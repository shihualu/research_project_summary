diff --git a/CHANGELOG.md b/CHANGELOG.md
index b99f00f4e3..0165564107 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,58 @@
 Change Log
 ==========
 
+## Version 3.5.0
+
+_2016-11-30_
+
+ *  **Web Sockets are now a stable feature of OkHttp.** Since being introduced as a beta feature in
+    OkHttp 2.3 our web socket client has matured. Connect to a server's web socket with
+    `OkHttpClient.newWebSocket()`, send messages with `send()`, and receive messages with the
+    `WebSocketListener`.
+
+    The `okhttp-ws` submodule is no longer available and `okhttp-ws` artifacts from previous
+    releases of OkHttp are not compatible with OkHttp 3.5. When upgrading to the new package
+    please note that the `WebSocket` and `WebSocketCall` classes have been merged. Sending messages
+    is now asynchronous and they may be enqueued before the web socket is connected.
+
+ *  **OkHttp no longer attempts a direct connection if the system's HTTP proxy fails.** This
+    behavior was surprising because OkHttp was disregarding the user's specified configuration. If
+    you need to customize proxy fallback behavior, implement your own `java.net.ProxySelector`.
+
+ *  Fix: Support TLSv1.3 on devices that support it.
+
+ *  Fix: Share pooled connections across equivalent `OkHttpClient` instances. Previous releases had
+    a bug where a shared connection pool did not guarantee shared connections in some cases.
+ *  Fix: Prefer the server's response body on all conditional cache misses. Previously we would
+    return the cached response's body if it had a newer `Last-Modified` date.
+ *  Fix: Update the stored timestamp on conditional cache hits.
+ *  New: Optimized HTTP/2 request header encoding. More headers are HPACK-encoded and string
+    literals are now Huffman-encoded.
+ *  New: Expose `Part` headers and body in `Multipart`.
+ *  New: Make `ResponseBody.string()` and `ResponseBody.charStream()` BOM-aware. If your HTTP
+    response body begins with a [byte order mark][bom] it will be consumed and used to select a
+    charset for the remaining bytes. Most applications should not not need a byte order mark.
+
+ *  New: Upgrade to Okio 1.11.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.11.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.11.0
+     ```
+
+ *  Fix: Avoid sending empty HTTP/2 data frames when there is no request body.
+ *  Fix: Add a leading `.` for better domain matching in `JavaNetCookieJar`.
+ *  Fix: Gracefully recover from HTTP/2 connection shutdowns at start of request.
+ *  Fix: Be lenient if a `MediaType`'s character set is `'single-quoted'`.
+ *  Fix: Allow horizontal tab characters in header values.
+ *  Fix: When parsing HTTP authentication headers permit challenge parameters in any order.
+
+
 ## Version 3.4.2
 
 _2016-11-03_
@@ -1146,3 +1198,4 @@ Initial release.
  [major_versions]: http://jakewharton.com/java-interoperability-policy-for-major-version-updates/
  [nginx_959]: https://trac.nginx.org/nginx/ticket/959
  [okhttp_idling_resource]: https://github.com/JakeWharton/okhttp-idling-resource
+ [bom]: https://en.wikipedia.org/wiki/Byte_order_mark
diff --git a/README.md b/README.md
index 5b70072b86..298b139f42 100644
--- a/README.md
+++ b/README.md
@@ -11,12 +11,12 @@ Download [the latest JAR][3] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>okhttp</artifactId>
-  <version>3.4.2</version>
+  <version>3.5.0</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.okhttp3:okhttp:3.4.2'
+compile 'com.squareup.okhttp3:okhttp:3.5.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -36,13 +36,13 @@ Download [the latest JAR][4] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>mockwebserver</artifactId>
-  <version>3.4.2</version>
+  <version>3.5.0</version>
   <scope>test</scope>
 </dependency>
 ```
 or Gradle:
 ```groovy
-testCompile 'com.squareup.okhttp3:mockwebserver:3.4.2'
+testCompile 'com.squareup.okhttp3:mockwebserver:3.5.0'
 ```
 
 
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index 0065b25634..e6067ec658 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
index 7c90e5e6b5..7fad22c79e 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
@@ -15,23 +15,19 @@
  */
 package okhttp3.benchmarks;
 
-import java.io.IOException;
-import java.util.concurrent.TimeUnit;
+import okhttp3.*;
+import okhttp3.internal.tls.SslClient;
+
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Call;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.ResponseBody;
-import okhttp3.internal.tls.SslClient;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
 
 class OkHttp extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
 
   private OkHttpClient client;
-
   @Override public void prepare(Benchmark benchmark) {
     super.prepare(benchmark);
     client = new OkHttpClient.Builder()
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 9f68096de5..12f9cf46a9 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
index 8452b84634..73691d4b54 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
@@ -19,9 +19,9 @@
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Headers;
+import okhttp3.WebSocketListener;
 import okhttp3.internal.Internal;
 import okhttp3.internal.http2.Settings;
-import okhttp3.WebSocketListener;
 import okio.Buffer;
 
 /** A scripted response to be replayed by the mock web server. */
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 329a5a7352..76ee2fbec0 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -41,9 +41,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Level;
@@ -82,7 +80,7 @@
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
 
-import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
@@ -347,13 +345,13 @@ private synchronized void start(InetSocketAddress inetSocketAddress) throws IOEx
         }
 
         // Release all sockets and all threads, even if any close fails.
-        Util.closeQuietly(serverSocket);
+        closeQuietly(serverSocket);
         for (Iterator<Socket> s = openClientSockets.iterator(); s.hasNext(); ) {
-          Util.closeQuietly(s.next());
+          closeQuietly(s.next());
           s.remove();
         }
         for (Iterator<Http2Connection> s = openConnections.iterator(); s.hasNext(); ) {
-          Util.closeQuietly(s.next());
+          closeQuietly(s.next());
           s.remove();
         }
         dispatcher.shutdown();
@@ -669,21 +667,17 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
         .protocol(Protocol.HTTP_1_1)
         .build();
 
-    String name = request.getPath();
-    ThreadPoolExecutor replyExecutor =
-        new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-            Util.threadFactory(Util.format("MockWebServer %s WebSocket Replier", name), true));
-    replyExecutor.allowCoreThreadTimeOut(true);
-
     final CountDownLatch connectionClose = new CountDownLatch(1);
-    RealWebSocket webSocket =
-        new RealWebSocket(false /* is server */, source, sink, new SecureRandom(), replyExecutor,
-            response.getWebSocketListener(), fancyResponse, name) {
-          @Override protected void shutdown() {
-            connectionClose.countDown();
-          }
-        };
-
+    RealWebSocket.Streams streams = new RealWebSocket.Streams(false, source, sink) {
+      @Override public void close() {
+        connectionClose.countDown();
+      }
+    };
+    RealWebSocket webSocket = new RealWebSocket(fancyRequest,
+        response.getWebSocketListener(), new SecureRandom());
+    response.getWebSocketListener().onOpen(webSocket, fancyResponse);
+    String name = "MockWebServer WebSocket " + request.getPath();
+    webSocket.initReaderAndWriter(name, 0, streams);
     webSocket.loopReader();
 
     // Even if messages are no longer being read we need to wait for the connection close signal.
@@ -692,9 +686,8 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
     } catch (InterruptedException ignored) {
     }
 
-    replyExecutor.shutdown();
-    Util.closeQuietly(sink);
-    Util.closeQuietly(source);
+    closeQuietly(sink);
+    closeQuietly(source);
   }
 
   private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse response)
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index edc86849cf..f2fccf897b 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index 1485393521..7ac8a4d245 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index ed13f59fb2..4c1de9241f 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
index 5f9d7862c8..bec052a7ae 100644
--- a/okhttp-logging-interceptor/pom.xml
+++ b/okhttp-logging-interceptor/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>logging-interceptor</artifactId>
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
index 18f83cc3b6..a7e166bb13 100644
--- a/okhttp-testing-support/pom.xml
+++ b/okhttp-testing-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-testing-support</artifactId>
diff --git a/okhttp-tests/fuzzingserver-config.json b/okhttp-tests/fuzzingserver-config.json
index 99e06abb51..f9a3e1f597 100644
--- a/okhttp-tests/fuzzingserver-config.json
+++ b/okhttp-tests/fuzzingserver-config.json
@@ -1,5 +1,5 @@
 {
-  "url": "ws://127.0.0.1:9001",
+  "url": "ws://127.0.0.1:9099",
   "outdir": "./target/fuzzingserver-report",
   "cases": ["*"],
   "exclude-cases": [
diff --git a/okhttp-tests/fuzzingserver-expected.txt b/okhttp-tests/fuzzingserver-expected.txt
index f4a3305f79..f0f6ed0bbd 100644
--- a/okhttp-tests/fuzzingserver-expected.txt
+++ b/okhttp-tests/fuzzingserver-expected.txt
@@ -257,7 +257,7 @@
 "4.2.1 OK"
 "4.2.2 OK"
 "4.2.3 NON-STRICT"
-"4.2.4 NON-STRICT"
+"4.2.4 OK"
 "4.2.5 OK"
 "5.1 OK"
 "5.10 OK"
@@ -265,7 +265,7 @@
 "5.12 OK"
 "5.13 OK"
 "5.14 OK"
-"5.15 NON-STRICT"
+"5.15 OK"
 "5.16 OK"
 "5.17 OK"
 "5.18 OK"
@@ -283,7 +283,7 @@
 "7.1.2 OK"
 "7.1.3 OK"
 "7.1.4 OK"
-"7.1.5 FAILED"
+"7.1.5 OK"
 "7.1.6 INFORMATIONAL"
 "7.13.1 INFORMATIONAL"
 "7.13.2 INFORMATIONAL"
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index 4b3a04ac78..215eb4c07d 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
diff --git a/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java b/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
index af9aed1499..ab7b9c771d 100644
--- a/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
+++ b/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
@@ -17,24 +17,18 @@
 
 import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 import okhttp3.internal.Version;
-import okio.BufferedSource;
 import okio.ByteString;
 
-import static okhttp3.WebSocket.BINARY;
-import static okhttp3.WebSocket.TEXT;
-
 /**
  * Exercises the web socket implementation against the <a
  * href="http://autobahn.ws/testsuite/">Autobahn Testsuite</a>.
  */
 public final class AutobahnTester {
-  private static final String HOST = "ws://localhost:9001";
+  private static final String HOST = "ws://localhost:9099";
 
   public static void main(String... args) throws IOException {
     new AutobahnTester().run();
@@ -42,9 +36,9 @@ public static void main(String... args) throws IOException {
 
   final OkHttpClient client = new OkHttpClient();
 
-  private WebSocketCall newWebSocket(String path) {
+  private WebSocket newWebSocket(String path, WebSocketListener listener) {
     Request request = new Request.Builder().url(HOST + path).build();
-    return client.newWebSocketCall(request);
+    return client.newWebSocket(request, listener);
   }
 
   public void run() throws IOException {
@@ -65,51 +59,30 @@ public void run() throws IOException {
   private void runTest(final long number, final long count) {
     final CountDownLatch latch = new CountDownLatch(1);
     final AtomicLong startNanos = new AtomicLong();
-    newWebSocket("/runCase?case=" + number + "&agent=okhttp") //
-        .enqueue(new WebSocketListener() {
-          private final ExecutorService sendExecutor = Executors.newSingleThreadExecutor();
-          private WebSocket webSocket;
-
-          @Override public void onOpen(WebSocket webSocket, Response response) {
-            this.webSocket = webSocket;
-
-            System.out.println("Executing test case " + number + "/" + count);
-            startNanos.set(System.nanoTime());
-          }
-
-          @Override public void onMessage(final ResponseBody message) throws IOException {
-            final RequestBody response;
-            if (message.contentType() == TEXT) {
-              response = RequestBody.create(TEXT, message.string());
-            } else {
-              BufferedSource source = message.source();
-              response = RequestBody.create(BINARY, source.readByteString());
-              source.close();
-            }
-            sendExecutor.execute(new Runnable() {
-              @Override public void run() {
-                try {
-                  webSocket.message(response);
-                } catch (IOException e) {
-                  e.printStackTrace(System.out);
-                }
-              }
-            });
-          }
-
-          @Override public void onPong(ByteString payload) {
-          }
-
-          @Override public void onClose(int code, String reason) {
-            sendExecutor.shutdown();
-            latch.countDown();
-          }
-
-          @Override public void onFailure(Throwable t, Response response) {
-            t.printStackTrace(System.out);
-            latch.countDown();
-          }
-        });
+    newWebSocket("/runCase?case=" + number + "&agent=okhttp", new WebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+        System.out.println("Executing test case " + number + "/" + count);
+        startNanos.set(System.nanoTime());
+      }
+
+      @Override public void onMessage(final WebSocket webSocket, final ByteString bytes) {
+        webSocket.send(bytes);
+      }
+
+      @Override public void onMessage(final WebSocket webSocket, final String text) {
+        webSocket.send(text);
+      }
+
+      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+        webSocket.close(1000, null);
+        latch.countDown();
+      }
+
+      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+        t.printStackTrace(System.out);
+        latch.countDown();
+      }
+    });
     try {
       if (!latch.await(30, TimeUnit.SECONDS)) {
         throw new IllegalStateException("Timed out waiting for test " + number + " to finish.");
@@ -127,23 +100,17 @@ private long getTestCount() throws IOException {
     final CountDownLatch latch = new CountDownLatch(1);
     final AtomicLong countRef = new AtomicLong();
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    newWebSocket("/getCaseCount").enqueue(new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-      }
-
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        countRef.set(message.source().readDecimalLong());
-        message.close();
+    newWebSocket("/getCaseCount", new WebSocketListener() {
+      @Override public void onMessage(WebSocket webSocket, String text) {
+        countRef.set(Long.parseLong(text));
       }
 
-      @Override public void onPong(ByteString payload) {
-      }
-
-      @Override public void onClose(int code, String reason) {
+      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+        webSocket.close(1000, null);
         latch.countDown();
       }
 
-      @Override public void onFailure(Throwable t, Response response) {
+      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
         failureRef.set(t);
         latch.countDown();
       }
@@ -164,21 +131,13 @@ private long getTestCount() throws IOException {
 
   private void updateReports() {
     final CountDownLatch latch = new CountDownLatch(1);
-    newWebSocket("/updateReports?agent=" + Version.userAgent()).enqueue(new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-      }
-
-      @Override public void onMessage(ResponseBody message) throws IOException {
-      }
-
-      @Override public void onPong(ByteString payload) {
-      }
-
-      @Override public void onClose(int code, String reason) {
+    newWebSocket("/updateReports?agent=" + Version.userAgent(), new WebSocketListener() {
+      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+        webSocket.close(1000, null);
         latch.countDown();
       }
 
-      @Override public void onFailure(Throwable t, Response response) {
+      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
         latch.countDown();
       }
     });
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
index 33f4952651..3d5eb7cfd8 100644
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -29,7 +29,6 @@
 
 import static java.util.Collections.singletonList;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
@@ -129,9 +128,9 @@
     HttpUrl baseWithPasswordAndUsername = HttpUrl.parse("http://username:password@host/a/b#fragment");
     HttpUrl baseWithUsernameOnly = HttpUrl.parse("http://username@host/a/b#fragment");
     HttpUrl baseWithPasswordOnly = HttpUrl.parse("http://password@host/a/b#fragment");
-    assertEquals(HttpUrl.parse("http://host/..."), baseWithPasswordAndUsername.redact());
-    assertEquals(HttpUrl.parse("http://host/..."), baseWithUsernameOnly.redact());
-    assertEquals(HttpUrl.parse("http://host/..."), baseWithPasswordOnly.redact());
+    assertEquals("http://host/...", baseWithPasswordAndUsername.redact());
+    assertEquals("http://host/...", baseWithUsernameOnly.redact());
+    assertEquals("http://host/...", baseWithPasswordOnly.redact());
   }
 
   @Test public void resolveNoScheme() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
index 3cf5d900c3..5c13119e46 100644
--- a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
@@ -42,11 +42,12 @@
     ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
   }
 
-  @Test public void timeoutDefaults() {
+  @Test public void durationDefaults() {
     OkHttpClient client = defaultClient();
     assertEquals(10_000, client.connectTimeoutMillis());
     assertEquals(10_000, client.readTimeoutMillis());
     assertEquals(10_000, client.writeTimeoutMillis());
+    assertEquals(0, client.pingIntervalMillis());
   }
 
   @Test public void timeoutValidRange() {
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
index beba4bd0d8..47feecacb6 100644
--- a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
@@ -58,7 +58,7 @@
   }
 
   @Test public void stringBomUtf8() throws IOException {
-    ResponseBody body = body("efbbff68656c6c6f");
+    ResponseBody body = body("efbbbf68656c6c6f");
     assertEquals("hello", body.string());
   }
 
@@ -128,7 +128,7 @@
   }
 
   @Test public void readerBomUtf8() throws IOException {
-    ResponseBody body = body("efbbff68656c6c6f");
+    ResponseBody body = body("efbbbf68656c6c6f");
     assertEquals("hello", exhaust(body.charStream()));
   }
 
@@ -212,11 +212,11 @@
   }
 
   @Test public void sourceSeesBom() throws IOException {
-    ResponseBody body = body("efbbff68656c6c6f");
+    ResponseBody body = body("efbbbf68656c6c6f");
     BufferedSource source = body.source();
     assertEquals(0xef, source.readByte() & 0xff);
     assertEquals(0xbb, source.readByte() & 0xff);
-    assertEquals(0xff, source.readByte() & 0xff);
+    assertEquals(0xbf, source.readByte() & 0xff);
     assertEquals("hello", source.readUtf8());
   }
 
@@ -251,11 +251,11 @@
   }
 
   @Test public void bytesSeesBom() throws IOException {
-    ResponseBody body = body("efbbff68656c6c6f");
+    ResponseBody body = body("efbbbf68656c6c6f");
     byte[] bytes = body.bytes();
     assertEquals(0xef, bytes[0] & 0xff);
     assertEquals(0xbb, bytes[1] & 0xff);
-    assertEquals(0xff, bytes[2] & 0xff);
+    assertEquals(0xbf, bytes[2] & 0xff);
     assertEquals("hello", new String(bytes, 3, 5, "UTF-8"));
   }
 
@@ -335,11 +335,11 @@
   }
 
   @Test public void byteStreamSeesBom() throws IOException {
-    ResponseBody body = body("efbbff68656c6c6f");
+    ResponseBody body = body("efbbbf68656c6c6f");
     InputStream bytes = body.byteStream();
     assertEquals(0xef, bytes.read());
     assertEquals(0xbb, bytes.read());
-    assertEquals(0xff, bytes.read());
+    assertEquals(0xbf, bytes.read());
     assertEquals("hello", exhaust(new InputStreamReader(bytes, "utf-8")));
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index d5d2a52e78..025a68a795 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -3581,7 +3581,6 @@ private void zeroLengthPayload(String method)
     assertEquals(0, dispatcher.runningCallsCount());
   }
 
-  @Ignore // TODO: recover gracefully when a connection is shutdown.
   @Test public void streamedBodyIsRetriedOnHttp2Shutdown() throws Exception {
     enableProtocol(Protocol.HTTP_2);
     server.enqueue(new MockResponse()
@@ -3599,6 +3598,9 @@ private void zeroLengthPayload(String method)
     HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     assertContent("abc", connection2);
 
+    // Ensure the GOAWAY frame has time to be read and processed.
+    Thread.sleep(500);
+
     OutputStream os = connection1.getOutputStream();
     os.write(new byte[] { '1', '2', '3' });
     os.close();
diff --git a/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java b/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java
deleted file mode 100644
index 261799a304..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java
+++ /dev/null
@@ -1,475 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Logger;
-import okhttp3.internal.tls.SslClient;
-import okhttp3.internal.ws.EmptyWebSocketListener;
-import okhttp3.internal.ws.RealWebSocket;
-import okhttp3.internal.ws.WebSocketRecorder;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okio.ByteString;
-import org.junit.After;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.WebSocket.BINARY;
-import static okhttp3.WebSocket.TEXT;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class WebSocketCallTest {
-  @Rule public final MockWebServer webServer = new MockWebServer();
-
-  private final SslClient sslClient = SslClient.localhost();
-  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
-  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
-  private final Random random = new Random(0);
-  private OkHttpClient client = defaultClient().newBuilder()
-      .addInterceptor(new Interceptor() {
-        @Override public Response intercept(Chain chain) throws IOException {
-          Response response = chain.proceed(chain.request());
-          assertNotNull(response.body()); // Ensure application interceptors never see a null body.
-          return response;
-        }
-      })
-      .build();
-
-  @After public void tearDown() {
-    clientListener.assertExhausted();
-  }
-
-  @Test public void textMessage() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-    serverListener.assertOpen();
-
-    client.message(RequestBody.create(TEXT, "Hello, WebSockets!"));
-    serverListener.assertTextMessage("Hello, WebSockets!");
-  }
-
-  @Test public void binaryMessage() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-    serverListener.assertOpen();
-
-    client.message(RequestBody.create(BINARY, "Hello!"));
-    serverListener.assertBinaryMessage(new byte[] {'H', 'e', 'l', 'l', 'o', '!'});
-  }
-
-  @Test public void nullMessageThrows() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-    try {
-      client.message(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertEquals("message == null", e.getMessage());
-    }
-  }
-
-  @Test public void missingContentTypeThrows() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-    try {
-      client.message(RequestBody.create(null, "Hey!"));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.",
-          e.getMessage());
-    }
-  }
-
-  @Test public void unknownContentTypeThrows() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-    try {
-      client.message(RequestBody.create(MediaType.parse("text/plain"), "Hey!"));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals(
-          "Unknown message content type: text/plain. Must use WebSocket.TEXT or WebSocket.BINARY.",
-          e.getMessage());
-    }
-  }
-
-  @Test public void pingPong() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-
-    client.ping(ByteString.encodeUtf8("Hello, WebSockets!"));
-    clientListener.assertPong(ByteString.encodeUtf8("Hello, WebSockets!"));
-  }
-
-  @Test public void nullPingPayloadThrows() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-    try {
-      client.ping(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertEquals("payload == null", e.getMessage());
-    }
-  }
-
-  @Test public void serverMessage() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    server.message(RequestBody.create(TEXT, "Hello, WebSockets!"));
-    clientListener.assertTextMessage("Hello, WebSockets!");
-  }
-
-  @Test public void writingOnReaderThreadThrows() throws IOException, InterruptedException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    Request request = new Request.Builder().get().url(webServer.url("/")).build();
-    RealWebSocketCall call = new RealWebSocketCall(client, request, random);
-
-    final AtomicInteger count = new AtomicInteger();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new WebSocketListener() {
-      private WebSocket webSocket;
-
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-        this.webSocket = webSocket;
-
-        try {
-          webSocket.close(1000, "");
-          fail();
-        } catch (IllegalStateException e) {
-          assertEquals("attempting to write from reader thread", e.getMessage());
-        } catch (IOException e) {
-          throw new AssertionError(e);
-        }
-
-        count.getAndIncrement();
-      }
-
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        try {
-          webSocket.message(RequestBody.create(TEXT, "hey"));
-          fail();
-        } catch (IllegalStateException e) {
-          assertEquals("attempting to write from reader thread", e.getMessage());
-        }
-
-        message.close();
-        count.getAndIncrement();
-      }
-
-      @Override public void onPong(ByteString payload) {
-        try {
-          webSocket.ping(ByteString.EMPTY);
-          fail();
-        } catch (IllegalStateException e) {
-          assertEquals("attempting to write from reader thread", e.getMessage());
-        } catch (IOException e) {
-          throw new AssertionError(e);
-        }
-
-        count.getAndIncrement();
-      }
-
-      @Override public void onClose(int code, String reason) {
-        latch.countDown();
-      }
-
-      @Override public void onFailure(Throwable t, Response response) {
-        t.printStackTrace();
-      }
-    });
-
-    WebSocket server = serverListener.assertOpen();
-    server.message(RequestBody.create(TEXT, "hi"));
-    ((RealWebSocket) server).pong(ByteString.EMPTY);
-    server.close(1000, "");
-
-    assertTrue(latch.await(10, SECONDS));
-    // Verify we hit all three callbacks and attempted to write in them.
-    assertEquals(3, count.get());
-  }
-
-  @Test public void throwingOnOpenClosesAndFails() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-        throw e;
-      }
-    });
-    enqueueClientWebSocket();
-
-    serverListener.assertOpen();
-    serverListener.assertClose(1001, "");
-    clientListener.assertFailure(e);
-  }
-
-  @Ignore("AsyncCall currently lets runtime exceptions propagate.")
-  @Test public void throwingOnFailLogs() throws InterruptedException {
-    TestLogHandler logs = new TestLogHandler();
-    Logger logger = Logger.getLogger(OkHttpClient.class.getName());
-    logger.addHandler(logs);
-
-    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onFailure(Throwable t, Response response) {
-        throw e;
-      }
-    });
-
-    enqueueClientWebSocket();
-
-    assertEquals("", logs.take());
-    logger.removeHandler(logs);
-  }
-
-  @Test public void throwingOnMessageClosesAndFails() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onMessage(ResponseBody message) {
-        throw e;
-      }
-    });
-
-    server.message(RequestBody.create(TEXT, "Hello, WebSockets!"));
-    clientListener.assertFailure(e);
-    serverListener.assertClose(1001, "");
-  }
-
-  @Test public void throwingOnOnPongClosesAndFails() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-    serverListener.assertOpen();
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onPong(ByteString payload) {
-        throw e;
-      }
-    });
-
-    client.ping(ByteString.EMPTY);
-    clientListener.assertFailure(e);
-    serverListener.assertClose(1001, "");
-  }
-
-  @Test public void throwingOnCloseClosesNormallyAndFails() throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onClose(int code, String reason) {
-        throw e;
-      }
-    });
-
-    server.close(1000, "bye");
-    clientListener.assertFailure(e);
-    serverListener.assertClose(1000, "bye");
-  }
-
-  @Test public void non101RetainsBody() throws IOException {
-    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
-    enqueueClientWebSocket();
-
-    clientListener.assertFailure(200, "Body", ProtocolException.class,
-        "Expected HTTP 101 response but was '200 OK'");
-  }
-
-  @Test public void notFound() throws IOException {
-    webServer.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
-    enqueueClientWebSocket();
-
-    clientListener.assertFailure(404, null, ProtocolException.class,
-        "Expected HTTP 101 response but was '404 Not Found'");
-  }
-
-  @Test public void clientTimeoutClosesBody() throws IOException {
-    webServer.enqueue(new MockResponse().setResponseCode(408));
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    enqueueClientWebSocket();
-
-    WebSocket client = clientListener.assertOpen();
-
-    client.ping(ByteString.encodeUtf8("WebSockets are fun!"));
-    clientListener.assertPong(ByteString.encodeUtf8("WebSockets are fun!"));
-  }
-
-  @Test public void missingConnectionHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    enqueueClientWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Connection' header value 'Upgrade' but was 'null'");
-  }
-
-  @Test public void wrongConnectionHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Connection", "Downgrade")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    enqueueClientWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Connection' header value 'Upgrade' but was 'Downgrade'");
-  }
-
-  @Test public void missingUpgradeHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    enqueueClientWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Upgrade' header value 'websocket' but was 'null'");
-  }
-
-  @Test public void wrongUpgradeHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "Pepsi")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    enqueueClientWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Upgrade' header value 'websocket' but was 'Pepsi'");
-  }
-
-  @Test public void missingMagicHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "websocket"));
-    enqueueClientWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'null'");
-  }
-
-  @Test public void wrongMagicHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", "magic"));
-    enqueueClientWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
-  }
-
-  @Test public void wsScheme() throws IOException {
-    websocketScheme("ws");
-  }
-
-  @Test public void wsUppercaseScheme() throws IOException {
-    websocketScheme("WS");
-  }
-
-  @Test public void wssScheme() throws IOException {
-    webServer.useHttps(sslClient.socketFactory, false);
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    websocketScheme("wss");
-  }
-
-  @Test public void httpsScheme() throws IOException {
-    webServer.useHttps(sslClient.socketFactory, false);
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    websocketScheme("https");
-  }
-
-  private void websocketScheme(String scheme) throws IOException {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    Request request = new Request.Builder()
-        .url(scheme + "://" + webServer.getHostName() + ":" + webServer.getPort() + "/")
-        .build();
-
-    enqueueClientWebSocket(request);
-    WebSocket webSocket = clientListener.assertOpen();
-    serverListener.assertOpen();
-
-    webSocket.message(RequestBody.create(TEXT, "abc"));
-    serverListener.assertTextMessage("abc");
-  }
-
-  private void enqueueClientWebSocket() {
-    enqueueClientWebSocket(new Request.Builder().get().url(webServer.url("/")).build());
-  }
-
-  private void enqueueClientWebSocket(Request request) {
-    WebSocketCall call = new RealWebSocketCall(client, request, random);
-    call.enqueue(clientListener);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
index d4ae88b84a..c5caeba49a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
@@ -15,16 +15,6 @@
  */
 package okhttp3.internal.cache;
 
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Deque;
-import java.util.Iterator;
-import java.util.List;
-import java.util.NoSuchElementException;
-import java.util.concurrent.Executor;
 import okhttp3.internal.io.FaultyFileSystem;
 import okhttp3.internal.io.FileSystem;
 import okio.BufferedSink;
@@ -38,16 +28,13 @@
 import org.junit.rules.TemporaryFolder;
 import org.junit.rules.Timeout;
 
-import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE;
-import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE_BACKUP;
-import static okhttp3.internal.cache.DiskLruCache.MAGIC;
-import static okhttp3.internal.cache.DiskLruCache.VERSION_1;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
+import java.io.File;
+import java.io.IOException;
+import java.util.*;
+import java.util.concurrent.Executor;
+
+import static okhttp3.internal.cache.DiskLruCache.*;
+import static org.junit.Assert.*;
 
 public final class DiskLruCacheTest {
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
@@ -93,6 +80,13 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertJournalEquals();
   }
 
+  @Test public void emptyCache1() throws Exception {
+    //DiskLruCache newCache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE-1, executor);
+    createNewCacheWithSize(Integer.MAX_VALUE-1);
+
+    assertJournalEquals();
+  }
+
   @Test public void validateKey() throws Exception {
     String key = null;
     try {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index 610e0898ec..a782691f7d 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -245,8 +245,7 @@
     try {
       connection.newStream(headerEntries("c", "cola"), true);
       fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
+    } catch (ConnectionShutdownException expected) {
     }
     assertTrue(stream1.isOpen());
     assertFalse(stream2.isOpen());
@@ -1009,8 +1008,7 @@
     try {
       connection.newStream(headerEntries("c", "cola"), false);
       fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
+    } catch (ConnectionShutdownException expected) {
     }
     assertTrue(stream1.isOpen());
     assertFalse(stream2.isOpen());
@@ -1068,8 +1066,7 @@
     try {
       connection.ping();
       fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
+    } catch (ConnectionShutdownException expected) {
     }
 
     // verify the peer received what was expected
@@ -1094,8 +1091,7 @@
     try {
       connection.newStream(headerEntries("b", "banana"), false);
       fail();
-    } catch (IOException expected) {
-      assertEquals("shutdown", expected.getMessage());
+    } catch (ConnectionShutdownException expected) {
     }
     BufferedSink sink = Okio.buffer(stream.getSink());
     try {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 719a3b28b8..73549d78ce 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -20,6 +20,7 @@
 import okhttp3.internal.RecordingOkAuthenticator;
 import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.Util;
+import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.*;
 import okio.Buffer;
@@ -846,6 +847,9 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
                   .build());
               Response response = call.execute();
               assertEquals("ABC", response.body().string());
+              // Wait until the GOAWAY has been processed.
+              RealConnection connection = (RealConnection) chain.connection();
+              while (connection.isHealthy(false)) ;
             }
             return chain.proceed(chain.request());
           }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/EmptyWebSocketListener.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/EmptyWebSocketListener.java
deleted file mode 100644
index f3ba32e464..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/EmptyWebSocketListener.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.IOException;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.WebSocket;
-import okhttp3.WebSocketListener;
-import okio.ByteString;
-
-public class EmptyWebSocketListener implements WebSocketListener {
-  @Override public void onOpen(WebSocket webSocket, Response response) {
-  }
-
-  @Override public void onMessage(ResponseBody message) throws IOException {
-  }
-
-  @Override public void onPong(ByteString payload) {
-  }
-
-  @Override public void onClose(int code, String reason) {
-  }
-
-  @Override public void onFailure(Throwable t, Response response) {
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
deleted file mode 100644
index 97e594b790..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ /dev/null
@@ -1,494 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import okhttp3.*;
-import okio.*;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.concurrent.Executor;
-
-import static okhttp3.WebSocket.TEXT;
-import static org.junit.Assert.*;
-
-public final class RealWebSocketTest {
-  // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
-  // zero effect on the behavior of the WebSocket API which is why tests are only written once
-  // from the perspective of a single peer.
-
-  private final Executor clientExecutor = new SynchronousExecutor();
-  private RealWebSocket client;
-  private boolean clientConnectionCloseThrows;
-  private boolean clientConnectionClosed;
-  private final MemorySocket client2Server = new MemorySocket();
-  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
-
-  private final Executor serverExecutor = new SynchronousExecutor();
-  private RealWebSocket server;
-  private boolean serverConnectionClosed;
-  private final MemorySocket server2client = new MemorySocket();
-  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
-
-  @Before public void setUp() {
-    Random random = new Random(0);
-    String url = "http://example.com/websocket";
-    Response response = new Response.Builder()
-        .code(101)
-        .request(new Request.Builder().url(url).build())
-        .protocol(Protocol.HTTP_1_1)
-        .build();
-
-    client = new RealWebSocket(true, server2client.source(), client2Server.sink(), random,
-        clientExecutor, clientListener, response, url) {
-      @Override protected void shutdown() {
-        if (clientConnectionClosed) {
-          throw new AssertionError("Already closed");
-        }
-        clientConnectionClosed = true;
-
-        if (clientConnectionCloseThrows) {
-          throw new RuntimeException("Oops!");
-        }
-      }
-    };
-    server = new RealWebSocket(false, client2Server.source(), server2client.sink(), random,
-        serverExecutor, serverListener, response, url) {
-      @Override protected void shutdown() {
-        if (serverConnectionClosed) {
-          throw new AssertionError("Already closed");
-        }
-        serverConnectionClosed = true;
-      }
-    };
-  }
-
-  @After public void tearDown() {
-    clientListener.assertExhausted();
-    serverListener.assertExhausted();
-  }
-
-  @Test public void streamingMessage() throws IOException {
-    RequestBody message = new RequestBody() {
-      @Override public MediaType contentType() {
-        return TEXT;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("Hel").flush();
-        sink.writeUtf8("lo!").flush();
-        sink.close();
-      }
-    };
-    client.message(message);
-    server.processNextFrame();
-    serverListener.assertTextMessage("Hello!");
-  }
-
-  @Test public void streamingMessageCanInterleavePing() throws IOException {
-    RequestBody message = new RequestBody() {
-      @Override public MediaType contentType() {
-        return TEXT;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("Hel").flush();
-        client.ping(ByteString.encodeUtf8("Pong?"));
-        sink.writeUtf8("lo!").flush();
-        sink.close();
-      }
-    };
-
-    client.message(message);
-    server.processNextFrame();
-    serverListener.assertTextMessage("Hello!");
-    client.processNextFrame();
-    clientListener.assertPong(ByteString.encodeUtf8("Pong?"));
-  }
-
-  @Test public void pingWritesPong() throws IOException {
-    client.ping(ByteString.encodeUtf8("Hello!"));
-    server.processNextFrame(); // Read the ping, write the pong.
-    client.processNextFrame(); // Read the pong.
-    clientListener.assertPong(ByteString.encodeUtf8("Hello!"));
-  }
-
-
- @Test public void pingPongreply() throws IOException {
-    client.ping(ByteString.encodeUtf8("Hey!"));
-    server.onReadPing(ByteString.encodeUtf8("Hey! Again"));
-    client.onReadPong(ByteString.encodeUtf8("Cool!"));
-    clientListener.assertPong(ByteString.encodeUtf8("Cool!"));
-  }
-
-  @Test public void unsolicitedPong() throws IOException {
-    client.pong(ByteString.encodeUtf8("Hello!"));
-    server.processNextFrame();
-    serverListener.assertPong(ByteString.encodeUtf8("Hello!"));
-  }
-
-  @Test public void nullPongPayloadThrows() throws IOException {
-    try {
-      client.pong(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertEquals("payload == null", e.getMessage());
-    }
-  }
-
-  @Test public void close() throws IOException {
-    client.close(1000, "Hello!");
-    assertFalse(server.processNextFrame()); // This will trigger a close response.
-    serverListener.assertClose(1000, "Hello!");
-    assertFalse(client.processNextFrame());
-    clientListener.assertClose(1000, "Hello!");
-  }
-
-  @Test public void clientCloseThenMethodsThrow() throws IOException {
-    client.close(1000, "Hello!");
-
-    try {
-      client.ping(ByteString.encodeUtf8("Pong?"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.close(1000, "Hello!");
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-    try {
-      client.message(RequestBody.create(TEXT, "Hello!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("closed", e.getMessage());
-    }
-  }
-
-  @Test public void socketClosedDuringPingKillsWebSocket() throws IOException {
-    client2Server.close();
-
-    try {
-      client.ping(ByteString.encodeUtf8("Ping!"));
-      fail();
-    } catch (IOException ignored) {
-    }
-
-    // A failed write prevents further use of the WebSocket instance.
-    try {
-      client.message(RequestBody.create(TEXT, "Hello!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("must call close()", e.getMessage());
-    }
-    try {
-      client.ping(ByteString.encodeUtf8("Ping!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("must call close()", e.getMessage());
-    }
-  }
-
-  @Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {
-    client2Server.close();
-
-    try {
-      client.message(RequestBody.create(TEXT, "Hello!"));
-      fail();
-    } catch (IOException ignored) {
-    }
-
-    // A failed write prevents further use of the WebSocket instance.
-    try {
-      client.message(RequestBody.create(TEXT, "Hello!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("must call close()", e.getMessage());
-    }
-    try {
-      client.ping(ByteString.encodeUtf8("Ping!"));
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("must call close()", e.getMessage());
-    }
-  }
-
-  @Test public void serverCloseThenWritingPingThrows() throws IOException {
-    server.close(1000, "Hello!");
-    client.processNextFrame();
-    clientListener.assertClose(1000, "Hello!");
-
-    try {
-      client.ping(ByteString.encodeUtf8("Pong?"));
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-  }
-
-  @Test public void serverCloseThenWritingMessageThrows() throws IOException {
-    server.close(1000, "Hello!");
-    client.processNextFrame();
-    clientListener.assertClose(1000, "Hello!");
-
-    try {
-      client.message(RequestBody.create(TEXT, "Hi!"));
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-  }
-
-  @Test public void serverCloseThenWritingCloseThrows() throws IOException {
-    server.close(1000, "Hello!");
-    client.processNextFrame();
-    clientListener.assertClose(1000, "Hello!");
-
-    try {
-      client.close(1000, "Bye!");
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-  }
-
-  @Test public void serverCloseWhileWritingThrows() throws IOException {
-    RequestBody message = new RequestBody() {
-      @Override public MediaType contentType() {
-        return TEXT;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        // Start writing data.
-        sink.writeUtf8("Hel").flush();
-
-        server.close(1000, "Hello!");
-        client.processNextFrame();
-        clientListener.assertClose(1000, "Hello!");
-
-        try {
-          sink.flush(); // No flushing.
-          fail();
-        } catch (IOException e) {
-          assertEquals("closed", e.getMessage());
-        }
-        try {
-          sink.close(); // No closing because this requires writing a frame.
-          fail();
-        } catch (IOException e) {
-          assertEquals("closed", e.getMessage());
-        }
-      }
-    };
-    client.message(message);
-  }
-
-  @Test public void clientCloseClosesConnection() throws IOException {
-    client.close(1000, "Hello!");
-    assertFalse(clientConnectionClosed);
-    server.processNextFrame(); // Read client close, send server close.
-    serverListener.assertClose(1000, "Hello!");
-
-    client.processNextFrame(); // Read server close, close connection.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClose(1000, "Hello!");
-  }
-
-  @Test public void serverCloseClosesConnection() throws IOException {
-    server.close(1000, "Hello!");
-
-    client.processNextFrame(); // Read server close, send client close, close connection.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClose(1000, "Hello!");
-
-    server.processNextFrame();
-    serverListener.assertClose(1000, "Hello!");
-  }
-
-  @Test public void clientAndServerCloseClosesConnection() throws IOException {
-    // Send close from both sides at the same time.
-    server.close(1000, "Hello!");
-    client.close(1000, "Hi!");
-    assertFalse(clientConnectionClosed);
-
-    client.processNextFrame(); // Read close, close connection close.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClose(1000, "Hello!");
-
-    server.processNextFrame();
-    serverListener.assertClose(1000, "Hi!");
-
-    serverListener.assertExhausted(); // Client should not have sent second close.
-    clientListener.assertExhausted(); // Server should not have sent second close.
-  }
-
-  @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
-    server.message(RequestBody.create(TEXT, "Hello!"));
-    server.close(1000, "Bye!");
-    assertTrue(client.processNextFrame());
-    clientListener.assertTextMessage("Hello!");
-    assertFalse(client.processNextFrame());
-    clientListener.assertClose(1000, "Bye!");
-  }
-
-  @Test public void protocolErrorBeforeCloseSendsClose() {
-    server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
-
-    client.processNextFrame(); // Detects error, send close, close connection.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
-
-    server.processNextFrame();
-    serverListener.assertClose(1002, "");
-  }
-
-  @Test public void protocolErrorInCloseResponseClosesConnection() throws IOException {
-    client.close(1000, "Hello");
-    assertFalse(clientConnectionClosed); // Not closed until close reply is received.
-
-    // Manually write an invalid masked close frame.
-    server2client.raw().write(ByteString.decodeHex("888760b420bb635c68de0cd84f"));
-
-    client.processNextFrame(); // Detects error, closes connection immediately since close already sent.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertFailure(ProtocolException.class, "Server-sent frames must not be masked.");
-
-    server.processNextFrame();
-    serverListener.assertClose(1000, "Hello");
-
-    serverListener.assertExhausted(); // Client should not have sent second close.
-  }
-
-  @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
-    client.close(1000, "Hello!");
-    assertFalse(clientConnectionClosed); // Not closed until close reply is received.
-    server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
-
-    client.processNextFrame(); // Detects error, closes connection immediately since close already sent.
-    assertTrue(clientConnectionClosed);
-    clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
-
-    server.processNextFrame();
-    serverListener.assertClose(1000, "Hello!");
-
-    serverListener.assertExhausted(); // Client should not have sent second close.
-  }
-
-  @Test public void networkErrorReportedAsCloseNotFailure() {
-    server2client.close();
-    client.processNextFrame();
-    clientListener.assertClose(1006, "");
-  }
-
-  @Test public void closeThrowingClosesConnection() {
-    client2Server.close();
-
-    try {
-      client.close(1000, null);
-      fail();
-    } catch (IOException ignored) {
-    }
-    assertTrue(clientConnectionClosed);
-  }
-
-  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() {
-    client2Server.close();
-    clientConnectionCloseThrows = true;
-
-    try {
-      client.close(1000, "Bye!");
-      fail();
-    } catch (IOException e) {
-      assertNotEquals("Oops!", e.getMessage());
-    }
-    assertTrue(clientConnectionClosed);
-  }
-
-  @Test public void peerConnectionCloseThrowingDoesNotPropagate() throws IOException {
-    clientConnectionCloseThrows = true;
-
-    server.close(1000, "Bye!");
-    client.processNextFrame();
-    assertTrue(clientConnectionClosed);
-    clientListener.assertClose(1000, "Bye!");
-
-    server.processNextFrame();
-    serverListener.assertClose(1000, "Bye!");
-  }
-
-  static final class MemorySocket implements Closeable {
-    private final Buffer buffer = new Buffer();
-    private boolean closed;
-
-    @Override public void close() {
-      closed = true;
-    }
-
-    Buffer raw() {
-      return buffer;
-    }
-
-    BufferedSource source() {
-      return Okio.buffer(new Source() {
-        @Override public long read(Buffer sink, long byteCount) throws IOException {
-          if (closed) throw new IOException("closed");
-          return buffer.read(sink, byteCount);
-        }
-
-        @Override public Timeout timeout() {
-          return Timeout.NONE;
-        }
-
-        @Override public void close() {
-          closed = true;
-        }
-      });
-    }
-
-    BufferedSink sink() {
-      return Okio.buffer(new Sink() {
-        @Override public void write(Buffer source, long byteCount) throws IOException {
-          if (closed) throw new IOException("closed");
-          buffer.write(source, byteCount);
-        }
-
-        @Override public void flush() {
-        }
-
-        @Override public Timeout timeout() {
-          return Timeout.NONE;
-        }
-
-        @Override public void close() {
-          closed = true;
-        }
-      });
-    }
-  }
-
-  static final class SynchronousExecutor implements Executor {
-    @Override public void execute(Runnable command) {
-      command.run();
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
new file mode 100644
index 0000000000..eaff205fd8
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
@@ -0,0 +1,608 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.net.SocketTimeoutException;
+import java.util.Random;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.logging.Logger;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.TestLogHandler;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.mockwebserver.Dispatcher;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.After;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.TestUtil.repeat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class WebSocketHttpTest {
+  @Rule public final MockWebServer webServer = new MockWebServer();
+
+  private final SslClient sslClient = SslClient.localhost();
+  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
+  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
+  private final Random random = new Random(0);
+  private OkHttpClient client = defaultClient().newBuilder()
+      .writeTimeout(500, TimeUnit.MILLISECONDS)
+      .readTimeout(500, TimeUnit.MILLISECONDS)
+      .addInterceptor(new Interceptor() {
+        @Override public Response intercept(Chain chain) throws IOException {
+          Response response = chain.proceed(chain.request());
+          assertNotNull(response.body()); // Ensure application interceptors never see a null body.
+          return response;
+        }
+      })
+      .build();
+
+  @After public void tearDown() {
+    clientListener.assertExhausted();
+  }
+
+  @Test public void textMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    webSocket.send("Hello, WebSockets!");
+    serverListener.assertTextMessage("Hello, WebSockets!");
+  }
+
+  @Test public void binaryMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    webSocket.send(ByteString.encodeUtf8("Hello!"));
+    serverListener.assertBinaryMessage(ByteString.of(new byte[] {'H', 'e', 'l', 'l', 'o', '!'}));
+  }
+
+  @Test public void nullStringThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    try {
+      webSocket.send((String) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertEquals("text == null", e.getMessage());
+    }
+  }
+
+  @Test public void nullByteStringThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    try {
+      webSocket.send((ByteString) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertEquals("bytes == null", e.getMessage());
+    }
+  }
+
+  @Test public void serverMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    server.send("Hello, WebSockets!");
+    clientListener.assertTextMessage("Hello, WebSockets!");
+  }
+
+  @Test public void throwingOnOpenFailsImmediately() {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new WebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+        throw e;
+      }
+    });
+    newWebSocket();
+
+    serverListener.assertOpen();
+    serverListener.assertExhausted();
+    clientListener.assertFailure(e);
+  }
+
+  @Ignore("AsyncCall currently lets runtime exceptions propagate.")
+  @Test public void throwingOnFailLogs() throws InterruptedException {
+    TestLogHandler logs = new TestLogHandler();
+    Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+    logger.addHandler(logs);
+
+    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new WebSocketListener() {
+      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+        throw e;
+      }
+    });
+
+    newWebSocket();
+
+    assertEquals("", logs.take());
+    logger.removeHandler(logs);
+  }
+
+  @Test public void throwingOnMessageClosesImmediatelyAndFails() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new WebSocketListener() {
+      @Override public void onMessage(WebSocket webSocket, String text) {
+        throw e;
+      }
+    });
+
+    server.send("Hello, WebSockets!");
+    clientListener.assertFailure(e);
+    serverListener.assertExhausted();
+  }
+
+  @Test public void throwingOnClosingClosesImmediatelyAndFails() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new WebSocketListener() {
+      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+        throw e;
+      }
+    });
+
+    server.close(1000, "bye");
+    clientListener.assertFailure(e);
+    serverListener.assertExhausted();
+  }
+
+  @Test public void non101RetainsBody() throws IOException {
+    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
+    newWebSocket();
+
+    clientListener.assertFailure(200, "Body", ProtocolException.class,
+        "Expected HTTP 101 response but was '200 OK'");
+  }
+
+  @Test public void notFound() throws IOException {
+    webServer.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
+    newWebSocket();
+
+    clientListener.assertFailure(404, null, ProtocolException.class,
+        "Expected HTTP 101 response but was '404 Not Found'");
+  }
+
+  @Test public void clientTimeoutClosesBody() throws IOException {
+    webServer.enqueue(new MockResponse().setResponseCode(408));
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    webSocket.send("abc");
+    serverListener.assertTextMessage("abc");
+
+    server.send("def");
+    clientListener.assertTextMessage("def");
+  }
+
+  @Test public void missingConnectionHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Connection' header value 'Upgrade' but was 'null'");
+  }
+
+  @Test public void wrongConnectionHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Connection", "Downgrade")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Connection' header value 'Upgrade' but was 'Downgrade'");
+  }
+
+  @Test public void missingUpgradeHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Upgrade' header value 'websocket' but was 'null'");
+  }
+
+  @Test public void wrongUpgradeHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "Pepsi")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Upgrade' header value 'websocket' but was 'Pepsi'");
+  }
+
+  @Test public void missingMagicHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "websocket"));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'null'");
+  }
+
+  @Test public void wrongMagicHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Sec-WebSocket-Accept", "magic"));
+    newWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
+  }
+
+  @Test public void webSocketAndApplicationInterceptors() throws IOException {
+    final AtomicInteger interceptedCount = new AtomicInteger();
+
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            assertNull(chain.request().body());
+            Response response = chain.proceed(chain.request());
+            assertEquals("Upgrade", response.header("Connection"));
+            assertTrue("", response.body().source().exhausted());
+            interceptedCount.incrementAndGet();
+            return response;
+          }
+        }).build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+    assertEquals(1, interceptedCount.get());
+    webSocket.close(1000, null);
+
+    WebSocket server = serverListener.assertOpen();
+    server.close(1000, null);
+  }
+
+  @Test public void webSocketAndNetworkInterceptors() throws IOException {
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            throw new AssertionError(); // Network interceptors don't execute.
+          }
+        }).build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+    webSocket.close(1000, null);
+
+    WebSocket server = serverListener.assertOpen();
+    server.close(1000, null);
+  }
+
+  @Test public void overflowOutgoingQueue() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+
+    // Send messages until the client's outgoing buffer overflows!
+    ByteString message = ByteString.of(new byte[1024 * 1024]);
+    int messageCount = 0;
+    while (true) {
+      boolean success = webSocket.send(message);
+      if (!success) break;
+
+      messageCount++;
+      long queueSize = webSocket.queueSize();
+      assertTrue(queueSize >= 0 && queueSize <= messageCount * message.size());
+      assertTrue(messageCount < 32); // Expect to fail before enqueueing 32 MiB.
+    }
+
+    // Confirm all sent messages were received, followed by a client-initiated close.
+    WebSocket server = serverListener.assertOpen();
+    for (int i = 0; i < messageCount; i++) {
+      serverListener.assertBinaryMessage(message);
+    }
+    serverListener.assertClosing(1001, "");
+
+    // When the server acknowledges the close the connection shuts down gracefully.
+    server.close(1000, null);
+    clientListener.assertClosing(1000, "");
+    clientListener.assertClosed(1000, "");
+    serverListener.assertClosed(1001, "");
+  }
+
+  @Test public void closeReasonMaximumLength() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    String clientReason = repeat('C', 123);
+    String serverReason = repeat('S', 123);
+
+    WebSocket webSocket = newWebSocket();
+    WebSocket server = serverListener.assertOpen();
+
+    clientListener.assertOpen();
+    webSocket.close(1000, clientReason);
+    serverListener.assertClosing(1000, clientReason);
+
+    server.close(1000, serverReason);
+    clientListener.assertClosing(1000, serverReason);
+    clientListener.assertClosed(1000, serverReason);
+
+    serverListener.assertClosed(1000, clientReason);
+  }
+
+  @Test public void closeReasonTooLong() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    WebSocket webSocket = newWebSocket();
+    WebSocket server = serverListener.assertOpen();
+
+    clientListener.assertOpen();
+    String reason = repeat('X', 124);
+    try {
+      webSocket.close(1000, reason);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("reason.size() > 123: " + reason, expected.getMessage());
+    }
+
+    webSocket.close(1000, null);
+    serverListener.assertClosing(1000, "");
+
+    server.close(1000, null);
+    clientListener.assertClosing(1000, "");
+    clientListener.assertClosed(1000, "");
+
+    serverListener.assertClosed(1000, "");
+  }
+
+  @Test public void wsScheme() throws IOException {
+    websocketScheme("ws");
+  }
+
+  @Test public void wsUppercaseScheme() throws IOException {
+    websocketScheme("WS");
+  }
+
+  @Test public void wssScheme() throws IOException {
+    webServer.useHttps(sslClient.socketFactory, false);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    websocketScheme("wss");
+  }
+
+  @Test public void httpsScheme() throws IOException {
+    webServer.useHttps(sslClient.socketFactory, false);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    websocketScheme("https");
+  }
+
+  @Test public void readTimeoutAppliesToHttpRequest() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
+
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertFailure(SocketTimeoutException.class, "timeout");
+    assertFalse(webSocket.close(1000, null));
+  }
+
+  /**
+   * There's no read timeout when reading the first byte of a new frame. But as soon as we start
+   * reading a frame we enable the read timeout. In this test we have the server returning the first
+   * byte of a frame but no more frames.
+   */
+  @Test public void readTimeoutAppliesWithinFrames() throws IOException {
+    webServer.setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        return upgradeResponse(request)
+            .setBody(new Buffer().write(ByteString.decodeHex("81"))) // Truncated frame.
+            .removeHeader("Content-Length")
+            .setSocketPolicy(SocketPolicy.KEEP_OPEN);
+      }
+    });
+
+    WebSocket webSocket = newWebSocket();
+    clientListener.assertOpen();
+
+    clientListener.assertFailure(SocketTimeoutException.class, "timeout");
+    assertFalse(webSocket.close(1000, null));
+  }
+
+  @Test public void readTimeoutDoesNotApplyAcrossFrames() throws Exception {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    // Sleep longer than the HTTP client's read timeout.
+    Thread.sleep(client.readTimeoutMillis() + 500);
+
+    server.send("abc");
+    clientListener.assertTextMessage("abc");
+  }
+
+  @Test public void clientPingsServerOnInterval() throws Exception {
+    client = client.newBuilder()
+        .pingInterval(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    RealWebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
+
+    long startNanos = System.nanoTime();
+    while (webSocket.pongCount() < 3) {
+      Thread.sleep(50);
+    }
+
+    long elapsedUntilPong3 = System.nanoTime() - startNanos;
+    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3), 250d);
+
+    // The client pinged the server 3 times, and it has ponged back 3 times.
+    assertEquals(3, server.pingCount());
+    assertEquals(3, webSocket.pongCount());
+
+    // The server has never pinged the client.
+    assertEquals(0, server.pongCount());
+    assertEquals(0, webSocket.pingCount());
+  }
+
+  @Test public void clientDoesNotPingServerByDefault() throws Exception {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    RealWebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
+
+    Thread.sleep(1000);
+
+    // No pings and no pongs.
+    assertEquals(0, server.pingCount());
+    assertEquals(0, webSocket.pongCount());
+    assertEquals(0, server.pongCount());
+    assertEquals(0, webSocket.pingCount());
+  }
+
+  /** https://github.com/square/okhttp/issues/2788 */
+  @Test public void clientCancelsIfCloseIsNotAcknowledged() throws Exception {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    RealWebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    // Initiate a close on the client, which will schedule a hard cancel in 500 ms.
+    long closeAtNanos = System.nanoTime();
+    webSocket.close(1000, "goodbye", 500);
+    serverListener.assertClosing(1000, "goodbye");
+
+    // Confirm that the hard cancel occurred after 500 ms.
+    clientListener.assertFailure();
+    long elapsedUntilFailure = System.nanoTime() - closeAtNanos;
+    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+
+    // Close the server and confirm it saw what we expected.
+    server.close(1000, null);
+    serverListener.assertClosed(1000, "goodbye");
+  }
+
+  private MockResponse upgradeResponse(RecordedRequest request) {
+    String key = request.getHeader("Sec-WebSocket-Key");
+    return new MockResponse()
+        .setStatus("HTTP/1.1 101 Switching Protocols")
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Sec-WebSocket-Accept", WebSocketProtocol.acceptHeader(key));
+  }
+
+  private void websocketScheme(String scheme) throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    Request request = new Request.Builder()
+        .url(scheme + "://" + webServer.getHostName() + ":" + webServer.getPort() + "/")
+        .build();
+
+    RealWebSocket webSocket = newWebSocket(request);
+    clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    webSocket.send("abc");
+    serverListener.assertTextMessage("abc");
+  }
+
+  private RealWebSocket newWebSocket() {
+    return newWebSocket(new Request.Builder().get().url(webServer.url("/")).build());
+  }
+
+  private RealWebSocket newWebSocket(Request request) {
+    RealWebSocket webSocket = new RealWebSocket(request, clientListener, random);
+    webSocket.connect(client);
+    return webSocket;
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index f1ae34e51f..21cf06df5d 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -19,18 +19,14 @@
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
-import java.util.concurrent.atomic.AtomicReference;
 import java.util.regex.Pattern;
-import okhttp3.ResponseBody;
 import okhttp3.internal.Util;
 import okio.Buffer;
-import okio.BufferedSource;
 import okio.ByteString;
 import org.junit.After;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -149,20 +145,11 @@
 
   @Test public void serverHelloTwoChunks() throws IOException {
     data.write(ByteString.decodeHex("818537fa213d7f9f4d")); // Hel
+    data.write(ByteString.decodeHex("5158")); // lo
 
-    final Buffer sink = new Buffer();
-    callback.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        BufferedSource source = message.source();
-        source.readFully(sink, 3); // Read "Hel"
-        data.write(ByteString.decodeHex("5158")); // lo
-        source.readFully(sink, 2); // Read "lo"
-        source.close();
-      }
-    });
     serverReader.processNextFrame();
 
-    assertEquals("Hello", sink.readUtf8());
+    callback.assertTextMessage("Hello");
   }
 
   @Test public void clientTwoFrameHello() throws IOException {
@@ -227,7 +214,7 @@
     byte[] bytes = binaryData(256);
     data.write(ByteString.decodeHex("827E0100")).write(bytes);
     clientReader.processNextFrame();
-    callback.assertBinaryMessage(bytes);
+    callback.assertBinaryMessage(ByteString.of(bytes));
   }
 
   @Test public void clientTwoFrameBinary() throws IOException {
@@ -235,7 +222,7 @@
     data.write(ByteString.decodeHex("0264")).write(bytes, 0, 100);
     data.write(ByteString.decodeHex("8064")).write(bytes, 100, 100);
     clientReader.processNextFrame();
-    callback.assertBinaryMessage(bytes);
+    callback.assertBinaryMessage(ByteString.of(bytes));
   }
 
   @Test public void twoFrameNotContinuation() throws IOException {
@@ -250,84 +237,6 @@
     }
   }
 
-  @Test public void noCloseErrors() throws IOException {
-    data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
-    callback.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onMessage(ResponseBody body) throws IOException {
-        body.source().readAll(new Buffer());
-      }
-    });
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("Listener failed to call close on message payload.", e.getMessage());
-    }
-  }
-
-  @Test public void closeExhaustsMessage() throws IOException {
-    data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
-    data.write(ByteString.decodeHex("810448657921")); // Hey!
-
-    final Buffer sink = new Buffer();
-    callback.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        message.source().read(sink, 3);
-        message.close();
-      }
-    });
-
-    clientReader.processNextFrame();
-    assertEquals("Hel", sink.readUtf8());
-
-    clientReader.processNextFrame();
-    callback.assertTextMessage("Hey!");
-  }
-
-  @Test public void closeExhaustsMessageOverControlFrames() throws IOException {
-    data.write(ByteString.decodeHex("010348656c")); // Hel
-    data.write(ByteString.decodeHex("8a00")); // Pong
-    data.write(ByteString.decodeHex("8a00")); // Pong
-    data.write(ByteString.decodeHex("80026c6f")); // lo
-    data.write(ByteString.decodeHex("810448657921")); // Hey!
-
-    final Buffer sink = new Buffer();
-    callback.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        message.source().read(sink, 2);
-        message.close();
-      }
-    });
-
-    clientReader.processNextFrame();
-    assertEquals("He", sink.readUtf8());
-    callback.assertPong(ByteString.EMPTY);
-    callback.assertPong(ByteString.EMPTY);
-
-    clientReader.processNextFrame();
-    callback.assertTextMessage("Hey!");
-  }
-
-  @Test public void closedMessageSourceThrows() throws IOException {
-    data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
-
-    final AtomicReference<Exception> exception = new AtomicReference<>();
-    callback.setNextEventDelegate(new EmptyWebSocketListener() {
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        message.close();
-        try {
-          message.source().readAll(new Buffer());
-          fail();
-        } catch (IllegalStateException e) {
-          exception.set(e);
-        }
-      }
-    });
-    clientReader.processNextFrame();
-
-    assertNotNull(exception.get());
-  }
-
   @Test public void emptyPingCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("8900")); // Empty ping
     clientReader.processNextFrame();
@@ -343,7 +252,7 @@
   @Test public void emptyCloseCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("8800")); // Empty close
     clientReader.processNextFrame();
-    callback.assertClose(1005, "");
+    callback.assertClosing(1005, "");
   }
 
   @Test public void closeLengthOfOneThrows() throws IOException {
@@ -359,7 +268,7 @@
   @Test public void closeCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("880703e848656c6c6f")); // Close with code and reason
     clientReader.processNextFrame();
-    callback.assertClose(1000, "Hello");
+    callback.assertClosing(1000, "Hello");
   }
 
   @Test public void closeOutOfRangeThrows() throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
index 91510cdf56..ac5626ce57 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
+ * Copyright (C) 2016 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,23 +19,19 @@
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
-import okhttp3.MediaType;
 import okhttp3.Response;
-import okhttp3.ResponseBody;
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
+import okhttp3.internal.Util;
 import okhttp3.internal.platform.Platform;
-import okio.Buffer;
 import okio.ByteString;
 
-import static okhttp3.WebSocket.BINARY;
-import static okhttp3.WebSocket.TEXT;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
-public final class WebSocketRecorder implements WebSocketListener {
+public final class WebSocketRecorder extends WebSocketListener {
   private final String name;
   private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
   private WebSocketListener delegate;
@@ -61,52 +57,63 @@ public void setNextEventDelegate(WebSocketListener delegate) {
     }
   }
 
-  @Override public void onMessage(ResponseBody message) throws IOException {
+  @Override public void onMessage(WebSocket webSocket, ByteString bytes) {
     Platform.get().log(Platform.INFO, "[WS " + name + "] onMessage", null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
       this.delegate = null;
-      delegate.onMessage(message);
+      delegate.onMessage(webSocket, bytes);
     } else {
-      Message event = new Message(message.contentType());
-      message.source().readAll(event.buffer);
-      message.close();
+      Message event = new Message(bytes);
       events.add(event);
     }
   }
 
-  @Override public void onPong(ByteString payload) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onPong", null);
+  @Override public void onMessage(WebSocket webSocket, String text) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onMessage", null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onMessage(webSocket, text);
+    } else {
+      Message event = new Message(text);
+      events.add(event);
+    }
+  }
+
+  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onClose " + code, null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
       this.delegate = null;
-      delegate.onPong(payload);
+      delegate.onClosing(webSocket, code, reason);
     } else {
-      events.add(new Pong(payload));
+      events.add(new Closing(code, reason));
     }
   }
 
-  @Override public void onClose(int code, String reason) {
+  @Override public void onClosed(WebSocket webSocket, int code, String reason) {
     Platform.get().log(Platform.INFO, "[WS " + name + "] onClose " + code, null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
       this.delegate = null;
-      delegate.onClose(code, reason);
+      delegate.onClosed(webSocket, code, reason);
     } else {
-      events.add(new Close(code, reason));
+      events.add(new Closed(code, reason));
     }
   }
 
-  @Override public void onFailure(Throwable t, Response response) {
+  @Override public void onFailure(WebSocket webSocket, Throwable t, Response response)  {
     Platform.get().log(Platform.INFO, "[WS " + name + "] onFailure", t);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
       this.delegate = null;
-      delegate.onFailure(t, response);
+      delegate.onFailure(webSocket, t, response);
     } else {
       events.add(new Failure(t, response));
     }
@@ -125,17 +132,18 @@ private Object nextEvent() {
   }
 
   public void assertTextMessage(String payload) {
-    Message message = new Message(TEXT);
-    message.buffer.writeUtf8(payload);
     Object actual = nextEvent();
-    assertEquals(message, actual);
+    assertEquals(new Message(payload), actual);
   }
 
-  public void assertBinaryMessage(byte[] payload) {
-    Message message = new Message(BINARY);
-    message.buffer.write(payload);
+  public void assertBinaryMessage(ByteString payload) {
     Object actual = nextEvent();
-    assertEquals(message, actual);
+    assertEquals(new Message(payload), actual);
+  }
+
+  public void assertPing(ByteString payload) {
+    Object actual = nextEvent();
+    assertEquals(new Ping(payload), actual);
   }
 
   public void assertPong(ByteString payload) {
@@ -143,9 +151,14 @@ public void assertPong(ByteString payload) {
     assertEquals(new Pong(payload), actual);
   }
 
-  public void assertClose(int code, String reason) {
+  public void assertClosing(int code, String reason) {
+    Object actual = nextEvent();
+    assertEquals(new Closing(code, reason), actual);
+  }
+
+  public void assertClosed(int code, String reason) {
     Object actual = nextEvent();
-    assertEquals(new Close(code, reason), actual);
+    assertEquals(new Closed(code, reason), actual);
   }
 
   public void assertExhausted() {
@@ -181,6 +194,13 @@ public void assertFailure(Class<? extends IOException> cls, String message) {
     assertEquals(message, failure.t.getMessage());
   }
 
+  public void assertFailure() {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+  }
+
   public void assertFailure(int code, String body, Class<? extends IOException> cls, String message)
       throws IOException {
     Object event = nextEvent();
@@ -190,12 +210,37 @@ public void assertFailure(int code, String body, Class<? extends IOException> cl
     Failure failure = (Failure) event;
     assertEquals(code, failure.response.code());
     if (body != null) {
-      assertEquals(body, failure.response.body().string());
+      assertEquals(body, failure.responseBody);
     }
     assertEquals(cls, failure.t.getClass());
     assertEquals(message, failure.t.getMessage());
   }
 
+  /** Expose this recorder as a frame callback and shim in "ping" events. */
+  public WebSocketReader.FrameCallback asFrameCallback() {
+    return new WebSocketReader.FrameCallback() {
+      @Override public void onReadMessage(String text) throws IOException {
+        onMessage(null, text);
+      }
+
+      @Override public void onReadMessage(ByteString bytes) throws IOException {
+        onMessage(null, bytes);
+      }
+
+      @Override public void onReadPing(ByteString payload) {
+        events.add(new Ping(payload));
+      }
+
+      @Override public void onReadPong(ByteString payload) {
+        events.add(new Pong(payload));
+      }
+
+      @Override public void onReadClose(int code, String reason) {
+        onClosing(null, code, reason);
+      }
+    };
+  }
+
   static final class Open {
     final WebSocket webSocket;
     final Response response;
@@ -213,10 +258,19 @@ public void assertFailure(int code, String body, Class<? extends IOException> cl
   static final class Failure {
     final Throwable t;
     final Response response;
+    final String responseBody;
 
     Failure(Throwable t, Response response) {
       this.t = t;
       this.response = response;
+      String responseBody = null;
+      if (response != null) {
+        try {
+          responseBody = response.body().string();
+        } catch (IOException ignored) {
+        }
+      }
+      this.responseBody = responseBody;
     }
 
     @Override public String toString() {
@@ -228,34 +282,59 @@ public void assertFailure(int code, String body, Class<? extends IOException> cl
   }
 
   static final class Message {
-    public final MediaType mediaType;
-    public final Buffer buffer = new Buffer();
+    public final ByteString bytes;
+    public final String string;
 
-    Message(MediaType mediaType) {
-      this.mediaType = mediaType;
+    public Message(ByteString bytes) {
+      this.bytes = bytes;
+      this.string = null;
+    }
+
+    public Message(String string) {
+      this.bytes = null;
+      this.string = string;
     }
 
     @Override public String toString() {
-      return "Message[" + mediaType + " " + buffer + "]";
+      return "Message[" + (bytes != null ? bytes : string) + "]";
     }
 
     @Override public int hashCode() {
-      return mediaType.hashCode() * 37 + buffer.hashCode();
+      return (bytes != null ? bytes : string).hashCode();
     }
 
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Message) {
-        Message other = (Message) obj;
-        return mediaType.equals(other.mediaType) && buffer.equals(other.buffer);
-      }
-      return false;
+    @Override public boolean equals(Object other) {
+      return other instanceof Message
+          && Util.equal(((Message) other).bytes, bytes)
+          && Util.equal(((Message) other).string, string);
+    }
+  }
+
+  static final class Ping {
+    public final ByteString payload;
+
+    public Ping(ByteString payload) {
+      this.payload = payload;
+    }
+
+    @Override public String toString() {
+      return "Ping[" + payload + "]";
+    }
+
+    @Override public int hashCode() {
+      return payload.hashCode();
+    }
+
+    @Override public boolean equals(Object other) {
+      return other instanceof Ping
+          && ((Ping) other).payload.equals(payload);
     }
   }
 
   static final class Pong {
     public final ByteString payload;
 
-    Pong(ByteString payload) {
+    public Pong(ByteString payload) {
       this.payload = payload;
     }
 
@@ -267,88 +346,57 @@ public void assertFailure(int code, String body, Class<? extends IOException> cl
       return payload.hashCode();
     }
 
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Pong) {
-        Pong other = (Pong) obj;
-        return payload == null ? other.payload == null : payload.equals(other.payload);
-      }
-      return false;
+    @Override public boolean equals(Object other) {
+      return other instanceof Pong
+          && ((Pong) other).payload.equals(payload);
     }
   }
 
-  static final class Close {
+  static final class Closing {
     public final int code;
     public final String reason;
 
-    Close(int code, String reason) {
+    Closing(int code, String reason) {
       this.code = code;
       this.reason = reason;
     }
 
     @Override public String toString() {
-      return "Close[" + code + " " + reason + "]";
+      return "Closing[" + code + " " + reason + "]";
     }
 
     @Override public int hashCode() {
       return code * 37 + reason.hashCode();
     }
 
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Close) {
-        Close other = (Close) obj;
-        return code == other.code && reason.equals(other.reason);
-      }
-      return false;
+    @Override public boolean equals(Object other) {
+      return other instanceof Closing
+          && ((Closing) other).code == code
+          && ((Closing) other).reason.equals(reason);
     }
   }
 
-  /** Expose this recorder as a frame callback and shim in "ping" events. */
-  WebSocketReader.FrameCallback asFrameCallback() {
-    return new WebSocketReader.FrameCallback() {
-      @Override public void onReadMessage(ResponseBody body) throws IOException {
-        onMessage(body);
-      }
-
-      @Override public void onReadPing(ByteString payload) {
-        events.add(new Ping(payload));
-      }
-
-      @Override public void onReadPong(ByteString padload) {
-        onPong(padload);
-      }
-
-      @Override public void onReadClose(int code, String reason) {
-        onClose(code, reason);
-      }
-    };
-  }
-
-  void assertPing(ByteString payload) {
-    Object actual = nextEvent();
-    assertEquals(new Ping(payload), actual);
-  }
-
-  static final class Ping {
-    public final ByteString buffer;
+  static final class Closed {
+    public final int code;
+    public final String reason;
 
-    Ping(ByteString buffer) {
-      this.buffer = buffer;
+    Closed(int code, String reason) {
+      this.code = code;
+      this.reason = reason;
     }
 
     @Override public String toString() {
-      return "Ping[" + buffer + "]";
+      return "Closed[" + code + " " + reason + "]";
     }
 
     @Override public int hashCode() {
-      return buffer.hashCode();
+      return code * 37 + reason.hashCode();
     }
 
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Ping) {
-        Ping other = (Ping) obj;
-        return buffer == null ? other.buffer == null : buffer.equals(other.buffer);
-      }
-      return false;
+    @Override public boolean equals(Object other) {
+      return other instanceof Closed
+          && ((Closed) other).code == code
+          && ((Closed) other).reason.equals(reason);
     }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
deleted file mode 100644
index e01b2c0269..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
+++ /dev/null
@@ -1,400 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import okhttp3.RequestBody;
-import okhttp3.internal.Util;
-import okio.*;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TestRule;
-import org.junit.runner.Description;
-import org.junit.runners.model.Statement;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.Random;
-
-import static okhttp3.internal.ws.WebSocketProtocol.*;
-import static org.junit.Assert.*;
-
-public final class WebSocketWriterTest {
-  private final Buffer data = new Buffer();
-  private final Random random = new Random(0);
-
-  /**
-   * Check all data as verified inside of the test. We do this in a rule instead of @After so that
-   * exceptions thrown from the test do not cause this check to fail.
-   */
-  @Rule public final TestRule noDataLeftBehind = new TestRule() {
-    @Override public Statement apply(final Statement base, Description description) {
-      return new Statement() {
-        @Override public void evaluate() throws Throwable {
-          base.evaluate();
-          assertEquals("Data not empty", "", data.readByteString().hex());
-        }
-      };
-    }
-  };
-
-  // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
-  private final WebSocketWriter serverWriter = new WebSocketWriter(false, data, random);
-  private final WebSocketWriter clientWriter = new WebSocketWriter(true, data, random);
-
-  @Test public void serverTextMessage() throws IOException {
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, -1));
-
-    sink.writeUtf8("Hel").flush();
-    assertData("010348656c");
-
-    sink.writeUtf8("lo").flush();
-    assertData("00026c6f");
-
-    sink.close();
-    assertData("8000");
-  }
-
-  @Test public void serverSmallBufferedPayloadWrittenAsOneFrame() throws IOException {
-    int length = 5;
-    byte[] bytes = binaryData(length);
-
-    RequestBody body = RequestBody.create(null, bytes);
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
-    body.writeTo(sink);
-    sink.close();
-
-    assertData("8105");
-    assertData(bytes);
-    assertTrue(data.exhausted());
-  }
-
-  @Test public void serverLargeBufferedPayloadWrittenAsOneFrame() throws IOException {
-    int length = 12345;
-    byte[] bytes = binaryData(length);
-
-    RequestBody body = RequestBody.create(null, bytes);
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
-    body.writeTo(sink);
-    sink.close();
-
-    assertData("817e");
-    assertData(Util.format("%04x", length));
-    assertData(bytes);
-    assertTrue(data.exhausted());
-
-  }
-
-  @Test public void serverLargeNonBufferedPayloadWrittenAsMultipleFrames() throws IOException {
-    int length = 100_000;
-    Buffer bytes = new Buffer().write(binaryData(length));
-
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
-    Buffer body = bytes.clone();
-    sink.write(body.readByteString(20_000));
-    sink.write(body.readByteString(20_000));
-    sink.write(body.readByteString(20_000));
-    sink.write(body.readByteString(20_000));
-    sink.write(body.readByteString(20_000));
-    sink.close();
-
-    assertData("017e4000");
-    assertData(bytes.readByteArray(16_384));
-    assertData("007e4000");
-    assertData(bytes.readByteArray(16_384));
-    assertData("007e6000");
-    assertData(bytes.readByteArray(24_576));
-    assertData("007e4000");
-    assertData(bytes.readByteArray(16_384));
-    assertData("007e6000");
-    assertData(bytes.readByteArray(24_576));
-    assertData("807e06a0");
-    assertData(bytes.readByteArray(1_696));
-    assertTrue(data.exhausted());
-  }
-
-  @Test public void closeFlushes() throws IOException {
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, -1));
-
-    sink.writeUtf8("Hel").flush();
-    assertData("010348656c");
-
-    sink.writeUtf8("lo").close();
-    assertData("80026c6f");
-  }
-
-  @Test public void noWritesAfterClose() throws IOException {
-    Sink sink = serverWriter.newMessageSink(OPCODE_TEXT, -1);
-
-    sink.close();
-    assertData("8100");
-
-    Buffer payload = new Buffer().writeUtf8("Hello");
-    try {
-      // Write to the unbuffered sink as BufferedSink keeps its own closed state.
-      sink.write(payload, payload.size());
-      fail();
-    } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
-    }
-  }
-
-  @Test public void clientTextMessage() throws IOException {
-    BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_TEXT, -1));
-
-    sink.writeUtf8("Hel").flush();
-    assertData("018360b420bb28d14c");
-
-    sink.writeUtf8("lo").flush();
-    assertData("00823851d9d4543e");
-
-    sink.close();
-    assertData("80807acb933d");
-  }
-
-  @Test public void serverBinaryMessage() throws IOException {
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_BINARY, -1));
-
-    sink.write(binaryData(50)).flush();
-    assertData("0232");
-    assertData(binaryData(50));
-
-    sink.write(binaryData(50)).flush();
-    assertData("0032");
-    assertData(binaryData(50));
-
-    sink.close();
-    assertData("8000");
-  }
-
-  @Test public void serverMessageLengthShort() throws IOException {
-    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY, -1);
-
-    // Create a payload which will overflow the normal payload byte size.
-    Buffer payload = new Buffer();
-    while (payload.completeSegmentByteCount() <= PAYLOAD_BYTE_MAX) {
-      payload.writeByte('0');
-    }
-    long byteCount = payload.completeSegmentByteCount();
-
-    // Write directly to the unbuffered sink. This ensures it will become single frame.
-    sink.write(payload.clone(), byteCount);
-    assertData("027e"); // 'e' == 4-byte follow-up length.
-    assertData(Util.format("%04X", payload.completeSegmentByteCount()));
-    assertData(payload.readByteArray());
-
-    sink.close();
-    assertData("8000");
-  }
-
-  @Test public void serverMessageLengthLong() throws IOException {
-    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY, -1);
-
-    // Create a payload which will overflow the normal and short payload byte size.
-    Buffer payload = new Buffer();
-    while (payload.completeSegmentByteCount() <= PAYLOAD_SHORT_MAX) {
-      payload.writeByte('0');
-    }
-    long byteCount = payload.completeSegmentByteCount();
-
-    // Write directly to the unbuffered sink. This ensures it will become single frame.
-    sink.write(payload.clone(), byteCount);
-    assertData("027f"); // 'f' == 16-byte follow-up length.
-    assertData(Util.format("%016X", byteCount));
-    assertData(payload.readByteArray(byteCount));
-    sink.close();
-    assertData("8000");
-  }
-
-  @Test public void clientBinary() throws IOException {
-    byte[] maskKey1 = new byte[4];
-    random.nextBytes(maskKey1);
-    byte[] maskKey2 = new byte[4];
-    random.nextBytes(maskKey2);
-
-    random.setSeed(0); // Reset the seed so real data matches.
-
-    BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_BINARY, -1));
-
-    byte[] part1 = binaryData(50);
-    sink.write(part1).flush();
-    toggleMask(part1, 50, maskKey1, 0);
-    assertData("02b2");
-    assertData(maskKey1);
-    assertData(part1);
-
-    byte[] part2 = binaryData(50);
-    sink.write(part2).close();
-    toggleMask(part2, 50, maskKey2, 0);
-    assertData("80b2");
-    assertData(maskKey2);
-    assertData(part2);
-  }
-
-  @Test public void serverEmptyClose() throws IOException {
-    serverWriter.writeClose(0, null);
-    assertData("8800");
-  }
-
-  @Test public void serverCloseWithCode() throws IOException {
-    serverWriter.writeClose(1001, null);
-    assertData("880203e9");
-  }
-
-  @Test public void serverCloseWithCodeAndReason() throws IOException {
-    serverWriter.writeClose(1001, "Hello");
-    assertData("880703e948656c6c6f");
-  }
-
-  @Test public void clientEmptyClose() throws IOException {
-    clientWriter.writeClose(0, null);
-    assertData("888060b420bb");
-  }
-
-  @Test public void clientCloseWithCode() throws IOException {
-    clientWriter.writeClose(1001, null);
-    assertData("888260b420bb635d");
-  }
-
-  @Test public void clientCloseWithCodeAndReason() throws IOException {
-    clientWriter.writeClose(1001, "Hello");
-    assertData("888760b420bb635d68de0cd84f");
-  }
-
-  @Test public void closeWithOnlyReasonThrows() throws IOException {
-    clientWriter.writeClose(0, "Hello");
-    assertData("888760b420bb60b468de0cd84f");
-  }
-
-  @Test public void closeCodeOutOfRangeThrows() throws IOException {
-    try {
-      clientWriter.writeClose(98724976, "Hello");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Code must be in range [1000,5000): 98724976", e.getMessage());
-    }
-  }
-
-  @Test public void closeReservedThrows() throws IOException {
-    try {
-      clientWriter.writeClose(1005, "Hello");
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Code 1005 is reserved and may not be used.", e.getMessage());
-    }
-  }
-
-  @Test public void serverEmptyPing() throws IOException {
-    serverWriter.writePing(ByteString.EMPTY);
-    assertData("8900");
-  }
-
-  @Test public void clientEmptyPing() throws IOException {
-    clientWriter.writePing(ByteString.EMPTY);
-    assertData("898060b420bb");
-  }
-
-  @Test public void serverPingWithPayload() throws IOException {
-    serverWriter.writePing(ByteString.encodeUtf8("Hello"));
-    assertData("890548656c6c6f");
-  }
-
-  @Test public void clientPingWithPayload() throws IOException {
-    clientWriter.writePing(ByteString.encodeUtf8("Hello"));
-    assertData("898560b420bb28d14cd70f");
-  }
-
-  @Test public void serverEmptyPong() throws IOException {
-    serverWriter.writePong(ByteString.EMPTY);
-    assertData("8a00");
-  }
-
-  @Test public void clientEmptyPong() throws IOException {
-    clientWriter.writePong(ByteString.EMPTY);
-    assertData("8a8060b420bb");
-  }
-
-  @Test public void serverPongWithPayload() throws IOException {
-    serverWriter.writePong(ByteString.encodeUtf8("Hello"));
-    assertData("8a0548656c6c6f");
-  }
-
-  @Test public void clientPongWithPayload() throws IOException {
-    clientWriter.writePong(ByteString.encodeUtf8("Hello"));
-    assertData("8a8560b420bb28d14cd70f");
-  }
-
-  @Test public void pingTooLongThrows() throws IOException {
-    try {
-      serverWriter.writePing(ByteString.of(binaryData(1000)));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
-    }
-  }
-
-  @Test public void pongTooLongThrows() throws IOException {
-    try {
-      serverWriter.writePong(ByteString.of(binaryData(1000)));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
-    }
-  }
-
-  @Test public void closeTooLongThrows() throws IOException {
-    try {
-      String longString = ByteString.of(binaryData(75)).hex();
-      serverWriter.writeClose(1000, longString);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
-    }
-  }
-
-  @Test public void twoMessageSinksThrows() {
-    Timeout time1= clientWriter.newMessageSink(OPCODE_TEXT, -1).timeout();
-
-    try {
-      Timeout time2 = clientWriter.newMessageSink(OPCODE_TEXT, -1).timeout();
-      assertEquals(time1,time2);
-      fail();
-    } catch (IllegalStateException e) {
-      assertEquals("Another message writer is active. Did you call close()?", e.getMessage());
-    }
-  }
-
-  private void assertData(String hex) throws EOFException {
-    ByteString expected = ByteString.decodeHex(hex);
-    ByteString actual = data.readByteString(expected.size());
-    assertEquals(expected, actual);
-  }
-
-  private void assertData(byte[] data) throws IOException {
-    int byteCount = 16;
-    for (int i = 0; i < data.length; i += byteCount) {
-      int count = Math.min(byteCount, data.length - i);
-      Buffer expectedChunk = new Buffer();
-      expectedChunk.write(data, i, count);
-      assertEquals("At " + i, expectedChunk.readByteString(), this.data.readByteString(count));
-    }
-  }
-
-  private static byte[] binaryData(int length) {
-    byte[] junk = new byte[length];
-    new Random(0).nextBytes(junk);
-    return junk;
-  }
-}
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index bde049037c..34c265c24c 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
index 046b098f2c..461b1f1c48 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
@@ -151,7 +151,7 @@ public OkHttpURLConnection(URL url, OkHttpClient client, URLFilter urlFilter) {
    */
   @Override public InputStream getErrorStream() {
     try {
-      Response response = getResponse();
+      Response response = getResponse(true);
       if (HttpHeaders.hasBody(response) && response.code() >= HTTP_BAD_REQUEST) {
         return response.body().byteStream();
       }
@@ -163,7 +163,7 @@ public OkHttpURLConnection(URL url, OkHttpClient client, URLFilter urlFilter) {
 
   private Headers getHeaders() throws IOException {
     if (responseHeaders == null) {
-      Response response = getResponse();
+      Response response = getResponse(true);
       Headers headers = response.headers();
       responseHeaders = headers.newBuilder()
           .add(SELECTED_PROTOCOL, response.protocol().toString())
@@ -207,7 +207,7 @@ private static String responseSourceHeader(Response response) {
   @Override public String getHeaderField(String fieldName) {
     try {
       return fieldName == null
-          ? StatusLine.get(getResponse()).toString()
+          ? StatusLine.get(getResponse(true)).toString()
           : getHeaders().get(fieldName);
     } catch (IOException e) {
       return null;
@@ -227,7 +227,7 @@ private static String responseSourceHeader(Response response) {
   @Override public Map<String, List<String>> getHeaderFields() {
     try {
       return JavaNetHeaders.toMultimap(getHeaders(),
-          StatusLine.get(getResponse()).toString());
+          StatusLine.get(getResponse(true)).toString());
     } catch (IOException e) {
       return Collections.emptyMap();
     }
@@ -247,7 +247,7 @@ private static String responseSourceHeader(Response response) {
       throw new ProtocolException("This protocol does not support input");
     }
 
-    Response response = getResponse();
+    Response response = getResponse(false);
 
     if (response.code() >= HTTP_BAD_REQUEST) {
       throw new FileNotFoundException(url.toString());
@@ -405,13 +405,13 @@ private String defaultUserAgent() {
    * Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the
    * process in order to cope with redirects and authentication.
    */
-  private Response getResponse() throws IOException {
-    if (response != null) {
-      return response;
-    } else if (networkResponse != null) {
-      return networkResponse;
-    } else if (callFailure != null) {
-      throw propagate(callFailure);
+  private Response getResponse(boolean networkResponseOnError) throws IOException {
+    synchronized (lock) {
+      if (response != null) return response;
+      if (callFailure != null) {
+        if (networkResponseOnError && networkResponse != null) return networkResponse;
+        throw propagate(callFailure);
+      }
     }
 
     Call call = buildCall();
@@ -466,11 +466,11 @@ private Response getResponse() throws IOException {
   }
 
   @Override public String getResponseMessage() throws IOException {
-    return getResponse().message();
+    return getResponse(true).message();
   }
 
   @Override public int getResponseCode() throws IOException {
-    return getResponse().code();
+    return getResponse(true).code();
   }
 
   @Override public void setRequestProperty(String field, String newValue) {
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 2e07de0875..a3e5aaa134 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
diff --git a/okhttp/src/main/java/okhttp3/CacheControl.java b/okhttp/src/main/java/okhttp3/CacheControl.java
index 9dcdbd3c2e..39972c4bfb 100644
--- a/okhttp/src/main/java/okhttp3/CacheControl.java
+++ b/okhttp/src/main/java/okhttp3/CacheControl.java
@@ -58,7 +58,7 @@ private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sM
     this.headerValue = headerValue;
   }
 
-  private CacheControl(Builder builder) {
+  CacheControl(Builder builder) {
     this.noCache = builder.noCache;
     this.noStore = builder.noStore;
     this.maxAgeSeconds = builder.maxAgeSeconds;
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index 855907e2b3..722521a70c 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -130,7 +130,7 @@
   private final Set<Pin> pins;
   private final CertificateChainCleaner certificateChainCleaner;
 
-  private CertificatePinner(Set<Pin> pins, CertificateChainCleaner certificateChainCleaner) {
+  CertificatePinner(Set<Pin> pins, CertificateChainCleaner certificateChainCleaner) {
     this.pins = pins;
     this.certificateChainCleaner = certificateChainCleaner;
   }
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
index a229e2dd00..11fd12c3ea 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -80,12 +80,12 @@
   /** Unencrypted, unauthenticated connections for {@code http:} URLs. */
   public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
 
-  private final boolean tls;
-  private final boolean supportsTlsExtensions;
-  private final String[] cipherSuites;
-  private final String[] tlsVersions;
+  final boolean tls;
+  final boolean supportsTlsExtensions;
+  final String[] cipherSuites;
+  final String[] tlsVersions;
 
-  private ConnectionSpec(Builder builder) {
+  ConnectionSpec(Builder builder) {
     this.tls = builder.tls;
     this.cipherSuites = builder.cipherSuites;
     this.tlsVersions = builder.tlsVersions;
@@ -251,10 +251,10 @@ private static boolean nonEmptyIntersection(String[] a, String[] b) {
   }
 
   public static final class Builder {
-    private boolean tls;
-    private String[] cipherSuites;
-    private String[] tlsVersions;
-    private boolean supportsTlsExtensions;
+    boolean tls;
+    String[] cipherSuites;
+    String[] tlsVersions;
+    boolean supportsTlsExtensions;
 
     Builder(boolean tls) {
       this.tls = tls;
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
index df882c01ab..066c6e1471 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -74,7 +74,7 @@ private Cookie(String name, String value, long expiresAt, String domain, String
     this.persistent = persistent;
   }
 
-  private Cookie(Builder builder) {
+  Cookie(Builder builder) {
     if (builder.name == null) throw new NullPointerException("builder.name == null");
     if (builder.value == null) throw new NullPointerException("builder.value == null");
     if (builder.domain == null) throw new NullPointerException("builder.domain == null");
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
index 95181b1f76..87ebb49f81 100644
--- a/okhttp/src/main/java/okhttp3/FormBody.java
+++ b/okhttp/src/main/java/okhttp3/FormBody.java
@@ -32,7 +32,7 @@
   private final List<String> encodedNames;
   private final List<String> encodedValues;
 
-  private FormBody(List<String> encodedNames, List<String> encodedValues) {
+  FormBody(List<String> encodedNames, List<String> encodedValues) {
     this.encodedNames = Util.immutableList(encodedNames);
     this.encodedValues = Util.immutableList(encodedValues);
   }
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index e6c7c359b5..96dab297b6 100644
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -49,7 +49,7 @@
 public final class Headers {
   private final String[] namesAndValues;
 
-  private Headers(Builder builder) {
+  Headers(Builder builder) {
     this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
   }
 
@@ -237,7 +237,7 @@ public static Headers of(Map<String, String> headers) {
   }
 
   public static final class Builder {
-    private final List<String> namesAndValues = new ArrayList<>(20);
+    final List<String> namesAndValues = new ArrayList<>(20);
 
     /**
      * Add a header line without any validation. Only appropriate for headers from the remote peer
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index deadf39ba0..6b37d5630d 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -296,7 +296,7 @@
   static final String FRAGMENT_ENCODE_SET_URI = " \"#<>\\^`{|}";
 
   /** Either "http" or "https". */
-  private final String scheme;
+  final String scheme;
 
   /** Decoded username. */
   private final String username;
@@ -305,10 +305,10 @@
   private final String password;
 
   /** Canonical hostname. */
-  private final String host;
+  final String host;
 
   /** Either 80, 443 or a user-specified port. In range [1..65535]. */
-  private final int port;
+  final int port;
 
   /**
    * A list of canonical path segments. This list always contains at least one element, which may be
@@ -330,7 +330,7 @@
   /** Canonical URL. */
   private final String url;
 
-  private HttpUrl(Builder builder) {
+  HttpUrl(Builder builder) {
     this.scheme = builder.scheme;
     this.username = percentDecode(builder.encodedUsername, false);
     this.password = percentDecode(builder.encodedPassword, false);
@@ -842,14 +842,16 @@ public String fragment() {
   }
 
   /**
-   * Returns the HttpUrl with the username, password, path, query, and fragment stripped.
-   * Example: http://username:password@example.com/path returns http://example.com/...
+   * Returns a string with containing this URL with its username, password, query, and fragment
+   * stripped, and its path replaced with {@code /...}. For example, redacting {@code
+   * http://username:password@example.com/path} returns {@code http://example.com/...}.
    */
-  public HttpUrl redact() {
-    Builder builder = newBuilder("/...");
-    builder.username("");
-    builder.password("");
-    return builder.build();
+  public String redact() {
+    return newBuilder("/...")
+        .username("")
+        .password("")
+        .build()
+        .toString();
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 225896d11d..d55351e841 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -21,6 +21,7 @@
 import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
 import java.security.KeyStore;
+import java.security.SecureRandom;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -44,6 +45,7 @@
 import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.OkHostnameVerifier;
+import okhttp3.internal.ws.RealWebSocket;
 
 /**
  * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
@@ -115,11 +117,11 @@
  * <p>OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
  * remain idle.
  */
-public class OkHttpClient implements Cloneable, Call.Factory, WebSocketCall.Factory {
-  private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
+public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
+  static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
       Protocol.HTTP_2, Protocol.HTTP_1_1);
 
-  private static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
+  static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
       ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, ConnectionSpec.CLEARTEXT);
 
   static {
@@ -163,6 +165,14 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
           throws MalformedURLException, UnknownHostException {
         return HttpUrl.getChecked(url);
       }
+
+      @Override public StreamAllocation streamAllocation(Call call) {
+        return ((RealCall) call).streamAllocation();
+      }
+
+      @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
+        return new RealCall(client, originalRequest, true);
+      }
     };
   }
 
@@ -191,12 +201,13 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
   final int connectTimeout;
   final int readTimeout;
   final int writeTimeout;
+  final int pingInterval;
 
   public OkHttpClient() {
     this(new Builder());
   }
 
-  private OkHttpClient(Builder builder) {
+  OkHttpClient(Builder builder) {
     this.dispatcher = builder.dispatcher;
     this.proxy = builder.proxy;
     this.protocols = builder.protocols;
@@ -236,6 +247,7 @@ private OkHttpClient(Builder builder) {
     this.connectTimeout = builder.connectTimeout;
     this.readTimeout = builder.readTimeout;
     this.writeTimeout = builder.writeTimeout;
+    this.pingInterval = builder.pingInterval;
   }
 
   private X509TrustManager systemDefaultTrustManager() {
@@ -279,6 +291,11 @@ public int writeTimeoutMillis() {
     return writeTimeout;
   }
 
+  /** Web socket ping interval (in milliseconds). */
+  public int pingIntervalMillis() {
+    return pingInterval;
+  }
+
   public Proxy proxy() {
     return proxy;
   }
@@ -381,10 +398,12 @@ public Dispatcher dispatcher() {
   }
 
   /**
-   * Prepares the {@code request} to create a web socket at some point in the future.
+   * Uses {@code request} to connect a new web socket.
    */
-  @Override public WebSocketCall newWebSocketCall(Request request) {
-    return new RealWebSocketCall(this, request);
+  @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {
+    RealWebSocket webSocket = new RealWebSocket(request, listener, new SecureRandom());
+    webSocket.connect(this);
+    return webSocket;
   }
 
   public Builder newBuilder() {
@@ -417,6 +436,7 @@ public Builder newBuilder() {
     int connectTimeout;
     int readTimeout;
     int writeTimeout;
+    int pingInterval;
 
     public Builder() {
       dispatcher = new Dispatcher();
@@ -437,6 +457,7 @@ public Builder() {
       connectTimeout = 10_000;
       readTimeout = 10_000;
       writeTimeout = 10_000;
+      pingInterval = 0;
     }
 
     Builder(OkHttpClient okHttpClient) {
@@ -465,6 +486,7 @@ public Builder() {
       this.connectTimeout = okHttpClient.connectTimeout;
       this.readTimeout = okHttpClient.readTimeout;
       this.writeTimeout = okHttpClient.writeTimeout;
+      this.pingInterval = okHttpClient.pingInterval;
     }
 
     /**
@@ -473,12 +495,7 @@ public Builder() {
      * milliseconds.
      */
     public Builder connectTimeout(long timeout, TimeUnit unit) {
-      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new NullPointerException("unit == null");
-      long millis = unit.toMillis(timeout);
-      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-      connectTimeout = (int) millis;
+      connectTimeout = checkDuration("timeout", timeout, unit);
       return this;
     }
 
@@ -487,12 +504,7 @@ public Builder connectTimeout(long timeout, TimeUnit unit) {
      * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
      */
     public Builder readTimeout(long timeout, TimeUnit unit) {
-      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new NullPointerException("unit == null");
-      long millis = unit.toMillis(timeout);
-      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-      readTimeout = (int) millis;
+      readTimeout = checkDuration("timeout", timeout, unit);
       return this;
     }
 
@@ -501,15 +513,32 @@ public Builder readTimeout(long timeout, TimeUnit unit) {
      * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
      */
     public Builder writeTimeout(long timeout, TimeUnit unit) {
-      if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
-      if (unit == null) throw new NullPointerException("unit == null");
-      long millis = unit.toMillis(timeout);
-      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
-      if (millis == 0 && timeout > 0) throw new IllegalArgumentException("Timeout too small.");
-      writeTimeout = (int) millis;
+      writeTimeout = checkDuration("timeout", timeout, unit);
       return this;
     }
 
+    /**
+     * Sets the interval between web socket pings initiated by this client. Use this to
+     * automatically send web socket ping frames until either the web socket fails or it is closed.
+     * This keeps the connection alive and may detect connectivity failures early. No timeouts are
+     * enforced on the acknowledging pongs.
+     *
+     * <p>The default value of 0 disables client-initiated pings.
+     */
+    public Builder pingInterval(long interval, TimeUnit unit) {
+      pingInterval = checkDuration("interval", interval, unit);
+      return this;
+    }
+
+    private static int checkDuration(String name, long duration, TimeUnit unit) {
+      if (duration < 0) throw new IllegalArgumentException(name + " < 0");
+      if (unit == null) throw new NullPointerException("unit == null");
+      long millis = unit.toMillis(duration);
+      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException(name + " too large.");
+      if (millis == 0 && duration > 0) throw new IllegalArgumentException(name + " too small.");
+      return (int) millis;
+    }
+
     /**
      * Sets the HTTP proxy that will be used by connections created by this client. This takes
      * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 3c027a2caf..ab3ddb088f 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -158,7 +158,7 @@ String toLoggableString() {
   }
 
   String redactedUrl() {
-    return originalRequest.url().redact().toString();
+    return originalRequest.url().redact();
   }
 
   Response getResponseWithInterceptorChain() throws IOException {
diff --git a/okhttp/src/main/java/okhttp3/RealWebSocketCall.java b/okhttp/src/main/java/okhttp3/RealWebSocketCall.java
deleted file mode 100644
index da65db1c4b..0000000000
--- a/okhttp/src/main/java/okhttp3/RealWebSocketCall.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.security.SecureRandom;
-import java.util.Collections;
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.LinkedBlockingDeque;
-import java.util.concurrent.ThreadPoolExecutor;
-import okhttp3.internal.Util;
-import okhttp3.internal.connection.StreamAllocation;
-import okhttp3.internal.ws.RealWebSocket;
-import okhttp3.internal.ws.WebSocketProtocol;
-import okio.ByteString;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-
-final class RealWebSocketCall implements WebSocketCall {
-  private static final List<Protocol> ONLY_HTTP1 = Collections.singletonList(Protocol.HTTP_1_1);
-
-  /** The application's original request unadulterated by web socket headers. */
-  private final Request originalRequest;
-  private final RealCall call;
-  private final Random random;
-  private final String key;
-
-  RealWebSocketCall(OkHttpClient client, Request request) {
-    this(client, request, new SecureRandom());
-  }
-
-  RealWebSocketCall(OkHttpClient client, Request request, Random random) {
-    if (!"GET".equals(request.method())) {
-      throw new IllegalArgumentException("Request must be GET: " + request.method());
-    }
-    this.random = random;
-
-    byte[] nonce = new byte[16];
-    random.nextBytes(nonce);
-    key = ByteString.of(nonce).base64();
-
-    client = client.newBuilder()
-        .readTimeout(0, SECONDS) // i.e., no timeout because this is a long-lived connection.
-        .writeTimeout(0, SECONDS) // i.e., no timeout because this is a long-lived connection.
-        .protocols(ONLY_HTTP1)
-        .build();
-
-    originalRequest = request;
-    request = request.newBuilder()
-        .header("Upgrade", "websocket")
-        .header("Connection", "Upgrade")
-        .header("Sec-WebSocket-Key", key)
-        .header("Sec-WebSocket-Version", "13")
-        .build();
-
-    call = new RealCall(client, request, true /* for web socket */);
-  }
-
-  @Override public void enqueue(final WebSocketListener listener) {
-    Callback responseCallback = new Callback() {
-      @Override public void onResponse(Call call, Response response) {
-        StreamWebSocket webSocket;
-        try {
-          webSocket = create(response, listener);
-        } catch (IOException e) {
-          listener.onFailure(e, response);
-          return;
-        }
-
-        webSocket.loopReader();
-      }
-
-      @Override public void onFailure(Call call, IOException e) {
-        listener.onFailure(e, null);
-      }
-    };
-    call.enqueue(responseCallback);
-  }
-
-  StreamWebSocket create(Response response, WebSocketListener listener) throws IOException {
-    if (response.code() != 101) {
-      throw new ProtocolException("Expected HTTP 101 response but was '"
-          + response.code()
-          + " "
-          + response.message()
-          + "'");
-    }
-
-    String headerConnection = response.header("Connection");
-    if (!"Upgrade".equalsIgnoreCase(headerConnection)) {
-      throw new ProtocolException(
-          "Expected 'Connection' header value 'Upgrade' but was '" + headerConnection + "'");
-    }
-    String headerUpgrade = response.header("Upgrade");
-    if (!"websocket".equalsIgnoreCase(headerUpgrade)) {
-      throw new ProtocolException(
-          "Expected 'Upgrade' header value 'websocket' but was '" + headerUpgrade + "'");
-    }
-    String headerAccept = response.header("Sec-WebSocket-Accept");
-    String acceptExpected = WebSocketProtocol.acceptHeader(key);
-    if (!acceptExpected.equals(headerAccept)) {
-      throw new ProtocolException("Expected 'Sec-WebSocket-Accept' header value '"
-          + acceptExpected
-          + "' but was '"
-          + headerAccept
-          + "'");
-    }
-
-    String name = response.request().url().redact().toString();
-    ThreadPoolExecutor replyExecutor =
-        new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-            Util.threadFactory(Util.format("OkHttp %s WebSocket Replier", name), true));
-    replyExecutor.allowCoreThreadTimeOut(true);
-
-    StreamAllocation streamAllocation = call.streamAllocation();
-    streamAllocation.noNewStreams(); // Web socket connections can't be re-used.
-    return new StreamWebSocket(streamAllocation, random, replyExecutor, listener, response, name);
-  }
-
-  @Override public Request request() {
-    return originalRequest;
-  }
-
-  @Override public void cancel() {
-    call.cancel();
-  }
-
-  @Override public boolean isExecuted() {
-    return call.isExecuted();
-  }
-
-  @Override public boolean isCanceled() {
-    return call.isCanceled();
-  }
-
-  @Override public WebSocketCall clone() {
-    return new RealWebSocketCall(call.client, originalRequest, random);
-  }
-
-  // Keep static so that the WebSocketCall instance can be garbage collected.
-  static final class StreamWebSocket extends RealWebSocket {
-    private final StreamAllocation streamAllocation;
-    private final ExecutorService executor;
-
-    StreamWebSocket(StreamAllocation streamAllocation, Random random, ExecutorService executor,
-        WebSocketListener listener, Response response, String name) {
-      super(true /* is client */, streamAllocation.connection().source,
-          streamAllocation.connection().sink, random, executor, listener, response, name);
-      this.streamAllocation = streamAllocation;
-      this.executor = executor;
-    }
-
-    @Override protected void shutdown() {
-      executor.shutdown();
-      streamAllocation.streamFinished(true, streamAllocation.codec());
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index 36aa6acfe7..f4b0f6dba4 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -131,7 +131,7 @@ public Builder url(HttpUrl url) {
     public Builder url(String url) {
       if (url == null) throw new NullPointerException("url == null");
 
-      // Silently replace websocket URLs with HTTP URLs.
+      // Silently replace web socket URLs with HTTP URLs.
       if (url.regionMatches(true, 0, "ws:", 0, 3)) {
         url = "http:" + url.substring(3);
       } else if (url.regionMatches(true, 0, "wss:", 0, 4)) {
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
index 113d607746..c00e90f961 100644
--- a/okhttp/src/main/java/okhttp3/ResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.java
@@ -235,7 +235,7 @@ public static ResponseBody create(
     private boolean closed;
     private Reader delegate;
 
-    private BomAwareReader(BufferedSource source, Charset charset) {
+    BomAwareReader(BufferedSource source, Charset charset) {
       this.source = source;
       this.charset = charset;
     }
diff --git a/okhttp/src/main/java/okhttp3/WebSocket.java b/okhttp/src/main/java/okhttp3/WebSocket.java
index 35b02f2503..12457e535e 100644
--- a/okhttp/src/main/java/okhttp3/WebSocket.java
+++ b/okhttp/src/main/java/okhttp3/WebSocket.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
+ * Copyright (C) 2016 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,52 +15,101 @@
  */
 package okhttp3;
 
-import java.io.IOException;
 import okio.ByteString;
 
-/** Blocking interface to connect and write to a web socket. This class is not thread safe. */
+/**
+ * A non-blocking interface to a web socket. Use the {@linkplain WebSocket.Factory factory} to
+ * create instances; usually this is {@link OkHttpClient}.
+ *
+ * <h3>Web Socket Lifecycle</h3>
+ *
+ * Upon normal operation each web socket progresses through a sequence of states:
+ *
+ * <ul>
+ *   <li><strong>Connecting:</strong> the initial state of each web socket. Messages may be enqueued
+ *       but they won't be transmitted until the web socket is open.
+ *   <li><strong>Open:</strong> the web socket has been accepted by the remote peer and is fully
+ *       operational. Messages in either direction are enqueued for immediate transmission.
+ *   <li><strong>Closing:</strong> one of the peers on the web socket has initiated a graceful
+ *       shutdown. The web socket will continue to transmit already-enqueued messages but will
+ *       refuse to enqueue new ones.
+ *   <li><strong>Closed:</strong> the web socket has transmitted all of its messages and has
+ *       received all messages from the peer.
+ * </ul>
+ *
+ * Web sockets may fail due to HTTP upgrade problems, connectivity problems, or if either peer
+ * chooses to short-circuit the graceful shutdown process:
+ *
+ * <ul>
+ *   <li><strong>Canceled:</strong> the web socket connection failed. Messages that were
+ *       successfully enqueued by either peer may not have been transmitted to the other.
+ * </ul>
+ *
+ * Note that the state progression is independent for each peer. Arriving at a gracefully-closed
+ * state indicates that a peer has sent all of its outgoing messages and received all of its
+ * incoming messages. But it does not guarantee that the other peer will successfully receive all of
+ * its incoming messages.
+ */
 public interface WebSocket {
-  /** A {@link MediaType} indicating UTF-8 text frames should be used when sending the message. */
-  MediaType TEXT = MediaType.parse("application/vnd.okhttp.websocket+text; charset=utf-8");
-  /** A {@link MediaType} indicating binary frames should be used when sending the message. */
-  MediaType BINARY = MediaType.parse("application/vnd.okhttp.websocket+binary");
+  /** Returns the original request that initiated this web socket. */
+  Request request();
 
   /**
-   * Send a message to the server.
-   *
-   * @param message The message body. The {@linkplain RequestBody#contentType() content type} of
-   * must be either {@link #TEXT} or {@link #BINARY}.
-   * @throws IOException if unable to write the message. Clients must call {@link #close} when this
-   * happens to ensure resources are cleaned up.
-   * @throws IllegalStateException if this web socket was already closed.
+   * Returns the size in bytes of all messages enqueued to be transmitted to the server. This
+   * doesn't include framing overhead. It also doesn't include any bytes buffered by the operating
+   * system or network intermediaries. This method returns 0 if no messages are waiting
+   * in the queue. If may return a nonzero value after the web socket has been canceled; this
+   * indicates that enqueued messages were not transmitted.
    */
-  void message(RequestBody message) throws IOException;
+  long queueSize();
 
   /**
-   * Send a ping to the server.
+   * Attempts to enqueue {@code text} to be UTF-8 encoded and sent as a the data of a text (type
+   * {@code 0x1}) message.
+   *
+   * <p>This method returns true if the message was enqueued. Messages that would overflow the
+   * outgoing message buffer will be rejected and trigger a {@linkplain #close graceful shutdown} of
+   * this web socket. This method returns false in that case, and in any other case where this
+   * web socket is closing, closed, or canceled.
    *
-   * @param payload Ping payload which must not exceed 125 bytes. Use {@link ByteString#EMPTY} for
-   * no payload.
-   * @throws IOException if unable to write the ping.  Clients must call {@link #close} when this
-   * happens to ensure resources are cleaned up.
-   * @throws IllegalStateException if this web socket was already closed.
+   * <p>This method returns immediately.
    */
-  void ping(ByteString payload) throws IOException;
+  boolean send(String text);
 
   /**
-   * Send a close indicator to the server.
+   * Attempts to enqueue {@code bytes} to be sent as a the data of a binary (type {@code 0x2})
+   * message.
    *
-   * <p>The corresponding {@link WebSocketListener} will continue to get messages until its {@link
-   * WebSocketListener#onClose onClose()} method is called.
+   * <p>This method returns true if the message was enqueued. Messages that would overflow the
+   * outgoing message buffer will be rejected and trigger a {@linkplain #close graceful shutdown} of
+   * this web socket. This method returns false in that case, and in any other case where this
+   * web socket is closing, closed, or canceled.
    *
-   * <p>It is an error to call this method before calling close on an active writer. Calling this
-   * method more than once has no effect.
+   * <p>This method returns immediately.
+   */
+  boolean send(ByteString bytes);
+
+  /**
+   * Attempts to initiate a graceful shutdown of this web socket. Any already-enqueued messages will
+   * be transmitted before the close message is sent but subsequent calls to {@link #send} will
+   * return false and their messages will not be enqueued.
+   *
+   * <p>This returns true if a graceful shutdown was initiated by this call. It returns false and if
+   * a graceful shutdown was already underway or if the web socket is already closed or canceled.
    *
    * @param code Status code as defined by <a
    * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
    * @param reason Reason for shutting down or {@code null}.
-   * @throws IOException if unable to write the close message. Resources will still be freed.
-   * @throws IllegalStateException if this web socket was already closed.
    */
-  void close(int code, String reason) throws IOException;
+  boolean close(int code, String reason);
+
+  /**
+   * Immediately and violently release resources held by this web socket, discarding any enqueued
+   * messages. This does nothing if the web socket has already been closed or canceled.
+   */
+  void cancel();
+
+  interface Factory {
+    WebSocket newWebSocket(Request request, WebSocketListener listener);
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/WebSocketCall.java b/okhttp/src/main/java/okhttp3/WebSocketCall.java
deleted file mode 100644
index 3dc18bcba4..0000000000
--- a/okhttp/src/main/java/okhttp3/WebSocketCall.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-public interface WebSocketCall extends Cloneable {
-  /** Returns the original request that initiated this call. */
-  Request request();
-
-  /**
-   * Schedules the request to be executed at some point in the future.
-   *
-   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
-   * immediately unless there are several other requests currently being executed.
-   *
-   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
-   * failure exception. If you {@link #cancel} a request before it completes the callback will not
-   * be invoked.
-   *
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  void enqueue(WebSocketListener listener);
-
-  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
-  void cancel();
-
-  /**
-   * Returns true if this call has been {@linkplain #enqueue(WebSocketListener) enqueued}. It is an
-   * error to enqueue a call more than once.
-   */
-  boolean isExecuted();
-
-  boolean isCanceled();
-
-  /**
-   * Create a new, identical call to this one which can be enqueued even if this call has already
-   * been.
-   */
-  WebSocketCall clone();
-
-  interface Factory {
-    WebSocketCall newWebSocketCall(Request request);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/WebSocketListener.java b/okhttp/src/main/java/okhttp3/WebSocketListener.java
index 8d853f7d93..d46e916dd8 100644
--- a/okhttp/src/main/java/okhttp3/WebSocketListener.java
+++ b/okhttp/src/main/java/okhttp3/WebSocketListener.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
+ * Copyright (C) 2016 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,76 +15,40 @@
  */
 package okhttp3;
 
-import java.io.IOException;
 import okio.ByteString;
 
-/**
- * Listener for server-initiated messages on a connected {@link WebSocket}. All callbacks will be
- * called on a single thread.
- *
- * <h2>Lifecycle Rules</h2>
- * <ul>
- * <li>Either {@link #onOpen} or {@link #onFailure} will be called first depending on if the web
- * socket was successfully opened or if there was an error connecting to the server or parsing its
- * response.</li>
- * <li>After {@link #onOpen} is called, {@link #onFailure} can be called at any time. No more
- * callbacks will follow a call to {@link #onFailure}.</li>
- * <li>After {@link #onOpen} is called, {@link #onMessage} and {@link #onPong} will be called for
- * each message and pong frame, respectively. Note: {@link #onPong} may be called while {@link
- * #onMessage} is reading the message because pong frames may interleave in the message body.</li>
- * <li>After {@link #onOpen} is called, {@link #onClose} may be called once. No calls to {@link
- * #onMessage} or {@link #onPong} will follow a call to {@link #onClose}.</li>
- * <li>{@link #onFailure} will be called if any of the other callbacks throws an exception.</li>
- * </ul>
- */
-public interface WebSocketListener {
+public abstract class WebSocketListener {
   /**
-   * Called when the request has successfully been upgraded to a web socket. <b>Do not</b> use this
-   * callback to write to the web socket. Start a new thread or use another thread in your
-   * application.
+   * Invoked when a web socket has been accepted by the remote peer and may begin transmitting
+   * messages.
    */
-  void onOpen(WebSocket webSocket, Response response);
+  public void onOpen(WebSocket webSocket, Response response) {
+  }
 
-  /**
-   * Called when a server message is received. The {@code type} indicates whether the {@code
-   * payload} should be interpreted as UTF-8 text or binary data.
-   *
-   * <p>Implementations <strong>must</strong> call {@code source.close()} before returning. This
-   * indicates completion of parsing the message payload and will consume any remaining bytes in the
-   * message.
-   *
-   * <p>The {@linkplain ResponseBody#contentType() content type} of {@code message} will be either
-   * {@link WebSocket#TEXT} or {@link WebSocket#BINARY} which indicates the format of the message.
-   */
-  void onMessage(ResponseBody message) throws IOException;
+  /** Invoked when a text (type {@code 0x1}) message has been received. */
+  public void onMessage(WebSocket webSocket, String text) {
+  }
 
-  /**
-   * Called when a server pong is received. This is usually a result of calling {@link
-   * WebSocket#ping(ByteString)} but might also be unsolicited directly from the server.
-   */
-  void onPong(ByteString payload);
+  /** Invoked when a binary (type {@code 0x2}) message has been received. */
+  public void onMessage(WebSocket webSocket, ByteString bytes) {
+  }
+
+  /** Invoked when the peer has indicated that no more incoming messages will be transmitted. */
+  public void onClosing(WebSocket webSocket, int code, String reason) {
+  }
 
   /**
-   * Called when the server sends a close message. This may have been initiated from a call to
-   * {@link WebSocket#close(int, String) close()} or as an unprompted message from the server.
-   * If you did not explicitly call {@link WebSocket#close(int, String) close()}, you do not need
-   * to do so in response to this callback. A matching close frame is automatically sent back to
-   * the server.
-   *
-   * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC-compliant</a>
-   * status code.
-   * @param reason Reason for close or an empty string.
+   * Invoked when both peers have indicated that no more messages will be transmitted and the
+   * connection has been successfully released. No further calls to this listener will be made.
    */
-  void onClose(int code, String reason);
+  public void onClosed(WebSocket webSocket, int code, String reason) {
+  }
 
   /**
-   * Called when the transport or protocol layer of this web socket errors during communication, or
-   * when another listener callback throws an exception. If the web socket was successfully
-   * {@linkplain #onOpen opened} before this callback, it will have been closed automatically and
-   * future interactions with it will throw {@link IOException}.
-   *
-   * @param response Non-null when the failure is because of an unexpected HTTP response (e.g.,
-   * failed upgrade, non-101 response code, etc.).
+   * Invoked when a web socket has been closed due to an error reading from or writing to the
+   * network. Both outgoing and incoming messages may have been lost. No further calls to this
+   * listener will be made.
    */
-  void onFailure(Throwable t, Response response);
+  public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index 6a25d3cdf8..2610a44516 100644
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -19,11 +19,13 @@
 import java.net.UnknownHostException;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Address;
+import okhttp3.Call;
 import okhttp3.ConnectionPool;
 import okhttp3.ConnectionSpec;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
+import okhttp3.Request;
 import okhttp3.internal.cache.InternalCache;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
@@ -62,4 +64,8 @@ public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
 
   public abstract HttpUrl getHttpUrlChecked(String url)
       throws MalformedURLException, UnknownHostException;
+
+  public abstract StreamAllocation streamAllocation(Call call);
+
+  public abstract Call newWebSocketCall(OkHttpClient client, Request request);
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 3ce2d46868..28c0b79388 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -48,7 +48,7 @@
   public static final ResponseBody EMPTY_RESPONSE = ResponseBody.create(null, EMPTY_BYTE_ARRAY);
   public static final RequestBody EMPTY_REQUEST = RequestBody.create(null, EMPTY_BYTE_ARRAY);
 
-  private static final ByteString UTF_8_BOM = ByteString.decodeHex("efbbff");
+  private static final ByteString UTF_8_BOM = ByteString.decodeHex("efbbbf");
   private static final ByteString UTF_16_BE_BOM = ByteString.decodeHex("feff");
   private static final ByteString UTF_16_LE_BOM = ByteString.decodeHex("fffe");
   private static final ByteString UTF_32_BE_BOM = ByteString.decodeHex("0000ffff");
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
index 93eacedef4..dae556bb98 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -53,7 +53,7 @@
   /** The cached response to return or validate; or null if this call doesn't use a cache. */
   public final Response cacheResponse;
 
-  private CacheStrategy(Request networkRequest, Response cacheResponse) {
+  CacheStrategy(Request networkRequest, Response cacheResponse) {
     this.networkRequest = networkRequest;
     this.cacheResponse = cacheResponse;
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
index 4d3ef616ab..19c2321414 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
@@ -136,25 +136,25 @@
      * it exists when the cache is opened.
      */
 
-  private final FileSystem fileSystem;
-  private final File directory;
+  final FileSystem fileSystem;
+  final File directory;
   private final File journalFile;
   private final File journalFileTmp;
   private final File journalFileBackup;
   private final int appVersion;
   private long maxSize;
-  private final int valueCount;
+  final int valueCount;
   private long size = 0;
-  private BufferedSink journalWriter;
-  private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
-  private int redundantOpCount;
-  private boolean hasJournalErrors;
+  BufferedSink journalWriter;
+  final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
+  int redundantOpCount;
+  boolean hasJournalErrors;
 
   // Must be read and written when synchronized on 'this'.
-  private boolean initialized;
-  private boolean closed;
-  private boolean mostRecentTrimFailed;
-  private boolean mostRecentRebuildFailed;
+  boolean initialized;
+  boolean closed;
+  boolean mostRecentTrimFailed;
+  boolean mostRecentRebuildFailed;
 
   /**
    * To differentiate between old and current snapshots, each entry is given a sequence number each
@@ -381,7 +381,7 @@ private void processJournal() throws IOException {
    * Creates a new journal that omits redundant information. This replaces the current journal if it
    * exists.
    */
-  private synchronized void rebuildJournal() throws IOException {
+  synchronized void rebuildJournal() throws IOException {
     if (journalWriter != null) {
       journalWriter.close();
     }
@@ -452,7 +452,7 @@ public Editor edit(String key) throws IOException {
     return edit(key, ANY_SEQUENCE_NUMBER);
   }
 
-  private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
+  synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
     initialize();
 
     checkNotClosed();
@@ -524,7 +524,7 @@ public synchronized long size() throws IOException {
     return size;
   }
 
-  private synchronized void completeEdit(Editor editor, boolean success) throws IOException {
+  synchronized void completeEdit(Editor editor, boolean success) throws IOException {
     Entry entry = editor.entry;
     if (entry.currentEditor != editor) {
       throw new IllegalStateException();
@@ -588,7 +588,7 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
    * We only rebuild the journal when it will halve the size of the journal and eliminate at least
    * 2000 ops.
    */
-  private boolean journalRebuildRequired() {
+  boolean journalRebuildRequired() {
     final int redundantOpCompactThreshold = 2000;
     return redundantOpCount >= redundantOpCompactThreshold
         && redundantOpCount >= lruEntries.size();
@@ -612,7 +612,7 @@ public synchronized boolean remove(String key) throws IOException {
     return removed;
   }
 
-  private boolean removeEntry(Entry entry) throws IOException {
+  boolean removeEntry(Entry entry) throws IOException {
     if (entry.currentEditor != null) {
       entry.currentEditor.detach(); // Prevent the edit from completing normally.
     }
@@ -672,7 +672,7 @@ private synchronized void checkNotClosed() {
     closed = true;
   }
 
-  private void trimToSize() throws IOException {
+  void trimToSize() throws IOException {
     while (size > maxSize) {
       Entry toEvict = lruEntries.values().iterator().next();
       removeEntry(toEvict);
@@ -784,7 +784,7 @@ private void validateKey(String key) {
     private final Source[] sources;
     private final long[] lengths;
 
-    private Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
+    Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
       this.key = key;
       this.sequenceNumber = sequenceNumber;
       this.sources = sources;
@@ -822,11 +822,11 @@ public void close() {
 
   /** Edits the values for an entry. */
   public final class Editor {
-    private final Entry entry;
-    private final boolean[] written;
+    final Entry entry;
+    final boolean[] written;
     private boolean done;
 
-    private Editor(Entry entry) {
+    Editor(Entry entry) {
       this.entry = entry;
       this.written = (entry.readable) ? null : new boolean[valueCount];
     }
@@ -948,23 +948,23 @@ public void abortUnlessCommitted() {
   }
 
   private final class Entry {
-    private final String key;
+    final String key;
 
     /** Lengths of this entry's files. */
-    private final long[] lengths;
-    private final File[] cleanFiles;
-    private final File[] dirtyFiles;
+    final long[] lengths;
+    final File[] cleanFiles;
+    final File[] dirtyFiles;
 
     /** True if this entry has ever been published. */
-    private boolean readable;
+    boolean readable;
 
     /** The ongoing edit or null if this entry is not being edited. */
-    private Editor currentEditor;
+    Editor currentEditor;
 
     /** The sequence number of the most recently committed edit to this entry. */
-    private long sequenceNumber;
+    long sequenceNumber;
 
-    private Entry(String key) {
+    Entry(String key) {
       this.key = key;
 
       lengths = new long[valueCount];
@@ -984,7 +984,7 @@ private Entry(String key) {
     }
 
     /** Set lengths using decimal numbers like "10123". */
-    private void setLengths(String[] strings) throws IOException {
+    void setLengths(String[] strings) throws IOException {
       if (strings.length != valueCount) {
         throw invalidLengths(strings);
       }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
index b2db592d1e..5131e6cd16 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
@@ -61,28 +61,28 @@
    * <p>This is closed and assigned to null when the last source is closed and no further sources
    * are permitted.
    */
-  private RandomAccessFile file;
+  RandomAccessFile file;
 
   /** The thread that currently has access to upstream. Possibly null. Guarded by this. */
-  private Thread upstreamReader;
+  Thread upstreamReader;
 
   /**
    * Null once the file has a complete copy of the upstream bytes. Only the {@code upstreamReader}
    * thread may access this source.
    */
-  private Source upstream;
+  Source upstream;
 
   /**
    * A buffer for {@code upstreamReader} to use when pulling bytes from upstream. Only the {@code
    * upstreamReader} thread may access this buffer.
    */
-  private final Buffer upstreamBuffer = new Buffer();
+  final Buffer upstreamBuffer = new Buffer();
 
   /** The number of bytes consumed from {@link #upstream}. Guarded by this. */
-  private long upstreamPos;
+  long upstreamPos;
 
   /** True if there are no further bytes to read from {@code upstream}. Guarded by this. */
-  private boolean complete;
+  boolean complete;
 
   /** User-supplied additional data persisted with the source data. */
   private final ByteString metadata;
@@ -91,17 +91,17 @@
    * The most recently read bytes from {@link #upstream}. This is a suffix of {@link #file}. Guarded
    * by this.
    */
-  private final Buffer buffer = new Buffer();
+  final Buffer buffer = new Buffer();
 
   /** The maximum size of {@code buffer}. */
-  private final long bufferMaxSize;
+  final long bufferMaxSize;
 
   /**
    * Reference count of the number of active sources reading this stream. When decremented to 0
    * resources are released and all following calls to {@link #newSource} return null. Guarded by
    * this.
    */
-  private int sourceCount;
+  int sourceCount;
 
   private Relay(RandomAccessFile file, Source upstream, long upstreamPos, ByteString metadata,
       long bufferMaxSize) {
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 73b2506f62..b78e3c54b1 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -28,6 +28,7 @@
 import okhttp3.internal.http1.Http1Codec;
 import okhttp3.internal.http2.ErrorCode;
 import okhttp3.internal.http2.Http2Codec;
+import okhttp3.internal.http2.ConnectionShutdownException;
 import okhttp3.internal.http2.StreamResetException;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -298,7 +299,8 @@ public void streamFailed(IOException e) {
           noNewStreams = true;
           route = null;
         }
-      } else if (connection != null && !connection.isMultiplexed()) {
+      } else if (connection != null && !connection.isMultiplexed()
+          || e instanceof ConnectionShutdownException) {
         noNewStreams = true;
 
         // If this route hasn't completed a call, avoid it for new connections.
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 2a7cd13822..792ddc9299 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -38,6 +38,7 @@
 import okhttp3.Route;
 import okhttp3.internal.connection.RouteException;
 import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.http2.ConnectionShutdownException;
 
 import static java.net.HttpURLConnection.HTTP_CLIENT_TIMEOUT;
 import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
@@ -120,12 +121,15 @@ public StreamAllocation streamAllocation() {
         releaseConnection = false;
       } catch (RouteException e) {
         // The attempt to connect via a route failed. The request will not have been sent.
-        if (!recover(e.getLastConnectException(), true, request)) throw e.getLastConnectException();
+        if (!recover(e.getLastConnectException(), false, request)) {
+          throw e.getLastConnectException();
+        }
         releaseConnection = false;
         continue;
       } catch (IOException e) {
         // An attempt to communicate with a server failed. The request may have been sent.
-        if (!recover(e, false, request)) throw e;
+        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
+        if (!recover(e, requestSendStarted, request)) throw e;
         releaseConnection = false;
         continue;
       } finally {
@@ -198,19 +202,20 @@ private Address createAddress(HttpUrl url) {
   /**
    * Report and attempt to recover from a failure to communicate with a server. Returns true if
    * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only
-   * be recovered if the body is buffered.
+   * be recovered if the body is buffered or if the failure occurred before the request has been
+   * sent.
    */
-  private boolean recover(IOException e, boolean routeException, Request userRequest) {
+  private boolean recover(IOException e, boolean requestSendStarted, Request userRequest) {
     streamAllocation.streamFailed(e);
 
     // The application layer has forbidden retries.
     if (!client.retryOnConnectionFailure()) return false;
 
     // We can't send the request body again.
-    if (!routeException && userRequest.body() instanceof UnrepeatableRequestBody) return false;
+    if (requestSendStarted && userRequest.body() instanceof UnrepeatableRequestBody) return false;
 
     // This exception is fatal.
-    if (!isRecoverable(e, routeException)) return false;
+    if (!isRecoverable(e, requestSendStarted)) return false;
 
     // No more routes to attempt.
     if (!streamAllocation.hasMoreRoutes()) return false;
@@ -219,7 +224,7 @@ private boolean recover(IOException e, boolean routeException, Request userReque
     return true;
   }
 
-  private boolean isRecoverable(IOException e, boolean routeException) {
+  private boolean isRecoverable(IOException e, boolean requestSendStarted) {
     // If there was a protocol problem, don't recover.
     if (e instanceof ProtocolException) {
       return false;
@@ -228,7 +233,7 @@ private boolean isRecoverable(IOException e, boolean routeException) {
     // If there was an interruption don't recover, but if there was a timeout connecting to a route
     // we should try the next route (if there is one).
     if (e instanceof InterruptedIOException) {
-      return e instanceof SocketTimeoutException && routeException;
+      return e instanceof SocketTimeoutException && !requestSendStarted;
     }
 
     // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 3df3696e1f..dc2dd1791e 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -76,13 +76,13 @@
   private static final int STATE_CLOSED = 6;
 
   /** The client that configures this stream. May be null for HTTPS proxy tunnels. */
-  private final OkHttpClient client;
+  final OkHttpClient client;
   /** The stream allocation that owns this stream. May be null for HTTPS proxy tunnels. */
-  private final StreamAllocation streamAllocation;
+  final StreamAllocation streamAllocation;
 
-  private final BufferedSource source;
-  private final BufferedSink sink;
-  private int state = STATE_IDLE;
+  final BufferedSource source;
+  final BufferedSink sink;
+  int state = STATE_IDLE;
 
   public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
       BufferedSink sink) {
@@ -256,7 +256,7 @@ public Source newUnknownLengthSource() throws IOException {
    * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
    * connections.
    */
-  private void detachTimeout(ForwardingTimeout timeout) {
+  void detachTimeout(ForwardingTimeout timeout) {
     Timeout oldDelegate = timeout.delegate();
     timeout.setDelegate(Timeout.NONE);
     oldDelegate.clearDeadline();
@@ -269,7 +269,7 @@ private void detachTimeout(ForwardingTimeout timeout) {
     private boolean closed;
     private long bytesRemaining;
 
-    private FixedLengthSink(long bytesRemaining) {
+    FixedLengthSink(long bytesRemaining) {
       this.bytesRemaining = bytesRemaining;
     }
 
@@ -310,6 +310,9 @@ private FixedLengthSink(long bytesRemaining) {
     private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
     private boolean closed;
 
+    ChunkedSink() {
+    }
+
     @Override public Timeout timeout() {
       return timeout;
     }
@@ -468,6 +471,9 @@ private void readChunkSize() throws IOException {
   private class UnknownLengthSource extends AbstractSource {
     private boolean inputExhausted;
 
+    UnknownLengthSource() {
+    }
+
     @Override public long read(Buffer sink, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java b/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java
new file mode 100644
index 0000000000..00c4f2441c
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2;
+
+import java.io.IOException;
+
+/**
+ * Thrown when an HTTP/2 connection is shutdown (either explicitly or if the peer has sent a GOAWAY
+ * frame) and an attempt is made to use the connection.
+ */
+public final class ConnectionShutdownException extends IOException {
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
index 3aeed262b4..a28698bf01 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
@@ -44,7 +44,7 @@
   private static final int PREFIX_6_BITS = 0x3f;
   private static final int PREFIX_7_BITS = 0x7f;
 
-  private static final Header[] STATIC_HEADER_TABLE = new Header[] {
+  static final Header[] STATIC_HEADER_TABLE = new Header[] {
       new Header(Header.TARGET_AUTHORITY, ""),
       new Header(Header.TARGET_METHOD, "GET"),
       new Header(Header.TARGET_METHOD, "POST"),
@@ -346,7 +346,7 @@ ByteString readByteString() throws IOException {
     }
   }
 
-  private static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
+  static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
 
   private static Map<ByteString, Integer> nameToFirstIndex() {
     Map<ByteString, Integer> result = new LinkedHashMap<>(STATIC_HEADER_TABLE.length);
@@ -587,7 +587,7 @@ private void adjustDynamicTableByteCount() {
    * An HTTP/2 response cannot contain uppercase header characters and must be treated as
    * malformed.
    */
-  private static ByteString checkLowercase(ByteString name) throws IOException {
+  static ByteString checkLowercase(ByteString name) throws IOException {
     for (int i = 0, length = name.size(); i < length; i++) {
       byte c = name.getByte(i);
       if (c >= 'A' && c <= 'Z') {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
index c2e0a38582..abd4b5ef3c 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -31,7 +31,6 @@
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.StreamAllocation;
 import okhttp3.internal.http.HttpCodec;
-import okhttp3.internal.http.HttpMethod;
 import okhttp3.internal.http.RealResponseBody;
 import okhttp3.internal.http.RequestLine;
 import okhttp3.internal.http.StatusLine;
@@ -83,7 +82,7 @@
       UPGRADE);
 
   private final OkHttpClient client;
-  private final StreamAllocation streamAllocation;
+  final StreamAllocation streamAllocation;
   private final Http2Connection connection;
   private Http2Stream stream;
 
@@ -101,9 +100,9 @@ public Http2Codec(
   @Override public void writeRequestHeaders(Request request) throws IOException {
     if (stream != null) return;
 
-    boolean permitsRequestBody = HttpMethod.permitsRequestBody(request.method());
+    boolean hasRequestBody = request.body() != null;
     List<Header> requestHeaders = http2HeadersList(request);
-    stream = connection.newStream(requestHeaders, permitsRequestBody);
+    stream = connection.newStream(requestHeaders, hasRequestBody);
     stream.readTimeout().timeout(client.readTimeoutMillis(), TimeUnit.MILLISECONDS);
     stream.writeTimeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index daf1b78671..71f4d19b5a 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -66,7 +66,7 @@
   // operations must synchronize on 'this' last. This ensures that we never
   // wait for a blocking operation while holding 'this'.
 
-  private static final ExecutorService executor = new ThreadPoolExecutor(0,
+  static final ExecutorService executor = new ThreadPoolExecutor(0,
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
       Util.threadFactory("OkHttp FramedConnection", true));
 
@@ -77,12 +77,12 @@
    * User code to run in response to incoming streams or settings. Calls to this are always invoked
    * on {@link #executor}.
    */
-  private final Listener listener;
-  private final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
-  private final String hostname;
-  private int lastGoodStreamId;
-  private int nextStreamId;
-  private boolean shutdown;
+  final Listener listener;
+  final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
+  final String hostname;
+  int lastGoodStreamId;
+  int nextStreamId;
+  boolean shutdown;
 
   /** Ensures push promise callbacks events are sent in order per stream. */
   private final ExecutorService pushExecutor;
@@ -90,7 +90,7 @@
   /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
   private Map<Integer, Ping> pings;
   /** User code to run in response to push promise events. */
-  private final PushObserver pushObserver;
+  final PushObserver pushObserver;
   private int nextPingId;
 
   /**
@@ -115,14 +115,14 @@
   // TODO: MWS will need to guard on this setting before attempting to push.
   final Settings peerSettings = new Settings();
 
-  private boolean receivedInitialPeerSettings = false;
+  boolean receivedInitialPeerSettings = false;
   final Socket socket;
   final Http2Writer writer;
 
   // Visible for testing
   final ReaderRunnable readerRunnable;
 
-  private Http2Connection(Builder builder) {
+  Http2Connection(Builder builder) {
     pushObserver = builder.pushObserver;
     client = builder.client;
     listener = builder.listener;
@@ -216,7 +216,7 @@ private Http2Stream newStream(
     synchronized (writer) {
       synchronized (this) {
         if (shutdown) {
-          throw new IOException("shutdown");
+          throw new ConnectionShutdownException();
         }
         streamId = nextStreamId;
         nextStreamId += 2;
@@ -335,7 +335,7 @@ public Ping ping() throws IOException {
     int pingId;
     synchronized (this) {
       if (shutdown) {
-        throw new IOException("shutdown");
+        throw new ConnectionShutdownException();
       }
       pingId = nextPingId;
       nextPingId += 2;
@@ -346,7 +346,7 @@ public Ping ping() throws IOException {
     return ping;
   }
 
-  private void writePingLater(
+  void writePingLater(
       final boolean reply, final int payload1, final int payload2, final Ping ping) {
     executor.execute(new NamedRunnable("OkHttp %s ping %08x%08x",
         hostname, payload1, payload2) {
@@ -359,7 +359,7 @@ private void writePingLater(
     });
   }
 
-  private void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
+  void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
     synchronized (writer) {
       // Observe the sent time immediately before performing I/O.
       if (ping != null) ping.send();
@@ -367,7 +367,7 @@ private void writePing(boolean reply, int payload1, int payload2, Ping ping) thr
     }
   }
 
-  private synchronized Ping removePing(int id) {
+  synchronized Ping removePing(int id) {
     return pings != null ? pings.remove(id) : null;
   }
 
@@ -404,7 +404,7 @@ public void shutdown(ErrorCode statusCode) throws IOException {
     close(ErrorCode.NO_ERROR, ErrorCode.CANCEL);
   }
 
-  private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
+  void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
     assert (!Thread.holdsLock(this));
     IOException thrown = null;
     try {
@@ -488,7 +488,7 @@ public void setSettings(Settings settings) throws IOException {
     synchronized (writer) {
       synchronized (this) {
         if (shutdown) {
-          throw new IOException("shutdown");
+          throw new ConnectionShutdownException();
         }
         okHttpSettings.merge(settings);
         writer.settings(settings);
@@ -501,13 +501,13 @@ public synchronized boolean isShutdown() {
   }
 
   public static class Builder {
-    private Socket socket;
-    private String hostname;
-    private BufferedSource source;
-    private BufferedSink sink;
-    private Listener listener = Listener.REFUSE_INCOMING_STREAMS;
-    private PushObserver pushObserver = PushObserver.CANCEL;
-    private boolean client;
+    Socket socket;
+    String hostname;
+    BufferedSource source;
+    BufferedSink sink;
+    Listener listener = Listener.REFUSE_INCOMING_STREAMS;
+    PushObserver pushObserver = PushObserver.CANCEL;
+    boolean client;
 
     /**
      * @param client true if this peer initiated the connection; false if this peer accepted the
@@ -553,7 +553,7 @@ public Http2Connection build() throws IOException {
   class ReaderRunnable extends NamedRunnable implements Http2Reader.Handler {
     final Http2Reader reader;
 
-    private ReaderRunnable(Http2Reader reader) {
+    ReaderRunnable(Http2Reader reader) {
       super("OkHttp %s", hostname);
       this.reader = reader;
     }
@@ -771,14 +771,14 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
   }
 
   /** Even, positive numbered streams are pushed streams in HTTP/2. */
-  private boolean pushedStream(int streamId) {
+  boolean pushedStream(int streamId) {
     return streamId != 0 && (streamId & 1) == 0;
   }
 
   // Guarded by this.
-  private final Set<Integer> currentPushRequests = new LinkedHashSet<>();
+  final Set<Integer> currentPushRequests = new LinkedHashSet<>();
 
-  private void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
+  void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
     synchronized (this) {
       if (currentPushRequests.contains(streamId)) {
         writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
@@ -802,7 +802,7 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
     });
   }
 
-  private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
+  void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
       final boolean inFinished) {
     pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostname, streamId) {
       @Override public void execute() {
@@ -824,7 +824,7 @@ private void pushHeadersLater(final int streamId, final List<Header> requestHead
    * Eagerly reads {@code byteCount} bytes from the source before launching a background task to
    * process the data.  This avoids corrupting the stream.
    */
-  private void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
+  void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
       final boolean inFinished) throws IOException {
     final Buffer buffer = new Buffer();
     source.require(byteCount); // Eagerly read the frame before firing client thread.
@@ -846,7 +846,7 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
     });
   }
 
-  private void pushResetLater(final int streamId, final ErrorCode errorCode) {
+  void pushResetLater(final int streamId, final ErrorCode errorCode) {
     pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostname, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
index a2d9e63678..8caed4f92b 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
@@ -57,7 +57,7 @@
  * Http2#INITIAL_MAX_FRAME_SIZE}.
  */
 final class Http2Reader implements Closeable {
-  private static final Logger logger = Logger.getLogger(Http2.class.getName());
+  static final Logger logger = Logger.getLogger(Http2.class.getName());
 
   private final BufferedSource source;
   private final ContinuationSource continuation;
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
index 5997b21288..3d036860a2 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -48,8 +48,8 @@
   // guarded by this
   long bytesLeftInWriteWindow;
 
-  private final int id;
-  private final Http2Connection connection;
+  final int id;
+  final Http2Connection connection;
 
   /** Headers sent by the stream initiator. Immutable and non null. */
   private final List<Header> requestHeaders;
@@ -59,15 +59,15 @@
 
   private final FramedDataSource source;
   final FramedDataSink sink;
-  private final StreamTimeout readTimeout = new StreamTimeout();
-  private final StreamTimeout writeTimeout = new StreamTimeout();
+  final StreamTimeout readTimeout = new StreamTimeout();
+  final StreamTimeout writeTimeout = new StreamTimeout();
 
   /**
    * The reason why this stream was abnormally closed. If there are multiple reasons to abnormally
    * close this stream (such as both peers closing it near-simultaneously) then this is the first
    * reason known to this peer.
    */
-  private ErrorCode errorCode = null;
+  ErrorCode errorCode = null;
 
   Http2Stream(int id, Http2Connection connection, boolean outFinished, boolean inFinished,
       List<Header> requestHeaders) {
@@ -308,15 +308,15 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     private final long maxByteCount;
 
     /** True if the caller has closed this stream. */
-    private boolean closed;
+    boolean closed;
 
     /**
      * True if either side has cleanly shut down this stream. We will receive no more bytes beyond
      * those already in the buffer.
      */
-    private boolean finished;
+    boolean finished;
 
-    private FramedDataSource(long maxByteCount) {
+    FramedDataSource(long maxByteCount) {
       this.maxByteCount = maxByteCount;
     }
 
@@ -430,7 +430,7 @@ private void checkNotClosed() throws IOException {
     }
   }
 
-  private void cancelStreamIfNecessary() throws IOException {
+  void cancelStreamIfNecessary() throws IOException {
     assert (!Thread.holdsLock(Http2Stream.this));
     boolean open;
     boolean cancel;
@@ -461,12 +461,12 @@ private void cancelStreamIfNecessary() throws IOException {
      */
     private final Buffer sendBuffer = new Buffer();
 
-    private boolean closed;
+    boolean closed;
 
     /**
      * True if either side has cleanly shut down this stream. We shall send no more bytes.
      */
-    private boolean finished;
+    boolean finished;
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
       assert (!Thread.holdsLock(Http2Stream.this));
@@ -552,7 +552,7 @@ void addBytesToWriteWindow(long delta) {
     if (delta > 0) Http2Stream.this.notifyAll();
   }
 
-  private void checkOutNotClosed() throws IOException {
+  void checkOutNotClosed() throws IOException {
     if (sink.closed) {
       throw new IOException("stream closed");
     } else if (sink.finished) {
@@ -566,7 +566,7 @@ private void checkOutNotClosed() throws IOException {
    * Like {@link #wait}, but throws an {@code InterruptedIOException} when interrupted instead of
    * the more awkward {@link InterruptedException}.
    */
-  private void waitForIo() throws InterruptedIOException {
+  void waitForIo() throws InterruptedIOException {
     try {
       wait();
     } catch (InterruptedException e) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java b/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
index 32582e9f40..7aa8024b72 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Huffman.java
@@ -196,13 +196,13 @@ private void addCode(int sym, int code, byte len) {
   private static final class Node {
 
     // Null if terminal.
-    private final Node[] children;
+    final Node[] children;
 
     // Terminal nodes have a symbol.
-    private final int symbol;
+    final int symbol;
 
     // Number of bits represented in the terminal node.
-    private final int terminalBits;
+    final int terminalBits;
 
     /** Construct an internal node. */
     Node() {
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
index 3d092b5cc2..6821bdf497 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
@@ -106,9 +106,9 @@ public static Platform buildIfSupported() {
     /** This peer's supported protocols. */
     private final List<String> protocols;
     /** Set when remote peer notifies ALPN is unsupported. */
-    private boolean unsupported;
+    boolean unsupported;
     /** The protocol the server selected. */
-    private String selected;
+    String selected;
 
     public JettyNegoProvider(List<String> protocols) {
       this.protocols = protocols;
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
index 8c360d8025..4fa547b2aa 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
+ * Copyright (C) 2016 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,329 +15,565 @@
  */
 package okhttp3.internal.ws;
 
+import java.io.Closeable;
 import java.io.IOException;
 import java.net.ProtocolException;
+import java.util.ArrayDeque;
+import java.util.Collections;
+import java.util.List;
 import java.util.Random;
-import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicBoolean;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.ResponseBody;
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
-import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
-import okhttp3.internal.platform.Platform;
+import okhttp3.internal.connection.StreamAllocation;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Okio;
 
-import static okhttp3.internal.platform.Platform.INFO;
-import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_ABNORMAL_TERMINATION;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_CLIENT_GOING_AWAY;
-import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_PROTOCOL_EXCEPTION;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_MESSAGE_MAX;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
-import static okhttp3.internal.ws.WebSocketReader.FrameCallback;
+import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
 
-/**
- * An implementation of {@link WebSocket} which sits on top of {@link WebSocketReader} and
- * {@link WebSocketWriter}.
- *
- * <h2>Threading</h2>
- * This class deals with three threads concurrently and care must be taken to only access the
- * appropriate resources on each:
- * <ul>
- * <li><b>Reader</b>: This is the only thread allowed to access {@link #reader}. Methods from
- * {@link FrameCallback} will happen on this thread as a result. This is the only thread that
- * should invoke methods on the {@link #readerListener}.</li>
- * <li><b>Replier</b>: Invoked on {@link #replier} to write responses from reading
- * frames. Contends with the "Sender" thread for access to {@link #writer}.</li>
- * <li><b>Sender</b>: Methods from {@link WebSocket} will happen on this thread. Contends with the
- * "Replier" thread</li>
- * </ul>
- * Instance variables have prefixes matching the thread names based on the thread on which they can
- * be accessed. A prefix of "writer" indicates both "Sender" and "Replier" threads can access.
- */
-public abstract class RealWebSocket implements WebSocket, FrameCallback {
-  private final WebSocketReader reader;
-  private final WebSocketListener readerListener;
-  /** True after a close frame was read by the reader. No frames will follow it. */
-  private boolean readerSawClose;
+public final class RealWebSocket implements WebSocket, WebSocketReader.FrameCallback {
+  private static final List<Protocol> ONLY_HTTP1 = Collections.singletonList(Protocol.HTTP_1_1);
+
+  /**
+   * The maximum number of bytes to enqueue. Rather than enqueueing beyond this limit we tear down
+   * the web socket! It's possible that we're writing faster than the peer can read.
+   */
+  private static final long MAX_QUEUE_SIZE = 16 * 1024 * 1024; // 16 MiB.
+
+  /**
+   * The maximum amount of time after the client calls {@link #close} to wait for a graceful
+   * shutdown. If the server doesn't respond the websocket will be canceled.
+   */
+  private static final long CANCEL_AFTER_CLOSE_MILLIS = 60 * 1000;
+
+  /** The application's original request unadulterated by web socket headers. */
+  private final Request originalRequest;
 
-  final WebSocketWriter writer;
-  /** True after calling {@link WebSocketWriter#writeClose(int, String)} to send a close frame. */
-  final AtomicBoolean writerClosed = new AtomicBoolean();
+  final WebSocketListener listener;
+  private final Random random;
+  private final String key;
+
+  /** Non-null for client web sockets. These can be canceled. */
+  private Call call;
+
+  /** This runnable processes the outgoing queues. Call {@link #runWriter()} to after enqueueing. */
+  private final Runnable writerRunnable;
+
+  /** Null until this web socket is connected. Only accessed by the reader thread. */
+  private WebSocketReader reader;
+
+  // All mutable web socket state is guarded by this.
+
+  /** Null until this web socket is connected. Note that messages may be enqueued before that. */
+  private WebSocketWriter writer;
+
+  /** Null until this web socket is connected. Used for writes, pings, and close timeouts. */
+  private ScheduledExecutorService executor;
+
+  /**
+   * The streams held by this web socket. This is non-null until all incoming messages have been
+   * read and all outgoing messages have been written. It is closed when both reader and writer are
+   * exhausted, or if there is any failure.
+   */
+  private Streams streams;
 
-  /** Guarded by itself. Must check {@link #isShutdown} before enqueuing work. */
-  private final Executor replier;
+  /** Outgoing pongs in the order they should be written. */
+  private final ArrayDeque<ByteString> pongQueue = new ArrayDeque<>();
 
-  /** True after calling {@link #close(int, String)}. No writes are allowed afterward. */
-  private boolean senderSentClose;
-  /** True after {@link IOException}. {@link #close(int, String)} becomes only valid call. */
-  private boolean senderWantsClose;
+  /** Outgoing messages and close frames in the order they should be written. */
+  private final ArrayDeque<Object> messageAndCloseQueue = new ArrayDeque<>();
 
-  private final Response response;
-  private final String name;
+  /** The total size in bytes of enqueued but not yet transmitted messages. */
+  private long queueSize;
+
+  /** True if we've enqueued a close frame. No further message frames will be enqueued. */
+  private boolean enqueuedClose;
+
+  /**
+   * When executed this will cancel this websocket. This future itself should be canceled if that is
+   * unnecessary because the web socket is already closed or canceled.
+   */
+  private ScheduledFuture<?> cancelFuture;
+
+  /** The close code from the peer, or -1 if this web socket has not yet read a close frame. */
+  private int receivedCloseCode = -1;
+
+  /** The close reason from the peer, or null if this web socket has not yet read a close frame. */
+  private String receivedCloseReason;
+
+  /** True if this web socket failed and the listener has been notified. */
+  private boolean failed;
+
+  /** For testing. */
+  int pingCount;
+
+  /** For testing. */
+  int pongCount;
+
+  public RealWebSocket(Request request, WebSocketListener listener, Random random) {
+    if (!"GET".equals(request.method())) {
+      throw new IllegalArgumentException("Request must be GET: " + request.method());
+    }
+    this.originalRequest = request;
+    this.listener = listener;
+    this.random = random;
+
+    byte[] nonce = new byte[16];
+    random.nextBytes(nonce);
+    this.key = ByteString.of(nonce).base64();
+
+    this.writerRunnable = new Runnable() {
+      @Override public void run() {
+        try {
+          while (writeOneFrame()) {
+          }
+        } catch (IOException e) {
+          failWebSocket(e, null);
+        }
+      }
+    };
+  }
 
-  /** The thread looping the reader. Will become null when looping stops for any reason. */
-  private volatile Thread looperThread;
-  /** Guarded by {@link #replier}. True after calling {@link #shutdown()}. */
-  private boolean isShutdown;
+  @Override public Request request() {
+    return originalRequest;
+  }
 
-  protected RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random,
-      Executor replier, WebSocketListener readerListener, Response response, String name) {
-    this.readerListener = readerListener;
-    this.replier = replier;
-    this.response = response;
-    this.name = name;
+  @Override public synchronized long queueSize() {
+    return queueSize;
+  }
 
-    reader = new WebSocketReader(isClient, source, this);
-    writer = new WebSocketWriter(isClient, sink, random);
+  @Override public void cancel() {
+    call.cancel();
   }
 
-  ////// READER THREAD
+  public void connect(OkHttpClient client) {
+    client = client.newBuilder()
+        .protocols(ONLY_HTTP1)
+        .build();
+    final int pingIntervalMillis = client.pingIntervalMillis();
+    final Request request = originalRequest.newBuilder()
+        .header("Upgrade", "websocket")
+        .header("Connection", "Upgrade")
+        .header("Sec-WebSocket-Key", key)
+        .header("Sec-WebSocket-Version", "13")
+        .build();
+    call = Internal.instance.newWebSocketCall(client, request);
+    call.enqueue(new Callback() {
+      @Override public void onResponse(Call call, Response response) {
+        try {
+          checkResponse(response);
+        } catch (ProtocolException e) {
+          failWebSocket(e, response);
+          closeQuietly(response);
+          return;
+        }
 
-  /** Read and process all socket messages delivering callbacks to the supplied listener. */
-  public final void loopReader() {
-    looperThread = Thread.currentThread();
+        // Promote the HTTP streams into web socket streams.
+        StreamAllocation streamAllocation = Internal.instance.streamAllocation(call);
+        streamAllocation.noNewStreams(); // Prevent connection pooling!
+        Streams streams = new ClientStreams(streamAllocation);
 
-    try {
-      try {
-        readerListener.onOpen(this, response);
-      } catch (Throwable t) {
-        Util.throwIfFatal(t);
-        replyToReaderError(t);
-        readerListener.onFailure(t, null);
-        return;
+        // Process all web socket messages.
+        try {
+          listener.onOpen(RealWebSocket.this, response);
+          String name = "OkHttp WebSocket " + request.url().redact();
+          initReaderAndWriter(name, pingIntervalMillis, streams);
+          streamAllocation.connection().socket().setSoTimeout(0);
+          loopReader();
+        } catch (Exception e) {
+          failWebSocket(e, null);
+        }
       }
 
-      while (processNextFrame()) {
+      @Override public void onFailure(Call call, IOException e) {
+        failWebSocket(e, null);
       }
-    } finally {
-      looperThread = null;
+    });
+  }
+
+  void checkResponse(Response response) throws ProtocolException {
+    if (response.code() != 101) {
+      throw new ProtocolException("Expected HTTP 101 response but was '"
+          + response.code() + " " + response.message() + "'");
+    }
+
+    String headerConnection = response.header("Connection");
+    if (!"Upgrade".equalsIgnoreCase(headerConnection)) {
+      throw new ProtocolException("Expected 'Connection' header value 'Upgrade' but was '"
+          + headerConnection + "'");
+    }
+
+    String headerUpgrade = response.header("Upgrade");
+    if (!"websocket".equalsIgnoreCase(headerUpgrade)) {
+      throw new ProtocolException(
+          "Expected 'Upgrade' header value 'websocket' but was '" + headerUpgrade + "'");
+    }
+
+    String headerAccept = response.header("Sec-WebSocket-Accept");
+    String acceptExpected = ByteString.encodeUtf8(key + WebSocketProtocol.ACCEPT_MAGIC)
+        .sha1().base64();
+    if (!acceptExpected.equals(headerAccept)) {
+      throw new ProtocolException("Expected 'Sec-WebSocket-Accept' header value '"
+          + acceptExpected + "' but was '" + headerAccept + "'");
+    }
+  }
+
+  public void initReaderAndWriter(
+      String name, long pingIntervalMillis, Streams streams) throws IOException {
+    synchronized (this) {
+      this.streams = streams;
+      this.writer = new WebSocketWriter(streams.client, streams.sink, random);
+      this.executor = new ScheduledThreadPoolExecutor(1, Util.threadFactory(name, false));
+      if (pingIntervalMillis != 0) {
+        executor.scheduleAtFixedRate(
+            new PingRunnable(), pingIntervalMillis, pingIntervalMillis, MILLISECONDS);
+      }
+      if (!messageAndCloseQueue.isEmpty()) {
+        runWriter(); // Send messages that were enqueued before we were connected.
+      }
+    }
+
+    reader = new WebSocketReader(streams.client, streams.source, this);
+  }
+
+  /** Receive frames until there are no more. Invoked only by the reader thread. */
+  public void loopReader() throws IOException {
+    while (receivedCloseCode == -1) {
+      // This method call results in one or more onRead* methods being called on this thread.
+      reader.processNextFrame();
     }
   }
 
   /**
-   * Read a single control frame or all frames of a message from the web socket and deliver any
-   * notifications to the listener. Returns false when no more messages can be read.
+   * For testing: receive a single frame and return true if there are more frames to read. Invoked
+   * only by the reader thread.
    */
-  final boolean processNextFrame() {
+  boolean processNextFrame() throws IOException {
     try {
-      // This method call results in one or more onRead* methods being called on this thread.
       reader.processNextFrame();
-
-      return !readerSawClose;
-    } catch (Throwable t) {
-      Util.throwIfFatal(t);
-      replyToReaderError(t);
-      if (t instanceof IOException && !(t instanceof ProtocolException)) {
-        readerListener.onClose(CLOSE_ABNORMAL_TERMINATION, "");
-      } else {
-        readerListener.onFailure(t, null);
-      }
+      return receivedCloseCode == -1;
+    } catch (Exception e) {
+      failWebSocket(e, null);
       return false;
     }
   }
 
-  @Override public final void onReadMessage(ResponseBody message) throws IOException {
-    readerListener.onMessage(message);
+  synchronized int pingCount() {
+    return pingCount;
   }
 
-  @Override public final void onReadPing(ByteString buffer) {
-    replyToPeerPing(buffer);
+  synchronized int pongCount() {
+    return pongCount;
   }
 
-  @Override public final void onReadPong(ByteString buffer) {
-    readerListener.onPong(buffer);
+  @Override public void onReadMessage(String text) throws IOException {
+    listener.onMessage(this, text);
   }
 
-  @Override public final void onReadClose(int code, String reason) {
-    replyToPeerClose(code, reason);
-    readerSawClose = true;
-    readerListener.onClose(code, reason);
+  @Override public void onReadMessage(ByteString bytes) throws IOException {
+    listener.onMessage(this, bytes);
   }
 
-  ///// REPLIER THREAD (executed on replier, contends with sender thread)
+  @Override public synchronized void onReadPing(ByteString payload) {
+    // Don't respond to pings after we've failed or sent the close frame.
+    if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty())) return;
 
-  /** Replies with a pong when a ping frame is read from the peer. */
-  private void replyToPeerPing(final ByteString payload) {
-    Runnable replierPong = new NamedRunnable("OkHttp %s WebSocket Pong Reply", name) {
-      @Override protected void execute() {
-        try {
-          writer.writePong(payload);
-        } catch (IOException t) {
-          Platform.get().log(INFO, "Unable to send pong reply in response to peer ping.", t);
-        }
+    pongQueue.add(payload);
+    runWriter();
+    pingCount++;
+  }
+
+  @Override public synchronized void onReadPong(ByteString buffer) {
+    // This API doesn't expose pings.
+    pongCount++;
+  }
+
+  @Override public void onReadClose(int code, String reason) {
+    if (code == -1) throw new IllegalArgumentException();
+
+    Streams toClose = null;
+    synchronized (this) {
+      if (receivedCloseCode != -1) throw new IllegalStateException("already closed");
+      receivedCloseCode = code;
+      receivedCloseReason = reason;
+      if (enqueuedClose && messageAndCloseQueue.isEmpty()) {
+        toClose = this.streams;
+        this.streams = null;
+        if (cancelFuture != null) cancelFuture.cancel(false);
+        this.executor.shutdown();
       }
-    };
-    synchronized (replier) {
-      if (!isShutdown) {
-        replier.execute(replierPong);
+    }
+
+    try {
+      listener.onClosing(this, code, reason);
+
+      if (toClose != null) {
+        listener.onClosed(this, code, reason);
       }
+    } finally {
+      closeQuietly(toClose);
     }
   }
 
-  /** Replies and closes this web socket when a close frame is read from the peer. */
-  private void replyToPeerClose(final int code, final String reason) {
-    Runnable replierClose = new NamedRunnable("OkHttp %s WebSocket Close Reply", name) {
-      @Override protected void execute() {
-        if (writerClosed.compareAndSet(false, true)) {
-          try {
-            writer.writeClose(code, reason);
-          } catch (IOException t) {
-            Platform.get().log(INFO, "Unable to send close reply in response to peer close.", t);
-          }
-        }
+  // Writer methods to enqueue frames. They'll be sent asynchronously by the writer thread.
 
-        quietlyCloseConnection();
-      }
-    };
-    synchronized (replier) {
-      if (!isShutdown) {
-        replier.execute(replierClose);
-      }
+  @Override public boolean send(String text) {
+    if (text == null) throw new NullPointerException("text == null");
+    return send(ByteString.encodeUtf8(text), OPCODE_TEXT);
+  }
+
+  @Override public boolean send(ByteString bytes) {
+    if (bytes == null) throw new NullPointerException("bytes == null");
+    return send(bytes, OPCODE_BINARY);
+  }
+
+  private synchronized boolean send(ByteString data, int formatOpcode) {
+    // Don't send new frames after we've failed or enqueued a close frame.
+    if (failed || enqueuedClose) return false;
+
+    // If this frame overflows the buffer, reject it and close the web socket.
+    if (queueSize + data.size() > MAX_QUEUE_SIZE) {
+      close(CLOSE_CLIENT_GOING_AWAY, null);
+      return false;
     }
+
+    // Enqueue the message frame.
+    queueSize += data.size();
+    messageAndCloseQueue.add(new Message(formatOpcode, data));
+    runWriter();
+    return true;
   }
 
-  private void replyToReaderError(final Throwable t) {
-    Runnable replierClose = new NamedRunnable("OkHttp %s WebSocket Fatal Reply", name) {
-      @Override protected void execute() {
-        if (writerClosed.compareAndSet(false, true)) {
-          // For protocol and runtime exceptions, try to inform the server of such.
-          boolean protocolException = t instanceof ProtocolException;
-          boolean runtimeException = !(t instanceof IOException);
-          if (protocolException || runtimeException) {
-            int code = protocolException ? CLOSE_PROTOCOL_EXCEPTION : CLOSE_CLIENT_GOING_AWAY;
-            try {
-              writer.writeClose(code, null);
-            } catch (IOException inner) {
-              Platform.get()
-                  .log(INFO, "Unable to send close in response to listener error.", inner);
-            }
-          }
-        }
+  synchronized boolean pong(ByteString payload) {
+    // Don't send pongs after we've failed or sent the close frame.
+    if (failed || (enqueuedClose && messageAndCloseQueue.isEmpty())) return false;
 
-        quietlyCloseConnection();
-      }
-    };
-    synchronized (replier) {
-      if (!isShutdown) {
-        replier.execute(replierClose);
+    pongQueue.add(payload);
+    runWriter();
+    return true;
+  }
+
+  @Override public boolean close(int code, String reason) {
+    return close(code, reason, CANCEL_AFTER_CLOSE_MILLIS);
+  }
+
+  synchronized boolean close(int code, String reason, long cancelAfterCloseMillis) {
+    validateCloseCode(code);
+
+    ByteString reasonBytes = null;
+    if (reason != null) {
+      reasonBytes = ByteString.encodeUtf8(reason);
+      if (reasonBytes.size() > CLOSE_MESSAGE_MAX) {
+        throw new IllegalArgumentException("reason.size() > " + CLOSE_MESSAGE_MAX + ": " + reason);
       }
     }
+
+    if (failed || enqueuedClose) return false;
+
+    // Immediately prevent further frames from being enqueued.
+    enqueuedClose = true;
+
+    // Enqueue the close frame.
+    messageAndCloseQueue.add(new Close(code, reasonBytes, cancelAfterCloseMillis));
+    runWriter();
+    return true;
   }
 
-  ////// SENDER THREAD (aka user thread)
+  private void runWriter() {
+    assert (Thread.holdsLock(this));
 
-  @Override public final void message(RequestBody message) throws IOException {
-    if (message == null) throw new NullPointerException("message == null");
-    if (senderSentClose) throw new IllegalStateException("closed");
-    if (senderWantsClose) throw new IllegalStateException("must call close()");
-    if (Thread.currentThread() == looperThread) {
-      throw new IllegalStateException("attempting to write from reader thread");
+    if (executor != null) {
+      executor.execute(writerRunnable);
     }
+  }
 
-    MediaType contentType = message.contentType();
-    if (contentType == null) {
-      throw new IllegalArgumentException(
-          "Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.");
-    }
-    String contentSubtype = contentType.subtype();
-
-    int formatOpcode;
-    if (WebSocket.TEXT.subtype().equals(contentSubtype)) {
-      formatOpcode = OPCODE_TEXT;
-    } else if (WebSocket.BINARY.subtype().equals(contentSubtype)) {
-      formatOpcode = OPCODE_BINARY;
-    } else {
-      throw new IllegalArgumentException("Unknown message content type: "
-          + contentType.type() + "/" + contentType.subtype() // Omit any implicitly added charset.
-          + ". Must use WebSocket.TEXT or WebSocket.BINARY.");
+  /**
+   * Attempts to remove a single frame from a queue and send it. This prefers to write urgent pongs
+   * before less urgent messages and close frames. For example it's possible that a caller will
+   * enqueue messages followed by pongs, but this sends pongs followed by messages. Pongs are always
+   * written in the order they were enqueued.
+   *
+   * <p>If a frame cannot be sent - because there are none enqueued or because the web socket is not
+   * connected - this does nothing and returns false. Otherwise this returns true and the caller
+   * should immediately invoke this method again until it returns false.
+   *
+   * <p>This method may only be invoked by the writer thread. There may be only thread invoking this
+   * method at a time.
+   */
+  boolean writeOneFrame() throws IOException {
+    WebSocketWriter writer;
+    ByteString pong;
+    Object messageOrClose = null;
+    int receivedCloseCode = -1;
+    String receivedCloseReason = null;
+    Streams streamsToClose = null;
+
+    synchronized (RealWebSocket.this) {
+      if (failed) {
+        return false; // Failed web socket.
+      }
+
+      writer = this.writer;
+      pong = pongQueue.poll();
+      if (pong == null) {
+        messageOrClose = messageAndCloseQueue.poll();
+        if (messageOrClose instanceof Close) {
+          receivedCloseCode = this.receivedCloseCode;
+          receivedCloseReason = this.receivedCloseReason;
+          if (receivedCloseCode != -1) {
+            streamsToClose = this.streams;
+            this.streams = null;
+            this.executor.shutdown();
+          } else {
+            // When we request a graceful close also schedule a cancel of the websocket.
+            cancelFuture = executor.schedule(new CancelRunnable(),
+                ((Close) messageOrClose).cancelAfterCloseMillis, MILLISECONDS);
+          }
+        } else if (messageOrClose == null) {
+          return false; // The queue is exhausted.
+        }
+      }
     }
 
-    BufferedSink sink = Okio.buffer(writer.newMessageSink(formatOpcode, message.contentLength()));
     try {
-      message.writeTo(sink);
-      sink.close();
-    } catch (IOException e) {
-      senderWantsClose = true;
-      throw e;
+      if (pong != null) {
+        writer.writePong(pong);
+
+      } else if (messageOrClose instanceof Message) {
+        ByteString data = ((Message) messageOrClose).data;
+        BufferedSink sink = Okio.buffer(writer.newMessageSink(
+            ((Message) messageOrClose).formatOpcode, data.size()));
+        sink.write(data);
+        sink.close();
+        synchronized (this) {
+          queueSize -= data.size();
+        }
+
+      } else if (messageOrClose instanceof Close) {
+        Close close = (Close) messageOrClose;
+        writer.writeClose(close.code, close.reason);
+
+        // We closed the writer: now both reader and writer are closed.
+        if (streamsToClose != null) {
+          listener.onClosed(this, receivedCloseCode, receivedCloseReason);
+        }
+
+      } else {
+        throw new AssertionError();
+      }
+
+      return true;
+    } finally {
+      closeQuietly(streamsToClose);
     }
   }
 
-  @Override public final void ping(ByteString payload) throws IOException {
-    if (payload == null) throw new NullPointerException("payload == null");
-    if (senderSentClose) throw new IllegalStateException("closed");
-    if (senderWantsClose) throw new IllegalStateException("must call close()");
-    if (Thread.currentThread() == looperThread) {
-      throw new IllegalStateException("attempting to write from reader thread");
+  private final class PingRunnable implements Runnable {
+    @Override public void run() {
+      writePingFrame();
+    }
+  }
+
+  private void writePingFrame() {
+    WebSocketWriter writer;
+    synchronized (this) {
+      if (failed) return;
+      writer = this.writer;
     }
 
     try {
-      writer.writePing(payload);
+      writer.writePing(ByteString.EMPTY);
     } catch (IOException e) {
-      senderWantsClose = true;
-      throw e;
+      failWebSocket(e, null);
     }
   }
 
-  /** Send an unsolicited pong with the specified payload. */
-  public final void pong(ByteString payload) throws IOException {
-    if (payload == null) throw new NullPointerException("payload == null");
-    if (senderSentClose) throw new IllegalStateException("closed");
-    if (senderWantsClose) throw new IllegalStateException("must call close()");
-    if (Thread.currentThread() == looperThread) {
-      throw new IllegalStateException("attempting to write from reader thread");
+  void failWebSocket(Exception e, Response response) {
+    Streams streamsToClose;
+    synchronized (this) {
+      if (failed) return; // Already failed.
+      failed = true;
+      streamsToClose = this.streams;
+      this.streams = null;
+      if (cancelFuture != null) cancelFuture.cancel(false);
+      if (executor != null) executor.shutdown();
     }
 
     try {
-      writer.writePong(payload);
-    } catch (IOException e) {
-      senderWantsClose = true;
-      throw e;
+      listener.onFailure(this, e, response);
+    } finally {
+      closeQuietly(streamsToClose);
     }
   }
 
-  @Override public final void close(int code, String reason) throws IOException {
-    if (senderSentClose) throw new IllegalStateException("closed");
-    if (Thread.currentThread() == looperThread) {
-      throw new IllegalStateException("attempting to write from reader thread");
-    }
+  static final class Message {
+    final int formatOpcode;
+    final ByteString data;
 
-    senderSentClose = true;
+    Message(int formatOpcode, ByteString data) {
+      this.formatOpcode = formatOpcode;
+      this.data = data;
+    }
+  }
 
-    // Not doing a CAS because we want writer to throw if already closed via peer close.
-    writerClosed.set(true);
+  static final class Close {
+    final int code;
+    final ByteString reason;
+    final long cancelAfterCloseMillis;
 
-    try {
-      writer.writeClose(code, reason);
-    } catch (IOException e) {
-      quietlyCloseConnection();
-      throw e;
+    Close(int code, ByteString reason, long cancelAfterCloseMillis) {
+      this.code = code;
+      this.reason = reason;
+      this.cancelAfterCloseMillis = cancelAfterCloseMillis;
     }
+  }
 
-    // NOTE: We do not close the connection here! That will happen when we read the close reply.
+  public abstract static class Streams implements Closeable {
+    public final boolean client;
+    public final BufferedSource source;
+    public final BufferedSink sink;
+
+    public Streams(boolean client, BufferedSource source, BufferedSink sink) {
+      this.client = client;
+      this.source = source;
+      this.sink = sink;
+    }
   }
 
-  ////// ANY THREAD
+  static final class ClientStreams extends Streams {
+    private final StreamAllocation streamAllocation;
 
-  void quietlyCloseConnection() {
-    synchronized (replier) {
-      if (isShutdown) return;
-      isShutdown = true;
+    ClientStreams(StreamAllocation streamAllocation) {
+      super(true, streamAllocation.connection().source, streamAllocation.connection().sink);
+      this.streamAllocation = streamAllocation;
     }
-    try {
-      shutdown();
-    } catch (Throwable inner) {
-      Util.throwIfFatal(inner);
-      Platform.get().log(INFO, "Unable to close web socket connection.", inner);
+
+    @Override public void close() {
+      streamAllocation.streamFinished(true, streamAllocation.codec());
     }
   }
 
-  /** Perform any tear-down work (close the connection, shutdown executors). */
-  protected abstract void shutdown();
+  final class CancelRunnable implements Runnable {
+    @Override public void run() {
+      cancel();
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
index 484ff24368..5be61eea5f 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
@@ -74,6 +74,8 @@
    * special values {@link #PAYLOAD_SHORT} or {@link #PAYLOAD_LONG}.
    */
   static final long PAYLOAD_BYTE_MAX = 125L;
+  /** Maximum length of close message in bytes. */
+  static final long CLOSE_MESSAGE_MAX = PAYLOAD_BYTE_MAX - 2;
   /**
    * Value for {@link #B1_MASK_LENGTH} which indicates the next two bytes are the unsigned length.
    */
@@ -103,21 +105,21 @@ static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameByte
     }
   }
 
-  static void validateCloseCode(int code, boolean argument) throws ProtocolException {
-    String message = null;
+  static String closeCodeExceptionMessage(int code) {
     if (code < 1000 || code >= 5000) {
-      message = "Code must be in range [1000,5000): " + code;
+      return "Code must be in range [1000,5000): " + code;
     } else if ((code >= 1004 && code <= 1006) || (code >= 1012 && code <= 2999)) {
-      message = "Code " + code + " is reserved and may not be used.";
-    }
-    if (message != null) {
-      if (argument) {
-        throw new IllegalArgumentException(message);
-      }
-      throw new ProtocolException(message);
+      return "Code " + code + " is reserved and may not be used.";
+    } else {
+      return null;
     }
   }
 
+  static void validateCloseCode(int code) {
+    String message = closeCodeExceptionMessage(code);
+    if (message != null) throw new IllegalArgumentException(message);
+  }
+
   public static String acceptHeader(String key) {
     return ByteString.encodeUtf8(key + WebSocketProtocol.ACCEPT_MAGIC).sha1().base64();
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
index bb6f5760d8..7e83a30a1d 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
@@ -18,15 +18,10 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
-import okhttp3.MediaType;
-import okhttp3.ResponseBody;
-import okhttp3.WebSocket;
+import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
-import okio.Okio;
-import okio.Source;
-import okio.Timeout;
 
 import static java.lang.Integer.toHexString;
 import static okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN;
@@ -48,7 +43,6 @@
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_LONG;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT;
 import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
-import static okhttp3.internal.ws.WebSocketProtocol.validateCloseCode;
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame reader.
@@ -57,7 +51,8 @@
  */
 final class WebSocketReader {
   public interface FrameCallback {
-    void onReadMessage(ResponseBody body) throws IOException;
+    void onReadMessage(String text) throws IOException;
+    void onReadMessage(ByteString bytes) throws IOException;
     void onReadPing(ByteString buffer);
     void onReadPong(ByteString buffer);
     void onReadClose(int code, String reason);
@@ -67,10 +62,7 @@
   final BufferedSource source;
   final FrameCallback frameCallback;
 
-  final Source framedMessageSource = new FramedMessageSource();
-
   boolean closed;
-  boolean messageClosed;
 
   // Stateful data about the current frame.
   int opcode;
@@ -113,7 +105,15 @@ void processNextFrame() throws IOException {
   private void readHeader() throws IOException {
     if (closed) throw new IOException("closed");
 
-    int b0 = source.readByte() & 0xff;
+    // Disable the timeout to read the first byte of a new frame.
+    int b0;
+    long timeoutBefore = source.timeout().timeoutNanos();
+    source.timeout().clearTimeout();
+    try {
+      b0 = source.readByte() & 0xff;
+    } finally {
+      source.timeout().timeout(timeoutBefore, TimeUnit.NANOSECONDS);
+    }
 
     opcode = b0 & B0_MASK_OPCODE;
     isFinalFrame = (b0 & B0_FLAG_FIN) != 0;
@@ -198,7 +198,8 @@ private void readControlFrame() throws IOException {
         } else if (bufferSize != 0) {
           code = buffer.readShort();
           reason = buffer.readUtf8();
-          validateCloseCode(code, false);
+          String codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code);
+          if (codeExceptionMessage != null) throw new ProtocolException(codeExceptionMessage);
         }
         frameCallback.onReadClose(code, reason);
         closed = true;
@@ -209,37 +210,18 @@ private void readControlFrame() throws IOException {
   }
 
   private void readMessageFrame() throws IOException {
-    final MediaType type;
-    switch (opcode) {
-      case OPCODE_TEXT:
-        type = WebSocket.TEXT;
-        break;
-      case OPCODE_BINARY:
-        type = WebSocket.BINARY;
-        break;
-      default:
-        throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
+    int opcode = this.opcode;
+    if (opcode != OPCODE_TEXT && opcode != OPCODE_BINARY) {
+      throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
     }
 
-    final BufferedSource source = Okio.buffer(framedMessageSource);
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return type;
-      }
+    Buffer message = new Buffer();
+    readMessage(message);
 
-      @Override public long contentLength() {
-        return -1;
-      }
-
-      @Override public BufferedSource source() {
-        return source;
-      }
-    };
-
-    messageClosed = false;
-    frameCallback.onReadMessage(body);
-    if (!messageClosed) {
-      throw new IllegalStateException("Listener failed to call close on message payload.");
+    if (opcode == OPCODE_TEXT) {
+      frameCallback.onReadMessage(message.readUtf8());
+    } else {
+      frameCallback.onReadMessage(message.readByteString());
     }
   }
 
@@ -255,28 +237,27 @@ void readUntilNonControlFrame() throws IOException {
   }
 
   /**
-   * A special source which knows how to read a message body across one or more frames. Control
-   * frames that occur between fragments will be processed. If the message payload is masked this
-   * will unmask as it's being processed.
+   * Reads a message body into across one or more frames. Control frames that occur between
+   * fragments will be processed. If the message payload is masked this will unmask as it's being
+   * processed.
    */
-  final class FramedMessageSource implements Source {
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
+  private void readMessage(Buffer sink) throws IOException {
+    while (true) {
       if (closed) throw new IOException("closed");
-      if (messageClosed) throw new IllegalStateException("closed");
 
       if (frameBytesRead == frameLength) {
-        if (isFinalFrame) return -1; // We are exhausted and have no continuations.
+        if (isFinalFrame) return; // We are exhausted and have no continuations.
 
         readUntilNonControlFrame();
         if (opcode != OPCODE_CONTINUATION) {
           throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
         }
         if (isFinalFrame && frameLength == 0) {
-          return -1; // Fast-path for empty final frame.
+          return; // Fast-path for empty final frame.
         }
       }
 
-      long toRead = Math.min(byteCount, frameLength - frameBytesRead);
+      long toRead = frameLength - frameBytesRead;
 
       long read;
       if (isMasked) {
@@ -291,24 +272,6 @@ void readUntilNonControlFrame() throws IOException {
       }
 
       frameBytesRead += read;
-      return read;
-    }
-
-    @Override public Timeout timeout() {
-      return source.timeout();
-    }
-
-    @Override public void close() throws IOException {
-      if (messageClosed) return;
-      messageClosed = true;
-      if (closed) return;
-
-      // Exhaust the remainder of the message, if any.
-      source.skip(frameLength - frameBytesRead);
-      while (!isFinalFrame) {
-        readUntilNonControlFrame();
-        source.skip(frameLength);
-      }
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
index e232857eed..9c466d672d 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -94,16 +94,16 @@ void writePong(ByteString payload) throws IOException {
    * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
    * @param reason Reason for shutting down or {@code null}.
    */
-  void writeClose(int code, String reason) throws IOException {
+  void writeClose(int code, ByteString reason) throws IOException {
     ByteString payload = ByteString.EMPTY;
     if (code != 0 || reason != null) {
       if (code != 0) {
-        validateCloseCode(code, true);
+        validateCloseCode(code);
       }
       Buffer buffer = new Buffer();
       buffer.writeShort(code);
       if (reason != null) {
-        buffer.writeUtf8(reason);
+        buffer.write(reason);
       }
       payload = buffer.readByteString();
     }
diff --git a/pom.xml b/pom.xml
index e1b638cb6c..bda83e1ade 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>parent</artifactId>
-  <version>3.5.0-SNAPSHOT</version>
+  <version>3.6.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index 8b91ca2dd7..7587628005 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index 2d0c791c38..4b55e5325c 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
diff --git a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
index d737171256..288fadb7ce 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
@@ -1,24 +1,14 @@
 package okhttp3.recipes;
 
-import java.io.IOException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
+import okhttp3.WebSocket;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
-import okhttp3.RequestBody;
 import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
 import okio.ByteString;
 
-import static okhttp3.WebSocket.BINARY;
-import static okhttp3.WebSocket.TEXT;
-
-public final class WebSocketEcho implements WebSocketListener {
-  private final ExecutorService writeExecutor = Executors.newSingleThreadExecutor();
-
+public final class WebSocketEcho extends WebSocketListener {
   private void run() {
     OkHttpClient client = new OkHttpClient.Builder()
         .readTimeout(0,  TimeUnit.MILLISECONDS)
@@ -27,48 +17,34 @@ private void run() {
     Request request = new Request.Builder()
         .url("ws://echo.websocket.org")
         .build();
-    client.newWebSocketCall(request).enqueue(this);
+    client.newWebSocket(request, this);
 
     // Trigger shutdown of the dispatcher's executor so this process can exit cleanly.
     client.dispatcher().executorService().shutdown();
   }
 
-  @Override public void onOpen(final WebSocket webSocket, Response response) {
-    writeExecutor.execute(new Runnable() {
-      @Override public void run() {
-        try {
-          webSocket.message(RequestBody.create(TEXT, "Hello..."));
-          webSocket.message(RequestBody.create(TEXT, "...World!"));
-          webSocket.message(RequestBody.create(BINARY, ByteString.decodeHex("deadbeef")));
-          webSocket.close(1000, "Goodbye, World!");
-        } catch (IOException e) {
-          System.err.println("Unable to send messages: " + e.getMessage());
-        }
-      }
-    });
+  @Override public void onOpen(WebSocket webSocket, Response response) {
+    webSocket.send("Hello...");
+    webSocket.send("...World!");
+    webSocket.send(ByteString.decodeHex("deadbeef"));
+    webSocket.close(1000, "Goodbye, World!");
   }
 
-  @Override public void onMessage(ResponseBody message) throws IOException {
-    if (message.contentType() == TEXT) {
-      System.out.println("MESSAGE: " + message.string());
-    } else {
-      System.out.println("MESSAGE: " + message.source().readByteString().hex());
-    }
-    message.close();
+  @Override public void onMessage(WebSocket webSocket, String text) {
+    System.out.println("MESSAGE: " + text);
   }
 
-  @Override public void onPong(ByteString payload) {
-    System.out.println("PONG: " + payload.utf8());
+  @Override public void onMessage(WebSocket webSocket, ByteString bytes) {
+    System.out.println("MESSAGE: " + bytes.hex());
   }
 
-  @Override public void onClose(int code, String reason) {
+  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+    webSocket.close(1000, null);
     System.out.println("CLOSE: " + code + " " + reason);
-    writeExecutor.shutdown();
   }
 
-  @Override public void onFailure(Throwable t, Response response) {
+  @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
     t.printStackTrace();
-    writeExecutor.shutdown();
   }
 
   public static void main(String... args) {
diff --git a/samples/pom.xml b/samples/pom.xml
index 1c0dc8b829..d88108480b 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp3.sample</groupId>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index c3330e4025..b5f4cb46fb 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/slack/pom.xml b/samples/slack/pom.xml
index 2b4d58b769..06d78916a1 100644
--- a/samples/slack/pom.xml
+++ b/samples/slack/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>slack</artifactId>
diff --git a/samples/slack/src/main/java/okhttp3/slack/RtmSession.java b/samples/slack/src/main/java/okhttp3/slack/RtmSession.java
index 83011d44ca..b5802ef4ad 100644
--- a/samples/slack/src/main/java/okhttp3/slack/RtmSession.java
+++ b/samples/slack/src/main/java/okhttp3/slack/RtmSession.java
@@ -17,17 +17,13 @@
 
 import java.io.Closeable;
 import java.io.IOException;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
 import okhttp3.WebSocket;
-import okhttp3.WebSocketCall;
+import okhttp3.Response;
 import okhttp3.WebSocketListener;
-import okio.ByteString;
 
 /** A realtime messaging session. */
-public final class RtmSession implements WebSocketListener, Closeable {
+public final class RtmSession extends WebSocketListener implements Closeable {
   private final SlackApi slackApi;
-  private WebSocketCall webSocketCall;
 
   /** Guarded by this. */
   private WebSocket webSocket;
@@ -37,53 +33,43 @@ public RtmSession(SlackApi slackApi) {
   }
 
   public void open(String accessToken) throws IOException {
-    if (webSocketCall != null) throw new IllegalStateException();
+    if (webSocket != null) throw new IllegalStateException();
 
     RtmStartResponse rtmStartResponse = slackApi.rtmStart(accessToken);
-    webSocketCall = slackApi.rtm(rtmStartResponse.url);
-    webSocketCall.enqueue(this);
+    webSocket = slackApi.rtm(rtmStartResponse.url, this);
   }
 
   // TODO(jwilson): can I read the response body? Do I have to?
   //                the body from slack is a 0-byte-buffer
   @Override public synchronized void onOpen(WebSocket webSocket, Response response) {
     System.out.println("onOpen: " + response);
-    this.webSocket = webSocket;
   }
 
   // TOOD(jwilson): decode incoming messages and dispatch them somewhere.
-  @Override public void onMessage(ResponseBody message) throws IOException {
-    System.out.println("onMessage: " + message.string());
+  @Override public void onMessage(WebSocket webSocket, String text) {
+    System.out.println("onMessage: " + text);
   }
 
-  @Override public void onPong(ByteString payload) {
-    System.out.println("onPong: " + payload);
-  }
-
-  @Override public void onClose(int code, String reason) {
+  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+    webSocket.close(1000, null);
     System.out.println("onClose (" + code + "): " + reason);
   }
 
-  // TODO(jwilson): can I read the response body? Do I have to?
-  @Override public void onFailure(Throwable t, Response response) {
+  @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+    // TODO(jwilson): can I read the response body? Do I have to?
     System.out.println("onFailure " + response);
   }
 
   @Override public void close() throws IOException {
-    if (webSocketCall == null) return;
+    if (webSocket == null) return;
 
     WebSocket webSocket;
     synchronized (this) {
       webSocket = this.webSocket;
     }
 
-    // TODO(jwilson): Racy? Is there an interleaving of events where the websocket is not closed?
-    //                Our docs say we cant close if we have an active writer: that seems like it
-    //                could cause problems?
     if (webSocket != null) {
       webSocket.close(1000, "bye");
-    } else {
-      webSocketCall.cancel();
     }
   }
 }
diff --git a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
index 0d0086b579..0ec0ef7a45 100644
--- a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
+++ b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
@@ -22,10 +22,11 @@
 import java.io.IOException;
 import okhttp3.Call;
 import okhttp3.HttpUrl;
+import okhttp3.WebSocket;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.WebSocketCall;
+import okhttp3.WebSocketListener;
 import okio.ByteString;
 
 /**
@@ -33,7 +34,7 @@
  * instance of this class may operate without a user, or on behalf of many users. Use the Slack API
  * dashboard to create a client ID and secret for this application.
  *
- * <p>You must configure your Slack API OAuth & Permissions page with a localhost URL like {@code
+ * <p>You must configure your Slack API OAuth and Permissions page with a localhost URL like {@code
  * http://localhost:53203/oauth/}, passing the same port to this class constructor.
  */
 public final class SlackApi {
@@ -105,10 +106,10 @@ public RtmStartResponse rtmStart(String accessToken) throws IOException {
   }
 
   /** See https://api.slack.com/rtm. */
-  public WebSocketCall rtm(HttpUrl url) {
-    return httpClient.newWebSocketCall(new Request.Builder()
+  public WebSocket rtm(HttpUrl url, WebSocketListener listener) {
+    return httpClient.newWebSocket(new Request.Builder()
         .url(url)
-        .build());
+        .build(), listener);
   }
 
   static final class SlackJsonAdapters {
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index ca52ac4b8a..3d86d04ca5 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
+    <version>3.6.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
