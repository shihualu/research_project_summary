diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
index 7e7dbb9f4b..9b3d4c11d2 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.File;
 import java.io.FileInputStream;
@@ -32,6 +33,8 @@
 import javax.net.ssl.SSLSocketFactory;
 import org.eclipse.jetty.npn.NextProtoNego;
 
+import static com.squareup.okhttp.internal.Util.byteStringList;
+
 /** A basic SPDY server that serves the contents of a local directory. */
 public final class SpdyServer implements IncomingStreamHandler {
   private final File baseDirectory;
@@ -78,12 +81,12 @@ private Socket doSsl(Socket socket) throws IOException {
   }
 
   @Override public void receive(final SpdyStream stream) throws IOException {
-    List<String> requestHeaders = stream.getRequestHeaders();
+    List<ByteString> requestHeaders = stream.getRequestHeaders();
     String path = null;
     for (int i = 0; i < requestHeaders.size(); i += 2) {
-      String s = requestHeaders.get(i);
-      if (":path".equals(s)) {
-        path = requestHeaders.get(i + 1);
+      ByteString s = requestHeaders.get(i);
+      if (s.utf8Equals(":path")) {
+        path = requestHeaders.get(i + 1).utf8();
         break;
       }
     }
@@ -105,8 +108,8 @@ private Socket doSsl(Socket socket) throws IOException {
   }
 
   private void send404(SpdyStream stream, String path) throws IOException {
-    List<String> responseHeaders =
-        Arrays.asList(":status", "404", ":version", "HTTP/1.1", "content-type", "text/plain");
+    List<ByteString> responseHeaders =
+        byteStringList(":status", "404", ":version", "HTTP/1.1", "content-type", "text/plain");
     stream.reply(responseHeaders, true);
     OutputStream out = stream.getOutputStream();
     String text = "Not found: " + path;
@@ -115,8 +118,8 @@ private void send404(SpdyStream stream, String path) throws IOException {
   }
 
   private void serveDirectory(SpdyStream stream, String[] files) throws IOException {
-    List<String> responseHeaders =
-        Arrays.asList(":status", "200", ":version", "HTTP/1.1", "content-type",
+    List<ByteString> responseHeaders =
+        byteStringList(":status", "200", ":version", "HTTP/1.1", "content-type",
             "text/html; charset=UTF-8");
     stream.reply(responseHeaders, true);
     OutputStream out = stream.getOutputStream();
@@ -131,7 +134,7 @@ private void serveFile(SpdyStream stream, File file) throws IOException {
     InputStream in = new FileInputStream(file);
     byte[] buffer = new byte[8192];
     stream.reply(
-        Arrays.asList(":status", "200", ":version", "HTTP/1.1", "content-type", contentType(file)),
+        byteStringList(":status", "200", ":version", "HTTP/1.1", "content-type", contentType(file)),
         true);
     OutputStream out = stream.getOutputStream();
     int count;
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 5030943f0f..c9b08f25cf 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -17,6 +17,7 @@
 
 package com.squareup.okhttp.mockwebserver;
 
+import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.spdy.IncomingStreamHandler;
@@ -69,20 +70,29 @@
  * replays them upon request in sequence.
  */
 public final class MockWebServer {
-  private static final byte[] NPN_PROTOCOLS = {
-      17, 'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '6', '/', '2', '.', '0',
-      6, 's', 'p', 'd', 'y', '/', '3',
-      8, 'h', 't', 't', 'p', '/', '1', '.', '1'
+  private static final byte[] HTTP_20_DRAFT_09 = new byte[] {
+      'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '9', '/', '2', '.', '0'
   };
   private static final byte[] SPDY3 = new byte[] {
       's', 'p', 'd', 'y', '/', '3'
   };
-  private static final byte[] HTTP_20_DRAFT_06 = new byte[] {
-      'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '6', '/', '2', '.', '0'
-  };
   private static final byte[] HTTP_11 = new byte[] {
       'h', 't', 't', 'p', '/', '1', '.', '1'
   };
+  private static final byte[] NPN_PROTOCOLS = joinNpnProtocols(HTTP_20_DRAFT_09, SPDY3, HTTP_11);
+
+  private static byte[] joinNpnProtocols(byte[]... protocols) {
+    try {
+      ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      for (byte[] protocol : protocols) {
+        baos.write(protocol.length);
+        baos.write(protocol);
+      }
+      return baos.toByteArray();
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
 
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
     @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
@@ -326,8 +336,8 @@ public void processConnection() throws Exception {
             byte[] selectedProtocol = Platform.get().getNpnSelectedProtocol(sslSocket);
             if (selectedProtocol == null || Arrays.equals(selectedProtocol, HTTP_11)) {
               transport = Transport.HTTP_11;
-            } else if (Arrays.equals(selectedProtocol, HTTP_20_DRAFT_06)) {
-              transport = Transport.HTTP_20_DRAFT_06;
+            } else if (Arrays.equals(selectedProtocol, HTTP_20_DRAFT_09)) {
+              transport = Transport.HTTP_20_DRAFT_09;
             } else if (Arrays.equals(selectedProtocol, SPDY3)) {
               transport = Transport.SPDY_3;
             } else {
@@ -340,14 +350,14 @@ public void processConnection() throws Exception {
           socket = raw;
         }
 
-        if (transport == Transport.SPDY_3 || transport == Transport.HTTP_20_DRAFT_06) {
+        if (transport == Transport.HTTP_20_DRAFT_09 || transport == Transport.SPDY_3) {
           SpdySocketHandler spdySocketHandler = new SpdySocketHandler(socket, transport);
           SpdyConnection.Builder builder = new SpdyConnection.Builder(false, socket)
               .handler(spdySocketHandler);
-          if (transport == Transport.SPDY_3) {
-            builder.spdy3();
+          if (transport == Transport.HTTP_20_DRAFT_09) {
+            builder.http20Draft09();
           } else {
-            builder.http20Draft06();
+            builder.spdy3();
           }
           SpdyConnection spdyConnection = builder.build();
           openSpdyConnections.put(spdyConnection, Boolean.TRUE);
@@ -516,7 +526,9 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
 
   private void writeResponse(OutputStream out, MockResponse response) throws IOException {
     out.write((response.getStatus() + "\r\n").getBytes(Util.US_ASCII));
-    for (String header : response.getHeaders()) {
+    List<String> headers = response.getHeaders();
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String header = headers.get(i);
       out.write((header + "\r\n").getBytes(Util.US_ASCII));
     }
     out.write(("\r\n").getBytes(Util.US_ASCII));
@@ -656,14 +668,14 @@ private SpdySocketHandler(Socket socket, Transport transport) {
     }
 
     private RecordedRequest readRequest(SpdyStream stream) throws IOException {
-      List<String> spdyHeaders = stream.getRequestHeaders();
+      List<ByteString> spdyHeaders = stream.getRequestHeaders();
       List<String> httpHeaders = new ArrayList<String>();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
       String version = "<:version omitted>";
-      for (Iterator<String> i = spdyHeaders.iterator(); i.hasNext(); ) {
-        String name = i.next();
-        String value = i.next();
+      for (int i = 0, size = spdyHeaders.size(); i < size; i += 2) {
+        String name = spdyHeaders.get(i).utf8();
+        String value = spdyHeaders.get(i + 1).utf8();
         if (":method".equals(name)) {
           method = value;
         } else if (":path".equals(name)) {
@@ -690,23 +702,29 @@ private RecordedRequest readRequest(SpdyStream stream) throws IOException {
     }
 
     private void writeResponse(SpdyStream stream, MockResponse response) throws IOException {
-      List<String> spdyHeaders = new ArrayList<String>();
+      if (response.getSocketPolicy() == SocketPolicy.NO_RESPONSE) {
+        return;
+      }
+      List<ByteString> spdyHeaders = new ArrayList<ByteString>();
       String[] statusParts = response.getStatus().split(" ", 2);
       if (statusParts.length != 2) {
         throw new AssertionError("Unexpected status: " + response.getStatus());
       }
-      spdyHeaders.add(":status");
-      spdyHeaders.add(statusParts[1]);
+      // TODO: constants for well-known header names.
+      spdyHeaders.add(ByteString.encodeUtf8(":status"));
+      spdyHeaders.add(ByteString.encodeUtf8(statusParts[1]));
       // TODO: no ":version" header for HTTP/2.0, only SPDY.
-      spdyHeaders.add(":version");
-      spdyHeaders.add(statusParts[0]);
-      for (String header : response.getHeaders()) {
+      spdyHeaders.add(ByteString.encodeUtf8(":version"));
+      spdyHeaders.add(ByteString.encodeUtf8(statusParts[0]));
+      List<String> headers = response.getHeaders();
+      for (int i = 0, size = headers.size(); i < size; i++) {
+        String header = headers.get(i);
         String[] headerParts = header.split(":", 2);
         if (headerParts.length != 2) {
           throw new AssertionError("Unexpected header: " + header);
         }
-        spdyHeaders.add(headerParts[0].toLowerCase(Locale.US).trim());
-        spdyHeaders.add(headerParts[1].trim());
+        spdyHeaders.add(ByteString.encodeUtf8(headerParts[0].toLowerCase(Locale.US).trim()));
+        spdyHeaders.add(ByteString.encodeUtf8(headerParts[1].trim()));
       }
       byte[] body = response.getBody();
       stream.reply(spdyHeaders, body.length > 0);
@@ -718,6 +736,6 @@ private void writeResponse(SpdyStream stream, MockResponse response) throws IOEx
   }
 
   enum Transport {
-    HTTP_11, SPDY_3, HTTP_20_DRAFT_06
+    HTTP_11, SPDY_3, HTTP_20_DRAFT_09
   }
 }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
index aceacd1845..58b5d107c9 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
@@ -80,7 +80,8 @@ public String getPath() {
    */
   public String getHeader(String name) {
     name += ":";
-    for (String header : headers) {
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String header = headers.get(i);
       if (name.regionMatches(true, 0, header, 0, name.length())) {
         return header.substring(name.length()).trim();
       }
@@ -92,7 +93,8 @@ public String getHeader(String name) {
   public List<String> getHeaders(String name) {
     List<String> result = new ArrayList<String>();
     name += ":";
-    for (String header : headers) {
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String header = headers.get(i);
       if (name.regionMatches(true, 0, header, 0, name.length())) {
         result.add(header.substring(name.length()).trim());
       }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
index 7912f3a773..76701c4c92 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
@@ -57,5 +57,11 @@
    * Shutdown the socket output after sending the response. For testing bad
    * behavior.
    */
-  SHUTDOWN_OUTPUT_AT_END
+  SHUTDOWN_OUTPUT_AT_END,
+
+  /**
+   * Don't response to the request but keep the socket open. For testing
+   * read response header timeout issue.
+   */
+  NO_RESPONSE
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java
new file mode 100644
index 0000000000..b6a688e3d7
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright 2014 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Arrays;
+
+/**
+ * An immutable sequence of bytes.
+ *
+ * <p><strong>Full disclosure:</strong> this class provides untrusted input and
+ * output streams with raw access to the underlying byte array. A hostile
+ * stream implementation could keep a reference to the mutable byte string,
+ * violating the immutable guarantee of this class. For this reason a byte
+ * string's immutability guarantee cannot be relied upon for security in applets
+ * and other environments that run both trusted and untrusted code in the same
+ * process.
+ */
+public final class ByteString {
+  private final byte[] data;
+  private transient int hashCode; // Lazily computed; 0 if unknown.
+  private transient String utf8; // Lazily computed.
+
+  /**
+   * A singleton empty {@code ByteString}.
+   */
+  public static final ByteString EMPTY = new ByteString(Util.EMPTY_BYTE_ARRAY);
+
+  /**
+   * Returns a new byte string containing the bytes of {@code data}, or
+   * {@link #EMPTY} if {@code data} is an empty array.
+   */
+  public static ByteString of(byte... data) {
+    return new ByteString(data.clone());
+  }
+
+  /**
+   * Returns a new byte string containing the bytes of {@code data}
+   * from {@code offset} to {@code offset + count - 1}, inclusive, or
+   * {@link #EMPTY} if {@code count} is zero.
+   */
+  public static ByteString of(byte[] data, int offset, int count) {
+    byte[] bytes = new byte[count];
+    System.arraycopy(data, offset, bytes, 0, count);
+    return new ByteString(bytes);
+  }
+
+  /**
+   * Returns a new byte string containing the {@code UTF-8} bytes of {@code s},
+   * or {@link #EMPTY} if {@code s} is zero length.
+   */
+  public static ByteString encodeUtf8(String s) {
+    ByteString byteString = new ByteString(s.getBytes(Util.UTF_8));
+    byteString.utf8 = s;
+    return byteString;
+  }
+
+  /** Constructs a new {@code String} by decoding the bytes as UTF-8. */
+  public String utf8() {
+    String result = utf8;
+    // We don't care if we double-allocate in racy code.
+    return result != null ? result : (utf8 = new String(data, Util.UTF_8));
+  }
+
+  /**
+   * Returns true when {@code s} is not null and its {@code UTF-8} encoded
+   * bytes are equivalent to the bytes wrapped by this byte string.
+   */
+  public boolean utf8Equals(String s) {
+    if (s == null) return false;
+    // TODO: avoid allocation
+    return utf8().equals(s);
+  }
+
+  /**
+   * Reads {@code count} bytes from {@code in} and returns the result.
+   *
+   * @throws EOFException if {@code in} has fewer than {@code count} bytes to
+   * read.
+   */
+  public static ByteString read(InputStream in, int count) throws IOException {
+    byte[] result = new byte[count];
+    for (int c = 0; c < count; ) {
+      int read = in.read(result, c, count - c);
+      if (read == -1) throw new EOFException("Expected " + count + "; received " + c);
+      c += read;
+    }
+    return new ByteString(result);
+  }
+
+  public static ByteString concat(ByteString... byteStrings) {
+    int size = 0;
+    for (ByteString byteString : byteStrings) {
+      size += byteString.size();
+    }
+    byte[] result = new byte[size];
+    int pos = 0;
+    for (ByteString byteString : byteStrings) {
+      System.arraycopy(byteString.data, 0, result, pos, byteString.size());
+      pos += byteString.size();
+    }
+    return ByteString.of(result);
+  }
+
+  private ByteString(byte[] data) {
+    this.data = data; // Trusted internal constructor doesn't clone data.
+  }
+
+  /**
+   * Returns the number of bytes in this ByteString.
+   */
+  public int size() {
+    return data.length;
+  }
+
+  /**
+   * Returns a byte array containing a copy of the bytes in this {@code ByteString}.
+   */
+  public byte[] toByteArray() {
+    return data.clone();
+  }
+
+  /** Writes the contents of this byte string to {@code out}. */
+  public void write(OutputStream out) throws IOException {
+    out.write(data);
+  }
+
+  /** Writes a subsequence of this byte string to {@code out}. */
+  public void write(OutputStream out, int offset, int count) throws IOException {
+    out.write(data, offset, count);
+  }
+
+  @Override public boolean equals(Object o) {
+    return o == this || o instanceof ByteString && Arrays.equals(((ByteString) o).data, data);
+  }
+
+  @Override public int hashCode() {
+    int result = hashCode;
+    return result != 0 ? result : (hashCode = Arrays.hashCode(data));
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
index 905641a30a..d5884b1848 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -25,7 +25,6 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.net.InetSocketAddress;
-import java.net.NetworkInterface;
 import java.net.Socket;
 import java.net.SocketException;
 import java.net.URI;
@@ -135,27 +134,8 @@ public OutputStream newDeflaterOutputStream(OutputStream out, Deflater deflater,
     }
   }
 
-  /**
-   * Returns the maximum transmission unit of the network interface used by
-   * {@code socket}, or a reasonable default if this platform doesn't expose the
-   * MTU to the application layer.
-   *
-   * <p>The returned value should only be used as an optimization; such as to
-   * size buffers efficiently.
-   */
-  public int getMtu(Socket socket) throws IOException {
-    return 1400; // Smaller than 1500 to leave room for headers on interfaces like PPPoE.
-  }
-
   /** Attempt to match the host runtime to a capable Platform implementation. */
   private static Platform findPlatform() {
-    Method getMtu;
-    try {
-      getMtu = NetworkInterface.class.getMethod("getMTU");
-    } catch (NoSuchMethodException e) {
-      return new Platform(); // No Java 1.6 APIs. It's either Java 1.5, Android 2.2 or earlier.
-    }
-
     // Attempt to find Android 2.3+ APIs.
     Class<?> openSslSocketClass;
     Method setUseSessionTickets;
@@ -176,10 +156,10 @@ private static Platform findPlatform() {
       try {
         Method setNpnProtocols = openSslSocketClass.getMethod("setNpnProtocols", byte[].class);
         Method getNpnSelectedProtocol = openSslSocketClass.getMethod("getNpnSelectedProtocol");
-        return new Android41(getMtu, openSslSocketClass, setUseSessionTickets, setHostname,
+        return new Android41(openSslSocketClass, setUseSessionTickets, setHostname,
             setNpnProtocols, getNpnSelectedProtocol);
       } catch (NoSuchMethodException ignored) {
-        return new Android23(getMtu, openSslSocketClass, setUseSessionTickets, setHostname);
+        return new Android23(openSslSocketClass, setUseSessionTickets, setHostname);
       }
     } catch (ClassNotFoundException ignored) {
       // This isn't an Android runtime.
@@ -196,56 +176,25 @@ private static Platform findPlatform() {
       Class<?> serverProviderClass = Class.forName(npnClassName + "$ServerProvider");
       Method putMethod = nextProtoNegoClass.getMethod("put", SSLSocket.class, providerClass);
       Method getMethod = nextProtoNegoClass.getMethod("get", SSLSocket.class);
-      return new JdkWithJettyNpnPlatform(getMtu, putMethod, getMethod, clientProviderClass,
-          serverProviderClass);
+      return new JdkWithJettyNpnPlatform(
+          putMethod, getMethod, clientProviderClass, serverProviderClass);
     } catch (ClassNotFoundException ignored) {
       // NPN isn't on the classpath.
     } catch (NoSuchMethodException ignored) {
       // The NPN version isn't what we expect.
     }
 
-    return new Java6(getMtu);
-  }
-
-  private static class Java6 extends Platform {
-    private final Method getMtu;
-
-    private Java6(Method getMtu) {
-      this.getMtu = getMtu;
-    }
-
-    @Override public int getMtu(Socket socket) throws IOException {
-      try {
-        NetworkInterface networkInterface = NetworkInterface.getByInetAddress(
-            socket.getLocalAddress());
-        if (networkInterface == null) {
-          return super.getMtu(socket); // There's no longer an interface with this local address.
-        }
-        return (Integer) getMtu.invoke(networkInterface);
-      } catch (NullPointerException e) {
-        // Certain Alcatel devices throw on getByInetAddress. Return default.
-        return super.getMtu(socket);
-      } catch (SocketException e) {
-        // Certain Motorola devices always throw on getByInetAddress. Return the default for those.
-        return super.getMtu(socket);
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      } catch (InvocationTargetException e) {
-        if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
-        throw new RuntimeException(e.getCause());
-      }
-    }
+    return new Platform();
   }
 
   /** Android version 2.3 and newer support TLS session tickets and server name indication (SNI). */
-  private static class Android23 extends Java6 {
+  private static class Android23 extends Platform {
     protected final Class<?> openSslSocketClass;
     private final Method setUseSessionTickets;
     private final Method setHostname;
 
-    private Android23(Method getMtu, Class<?> openSslSocketClass, Method setUseSessionTickets,
-        Method setHostname) {
-      super(getMtu);
+    private Android23(
+        Class<?> openSslSocketClass, Method setUseSessionTickets, Method setHostname) {
       this.openSslSocketClass = openSslSocketClass;
       this.setUseSessionTickets = setUseSessionTickets;
       this.setHostname = setHostname;
@@ -285,9 +234,9 @@ private Android23(Method getMtu, Class<?> openSslSocketClass, Method setUseSessi
     private final Method setNpnProtocols;
     private final Method getNpnSelectedProtocol;
 
-    private Android41(Method getMtu, Class<?> openSslSocketClass, Method setUseSessionTickets,
-        Method setHostname, Method setNpnProtocols, Method getNpnSelectedProtocol) {
-      super(getMtu, openSslSocketClass, setUseSessionTickets, setHostname);
+    private Android41(Class<?> openSslSocketClass, Method setUseSessionTickets, Method setHostname,
+        Method setNpnProtocols, Method getNpnSelectedProtocol) {
+      super(openSslSocketClass, setUseSessionTickets, setHostname);
       this.setNpnProtocols = setNpnProtocols;
       this.getNpnSelectedProtocol = getNpnSelectedProtocol;
     }
@@ -320,15 +269,14 @@ private Android41(Method getMtu, Class<?> openSslSocketClass, Method setUseSessi
   }
 
   /** OpenJDK 7 plus {@code org.mortbay.jetty.npn/npn-boot} on the boot class path. */
-  private static class JdkWithJettyNpnPlatform extends Java6 {
+  private static class JdkWithJettyNpnPlatform extends Platform {
     private final Method getMethod;
     private final Method putMethod;
     private final Class<?> clientProviderClass;
     private final Class<?> serverProviderClass;
 
-    public JdkWithJettyNpnPlatform(Method getMtu, Method putMethod, Method getMethod,
-        Class<?> clientProviderClass, Class<?> serverProviderClass) {
-      super(getMtu);
+    public JdkWithJettyNpnPlatform(Method putMethod, Method getMethod, Class<?> clientProviderClass,
+        Class<?> serverProviderClass) {
       this.putMethod = putMethod;
       this.getMethod = getMethod;
       this.clientProviderClass = clientProviderClass;
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
index f2adbf58f2..c5bb07eaa6 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -392,4 +392,12 @@ public static ThreadFactory daemonThreadFactory(final String name) {
       }
     };
   }
+
+  public static List<ByteString> byteStringList(String... strings) {
+    List<ByteString> result = new ArrayList<ByteString>(strings.length);
+    for (String string : strings) {
+      result.add(ByteString.encodeUtf8(string));
+    }
+    return result;
+  }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ByteArrayPool.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ByteArrayPool.java
new file mode 100644
index 0000000000..5961172e1f
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ByteArrayPool.java
@@ -0,0 +1,133 @@
+  /*
+   * Copyright (C) 2012 The Android Open Source Project
+   *
+   * Licensed under the Apache License, Version 2.0 (the "License");
+   * you may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at
+   *
+   *      http://www.apache.org/licenses/LICENSE-2.0
+   *
+   * Unless required by applicable law or agreed to in writing, software
+   * distributed under the License is distributed on an "AS IS" BASIS,
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   */
+
+  package com.squareup.okhttp.internal.spdy;
+
+  import java.util.ArrayList;
+  import java.util.Collections;
+  import java.util.Comparator;
+  import java.util.List;
+
+  /**
+   * ByteArrayPool is a source and repository of <code>byte[]</code> objects. Its purpose is to
+   * supply those buffers to consumers who need to use them for a short period of time and then
+   * dispose of them. Simply creating and disposing such buffers in the conventional manner can
+   * considerable heap churn and garbage collection delays on Android, which lacks good management
+   * of short-lived heap objects. It may be advantageous to trade off some memory in the form of a
+   * permanently allocated pool of buffers in order to gain heap performance improvements; that is
+   * what this class does.
+   * <p>
+   * A good candidate user for this class is something like an I/O system that uses large temporary
+   * <code>byte[]</code> buffers to copy data around. In these use cases, often the consumer wants
+   * the buffer to be a certain minimum size to ensure good performance (e.g. when copying data
+   * chunks off of a stream), but doesn't mind if the buffer is larger than the minimum. Taking this
+   * into account and also to maximize the odds of being able to reuse a recycled buffer, this
+   * class is free to return buffers larger than the requested size. The caller needs to be able
+   * to gracefully deal with getting buffers any size over the minimum.
+   * <p>
+   * If there is not a suitably-sized buffer in its recycling pool when a buffer is requested, this
+   * class will allocate a new buffer and return it.
+   * <p>
+   * This class has no special ownership of buffers it creates; the caller is free to take a buffer
+   * it receives from this pool, use it permanently, and never return it to the pool; additionally,
+   * it is not harmful to return to this pool a buffer that was allocated elsewhere, provided there
+   * are no other lingering references to it.
+   * <p>
+   * This class ensures that the total size of the buffers in its recycling pool never exceeds a
+   * certain byte limit. When a buffer is returned that would cause the pool to exceed the limit,
+   * least-recently-used buffers are disposed.
+   */
+  public class ByteArrayPool {
+    /** The buffer pool, arranged both by last use and by buffer size. */
+    private List<byte[]> mBuffersByLastUse = new ArrayList<byte[]>();
+    private List<byte[]> mBuffersBySize = new ArrayList<byte[]>(64);
+
+    /** The total size of the buffers in the pool. */
+    private int mCurrentSize = 0;
+
+    /**
+     * The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay
+     * under this limit.
+     */
+    private final int mSizeLimit;
+
+    /** Compares buffers by size. */
+    protected static final Comparator<byte[]> BUF_COMPARATOR = new Comparator<byte[]>() {
+      @Override
+      public int compare(byte[] lhs, byte[] rhs) {
+        return lhs.length - rhs.length;
+      }
+    };
+
+    /**
+     * @param sizeLimit the maximum size of the pool, in bytes
+     */
+    public ByteArrayPool(int sizeLimit) {
+      mSizeLimit = sizeLimit;
+    }
+
+    /**
+     * Returns a buffer from the pool if one is available in the requested size, or
+     * allocates a new one if a pooled one is not available.
+     *
+     * @param len the minimum size, in bytes, of the requested buffer. The returned buffer may be
+     * larger.
+     * @return a byte[] buffer is always returned.
+     */
+    public synchronized byte[] getBuf(int len) {
+      for (int i = 0; i < mBuffersBySize.size(); i++) {
+        byte[] buf = mBuffersBySize.get(i);
+        if (buf.length >= len) {
+          mCurrentSize -= buf.length;
+          mBuffersBySize.remove(i);
+          mBuffersByLastUse.remove(buf);
+          return buf;
+        }
+      }
+      return new byte[len];
+    }
+
+    /**
+     * Returns a buffer to the pool, throwing away old buffers if the pool would exceed its
+     * allotted size.
+     *
+     * @param buf the buffer to return to the pool.
+     */
+    public synchronized void returnBuf(byte[] buf) {
+      if (buf == null || buf.length > mSizeLimit) {
+        return;
+      }
+      mBuffersByLastUse.add(buf);
+      int pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);
+      if (pos < 0) {
+        pos = -pos - 1;
+      }
+      mBuffersBySize.add(pos, buf);
+      mCurrentSize += buf.length;
+      trim();
+    }
+
+    /**
+     * Removes buffers from the pool until it is under its size limit.
+     */
+    private synchronized void trim() {
+      while (mCurrentSize > mSizeLimit) {
+        byte[] buf = mBuffersByLastUse.remove(0);
+        mBuffersBySize.remove(buf);
+        mCurrentSize -= buf.length;
+      }
+    }
+  }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
index d3a32e1172..045677b5dd 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
@@ -1,5 +1,7 @@
 package com.squareup.okhttp.internal.spdy;
 
+// TODO: revisit for http/2 draft 9
+// http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-7
 public enum ErrorCode {
   /** Not an error! For SPDY stream resets, prefer null over NO_ERROR. */
   NO_ERROR(0, -1, 0),
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index 1371262e6c..a2228601a6 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.ByteString;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
@@ -28,22 +29,22 @@
 
   public interface Handler {
     void data(boolean inFinished, int streamId, InputStream in, int length) throws IOException;
+
     /**
      * Create or update incoming headers, creating the corresponding streams
      * if necessary. Frames that trigger this are SPDY SYN_STREAM, HEADERS, and
      * SYN_REPLY, and HTTP/2.0 HEADERS and PUSH_PROMISE.
      *
-     * @param inFinished true if the sender will not send further frames.
      * @param outFinished true if the receiver should not send further frames.
+     * @param inFinished true if the sender will not send further frames.
      * @param streamId the stream owning these headers.
      * @param associatedStreamId the stream that triggered the sender to create
-     *     this stream.
+     * this stream.
      * @param priority or -1 for no priority. For SPDY, priorities range from 0
-     *     (highest) thru 7 (lowest). For HTTP/2.0, priorities range from 0
-     *     (highest) thru 2**31-1 (lowest).
+     * (highest) thru 7 (lowest). For HTTP/2.0, priorities range from 0
      */
     void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-        int priority, List<String> nameValueBlock, HeadersMode headersMode);
+        int priority, List<ByteString> nameValueBlock, HeadersMode headersMode);
     void rstStream(int streamId, ErrorCode errorCode);
     void settings(boolean clearPrevious, Settings settings);
     void noop();
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index 354f43d1d1..77bbdf8c99 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.ByteString;
 import java.io.Closeable;
 import java.io.IOException;
 import java.util.List;
@@ -28,9 +29,10 @@
   /** SPDY/3 only. */
   void flush() throws IOException;
   void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      int priority, int slot, List<String> nameValueBlock) throws IOException;
-  void synReply(boolean outFinished, int streamId, List<String> nameValueBlock) throws IOException;
-  void headers(int streamId, List<String> nameValueBlock) throws IOException;
+      int priority, int slot, List<ByteString> nameValueBlock) throws IOException;
+  void synReply(boolean outFinished, int streamId, List<ByteString> nameValueBlock)
+      throws IOException;
+  void headers(int streamId, List<ByteString> nameValueBlock) throws IOException;
   void rstStream(int streamId, ErrorCode errorCode) throws IOException;
   void data(boolean outFinished, int streamId, byte[] data) throws IOException;
   void data(boolean outFinished, int streamId, byte[] data, int offset, int byteCount)
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
deleted file mode 100644
index c3ca8f1163..0000000000
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
+++ /dev/null
@@ -1,371 +0,0 @@
-package com.squareup.okhttp.internal.spdy;
-
-import java.io.DataInputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.BitSet;
-import java.util.List;
-
-/**
- * Read and write HPACK v03.
- * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-03
- */
-final class Hpack {
-
-  static class HeaderEntry {
-    private final String name;
-    private final String value;
-
-    HeaderEntry(String name, String value) {
-      this.name = name;
-      this.value = value;
-    }
-
-    // TODO: This needs to be the length in UTF-8 bytes, not the length in chars.
-    int length() {
-      return 32 + name.length() + value.length();
-    }
-  }
-
-  static final int PREFIX_5_BITS = 0x1f;
-  static final int PREFIX_6_BITS = 0x3f;
-  static final int PREFIX_7_BITS = 0x7f;
-  static final int PREFIX_8_BITS = 0xff;
-
-  static final List<HeaderEntry> INITIAL_CLIENT_TO_SERVER_HEADER_TABLE = Arrays.asList(
-      new HeaderEntry(":scheme", "http"),
-      new HeaderEntry(":scheme", "https"),
-      new HeaderEntry(":host", ""),
-      new HeaderEntry(":path", "/"),
-      new HeaderEntry(":method", "GET"),
-      new HeaderEntry("accept", ""),
-      new HeaderEntry("accept-charset", ""),
-      new HeaderEntry("accept-encoding", ""),
-      new HeaderEntry("accept-language", ""),
-      new HeaderEntry("cookie", ""),
-      new HeaderEntry("if-modified-since", ""),
-      new HeaderEntry("user-agent", ""),
-      new HeaderEntry("referer", ""),
-      new HeaderEntry("authorization", ""),
-      new HeaderEntry("allow", ""),
-      new HeaderEntry("cache-control", ""),
-      new HeaderEntry("connection", ""),
-      new HeaderEntry("content-length", ""),
-      new HeaderEntry("content-type", ""),
-      new HeaderEntry("date", ""),
-      new HeaderEntry("expect", ""),
-      new HeaderEntry("from", ""),
-      new HeaderEntry("if-match", ""),
-      new HeaderEntry("if-none-match", ""),
-      new HeaderEntry("if-range", ""),
-      new HeaderEntry("if-unmodified-since", ""),
-      new HeaderEntry("max-forwards", ""),
-      new HeaderEntry("proxy-authorization", ""),
-      new HeaderEntry("range", ""),
-      new HeaderEntry("via", "")
-  );
-
-  static final List<HeaderEntry> INITIAL_SERVER_TO_CLIENT_HEADER_TABLE = Arrays.asList(
-      new HeaderEntry(":status", "200"),
-      new HeaderEntry("age", ""),
-      new HeaderEntry("cache-control", ""),
-      new HeaderEntry("content-length", ""),
-      new HeaderEntry("content-type", ""),
-      new HeaderEntry("date", ""),
-      new HeaderEntry("etag", ""),
-      new HeaderEntry("expires", ""),
-      new HeaderEntry("last-modified", ""),
-      new HeaderEntry("server", ""),
-      new HeaderEntry("set-cookie", ""),
-      new HeaderEntry("vary", ""),
-      new HeaderEntry("via", ""),
-      new HeaderEntry("access-control-allow-origin", ""),
-      new HeaderEntry("accept-ranges", ""),
-      new HeaderEntry("allow", ""),
-      new HeaderEntry("connection", ""),
-      new HeaderEntry("content-disposition", ""),
-      new HeaderEntry("content-encoding", ""),
-      new HeaderEntry("content-language", ""),
-      new HeaderEntry("content-location", ""),
-      new HeaderEntry("content-range", ""),
-      new HeaderEntry("link", ""),
-      new HeaderEntry("location", ""),
-      new HeaderEntry("proxy-authenticate", ""),
-      new HeaderEntry("refresh", ""),
-      new HeaderEntry("retry-after", ""),
-      new HeaderEntry("strict-transport-security", ""),
-      new HeaderEntry("transfer-encoding", ""),
-      new HeaderEntry("www-authenticate", "")
-  );
-
-  // Update these when initial tables change to sum of each entry length.
-  static final int INITIAL_CLIENT_TO_SERVER_HEADER_TABLE_LENGTH = 1262;
-  static final int INITIAL_SERVER_TO_CLIENT_HEADER_TABLE_LENGTH = 1304;
-
-  private Hpack() {
-  }
-
-  static class Reader {
-    private final long maxBufferSize = 4096; // TODO: needs to come from settings.
-    private final DataInputStream in;
-
-    private final BitSet referenceSet = new BitSet();
-    private final List<HeaderEntry> headerTable;
-    private final List<String> emittedHeaders = new ArrayList<String>();
-    private long bufferSize = 0;
-    private long bytesLeft = 0;
-
-    Reader(DataInputStream in, boolean client) {
-      this.in = in;
-      if (client) {  // we are reading from the server
-        this.headerTable = new ArrayList<HeaderEntry>(INITIAL_SERVER_TO_CLIENT_HEADER_TABLE);
-        this.bufferSize = INITIAL_SERVER_TO_CLIENT_HEADER_TABLE_LENGTH;
-      } else {
-        this.headerTable = new ArrayList<HeaderEntry>(INITIAL_CLIENT_TO_SERVER_HEADER_TABLE);
-        this.bufferSize = INITIAL_CLIENT_TO_SERVER_HEADER_TABLE_LENGTH;
-      }
-    }
-
-    /**
-     * Read {@code byteCount} bytes of headers from the source stream into the
-     * set of emitted headers.
-     */
-    public void readHeaders(int byteCount) throws IOException {
-      bytesLeft += byteCount;
-      // TODO: limit to 'byteCount' bytes?
-
-      while (bytesLeft > 0) {
-        int b = readByte();
-
-        if ((b & 0x80) != 0) {
-          int index = readInt(b, PREFIX_7_BITS);
-          readIndexedHeader(index);
-        } else if (b == 0x60) {
-          readLiteralHeaderWithoutIndexingNewName();
-        } else if ((b & 0xe0) == 0x60) {
-          int index = readInt(b, PREFIX_5_BITS);
-          readLiteralHeaderWithoutIndexingIndexedName(index - 1);
-        } else if (b == 0x40) {
-          readLiteralHeaderWithIncrementalIndexingNewName();
-        } else if ((b & 0xe0) == 0x40) {
-          int index = readInt(b, PREFIX_5_BITS);
-          readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
-        } else if (b == 0) {
-          readLiteralHeaderWithSubstitutionIndexingNewName();
-        } else if ((b & 0xc0) == 0) {
-          int index = readInt(b, PREFIX_6_BITS);
-          readLiteralHeaderWithSubstitutionIndexingIndexedName(index - 1);
-        } else {
-          throw new AssertionError();
-        }
-      }
-    }
-
-    public void emitReferenceSet() {
-      for (int i = referenceSet.nextSetBit(0); i != -1; i = referenceSet.nextSetBit(i + 1)) {
-        emittedHeaders.add(getName(i));
-        emittedHeaders.add(getValue(i));
-      }
-    }
-
-    /**
-     * Returns all headers emitted since they were last cleared, then clears the
-     * emitted headers.
-     */
-    public List<String> getAndReset() {
-      List<String> result = new ArrayList<String>(emittedHeaders);
-      emittedHeaders.clear();
-      return result;
-    }
-
-    private void readIndexedHeader(int index) {
-      if (referenceSet.get(index)) {
-        referenceSet.clear(index);
-      } else {
-        referenceSet.set(index);
-      }
-    }
-
-    private void readLiteralHeaderWithoutIndexingIndexedName(int index)
-        throws IOException {
-      String name = getName(index);
-      String value = readString();
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-    }
-
-    private void readLiteralHeaderWithoutIndexingNewName()
-        throws IOException {
-      String name = readString();
-      String value = readString();
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-    }
-
-    private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
-        throws IOException {
-      String name = getName(nameIndex);
-      String value = readString();
-      int index = headerTable.size(); // append to tail
-      insertIntoHeaderTable(index, new HeaderEntry(name, value));
-    }
-
-    private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
-      String name = readString();
-      String value = readString();
-      int index = headerTable.size(); // append to tail
-      insertIntoHeaderTable(index, new HeaderEntry(name, value));
-    }
-
-    private void readLiteralHeaderWithSubstitutionIndexingIndexedName(int nameIndex)
-        throws IOException {
-      int index = readInt(readByte(), PREFIX_8_BITS);
-      String name = getName(nameIndex);
-      String value = readString();
-      insertIntoHeaderTable(index, new HeaderEntry(name, value));
-    }
-
-    private void readLiteralHeaderWithSubstitutionIndexingNewName() throws IOException {
-      String name = readString();
-      int index = readInt(readByte(), PREFIX_8_BITS);
-      String value = readString();
-      insertIntoHeaderTable(index, new HeaderEntry(name, value));
-    }
-
-    private String getName(int index) {
-      return headerTable.get(index).name;
-    }
-
-    private String getValue(int index) {
-      return headerTable.get(index).value;
-    }
-
-    private void insertIntoHeaderTable(int index, HeaderEntry entry) {
-      int delta = entry.length();
-      if (index != headerTable.size()) {
-        delta -= headerTable.get(index).length();
-      }
-
-      // if the new or replacement header is too big, drop all entries.
-      if (delta > maxBufferSize) {
-        headerTable.clear();
-        bufferSize = 0;
-        // emit the large header to the callback.
-        emittedHeaders.add(entry.name);
-        emittedHeaders.add(entry.value);
-        return;
-      }
-
-      // Prune headers to the required length.
-      while (bufferSize + delta > maxBufferSize) {
-        remove(0);
-        index--;
-      }
-
-      if (index < 0) { // we pruned it, so insert at beginning
-        index = 0;
-        headerTable.add(index, entry);
-      } else if (index == headerTable.size()) { // append to the end
-        headerTable.add(index, entry);
-      } else { // replace value at same position
-        headerTable.set(index, entry);
-      }
-
-      bufferSize += delta;
-      referenceSet.set(index);
-    }
-
-    private void remove(int index) {
-      bufferSize -= headerTable.remove(index).length();
-    }
-
-    private int readByte() throws IOException {
-      bytesLeft--;
-      return in.readByte() & 0xff;
-    }
-
-    int readInt(int firstByte, int prefixMask) throws IOException {
-      int prefix = firstByte & prefixMask;
-      if (prefix < prefixMask) {
-        return prefix; // This was a single byte value.
-      }
-
-      // This is a multibyte value. Read 7 bits at a time.
-      int result = prefixMask;
-      int shift = 0;
-      while (true) {
-        int b = readByte();
-        if ((b & 0x80) != 0) { // Equivalent to (b >= 128) since b is in [0..255].
-          result += (b & 0x7f) << shift;
-          shift += 7;
-        } else {
-          result += b << shift; // Last byte.
-          break;
-        }
-      }
-      return result;
-    }
-
-    /**
-     * Reads a UTF-8 encoded string. Since ASCII is a subset of UTF-8, this method
-     * may be used to read strings that are known to be ASCII-only.
-     */
-    public String readString() throws IOException {
-      int firstByte = readByte();
-      int length = readInt(firstByte, PREFIX_8_BITS);
-      byte[] encoded = new byte[length];
-      bytesLeft -= length;
-      in.readFully(encoded);
-      return new String(encoded, "UTF-8");
-    }
-  }
-
-  static class Writer {
-    private final OutputStream out;
-
-    Writer(OutputStream out) {
-      this.out = out;
-    }
-
-    public void writeHeaders(List<String> nameValueBlock) throws IOException {
-      // TODO: implement a compression strategy.
-      for (int i = 0, size = nameValueBlock.size(); i < size; i += 2) {
-        out.write(0x60); // Literal Header without Indexing - New Name.
-        writeString(nameValueBlock.get(i));
-        writeString(nameValueBlock.get(i + 1));
-      }
-    }
-
-    public void writeInt(int value, int prefixMask, int bits) throws IOException {
-      // Write the raw value for a single byte value.
-      if (value < prefixMask) {
-        out.write(bits | value);
-        return;
-      }
-
-      // Write the mask to start a multibyte value.
-      out.write(bits | prefixMask);
-      value -= prefixMask;
-
-      // Write 7 bits at a time 'til we're done.
-      while (value >= 0x80) {
-        int b = value & 0x7f;
-        out.write(b | 0x80);
-        value >>>= 7;
-      }
-      out.write(value);
-    }
-
-    /**
-     * Writes a UTF-8 encoded string. Since ASCII is a subset of UTF-8, this
-     * method can be used to write strings that are known to be ASCII-only.
-     */
-    public void writeString(String headerName) throws IOException {
-      byte[] bytes = headerName.getBytes("UTF-8");
-      writeInt(bytes.length, PREFIX_8_BITS, 0);
-      out.write(bytes);
-    }
-  }
-}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
new file mode 100644
index 0000000000..1c8d4397c2
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -0,0 +1,390 @@
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.ByteString;
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.List;
+
+/**
+ * Read and write HPACK v05.
+ * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05
+ */
+final class HpackDraft05 {
+
+  // Visible for testing.
+  static class HeaderEntry {
+    final ByteString name;
+    final ByteString value;
+    final int size;
+    // Static entries can be shared safely, as long as {@code referenced} is not mutated.
+    final boolean isStatic;
+    // Only read when in headerTable.
+    // Mutable to avoid needing another BitSet for referenced header indexes.  Using a BitSet for
+    // reference entries sounds good, except that entries are added at index zero.  This implies
+    // shifting the BitSet, which would be expensive to implement.
+    boolean referenced = true;
+
+    HeaderEntry(ByteString name, ByteString value, boolean isStatic) {
+      this(name, value, 32 + name.size() + value.size(), isStatic);
+    }
+
+    private HeaderEntry(ByteString name, ByteString value, int size, boolean isStatic) {
+      this.name = name;
+      this.value = value;
+      this.size = size;
+      this.isStatic = isStatic;
+    }
+
+    /** Adds name and value, if this entry is referenced. */
+    void addTo(List<ByteString> out) {
+      if (!referenced) return;
+      out.add(name);
+      out.add(value);
+    }
+
+    /** Copies this header entry and designates it as not a static entry. */
+    @Override public HeaderEntry clone() {
+      return new HeaderEntry(name, value, size, false);
+    }
+  }
+
+  private static final int PREFIX_6_BITS = 0x3f;
+  private static final int PREFIX_7_BITS = 0x7f;
+  private static final int PREFIX_8_BITS = 0xff;
+
+  private static final HeaderEntry[] STATIC_HEADER_TABLE = new HeaderEntry[] {
+      staticEntry(":authority", ""),
+      staticEntry(":method", "GET"),
+      staticEntry(":method", "POST"),
+      staticEntry(":path", "/"),
+      staticEntry(":path", "/index.html"),
+      staticEntry(":scheme", "http"),
+      staticEntry(":scheme", "https"),
+      staticEntry(":status", "200"),
+      staticEntry(":status", "500"),
+      staticEntry(":status", "404"),
+      staticEntry(":status", "403"),
+      staticEntry(":status", "400"),
+      staticEntry(":status", "401"),
+      staticEntry("accept-charset", ""),
+      staticEntry("accept-encoding", ""),
+      staticEntry("accept-language", ""),
+      staticEntry("accept-ranges", ""),
+      staticEntry("accept", ""),
+      staticEntry("access-control-allow-origin", ""),
+      staticEntry("age", ""),
+      staticEntry("allow", ""),
+      staticEntry("authorization", ""),
+      staticEntry("cache-control", ""),
+      staticEntry("content-disposition", ""),
+      staticEntry("content-encoding", ""),
+      staticEntry("content-language", ""),
+      staticEntry("content-length", ""),
+      staticEntry("content-location", ""),
+      staticEntry("content-range", ""),
+      staticEntry("content-type", ""),
+      staticEntry("cookie", ""),
+      staticEntry("date", ""),
+      staticEntry("etag", ""),
+      staticEntry("expect", ""),
+      staticEntry("expires", ""),
+      staticEntry("from", ""),
+      staticEntry("host", ""),
+      staticEntry("if-match", ""),
+      staticEntry("if-modified-since", ""),
+      staticEntry("if-none-match", ""),
+      staticEntry("if-range", ""),
+      staticEntry("if-unmodified-since", ""),
+      staticEntry("last-modified", ""),
+      staticEntry("link", ""),
+      staticEntry("location", ""),
+      staticEntry("max-forwards", ""),
+      staticEntry("proxy-authenticate", ""),
+      staticEntry("proxy-authorization", ""),
+      staticEntry("range", ""),
+      staticEntry("referer", ""),
+      staticEntry("refresh", ""),
+      staticEntry("retry-after", ""),
+      staticEntry("server", ""),
+      staticEntry("set-cookie", ""),
+      staticEntry("strict-transport-security", ""),
+      staticEntry("transfer-encoding", ""),
+      staticEntry("user-agent", ""),
+      staticEntry("vary", ""),
+      staticEntry("via", ""),
+      staticEntry("www-authenticate", "")
+  };
+
+  private HpackDraft05() {
+  }
+
+  // TODO: huffman encoding!
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.2
+  static class Reader {
+    private final DataInputStream in;
+    private final List<ByteString> emittedHeaders = new ArrayList<ByteString>();
+    private long bytesLeft = 0;
+
+    // Visible for testing.
+    final List<HeaderEntry> headerTable = new ArrayList<HeaderEntry>(5); // average of 5 headers
+    final BitSet staticReferenceSet = new BitSet();
+    long headerTableSize = 0;
+    long maxHeaderTableSize = 4096; // TODO: needs to come from SETTINGS_HEADER_TABLE_SIZE.
+
+    Reader(DataInputStream in) {
+      this.in = in;
+    }
+
+    /**
+     * Read {@code byteCount} bytes of headers from the source stream into the
+     * set of emitted headers.
+     */
+    public void readHeaders(int byteCount) throws IOException {
+      bytesLeft += byteCount;
+      // TODO: limit to 'byteCount' bytes?
+
+      while (bytesLeft > 0) {
+        int b = readByte();
+
+        if ((b & 0x80) != 0) {
+          int index = readInt(b, PREFIX_7_BITS);
+          if (index == 0) {
+            clearReferenceSet();
+          } else {
+            readIndexedHeader(index - 1);
+          }
+        } else if (b == 0x40) {
+          readLiteralHeaderWithoutIndexingNewName();
+        } else if ((b & 0xe0) == 0x40) {
+          int index = readInt(b, PREFIX_6_BITS);
+          readLiteralHeaderWithoutIndexingIndexedName(index - 1);
+        } else if (b == 0) {
+          readLiteralHeaderWithIncrementalIndexingNewName();
+        } else if ((b & 0xc0) == 0) {
+          int index = readInt(b, PREFIX_6_BITS);
+          readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
+        } else {
+          // TODO: we should throw something that we can coerce to a PROTOCOL_ERROR
+          throw new AssertionError("unhandled byte: " + Integer.toBinaryString(b));
+        }
+      }
+    }
+
+    private void clearReferenceSet() {
+      staticReferenceSet.clear();
+      for (int i = 0, size = headerTable.size(); i < size; i++) {
+        HeaderEntry entry = headerTable.get(i);
+        if (entry.isStatic) { // lazy clone static entries on mutation.
+          entry = entry.clone();
+          entry.referenced = false;
+          headerTable.set(i, entry);
+        } else {
+          entry.referenced = false;
+        }
+      }
+    }
+
+    public void emitReferenceSet() {
+      for (int i = staticReferenceSet.nextSetBit(0); i != -1;
+          i = staticReferenceSet.nextSetBit(i + 1)) {
+        STATIC_HEADER_TABLE[i].addTo(emittedHeaders);
+      }
+      for (int i = headerTable.size() - 1; i != -1; i--) {
+        headerTable.get(i).addTo(emittedHeaders);
+      }
+    }
+
+    /**
+     * Returns all headers emitted since they were last cleared, then clears the
+     * emitted headers.
+     */
+    public List<ByteString> getAndReset() {
+      List<ByteString> result = new ArrayList<ByteString>(emittedHeaders);
+      emittedHeaders.clear();
+      return result;
+    }
+
+    private void readIndexedHeader(int index) {
+      if (isStaticHeader(index)) {
+        if (maxHeaderTableSize == 0) {
+          staticReferenceSet.set(index - headerTable.size());
+        } else {
+          HeaderEntry staticEntry = STATIC_HEADER_TABLE[index - headerTable.size()];
+          insertIntoHeaderTable(-1, staticEntry);
+       }
+      } else if (!headerTable.get(index).referenced) {
+        HeaderEntry existing = headerTable.get(index);
+        existing.referenced = true;
+        insertIntoHeaderTable(index, existing);
+      } else {
+        // TODO: we should throw something that we can coerce to a PROTOCOL_ERROR
+        throw new AssertionError("invalid index " + index);
+      }
+    }
+
+    private void readLiteralHeaderWithoutIndexingIndexedName(int index)
+        throws IOException {
+      ByteString name = getName(index);
+      ByteString value = readString();
+      emittedHeaders.add(name);
+      emittedHeaders.add(value);
+    }
+
+    private void readLiteralHeaderWithoutIndexingNewName()
+        throws IOException {
+      ByteString name = readString();
+      ByteString value = readString();
+      emittedHeaders.add(name);
+      emittedHeaders.add(value);
+    }
+
+    private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
+        throws IOException {
+      ByteString name = getName(nameIndex);
+      ByteString value = readString();
+      insertIntoHeaderTable(-1, new HeaderEntry(name, value, false));
+    }
+
+    private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
+      ByteString name = readString();
+      ByteString value = readString();
+      insertIntoHeaderTable(-1, new HeaderEntry(name, value, false));
+    }
+
+    private ByteString getName(int index) {
+      if (isStaticHeader(index)) {
+        return STATIC_HEADER_TABLE[index - headerTable.size()].name;
+      } else {
+        return headerTable.get(index).name;
+      }
+    }
+
+    private boolean isStaticHeader(int index) {
+      return index >= headerTable.size();
+    }
+
+    /** index == -1 when new. */
+    private void insertIntoHeaderTable(int index, HeaderEntry entry) {
+      int delta = entry.size;
+      if (index != -1) { // Index -1 == new header.
+        delta -= headerTable.get(index).size;
+      }
+
+      // if the new or replacement header is too big, drop all entries.
+      if (delta > maxHeaderTableSize) {
+        staticReferenceSet.clear();
+        headerTable.clear();
+        headerTableSize = 0;
+        // emit the large header to the callback.
+        entry.addTo(emittedHeaders);
+        return;
+      }
+
+      // Evict headers to the required length.
+      while (headerTableSize + delta > maxHeaderTableSize) {
+        remove(headerTable.size() - 1);
+      }
+
+      if (index == -1) {
+        headerTable.add(0, entry);
+      } else { // Replace value at same position.
+        headerTable.set(index, entry);
+      }
+
+      headerTableSize += delta;
+    }
+
+    private void remove(int index) {
+      headerTableSize -= headerTable.remove(index).size;
+    }
+
+    private int readByte() throws IOException {
+      bytesLeft--;
+      return in.readByte() & 0xff;
+    }
+
+    int readInt(int firstByte, int prefixMask) throws IOException {
+      int prefix = firstByte & prefixMask;
+      if (prefix < prefixMask) {
+        return prefix; // This was a single byte value.
+      }
+
+      // This is a multibyte value. Read 7 bits at a time.
+      int result = prefixMask;
+      int shift = 0;
+      while (true) {
+        int b = readByte();
+        if ((b & 0x80) != 0) { // Equivalent to (b >= 128) since b is in [0..255].
+          result += (b & 0x7f) << shift;
+          shift += 7;
+        } else {
+          result += b << shift; // Last byte.
+          break;
+        }
+      }
+      return result;
+    }
+
+    /**
+     * Reads a UTF-8 encoded string. Since ASCII is a subset of UTF-8, this method
+     * may be used to read strings that are known to be ASCII-only.
+     */
+    public ByteString readString() throws IOException {
+      int firstByte = readByte();
+      int length = readInt(firstByte, PREFIX_8_BITS);
+      byte[] encoded = new byte[length];
+      bytesLeft -= length;
+      in.readFully(encoded);
+      return ByteString.of(encoded);
+    }
+  }
+
+  static class Writer {
+    private final OutputStream out;
+
+    Writer(OutputStream out) {
+      this.out = out;
+    }
+
+    public void writeHeaders(List<ByteString> nameValueBlock) throws IOException {
+      // TODO: implement a compression strategy.
+      for (int i = 0, size = nameValueBlock.size(); i < size; i += 2) {
+        out.write(0x40); // Literal Header without Indexing - New Name.
+        writeByteString(nameValueBlock.get(i));
+        writeByteString(nameValueBlock.get(i + 1));
+      }
+    }
+
+    public void writeInt(int value, int prefixMask, int bits) throws IOException {
+      // Write the raw value for a single byte value.
+      if (value < prefixMask) {
+        out.write(bits | value);
+        return;
+      }
+
+      // Write the mask to start a multibyte value.
+      out.write(bits | prefixMask);
+      value -= prefixMask;
+
+      // Write 7 bits at a time 'til we're done.
+      while (value >= 0x80) {
+        int b = value & 0x7f;
+        out.write(b | 0x80);
+        value >>>= 7;
+      }
+      out.write(value);
+    }
+
+    public void writeByteString(ByteString data) throws IOException {
+      writeInt(data.size(), PREFIX_8_BITS, 0);
+      data.write(out);
+    }
+  }
+
+  private static HeaderEntry staticEntry(String name, String value) {
+    return new HeaderEntry(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value), true);
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft06.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
similarity index 81%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft06.java
rename to okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index 3d53f48488..8ec7e81621 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft06.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayOutputStream;
 import java.io.DataInputStream;
@@ -27,10 +28,15 @@
 import java.util.List;
 
 /**
- * Read and write http/2 v06 frames.
- * http://tools.ietf.org/html/draft-ietf-httpbis-http2-06
+ * Read and write http/2 v09 frames.
+ * http://tools.ietf.org/html/draft-ietf-httpbis-http2-09
  */
-final class Http20Draft06 implements Variant {
+public final class Http20Draft09 implements Variant {
+
+  @Override public String getProtocol() {
+    return "HTTP-draft-09/2.0";
+  }
+
   private static final byte[] CONNECTION_HEADER;
   static {
     try {
@@ -52,10 +58,11 @@
   static final int TYPE_CONTINUATION = 0xa;
 
   static final int FLAG_END_STREAM = 0x1;
+
   /** Used for headers, push-promise and continuation. */
   static final int FLAG_END_HEADERS = 0x4;
   static final int FLAG_PRIORITY = 0x8;
-  static final int FLAG_PONG = 0x1;
+  static final int FLAG_ACK = 0x1;
   static final int FLAG_END_FLOW_CONTROL = 0x1;
 
   @Override public FrameReader newReader(InputStream in, boolean client) {
@@ -69,12 +76,14 @@
   static final class Reader implements FrameReader {
     private final DataInputStream in;
     private final boolean client;
-    private final Hpack.Reader hpackReader;
+
+    // Visible for testing.
+    final HpackDraft05.Reader hpackReader;
 
     Reader(InputStream in, boolean client) {
       this.in = new DataInputStream(in);
       this.client = client;
-      this.hpackReader = new Hpack.Reader(this.in, client);
+      this.hpackReader = new HpackDraft05.Reader(this.in);
     }
 
     @Override public void readConnectionHeader() throws IOException {
@@ -96,7 +105,8 @@
       }
       int w2 = in.readInt();
 
-      int length = (w1 & 0xffff0000) >> 16;
+      // boolean r = (w1 & 0xc0000000) != 0; // Reserved.
+      int length = (w1 & 0x3fff0000) >> 16; // 14-bit unsigned.
       int type = (w1 & 0xff00) >> 8;
       int flags = w1 & 0xff;
       // boolean r = (w2 & 0x80000000) != 0; // Reserved.
@@ -154,9 +164,11 @@ private void readHeaders(Handler handler, int flags, int length, int streamId)
 
         if ((flags & FLAG_END_HEADERS) != 0) {
           hpackReader.emitReferenceSet();
-          List<String> namesAndValues = hpackReader.getAndReset();
+          List<ByteString> nameValueBlock = hpackReader.getAndReset();
+          // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
+          // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
           int priority = -1; // TODO: priority
-          handler.headers(false, inFinished, streamId, -1, priority, namesAndValues,
+          handler.headers(false, inFinished, streamId, -1, priority, nameValueBlock,
               HeadersMode.HTTP_20_HEADERS);
           return;
         }
@@ -165,13 +177,11 @@ private void readHeaders(Handler handler, int flags, int length, int streamId)
         int w1 = in.readInt();
         int w2 = in.readInt();
 
-        length = (w1 & 0xffff0000) >> 16;
+        // boolean r = (w1 & 0xc0000000) != 0; // Reserved.
+        length = (w1 & 0x3fff0000) >> 16; // 14-bit unsigned.
         int newType = (w1 & 0xff00) >> 8;
         flags = w1 & 0xff;
 
-        // TODO: remove in draft 8: CONTINUATION no longer sets END_STREAM
-        inFinished = (flags & FLAG_END_STREAM) != 0;
-
         // boolean u = (w2 & 0x80000000) != 0; // Unused.
         int newStreamId = (w2 & 0x7fffffff);
 
@@ -184,6 +194,7 @@ private void readHeaders(Handler handler, int flags, int length, int streamId)
 
     private void readData(Handler handler, int flags, int length, int streamId) throws IOException {
       boolean inFinished = (flags & FLAG_END_STREAM) != 0;
+      // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
       handler.data(inFinished, streamId, in, length);
     }
 
@@ -211,6 +222,13 @@ private void readRstStream(Handler handler, int flags, int length, int streamId)
 
     private void readSettings(Handler handler, int flags, int length, int streamId)
         throws IOException {
+      if ((flags & FLAG_ACK) != 0) {
+        if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
+        // TODO: signal apply changes
+        // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-6.5.3
+        return;
+      }
+
       if (length % 8 != 0) throw ioException("TYPE_SETTINGS length %% 8 != 0: %s", length);
       if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
       Settings settings = new Settings();
@@ -233,7 +251,7 @@ private void readPing(Handler handler, int flags, int length, int streamId) thro
       if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
       int payload1 = in.readInt();
       int payload2 = in.readInt();
-      boolean reply = (flags & FLAG_PONG) != 0;
+      boolean reply = (flags & FLAG_ACK) != 0;
       handler.ping(reply, payload1, payload2);
     }
 
@@ -262,10 +280,6 @@ private void readWindowUpdate(Handler handler, int flags, int length, int stream
       handler.windowUpdate(streamId, windowSizeIncrement, endFlowControl);
     }
 
-    private static IOException ioException(String message, Object... args) throws IOException {
-      throw new IOException(String.format(message, args));
-    }
-
     @Override public void close() throws IOException {
       in.close();
     }
@@ -275,13 +289,13 @@ private static IOException ioException(String message, Object... args) throws IO
     private final DataOutputStream out;
     private final boolean client;
     private final ByteArrayOutputStream hpackBuffer;
-    private final Hpack.Writer hpackWriter;
+    private final HpackDraft05.Writer hpackWriter;
 
     Writer(OutputStream out, boolean client) {
       this.out = new DataOutputStream(out);
       this.client = client;
       this.hpackBuffer = new ByteArrayOutputStream();
-      this.hpackWriter = new Hpack.Writer(hpackBuffer);
+      this.hpackWriter = new HpackDraft05.Writer(hpackBuffer);
     }
 
     @Override public synchronized void flush() throws IOException {
@@ -293,34 +307,36 @@ private static IOException ioException(String message, Object... args) throws IO
       out.write(CONNECTION_HEADER);
     }
 
-    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, int priority, int slot, List<String> nameValueBlock)
+    @Override
+    public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId,
+        int associatedStreamId, int priority, int slot, List<ByteString> nameValueBlock)
         throws IOException {
       if (inFinished) throw new UnsupportedOperationException();
       headers(outFinished, streamId, priority, nameValueBlock);
     }
 
     @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<String> nameValueBlock) throws IOException {
+        List<ByteString> nameValueBlock) throws IOException {
       headers(outFinished, streamId, -1, nameValueBlock);
     }
 
-    @Override public synchronized void headers(int streamId, List<String> nameValueBlock)
+    @Override public synchronized void headers(int streamId, List<ByteString> nameValueBlock)
         throws IOException {
       headers(false, streamId, -1, nameValueBlock);
     }
 
     private void headers(boolean outFinished, int streamId, int priority,
-        List<String> nameValueBlock) throws IOException {
+        List<ByteString> nameValueBlock) throws IOException {
       hpackBuffer.reset();
       hpackWriter.writeHeaders(nameValueBlock);
       int type = TYPE_HEADERS;
       // TODO: implement CONTINUATION
       int length = hpackBuffer.size();
+      checkFrameSize(length);
       int flags = FLAG_END_HEADERS;
       if (outFinished) flags |= FLAG_END_STREAM;
       if (priority != -1) flags |= FLAG_PRIORITY;
-      out.writeInt((length & 0xffff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
+      out.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
       out.writeInt(streamId & 0x7fffffff);
       if (priority != -1) out.writeInt(priority & 0x7fffffff);
       hpackBuffer.writeTo(out);
@@ -328,7 +344,14 @@ private void headers(boolean outFinished, int streamId, int priority,
 
     @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
         throws IOException {
-      throw new UnsupportedOperationException("TODO");
+      if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
+      int flags = 0;
+      int type = TYPE_RST_STREAM;
+      int length = 4;
+      out.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
+      out.writeInt(streamId & 0x7fffffff);
+      out.writeInt(errorCode.httpCode);
+      out.flush();
     }
 
     @Override public void data(boolean outFinished, int streamId, byte[] data) throws IOException {
@@ -340,7 +363,9 @@ private void headers(boolean outFinished, int streamId, int priority,
       int type = TYPE_DATA;
       int flags = 0;
       if (outFinished) flags |= FLAG_END_STREAM;
-      out.writeInt((byteCount & 0xffff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
+      // TODO: Implement looping strategy.
+      checkFrameSize(byteCount);
+      out.writeInt((byteCount & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
       out.writeInt(streamId & 0x7fffffff);
       out.write(data, offset, byteCount);
     }
@@ -350,7 +375,7 @@ private void headers(boolean outFinished, int streamId, int priority,
       int length = settings.size() * 8;
       int flags = 0;
       int streamId = 0;
-      out.writeInt((length & 0xffff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
+      out.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
       out.writeInt(streamId & 0x7fffffff);
       for (int i = 0; i < Settings.COUNT; i++) {
         if (!settings.isSet(i)) continue;
@@ -382,4 +407,12 @@ private void headers(boolean outFinished, int streamId, int priority,
       out.close();
     }
   }
+
+  private static void checkFrameSize(int bytes) throws IOException {
+    if (bytes > 16383) throw ioException("FRAME_SIZE_ERROR max size is 16383: %s", bytes);
+  }
+
+  private static IOException ioException(String message, Object... args) throws IOException {
+    throw new IOException(String.format(message, args));
+  }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
index b95d013818..85af6ed40d 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
@@ -1,5 +1,6 @@
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
 import java.io.Closeable;
 import java.io.DataInputStream;
@@ -71,7 +72,7 @@ public FillableInflaterInputStream(InputStream in, Inflater inf) {
     }
   }
 
-  public List<String> readNameValueBlock(int length) throws IOException {
+  public List<ByteString> readNameValueBlock(int length) throws IOException {
     this.compressedLimit += length;
     try {
       int numberOfPairs = nameValueBlockIn.readInt();
@@ -81,11 +82,11 @@ public FillableInflaterInputStream(InputStream in, Inflater inf) {
       if (numberOfPairs > 1024) {
         throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
       }
-      List<String> entries = new ArrayList<String>(numberOfPairs * 2);
+      List<ByteString> entries = new ArrayList<ByteString>(numberOfPairs * 2);
       for (int i = 0; i < numberOfPairs; i++) {
-        String name = readString();
-        String values = readString();
-        if (name.length() == 0) throw new IOException("name.length == 0");
+        ByteString name = readString();
+        ByteString values = readString();
+        if (name.size() == 0) throw new IOException("name.size == 0");
         entries.add(name);
         entries.add(values);
       }
@@ -110,11 +111,11 @@ private void doneReading() throws IOException {
     }
   }
 
-  private String readString() throws DataFormatException, IOException {
+  private ByteString readString() throws DataFormatException, IOException {
     int length = nameValueBlockIn.readInt();
     byte[] bytes = new byte[length];
     Util.readFully(nameValueBlockIn, bytes);
-    return new String(bytes, 0, length, "UTF-8");
+    return ByteString.of(bytes);
   }
 
   @Override public void close() throws IOException {
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
index 05380e27e1..f8b13ae330 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
@@ -17,10 +17,14 @@
 
 final class Settings {
   /**
-   * From the spdy/3 spec, the default initial window size for all streams is
-   * 64 KiB. (Chrome 25 uses 10 MiB).
+   * spdy/3: The default initial window size for all streams is 64 KiB. (Chrome
+   * 25 uses 10 MiB).
    */
   static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
+  /** http/2: The default header compression table size is 4 KiB. */
+  static final int DEFAULT_HEADER_TABLE_SIZE = 4096;
+  /** http/2: The default is to enable PUSH_PROMISE frames. */
+  static final int DEFAULT_ENABLE_PUSH = 1;
 
   /** Peer request to clear durable settings. */
   static final int FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS = 0x1;
@@ -30,24 +34,28 @@
   /** Sent by clients only. The client is reminding the server of a persisted value. */
   static final int PERSISTED = 0x2;
 
-  /** Sender's estimate of max incoming kbps. */
+  /** spdy/3: Sender's estimate of max incoming kbps. */
   static final int UPLOAD_BANDWIDTH = 1;
-  /** Sender's estimate of max outgoing kbps. */
+  /** http/2: Size in bytes of the table used to decode the sender's header blocks. */
+  static final int HEADER_TABLE_SIZE = 1;
+  /** spdy/3: Sender's estimate of max outgoing kbps. */
   static final int DOWNLOAD_BANDWIDTH = 2;
-  /** Sender's estimate of milliseconds between sending a request and receiving a response. */
+  /** http/2: An endpoint must not send a PUSH_PROMISE frame when this is 0. */
+  static final int ENABLE_PUSH = 2;
+  /** spdy/3: Sender's estimate of millis between sending a request and receiving a response. */
   static final int ROUND_TRIP_TIME = 3;
   /** Sender's maximum number of concurrent streams. */
   static final int MAX_CONCURRENT_STREAMS = 4;
-  /** Current CWND in Packets. */
+  /** spdy/3: Current CWND in Packets. */
   static final int CURRENT_CWND = 5;
-  /** Retransmission rate. Percentage */
+  /** spdy/3: Retransmission rate. Percentage */
   static final int DOWNLOAD_RETRANS_RATE = 6;
   /** Window size in bytes. */
   static final int INITIAL_WINDOW_SIZE = 7;
-  /** Window size in bytes. */
+  /** spdy/3: Window size in bytes. */
   static final int CLIENT_CERTIFICATE_VECTOR_SIZE = 8;
   /** Flow control options. */
-  static final int FLOW_CONTROL_OPTIONS = 9;
+  static final int FLOW_CONTROL_OPTIONS = 10;
 
   /** Total number of settings. */
   static final int COUNT = 10;
@@ -112,47 +120,69 @@ int size() {
     return Integer.bitCount(set);
   }
 
+  /** spdy/3 only. */
   int getUploadBandwidth(int defaultValue) {
     int bit = 1 << UPLOAD_BANDWIDTH;
     return (bit & set) != 0 ? values[UPLOAD_BANDWIDTH] : defaultValue;
   }
 
+  /** http/2 only. */
+  // TODO: honor this setting in http/2.
+  int getHeaderTableSize() {
+    int bit = 1 << HEADER_TABLE_SIZE;
+    return (bit & set) != 0 ? values[HEADER_TABLE_SIZE] : DEFAULT_HEADER_TABLE_SIZE;
+  }
+
+  /** spdy/3 only. */
   int getDownloadBandwidth(int defaultValue) {
     int bit = 1 << DOWNLOAD_BANDWIDTH;
     return (bit & set) != 0 ? values[DOWNLOAD_BANDWIDTH] : defaultValue;
   }
 
+  /** http/2 only. */
+  // TODO: honor this setting in http/2.
+  boolean getEnablePush() {
+    int bit = 1 << ENABLE_PUSH;
+    return ((bit & set) != 0 ? values[ENABLE_PUSH] : DEFAULT_ENABLE_PUSH) == 1;
+  }
+
+  /** spdy/3 only. */
   int getRoundTripTime(int defaultValue) {
     int bit = 1 << ROUND_TRIP_TIME;
     return (bit & set) != 0 ? values[ROUND_TRIP_TIME] : defaultValue;
   }
 
+  // TODO: honor this setting in spdy/3 and http/2.
   int getMaxConcurrentStreams(int defaultValue) {
     int bit = 1 << MAX_CONCURRENT_STREAMS;
     return (bit & set) != 0 ? values[MAX_CONCURRENT_STREAMS] : defaultValue;
   }
 
+  /** spdy/3 only. */
   int getCurrentCwnd(int defaultValue) {
     int bit = 1 << CURRENT_CWND;
     return (bit & set) != 0 ? values[CURRENT_CWND] : defaultValue;
   }
 
+  /** spdy/3 only. */
   int getDownloadRetransRate(int defaultValue) {
     int bit = 1 << DOWNLOAD_RETRANS_RATE;
     return (bit & set) != 0 ? values[DOWNLOAD_RETRANS_RATE] : defaultValue;
   }
 
+  // TODO: honor this setting in http/2.
   int getInitialWindowSize(int defaultValue) {
     int bit = 1 << INITIAL_WINDOW_SIZE;
     return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : defaultValue;
   }
 
+  /** spdy/3 only. */
   int getClientCertificateVectorSize(int defaultValue) {
     int bit = 1 << CLIENT_CERTIFICATE_VECTOR_SIZE;
     return (bit & set) != 0 ? values[CLIENT_CERTIFICATE_VECTOR_SIZE] : defaultValue;
   }
 
-  // TODO: honor this setting.
+  // TODO: honor this setting in spdy/3 and http/2.
   boolean isFlowControlDisabled() {
     int bit = 1 << FLOW_CONTROL_OPTIONS;
     int value = (bit & set) != 0 ? values[FLOW_CONTROL_OPTIONS] : 0;
@@ -160,7 +190,7 @@ boolean isFlowControlDisabled() {
   }
 
   /**
-   * Returns true if this user agent should use this setting in future SPDY
+   * Returns true if this user agent should use this setting in future spdy/3
    * connections to the same host.
    */
   boolean persistValue(int id) {
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 5d9a49b3a2..595ea7b787 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayOutputStream;
@@ -29,6 +30,11 @@
 import java.util.zip.Deflater;
 
 final class Spdy3 implements Variant {
+
+  @Override public String getProtocol() {
+    return "spdy/3";
+  }
+
   static final int TYPE_DATA = 0x0;
   static final int TYPE_SYN_STREAM = 0x1;
   static final int TYPE_SYN_REPLY = 0x2;
@@ -196,7 +202,7 @@ private void readSynStream(Handler handler, int flags, int length) throws IOExce
       int associatedStreamId = w2 & 0x7fffffff;
       int priority = (s3 & 0xe000) >>> 13;
       int slot = s3 & 0xff;
-      List<String> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 10);
+      List<ByteString> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 10);
 
       boolean inFinished = (flags & FLAG_FIN) != 0;
       boolean outFinished = (flags & FLAG_UNIDIRECTIONAL) != 0;
@@ -207,7 +213,7 @@ private void readSynStream(Handler handler, int flags, int length) throws IOExce
     private void readSynReply(Handler handler, int flags, int length) throws IOException {
       int w1 = in.readInt();
       int streamId = w1 & 0x7fffffff;
-      List<String> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 4);
+      List<ByteString> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 4);
       boolean inFinished = (flags & FLAG_FIN) != 0;
       handler.headers(false, inFinished, streamId, -1, -1, nameValueBlock, HeadersMode.SPDY_REPLY);
     }
@@ -226,7 +232,7 @@ private void readRstStream(Handler handler, int flags, int length) throws IOExce
     private void readHeaders(Handler handler, int flags, int length) throws IOException {
       int w1 = in.readInt();
       int streamId = w1 & 0x7fffffff;
-      List<String> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 4);
+      List<ByteString> nameValueBlock = nameValueBlockReader.readNameValueBlock(length - 4);
       handler.headers(false, false, streamId, -1, -1, nameValueBlock, HeadersMode.SPDY_HEADERS);
     }
 
@@ -309,8 +315,9 @@ private static IOException ioException(String message, Object... args) throws IO
       out.flush();
     }
 
-    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, int priority, int slot, List<String> nameValueBlock)
+    @Override
+    public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId,
+        int associatedStreamId, int priority, int slot, List<ByteString> nameValueBlock)
         throws IOException {
       writeNameValueBlockToBuffer(nameValueBlock);
       int length = 10 + nameValueBlockBuffer.size();
@@ -327,8 +334,8 @@ private static IOException ioException(String message, Object... args) throws IO
       out.flush();
     }
 
-    @Override public synchronized void synReply(
-        boolean outFinished, int streamId, List<String> nameValueBlock) throws IOException {
+    @Override public synchronized void synReply(boolean outFinished, int streamId,
+        List<ByteString> nameValueBlock) throws IOException {
       writeNameValueBlockToBuffer(nameValueBlock);
       int type = TYPE_SYN_REPLY;
       int flags = (outFinished ? FLAG_FIN : 0);
@@ -341,7 +348,7 @@ private static IOException ioException(String message, Object... args) throws IO
       out.flush();
     }
 
-    @Override public synchronized void headers(int streamId, List<String> nameValueBlock)
+    @Override public synchronized void headers(int streamId, List<ByteString> nameValueBlock)
         throws IOException {
       writeNameValueBlockToBuffer(nameValueBlock);
       int flags = 0;
@@ -381,13 +388,14 @@ private static IOException ioException(String message, Object... args) throws IO
       out.write(data, offset, byteCount);
     }
 
-    private void writeNameValueBlockToBuffer(List<String> nameValueBlock) throws IOException {
+    private void writeNameValueBlockToBuffer(List<ByteString> nameValueBlock) throws IOException {
       nameValueBlockBuffer.reset();
       int numberOfPairs = nameValueBlock.size() / 2;
       nameValueBlockOut.writeInt(numberOfPairs);
-      for (String s : nameValueBlock) {
-        nameValueBlockOut.writeInt(s.length());
-        nameValueBlockOut.write(s.getBytes("UTF-8"));
+      for (int i = 0, size = nameValueBlock.size(); i < size; i++) {
+        ByteString s = nameValueBlock.get(i);
+        nameValueBlockOut.writeInt(s.size());
+        s.write(nameValueBlockOut);
       }
       nameValueBlockOut.flush();
     }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index 41724f0787..8b09f09b68 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Util;
 import java.io.Closeable;
@@ -59,7 +60,7 @@
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
       Util.daemonThreadFactory("OkHttp SpdyConnection"));
 
-  /** The protocol variant, like SPDY/3 or HTTP-draft-06/2.0. */
+  /** The protocol variant, like SPDY/3 or HTTP-draft-09/2.0. */
   final Variant variant;
 
   /** True if this peer initiated the connection. */
@@ -87,6 +88,8 @@
   /** Lazily-created settings for the peer. */
   Settings settings;
 
+  ByteArrayPool bufferPool = new ByteArrayPool(8 * Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+
   private SpdyConnection(Builder builder) {
     variant = builder.variant;
     client = builder.client;
@@ -101,6 +104,15 @@ private SpdyConnection(Builder builder) {
     new Thread(new Reader(), "Spdy Reader " + hostName).start();
   }
 
+  /**
+   * The protocol name, like {@code spdy/3} or {@code HTTP-draft-09/2.0}.
+   *
+   * @see com.squareup.okhttp.internal.spdy.Variant#getProtocol()
+   */
+  public String getProtocol() {
+     return variant.getProtocol();
+  }
+
   /**
    * Returns the number of {@link SpdyStream#isOpen() open streams} on this
    * connection.
@@ -146,12 +158,12 @@ public synchronized long getIdleStartTimeNs() {
    * @param in true to create an input stream that the remote peer can use to
    *     send data to us. Corresponds to {@code FLAG_UNIDIRECTIONAL}.
    */
-  public SpdyStream newStream(List<String> requestHeaders, boolean out, boolean in)
+  public SpdyStream newStream(List<ByteString> requestHeaders, boolean out, boolean in)
       throws IOException {
     boolean outFinished = !out;
     boolean inFinished = !in;
     int associatedStreamId = 0;  // TODO: permit the caller to specify an associated stream?
-    int priority = 0; // TODO: permit the caller to specify a priority?
+    int priority = -1; // TODO: permit the caller to specify a priority?
     int slot = 0; // TODO: permit the caller to specify a slot?
     SpdyStream stream;
     int streamId;
@@ -178,7 +190,7 @@ public SpdyStream newStream(List<String> requestHeaders, boolean out, boolean in
     return stream;
   }
 
-  void writeSynReply(int streamId, boolean outFinished, List<String> alternating)
+  void writeSynReply(int streamId, boolean outFinished, List<ByteString> alternating)
       throws IOException {
     frameWriter.synReply(outFinished, streamId, alternating);
   }
@@ -416,8 +428,8 @@ public Builder spdy3() {
       return this;
     }
 
-    public Builder http20Draft06() {
-      this.variant = Variant.HTTP_20_DRAFT_06;
+    public Builder http20Draft09() {
+      this.variant = Variant.HTTP_20_DRAFT_09;
       return this;
     }
 
@@ -461,7 +473,7 @@ public SpdyConnection build() {
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<String> nameValueBlock,
+        int associatedStreamId, int priority, List<ByteString> nameValueBlock,
         HeadersMode headersMode) {
       SpdyStream stream;
       synchronized (SpdyConnection.this) {
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index e550022030..baf7e6dc18 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.io.InputStream;
@@ -48,13 +49,13 @@
   private int writeWindowSize;
 
   /** Headers sent by the stream initiator. Immutable and non null. */
-  private final List<String> requestHeaders;
+  private final List<ByteString> requestHeaders;
 
   /** Headers sent in the stream reply. Null if reply is either not sent or not sent yet. */
-  private List<String> responseHeaders;
+  private List<ByteString> responseHeaders;
 
-  private final SpdyDataInputStream in = new SpdyDataInputStream();
-  private final SpdyDataOutputStream out = new SpdyDataOutputStream();
+  private final SpdyDataInputStream in;
+  private final SpdyDataOutputStream out;
 
   /**
    * The reason why this stream was abnormally closed. If there are multiple
@@ -64,11 +65,13 @@
   private ErrorCode errorCode = null;
 
   SpdyStream(int id, SpdyConnection connection, boolean outFinished, boolean inFinished,
-      int priority, List<String> requestHeaders, Settings settings) {
+      int priority, List<ByteString> requestHeaders, Settings settings) {
     if (connection == null) throw new NullPointerException("connection == null");
     if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
     this.id = id;
     this.connection = connection;
+    this.in = new SpdyDataInputStream();
+    this.out = new SpdyDataOutputStream();
     this.in.finished = inFinished;
     this.out.finished = outFinished;
     this.priority = priority;
@@ -107,7 +110,7 @@ public SpdyConnection getConnection() {
     return connection;
   }
 
-  public List<String> getRequestHeaders() {
+  public List<ByteString> getRequestHeaders() {
     return requestHeaders;
   }
 
@@ -115,10 +118,24 @@ public SpdyConnection getConnection() {
    * Returns the stream's response headers, blocking if necessary if they
    * have not been received yet.
    */
-  public synchronized List<String> getResponseHeaders() throws IOException {
+  public synchronized List<ByteString> getResponseHeaders() throws IOException {
+    long remaining = 0;
+    long start = 0;
+    if (readTimeoutMillis != 0) {
+      start = (System.nanoTime() / 1000000);
+      remaining = readTimeoutMillis;
+    }
     try {
       while (responseHeaders == null && errorCode == null) {
-        wait();
+        if (readTimeoutMillis == 0) { // No timeout configured.
+          wait();
+        } else if (remaining > 0) {
+          wait(remaining);
+          remaining = start + readTimeoutMillis - (System.nanoTime() / 1000000);
+        } else {
+          throw new SocketTimeoutException("Read response header timeout. readTimeoutMillis: "
+                            + readTimeoutMillis);
+        }
       }
       if (responseHeaders != null) {
         return responseHeaders;
@@ -145,7 +162,7 @@ public synchronized ErrorCode getErrorCode() {
    * @param out true to create an output stream that we can use to send data
    * to the remote peer. Corresponds to {@code FLAG_FIN}.
    */
-  public void reply(List<String> responseHeaders, boolean out) throws IOException {
+  public void reply(List<ByteString> responseHeaders, boolean out) throws IOException {
     assert (!Thread.holdsLock(SpdyStream.this));
     boolean outFinished = false;
     synchronized (this) {
@@ -238,7 +255,7 @@ private boolean closeInternal(ErrorCode errorCode) {
     return true;
   }
 
-  void receiveHeaders(List<String> headers, HeadersMode headersMode) {
+  void receiveHeaders(List<ByteString> headers, HeadersMode headersMode) {
     assert (!Thread.holdsLock(SpdyStream.this));
     ErrorCode errorCode = null;
     boolean open = true;
@@ -255,7 +272,7 @@ void receiveHeaders(List<String> headers, HeadersMode headersMode) {
         if (headersMode.failIfHeadersPresent()) {
           errorCode = ErrorCode.STREAM_IN_USE;
         } else {
-          List<String> newHeaders = new ArrayList<String>();
+          List<ByteString> newHeaders = new ArrayList<ByteString>();
           newHeaders.addAll(responseHeaders);
           newHeaders.addAll(headers);
           this.responseHeaders = newHeaders;
@@ -336,7 +353,8 @@ int getPriority() {
     //         ^       ^
     //       limit    pos
 
-    private final byte[] buffer = new byte[Settings.DEFAULT_INITIAL_WINDOW_SIZE];
+    private final byte[] buffer = SpdyStream.this.connection.bufferPool.getBuf(
+        Settings.DEFAULT_INITIAL_WINDOW_SIZE);
 
     /** the next byte to be read, or -1 if the buffer is empty. Never buffer.length */
     private int pos = -1;
@@ -516,6 +534,7 @@ void receive(InputStream in, int byteCount) throws IOException {
       synchronized (SpdyStream.this) {
         closed = true;
         SpdyStream.this.notifyAll();
+        SpdyStream.this.connection.bufferPool.returnBuf(buffer);
       }
       cancelStreamIfNecessary();
     }
@@ -554,7 +573,7 @@ private void cancelStreamIfNecessary() throws IOException {
    * is not thread safe.
    */
   private final class SpdyDataOutputStream extends OutputStream {
-    private final byte[] buffer = new byte[8192];
+    private final byte[] buffer = SpdyStream.this.connection.bufferPool.getBuf(8192);
     private int pos = 0;
 
     /** True if the caller has closed this stream. */
@@ -610,6 +629,7 @@ private void cancelStreamIfNecessary() throws IOException {
           return;
         }
         closed = true;
+        SpdyStream.this.connection.bufferPool.returnBuf(buffer);
       }
       if (!out.finished) {
         writeFrame(true);
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
index 8f48bcd244..3ff3e0b2f9 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
@@ -21,7 +21,10 @@
 /** A version and dialect of the framed socket protocol. */
 interface Variant {
   Variant SPDY3 = new Spdy3();
-  Variant HTTP_20_DRAFT_06 = new Http20Draft06();
+  Variant HTTP_20_DRAFT_09 = new Http20Draft09();
+
+  /** The protocol name, like {@code spdy/3} or {@code HTTP-draft-09/2.0}. */
+  String getProtocol();
 
   /**
    * @param client true if this is the HTTP client's reader, reading frames from
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
new file mode 100644
index 0000000000..95b91d176e
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2014 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
+import java.util.Arrays;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class ByteStringTest {
+
+  @Test public void equals() throws Exception {
+    ByteString byteString = ByteString.of((byte) 0x0, (byte) 0x1, (byte) 0x2);
+    assertTrue(byteString.equals(byteString));
+    assertTrue(byteString.equals(ByteString.of((byte) 0x0, (byte) 0x1, (byte) 0x2)));
+    assertTrue(ByteString.of().equals(ByteString.EMPTY));
+    assertTrue(ByteString.EMPTY.equals(ByteString.of()));
+    assertFalse(byteString.equals(new Object()));
+    assertFalse(byteString.equals(ByteString.of((byte) 0x0, (byte) 0x2, (byte) 0x1)));
+  }
+
+  private final String bronzeHorseman = "   ";
+
+  @Test public void utf8() throws Exception {
+    ByteString byteString = ByteString.encodeUtf8(bronzeHorseman);
+    assertByteArraysEquals(byteString.toByteArray(), bronzeHorseman.getBytes("UTF-8"));
+    assertTrue(byteString.equals(ByteString.of(bronzeHorseman.getBytes("UTF-8"))));
+    assertTrue(byteString.utf8Equals(bronzeHorseman));
+    assertEquals(byteString.utf8(), bronzeHorseman);
+  }
+
+  @Test public void testHashCode() throws Exception {
+    ByteString byteString = ByteString.of((byte) 0x1, (byte) 0x2);
+    assertEquals(byteString.hashCode(), byteString.hashCode());
+    assertEquals(byteString.hashCode(), ByteString.of((byte) 0x1, (byte) 0x2).hashCode());
+  }
+
+  @Test public void read() throws Exception {
+    InputStream in = new ByteArrayInputStream("abc".getBytes("UTF-8"));
+    assertEquals(ByteString.of((byte) 0x61, (byte) 0x62), ByteString.read(in, 2));
+    assertEquals(ByteString.of((byte) 0x63), ByteString.read(in, 1));
+    assertEquals(ByteString.of(), ByteString.read(in, 0));
+  }
+
+  @Test public void write() throws Exception {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    ByteString.of((byte) 0x61, (byte) 0x62, (byte) 0x63).write(out);
+    assertByteArraysEquals(new byte[] { 0x61, 0x62, 0x63 }, out.toByteArray());
+  }
+
+  @Test public void writeWithOffset() throws Exception {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    ByteString.of((byte) 0x61, (byte) 0x62, (byte) 0x63).write(out, 1, 2);
+    assertByteArraysEquals(new byte[] { 0x62, 0x63 }, out.toByteArray());
+  }
+
+  @Test public void concat() {
+    assertEquals(ByteString.of(), ByteString.concat());
+    assertEquals(ByteString.of(), ByteString.concat(ByteString.EMPTY));
+    assertEquals(ByteString.of(), ByteString.concat(ByteString.EMPTY, ByteString.EMPTY));
+    ByteString foo = ByteString.encodeUtf8("foo");
+    ByteString bar = ByteString.encodeUtf8("bar");
+    assertEquals(foo, ByteString.concat(foo));
+    assertEquals(ByteString.encodeUtf8("foobar"), ByteString.concat(foo, bar));
+  }
+
+  private static void assertByteArraysEquals(byte[] a, byte[] b) {
+    assertEquals(Arrays.toString(a), Arrays.toString(b));
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
index 95e6441679..9933b09a82 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.ByteString;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.List;
@@ -29,7 +30,7 @@
 
   @Override
   public void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      int priority, List<String> nameValueBlock, HeadersMode headersMode) {
+      int priority, List<ByteString> nameValueBlock, HeadersMode headersMode) {
     fail();
   }
 
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ByteArrayPoolTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ByteArrayPoolTest.java
new file mode 100644
index 0000000000..23df684070
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ByteArrayPoolTest.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.spdy;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertSame;
+
+public class ByteArrayPoolTest {
+  @Test public void testReusesBuffer() {
+    ByteArrayPool pool = new ByteArrayPool(32);
+
+    byte[] buf1 = pool.getBuf(16);
+    byte[] buf2 = pool.getBuf(16);
+
+    pool.returnBuf(buf1);
+    pool.returnBuf(buf2);
+
+    byte[] buf3 = pool.getBuf(16);
+    byte[] buf4 = pool.getBuf(16);
+    assertTrue(buf3 == buf1 || buf3 == buf2);
+    assertTrue(buf4 == buf1 || buf4 == buf2);
+    assertTrue(buf3 != buf4);
+  }
+
+  @Test public void testObeysSizeLimit() {
+    ByteArrayPool pool = new ByteArrayPool(32);
+
+    byte[] buf1 = pool.getBuf(16);
+    byte[] buf2 = pool.getBuf(16);
+    byte[] buf3 = pool.getBuf(16);
+
+    pool.returnBuf(buf1);
+    pool.returnBuf(buf2);
+    pool.returnBuf(buf3);
+
+    byte[] buf4 = pool.getBuf(16);
+    byte[] buf5 = pool.getBuf(16);
+    byte[] buf6 = pool.getBuf(16);
+
+    assertTrue(buf4 == buf2 || buf4 == buf3);
+    assertTrue(buf5 == buf2 || buf5 == buf3);
+    assertTrue(buf4 != buf5);
+    assertTrue(buf6 != buf1 && buf6 != buf2 && buf6 != buf3);
+  }
+
+  @Test public void testReturnsBufferWithRightSize() {
+    ByteArrayPool pool = new ByteArrayPool(32);
+
+    byte[] buf1 = pool.getBuf(16);
+    pool.returnBuf(buf1);
+
+    byte[] buf2 = pool.getBuf(17);
+    assertNotSame(buf2, buf1);
+
+    byte[] buf3 = pool.getBuf(15);
+    assertSame(buf3, buf1);
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
new file mode 100644
index 0000000000..4b8fef9f41
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -0,0 +1,453 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.ByteString;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.Util.byteStringList;
+import static org.junit.Assert.assertEquals;
+
+public class HpackDraft05Test {
+
+  private final MutableByteArrayInputStream bytesIn = new MutableByteArrayInputStream();
+  private HpackDraft05.Reader hpackReader;
+
+  @Before public void resetReader() {
+    hpackReader = new HpackDraft05.Reader(new DataInputStream(bytesIn));
+  }
+
+  /**
+   * HPACK has a max header table size, which can be smaller than the max header message.
+   * Ensure the larger header content is not lost.
+   */
+  @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
+    char[] tooLarge = new char[4096];
+    Arrays.fill(tooLarge, 'a');
+    final List<ByteString> sentHeaders = byteStringList("foo", new String(tooLarge));
+
+    ByteArrayOutputStream out = literalHeaders(sentHeaders);
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+
+    assertEquals(0, hpackReader.headerTable.size());
+
+    assertEquals(sentHeaders, hpackReader.getAndReset());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.1
+   */
+  @Test public void decodeLiteralHeaderFieldWithIndexing() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x00); // Literal indexed
+    out.write(0x0a); // Literal name (len = 10)
+    out.write("custom-key".getBytes(), 0, 10);
+
+    out.write(0x0d); // Literal value (len = 13)
+    out.write("custom-header".getBytes(), 0, 13);
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+
+    assertEquals(1, hpackReader.headerTable.size());
+    assertEquals(55, hpackReader.headerTableSize);
+
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
+    checkEntry(entry, "custom-key", "custom-header", 55, true);
+
+    assertEquals(byteStringList("custom-key", "custom-header"), hpackReader.getAndReset());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.2
+   */
+  @Test public void decodeLiteralHeaderFieldWithoutIndexingIndexedName() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x44); // == Literal not indexed ==
+                     // Indexed name (idx = 4) -> :path
+    out.write(0x0c); // Literal value (len = 12)
+    out.write("/sample/path".getBytes(), 0, 12);
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+
+    assertEquals(0, hpackReader.headerTable.size());
+
+    assertEquals(byteStringList(":path", "/sample/path"), hpackReader.getAndReset());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.3
+   */
+  @Test public void decodeIndexedHeaderField() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x82); // == Indexed - Add ==
+                     // idx = 2 -> :method: GET
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+
+    assertEquals(1, hpackReader.headerTable.size());
+    assertEquals(42, hpackReader.headerTableSize);
+
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
+    checkEntry(entry, ":method", "GET", 42, true);
+
+    assertEquals(byteStringList(":method", "GET"), hpackReader.getAndReset());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.4
+   */
+  @Test public void decodeIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x82); // == Indexed - Add ==
+                     // idx = 2 -> :method: GET
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.maxHeaderTableSize = 0; // SETTINGS_HEADER_TABLE_SIZE == 0
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+
+    // Not buffered in header table.
+    assertEquals(0, hpackReader.headerTable.size());
+
+    assertEquals(byteStringList(":method", "GET"), hpackReader.getAndReset());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.2
+   */
+  @Test public void decodeRequestExamplesWithoutHuffman() throws IOException {
+    ByteArrayOutputStream out = firstRequestWithoutHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+    checkFirstRequestWithoutHuffman();
+
+    out = secondRequestWithoutHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+    checkSecondRequestWithoutHuffman();
+
+    out = thirdRequestWithoutHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders(out.size());
+    hpackReader.emitReferenceSet();
+    checkThirdRequestWithoutHuffman();
+  }
+
+  private ByteArrayOutputStream firstRequestWithoutHuffman() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x82); // == Indexed - Add ==
+                     // idx = 2 -> :method: GET
+    out.write(0x87); // == Indexed - Add ==
+                     // idx = 7 -> :scheme: http
+    out.write(0x86); // == Indexed - Add ==
+                     // idx = 6 -> :path: /
+    out.write(0x04); // == Literal indexed ==
+                     // Indexed name (idx = 4) -> :authority
+    out.write(0x0f); // Literal value (len = 15)
+    out.write("www.example.com".getBytes(), 0, 15);
+
+    return out;
+  }
+
+  private void checkFirstRequestWithoutHuffman() {
+    assertEquals(4, hpackReader.headerTable.size());
+
+    // [  1] (s =  57) :authority: www.example.com
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
+    checkEntry(entry, ":authority", "www.example.com", 57, true);
+
+    // [  2] (s =  38) :path: /
+    entry = hpackReader.headerTable.get(1);
+    checkEntry(entry, ":path", "/", 38, true);
+
+    // [  3] (s =  43) :scheme: http
+    entry = hpackReader.headerTable.get(2);
+    checkEntry(entry, ":scheme", "http", 43, true);
+
+    // [  4] (s =  42) :method: GET
+    entry = hpackReader.headerTable.get(3);
+    checkEntry(entry, ":method", "GET", 42, true);
+
+    // Table size: 180
+    assertEquals(180, hpackReader.headerTableSize);
+
+    // Decoded header set:
+    assertEquals(byteStringList(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com"), hpackReader.getAndReset());
+  }
+
+  private ByteArrayOutputStream secondRequestWithoutHuffman() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x1b); // == Literal indexed ==
+                     // Indexed name (idx = 27) -> cache-control
+    out.write(0x08); // Literal value (len = 8)
+    out.write("no-cache".getBytes(), 0, 8);
+
+    return out;
+  }
+
+  private void checkSecondRequestWithoutHuffman() {
+    assertEquals(5, hpackReader.headerTable.size());
+
+    // [  1] (s =  53) cache-control: no-cache
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
+    checkEntry(entry, "cache-control", "no-cache", 53, true);
+
+    // [  2] (s =  57) :authority: www.example.com
+    entry = hpackReader.headerTable.get(1);
+    checkEntry(entry, ":authority", "www.example.com", 57, true);
+
+    // [  3] (s =  38) :path: /
+    entry = hpackReader.headerTable.get(2);
+    checkEntry(entry, ":path", "/", 38, true);
+
+    // [  4] (s =  43) :scheme: http
+    entry = hpackReader.headerTable.get(3);
+    checkEntry(entry, ":scheme", "http", 43, true);
+
+    // [  5] (s =  42) :method: GET
+    entry = hpackReader.headerTable.get(4);
+    checkEntry(entry, ":method", "GET", 42, true);
+
+    // Table size: 233
+    assertEquals(233, hpackReader.headerTableSize);
+
+    // Decoded header set:
+    assertEquals(byteStringList(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com",
+        "cache-control", "no-cache"), hpackReader.getAndReset());
+  }
+
+  private ByteArrayOutputStream thirdRequestWithoutHuffman() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x80); // == Empty reference set ==
+    out.write(0x85); // == Indexed - Add ==
+                     // idx = 5 -> :method: GET
+    out.write(0x8c); // == Indexed - Add ==
+                     // idx = 12 -> :scheme: https
+    out.write(0x8b); // == Indexed - Add ==
+                     // idx = 11 -> :path: /index.html
+    out.write(0x84); // == Indexed - Add ==
+                     // idx = 4 -> :authority: www.example.com
+    out.write(0x00); // Literal indexed
+    out.write(0x0a); // Literal name (len = 10)
+    out.write("custom-key".getBytes(), 0, 10);
+    out.write(0x0c); // Literal value (len = 12)
+    out.write("custom-value".getBytes(), 0, 12);
+
+    return out;
+  }
+
+  private void checkThirdRequestWithoutHuffman() {
+    assertEquals(8, hpackReader.headerTable.size());
+
+    // [  1] (s =  54) custom-key: custom-value
+    HpackDraft05.HeaderEntry entry = hpackReader.headerTable.get(0);
+    checkEntry(entry, "custom-key", "custom-value", 54, true);
+
+    // [  2] (s =  48) :path: /index.html
+    entry = hpackReader.headerTable.get(1);
+    checkEntry(entry, ":path", "/index.html", 48, true);
+
+    // [  3] (s =  44) :scheme: https
+    entry = hpackReader.headerTable.get(2);
+    checkEntry(entry, ":scheme", "https", 44, true);
+
+    // [  4] (s =  53) cache-control: no-cache
+    entry = hpackReader.headerTable.get(3);
+    checkEntry(entry, "cache-control", "no-cache", 53, false);
+
+    // [  5] (s =  57) :authority: www.example.com
+    entry = hpackReader.headerTable.get(4);
+    checkEntry(entry, ":authority", "www.example.com", 57, true);
+
+    // [  6] (s =  38) :path: /
+    entry = hpackReader.headerTable.get(5);
+    checkEntry(entry, ":path", "/", 38, false);
+
+    // [  7] (s =  43) :scheme: http
+    entry = hpackReader.headerTable.get(6);
+    checkEntry(entry, ":scheme", "http", 43, false);
+
+    // [  8] (s =  42) :method: GET
+    entry = hpackReader.headerTable.get(7);
+    checkEntry(entry, ":method", "GET", 42, true);
+
+    // Table size: 379
+    assertEquals(379, hpackReader.headerTableSize);
+
+    // Decoded header set:
+    // TODO: order is not correct per docs, but then again, the spec doesn't require ordering.
+    assertEquals(byteStringList(
+        ":method", "GET",
+        ":authority", "www.example.com",
+        ":scheme", "https",
+        ":path", "/index.html",
+        "custom-key", "custom-value"), hpackReader.getAndReset());
+  }
+
+  private ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
+  private final HpackDraft05.Writer hpackWriter = new HpackDraft05.Writer(new DataOutputStream(bytesOut));
+
+  @Test public void readSingleByteInt() throws IOException {
+    assertEquals(10, new HpackDraft05.Reader(byteStream()).readInt(10, 31));
+    assertEquals(10, new HpackDraft05.Reader(byteStream()).readInt(0xe0 | 10, 31));
+  }
+
+  @Test public void readMultibyteInt() throws IOException {
+    assertEquals(1337, new HpackDraft05.Reader(byteStream(154, 10)).readInt(31, 31));
+  }
+
+  @Test public void writeSingleByteInt() throws IOException {
+    hpackWriter.writeInt(10, 31, 0);
+    assertBytes(10);
+    hpackWriter.writeInt(10, 31, 0xe0);
+    assertBytes(0xe0 | 10);
+  }
+
+  @Test public void writeMultibyteInt() throws IOException {
+    hpackWriter.writeInt(1337, 31, 0);
+    assertBytes(31, 154, 10);
+    hpackWriter.writeInt(1337, 31, 0xe0);
+    assertBytes(0xe0 | 31, 154, 10);
+  }
+
+  @Test public void max31BitValue() throws IOException {
+    hpackWriter.writeInt(0x7fffffff, 31, 0);
+    assertBytes(31, 224, 255, 255, 255, 7);
+    assertEquals(0x7fffffff,
+        new HpackDraft05.Reader(byteStream(224, 255, 255, 255, 7)).readInt(31, 31));
+  }
+
+  @Test public void prefixMask() throws IOException {
+    hpackWriter.writeInt(31, 31, 0);
+    assertBytes(31, 0);
+    assertEquals(31, new HpackDraft05.Reader(byteStream(0)).readInt(31, 31));
+  }
+
+  @Test public void prefixMaskMinusOne() throws IOException {
+    hpackWriter.writeInt(30, 31, 0);
+    assertBytes(30);
+    assertEquals(31, new HpackDraft05.Reader(byteStream(0)).readInt(31, 31));
+  }
+
+  @Test public void zero() throws IOException {
+    hpackWriter.writeInt(0, 31, 0);
+    assertBytes(0);
+    assertEquals(0, new HpackDraft05.Reader(byteStream()).readInt(0, 31));
+  }
+
+  @Test public void headerName() throws IOException {
+    hpackWriter.writeByteString(ByteString.encodeUtf8("foo"));
+    assertBytes(3, 'f', 'o', 'o');
+    assertEquals("foo", new HpackDraft05.Reader(byteStream(3, 'f', 'o', 'o')).readString().utf8());
+  }
+
+  @Test public void emptyHeaderName() throws IOException {
+    hpackWriter.writeByteString(ByteString.encodeUtf8(""));
+    assertBytes(0);
+    assertEquals("", new HpackDraft05.Reader(byteStream(0)).readString().utf8());
+  }
+
+  @Test public void headersRoundTrip() throws IOException {
+    List<ByteString> sentHeaders = byteStringList("name", "value");
+    hpackWriter.writeHeaders(sentHeaders);
+    ByteArrayInputStream bytesIn = new ByteArrayInputStream(bytesOut.toByteArray());
+    HpackDraft05.Reader reader = new HpackDraft05.Reader(new DataInputStream(bytesIn));
+    reader.readHeaders(bytesOut.size());
+    reader.emitReferenceSet();
+    List<ByteString> receivedHeaders = reader.getAndReset();
+    assertEquals(sentHeaders, receivedHeaders);
+  }
+
+  private DataInputStream byteStream(int... bytes) {
+    byte[] data = intArrayToByteArray(bytes);
+    return new DataInputStream(new ByteArrayInputStream(data));
+  }
+
+  private ByteArrayOutputStream literalHeaders(List<ByteString> sentHeaders) throws IOException {
+    ByteArrayOutputStream headerBytes = new ByteArrayOutputStream();
+    new HpackDraft05.Writer(new DataOutputStream(headerBytes)).writeHeaders(sentHeaders);
+    return headerBytes;
+  }
+
+  private void checkEntry(HpackDraft05.HeaderEntry entry, String name, String value, int size,
+      boolean referenced) {
+    assertEquals(name, entry.name.utf8());
+    assertEquals(value, entry.value.utf8());
+    assertEquals(size, entry.size);
+    assertEquals(referenced, entry.referenced);
+  }
+
+  private void assertBytes(int... bytes) {
+    byte[] expected = intArrayToByteArray(bytes);
+    byte[] actual = bytesOut.toByteArray();
+    assertEquals(Arrays.toString(expected), Arrays.toString(actual));
+    bytesOut.reset(); // So the next test starts with a clean slate.
+  }
+
+  private byte[] intArrayToByteArray(int[] bytes) {
+    byte[] data = new byte[bytes.length];
+    for (int i = 0; i < bytes.length; i++) {
+      data[i] = (byte) bytes[i];
+    }
+    return data;
+  }
+
+  private static class MutableByteArrayInputStream extends ByteArrayInputStream {
+
+    private MutableByteArrayInputStream() {
+      super(new byte[] { });
+    }
+
+    private void set(byte[] replacement) {
+      this.buf = replacement;
+      this.pos = 0;
+      this.count = replacement.length;
+    }
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackTest.java
deleted file mode 100644
index 0bcadce36e..0000000000
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackTest.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.spdy;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-public class HpackTest {
-  private ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-  private final Hpack.Writer hpackWriter = new Hpack.Writer(new DataOutputStream(bytesOut));
-
-  @Test public void readSingleByteInt() throws IOException {
-    assertEquals(10, new Hpack.Reader(byteStream(), true).readInt(10, 31));
-    assertEquals(10, new Hpack.Reader(byteStream(), true).readInt(0xe0 | 10, 31));
-  }
-
-  @Test public void readMultibyteInt() throws IOException {
-    assertEquals(1337, new Hpack.Reader(byteStream(154, 10), true).readInt(31, 31));
-  }
-
-  @Test public void writeSingleByteInt() throws IOException {
-    hpackWriter.writeInt(10, 31, 0);
-    assertBytes(10);
-    hpackWriter.writeInt(10, 31, 0xe0);
-    assertBytes(0xe0 | 10);
-  }
-
-  @Test public void writeMultibyteInt() throws IOException {
-    hpackWriter.writeInt(1337, 31, 0);
-    assertBytes(31, 154, 10);
-    hpackWriter.writeInt(1337, 31, 0xe0);
-    assertBytes(0xe0 | 31, 154, 10);
-  }
-
-  @Test public void max31BitValue() throws IOException {
-    hpackWriter.writeInt(0x7fffffff, 31, 0);
-    assertBytes(31, 224, 255, 255, 255, 7);
-    assertEquals(0x7fffffff,
-        new Hpack.Reader(byteStream(224, 255, 255, 255, 7), true).readInt(31, 31));
-  }
-
-  @Test public void prefixMask() throws IOException {
-    hpackWriter.writeInt(31, 31, 0);
-    assertBytes(31, 0);
-    assertEquals(31, new Hpack.Reader(byteStream(0), true).readInt(31, 31));
-  }
-
-  @Test public void prefixMaskMinusOne() throws IOException {
-    hpackWriter.writeInt(30, 31, 0);
-    assertBytes(30);
-    assertEquals(31, new Hpack.Reader(byteStream(0), true).readInt(31, 31));
-  }
-
-  @Test public void zero() throws IOException {
-    hpackWriter.writeInt(0, 31, 0);
-    assertBytes(0);
-    assertEquals(0, new Hpack.Reader(byteStream(), true).readInt(0, 31));
-  }
-
-  @Test public void headerName() throws IOException {
-    hpackWriter.writeString("foo");
-    assertBytes(3, 'f', 'o', 'o');
-    assertEquals("foo", new Hpack.Reader(byteStream(3, 'f', 'o', 'o'), true).readString());
-  }
-
-  @Test public void emptyHeaderName() throws IOException {
-    hpackWriter.writeString("");
-    assertBytes(0);
-    assertEquals("", new Hpack.Reader(byteStream(0), true).readString());
-  }
-
-  @Test public void headersRoundTrip() throws IOException {
-    List<String> sentHeaders = Arrays.asList("name", "value");
-    hpackWriter.writeHeaders(sentHeaders);
-    ByteArrayInputStream bytesIn = new ByteArrayInputStream(bytesOut.toByteArray());
-    Hpack.Reader reader = new Hpack.Reader(new DataInputStream(bytesIn), true);
-    reader.readHeaders(bytesOut.size());
-    reader.emitReferenceSet();
-    List<String> receivedHeaders = reader.getAndReset();
-    assertEquals(sentHeaders, receivedHeaders);
-  }
-
-  private DataInputStream byteStream(int... bytes) {
-    byte[] data = intArrayToByteArray(bytes);
-    return new DataInputStream(new ByteArrayInputStream(data));
-  }
-
-  private void assertBytes(int... bytes) {
-    byte[] expected = intArrayToByteArray(bytes);
-    byte[] actual = bytesOut.toByteArray();
-    assertEquals(Arrays.toString(expected), Arrays.toString(actual));
-    bytesOut.reset(); // So the next test starts with a clean slate.
-  }
-
-  private byte[] intArrayToByteArray(int[] bytes) {
-    byte[] data = new byte[bytes.length];
-    for (int i = 0; i < bytes.length; i++) {
-      data[i] = (byte) bytes[i];
-    }
-    return data;
-  }
-}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft06Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft06Test.java
deleted file mode 100644
index c0e0fe65ad..0000000000
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft06Test.java
+++ /dev/null
@@ -1,235 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.spdy;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-public class Http20Draft06Test {
-  static final int expectedStreamId = 15;
-
-  @Test public void onlyOneLiteralHeadersFrame() throws IOException {
-    final List<String> sentHeaders = Arrays.asList("name", "value");
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
-
-    // Write the headers frame, specifying no more frames are expected.
-    {
-      byte[] headerBytes = literalHeaders(sentHeaders);
-      dataOut.writeShort(headerBytes.length);
-      dataOut.write(Http20Draft06.TYPE_HEADERS);
-      dataOut.write(Http20Draft06.FLAG_END_HEADERS | Http20Draft06.FLAG_END_STREAM);
-      dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
-      dataOut.write(headerBytes);
-    }
-
-    FrameReader fr = new Http20Draft06.Reader(new ByteArrayInputStream(out.toByteArray()), false);
-
-    // Consume the headers frame.
-    fr.nextFrame(new BaseTestHandler() {
-
-      @Override
-      public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<String> nameValueBlock,
-          HeadersMode headersMode) {
-        assertFalse(outFinished);
-        assertTrue(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(-1, priority);
-        assertEquals(sentHeaders, nameValueBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
-      }
-    });
-  }
-
-  @Test public void headersFrameThenContinuation() throws IOException {
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
-
-    // Write the first headers frame.
-    {
-      byte[] headerBytes = literalHeaders(Arrays.asList("foo", "bar"));
-      dataOut.writeShort(headerBytes.length);
-      dataOut.write(Http20Draft06.TYPE_HEADERS);
-      dataOut.write(0); // no flags
-      dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
-      dataOut.write(headerBytes);
-    }
-
-    // Write the continuation frame, specifying no more frames are expected.
-    {
-      byte[] headerBytes = literalHeaders(Arrays.asList("baz", "qux"));
-      dataOut.writeShort(headerBytes.length);
-      dataOut.write(Http20Draft06.TYPE_CONTINUATION);
-      dataOut.write(Http20Draft06.FLAG_END_HEADERS | Http20Draft06.FLAG_END_STREAM);
-      dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
-      dataOut.write(headerBytes);
-    }
-
-    FrameReader fr = new Http20Draft06.Reader(new ByteArrayInputStream(out.toByteArray()), false);
-
-    // Reading the above frames should result in a concatenated nameValueBlock.
-    fr.nextFrame(new BaseTestHandler() {
-
-      @Override
-      public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<String> nameValueBlock,
-          HeadersMode headersMode) {
-        assertFalse(outFinished);
-        assertTrue(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(-1, priority);
-        assertEquals(Arrays.asList("foo", "bar", "baz", "qux"), nameValueBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
-      }
-    });
-  }
-
-  /**
-   * HPACK has a max header table size, which can be smaller than the max header message.
-   * Ensure the larger header content is not lost.
-   */
-  @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
-    char[] tooLarge = new char[4096];
-    Arrays.fill(tooLarge, 'a');
-    final List<String> sentHeaders = Arrays.asList("foo", new String(tooLarge));
-
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
-
-    writeOnlyHeadersFrame(literalHeaders(sentHeaders), dataOut);
-
-    FrameReader fr = new Http20Draft06.Reader(new ByteArrayInputStream(out.toByteArray()), false);
-
-    // Consume the large header set.
-    fr.nextFrame(new BaseTestHandler() {
-
-      @Override
-      public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<String> nameValueBlock,
-          HeadersMode headersMode) {
-        assertEquals(sentHeaders, nameValueBlock);
-      }
-    });
-  }
-
-  @Test public void usingDraft06Examples() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
-
-    writeOnlyHeadersFrame(firstHeaderSetBytes(), dataOut);
-    writeOnlyHeadersFrame(secondHeaderSetBytes(), dataOut);
-
-    FrameReader fr = new Http20Draft06.Reader(new ByteArrayInputStream(out.toByteArray()), false);
-
-    // Consume the first header set.
-    fr.nextFrame(new BaseTestHandler() {
-
-      @Override
-      public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<String> nameValueBlock,
-          HeadersMode headersMode) {
-        assertEquals(Arrays.asList(":path", "/my-example/index.html", "user-agent", "my-user-agent",
-            "mynewheader", "first"), nameValueBlock);
-      }
-    });
-
-    // Consume the second header set.
-    fr.nextFrame(new BaseTestHandler() {
-
-      @Override
-      public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<String> nameValueBlock,
-          HeadersMode headersMode) {
-        assertEquals(Arrays.asList(
-            ":path", "/my-example/resources/script.js",
-            "user-agent", "my-user-agent",
-            "mynewheader", "second"
-        ), nameValueBlock);
-      }
-    });
-  }
-
-  // Deviates from draft only to fix doc bugs noted in https://github.com/igrigorik/http-2 specs.
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-03#appendix-C.1
-  static byte[] firstHeaderSetBytes() {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-
-    out.write(0x44); // literal header with incremental indexing, name index = 3
-    out.write(0x16); // header value string length = 22
-    out.write("/my-example/index.html".getBytes(), 0, 22);
-
-    out.write(0x4C); // literal header with incremental indexing, name index = 11
-    out.write(0x0D); // header value string length = 13
-    out.write("my-user-agent".getBytes(), 0, 13);
-
-    out.write(0x40); // literal header with incremental indexing, new name
-    out.write(0x0B); // header name string length = 11
-    out.write("mynewheader".getBytes(), 0, 11);
-    out.write(0x05); // header value string length = 5
-    out.write("first".getBytes(), 0, 5);
-
-    return out.toByteArray();
-  }
-
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-03#appendix-C.2
-  static byte[] secondHeaderSetBytes() {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-
-    out.write(0x9e); // indexed header, index = 30: removal from reference set
-    out.write(0xa0); // indexed header, index = 32: removal from reference set
-    out.write(0x04); // literal header, substitution indexing, name index = 3
-
-    out.write(0x1e); // replaced entry index = 30
-    out.write(0x1f); // header value string length = 31
-    out.write("/my-example/resources/script.js".getBytes(), 0, 31);
-
-    out.write(0x5f);
-    out.write(0x02); // literal header, incremental indexing, name index = 32
-    out.write(0x06); // header value string length = 6
-    out.write("second".getBytes(), 0, 6);
-
-    return out.toByteArray();
-  }
-
-  static void writeOnlyHeadersFrame(byte[] headersSet, DataOutputStream dataOut)
-      throws IOException {
-    dataOut.writeShort(headersSet.length);
-    dataOut.write(Http20Draft06.TYPE_HEADERS);
-    dataOut.write(Http20Draft06.FLAG_END_HEADERS | Http20Draft06.FLAG_END_STREAM);
-    dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream 15 with reserved bit set
-    dataOut.write(headersSet);
-  }
-
-  static byte[] literalHeaders(List<String> sentHeaders) throws IOException {
-    ByteArrayOutputStream headerBytes = new ByteArrayOutputStream();
-    new Hpack.Writer(new DataOutputStream(headerBytes)).writeHeaders(sentHeaders);
-    return headerBytes.toByteArray();
-  }
-}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
new file mode 100644
index 0000000000..4c750712c2
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.ByteString;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.List;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.Util.byteStringList;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class Http20Draft09Test {
+  static final int expectedStreamId = 15;
+
+  @Test public void onlyOneLiteralHeadersFrame() throws IOException {
+    final List<ByteString> sentHeaders = byteStringList("name", "value");
+
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    // Write the headers frame, specifying no more frames are expected.
+    {
+      byte[] headerBytes = literalHeaders(sentHeaders);
+      dataOut.writeShort(headerBytes.length);
+      dataOut.write(Http20Draft09.TYPE_HEADERS);
+      dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_END_STREAM);
+      dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
+      dataOut.write(headerBytes);
+    }
+
+    FrameReader fr = new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()), false);
+
+    // Consume the headers frame.
+    fr.nextFrame(new BaseTestHandler() {
+
+      @Override
+      public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, int priority, List<ByteString> nameValueBlock,
+          HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertTrue(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(-1, priority);
+        assertEquals(sentHeaders, nameValueBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  @Test public void headersFrameThenContinuation() throws IOException {
+
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    // Write the first headers frame.
+    {
+      byte[] headerBytes = literalHeaders(byteStringList("foo", "bar"));
+      dataOut.writeShort(headerBytes.length);
+      dataOut.write(Http20Draft09.TYPE_HEADERS);
+      dataOut.write(0); // no flags
+      dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
+      dataOut.write(headerBytes);
+    }
+
+    // Write the continuation frame, specifying no more frames are expected.
+    {
+      byte[] headerBytes = literalHeaders(byteStringList("baz", "qux"));
+      dataOut.writeShort(headerBytes.length);
+      dataOut.write(Http20Draft09.TYPE_CONTINUATION);
+      dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_END_STREAM);
+      dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
+      dataOut.write(headerBytes);
+    }
+
+    FrameReader fr = new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()), false);
+
+    // Reading the above frames should result in a concatenated nameValueBlock.
+    fr.nextFrame(new BaseTestHandler() {
+
+      @Override
+      public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, int priority, List<ByteString> nameValueBlock,
+          HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(-1, priority);
+        assertEquals(byteStringList("foo", "bar", "baz", "qux"), nameValueBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  @Test public void readRstStreamFrame() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    dataOut.writeShort(4);
+    dataOut.write(Http20Draft09.TYPE_RST_STREAM);
+    dataOut.write(0); // No flags
+    dataOut.writeInt(expectedStreamId & 0x7fffffff); // stream with reserved bit set
+    dataOut.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
+
+    FrameReader fr = new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()), false);
+
+    // Consume the reset frame.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void rstStream(int streamId, ErrorCode errorCode) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(ErrorCode.COMPRESSION_ERROR, errorCode);
+      }
+    });
+  }
+
+  private byte[] literalHeaders(List<ByteString> sentHeaders) throws IOException {
+    ByteArrayOutputStream headerBytes = new ByteArrayOutputStream();
+    new HpackDraft05.Writer(new DataOutputStream(headerBytes)).writeHeaders(sentHeaders);
+    return headerBytes.toByteArray();
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index 99ddc6dc56..5828fe65c9 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
@@ -185,7 +186,7 @@ private OutFrame(int sequence, int start, int truncateToLength) {
     public int priority;
     public ErrorCode errorCode;
     public int deltaWindowSize;
-    public List<String> nameValueBlock;
+    public List<ByteString> nameValueBlock;
     public byte[] data;
     public Settings settings;
     public HeadersMode headersMode;
@@ -203,7 +204,7 @@ public InFrame(int sequence, FrameReader reader) {
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<String> nameValueBlock,
+        int associatedStreamId, int priority, List<ByteString> nameValueBlock,
         HeadersMode headersMode) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_HEADERS;
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
index a906fc7cb9..ead73eba53 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
@@ -36,13 +36,21 @@
   @Test public void setFields() {
     Settings settings = new Settings();
 
+    // WARNING: clash on flags between spdy/3 and http/2!
     assertEquals(-3, settings.getUploadBandwidth(-3));
+    assertEquals(4096, settings.getHeaderTableSize());
     settings.set(Settings.UPLOAD_BANDWIDTH, 0, 42);
     assertEquals(42, settings.getUploadBandwidth(-3));
+    settings.set(Settings.HEADER_TABLE_SIZE, 0, 8096);
+    assertEquals(8096, settings.getHeaderTableSize());
 
+    // WARNING: clash on flags between spdy/3 and http/2!
     assertEquals(-3, settings.getDownloadBandwidth(-3));
+    assertTrue(settings.getEnablePush());
     settings.set(Settings.DOWNLOAD_BANDWIDTH, 0, 53);
     assertEquals(53, settings.getDownloadBandwidth(-3));
+    settings.set(Settings.ENABLE_PUSH, 0, 0);
+    assertFalse(settings.getEnablePush());
 
     assertEquals(-3, settings.getRoundTripTime(-3));
     settings.set(Settings.ROUND_TRIP_TIME, 0, 64);
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index b0f23f44cd..8d263885b7 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -30,6 +30,7 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.UTF_8;
+import static com.squareup.okhttp.internal.Util.byteStringList;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.CANCEL;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.FLOW_CONTROL_ERROR;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.INTERNAL_ERROR;
@@ -66,15 +67,16 @@
   @Test public void clientCreatesStreamAndServerReplies() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
+    peer.sendFrame()
+        .synReply(false, 1, byteStringList("a", "android"));
     peer.sendFrame().data(true, 1, "robot".getBytes("UTF-8"));
     peer.acceptFrame(); // DATA
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
-    assertEquals(Arrays.asList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
+    assertEquals(byteStringList("a", "android"), stream.getResponseHeaders());
     assertStreamData("robot", stream.getInputStream());
     writeAndClose(stream, "c3po");
     assertEquals(0, connection.openStreamCount());
@@ -87,20 +89,20 @@
     assertFalse(synStream.outFinished);
     assertEquals(1, synStream.streamId);
     assertEquals(0, synStream.associatedStreamId);
-    assertEquals(Arrays.asList("b", "banana"), synStream.nameValueBlock);
+    assertEquals(byteStringList("b", "banana"), synStream.nameValueBlock);
     MockSpdyPeer.InFrame requestData = peer.takeFrame();
     assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
   }
 
   @Test public void headersOnlyStreamIsClosedAfterReplyHeaders() throws Exception {
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, byteStringList("b", "banana"));
     peer.play();
 
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), false, false);
+    SpdyStream stream = connection.newStream(byteStringList("a", "android"), false, false);
     assertEquals(1, connection.openStreamCount());
-    assertEquals(Arrays.asList("b", "banana"), stream.getResponseHeaders());
+    assertEquals(byteStringList("b", "banana"), stream.getResponseHeaders());
     assertEquals(0, connection.openStreamCount());
   }
 
@@ -108,13 +110,13 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(true, 1, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(true, 1, byteStringList("a", "android"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    connection.newStream(Arrays.asList("b", "banana"), false, true);
+    connection.newStream(byteStringList("b", "banana"), false, true);
     assertEquals(1, connection.openStreamCount());
     connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
     assertEquals(0, connection.openStreamCount());
@@ -129,7 +131,7 @@
 
   @Test public void serverCreatesStreamAndClientReplies() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 5, 129, Arrays.asList("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, 5, 129, byteStringList("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
     peer.play();
 
@@ -138,10 +140,10 @@
     IncomingStreamHandler handler = new IncomingStreamHandler() {
       @Override public void receive(SpdyStream stream) throws IOException {
         receiveCount.incrementAndGet();
-        assertEquals(Arrays.asList("a", "android"), stream.getRequestHeaders());
+        assertEquals(byteStringList("a", "android"), stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
         assertEquals(5, stream.getPriority());
-        stream.reply(Arrays.asList("b", "banana"), true);
+        stream.reply(byteStringList("b", "banana"), true);
       }
     };
     new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
@@ -152,13 +154,13 @@
     assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
     assertFalse(reply.inFinished);
     assertEquals(2, reply.streamId);
-    assertEquals(Arrays.asList("b", "banana"), reply.nameValueBlock);
+    assertEquals(byteStringList("b", "banana"), reply.nameValueBlock);
     assertEquals(1, receiveCount.get());
   }
 
   @Test public void replyWithNoData() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, Arrays.asList("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, byteStringList("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
     peer.play();
 
@@ -166,7 +168,7 @@
     final AtomicInteger receiveCount = new AtomicInteger();
     IncomingStreamHandler handler = new IncomingStreamHandler() {
       @Override public void receive(SpdyStream stream) throws IOException {
-        stream.reply(Arrays.asList("b", "banana"), false);
+        stream.reply(byteStringList("b", "banana"), false);
         receiveCount.incrementAndGet();
       }
     };
@@ -177,7 +179,7 @@
     assertEquals(TYPE_HEADERS, reply.type);
     assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
     assertTrue(reply.inFinished);
-    assertEquals(Arrays.asList("b", "banana"), reply.nameValueBlock);
+    assertEquals(byteStringList("b", "banana"), reply.nameValueBlock);
     assertEquals(1, receiveCount.get());
   }
 
@@ -327,7 +329,7 @@
 
   @Test public void bogusReplyFrameDoesNotDisruptConnection() throws Exception {
     // write the mocking script
-    peer.sendFrame().synReply(false, 42, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(false, 42, byteStringList("a", "android"));
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
@@ -348,7 +350,7 @@
   @Test public void clientClosesClientOutputStream() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, byteStringList("b", "banana"));
     peer.acceptFrame(); // TYPE_DATA
     peer.acceptFrame(); // TYPE_DATA with FLAG_FIN
     peer.acceptFrame(); // PING
@@ -359,7 +361,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
         .handler(REJECT_INCOMING_STREAMS)
         .build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, false);
+    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, false);
     OutputStream out = stream.getOutputStream();
     out.write("square".getBytes(UTF_8));
     out.flush();
@@ -405,7 +407,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
         .handler(REJECT_INCOMING_STREAMS)
         .build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, true);
+    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, true);
     OutputStream out = stream.getOutputStream();
     connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
     try {
@@ -447,7 +449,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
         .handler(REJECT_INCOMING_STREAMS)
         .build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), false, true);
+    SpdyStream stream = connection.newStream(byteStringList("a", "android"), false, true);
     InputStream in = stream.getInputStream();
     OutputStream out = stream.getOutputStream();
     in.close();
@@ -492,7 +494,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
         .handler(REJECT_INCOMING_STREAMS)
         .build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, true);
+    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, true);
     InputStream in = stream.getInputStream();
     OutputStream out = stream.getOutputStream();
     in.close();
@@ -528,7 +530,7 @@
   @Test public void serverClosesClientInputStream() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, byteStringList("b", "banana"));
     peer.sendFrame().data(true, 1, "square".getBytes(UTF_8));
     peer.play();
 
@@ -536,7 +538,7 @@
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
         .handler(REJECT_INCOMING_STREAMS)
         .build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), false, true);
+    SpdyStream stream = connection.newStream(byteStringList("a", "android"), false, true);
     InputStream in = stream.getInputStream();
     assertStreamData("square", in);
     assertEquals(0, connection.openStreamCount());
@@ -552,17 +554,17 @@
   @Test public void remoteDoubleSynReply() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 1, Arrays.asList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, byteStringList("b", "banana"));
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("c", "cola"), true, true);
-    assertEquals(Arrays.asList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(byteStringList("c", "cola"), true, true);
+    assertEquals(byteStringList("a", "android"), stream.getResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
     try {
       stream.getInputStream().read();
@@ -585,9 +587,9 @@
 
   @Test public void remoteDoubleSynStream() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, Arrays.asList("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, byteStringList("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, Arrays.asList("b", "banana"));
+    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, byteStringList("b", "banana"));
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
@@ -596,9 +598,9 @@
     IncomingStreamHandler handler = new IncomingStreamHandler() {
       @Override public void receive(SpdyStream stream) throws IOException {
         receiveCount.incrementAndGet();
-        assertEquals(Arrays.asList("a", "android"), stream.getRequestHeaders());
+        assertEquals(byteStringList("a", "android"), stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
-        stream.reply(Arrays.asList("c", "cola"), true);
+        stream.reply(byteStringList("c", "cola"), true);
       }
     };
     new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
@@ -617,7 +619,7 @@
   @Test public void remoteSendsDataAfterInFinished() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
     peer.sendFrame().data(true, 1, "robot".getBytes("UTF-8"));
     peer.sendFrame().data(true, 1, "c3po".getBytes("UTF-8")); // Ignored.
     peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
@@ -626,8 +628,8 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
-    assertEquals(Arrays.asList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
+    assertEquals(byteStringList("a", "android"), stream.getResponseHeaders());
     assertStreamData("robot", stream.getInputStream());
 
     // verify the peer received what was expected
@@ -642,7 +644,7 @@
   @Test public void remoteSendsTooMuchData() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, byteStringList("b", "banana"));
     peer.sendFrame().data(false, 1, new byte[64 * 1024 + 1]);
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
@@ -651,8 +653,8 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, true);
-    assertEquals(Arrays.asList("b", "banana"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, true);
+    assertEquals(byteStringList("b", "banana"), stream.getResponseHeaders());
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
@@ -677,7 +679,7 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, true);
+    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, true);
     try {
       stream.getResponseHeaders();
       fail();
@@ -707,8 +709,8 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream1 = connection.newStream(Arrays.asList("a", "android"), true, true);
-    SpdyStream stream2 = connection.newStream(Arrays.asList("b", "banana"), true, true);
+    SpdyStream stream1 = connection.newStream(byteStringList("a", "android"), true, true);
+    SpdyStream stream2 = connection.newStream(byteStringList("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the GO_AWAY has been received.
     stream1.getOutputStream().write("abc".getBytes(UTF_8));
     try {
@@ -720,7 +722,7 @@
     stream1.getOutputStream().write("def".getBytes(UTF_8));
     stream1.getOutputStream().close();
     try {
-      connection.newStream(Arrays.asList("c", "cola"), true, true);
+      connection.newStream(byteStringList("c", "cola"), true, true);
       fail();
     } catch (IOException expected) {
       assertEquals("shutdown", expected.getMessage());
@@ -745,13 +747,13 @@
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // GOAWAY
     peer.acceptFrame(); // PING
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, Arrays.asList("b", "b")); // Should be ignored!
+    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, byteStringList("b", "b")); // Should be ignored!
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    connection.newStream(Arrays.asList("a", "android"), true, true);
+    connection.newStream(byteStringList("a", "android"), true, true);
     Ping ping = connection.ping();
     connection.shutdown(PROTOCOL_ERROR);
     assertEquals(1, connection.openStreamCount());
@@ -798,12 +800,12 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, true);
+    SpdyStream stream = connection.newStream(byteStringList("a", "android"), true, true);
     assertEquals(1, connection.openStreamCount());
     connection.close();
     assertEquals(0, connection.openStreamCount());
     try {
-      connection.newStream(Arrays.asList("b", "banana"), true, true);
+      connection.newStream(byteStringList("b", "banana"), true, true);
       fail();
     } catch (IOException expected) {
       assertEquals("shutdown", expected.getMessage());
@@ -848,14 +850,14 @@
   @Test public void readTimeoutExpires() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
     stream.setReadTimeout(1000);
     InputStream in = stream.getInputStream();
     long startNanos = System.nanoTime();
@@ -878,16 +880,16 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
-    peer.sendFrame().headers(1, Arrays.asList("c", "c3po"));
+    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
+    peer.sendFrame().headers(1, byteStringList("c", "c3po"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
-    assertEquals(Arrays.asList("a", "android", "c", "c3po"), stream.getResponseHeaders());
+    assertEquals(byteStringList("a", "android", "c", "c3po"), stream.getResponseHeaders());
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
@@ -901,14 +903,14 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().headers(1, Arrays.asList("c", "c3po"));
+    peer.sendFrame().headers(1, byteStringList("c", "c3po"));
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
     try {
       stream.getResponseHeaders();
@@ -931,7 +933,7 @@
   @Test public void readSendsWindowUpdate() throws Exception {
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
     for (int i = 0; i < 3; i++) {
       peer.sendFrame().data(false, 1, new byte[WINDOW_UPDATE_THRESHOLD]);
       peer.acceptFrame(); // WINDOW UPDATE
@@ -941,8 +943,8 @@
 
     // Play it back.
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
-    assertEquals(Arrays.asList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
+    assertEquals(byteStringList("a", "android"), stream.getResponseHeaders());
     InputStream in = stream.getInputStream();
     int total = 0;
     byte[] buffer = new byte[1024];
@@ -974,7 +976,7 @@
 
     // Play it back.
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
     OutputStream out = stream.getOutputStream();
     out.write(new byte[Settings.DEFAULT_INITIAL_WINDOW_SIZE]);
     interruptAfterDelay(500);
@@ -995,14 +997,14 @@
   @Test public void testTruncatedDataFrame() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(false, 1, byteStringList("a", "android"));
     peer.sendTruncatedFrame(8 + 100).data(false, 1, new byte[1024]);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
-    assertEquals(Arrays.asList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
+    assertEquals(byteStringList("a", "android"), stream.getResponseHeaders());
     InputStream in = stream.getInputStream();
     try {
       Util.readFully(in, new byte[101]);
@@ -1033,9 +1035,9 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
-    assertEquals("a", stream.getResponseHeaders().get(0));
-    assertEquals(60, stream.getResponseHeaders().get(1).length());
+    SpdyStream stream = connection.newStream(byteStringList("b", "banana"), true, true);
+    assertEquals("a", stream.getResponseHeaders().get(0).utf8());
+    assertEquals(60, stream.getResponseHeaders().get(1).size());
     assertStreamData("robot", stream.getInputStream());
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index a9d41822a9..4331220a46 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -38,9 +38,9 @@
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 
 /**
- * Holds the sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection,
- * which may be used for multiple HTTP request/response exchanges. Connections
- * may be direct to the origin server or via a proxy.
+ * The sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection. May be
+ * used for multiple HTTP request/response exchanges. Connections may be direct
+ * to the origin server or via a proxy.
  *
  * <p>Typically instances of this class are created, connected and exercised
  * automatically by the HTTP client. Applications may use this class to monitor
@@ -53,10 +53,10 @@
  * There are tradeoffs when selecting which options to include when negotiating
  * a secure connection to a remote host. Newer TLS options are quite useful:
  * <ul>
- * <li>Server Name Indication (SNI) enables one IP address to negotiate secure
- * connections for multiple domain names.
- * <li>Next Protocol Negotiation (NPN) enables the HTTPS port (443) to be used
- * for both HTTP and SPDY transports.
+ *   <li>Server Name Indication (SNI) enables one IP address to negotiate secure
+ *       connections for multiple domain names.
+ *   <li>Next Protocol Negotiation (NPN) enables the HTTPS port (443) to be used
+ *       for both HTTP and SPDY transports.
  * </ul>
  * Unfortunately, older HTTPS servers refuse to connect when such options are
  * presented. Rather than avoiding these options entirely, this class allows a
@@ -64,10 +64,25 @@
  * should the attempt fail.
  */
 public final class Connection implements Closeable {
-  private static final byte[] NPN_PROTOCOLS = new byte[] {
+  private static final byte[] ALL_PROTOCOLS = new byte[] {
+      17, 'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '9', '/', '2', '.', '0',
       6, 's', 'p', 'd', 'y', '/', '3',
       8, 'h', 't', 't', 'p', '/', '1', '.', '1'
   };
+
+  private static final byte[] SPDY3_AND_HTTP11 = new byte[] {
+      6, 's', 'p', 'd', 'y', '/', '3',
+      8, 'h', 't', 't', 'p', '/', '1', '.', '1'
+  };
+
+  private static final byte[] HTTP2_AND_HTTP = new byte[] {
+      17, 'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '9', '/', '2', '.', '0',
+      8, 'h', 't', 't', 'p', '/', '1', '.', '1'
+  };
+
+  private static final byte[] HTTP_20_DRAFT_09 = new byte[] {
+      'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '9', '/', '2', '.', '0'
+  };
   private static final byte[] SPDY3 = new byte[] {
       's', 'p', 'd', 'y', '/', '3'
   };
@@ -130,9 +145,20 @@ private void upgradeToTls(TunnelRequest tunnelRequest) throws IOException {
       platform.supportTlsIntolerantServer(sslSocket);
     }
 
-    boolean useNpn = route.modernTls && route.address.transports.contains("spdy/3");
+    boolean useNpn = route.modernTls && (
+        route.address.transports.contains("HTTP-draft-09/2.0")
+     || route.address.transports.contains("spdy/3")
+    );
+
     if (useNpn) {
-      platform.setNpnProtocols(sslSocket, NPN_PROTOCOLS);
+      if (route.address.transports.contains("HTTP-draft-09/2.0")
+       && route.address.transports.contains("spdy/3")) {
+        platform.setNpnProtocols(sslSocket, ALL_PROTOCOLS);
+      } else if (route.address.transports.contains("HTTP-draft-09/2.0")) {
+        platform.setNpnProtocols(sslSocket, HTTP2_AND_HTTP);
+      } else {
+        platform.setNpnProtocols(sslSocket, SPDY3_AND_HTTP11);
+      }
     }
 
     // Force handshake. This can throw!
@@ -150,10 +176,13 @@ private void upgradeToTls(TunnelRequest tunnelRequest) throws IOException {
 
     byte[] selectedProtocol;
     if (useNpn && (selectedProtocol = platform.getNpnSelectedProtocol(sslSocket)) != null) {
-      if (Arrays.equals(selectedProtocol, SPDY3)) {
+      if (Arrays.equals(selectedProtocol, HTTP_20_DRAFT_09)
+       || Arrays.equals(selectedProtocol, SPDY3)) {
+        SpdyConnection.Builder builder =
+            new SpdyConnection.Builder(route.address.getUriHost(), true, in, out);
+        if (Arrays.equals(selectedProtocol, HTTP_20_DRAFT_09)) builder.http20Draft09();
         sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
-        spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, in, out)
-            .build();
+        spdyConnection = builder.build();
         spdyConnection.sendConnectionHeader();
       } else if (!Arrays.equals(selectedProtocol, HTTP_11)) {
         throw new IOException(
@@ -223,9 +252,7 @@ public boolean isReadable() {
   }
 
   public void resetIdleStartTime() {
-    if (spdyConnection != null) {
-      throw new IllegalStateException("spdyConnection != null");
-    }
+    if (spdyConnection != null) throw new IllegalStateException("spdyConnection != null");
     this.idleStartTimeNs = System.nanoTime();
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index 42b70b9806..b9341328d2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -267,8 +267,8 @@ public void evictAll() {
       this.connections.clear();
     }
 
-    for (Connection connection : connections) {
-      Util.closeQuietly(connection);
+    for (int i = 0, size = connections.size(); i < size; i++) {
+      Util.closeQuietly(connections.get(i));
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index c5fa343f55..9868b165bd 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -15,71 +15,148 @@
  */
 package com.squareup.okhttp;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
+import com.squareup.okhttp.internal.Util;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.concurrent.Executor;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
-final class Dispatcher {
-  // TODO: thread pool size should be configurable; possibly configurable per host.
-  private final ThreadPoolExecutor executorService = new ThreadPoolExecutor(
-      8, 8, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
-  private final Map<Object, List<Job>> enqueuedJobs = new LinkedHashMap<Object, List<Job>>();
-
-  public synchronized void enqueue(
-      OkHttpClient client, Request request, Response.Receiver responseReceiver) {
-    Job job = new Job(this, client, request, responseReceiver);
-    List<Job> jobsForTag = enqueuedJobs.get(request.tag());
-    if (jobsForTag == null) {
-      jobsForTag = new ArrayList<Job>(2);
-      enqueuedJobs.put(request.tag(), jobsForTag);
+/**
+ * Policy on when async requests are executed.
+ *
+ * <p>Each dispatcher uses an {@link Executor} to run jobs internally. If you
+ * supply your own executor, it should be able to run {@link #getMaxRequests the
+ * configured maximum} number of jobs concurrently.
+ */
+public final class Dispatcher {
+  private int maxRequests = 64;
+  private int maxRequestsPerHost = 5;
+
+  /** Executes jobs. Created lazily. */
+  private Executor executor;
+
+  /** Ready jobs in the order they'll be run. */
+  private final Deque<Job> readyJobs = new ArrayDeque<Job>();
+
+  /** Running jobs. Includes canceled jobs that haven't finished yet. */
+  private final Deque<Job> runningJobs = new ArrayDeque<Job>();
+
+  public Dispatcher(Executor executor) {
+    this.executor = executor;
+  }
+
+  public Dispatcher() {
+  }
+
+  public synchronized Executor getExecutor() {
+    if (executor == null) {
+      // TODO: name these threads, either here or in the job.
+      executor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
+          new LinkedBlockingQueue<Runnable>());
     }
-    jobsForTag.add(job);
-    executorService.execute(job);
+    return executor;
   }
 
-  public synchronized void cancel(Object tag) {
-    List<Job> jobs = enqueuedJobs.remove(tag);
-    if (jobs == null) return;
-    for (Job job : jobs) {
-      executorService.remove(job);
+  /**
+   * Set the maximum number of requests to execute concurrently. Above this
+   * requests queue in memory, waiting for the running jobs to complete.
+   *
+   * <p>If more than {@code maxRequests} requests are in flight when this is
+   * invoked, those requests will remain in flight.
+   */
+  public synchronized void setMaxRequests(int maxRequests) {
+    if (maxRequests < 1) {
+      throw new IllegalArgumentException("max < 1: " + maxRequests);
     }
+    this.maxRequests = maxRequests;
+    promoteJobs();
   }
 
-  synchronized void finished(Job job) {
-    List<Job> jobs = enqueuedJobs.get(job.tag());
-    if (jobs != null) jobs.remove(job);
+  public synchronized int getMaxRequests() {
+    return maxRequests;
   }
 
-  static class RealResponseBody extends Response.Body {
-    private final Response response;
-    private final InputStream in;
+  /**
+   * Set the maximum number of requests for each host to execute concurrently.
+   * This limits requests by the URL's host name. Note that concurrent requests
+   * to a single IP address may still exceed this limit: multiple hostnames may
+   * share an IP address or be routed through the same HTTP proxy.
+   *
+   * <p>If more than {@code maxRequestsPerHost} requests are in flight when this
+   * is invoked, those requests will remain in flight.
+   */
+  public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
+    if (maxRequestsPerHost < 1) {
+      throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
+    }
+    this.maxRequestsPerHost = maxRequestsPerHost;
+    promoteJobs();
+  }
 
-    RealResponseBody(Response response, InputStream in) {
-      this.response = response;
-      this.in = in;
+  public synchronized int getMaxRequestsPerHost() {
+    return maxRequestsPerHost;
+  }
+
+  synchronized void enqueue(OkHttpClient client, Request request, Response.Receiver receiver) {
+    // Copy the client. Otherwise changes (socket factory, redirect policy,
+    // etc.) may incorrectly be reflected in the request when it is executed.
+    client = client.copyWithDefaults();
+    Job job = new Job(this, client, request, receiver);
+
+    if (runningJobs.size() < maxRequests && runningJobsForHost(job) < maxRequestsPerHost) {
+      runningJobs.add(job);
+      getExecutor().execute(job);
+    } else {
+      readyJobs.add(job);
     }
+  }
 
-    @Override public boolean ready() throws IOException {
-      return true;
+  /**
+   * Cancel all jobs with the tag {@code tag}. If a canceled job is running it
+   * may continue running until it reaches a safe point to finish.
+   */
+  public synchronized void cancel(Object tag) {
+    for (Iterator<Job> i = readyJobs.iterator(); i.hasNext(); ) {
+      if (Util.equal(tag, i.next().tag())) i.remove();
     }
 
-    @Override public MediaType contentType() {
-      String contentType = response.getContentType();
-      return contentType != null ? MediaType.parse(contentType) : null;
+    for (Job job : runningJobs) {
+      if (Util.equal(tag, job.tag())) job.canceled = true;
     }
+  }
 
-    @Override public long contentLength() {
-      return response.getContentLength();
+  /** Used by {@code Job#run} to signal completion. */
+  synchronized void finished(Job job) {
+    if (!runningJobs.remove(job)) throw new AssertionError("Job wasn't running!");
+    promoteJobs();
+  }
+
+  private void promoteJobs() {
+    if (runningJobs.size() >= maxRequests) return; // Already running max capacity.
+    if (readyJobs.isEmpty()) return; // No ready jobs to promote.
+
+    for (Iterator<Job> i = readyJobs.iterator(); i.hasNext(); ) {
+      Job job = i.next();
+
+      if (runningJobsForHost(job) < maxRequestsPerHost) {
+        i.remove();
+        runningJobs.add(job);
+        getExecutor().execute(job);
+      }
+
+      if (runningJobs.size() >= maxRequests) return; // Reached max capacity.
     }
+  }
 
-    @Override public InputStream byteStream() {
-      return in;
+  /** Returns the number of running jobs that share a host with {@code job}. */
+  private int runningJobsForHost(Job job) {
+    int result = 0;
+    for (Job j : runningJobs) {
+      if (j.host().equals(job.host())) result++;
     }
+    return result;
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Headers.java b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
similarity index 60%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/Headers.java
rename to okhttp/src/main/java/com/squareup/okhttp/Headers.java
index d2a2eefccf..7753d9f1f6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Headers.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
@@ -15,27 +15,21 @@
  *  limitations under the License.
  */
 
-package com.squareup.okhttp.internal.http;
+package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
-import java.io.InputStream;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
-import java.util.TreeMap;
 import java.util.TreeSet;
 
 /**
- * The HTTP status and unparsed header fields of a single HTTP message. Values
- * are represented as uninterpreted strings; use {@code Request} and
- * {@code Response} for interpreted headers. This class maintains the
- * order of the header fields within the HTTP message.
+ * The header fields of a single HTTP message. Values are uninterpreted strings;
+ * use {@code Request} and {@code Response} for interpreted headers. This class
+ * maintains the order of the header fields within the HTTP message.
  *
- * <p>This class tracks fields line-by-line. A field with multiple comma-
+ * <p>This class tracks header values line-by-line. A field with multiple comma-
  * separated values on the same line will be treated as a field with a single
  * value by this class. It is the caller's responsibility to detect and split
  * on commas if their field permits multiple values. This simplifies use of
@@ -44,64 +38,52 @@
  *
  * <p>This class trims whitespace from values. It never returns values with
  * leading or trailing whitespace.
+ *
+ * <p>Instances of this class are immutable. Use {@link Builder} to create
+ * instances.
  */
 public final class Headers {
-  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
-    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
-    @Override public int compare(String a, String b) {
-      if (a == b) {
-        return 0;
-      } else if (a == null) {
-        return -1;
-      } else if (b == null) {
-        return 1;
-      } else {
-        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
-      }
-    }
-  };
-
-  private final List<String> namesAndValues;
+  private final String[] namesAndValues;
 
   private Headers(Builder builder) {
-    this.namesAndValues = Util.immutableList(builder.namesAndValues);
+    this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
+  }
+
+  /** Returns the last value corresponding to the specified field, or null. */
+  public String get(String fieldName) {
+    return get(namesAndValues, fieldName);
   }
 
   /** Returns the number of field values. */
   public int size() {
-    return namesAndValues.size() / 2;
+    return namesAndValues.length / 2;
   }
 
   /** Returns the field at {@code position} or null if that is out of range. */
   public String name(int index) {
     int fieldNameIndex = index * 2;
-    if (fieldNameIndex < 0 || fieldNameIndex >= namesAndValues.size()) {
+    if (fieldNameIndex < 0 || fieldNameIndex >= namesAndValues.length) {
       return null;
     }
-    return namesAndValues.get(fieldNameIndex);
-  }
-
-  /** Returns an immutable case-insensitive set of header names. */
-  public Set<String> names() {
-    TreeSet<String> result = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
-    for (int i = 0; i < size(); i++) {
-      result.add(name(i));
-    }
-    return Collections.unmodifiableSet(result);
+    return namesAndValues[fieldNameIndex];
   }
 
   /** Returns the value at {@code index} or null if that is out of range. */
   public String value(int index) {
     int valueIndex = index * 2 + 1;
-    if (valueIndex < 0 || valueIndex >= namesAndValues.size()) {
+    if (valueIndex < 0 || valueIndex >= namesAndValues.length) {
       return null;
     }
-    return namesAndValues.get(valueIndex);
+    return namesAndValues[valueIndex];
   }
 
-  /** Returns the last value corresponding to the specified field, or null. */
-  public String get(String fieldName) {
-    return get(namesAndValues, fieldName);
+  /** Returns an immutable case-insensitive set of header names. */
+  public Set<String> names() {
+    TreeSet<String> result = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
+    for (int i = 0; i < size(); i++) {
+      result.add(name(i));
+    }
+    return Collections.unmodifiableSet(result);
   }
 
   /** Returns an immutable list of the header values for {@code name}. */
@@ -119,53 +101,28 @@ public String get(String fieldName) {
   }
 
   /** @param fieldNames a case-insensitive set of HTTP header field names. */
+  // TODO: it is very weird to request a case-insensitive set as a parameter.
   public Headers getAll(Set<String> fieldNames) {
     Builder result = new Builder();
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      String fieldName = namesAndValues.get(i);
+    for (int i = 0; i < namesAndValues.length; i += 2) {
+      String fieldName = namesAndValues[i];
       if (fieldNames.contains(fieldName)) {
-        result.add(fieldName, namesAndValues.get(i + 1));
+        result.add(fieldName, namesAndValues[i + 1]);
       }
     }
     return result.build();
   }
 
-  /**
-   * Returns an immutable map containing each field to its list of values.
-   *
-   * @param valueForNullKey the request line for requests, or the status line
-   *     for responses. If non-null, this value is mapped to the null key.
-   */
-  public Map<String, List<String>> toMultimap(String valueForNullKey) {
-    Map<String, List<String>> result = new TreeMap<String, List<String>>(FIELD_NAME_COMPARATOR);
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      String fieldName = namesAndValues.get(i);
-      String value = namesAndValues.get(i + 1);
-
-      List<String> allValues = new ArrayList<String>();
-      List<String> otherValues = result.get(fieldName);
-      if (otherValues != null) {
-        allValues.addAll(otherValues);
-      }
-      allValues.add(value);
-      result.put(fieldName, Collections.unmodifiableList(allValues));
-    }
-    if (valueForNullKey != null) {
-      result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));
-    }
-    return Collections.unmodifiableMap(result);
-  }
-
   public Builder newBuilder() {
     Builder result = new Builder();
-    result.namesAndValues.addAll(namesAndValues);
+    result.namesAndValues.addAll(Arrays.asList(namesAndValues));
     return result;
   }
 
-  private static String get(List<String> namesAndValues, String fieldName) {
-    for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
-      if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
-        return namesAndValues.get(i + 1);
+  private static String get(String[] namesAndValues, String fieldName) {
+    for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
+      if (fieldName.equalsIgnoreCase(namesAndValues[i])) {
+        return namesAndValues[i + 1];
       }
     }
     return null;
@@ -174,21 +131,14 @@ private static String get(List<String> namesAndValues, String fieldName) {
   public static class Builder {
     private final List<String> namesAndValues = new ArrayList<String>(20);
 
-    /** Equivalent to {@code build().get(fieldName)}, but potentially faster. */
-    public String get(String fieldName) {
-      return Headers.get(namesAndValues, fieldName);
-    }
-
-    /**
-     * Add an HTTP header line containing a field name, a literal colon, and a
-     * value. This works around empty header names and header names that start
-     * with a colon (created by old broken SPDY versions of the response cache).
-     */
+    /** Add an header line containing a field name, a literal colon, and a value. */
     public Builder addLine(String line) {
       int index = line.indexOf(":", 1);
       if (index != -1) {
         return addLenient(line.substring(0, index), line.substring(index + 1));
       } else if (line.startsWith(":")) {
+        // Work around empty header names and header names that start with a
+        // colon (created by old broken SPDY versions of the response cache).
         return addLenient("", line.substring(1)); // Empty header name.
       } else {
         return addLenient("", line); // No header name.
@@ -235,13 +185,14 @@ public Builder set(String fieldName, String value) {
       return this;
     }
 
-    /** Reads headers or trailers into {@code out}. */
-    public Builder readHeaders(InputStream in) throws IOException {
-      // parse the result headers until the first blank line
-      for (String line; (line = Util.readAsciiLine(in)).length() != 0; ) {
-        addLine(line);
+    /** Equivalent to {@code build().get(fieldName)}, but potentially faster. */
+    public String get(String fieldName) {
+      for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
+        if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
+          return namesAndValues.get(i + 1);
+        }
       }
-      return this;
+      return null;
     }
 
     public Headers build() {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java b/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
index 7873fa444d..db8809ebe0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
@@ -20,7 +20,6 @@
 import com.squareup.okhttp.internal.DiskLruCache;
 import com.squareup.okhttp.internal.StrictLineReader;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.Headers;
 import java.io.BufferedWriter;
 import java.io.ByteArrayInputStream;
 import java.io.File;
@@ -508,8 +507,8 @@ private boolean isHttps() {
     private void writeCertArray(Writer writer, List<Certificate> certificates) throws IOException {
       try {
         writer.write(Integer.toString(certificates.size()) + '\n');
-        for (Certificate certificate : certificates) {
-          byte[] bytes = certificate.getEncoded();
+        for (int i = 0, size = certificates.size(); i < size; i++) {
+          byte[] bytes = certificates.get(i).getEncoded();
           String line = Base64.encode(bytes);
           writer.write(line + '\n');
         }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Job.java b/okhttp/src/main/java/com/squareup/okhttp/Job.java
index 550caf95f0..a9286adfb7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Job.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Job.java
@@ -17,7 +17,10 @@
 
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
+import com.squareup.okhttp.internal.http.OkHeaders;
 import java.io.IOException;
+import java.io.InputStream;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.URL;
@@ -35,9 +38,13 @@
   private final Dispatcher dispatcher;
   private final OkHttpClient client;
   private final Response.Receiver responseReceiver;
+  private int redirectionCount;
+
+  volatile boolean canceled;
 
   /** The request; possibly a consequence of redirects or auth headers. */
   private Request request;
+  private HttpEngine engine;
 
   public Job(Dispatcher dispatcher, OkHttpClient client, Request request,
       Response.Receiver responseReceiver) {
@@ -47,31 +54,49 @@ public Job(Dispatcher dispatcher, OkHttpClient client, Request request,
     this.responseReceiver = responseReceiver;
   }
 
+  String host() {
+    return request.url().getHost();
+  }
+
+  Request request() {
+    return request;
+  }
+
   Object tag() {
     return request.tag();
   }
 
   @Override public void run() {
+    String oldName = Thread.currentThread().getName();
+    Thread.currentThread().setName("OkHttp " + request.urlString());
     try {
       Response response = execute();
-      responseReceiver.onResponse(response);
+      if (response != null && !canceled) {
+        responseReceiver.onResponse(response);
+      }
     } catch (IOException e) {
       responseReceiver.onFailure(new Failure.Builder()
           .request(request)
           .exception(e)
           .build());
     } finally {
-      // TODO: close the response body
-      // TODO: release the HTTP engine (potentially multiple!)
+      engine.release(true); // Release the connection if it isn't already released.
+      Thread.currentThread().setName(oldName);
       dispatcher.finished(this);
     }
   }
 
+  /**
+   * Performs the request and returns the response. May return null if this job
+   * was canceled.
+   */
   private Response execute() throws IOException {
     Connection connection = null;
     Response redirectedBy = null;
 
     while (true) {
+      if (canceled) return null;
+
       Request.Body body = request.body();
       if (body != null) {
         MediaType contentType = body.contentType();
@@ -82,7 +107,7 @@ private Response execute() throws IOException {
 
         long contentLength = body.contentLength();
         if (contentLength != -1) {
-          requestBuilder.setContentLength(contentLength);
+          requestBuilder.header("Content-Length", Long.toString(contentLength));
           requestBuilder.removeHeader("Transfer-Encoding");
         } else {
           requestBuilder.header("Transfer-Encoding", "chunked");
@@ -92,7 +117,7 @@ private Response execute() throws IOException {
         request = requestBuilder.build();
       }
 
-      HttpEngine engine = newEngine(connection);
+      engine = new HttpEngine(client, request, false, connection, null);
       engine.sendRequest();
 
       if (body != null) {
@@ -101,33 +126,28 @@ private Response execute() throws IOException {
 
       engine.readResponse();
 
-      Response engineResponse = engine.getResponse();
-      Response response = engineResponse.newBuilder()
-          .body(new Dispatcher.RealResponseBody(engineResponse, engine.getResponseBody()))
-          .redirectedBy(redirectedBy)
-          .build();
-
+      Response response = engine.getResponse();
       Request redirect = processResponse(engine, response);
 
       if (redirect == null) {
         engine.automaticallyReleaseConnectionToPool();
-        return response;
+        return response.newBuilder()
+            .body(new RealResponseBody(response, engine.getResponseBody()))
+            .redirectedBy(redirectedBy)
+            .build();
       }
 
-      // TODO: fail if too many redirects
-      // TODO: fail if not following redirects
-      // TODO: release engine
+      if (!sameConnection(request, redirect)) {
+        engine.automaticallyReleaseConnectionToPool();
+      }
 
-      connection = sameConnection(request, redirect) ? engine.getConnection() : null;
-      redirectedBy = response;
+      engine.release(false);
+      connection = engine.getConnection();
+      redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.
       request = redirect;
     }
   }
 
-  HttpEngine newEngine(Connection connection) throws IOException {
-    return new HttpEngine(client, request, false, connection, null);
-  }
-
   /**
    * Figures out the HTTP request to make in response to receiving {@code
    * response}. This will either add authentication headers or follow
@@ -156,6 +176,14 @@ private Request processResponse(HttpEngine engine, Response response) throws IOE
       case HTTP_MOVED_TEMP:
       case HTTP_SEE_OTHER:
       case HTTP_TEMP_REDIRECT:
+        if (!client.getFollowProtocolRedirects()) {
+          return null; // This client has is configured to not follow redirects.
+        }
+
+        if (++redirectionCount > HttpURLConnectionImpl.MAX_REDIRECTS) {
+          throw new ProtocolException("Too many redirects: " + redirectionCount);
+        }
+
         String method = request.method();
         if (responseCode == HTTP_TEMP_REDIRECT && !method.equals("GET") && !method.equals("HEAD")) {
           // "If the 307 status code is received in response to a request other than GET or HEAD,
@@ -185,4 +213,31 @@ static boolean sameConnection(Request a, Request b) {
         && getEffectivePort(a.url()) == getEffectivePort(b.url())
         && a.url().getProtocol().equals(b.url().getProtocol());
   }
+
+  static class RealResponseBody extends Response.Body {
+    private final Response response;
+    private final InputStream in;
+
+    RealResponseBody(Response response, InputStream in) {
+      this.response = response;
+      this.in = in;
+    }
+
+    @Override public boolean ready() throws IOException {
+      return true;
+    }
+
+    @Override public MediaType contentType() {
+      String contentType = response.header("Content-Type");
+      return contentType != null ? MediaType.parse(contentType) : null;
+    }
+
+    @Override public long contentLength() {
+      return OkHeaders.contentLength(response);
+    }
+
+    @Override public InputStream byteStream() {
+      return in;
+    }
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index 37f83f7dcd..c388c18c09 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -39,10 +39,10 @@
 /** Configures and creates HTTP connections. */
 public final class OkHttpClient implements URLStreamHandlerFactory, Cloneable {
   private static final List<String> DEFAULT_TRANSPORTS
-      = Util.immutableList(Arrays.asList("spdy/3", "http/1.1"));
+      = Util.immutableList(Arrays.asList("HTTP-draft-09/2.0", "spdy/3", "http/1.1"));
 
   private final RouteDatabase routeDatabase;
-  private final Dispatcher dispatcher;
+  private Dispatcher dispatcher;
   private Proxy proxy;
   private List<String> transports;
   private ProxySelector proxySelector;
@@ -281,6 +281,20 @@ public RouteDatabase getRoutesDatabase() {
     return routeDatabase;
   }
 
+  /**
+   * Sets the dispatcher used to set policy and execute asynchronous requests.
+   * Must not be null.
+   */
+  public OkHttpClient setDispatcher(Dispatcher dispatcher) {
+    if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
+    this.dispatcher = dispatcher;
+    return this;
+  }
+
+  public Dispatcher getDispatcher() {
+    return dispatcher;
+  }
+
   /**
    * Configure the transports used by this client to communicate with remote
    * servers. By default this client will prefer the most efficient transport
@@ -334,9 +348,7 @@ public OkHttpClient setTransports(List<String> transports) {
    * This method is in beta. APIs are subject to change!
    */
   public void enqueue(Request request, Response.Receiver responseReceiver) {
-    // Copy this client. Otherwise changes (socket factory, redirect policy,
-    // etc.) may incorrectly be reflected in the request when it is dispatched.
-    dispatcher.enqueue(copyWithDefaults(), request, responseReceiver);
+    dispatcher.enqueue(this, request, responseReceiver);
   }
 
   /**
@@ -368,7 +380,7 @@ HttpURLConnection open(URL url, Proxy proxy) {
    * Returns a shallow copy of this OkHttpClient that uses the system-wide
    * default for each field that hasn't been explicitly configured.
    */
-  private OkHttpClient copyWithDefaults() {
+  OkHttpClient copyWithDefaults() {
     OkHttpClient result = clone();
     if (result.proxySelector == null) {
       result.proxySelector = ProxySelector.getDefault();
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index 79f1ca8215..5866af0f21 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -18,7 +18,6 @@
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HeaderParser;
-import com.squareup.okhttp.internal.http.Headers;
 import com.squareup.okhttp.internal.http.HttpDate;
 import java.io.File;
 import java.io.FileInputStream;
@@ -32,8 +31,6 @@
 import java.net.URL;
 import java.util.Date;
 import java.util.List;
-import java.util.Map;
-import java.util.Set;
 
 /**
  * An HTTP request. Instances of this class are immutable if their {@link #body}
@@ -81,6 +78,10 @@ public String method() {
     return method;
   }
 
+  public Headers headers() {
+    return headers;
+  }
+
   public String header(String name) {
     return headers.get(name);
   }
@@ -89,26 +90,6 @@ public String header(String name) {
     return headers.values(name);
   }
 
-  public Set<String> headerNames() {
-    return headers.names();
-  }
-
-  Headers headers() {
-    return headers;
-  }
-
-  public int headerCount() {
-    return headers.size();
-  }
-
-  public String headerName(int index) {
-    return headers.name(index);
-  }
-
-  public String headerValue(int index) {
-    return headers.value(index);
-  }
-
   public Body body() {
     return body;
   }
@@ -145,20 +126,10 @@ public boolean getOnlyIfCached() {
     return parsedHeaders().onlyIfCached;
   }
 
-  // TODO: Make non-public. This conflicts with the Body's content length!
-  public long getContentLength() {
-    return parsedHeaders().contentLength;
-  }
-
   public String getUserAgent() {
     return parsedHeaders().userAgent;
   }
 
-  // TODO: Make non-public. This conflicts with the Body's content type!
-  public String getContentType() {
-    return parsedHeaders().contentType;
-  }
-
   public String getProxyAuthorization() {
     return parsedHeaders().proxyAuthorization;
   }
@@ -189,9 +160,7 @@ public boolean isHttps() {
      */
     private boolean onlyIfCached;
 
-    private long contentLength = -1;
     private String userAgent;
-    private String contentType;
     private String proxyAuthorization;
 
     public ParsedHeaders(Headers headers) {
@@ -220,15 +189,8 @@ public ParsedHeaders(Headers headers) {
           if ("no-cache".equalsIgnoreCase(value)) {
             noCache = true;
           }
-        } else if ("Content-Length".equalsIgnoreCase(fieldName)) {
-          try {
-            contentLength = Long.parseLong(value);
-          } catch (NumberFormatException ignored) {
-          }
         } else if ("User-Agent".equalsIgnoreCase(fieldName)) {
           userAgent = value;
-        } else if ("Content-Type".equalsIgnoreCase(fieldName)) {
-          contentType = value;
         } else if ("Proxy-Authorization".equalsIgnoreCase(fieldName)) {
           proxyAuthorization = value;
         }
@@ -323,7 +285,7 @@ public static Body create(final MediaType contentType, final File file) {
   public static class Builder {
     private URL url;
     private String method;
-    private final Headers.Builder headers;
+    private Headers.Builder headers;
     private Body body;
     private Object tag;
 
@@ -377,51 +339,22 @@ public Builder removeHeader(String name) {
       return this;
     }
 
-    // TODO: conflict's with the body's content type.
-    public Builder setContentLength(long contentLength) {
-      headers.set("Content-Length", Long.toString(contentLength));
+    /** Removes all headers on this builder and adds {@code headers}. */
+    public Builder headers(Headers headers) {
+      this.headers = headers.newBuilder();
       return this;
     }
 
-    public void setUserAgent(String userAgent) {
-      headers.set("User-Agent", userAgent);
-    }
-
-    // TODO: conflict's with the body's content type.
-    public void setContentType(String contentType) {
-      headers.set("Content-Type", contentType);
-    }
-
-    public void setIfModifiedSince(Date date) {
-      headers.set("If-Modified-Since", HttpDate.format(date));
+    public Builder setUserAgent(String userAgent) {
+      return header("User-Agent", userAgent);
     }
 
-    public void setIfNoneMatch(String ifNoneMatch) {
-      headers.set("If-None-Match", ifNoneMatch);
+    public Builder setIfModifiedSince(Date date) {
+      return header("If-Modified-Since", HttpDate.format(date));
     }
 
-    public void addCookies(Map<String, List<String>> cookieHeaders) {
-      for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
-        String key = entry.getKey();
-        if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
-            && !entry.getValue().isEmpty()) {
-          headers.add(key, buildCookieHeader(entry.getValue()));
-        }
-      }
-    }
-
-    /**
-     * Send all cookies in one big header, as recommended by
-     * <a href="http://tools.ietf.org/html/rfc6265#section-4.2.1">RFC 6265</a>.
-     */
-    private String buildCookieHeader(List<String> cookies) {
-      if (cookies.size() == 1) return cookies.get(0);
-      StringBuilder sb = new StringBuilder();
-      for (int i = 0; i < cookies.size(); i++) {
-        if (i > 0) sb.append("; ");
-        sb.append(cookies.get(i));
-      }
-      return sb.toString();
+    public Builder setIfNoneMatch(String ifNoneMatch) {
+      return header("If-None-Match", ifNoneMatch);
     }
 
     public Builder get() {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index bdbc8a9974..8026a78f66 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -17,10 +17,9 @@
 
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HeaderParser;
-import com.squareup.okhttp.internal.http.Headers;
 import com.squareup.okhttp.internal.http.HttpDate;
+import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.StatusLine;
-import com.squareup.okhttp.internal.http.SyntheticHeaders;
 import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
 import java.io.IOException;
@@ -105,6 +104,10 @@ public Handshake handshake() {
     return handshake;
   }
 
+  public List<String> headers(String name) {
+    return headers.values(name);
+  }
+
   public String header(String name) {
     return header(name, null);
   }
@@ -114,31 +117,10 @@ public String header(String name, String defaultValue) {
     return result != null ? result : defaultValue;
   }
 
-  public List<String> headers(String name) {
-    return headers.values(name);
-  }
-
-  public Set<String> headerNames() {
-    return headers.names();
-  }
-
-  public int headerCount() {
-    return headers.size();
-  }
-
-  public String headerName(int index) {
-    return headers.name(index);
-  }
-
-  // TODO: this shouldn't be public?
   public Headers headers() {
     return headers;
   }
 
-  public String headerValue(int index) {
-    return headers.value(index);
-  }
-
   public Body body() {
     return body;
   }
@@ -201,16 +183,6 @@ public String getEtag() {
     return parsedHeaders().varyFields;
   }
 
-  // TODO: this shouldn't be public.
-  public long getContentLength() {
-    return parsedHeaders().contentLength;
-  }
-
-  // TODO: this shouldn't be public.
-  public String getContentType() {
-    return parsedHeaders().contentType;
-  }
-
   /**
    * Returns true if a Vary header contains an asterisk. Such responses cannot
    * be cached.
@@ -471,9 +443,9 @@ private ParsedHeaders(Headers headers) {
           }
         } else if ("Content-Type".equalsIgnoreCase(fieldName)) {
           contentType = value;
-        } else if (SyntheticHeaders.SENT_MILLIS.equalsIgnoreCase(fieldName)) {
+        } else if (OkHeaders.SENT_MILLIS.equalsIgnoreCase(fieldName)) {
           sentRequestMillis = Long.parseLong(value);
-        } else if (SyntheticHeaders.RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
+        } else if (OkHeaders.RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
           receivedResponseMillis = Long.parseLong(value);
         }
       }
@@ -589,7 +561,7 @@ public Builder removeHeader(String name) {
       return this;
     }
 
-    // TODO: this shouldn't be public?
+    /** Removes all headers on this builder and adds {@code headers}. */
     public Builder headers(Headers headers) {
       this.headers = headers.newBuilder();
       return this;
@@ -602,8 +574,7 @@ public Builder body(Body body) {
 
     // TODO: this shouldn't be public.
     public Builder setResponseSource(ResponseSource responseSource) {
-      headers.set(SyntheticHeaders.RESPONSE_SOURCE, responseSource + " " + statusLine.code());
-      return this;
+      return header(OkHeaders.RESPONSE_SOURCE, responseSource + " " + statusLine.code());
     }
 
     public Builder redirectedBy(Response redirectedBy) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Route.java b/okhttp/src/main/java/com/squareup/okhttp/Route.java
index 4b8786d229..08963ad864 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Route.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Route.java
@@ -18,7 +18,21 @@
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 
-/** Represents the route used by a connection to reach an endpoint. */
+/**
+ * The concrete route used by a connection to reach an abstract origin server.
+ * When creating a connection the client has many options:
+ * <ul>
+ *   <li><strong>HTTP proxy:</strong> a proxy server may be explicitly
+ *       configured for the client. Otherwise the {@link java.net.ProxySelector
+ *       proxy selector} is used. It may return multiple proxies to attempt.
+ *   <li><strong>IP address:</strong> whether connecting directly to an origin
+ *       server or a proxy, opening a socket requires an IP address. The DNS
+ *       server may return multiple IP addresses to attempt.
+ *   <li><strong>Modern TLS:</strong> whether to include advanced TLS options
+ *       when attempting a HTTPS connection.
+ * </ul>
+ * Each route is a specific selection of these options.
+ */
 public class Route {
   final Address address;
   final Proxy proxy;
@@ -44,11 +58,8 @@ public Address getAddress() {
   /**
    * Returns the {@link Proxy} of this route.
    *
-   * <strong>Warning:</strong> This may be different than the proxy returned
-   * by {@link #getAddress}! That is the proxy that the user asked to be
-   * connected to; this returns the proxy that they were actually connected
-   * to. The two may disagree when a proxy selector selects a different proxy
-   * for a connection.
+   * <strong>Warning:</strong> This may disagree with {@link Address#getProxy}
+   * is null. When the address's proxy is null, the proxy selector will be used.
    */
   public Proxy getProxy() {
     return proxy;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index f7fcb1ed2a..69f3c31563 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -30,7 +30,6 @@
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
-import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -562,7 +561,7 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
    */
   private boolean journalRebuildRequired() {
     final int redundantOpCompactThreshold = 2000;
-    return redundantOpCount >= redundantOpCompactThreshold //
+    return redundantOpCount >= redundantOpCompactThreshold
         && redundantOpCount >= lruEntries.size();
   }
 
@@ -623,7 +622,9 @@ public synchronized void close() throws IOException {
     if (journalWriter == null) {
       return; // Already closed.
     }
-    for (Entry entry : new ArrayList<Entry>(lruEntries.values())) {
+    // Copying for safe iteration.
+    for (Object next : lruEntries.values().toArray()) {
+      Entry entry = (Entry) next;
       if (entry.currentEditor != null) {
         entry.currentEditor.abort();
       }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java
index 14fe3c8ff1..ce40a92c27 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java
@@ -16,6 +16,7 @@
  */
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkAuthenticator;
 import com.squareup.okhttp.OkAuthenticator.Challenge;
 import com.squareup.okhttp.Request;
@@ -40,7 +41,8 @@
   public static final OkAuthenticator SYSTEM_DEFAULT = new OkAuthenticator() {
     @Override public Credential authenticate(
         Proxy proxy, URL url, List<Challenge> challenges) throws IOException {
-      for (Challenge challenge : challenges) {
+      for (int i = 0, size = challenges.size(); i < size; i++) {
+        Challenge challenge = challenges.get(i);
         if (!"Basic".equalsIgnoreCase(challenge.getScheme())) {
           continue;
         }
@@ -57,7 +59,8 @@
 
     @Override public Credential authenticateProxy(
         Proxy proxy, URL url, List<Challenge> challenges) throws IOException {
-      for (Challenge challenge : challenges) {
+      for (int i = 0, size = challenges.size(); i < size; i++) {
+        Challenge challenge = challenges.get(i);
         if (!"Basic".equalsIgnoreCase(challenge.getScheme())) {
           continue;
         }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index da14c39d7e..96a401984a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -19,7 +19,7 @@
 
 import com.squareup.okhttp.Address;
 import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.OkResponseCache;
 import com.squareup.okhttp.Request;
@@ -35,6 +35,8 @@
 import java.net.CookieHandler;
 import java.net.URL;
 import java.net.UnknownHostException;
+import java.util.List;
+import java.util.Map;
 import java.util.zip.GZIPInputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
@@ -206,10 +208,7 @@ public final void sendRequest() throws IOException {
   private Response cacheableResponse() {
     // Use an unreadable response body when offering the response to the cache.
     // The cache isn't allowed to consume the response body bytes!
-    return response.newBuilder()
-        .body(new UnreadableResponseBody(response.getContentType(),
-            response.getContentLength()))
-        .build();
+    return response.newBuilder().body(null).build();
   }
 
   /** Connect to the origin server either directly or via a proxy. */
@@ -239,8 +238,8 @@ private void connect() throws IOException {
       connection.connect(client.getConnectTimeout(), client.getReadTimeout(), getTunnelConfig());
       client.getConnectionPool().maybeShare(connection);
       client.getRoutesDatabase().connected(connection.getRoute());
-    } else {
-      connection.updateReadTimeout(client.getReadTimeout());
+    } else if (!connection.isSpdy()) {
+        connection.updateReadTimeout(client.getReadTimeout());
     }
 
     route = connection.getRoute();
@@ -400,7 +399,7 @@ public final boolean hasResponseBody() {
     // If the Content-Length or Transfer-Encoding headers disagree with the
     // response code, the response is malformed. For best compatibility, we
     // honor the headers.
-    if (response.getContentLength() != -1
+    if (OkHeaders.contentLength(response) != -1
         || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
       return true;
     }
@@ -435,13 +434,15 @@ private void prepareRawRequestHeaders() throws IOException {
       result.header("Accept-Encoding", "gzip");
     }
 
-    if (hasRequestBody() && request.getContentType() == null) {
-      result.setContentType("application/x-www-form-urlencoded");
+    if (hasRequestBody() && request.header("Content-Type") == null) {
+      result.header("Content-Type", "application/x-www-form-urlencoded");
     }
 
     CookieHandler cookieHandler = client.getCookieHandler();
     if (cookieHandler != null) {
-      result.addCookies(cookieHandler.get(request.uri(), request.getHeaders().toMultimap(null)));
+      Map<String, List<String>> cookies = cookieHandler.get(
+          request.uri(), OkHeaders.toMultimap(request.getHeaders(), null));
+      OkHeaders.addCookies(result, cookies);
     }
 
     request = result.build();
@@ -468,11 +469,13 @@ public final void readResponse() throws IOException {
     if (!responseSource.requiresConnection()) return;
 
     if (sentRequestMillis == -1) {
-      if (request.getContentLength() == -1
+      if (OkHeaders.contentLength(request) == -1
           && requestBodyOut instanceof RetryableOutputStream) {
         // We might not learn the Content-Length until the request body has been buffered.
-        int contentLength = ((RetryableOutputStream) requestBodyOut).contentLength();
-        request = request.newBuilder().setContentLength(contentLength).build();
+        long contentLength = ((RetryableOutputStream) requestBodyOut).contentLength();
+        request = request.newBuilder()
+            .header("Content-Length", Long.toString(contentLength))
+            .build();
       }
       transport.writeRequestHeaders(request);
     }
@@ -489,8 +492,8 @@ public final void readResponse() throws IOException {
     response = transport.readResponseHeaders()
         .request(request)
         .handshake(connection.getHandshake())
-        .header(SyntheticHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
-        .header(SyntheticHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
+        .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
+        .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
         .setResponseSource(responseSource)
         .build();
     connection.setHttpMinorVersion(response.httpMinorVersion());
@@ -530,9 +533,10 @@ public final void readResponse() throws IOException {
   private static Response combine(Response cached, Response network) throws IOException {
     Headers.Builder result = new Headers.Builder();
 
-    for (int i = 0; i < cached.headerCount(); i++) {
-      String fieldName = cached.headerName(i);
-      String value = cached.headerValue(i);
+    Headers cachedHeaders = cached.headers();
+    for (int i = 0; i < cachedHeaders.size(); i++) {
+      String fieldName = cachedHeaders.name(i);
+      String value = cachedHeaders.value(i);
       if ("Warning".equals(fieldName) && value.startsWith("1")) {
         continue; // drop 100-level freshness warnings
       }
@@ -541,10 +545,11 @@ private static Response combine(Response cached, Response network) throws IOExce
       }
     }
 
-    for (int i = 0; i < network.headerCount(); i++) {
-      String fieldName = network.headerName(i);
+    Headers networkHeaders = network.headers();
+    for (int i = 0; i < networkHeaders.size(); i++) {
+      String fieldName = networkHeaders.name(i);
       if (isEndToEnd(fieldName)) {
-        result.add(fieldName, network.headerValue(i));
+        result.add(fieldName, networkHeaders.value(i));
       }
     }
 
@@ -580,33 +585,7 @@ private TunnelRequest getTunnelConfig() {
   public void receiveHeaders(Headers headers) throws IOException {
     CookieHandler cookieHandler = client.getCookieHandler();
     if (cookieHandler != null) {
-      cookieHandler.put(request.uri(), headers.toMultimap(null));
-    }
-  }
-
-  static class UnreadableResponseBody extends Response.Body {
-    private final String contentType;
-    private final long contentLength;
-
-    public UnreadableResponseBody(String contentType, long contentLength) {
-      this.contentType = contentType;
-      this.contentLength = contentLength;
-    }
-
-    @Override public boolean ready() throws IOException {
-      throw new IllegalStateException("It is an error to read this response body at this time.");
-    }
-
-    @Override public MediaType contentType() {
-      return contentType != null ? MediaType.parse(contentType) : null;
-    }
-
-    @Override public long contentLength() {
-      return contentLength;
-    }
-
-    @Override public InputStream byteStream() {
-      throw new IllegalStateException("It is an error to read this response body at this time.");
+      cookieHandler.put(request.uri(), OkHeaders.toMultimap(headers, null));
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
index ab9261f323..4a166dcc38 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
@@ -17,6 +17,7 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.AbstractOutputStream;
@@ -62,7 +63,7 @@ public HttpTransport(HttpEngine httpEngine, OutputStream outputStream, InputStre
   }
 
   @Override public OutputStream createRequestBody(Request request) throws IOException {
-    long contentLength = request.getContentLength();
+    long contentLength = OkHeaders.contentLength(request);
 
     if (httpEngine.bufferRequestBody) {
       if (contentLength > Integer.MAX_VALUE) {
@@ -154,10 +155,10 @@ public static void writeRequest(OutputStream out, Headers headers, String reques
 
       Response.Builder responseBuilder = new Response.Builder()
           .statusLine(statusLine)
-          .header(SyntheticHeaders.SELECTED_TRANSPORT, "http/1.1");
+          .header(OkHeaders.SELECTED_TRANSPORT, "http/1.1");
 
       Headers.Builder headersBuilder = new Headers.Builder();
-      headersBuilder.readHeaders(in);
+      OkHeaders.readHeaders(headersBuilder, in);
       responseBuilder.headers(headersBuilder.build());
 
       if (statusLine.code() != HTTP_CONTINUE) return responseBuilder;
@@ -234,9 +235,9 @@ private static boolean discardStream(HttpEngine httpEngine, InputStream response
       return new ChunkedInputStream(socketIn, cacheRequest, this);
     }
 
-    if (httpEngine.getResponse().getContentLength() != -1) {
-      return new FixedLengthInputStream(socketIn, cacheRequest, httpEngine,
-          httpEngine.getResponse().getContentLength());
+    long contentLength = OkHeaders.contentLength(httpEngine.getResponse());
+    if (contentLength != -1) {
+      return new FixedLengthInputStream(socketIn, cacheRequest, httpEngine, contentLength);
     }
 
     // Wrap the input stream from the connection (rather than just returning
@@ -443,14 +444,12 @@ public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEng
   /** An HTTP body with alternating chunk sizes and chunk bodies. */
   private static class ChunkedInputStream extends AbstractHttpInputStream {
     private static final int NO_CHUNK_YET = -1;
-    private final HttpTransport transport;
     private int bytesRemainingInChunk = NO_CHUNK_YET;
     private boolean hasMoreChunks = true;
 
     ChunkedInputStream(InputStream is, CacheRequest cacheRequest, HttpTransport transport)
         throws IOException {
       super(is, transport.httpEngine, cacheRequest);
-      this.transport = transport;
     }
 
     @Override public int read(byte[] buffer, int offset, int count) throws IOException {
@@ -493,10 +492,9 @@ private void readChunkSize() throws IOException {
       }
       if (bytesRemainingInChunk == 0) {
         hasMoreChunks = false;
-        Headers trailers = new Headers.Builder()
-            .readHeaders(transport.socketIn)
-            .build();
-        httpEngine.receiveHeaders(trailers);
+        Headers.Builder trailersBuilder = new Headers.Builder();
+        OkHeaders.readHeaders(trailersBuilder, in);
+        httpEngine.receiveHeaders(trailersBuilder.build());
         endOfInput();
       }
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
index 1517ebaa73..c54de7a00a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
@@ -18,6 +18,7 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
@@ -66,7 +67,7 @@
    * How many redirects should we follow? Chrome follows 21; Firefox, curl,
    * and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
    */
-  private static final int MAX_REDIRECTS = 20;
+  public static final int MAX_REDIRECTS = 20;
 
   final OkHttpClient client;
 
@@ -165,7 +166,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
   @Override public final Map<String, List<String>> getHeaderFields() {
     try {
       Response response = getResponse().getResponse();
-      return response.headers().toMultimap(response.statusLine());
+      return OkHeaders.toMultimap(response.headers(), response.statusLine());
     } catch (IOException e) {
       return Collections.emptyMap();
     }
@@ -180,7 +181,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
     // For the request line property assigned to the null key, just use no proxy and HTTP 1.1.
     Request request = new Request.Builder().url(getURL()).method(method, null).build();
     String requestLine = RequestLine.get(request, null, 1);
-    return requestHeaders.build().toMultimap(requestLine);
+    return OkHeaders.toMultimap(requestHeaders.build(), requestLine);
   }
 
   @Override public final InputStream getInputStream() throws IOException {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
new file mode 100644
index 0000000000..09193537cb
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
@@ -0,0 +1,134 @@
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+
+/** Headers and utilities for internal use by OkHttp. */
+public final class OkHeaders {
+  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
+    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
+    @Override public int compare(String a, String b) {
+      if (a == b) {
+        return 0;
+      } else if (a == null) {
+        return -1;
+      } else if (b == null) {
+        return 1;
+      } else {
+        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
+      }
+    }
+  };
+
+  static final String PREFIX = Platform.get().getPrefix();
+
+  /**
+   * Synthetic response header: the local time when the request was sent.
+   */
+  public static final String SENT_MILLIS = PREFIX + "-Sent-Millis";
+
+  /**
+   * Synthetic response header: the local time when the response was received.
+   */
+  public static final String RECEIVED_MILLIS = PREFIX + "-Received-Millis";
+
+  /**
+   * Synthetic response header: the response source and status code like
+   * "CONDITIONAL_CACHE 304".
+   */
+  public static final String RESPONSE_SOURCE = PREFIX + "-Response-Source";
+
+  /**
+   * Synthetic response header: the selected transport ("spdy/3", "http/1.1", etc).
+   */
+  public static final String SELECTED_TRANSPORT = PREFIX + "-Selected-Transport";
+
+  private OkHeaders() {
+  }
+
+  public static long contentLength(Request request) {
+    return stringToLong(request.header("Content-Length"));
+  }
+
+  public static long contentLength(Response response) {
+    return stringToLong(response.header("Content-Length"));
+  }
+
+  private static long stringToLong(String s) {
+    if (s == null) return -1;
+    try {
+      return Long.parseLong(s);
+    } catch (NumberFormatException e) {
+      return -1;
+    }
+  }
+
+  /**
+   * Returns an immutable map containing each field to its list of values.
+   *
+   * @param valueForNullKey the request line for requests, or the status line
+   *     for responses. If non-null, this value is mapped to the null key.
+   */
+  public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
+    Map<String, List<String>> result = new TreeMap<String, List<String>>(FIELD_NAME_COMPARATOR);
+    for (int i = 0; i < headers.size(); i++) {
+      String fieldName = headers.name(i);
+      String value = headers.value(i);
+
+      List<String> allValues = new ArrayList<String>();
+      List<String> otherValues = result.get(fieldName);
+      if (otherValues != null) {
+        allValues.addAll(otherValues);
+      }
+      allValues.add(value);
+      result.put(fieldName, Collections.unmodifiableList(allValues));
+    }
+    if (valueForNullKey != null) {
+      result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));
+    }
+    return Collections.unmodifiableMap(result);
+  }
+
+  public static void addCookies(Request.Builder builder, Map<String, List<String>> cookieHeaders) {
+    for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
+      String key = entry.getKey();
+      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
+          && !entry.getValue().isEmpty()) {
+        builder.addHeader(key, buildCookieHeader(entry.getValue()));
+      }
+    }
+  }
+
+  /**
+   * Send all cookies in one big header, as recommended by
+   * <a href="http://tools.ietf.org/html/rfc6265#section-4.2.1">RFC 6265</a>.
+   */
+  private static String buildCookieHeader(List<String> cookies) {
+    if (cookies.size() == 1) return cookies.get(0);
+    StringBuilder sb = new StringBuilder();
+    for (int i = 0; i < cookies.size(); i++) {
+      if (i > 0) sb.append("; ");
+      sb.append(cookies.get(i));
+    }
+    return sb.toString();
+  }
+
+  /** Reads headers or trailers into {@code builder}. */
+  public static void readHeaders(Headers.Builder builder, InputStream in) throws IOException {
+    // parse the result headers until the first blank line
+    for (String line; (line = Util.readAsciiLine(in)).length() != 0; ) {
+      builder.addLine(line);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 2665125586..6004f238d0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -16,8 +16,10 @@
 
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.spdy.ErrorCode;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
@@ -33,6 +35,14 @@
 import java.util.Set;
 
 public final class SpdyTransport implements Transport {
+  private static final ByteString HEADER_METHOD = ByteString.encodeUtf8(":method");
+  private static final ByteString HEADER_PATH = ByteString.encodeUtf8(":path");
+  private static final ByteString HEADER_VERSION = ByteString.encodeUtf8(":version");
+  private static final ByteString HEADER_HOST = ByteString.encodeUtf8(":host");
+  private static final ByteString HEADER_AUTHORITY = ByteString.encodeUtf8(":authority");
+  private static final ByteString HEADER_SCHEME = ByteString.encodeUtf8(":scheme");
+  private static final ByteString NULL = ByteString.of((byte) 0x00);
+
   private final HttpEngine httpEngine;
   private final SpdyConnection spdyConnection;
   private SpdyStream stream;
@@ -56,7 +66,8 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     boolean hasResponseBody = true;
     String version = RequestLine.version(httpEngine.connection.getHttpMinorVersion());
     stream = spdyConnection.newStream(
-        writeNameValueBlock(request, version), hasRequestBody, hasResponseBody);
+        writeNameValueBlock(request, spdyConnection.getProtocol(), version), hasRequestBody,
+        hasResponseBody);
     stream.setReadTimeout(httpEngine.client.getReadTimeout());
   }
 
@@ -69,7 +80,7 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
   }
 
   @Override public Response.Builder readResponseHeaders() throws IOException {
-    return readNameValueBlock(stream.getResponseHeaders());
+    return readNameValueBlock(stream.getResponseHeaders(), spdyConnection.getProtocol());
   }
 
   /**
@@ -77,53 +88,58 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
    * Names are all lower case. No names are repeated. If any name has multiple
    * values, they are concatenated using "\0" as a delimiter.
    */
-  public static List<String> writeNameValueBlock(Request request, String version) {
-    List<String> result = new ArrayList<String>(request.headerCount() + 10);
-    result.add(":method");
-    result.add(request.method());
-    result.add(":path");
-    result.add(RequestLine.requestPath(request.url()));
-    result.add(":version");
-    result.add(version);
-    result.add(":host");
-    result.add(HttpEngine.hostHeader(request.url()));
-    result.add(":scheme");
-    result.add(request.url().getProtocol());
-
-    Set<String> names = new LinkedHashSet<String>();
-    for (int i = 0; i < request.headerCount(); i++) {
-      String name = request.headerName(i).toLowerCase(Locale.US);
-      String value = request.headerValue(i);
+  public static List<ByteString> writeNameValueBlock(Request request, String protocol,
+      String version) {
+    Headers headers = request.headers();
+    // TODO: make the known header names constants.
+    List<ByteString> result = new ArrayList<ByteString>(headers.size() + 10);
+    result.add(HEADER_METHOD);
+    result.add(ByteString.encodeUtf8(request.method()));
+    result.add(HEADER_PATH);
+    result.add(ByteString.encodeUtf8(RequestLine.requestPath(request.url())));
+    result.add(HEADER_VERSION);
+    result.add(ByteString.encodeUtf8(version));
+    if (protocol.equals("spdy/3")) {
+      result.add(HEADER_HOST);
+    } else if (protocol.equals("HTTP-draft-09/2.0")) {
+      result.add(HEADER_AUTHORITY);
+    } else {
+      throw new AssertionError();
+    }
+    result.add(ByteString.encodeUtf8(HttpEngine.hostHeader(request.url())));
+    result.add(HEADER_SCHEME);
+    result.add(ByteString.encodeUtf8(request.url().getProtocol()));
+
+    Set<ByteString> names = new LinkedHashSet<ByteString>();
+    for (int i = 0; i < headers.size(); i++) {
+      String name = headers.name(i).toLowerCase(Locale.US);
+      String value = headers.value(i);
 
       // Drop headers that are forbidden when layering HTTP over SPDY.
-      if (name.equals("connection")
-          || name.equals("host")
-          || name.equals("keep-alive")
-          || name.equals("proxy-connection")
-          || name.equals("transfer-encoding")) {
-        continue;
-      }
+      if (isProhibitedHeader(protocol, name)) continue;
 
       // They shouldn't be set, but if they are, drop them. We've already written them!
       if (name.equals(":method")
           || name.equals(":path")
           || name.equals(":version")
           || name.equals(":host")
+          || name.equals(":authority")
           || name.equals(":scheme")) {
         continue;
       }
+      ByteString valueBytes = ByteString.encodeUtf8(value);
 
       // If we haven't seen this name before, add the pair to the end of the list...
-      if (names.add(name)) {
-        result.add(name);
-        result.add(value);
+      if (names.add(ByteString.encodeUtf8(name))) {
+        result.add(ByteString.encodeUtf8(name));
+        result.add(valueBytes);
         continue;
       }
 
       // ...otherwise concatenate the existing values and this value.
       for (int j = 0; j < result.size(); j += 2) {
-        if (name.equals(result.get(j))) {
-          result.set(j + 1, result.get(j + 1) + "\0" + value);
+        if (result.get(j).utf8Equals(name)) {
+          result.set(j + 1, ByteString.concat(result.get(j + 1), NULL, valueBytes));
           break;
         }
       }
@@ -132,8 +148,8 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
   }
 
   /** Returns headers for a name value block containing a SPDY response. */
-  public static Response.Builder readNameValueBlock(List<String> nameValueBlock)
-      throws IOException {
+  public static Response.Builder readNameValueBlock(List<ByteString> nameValueBlock,
+      String protocol) throws IOException {
     if (nameValueBlock.size() % 2 != 0) {
       throw new IllegalArgumentException("Unexpected name value block: " + nameValueBlock);
     }
@@ -141,10 +157,10 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     String version = null;
 
     Headers.Builder headersBuilder = new Headers.Builder();
-    headersBuilder.set(SyntheticHeaders.SELECTED_TRANSPORT, "spdy/3");
+    headersBuilder.set(OkHeaders.SELECTED_TRANSPORT, protocol);
     for (int i = 0; i < nameValueBlock.size(); i += 2) {
-      String name = nameValueBlock.get(i);
-      String values = nameValueBlock.get(i + 1);
+      String name = nameValueBlock.get(i).utf8();
+      String values = nameValueBlock.get(i + 1).utf8();
       for (int start = 0; start < values.length(); ) {
         int end = values.indexOf('\0', start);
         if (end == -1) {
@@ -155,7 +171,7 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
           status = value;
         } else if (":version".equals(name)) {
           version = value;
-        } else {
+        } else if (!isProhibitedHeader(protocol, name)) { // Don't write forbidden headers!
           headersBuilder.add(name, value);
         }
         start = end + 1;
@@ -188,4 +204,34 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     }
     return true;
   }
+
+  /** When true, this header should not be emitted or consumed. */
+  private static boolean isProhibitedHeader(String protocol, String name) {
+    boolean prohibited = false;
+    if (protocol.equals("spdy/3")) {
+      // http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3#TOC-3.2.1-Request
+      if (name.equals("connection")
+          || name.equals("host")
+          || name.equals("keep-alive")
+          || name.equals("proxy-connection")
+          || name.equals("transfer-encoding")) {
+        prohibited = true;
+      }
+    } else if (protocol.equals("HTTP-draft-09/2.0")) {
+      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
+      if (name.equals("connection")
+          || name.equals("host")
+          || name.equals("keep-alive")
+          || name.equals("proxy-connection")
+          || name.equals("te")
+          || name.equals("transfer-encoding")
+          || name.equals("encoding")
+          || name.equals("upgrade")) {
+        prohibited = true;
+      }
+    } else {
+      throw new AssertionError();
+    }
+    return prohibited;
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SyntheticHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SyntheticHeaders.java
deleted file mode 100644
index fbb633d654..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SyntheticHeaders.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.internal.Platform;
-
-/** Headers added to the HTTP response for internal use by OkHttp. */
-public final class SyntheticHeaders {
-  static final String PREFIX = Platform.get().getPrefix();
-
-  /** The local time when the request was sent. */
-  public static final String SENT_MILLIS = PREFIX + "-Sent-Millis";
-
-  /** The local time when the response was received. */
-  public static final String RECEIVED_MILLIS = PREFIX + "-Received-Millis";
-
-  /** The response source. */
-  public static final String RESPONSE_SOURCE = PREFIX + "-Response-Source";
-
-  /** The selected transport (spdy/3, http/1.1, etc). */
-  public static final String SELECTED_TRANSPORT = PREFIX + "-Selected-Transport";
-
-  private SyntheticHeaders() {
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java b/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
index e21f93877b..bf4ee23410 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
@@ -17,12 +17,17 @@
 
 import com.squareup.okhttp.internal.RecordingHostnameVerifier;
 import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.Dispatcher;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
 import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
 import java.net.HttpURLConnection;
 import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.SSLContext;
 import org.junit.After;
 import org.junit.Before;
@@ -71,6 +76,26 @@
     assertTrue(server.takeRequest().getHeaders().contains("User-Agent: AsyncApiTest"));
   }
 
+  @Test public void connectionPooling() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+    server.play();
+
+    client.enqueue(new Request.Builder().url(server.getUrl("/a")).build(), receiver);
+    receiver.await(server.getUrl("/a")).assertBody("abc");
+
+    client.enqueue(new Request.Builder().url(server.getUrl("/b")).build(), receiver);
+    receiver.await(server.getUrl("/b")).assertBody("def");
+
+    client.enqueue(new Request.Builder().url(server.getUrl("/c")).build(), receiver);
+    receiver.await(server.getUrl("/c")).assertBody("ghi");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
   @Test public void tls() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse()
@@ -130,4 +155,167 @@
     receiver.await(request2.url()).assertCode(200).assertBody("A");
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
   }
+
+  @Test public void redirect() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .addHeader("Test", "Redirect from /a to /b")
+        .setBody("/a has moved!"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /c")
+        .addHeader("Test", "Redirect from /b to /c")
+        .setBody("/b has moved!"));
+    server.enqueue(new MockResponse().setBody("C"));
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    client.enqueue(request, receiver);
+
+    receiver.await(server.getUrl("/c"))
+        .assertCode(200)
+        .assertBody("C")
+        .redirectedBy()
+        .assertCode(302)
+        .assertContainsHeaders("Test: Redirect from /b to /c")
+        .redirectedBy()
+        .assertCode(301)
+        .assertContainsHeaders("Test: Redirect from /a to /b");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+  }
+
+  @Test public void redirectWithRedirectsDisabled() throws Exception {
+    client.setFollowProtocolRedirects(false);
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .addHeader("Test", "Redirect from /a to /b")
+        .setBody("/a has moved!"));
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    client.enqueue(request, receiver);
+
+    receiver.await(server.getUrl("/a"))
+        .assertCode(301)
+        .assertBody("/a has moved!")
+        .assertContainsHeaders("Location: /b");
+  }
+
+  @Test public void follow20Redirects() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/0")).build();
+    client.enqueue(request, receiver);
+    receiver.await(server.getUrl("/20"))
+        .assertCode(200)
+        .assertBody("Success!");
+  }
+
+  @Test public void doesNotFollow21Redirects() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/0")).build();
+    client.enqueue(request, receiver);
+    receiver.await(server.getUrl("/20")).assertFailure("Too many redirects: 21");
+  }
+
+  @Test public void canceledBeforeResponseReadIsNeverDelivered() throws Exception {
+    client.getDispatcher().setMaxRequests(1); // Force requests to be executed serially.
+    server.setDispatcher(new Dispatcher() {
+      char nextResponse = 'A';
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        client.cancel("request A");
+        return new MockResponse().setBody(Character.toString(nextResponse++));
+      }
+    });
+    server.play();
+
+    // Canceling a request after the server has received a request but before
+    // it has delivered the response. That request will never be received to the
+    // client.
+    Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    client.enqueue(requestA, receiver);
+    assertEquals("/a", server.takeRequest().getPath());
+
+    // We then make a second request (not canceled) to make sure the receiver
+    // has nothing left to wait for.
+    Request requestB = new Request.Builder().url(server.getUrl("/b")).tag("request B").build();
+    client.enqueue(requestB, receiver);
+    assertEquals("/b", server.takeRequest().getPath());
+    receiver.await(requestB.url()).assertBody("B");
+
+    // At this point we know the receiver is ready: if it hasn't received 'A'
+    // yet it never will.
+    receiver.assertNoResponse(requestA.url());
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredDoesNothing() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<String> bodyRef = new AtomicReference<String>();
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    client.enqueue(request, new Response.Receiver() {
+      @Override public void onFailure(Failure failure) {
+        throw new AssertionError();
+      }
+
+      @Override public boolean onResponse(Response response) throws IOException {
+        client.cancel("request A");
+        bodyRef.set(response.body().string());
+        latch.countDown();
+        return true;
+      }
+    });
+
+    latch.await();
+    assertEquals("A", bodyRef.get());
+  }
+
+  @Test public void connectionReuseWhenResponseBodyConsumed() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    client.enqueue(request, new Response.Receiver() {
+      @Override public void onFailure(Failure failure) {
+        throw new AssertionError();
+      }
+      @Override public boolean onResponse(Response response) throws IOException {
+        InputStream bytes = response.body().byteStream();
+        assertEquals('a', bytes.read());
+        assertEquals('b', bytes.read());
+        assertEquals('c', bytes.read());
+
+        // This request will share a connection with 'A' cause it's all done.
+        client.enqueue(new Request.Builder().url(server.getUrl("/b")).build(), receiver);
+        return true;
+      }
+    });
+
+    receiver.await(server.getUrl("/b")).assertCode(200).assertBody("def");
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reuse!
+  }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/DispatcherTest.java b/okhttp/src/test/java/com/squareup/okhttp/DispatcherTest.java
new file mode 100644
index 0000000000..034ed84b64
--- /dev/null
+++ b/okhttp/src/test/java/com/squareup/okhttp/DispatcherTest.java
@@ -0,0 +1,167 @@
+package com.squareup.okhttp;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.Executor;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class DispatcherTest {
+  RecordingExecutor executor = new RecordingExecutor();
+  RecordingReceiver receiver = new RecordingReceiver();
+  Dispatcher dispatcher = new Dispatcher(executor);
+  OkHttpClient client = new OkHttpClient().setDispatcher(dispatcher);
+
+  @Before public void setUp() throws Exception {
+    dispatcher.setMaxRequests(20);
+    dispatcher.setMaxRequestsPerHost(10);
+  }
+
+  @Test public void maxRequestsZero() throws Exception {
+    try {
+      dispatcher.setMaxRequests(0);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void maxPerHostZero() throws Exception {
+    try {
+      dispatcher.setMaxRequestsPerHost(0);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void enqueuedJobsRunImmediately() throws Exception {
+    client.enqueue(newRequest("http://a/1"), receiver);
+    executor.assertJobs("http://a/1");
+  }
+
+  @Test public void maxRequestsEnforced() throws Exception {
+    dispatcher.setMaxRequests(3);
+    client.enqueue(newRequest("http://a/1"), receiver);
+    client.enqueue(newRequest("http://a/2"), receiver);
+    client.enqueue(newRequest("http://b/1"), receiver);
+    client.enqueue(newRequest("http://b/2"), receiver);
+    executor.assertJobs("http://a/1", "http://a/2", "http://b/1");
+  }
+
+  @Test public void maxPerHostEnforced() throws Exception {
+    dispatcher.setMaxRequestsPerHost(2);
+    client.enqueue(newRequest("http://a/1"), receiver);
+    client.enqueue(newRequest("http://a/2"), receiver);
+    client.enqueue(newRequest("http://a/3"), receiver);
+    executor.assertJobs("http://a/1", "http://a/2");
+  }
+
+  @Test public void increasingMaxRequestsPromotesJobsImmediately() throws Exception {
+    dispatcher.setMaxRequests(2);
+    client.enqueue(newRequest("http://a/1"), receiver);
+    client.enqueue(newRequest("http://b/1"), receiver);
+    client.enqueue(newRequest("http://c/1"), receiver);
+    client.enqueue(newRequest("http://a/2"), receiver);
+    client.enqueue(newRequest("http://b/2"), receiver);
+    dispatcher.setMaxRequests(4);
+    executor.assertJobs("http://a/1", "http://b/1", "http://c/1", "http://a/2");
+  }
+
+  @Test public void increasingMaxPerHostPromotesJobsImmediately() throws Exception {
+    dispatcher.setMaxRequestsPerHost(2);
+    client.enqueue(newRequest("http://a/1"), receiver);
+    client.enqueue(newRequest("http://a/2"), receiver);
+    client.enqueue(newRequest("http://a/3"), receiver);
+    client.enqueue(newRequest("http://a/4"), receiver);
+    client.enqueue(newRequest("http://a/5"), receiver);
+    dispatcher.setMaxRequestsPerHost(4);
+    executor.assertJobs("http://a/1", "http://a/2", "http://a/3", "http://a/4");
+  }
+
+  @Test public void oldJobFinishesNewJobCanRunDifferentHost() throws Exception {
+    dispatcher.setMaxRequests(1);
+    client.enqueue(newRequest("http://a/1"), receiver);
+    client.enqueue(newRequest("http://b/1"), receiver);
+    executor.finishJob("http://a/1");
+    executor.assertJobs("http://b/1");
+  }
+
+  @Test public void oldJobFinishesNewJobWithSameHostStarts() throws Exception {
+    dispatcher.setMaxRequests(2);
+    dispatcher.setMaxRequestsPerHost(1);
+    client.enqueue(newRequest("http://a/1"), receiver);
+    client.enqueue(newRequest("http://b/1"), receiver);
+    client.enqueue(newRequest("http://b/2"), receiver);
+    client.enqueue(newRequest("http://a/2"), receiver);
+    executor.finishJob("http://a/1");
+    executor.assertJobs("http://b/1", "http://a/2");
+  }
+
+  @Test public void oldJobFinishesNewJobCantRunDueToHostLimit() throws Exception {
+    dispatcher.setMaxRequestsPerHost(1);
+    client.enqueue(newRequest("http://a/1"), receiver);
+    client.enqueue(newRequest("http://b/1"), receiver);
+    client.enqueue(newRequest("http://a/2"), receiver);
+    executor.finishJob("http://b/1");
+    executor.assertJobs("http://a/1");
+  }
+
+  @Test public void cancelingReadyJobPreventsItFromStarting() throws Exception {
+    dispatcher.setMaxRequestsPerHost(1);
+    client.enqueue(newRequest("http://a/1"), receiver);
+    client.enqueue(newRequest("http://a/2", "tag1"), receiver);
+    dispatcher.cancel("tag1");
+    executor.finishJob("http://a/1");
+    executor.assertJobs();
+  }
+
+  @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
+    dispatcher.setMaxRequests(1);
+    client.enqueue(newRequest("http://a/1", "tag1"), receiver);
+    client.enqueue(newRequest("http://a/2"), receiver);
+    dispatcher.cancel("tag1");
+    executor.assertJobs("http://a/1");
+    executor.finishJob("http://a/1");
+    executor.assertJobs("http://a/2");
+  }
+
+  class RecordingExecutor implements Executor {
+    private List<Job> jobs = new ArrayList<Job>();
+
+    @Override public void execute(Runnable command) {
+      jobs.add((Job) command);
+    }
+
+    public void assertJobs(String... expectedUrls) {
+      List<String> actualUrls = new ArrayList<String>();
+      for (Job job : jobs) {
+        actualUrls.add(job.request().urlString());
+      }
+      assertEquals(Arrays.asList(expectedUrls), actualUrls);
+    }
+
+    public void finishJob(String url) {
+      for (Iterator<Job> i = jobs.iterator(); i.hasNext(); ) {
+        Job job = i.next();
+        if (job.request().urlString().equals(url)) {
+          i.remove();
+          dispatcher.finished(job);
+          return;
+        }
+      }
+      throw new AssertionError("No such job: " + url);
+    }
+  }
+
+  private Request newRequest(String url) {
+    return new Request.Builder().url(url).build();
+  }
+
+  private Request newRequest(String url, String tag) {
+    return new Request.Builder().url(url).tag(tag).build();
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java b/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java
index cf18e4f4f3..6628331a92 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java
@@ -47,8 +47,9 @@ public RecordedResponse assertCode(int expectedCode) {
 
   public RecordedResponse assertContainsHeaders(String... expectedHeaders) {
     List<String> actualHeaders = new ArrayList<String>();
-    for (int i = 0; i < response.headerCount(); i++) {
-      actualHeaders.add(response.headerName(i) + ": " + response.headerValue(i));
+    Headers headers = response.headers();
+    for (int i = 0; i < headers.size(); i++) {
+      actualHeaders.add(headers.name(i) + ": " + headers.value(i));
     }
     if (!actualHeaders.containsAll(Arrays.asList(expectedHeaders))) {
       fail("Expected: " + actualHeaders + "\nto contain: " + Arrays.toString(expectedHeaders));
@@ -70,4 +71,20 @@ public RecordedResponse assertHandshake() {
     assertEquals(0, handshake.localCertificates().size());
     return this;
   }
+
+  /**
+   * Asserts that the current response was redirected and returns a new recorded
+   * response for the original request.
+   */
+  public RecordedResponse redirectedBy() {
+    Response redirectedBy = response.redirectedBy();
+    assertNotNull(redirectedBy);
+    assertNull(redirectedBy.body());
+    return new RecordedResponse(redirectedBy.request(), redirectedBy, null, null);
+  }
+
+  public void assertFailure(String message) {
+    assertNotNull(failure);
+    assertEquals(message, failure.exception().getMessage());
+  }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java b/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java
index 5d36c8d6c9..f5b54eede0 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java
@@ -86,4 +86,12 @@ public synchronized RecordedResponse await(URL url) throws Exception {
 
     throw new AssertionError("Timed out waiting for response to " + url);
   }
+
+  public synchronized void assertNoResponse(URL url) throws Exception {
+    for (RecordedResponse recordedResponse : responses) {
+      if (recordedResponse.request.url().equals(url)) {
+        throw new AssertionError("Expected no response for " + url);
+      }
+    }
+  }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
index 3b4dfcf091..238a199a0d 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
@@ -15,32 +15,35 @@
  */
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.ByteString;
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.List;
 import org.junit.Test;
 
+import static com.squareup.okhttp.internal.Util.byteStringList;
 import static junit.framework.Assert.assertNull;
 import static org.junit.Assert.assertEquals;
 
 public final class HeadersTest {
   @Test public void parseNameValueBlock() throws IOException {
-    List<String> nameValueBlock = Arrays.asList(
+    List<ByteString> nameValueBlock = byteStringList(
         "cache-control", "no-cache, no-store",
         "set-cookie", "Cookie1\u0000Cookie2",
         ":status", "200 OK",
         ":version", "HTTP/1.1");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = SpdyTransport.readNameValueBlock(nameValueBlock).request(request).build();
+    Response response =
+        SpdyTransport.readNameValueBlock(nameValueBlock, "spdy/3").request(request).build();
     Headers headers = response.headers();
     assertEquals(4, headers.size());
     assertEquals("HTTP/1.1 200 OK", response.statusLine());
     assertEquals("no-cache, no-store", headers.get("cache-control"));
     assertEquals("Cookie2", headers.get("set-cookie"));
-    assertEquals("spdy/3", headers.get(SyntheticHeaders.SELECTED_TRANSPORT));
-    assertEquals(SyntheticHeaders.SELECTED_TRANSPORT, headers.name(0));
+    assertEquals("spdy/3", headers.get(OkHeaders.SELECTED_TRANSPORT));
+    assertEquals(OkHeaders.SELECTED_TRANSPORT, headers.name(0));
     assertEquals("spdy/3", headers.value(0));
     assertEquals("cache-control", headers.name(1));
     assertEquals("no-cache, no-store", headers.value(1));
@@ -52,6 +55,34 @@
     assertNull(headers.get(":version"));
   }
 
+  @Test public void readNameValueBlockDropsForbiddenHeadersSpdy3() throws IOException {
+    List<ByteString> nameValueBlock = byteStringList(
+        ":status", "200 OK",
+        ":version", "HTTP/1.1",
+        "connection", "close");
+    Request request = new Request.Builder().url("http://square.com/").build();
+    Response response =
+        SpdyTransport.readNameValueBlock(nameValueBlock, "spdy/3").request(request).build();
+    Headers headers = response.headers();
+    assertEquals(1, headers.size());
+    assertEquals(OkHeaders.SELECTED_TRANSPORT, headers.name(0));
+    assertEquals("spdy/3", headers.value(0));;
+  }
+
+  @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
+    List<ByteString> nameValueBlock = byteStringList(
+        ":status", "200 OK",
+        ":version", "HTTP/1.1",
+        "connection", "close");
+    Request request = new Request.Builder().url("http://square.com/").build();
+    Response response =
+        SpdyTransport.readNameValueBlock(nameValueBlock, "HTTP-draft-09/2.0").request(request).build();
+    Headers headers = response.headers();
+    assertEquals(1, headers.size());
+    assertEquals(OkHeaders.SELECTED_TRANSPORT, headers.name(0));
+    assertEquals("HTTP-draft-09/2.0", headers.value(0));;
+  }
+
   @Test public void toNameValueBlock() {
     Request request = new Request.Builder()
         .url("http://square.com/")
@@ -60,8 +91,8 @@
         .addHeader("set-cookie", "Cookie2")
         .header(":status", "200 OK")
         .build();
-    List<String> nameValueBlock = SpdyTransport.writeNameValueBlock(request, "HTTP/1.1");
-    List<String> expected = Arrays.asList(
+    List<ByteString> nameValueBlock = SpdyTransport.writeNameValueBlock(request, "spdy/3", "HTTP/1.1");
+    List<ByteString> expected = byteStringList(
         ":method", "GET",
         ":path", "/",
         ":version", "HTTP/1.1",
@@ -73,18 +104,34 @@
     assertEquals(expected, nameValueBlock);
   }
 
-  @Test public void toNameValueBlockDropsForbiddenHeaders() {
+  @Test public void toNameValueBlockDropsForbiddenHeadersSpdy3() {
     Request request = new Request.Builder()
         .url("http://square.com/")
         .header("Connection", "close")
         .header("Transfer-Encoding", "chunked")
         .build();
-    List<String> expected = Arrays.asList(
+    List<ByteString> expected = byteStringList(
         ":method", "GET",
         ":path", "/",
         ":version", "HTTP/1.1",
         ":host", "square.com",
         ":scheme", "http");
-    assertEquals(expected, SpdyTransport.writeNameValueBlock(request, "HTTP/1.1"));
+    assertEquals(expected, SpdyTransport.writeNameValueBlock(request, "spdy/3", "HTTP/1.1"));
+  }
+
+  @Test public void toNameValueBlockDropsForbiddenHeadersHttp2() {
+    Request request = new Request.Builder()
+        .url("http://square.com/")
+        .header("Connection", "upgrade")
+        .header("Upgrade", "websocket")
+        .build();
+    List<ByteString> expected = byteStringList(
+        ":method", "GET",
+        ":path", "/",
+        ":version", "HTTP/1.1",
+        ":authority", "square.com",
+        ":scheme", "http");
+    assertEquals(expected,
+        SpdyTransport.writeNameValueBlock(request, "HTTP-draft-09/2.0", "HTTP/1.1"));
   }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
new file mode 100644
index 0000000000..dfc962be97
--- /dev/null
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+public class HttpOverHttp20Draft09Test extends HttpOverSpdyTest {
+
+  public HttpOverHttp20Draft09Test() {
+    super("HTTP-draft-09/2.0");
+    // TODO: is this really the whole authority, or just the host/port?
+    // https://github.com/http2/http2-spec/issues/334
+    this.hostHeader = ":authority";
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
new file mode 100644
index 0000000000..4c30e45f4a
--- /dev/null
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+public class HttpOverSpdy3Test extends HttpOverSpdyTest {
+
+  public HttpOverSpdy3Test() {
+    super("spdy/3");
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index 035d5d21c0..eaa59ec165 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -15,6 +15,7 @@
  */
 package com.squareup.okhttp.internal.http;
 
+
 import com.squareup.okhttp.HttpResponseCache;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.internal.RecordingAuthenticator;
@@ -23,7 +24,10 @@
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.SocketPolicy;
+
 import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -39,12 +43,19 @@
 import java.util.List;
 import java.util.Map;
 import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import static org.junit.Assert.assertArrayEquals;
@@ -54,7 +65,16 @@
 import static org.junit.Assert.fail;
 
 /** Test how SPDY interacts with HTTP features. */
-public final class HttpOverSpdyTest {
+public abstract class HttpOverSpdyTest {
+
+  /** Transport to test, for example {@code spdy/3} */
+  private final String transport;
+  protected String hostHeader = ":host";
+
+  protected HttpOverSpdyTest(String transport){
+    this.transport = transport;
+  }
+
   private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
     public boolean verify(String hostname, SSLSession session) {
       return true;
@@ -69,10 +89,11 @@ public boolean verify(String hostname, SSLSession session) {
 
   @Before public void setUp() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
+    client.setTransports(Arrays.asList(transport, "http/1.1"));
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     String systemTmpDir = System.getProperty("java.io.tmpdir");
-    File cacheDir = new File(systemTmpDir, "HttpCache-" + UUID.randomUUID());
+    File cacheDir = new File(systemTmpDir, "HttpCache-" + transport + "-" + UUID.randomUUID());
     cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
   }
 
@@ -94,7 +115,7 @@ public boolean verify(String hostname, SSLSession session) {
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
     assertContains(request.getHeaders(), ":scheme: https");
-    assertContains(request.getHeaders(), ":host: " + hostName + ":" + server.getPort());
+    assertContains(request.getHeaders(), hostHeader + ": " + hostName + ":" + server.getPort());
   }
 
   @Test public void emptyResponse() throws IOException {
@@ -173,6 +194,20 @@ public boolean verify(String hostname, SSLSession session) {
     assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
+  @Test @Ignore public void synchronousSpdyRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+
+    ExecutorService executor = Executors.newCachedThreadPool();
+    CountDownLatch countDownLatch = new CountDownLatch(2);
+    executor.execute(new SpdyRequest("/r1", countDownLatch));
+    executor.execute(new SpdyRequest("/r2", countDownLatch));
+    countDownLatch.await();
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
   @Test public void gzippedResponseBody() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Encoding: gzip")
         .setBody(gzip("ABCABCABC".getBytes(Util.UTF_8))));
@@ -226,6 +261,16 @@ public boolean verify(String hostname, SSLSession session) {
     assertEquals(-1, in.read());
   }
 
+  @Test(timeout = 3000) public void readResponseHeaderTimeout() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection.setReadTimeout(1000);
+    assertContent("A", connection, Integer.MAX_VALUE);
+  }
+
   @Test public void responsesAreCached() throws IOException {
     client.setResponseCache(cache);
 
@@ -321,4 +366,24 @@ private String readAscii(InputStream in, int count) throws IOException {
     gzippedOut.close();
     return bytesOut.toByteArray();
   }
+
+  class SpdyRequest implements Runnable {
+    String path;
+    CountDownLatch countDownLatch;
+    public SpdyRequest(String path, CountDownLatch countDownLatch) {
+      this.path = path;
+      this.countDownLatch = countDownLatch;
+    }
+
+    @Override public void run() {
+      try {
+        HttpURLConnection conn = null;
+        conn = (HttpURLConnection) client.open(server.getUrl(path));
+        assertEquals("A", readAscii(conn.getInputStream(), 1));
+        countDownLatch.countDown();
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+  }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
index 946c4084e3..91dfcd1f28 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
@@ -233,14 +233,10 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
       @Override public CacheRequest put(Response response) throws IOException {
         assertEquals(server.getUrl("/"), response.request().url());
         assertEquals(200, response.code());
-        assertEquals(body.length(), response.body().contentLength());
-        assertEquals("text/plain", response.body().contentType().toString());
+        assertNull(response.body());
+        assertEquals("5", response.header("Content-Length"));
+        assertEquals("text/plain", response.header("Content-Type"));
         assertEquals("ijk", response.header("fgh"));
-        try {
-          response.body().byteStream(); // the RI doesn't forbid this, but it should
-          fail();
-        } catch (IllegalStateException expected) {
-        }
         cacheCount.incrementAndGet();
         return null;
       }
@@ -1696,7 +1692,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
 
-    String source = connection.getHeaderField(SyntheticHeaders.RESPONSE_SOURCE);
+    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
     assertEquals(ResponseSource.CACHE + " 200", source);
   }
 
@@ -1713,7 +1709,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("B", readAscii(connection));
 
-    String source = connection.getHeaderField(SyntheticHeaders.RESPONSE_SOURCE);
+    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
     assertEquals(ResponseSource.CONDITIONAL_CACHE + " 200", source);
   }
 
@@ -1728,7 +1724,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
 
-    String source = connection.getHeaderField(SyntheticHeaders.RESPONSE_SOURCE);
+    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
     assertEquals(ResponseSource.CONDITIONAL_CACHE + " 304", source);
   }
 
@@ -1739,7 +1735,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     URLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
 
-    String source = connection.getHeaderField(SyntheticHeaders.RESPONSE_SOURCE);
+    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
     assertEquals(ResponseSource.NETWORK + " 200", source);
   }
 
@@ -1956,7 +1952,7 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
     assertEquals(504, connection.getResponseCode());
     assertEquals(-1, connection.getErrorStream().read());
     assertEquals(ResponseSource.NONE + " 504",
-        connection.getHeaderField(SyntheticHeaders.RESPONSE_SOURCE));
+        connection.getHeaderField(OkHeaders.RESPONSE_SOURCE));
   }
 
   enum TransferKind {
diff --git a/pom.xml b/pom.xml
index a24a0efedc..0391107ec0 100644
--- a/pom.xml
+++ b/pom.xml
@@ -162,8 +162,8 @@
         <configuration>
           <signature>
             <groupId>org.codehaus.mojo.signature</groupId>
-            <artifactId>java15</artifactId>
-            <version>1.0</version>
+            <artifactId>java16</artifactId>
+            <version>1.1</version>
           </signature>
         </configuration>
       </plugin>
