diff --git a/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java b/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
index de5788539a..0f07706eaf 100644
--- a/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
+++ b/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
@@ -16,7 +16,6 @@
 package okhttp3;
 
 import java.net.ResponseCache;
-import okhttp3.internal.huc.CacheAdapter;
 
 /**
  * Back doors to enable the use of OkHttp within the Android platform libraries. OkHttp is used to
@@ -28,18 +27,4 @@
   private AndroidInternal() {
   }
 
-  /** Sets the response cache to be used to read and write cached responses. */
-  public static void setResponseCache(OkUrlFactory okUrlFactory, ResponseCache responseCache) {
-    OkHttpClient.Builder builder = okUrlFactory.client().newBuilder();
-    if (responseCache instanceof OkCacheContainer) {
-      // Avoid adding layers of wrappers. Rather than wrap the ResponseCache in yet another layer to
-      // make the ResponseCache look like an InternalCache, we can unwrap the Cache instead.
-      // This means that Cache stats will be correctly updated.
-      OkCacheContainer okCacheContainer = (OkCacheContainer) responseCache;
-      builder.cache(okCacheContainer.getCache());
-    } else {
-      builder.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
-    }
-    okUrlFactory.setClient(builder.build());
-  }
 }
diff --git a/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
deleted file mode 100644
index c46a0cb9fd..0000000000
--- a/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-import okhttp3.internal.huc.JavaApiConverter;
-
-/**
- * A class provided for use by Android so that it can continue supporting a {@link ResponseCache}
- * with stats.
- */
-public class AndroidShimResponseCache extends ResponseCache {
-
-  private final Cache delegate;
-
-  private AndroidShimResponseCache(Cache delegate) {
-    this.delegate = delegate;
-  }
-
-  public static AndroidShimResponseCache create(File directory, long maxSize) throws IOException {
-    Cache cache = new Cache(directory, maxSize);
-    return new AndroidShimResponseCache(cache);
-  }
-
-  public boolean isEquivalent(File directory, long maxSize) {
-    Cache installedCache = getCache();
-    return (installedCache.directory().equals(directory)
-        && installedCache.maxSize() == maxSize
-        && !installedCache.isClosed());
-  }
-
-  public Cache getCache() {
-    return delegate;
-  }
-
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) throws IOException {
-    Request okRequest = JavaApiConverter.createOkRequest(uri, requestMethod, requestHeaders);
-    Response okResponse = delegate.internalCache.get(okRequest);
-    if (okResponse == null) {
-      return null;
-    }
-    return JavaApiConverter.createJavaCacheResponse(okResponse);
-  }
-
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    Response okResponse = JavaApiConverter.createOkResponseForCachePut(uri, urlConnection);
-    if (okResponse == null) {
-      // The URLConnection is not cacheable or could not be converted. Stop.
-      return null;
-    }
-    okhttp3.internal.cache.CacheRequest okCacheRequest =
-        delegate.internalCache.put(okResponse);
-    if (okCacheRequest == null) {
-      return null;
-    }
-    return JavaApiConverter.createJavaCacheRequest(okCacheRequest);
-  }
-
-  /**
-   * Returns the number of bytes currently being used to store the values in this cache. This may be
-   * greater than the {@link #maxSize} if a background deletion is pending.
-   */
-  public long size() throws IOException {
-    return delegate.size();
-  }
-
-  /**
-   * Returns the maximum number of bytes that this cache should use to store its data.
-   */
-  public long maxSize() {
-    return delegate.maxSize();
-  }
-
-  /**
-   * Force buffered operations to the filesystem. This ensures that responses written to the cache
-   * will be available the next time the cache is opened, even if this process is killed.
-   */
-  public void flush() throws IOException {
-    delegate.flush();
-  }
-
-  /**
-   * Returns the number of HTTP requests that required the network to either supply a response or
-   * validate a locally cached response.
-   */
-  public int getNetworkCount() {
-    return delegate.networkCount();
-  }
-
-  /**
-   * Returns the number of HTTP requests whose response was provided by the cache. This may include
-   * conditional {@code GET} requests that were validated over the network.
-   */
-  public int getHitCount() {
-    return delegate.hitCount();
-  }
-
-  /**
-   * Returns the total number of HTTP requests that were made. This includes both client requests
-   * and requests that were made on the client's behalf to handle a redirects and retries.
-   */
-  public int getRequestCount() {
-    return delegate.requestCount();
-  }
-
-  /**
-   * Uninstalls the cache and releases any active resources. Stored contents will remain on the
-   * filesystem.
-   */
-  public void close() throws IOException {
-    delegate.close();
-  }
-
-  /**
-   * Uninstalls the cache and deletes all of its stored contents.
-   */
-  public void delete() throws IOException {
-    delegate.delete();
-  }
-}
diff --git a/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java b/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
deleted file mode 100644
index d52cb0133d..0000000000
--- a/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-/**
- * An interface that allows OkHttp to detect that a {@link java.net.ResponseCache} contains a {@link
- * Cache}.
- */
-public interface OkCacheContainer {
-  Cache getCache();
-}
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
deleted file mode 100644
index 5bca95b937..0000000000
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.util.List;
-import java.util.Map;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.cache.CacheRequest;
-import okhttp3.internal.cache.CacheStrategy;
-import okhttp3.internal.cache.InternalCache;
-import okio.Okio;
-import okio.Sink;
-
-/** Adapts {@link ResponseCache} to {@link InternalCache}. */
-public final class CacheAdapter implements InternalCache {
-  private final ResponseCache delegate;
-
-  public CacheAdapter(ResponseCache delegate) {
-    this.delegate = delegate;
-  }
-
-  public ResponseCache getDelegate() {
-    return delegate;
-  }
-
-  @Override public Response get(Request request) throws IOException {
-    CacheResponse javaResponse = getJavaCachedResponse(request);
-    if (javaResponse == null) {
-      return null;
-    }
-    return JavaApiConverter.createOkResponseForCacheGet(request, javaResponse);
-  }
-
-  @Override public CacheRequest put(Response response) throws IOException {
-    URI uri = response.request().url().uri();
-    HttpURLConnection connection = JavaApiConverter.createJavaUrlConnectionForCachePut(response);
-    final java.net.CacheRequest request = delegate.put(uri, connection);
-    if (request == null) {
-      return null;
-    }
-    return new CacheRequest() {
-      @Override public Sink body() throws IOException {
-        OutputStream body = request.getBody();
-        return body != null ? Okio.sink(body) : null;
-      }
-
-      @Override public void abort() {
-        request.abort();
-      }
-    };
-  }
-
-  @Override public void remove(Request request) throws IOException {
-    // This method is treated as optional and there is no obvious way of implementing it with
-    // ResponseCache. Removing items from the cache due to modifications made from this client is
-    // not essential given that modifications could be made from any other client. We have to assume
-    // that it's ok to keep using the cached data. Otherwise the server shouldn't declare it as
-    // cacheable or the client should be careful about caching it.
-  }
-
-  @Override public void update(Response cached, Response network) {
-    // This method is treated as optional and there is no obvious way of implementing it with
-    // ResponseCache. Updating headers is useful if the server changes the metadata for a resource
-    // (e.g. max age) to extend or truncate the life of that resource in the cache. If the metadata
-    // is not updated the caching behavior may not be optimal, but will obey the metadata sent
-    // with the original cached response.
-  }
-
-  @Override public void trackConditionalCacheHit() {
-    // This method is optional.
-  }
-
-  @Override public void trackResponse(CacheStrategy cacheStrategy) {
-    // This method is optional.
-  }
-
-  /**
-   * Returns the {@link CacheResponse} from the delegate by converting the OkHttp {@link Request}
-   * into the arguments required by the {@link ResponseCache}.
-   */
-  private CacheResponse getJavaCachedResponse(Request request) throws IOException {
-    Map<String, List<String>> headers = JavaApiConverter.extractJavaHeaders(request);
-    return delegate.get(request.url().uri(), request.method(), headers);
-  }
-}
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
index b65d463b51..34dd6043af 100644
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
@@ -45,7 +45,6 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.JavaNetHeaders;
 import okhttp3.internal.Util;
-import okhttp3.internal.cache.CacheRequest;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http.HttpMethod;
 import okhttp3.internal.http.StatusLine;
@@ -364,23 +363,6 @@ public InputStream getBody() throws IOException {
     }
   }
 
-  public static java.net.CacheRequest createJavaCacheRequest(final CacheRequest okCacheRequest) {
-    return new java.net.CacheRequest() {
-      @Override
-      public void abort() {
-        okCacheRequest.abort();
-      }
-
-      @Override
-      public OutputStream getBody() throws IOException {
-        Sink body = okCacheRequest.body();
-        if (body == null) {
-          return null;
-        }
-        return Okio.buffer(body).outputStream();
-      }
-    };
-  }
 
   /**
    * Creates an {@link java.net.HttpURLConnection} of the correct subclass from the supplied OkHttp
diff --git a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
deleted file mode 100644
index c569a3b365..0000000000
--- a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.android;
-
-import java.io.Closeable;
-import java.io.File;
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-import okhttp3.AndroidShimResponseCache;
-import okhttp3.Cache;
-import okhttp3.OkCacheContainer;
-
-/**
- * A copy of android.net.http.HttpResponseCache taken from AOSP. Android need to keep this code
- * working somehow. Dependencies on okhttp3 are com.android.okhttp on Android.
- *
- * <p>This class exists in okhttp-android-support to help keep the API as it always has been on
- * Android. The public API cannot be changed. This class delegates to {@link
- * AndroidShimResponseCache}, a class that exists in a package that enables it to interact with
- * non-public OkHttp classes.
- */
-public final class HttpResponseCache extends ResponseCache implements Closeable, OkCacheContainer {
-
-  private AndroidShimResponseCache shimResponseCache;
-
-  private HttpResponseCache(AndroidShimResponseCache shimResponseCache) {
-    this.shimResponseCache = shimResponseCache;
-  }
-
-  /**
-   * Returns the currently-installed {@code HttpResponseCache}, or null if there is no cache
-   * installed or it is not a {@code HttpResponseCache}.
-   */
-  public static HttpResponseCache getInstalled() {
-    ResponseCache installed = ResponseCache.getDefault();
-    if (installed instanceof HttpResponseCache) {
-      return (HttpResponseCache) installed;
-    }
-    return null;
-  }
-
-  /**
-   * Creates a new HTTP response cache and sets it as the system default cache.
-   *
-   * @param directory the directory to hold cache data.
-   * @param maxSize the maximum size of the cache in bytes.
-   * @return the newly-installed cache
-   * @throws java.io.IOException if {@code directory} cannot be used for this cache. Most
-   * applications should respond to this exception by logging a warning.
-   */
-  public static synchronized HttpResponseCache install(File directory, long maxSize) throws
-      IOException {
-    ResponseCache installed = ResponseCache.getDefault();
-
-    if (installed instanceof HttpResponseCache) {
-      HttpResponseCache installedResponseCache = (HttpResponseCache) installed;
-      // don't close and reopen if an equivalent cache is already installed
-      AndroidShimResponseCache trueResponseCache = installedResponseCache.shimResponseCache;
-      if (trueResponseCache.isEquivalent(directory, maxSize)) {
-        return installedResponseCache;
-      } else {
-        // The HttpResponseCache that owns this object is about to be replaced.
-        trueResponseCache.close();
-      }
-    }
-
-    AndroidShimResponseCache trueResponseCache =
-        AndroidShimResponseCache.create(directory, maxSize);
-    HttpResponseCache newResponseCache = new HttpResponseCache(trueResponseCache);
-    ResponseCache.setDefault(newResponseCache);
-    return newResponseCache;
-  }
-
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) throws IOException {
-    return shimResponseCache.get(uri, requestMethod, requestHeaders);
-  }
-
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    return shimResponseCache.put(uri, urlConnection);
-  }
-
-  /**
-   * Returns the number of bytes currently being used to store the values in this cache. This may be
-   * greater than the {@link #maxSize} if a background deletion is pending.
-   */
-  public long size() {
-    try {
-      return shimResponseCache.size();
-    } catch (IOException e) {
-      // This can occur if the cache failed to lazily initialize. Return -1 to mean "unknown".
-      return -1;
-    }
-  }
-
-  /**
-   * Returns the maximum number of bytes that this cache should use to store its data.
-   */
-  public long maxSize() {
-    return shimResponseCache.maxSize();
-  }
-
-  /**
-   * Force buffered operations to the filesystem. This ensures that responses written to the cache
-   * will be available the next time the cache is opened, even if this process is killed.
-   */
-  public void flush() {
-    try {
-      shimResponseCache.flush();
-    } catch (IOException ignored) {
-    }
-  }
-
-  /**
-   * Returns the number of HTTP requests that required the network to either supply a response or
-   * validate a locally cached response.
-   */
-  public int getNetworkCount() {
-    return shimResponseCache.getNetworkCount();
-  }
-
-  /**
-   * Returns the number of HTTP requests whose response was provided by the cache. This may include
-   * conditional {@code GET} requests that were validated over the network.
-   */
-  public int getHitCount() {
-    return shimResponseCache.getHitCount();
-  }
-
-  /**
-   * Returns the total number of HTTP requests that were made. This includes both client requests
-   * and requests that were made on the client's behalf to handle a redirects and retries.
-   */
-  public int getRequestCount() {
-    return shimResponseCache.getRequestCount();
-  }
-
-  /**
-   * Uninstalls the cache and releases any active resources. Stored contents will remain on the
-   * filesystem.
-   */
-  @Override public void close() throws IOException {
-    if (ResponseCache.getDefault() == this) {
-      ResponseCache.setDefault(null);
-    }
-    shimResponseCache.close();
-  }
-
-  /**
-   * Uninstalls the cache and deletes all of its stored contents.
-   */
-  public void delete() throws IOException {
-    if (ResponseCache.getDefault() == this) {
-      ResponseCache.setDefault(null);
-    }
-    shimResponseCache.delete();
-  }
-
-  @Override
-  public Cache getCache() {
-    return shimResponseCache.getCache();
-  }
-}
diff --git a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
deleted file mode 100644
index dcb1c01815..0000000000
--- a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.android;
-
-import java.io.File;
-import java.io.InputStream;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-import okhttp3.AndroidInternal;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.fail;
-
-/**
- * A port of Android's android.net.http.HttpResponseCacheTest to JUnit4.
- */
-public final class HttpResponseCacheTest {
-  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
-  @Rule public MockWebServer server = new MockWebServer();
-
-  private File cacheDir;
-  private OkUrlFactory urlFactory;
-
-  @Before public void setUp() throws Exception {
-    cacheDir = cacheRule.getRoot();
-    urlFactory = new OkUrlFactory(new OkHttpClient());
-  }
-
-  @After public void tearDown() throws Exception {
-    ResponseCache.setDefault(null);
-  }
-
-  @Test public void install() throws Exception {
-    HttpResponseCache installed = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    assertNotNull(installed);
-    assertSame(installed, ResponseCache.getDefault());
-    assertSame(installed, HttpResponseCache.getDefault());
-  }
-
-  @Test public void secondEquivalentInstallDoesNothing() throws Exception {
-    HttpResponseCache first = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    HttpResponseCache another = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    assertSame(first, another);
-  }
-
-  @Test public void installClosesPreviouslyInstalled() throws Exception {
-    HttpResponseCache first = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    initializeCache(first);
-
-    HttpResponseCache another = HttpResponseCache.install(cacheDir, 8 * 1024 * 1024);
-    initializeCache(another);
-
-    assertNotSame(first, another);
-    try {
-      first.flush();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void getInstalledWithWrongTypeInstalled() {
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override
-      public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) {
-        return null;
-      }
-
-      @Override
-      public CacheRequest put(URI uri, URLConnection connection) {
-        return null;
-      }
-    });
-    assertNull(HttpResponseCache.getInstalled());
-  }
-
-  @Test public void closeCloses() throws Exception {
-    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    initializeCache(cache);
-
-    cache.close();
-    try {
-      cache.flush();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void closeUninstalls() throws Exception {
-    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    cache.close();
-    assertNull(ResponseCache.getDefault());
-  }
-
-  @Test public void deleteUninstalls() throws Exception {
-    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    cache.delete();
-    assertNull(ResponseCache.getDefault());
-  }
-
-  /**
-   * Make sure that statistics tracking are wired all the way through the wrapper class.
-   * http://code.google.com/p/android/issues/detail?id=25418
-   */
-  @Test public void statisticsTracking() throws Exception {
-    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-
-    URLConnection c1 = openUrl(server.url("/"));
-
-    InputStream inputStream = c1.getInputStream();
-    assertEquals('A', inputStream.read());
-    inputStream.close();
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-
-    URLConnection c2 = openUrl(server.url("/"));
-    assertEquals('A', c2.getInputStream().read());
-
-    URLConnection c3 = openUrl(server.url("/"));
-    assertEquals('A', c3.getInputStream().read());
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
-  }
-
-  // This mimics the Android HttpHandler, which is found in the okhttp3 package.
-  private URLConnection openUrl(HttpUrl url) {
-    ResponseCache responseCache = ResponseCache.getDefault();
-    AndroidInternal.setResponseCache(urlFactory, responseCache);
-    return urlFactory.open(url.url());
-  }
-
-  private void initializeCache(HttpResponseCache cache) {
-    // Ensure the cache is initialized, otherwise various methods are no-ops.
-    cache.size();
-  }
-}
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
deleted file mode 100644
index 53470ce87b..0000000000
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
+++ /dev/null
@@ -1,295 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URL;
-import java.net.URLConnection;
-import java.nio.charset.StandardCharsets;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import okhttp3.AbstractResponseCache;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.internal.Internal;
-import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.tls.SslClient;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okio.Buffer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-/**
- * A white-box test for {@link CacheAdapter}. See also:
- * <ul>
- *     <li>{@link ResponseCacheTest} for black-box tests that check that {@link ResponseCache}
- *         classes are called correctly by OkHttp.
- *     <li>{@link JavaApiConverterTest} for tests that check Java API classes / OkHttp conversion
- *         logic.
- * </ul>
- */
-public class CacheAdapterTest {
-  private SslClient sslClient = SslClient.localhost();
-  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  private MockWebServer server;
-  private OkHttpClient client;
-  private HttpURLConnection connection;
-
-  @Before public void setUp() throws Exception {
-    server = new MockWebServer();
-    client = new OkHttpClient();
-  }
-
-  @After public void tearDown() throws Exception {
-    if (connection != null) {
-      connection.disconnect();
-    }
-    server.shutdown();
-  }
-
-  @Test public void get_httpGet() throws Exception {
-    final URL serverUrl = configureServer(new MockResponse());
-    assertEquals("http", serverUrl.getProtocol());
-
-    ResponseCache responseCache = new AbstractResponseCache() {
-      @Override public CacheResponse get(
-          URI uri, String method, Map<String, List<String>> headers) throws IOException {
-        try {
-          assertEquals(toUri(serverUrl), uri);
-          assertEquals("GET", method);
-          assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
-          assertEquals(Collections.singletonList("value1"), headers.get("key1"));
-          return null;
-        } catch (Throwable t) {
-          throw new IOException("unexpected cache failure", t);
-        }
-      }
-    };
-    setInternalCache(new CacheAdapter(responseCache));
-
-    connection = new OkUrlFactory(client).open(serverUrl);
-    connection.setRequestProperty("key1", "value1");
-
-    executeGet(connection);
-  }
-
-  @Test public void get_httpsGet() throws Exception {
-    final URL serverUrl = configureHttpsServer(new MockResponse());
-    assertEquals("https", serverUrl.getProtocol());
-
-    ResponseCache responseCache = new AbstractResponseCache() {
-      @Override public CacheResponse get(URI uri, String method, Map<String, List<String>> headers)
-          throws IOException {
-        try {
-          assertEquals("https", uri.getScheme());
-          assertEquals(toUri(serverUrl), uri);
-          assertEquals("GET", method);
-          assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
-          assertEquals(Collections.singletonList("value1"), headers.get("key1"));
-          return null;
-        } catch (Throwable t) {
-          throw new IOException("unexpected cache failure", t);
-        }
-      }
-    };
-    setInternalCache(new CacheAdapter(responseCache));
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-
-    connection = new OkUrlFactory(client).open(serverUrl);
-    connection.setRequestProperty("key1", "value1");
-
-    executeGet(connection);
-  }
-
-  @Test public void put_httpGet() throws Exception {
-    final String statusLine = "HTTP/1.1 200 Fantastic";
-    final byte[] response = "ResponseString".getBytes(StandardCharsets.UTF_8);
-    final URL serverUrl = configureServer(
-        new MockResponse()
-            .setStatus(statusLine)
-            .addHeader("A", "c")
-            .setBody(new Buffer().write(response)));
-
-    ResponseCache responseCache = new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        try {
-          assertTrue(connection instanceof HttpURLConnection);
-          assertFalse(connection instanceof HttpsURLConnection);
-
-          assertEquals(response.length, connection.getContentLength());
-
-          HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
-          assertEquals("GET", httpUrlConnection.getRequestMethod());
-          assertTrue(httpUrlConnection.getDoInput());
-          assertFalse(httpUrlConnection.getDoOutput());
-
-          assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
-          assertEquals(toUri(serverUrl), uri);
-          assertEquals(serverUrl, connection.getURL());
-          assertEquals("value", connection.getRequestProperty("key"));
-
-          // Check retrieval by string key.
-          assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
-          assertEquals("c", httpUrlConnection.getHeaderField("A"));
-          // The RI and OkHttp supports case-insensitive matching for this method.
-          assertEquals("c", httpUrlConnection.getHeaderField("a"));
-          return null;
-        } catch (Throwable t) {
-          throw new IOException("unexpected cache failure", t);
-        }
-      }
-    };
-    setInternalCache(new CacheAdapter(responseCache));
-
-    connection = new OkUrlFactory(client).open(serverUrl);
-    connection.setRequestProperty("key", "value");
-    executeGet(connection);
-  }
-
-  @Test public void put_httpPost() throws Exception {
-    final String statusLine = "HTTP/1.1 200 Fantastic";
-    final URL serverUrl = configureServer(
-        new MockResponse()
-            .setStatus(statusLine)
-            .addHeader("A", "c"));
-
-    ResponseCache responseCache = new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        try {
-          assertTrue(connection instanceof HttpURLConnection);
-          assertFalse(connection instanceof HttpsURLConnection);
-
-          assertEquals(0, connection.getContentLength());
-
-          HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
-          assertEquals("POST", httpUrlConnection.getRequestMethod());
-          assertTrue(httpUrlConnection.getDoInput());
-          assertTrue(httpUrlConnection.getDoOutput());
-
-          assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
-          assertEquals(toUri(serverUrl), uri);
-          assertEquals(serverUrl, connection.getURL());
-          assertEquals("value", connection.getRequestProperty("key"));
-
-          // Check retrieval by string key.
-          assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
-          assertEquals("c", httpUrlConnection.getHeaderField("A"));
-          // The RI and OkHttp supports case-insensitive matching for this method.
-          assertEquals("c", httpUrlConnection.getHeaderField("a"));
-          return null;
-        } catch (Throwable t) {
-          throw new IOException("unexpected cache failure", t);
-        }
-      }
-    };
-    setInternalCache(new CacheAdapter(responseCache));
-
-    connection = new OkUrlFactory(client).open(serverUrl);
-
-    executePost(connection);
-  }
-
-  @Test public void put_httpsGet() throws Exception {
-    final URL serverUrl = configureHttpsServer(new MockResponse());
-    assertEquals("https", serverUrl.getProtocol());
-
-    ResponseCache responseCache = new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        try {
-          assertTrue(connection instanceof HttpsURLConnection);
-          assertEquals(toUri(serverUrl), uri);
-          assertEquals(serverUrl, connection.getURL());
-
-          HttpsURLConnection cacheHttpsUrlConnection = (HttpsURLConnection) connection;
-          HttpsURLConnection realHttpsUrlConnection =
-              (HttpsURLConnection) CacheAdapterTest.this.connection;
-          assertEquals(realHttpsUrlConnection.getCipherSuite(),
-              cacheHttpsUrlConnection.getCipherSuite());
-          assertEquals(realHttpsUrlConnection.getPeerPrincipal(),
-              cacheHttpsUrlConnection.getPeerPrincipal());
-          assertArrayEquals(realHttpsUrlConnection.getLocalCertificates(),
-              cacheHttpsUrlConnection.getLocalCertificates());
-          assertArrayEquals(realHttpsUrlConnection.getServerCertificates(),
-              cacheHttpsUrlConnection.getServerCertificates());
-          assertEquals(realHttpsUrlConnection.getLocalPrincipal(),
-              cacheHttpsUrlConnection.getLocalPrincipal());
-          return null;
-        } catch (Throwable t) {
-          throw new IOException("unexpected cache failure", t);
-        }
-      }
-    };
-    setInternalCache(new CacheAdapter(responseCache));
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-
-    connection = new OkUrlFactory(client).open(serverUrl);
-    executeGet(connection);
-  }
-
-  private void executeGet(HttpURLConnection connection) throws IOException {
-    connection.connect();
-    connection.getHeaderFields();
-    connection.disconnect();
-  }
-
-  private void executePost(HttpURLConnection connection) throws IOException {
-    connection.setDoOutput(true);
-    connection.connect();
-    connection.getOutputStream().write("Hello World".getBytes());
-    connection.disconnect();
-  }
-
-  private URL configureServer(MockResponse mockResponse) throws Exception {
-    server.enqueue(mockResponse);
-    server.start();
-    return server.url("/").url();
-  }
-
-  private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
-    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);
-    server.enqueue(mockResponse);
-    server.start();
-    return server.url("/").url();
-  }
-
-  private void setInternalCache(InternalCache internalCache) {
-    OkHttpClient.Builder builder = client.newBuilder();
-    Internal.instance.setCache(builder, internalCache);
-    client = builder.build();
-  }
-}
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
deleted file mode 100644
index 51bf46cc88..0000000000
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
+++ /dev/null
@@ -1,2200 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.internal.huc;
-
-import java.io.BufferedReader;
-import java.io.ByteArrayInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.CookieManager;
-import java.net.HttpCookie;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.ResponseCache;
-import java.net.SecureCacheResponse;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.net.URLConnection;
-import java.nio.charset.StandardCharsets;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.TimeZone;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import okhttp3.AbstractResponseCache;
-import okhttp3.AndroidInternal;
-import okhttp3.AndroidShimResponseCache;
-import okhttp3.Headers;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.internal.Internal;
-import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.tls.SslClient;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeFalse;
-
-/**
- * Tests the interaction between OkHttp and {@link ResponseCache}. Based on okhttp3.CacheTest with
- * changes for ResponseCache and HttpURLConnection.
- */
-public final class ResponseCacheTest {
-  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
-  @Rule public MockWebServer server = new MockWebServer();
-  @Rule public MockWebServer server2 = new MockWebServer();
-
-  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  private SslClient sslClient = SslClient.localhost();
-  private ResponseCache cache;
-  private CookieManager cookieManager;
-  private OkUrlFactory urlFactory;
-
-  @Before public void setUp() throws Exception {
-    server.setProtocolNegotiationEnabled(false);
-
-    cache = AndroidShimResponseCache.create(cacheRule.getRoot(), 10 * 1024 * 1024);
-    urlFactory = new OkUrlFactory(new OkHttpClient());
-    AndroidInternal.setResponseCache(urlFactory, cache);
-
-    cookieManager = new CookieManager();
-  }
-
-  @After public void tearDown() throws Exception {
-    ResponseCache.setDefault(null);
-  }
-
-  private HttpURLConnection openConnection(URL url) {
-    return urlFactory.open(url);
-  }
-
-  /**
-   * Test that response caching is consistent with the RI and the spec.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
-   */
-  @Test public void responseCachingByResponseCode() throws Exception {
-    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
-    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
-
-    // We can't test 100 because it's not really a response.
-    // assertCached(false, 100);
-    assertCached(false, 101);
-    assertCached(false, 102);
-    assertCached(true, 200);
-    assertCached(false, 201);
-    assertCached(false, 202);
-    assertCached(true, 203);
-    assertCached(true, 204);
-    assertCached(false, 205);
-    assertCached(false, 206); //Electing to not cache partial responses
-    assertCached(false, 207);
-    assertCached(true, 300);
-    assertCached(true, 301);
-    assertCached(true, 302);
-    assertCached(false, 303);
-    assertCached(false, 304);
-    assertCached(false, 305);
-    assertCached(false, 306);
-    assertCached(true, 307);
-    assertCached(true, 308);
-    assertCached(false, 400);
-    assertCached(false, 401);
-    assertCached(false, 402);
-    assertCached(false, 403);
-    assertCached(true, 404);
-    assertCached(true, 405);
-    assertCached(false, 406);
-    assertCached(false, 408);
-    assertCached(false, 409);
-    // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true, 410);
-    assertCached(false, 411);
-    assertCached(false, 412);
-    assertCached(false, 413);
-    assertCached(true, 414);
-    assertCached(false, 415);
-    assertCached(false, 416);
-    assertCached(false, 417);
-    assertCached(false, 418);
-
-    assertCached(false, 500);
-    assertCached(true, 501);
-    assertCached(false, 502);
-    assertCached(false, 503);
-    assertCached(false, 504);
-    assertCached(false, 505);
-    assertCached(false, 506);
-  }
-
-  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
-    int expectedResponseCode = responseCode;
-
-    server = new MockWebServer();
-    MockResponse mockResponse = new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(responseCode)
-        .setBody("ABCDE")
-        .addHeader("WWW-Authenticate: challenge");
-    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
-      mockResponse.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
-      mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
-        || responseCode == HttpURLConnection.HTTP_RESET) {
-      mockResponse.setBody(""); // We forbid bodies for 204 and 205.
-    }
-    server.enqueue(mockResponse);
-
-    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
-      // 408's are a bit of an outlier because we may repeat the request if we encounter this
-      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
-      // because of the retry. We just want to ensure the initial 408 isn't cached.
-      expectedResponseCode = 200;
-      server.enqueue(new MockResponse()
-          .setHeader("Cache-Control", "no-store")
-          .setBody("FGHIJ"));
-    }
-
-    server.start();
-
-    URL url = server.url("/").url();
-    HttpURLConnection connection = openConnection(url);
-    assertEquals(expectedResponseCode, connection.getResponseCode());
-
-    // Exhaust the content stream.
-    readAscii(connection);
-
-    CacheResponse cached = cache.get(url.toURI(), "GET", null);
-    if (shouldPut) {
-      assertNotNull(Integer.toString(responseCode), cached);
-    } else {
-      assertNull(Integer.toString(responseCode), cached);
-    }
-    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
-    testResponseCaching(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
-    testResponseCaching(TransferKind.CHUNKED);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
-    testResponseCaching(TransferKind.END_OF_STREAM);
-  }
-
-  /**
-   * HttpURLConnection.getInputStream().skip(long) causes ResponseCache corruption
-   * http://code.google.com/p/android/issues/detail?id=8175
-   */
-  private void testResponseCaching(TransferKind transferKind) throws IOException {
-    MockResponse mockResponse = new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setStatus("HTTP/1.1 200 Fantastic");
-    transferKind.setBody(mockResponse, "I love puppies but hate spiders", 1);
-    server.enqueue(mockResponse);
-
-    // Make sure that calling skip() doesn't omit bytes from the cache.
-    HttpURLConnection urlConnection = openConnection(server.url("/").url());
-    InputStream in = urlConnection.getInputStream();
-    assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
-    reliableSkip(in, "puppies but hate ".length());
-    assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
-    assertEquals(-1, in.read());
-    in.close();
-
-    urlConnection = openConnection(server.url("/").url()); // cached!
-    in = urlConnection.getInputStream();
-    assertEquals("I love puppies but hate spiders",
-        readAscii(urlConnection, "I love puppies but hate spiders".length()));
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-
-    assertEquals(-1, in.read());
-    in.close();
-  }
-
-  @Test public void secureResponseCaching() throws IOException {
-    assumeFalse(getPlatform().equals("jdk9"));
-
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-
-    HttpsURLConnection c1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    c1.setSSLSocketFactory(sslClient.socketFactory);
-    c1.setHostnameVerifier(hostnameVerifier);
-    assertEquals("ABC", readAscii(c1));
-
-    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    String suite = c1.getCipherSuite();
-    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
-    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
-    Principal peerPrincipal = c1.getPeerPrincipal();
-    Principal localPrincipal = c1.getLocalPrincipal();
-
-    HttpsURLConnection c2 = (HttpsURLConnection) openConnection(server.url("/").url()); // cached!
-    c2.setSSLSocketFactory(sslClient.socketFactory);
-    c2.setHostnameVerifier(hostnameVerifier);
-    assertEquals("ABC", readAscii(c2));
-
-    assertEquals(suite, c2.getCipherSuite());
-    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
-    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
-    assertEquals(peerPrincipal, c2.getPeerPrincipal());
-    assertEquals(localPrincipal, c2.getLocalPrincipal());
-  }
-
-  @Test public void responseCachingAndRedirects() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    assertEquals("ABC", readAscii(connection));
-
-    connection = openConnection(server.url("/").url()); // cached!
-    assertEquals("ABC", readAscii(connection));
-  }
-
-  @Test public void redirectToCachedResult() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    assertEquals("ABC", readAscii(openConnection(server.url("/foo").url())));
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
-    assertEquals(0, request1.getSequenceNumber());
-
-    assertEquals("ABC", readAscii(openConnection(server.url("/bar").url())));
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
-    assertEquals(1, request2.getSequenceNumber());
-
-    // an unrelated request should reuse the pooled connection
-    assertEquals("DEF", readAscii(openConnection(server.url("/baz").url())));
-    RecordedRequest request3 = server.takeRequest();
-    assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
-    assertEquals(2, request3.getSequenceNumber());
-  }
-
-  @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-
-    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    assertEquals("ABC", readAscii(connection1));
-    assertNotNull(connection1.getCipherSuite());
-
-    // Cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.url("/").url());
-    assertEquals("ABC", readAscii(connection2));
-    assertNotNull(connection2.getCipherSuite());
-
-    assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
-  }
-
-  /**
-   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
-   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
-   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
-   *
-   * https://github.com/square/okhttp/issues/214
-   */
-  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslClient.socketFactory, false);
-    server2.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server2.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: " + server2.url("/").url()));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-
-    HttpURLConnection connection1 = openConnection(server.url("/").url());
-    assertEquals("ABC", readAscii(connection1));
-
-    // Cached!
-    HttpURLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("ABC", readAscii(connection2));
-  }
-
-  @Test public void foundCachedWithExpiresHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(302, "Expires", formatDate(1, TimeUnit.HOURS));
-  }
-
-  @Test public void foundCachedWithCacheControlHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(302, "Cache-Control", "max-age=60");
-  }
-
-  @Test public void temporaryRedirectCachedWithExpiresHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(307, "Expires", formatDate(1, TimeUnit.HOURS));
-  }
-
-  @Test public void temporaryRedirectCachedWithCacheControlHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(307, "Cache-Control", "max-age=60");
-  }
-
-  @Test public void foundNotCachedWithoutCacheHeader() throws Exception {
-    temporaryRedirectNotCachedWithoutCachingHeader(302);
-  }
-
-  @Test public void temporaryRedirectNotCachedWithoutCacheHeader() throws Exception {
-    temporaryRedirectNotCachedWithoutCachingHeader(307);
-  }
-
-  private void temporaryRedirectCachedWithCachingHeader(
-      int responseCode, String headerName, String headerValue) throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader(headerName, headerValue)
-        .addHeader("Location", "/a"));
-    server.enqueue(new MockResponse()
-        .addHeader(headerName, headerValue)
-        .setBody("a"));
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-    server.enqueue(new MockResponse()
-        .setBody("c"));
-
-    URL url = server.url("/").url();
-    assertEquals("a", readAscii(openConnection(url)));
-    assertEquals("a", readAscii(openConnection(url)));
-  }
-
-  private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader("Location", "/a"));
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-
-    URL url = server.url("/").url();
-    assertEquals("a", readAscii(openConnection(url)));
-    assertEquals("b", readAscii(openConnection(url)));
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
-    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
-    testServerPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
-    // Intentionally empty. This case doesn't make sense because there's no
-    // such thing as a premature disconnect when the disconnect itself
-    // indicates the end of the data stream.
-  }
-
-  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
-    server.enqueue(truncateViolently(response, 16));
-    server.enqueue(new MockResponse()
-        .setBody("Request #2"));
-
-    BufferedReader reader = new BufferedReader(
-        new InputStreamReader(openConnection(server.url("/").url()).getInputStream()));
-    assertEquals("ABCDE", reader.readLine());
-    try {
-      reader.readLine();
-      fail("This implementation silently ignored a truncated HTTP body.");
-    } catch (IOException expected) {
-    } finally {
-      reader.close();
-    }
-
-    URLConnection connection = openConnection(server.url("/").url());
-    assertEquals("Request #2", readAscii(connection));
-  }
-
-  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
-    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
-    testClientPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
-    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
-  }
-
-  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
-    // Setting a low transfer speed ensures that stream discarding will time out.
-    MockResponse response = new MockResponse()
-        .throttleBody(6, 1, TimeUnit.SECONDS);
-    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(response);
-    server.enqueue(new MockResponse()
-        .setBody("Request #2"));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals("ABCDE", readAscii(connection, 5));
-    in.close();
-    try {
-      in.read();
-      fail("Expected an IOException because the stream is closed.");
-    } catch (IOException expected) {
-    }
-
-    connection = openConnection(server.url("/").url());
-    assertEquals("Request #2", readAscii(connection));
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
-    //      last modified: 105 seconds ago
-    //             served:   5 seconds ago
-    //   default lifetime: (105 - 5) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds from now
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-        .setBody("A"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
-    assertEquals("A", readAscii(connection));
-    assertNull(connection.getHeaderField("Warning"));
-  }
-
-  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
-    //      last modified: 115 seconds ago
-    //             served:  15 seconds ago
-    //   default lifetime: (115 - 15) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds ago
-    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
-    //      last modified: 105 days ago
-    //             served:   5 days ago
-    //   default lifetime: (105 - 5) / 10 = 10 days
-    //            expires:  10 days from served date = 5 days from now
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
-        .setBody("A"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    URLConnection connection = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection));
-    assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
-        connection.getHeaderField("Warning"));
-  }
-
-  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/?foo=bar").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
-  }
-
-  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void expirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Cache-Control: max-age=60"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
-    // Chrome interprets max-age relative to the local clock. Both our cache
-    // and Firefox both use the earlier of the local and server's clock.
-    assertNotCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=60")
-        .addHeader("Cache-Control: max-age=180"));
-  }
-
-  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=180")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void requestMethodOptionsIsNotCached() throws Exception {
-    testRequestMethod("OPTIONS", false);
-  }
-
-  @Test public void requestMethodGetIsCached() throws Exception {
-    testRequestMethod("GET", true);
-  }
-
-  @Test public void requestMethodHeadIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("HEAD", false);
-  }
-
-  @Test public void requestMethodPostIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("POST", false);
-  }
-
-  @Test public void requestMethodPutIsNotCached() throws Exception {
-    testRequestMethod("PUT", false);
-  }
-
-  @Test public void requestMethodDeleteIsNotCached() throws Exception {
-    testRequestMethod("DELETE", false);
-  }
-
-  @Test public void requestMethodTraceIsNotCached() throws Exception {
-    testRequestMethod("TRACE", false);
-  }
-
-  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
-    // 1. seed the cache (potentially)
-    // 2. expect a cache hit or miss
-    server.enqueue(new MockResponse()
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("X-Response-ID: 1"));
-    server.enqueue(new MockResponse()
-        .addHeader("X-Response-ID: 2"));
-
-    URL url = server.url("/").url();
-
-    HttpURLConnection request1 = openConnection(url);
-    request1.setRequestMethod(requestMethod);
-    addRequestBodyIfNecessary(requestMethod, request1);
-    request1.getInputStream().close();
-    assertEquals("1", request1.getHeaderField("X-Response-ID"));
-
-    URLConnection request2 = openConnection(url);
-    request2.getInputStream().close();
-    if (expectCached) {
-      assertEquals("1", request2.getHeaderField("X-Response-ID"));
-    } else {
-      assertEquals("2", request2.getHeaderField("X-Response-ID"));
-    }
-  }
-
-  private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection connection)
-      throws IOException {
-    if (requestMethod.equals("POST") || requestMethod.equals("PUT")) {
-      connection.setDoOutput(true);
-      OutputStream requestBody = connection.getOutputStream();
-      requestBody.write('x');
-      requestBody.close();
-    }
-  }
-
-  @Test public void postInvalidatesCache() throws Exception {
-    testMethodInvalidates("POST");
-  }
-
-  @Test public void putInvalidatesCache() throws Exception {
-    testMethodInvalidates("PUT");
-  }
-
-  @Test public void deleteMethodInvalidatesCache() throws Exception {
-    testMethodInvalidates("DELETE");
-  }
-
-  private void testMethodInvalidates(String requestMethod) throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it
-    // 3. expect a cache miss
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    URL url = server.url("/").url();
-
-    assertEquals("A", readAscii(openConnection(url)));
-
-    HttpURLConnection invalidateConnection = openConnection(url);
-    invalidateConnection.setRequestMethod(requestMethod);
-    assertEquals("B", readAscii(invalidateConnection));
-
-    assertEquals("C", readAscii(openConnection(url)));
-  }
-
-  /**
-   * Equivalent to {@code CacheTest.postInvalidatesCacheWithUncacheableResponse()} but demonstrating
-   * that {@link ResponseCache} provides no mechanism for cache invalidation as the result of
-   * locally-made requests. In reality invalidation could take place from other clients at any
-   * time.
-   */
-  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it with uncacheable response
-    // 3. the cache to return the original value
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .setResponseCode(500));
-
-    URL url = server.url("/").url();
-
-    assertEquals("A", readAscii(openConnection(url)));
-
-    HttpURLConnection invalidate = openConnection(url);
-    invalidate.setRequestMethod("POST");
-    addRequestBodyIfNecessary("POST", invalidate);
-    assertEquals("B", readAscii(invalidate));
-
-    assertEquals("A", readAscii(openConnection(url)));
-  }
-
-  @Test public void etag() throws Exception {
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("ETag: v1"));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-  }
-
-  /** If both If-Modified-Since and If-None-Match conditions apply, send only If-None-Match. */
-  @Test public void etagAndExpirationDateInThePast() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void cacheControlNoCache() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Cache-Control: no-cache"));
-  }
-
-  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void pragmaNoCache() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Pragma: no-cache"));
-  }
-
-  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Pragma: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void cacheControlNoStore() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
-    // 1. request a range
-    // 2. request a full document, expecting a cache miss
-    server.enqueue(new MockResponse()
-        .setBody("AA")
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 1000-1001/2000"));
-    server.enqueue(new MockResponse()
-        .setBody("BB"));
-
-    URL url = server.url("/").url();
-
-    HttpURLConnection range = openConnection(url);
-    range.addRequestProperty("Range", "bytes=1000-1001");
-    assertEquals("AA", readAscii(range));
-
-    assertEquals("BB", readAscii(openConnection(url)));
-  }
-
-  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
-
-    URL url = server.url("/").url();
-
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
-  }
-
-  @Test public void clientSideNoStore() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("B"));
-
-    HttpURLConnection connection1 = openConnection(server.url("/").url());
-    connection1.setRequestProperty("Cache-Control", "no-store");
-    assertEquals("A", readAscii(connection1));
-
-    HttpURLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("B", readAscii(connection2));
-  }
-
-  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
-    assertNonIdentityEncodingCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
-    assertNonIdentityEncodingCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
-    server.enqueue(response
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // At least three request/response pairs are required because after the first request is cached
-    // a different execution path might be taken. Thus modifications to the cache applied during
-    // the second request might not be visible until another request is performed.
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void notModifiedSpecifiesEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setBody("DEFDEFDEF"));
-
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-    assertEquals("DEFDEFDEF", readAscii(openConnection(server.url("/").url())));
-  }
-
-  /** https://github.com/square/okhttp/issues/947 */
-  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Vary: Accept-Encoding")
-        .addHeader("Cache-Control: max-age=60"));
-    server.enqueue(new MockResponse()
-        .setBody("FAIL"));
-
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void expiresDateBeforeModifiedDate() throws Exception {
-    assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
-  }
-
-  @Test public void requestMaxAge() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "max-age=30");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestMinFresh() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "min-fresh=120");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestMaxStale() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "max-stale=180");
-    assertEquals("A", readAscii(connection));
-    assertEquals("110 HttpURLConnection \"Response is stale\"",
-        connection.getHeaderField("Warning"));
-  }
-
-  @Test public void requestMaxStaleDirectiveWithNoValue() throws IOException {
-    // Add a stale response to the cache.
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    // With max-stale, we'll return that stale response.
-    URLConnection maxStaleConnection = openConnection(server.url("/").url());
-    maxStaleConnection.setRequestProperty("Cache-Control", "max-stale");
-    assertEquals("A", readAscii(maxStaleConnection));
-    assertEquals("110 HttpURLConnection \"Response is stale\"",
-        maxStaleConnection.getHeaderField("Warning"));
-  }
-
-  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120, must-revalidate")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "max-stale=180");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
-    // (no responses enqueued)
-
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-  }
-
-  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-  }
-
-  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-  }
-
-  @Test public void requestCacheControlNoCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
-    connection.setRequestProperty("Cache-Control", "no-cache");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestPragmaNoCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
-    connection.setRequestProperty("Pragma", "no-cache");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
-    MockResponse response = new MockResponse()
-        .addHeader("ETag: v3")
-        .addHeader("Cache-Control: max-age=0");
-    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
-    RecordedRequest request =
-        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
-    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
-    assertNull(request.getHeader("If-None-Match"));
-  }
-
-  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
-    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
-    MockResponse response = new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: max-age=0");
-    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
-    assertEquals("v1", request.getHeader("If-None-Match"));
-    assertNull(request.getHeader("If-Modified-Since"));
-  }
-
-  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
-      String conditionValue) throws Exception {
-    server.enqueue(seed.setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-
-    HttpURLConnection connection = openConnection(url);
-    connection.addRequestProperty(conditionName, conditionValue);
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
-    assertEquals("", readAscii(connection));
-
-    server.takeRequest(); // seed
-    return server.takeRequest();
-  }
-
-  /**
-   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
-   * served.
-   */
-  @Test public void retainServedDateFormat() throws Exception {
-    // Serve a response with a non-standard date format that OkHttp supports.
-    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
-    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
-    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
-    String lastModifiedString = dateFormat.format(lastModifiedDate);
-    String servedString = dateFormat.format(servedDate);
-
-    // This response should be conditionally cached.
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedString)
-        .addHeader("Expires: " + servedString)
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    // The first request has no conditions.
-    RecordedRequest request1 = server.takeRequest();
-    assertNull(request1.getHeader("If-Modified-Since"));
-
-    // The 2nd request uses the server's date format.
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
-    connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
-    assertEquals("", readAscii(connection));
-  }
-
-  @Test public void authorizationRequestFullyCached() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection connection = openConnection(url);
-    connection.addRequestProperty("Authorization", "password");
-    assertEquals("A", readAscii(connection));
-    assertEquals("A", readAscii(openConnection(url)));
-  }
-
-  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Content-Location: /bar")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/foo").url())));
-    assertEquals("B", readAscii(openConnection(server.url("/bar").url())));
-  }
-
-  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/a").url())));
-    assertEquals("A", readAscii(openConnection(server.url("/a").url())));
-    assertEquals("B", readAscii(openConnection(server.url("/b").url())));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frenchConnection = openConnection(url);
-    frenchConnection.setRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(frenchConnection));
-
-    HttpURLConnection englishConnection = openConnection(url);
-    englishConnection.setRequestProperty("Accept-Language", "en-US");
-    assertEquals("B", readAscii(englishConnection));
-  }
-
-  @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frenchConnection1 = openConnection(url);
-    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(frenchConnection1));
-
-    HttpURLConnection frenchConnection2 = openConnection(url);
-    frenchConnection2.setRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(frenchConnection2));
-  }
-
-  @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    HttpURLConnection connection2 = openConnection(server.url("/").url());
-    connection2.setRequestProperty("Foo", "bar");
-    assertEquals("B", readAscii(connection2));
-  }
-
-  @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpURLConnection connection1 = openConnection(server.url("/").url());
-    connection1.setRequestProperty("Foo", "bar");
-    assertEquals("A", readAscii(connection1));
-    assertEquals("B", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void varyFieldsAreCaseInsensitive() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: ACCEPT-LANGUAGE")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frenchConnection1 = openConnection(url);
-    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(frenchConnection1));
-    HttpURLConnection frenchConnection2 = openConnection(url);
-    frenchConnection2.setRequestProperty("accept-language", "fr-CA");
-    assertEquals("A", readAscii(frenchConnection2));
-  }
-
-  @Test public void varyMultipleFieldsWithMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frenchConnection1 = openConnection(url);
-    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
-    frenchConnection1.setRequestProperty("Accept-Charset", "UTF-8");
-    frenchConnection1.setRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(frenchConnection1));
-    HttpURLConnection frenchConnection2 = openConnection(url);
-    frenchConnection2.setRequestProperty("Accept-Language", "fr-CA");
-    frenchConnection2.setRequestProperty("Accept-Charset", "UTF-8");
-    frenchConnection2.setRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(frenchConnection2));
-  }
-
-  @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frenchConnection = openConnection(url);
-    frenchConnection.setRequestProperty("Accept-Language", "fr-CA");
-    frenchConnection.setRequestProperty("Accept-Charset", "UTF-8");
-    frenchConnection.setRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(frenchConnection));
-    HttpURLConnection englishConnection = openConnection(url);
-    englishConnection.setRequestProperty("Accept-Language", "en-CA");
-    englishConnection.setRequestProperty("Accept-Charset", "UTF-8");
-    englishConnection.setRequestProperty("Accept-Encoding", "identity");
-    assertEquals("B", readAscii(englishConnection));
-  }
-
-  @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection multiConnection1 = openConnection(url);
-    multiConnection1.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    multiConnection1.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(multiConnection1));
-
-    HttpURLConnection multiConnection2 = openConnection(url);
-    multiConnection2.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    multiConnection2.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(multiConnection2));
-  }
-
-  @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection multiConnection = openConnection(url);
-    multiConnection.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    multiConnection.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(multiConnection));
-
-    HttpURLConnection notFrenchConnection = openConnection(url);
-    notFrenchConnection.setRequestProperty("Accept-Language", "fr-CA");
-    notFrenchConnection.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("B", readAscii(notFrenchConnection));
-  }
-
-  @Test public void varyAsterisk() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: *")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    assertEquals("B", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void varyAndHttps() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-
-    URL url = server.url("/").url();
-    HttpURLConnection connection1 = openConnection(url);
-    connection1.setRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection1));
-
-    HttpURLConnection connection2 = openConnection(url);
-    connection2.setRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Allow: GET, HEAD")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Allow: GET, HEAD, PUT")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
-
-    URLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
-  }
-
-  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Transfer-Encoding: identity")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Transfer-Encoding: none")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
-
-    URLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
-  }
-
-  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Warning: 199 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("199 test danger", connection1.getHeaderField("Warning"));
-
-    URLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals(null, connection2.getHeaderField("Warning"));
-  }
-
-  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Warning: 299 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("299 test danger", connection1.getHeaderField("Warning"));
-
-    URLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("299 test danger", connection2.getHeaderField("Warning"));
-  }
-
-  public void assertCookies(URL url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<>();
-    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
-      actualCookies.add(cookie.toString());
-    }
-    assertEquals(Arrays.asList(expectedCookies), actualCookies);
-  }
-
-  @Test public void doNotCachePartialResponse() throws Exception {
-    assertNotCached(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 100-100/200")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  /**
-   * Equivalent to {@code CacheTest.conditionalHitUpdatesCache()}, except a Java standard cache has
-   * no means to update the headers for an existing entry so the behavior is different.
-   */
-  @Test public void conditionalHitDoesNotUpdateCache() throws Exception {
-    // A response that is cacheable, but with a short life.
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    // A response that refers to the previous response, but is cacheable with a long life.
-    // Contains a header we can recognize as having come from the server.
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Allow: GET, HEAD")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    // A response that is cacheable with a long life.
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .addHeader("Cache-Control: max-age=30"));
-    // A response that should never be requested.
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    // cache miss; seed the cache with an entry that will require a network hit to be sure it is
-    // still valid
-    HttpURLConnection connection1 = openConnection(server.url("/a").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals(null, connection1.getHeaderField("Allow"));
-
-    // conditional cache hit; The cached data should be returned, but the cache is not updated.
-    HttpURLConnection connection2 = openConnection(server.url("/a").url());
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
-
-    // conditional cache hit; The server responds with new data. The cache is updated.
-    HttpURLConnection connection3 = openConnection(server.url("/a").url());
-    assertEquals("B", readAscii(connection3));
-
-    // full cache hit; The data from connection3 has now replaced that from connection 1.
-    HttpURLConnection connection4 = openConnection(server.url("/a").url());
-    assertEquals("B", readAscii(connection4));
-
-    assertEquals(3, server.getRequestCount());
-  }
-
-  @Test public void responseSourceHeaderCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=0")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(304));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
-    Headers.Builder headers = new Headers.Builder()
-        .add("Cache-Control: max-age=120");
-    Internal.instance.addLenient(headers, ": A");
-    server.enqueue(new MockResponse()
-        .setHeaders(headers.build())
-        .setBody("body"));
-
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    assertEquals("A", connection.getHeaderField(""));
-  }
-
-  /**
-   * @param delta the offset from the current date to use. Negative values yield dates in the past;
-   * positive values yield dates in the future.
-   */
-  private String formatDate(long delta, TimeUnit timeUnit) {
-    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private String formatDate(Date date) {
-    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
-    return rfc1123.format(date);
-  }
-
-  private void assertNotCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
-  }
-
-  /** @return the request with the conditional get headers. */
-  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
-    // scenario 1: condition succeeds
-    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // scenario 2: condition fails
-    server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
-
-    URL valid = server.url("/valid").url();
-    HttpURLConnection connection1 = openConnection(valid);
-    assertEquals("A", readAscii(connection1));
-    assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
-    assertEquals("A-OK", connection1.getResponseMessage());
-    HttpURLConnection connection2 = openConnection(valid);
-    assertEquals("A", readAscii(connection2));
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertEquals("A-OK", connection2.getResponseMessage());
-
-    URL invalid = server.url("/invalid").url();
-    HttpURLConnection connection3 = openConnection(invalid);
-    assertEquals("B", readAscii(connection3));
-    assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
-    assertEquals("B-OK", connection3.getResponseMessage());
-    HttpURLConnection connection4 = openConnection(invalid);
-    assertEquals("C", readAscii(connection4));
-    assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
-    assertEquals("C-OK", connection4.getResponseMessage());
-
-    server.takeRequest(); // regular get
-    return server.takeRequest(); // conditional get
-  }
-
-  private void assertFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(response.setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("A", readAscii(openConnection(url)));
-  }
-
-  /**
-   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
-   * how clients respond to the premature conclusion of the HTTP body.
-   */
-  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
-    response.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
-    Headers headers = response.getHeaders();
-    Buffer truncatedBody = new Buffer();
-    truncatedBody.write(response.getBody(), numBytesToKeep);
-    response.setBody(truncatedBody);
-    response.setHeaders(headers);
-    return response;
-  }
-
-  enum TransferKind {
-    CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
-        response.setChunkedBody(content, chunkSize);
-      }
-    },
-    FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-      }
-    },
-    END_OF_STREAM() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
-        response.removeHeader("Content-Length");
-      }
-    };
-
-    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, new Buffer().writeUtf8(content), chunkSize);
-    }
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(result));
-    sink.writeUtf8(data);
-    sink.close();
-    return result;
-  }
-
-  /**
-   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
-   * characters can be read, the remaining characters are returned and the stream is closed.
-   */
-  private String readAscii(URLConnection connection, int count) throws IOException {
-    HttpURLConnection httpConnection = (HttpURLConnection) connection;
-    InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
-        ? connection.getInputStream() : httpConnection.getErrorStream();
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  private String readAscii(URLConnection connection) throws IOException {
-    return readAscii(connection, Integer.MAX_VALUE);
-  }
-
-  private void reliableSkip(InputStream in, int length) throws IOException {
-    while (length > 0) {
-      length -= in.skip(length);
-    }
-  }
-
-  private void assertGatewayTimeout(HttpURLConnection connection) throws IOException {
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (FileNotFoundException expected) {
-    }
-    assertEquals(504, connection.getResponseCode());
-    assertEquals(-1, connection.getErrorStream().read());
-  }
-
-  private static <T> List<T> toListOrNull(T[] arrayOrNull) {
-    return arrayOrNull != null ? Arrays.asList(arrayOrNull) : null;
-  }
-
-  // Android-added tests.
-
-  /**
-   * Test that we can interrogate the response when the cache is being populated.
-   * http://code.google.com/p/android/issues/detail?id=7787
-   */
-  @Test public void responseCacheCallbackApis() throws Exception {
-    final String body = "ABCDE";
-    final AtomicInteger cacheCount = new AtomicInteger();
-
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 200 Fantastic")
-        .addHeader("Content-Type: text/plain")
-        .addHeader("fgh: ijk")
-        .setBody(body));
-
-    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        HttpURLConnection httpURLConnection = (HttpURLConnection) connection;
-        assertEquals(server.url("/").url(), uri.toURL());
-        assertEquals(200, httpURLConnection.getResponseCode());
-        InputStream is = httpURLConnection.getInputStream();
-        try {
-          is.read();
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        assertEquals("5", connection.getHeaderField("Content-Length"));
-        assertEquals("text/plain", connection.getHeaderField("Content-Type"));
-        assertEquals("ijk", connection.getHeaderField("fgh"));
-        cacheCount.incrementAndGet();
-        return null;
-      }
-    }));
-
-    URL url = server.url("/").url();
-    HttpURLConnection connection = openConnection(url);
-    assertEquals(body, readAscii(connection));
-    assertEquals(1, cacheCount.get());
-  }
-
-  /** Don't explode if the cache returns a null body. http://b/3373699 */
-  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
-    final AtomicBoolean aborted = new AtomicBoolean();
-    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) {
-        return new CacheRequest() {
-          @Override public void abort() {
-            aborted.set(true);
-          }
-
-          @Override public OutputStream getBody() throws IOException {
-            return null;
-          }
-        };
-      }
-    }));
-
-    server.enqueue(new MockResponse().setBody("abcdef"));
-
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    assertEquals("abc", readAscii(connection, 3));
-    connection.getInputStream().close();
-    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
-  }
-
-  /**
-   * Fail if a badly-behaved cache returns a null status line header.
-   * https://code.google.com/p/android/issues/detail?id=160522
-   */
-  @Test public void responseCacheReturnsNullStatusLine() throws Exception {
-    String cachedContentString = "Hello";
-    final byte[] cachedContent = cachedContentString.getBytes(StandardCharsets.US_ASCII);
-
-    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
-      @Override
-      public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders)
-          throws IOException {
-        return new CacheResponse() {
-          @Override public Map<String, List<String>> getHeaders() throws IOException {
-            String contentType = "text/plain";
-            Map<String, List<String>> headers = new LinkedHashMap<>();
-            headers.put("Content-Length", Arrays.asList(Integer.toString(cachedContent.length)));
-            headers.put("Content-Type", Arrays.asList(contentType));
-            headers.put("Expires", Arrays.asList(formatDate(-1, TimeUnit.HOURS)));
-            headers.put("Cache-Control", Arrays.asList("max-age=60"));
-            // Crucially, the header with a null key is missing, which renders the cache response
-            // unusable because OkHttp only caches responses with cacheable response codes.
-            return headers;
-          }
-
-          @Override public InputStream getBody() throws IOException {
-            return new ByteArrayInputStream(cachedContent);
-          }
-        };
-      }
-    }));
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    // If there was no status line from the cache an exception will be thrown. No network request
-    // should be made.
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  private static class InsecureResponseCache extends ResponseCache {
-
-    private final ResponseCache delegate;
-
-    private InsecureResponseCache(ResponseCache delegate) {
-      this.delegate = delegate;
-    }
-
-    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-      return delegate.put(uri, connection);
-    }
-
-    @Override public CacheResponse get(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) throws IOException {
-      final CacheResponse response = delegate.get(uri, requestMethod, requestHeaders);
-      if (response instanceof SecureCacheResponse) {
-        return new CacheResponse() {
-          @Override public InputStream getBody() throws IOException {
-            return response.getBody();
-          }
-
-          @Override public Map<String, List<String>> getHeaders() throws IOException {
-            return response.getHeaders();
-          }
-        };
-      }
-      return response;
-    }
-  }
-
-  @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
-    assumeFalse(getPlatform().equals("jdk9"));
-
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-
-    AndroidInternal.setResponseCache(urlFactory, new InsecureResponseCache(cache));
-
-    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    connection1.setSSLSocketFactory(sslClient.socketFactory);
-    connection1.setHostnameVerifier(hostnameVerifier);
-    assertEquals("ABC", readAscii(connection1));
-
-    // Not cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.url("/").url());
-    connection2.setSSLSocketFactory(sslClient.socketFactory);
-    connection2.setHostnameVerifier(hostnameVerifier);
-    assertEquals("DEF", readAscii(connection2));
-  }
-
-  @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    final AtomicReference<Map<String, List<String>>> requestHeadersRef = new AtomicReference<>();
-    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        requestHeadersRef.set(requestHeaders);
-        return null;
-      }
-    }));
-
-    URL url = server.url("/").url();
-    URLConnection urlConnection = openConnection(url);
-    urlConnection.addRequestProperty("A", "android");
-    readAscii(urlConnection);
-    assertEquals(Arrays.asList("android"), requestHeadersRef.get().get("A"));
-  }
-
-  @Test public void responseCachingWithoutBody() throws IOException {
-    MockResponse response =
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .setStatus("HTTP/1.1 200 Fantastic");
-    server.enqueue(response);
-
-    HttpURLConnection urlConnection = openConnection(server.url("/").url());
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-    assertTrue(urlConnection.getDoInput());
-    InputStream is = urlConnection.getInputStream();
-    assertEquals(-1, is.read());
-    is.close();
-
-    urlConnection = openConnection(server.url("/").url()); // cached!
-    assertTrue(urlConnection.getDoInput());
-    InputStream cachedIs = urlConnection.getInputStream();
-    assertEquals(-1, cachedIs.read());
-    cachedIs.close();
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-  }
-
-  @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.setUseCaches(false);
-    assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.setUseCaches(false);
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
-    URL url = new URL("http://localhost/");
-    URLConnection c1 = openConnection(url);
-    URLConnection c2 = openConnection(url);
-    assertTrue(c1.getDefaultUseCaches());
-    c1.setDefaultUseCaches(false);
-    try {
-      assertTrue(c1.getUseCaches());
-      assertTrue(c2.getUseCaches());
-      URLConnection c3 = openConnection(url);
-      assertFalse(c3.getUseCaches());
-    } finally {
-      c1.setDefaultUseCaches(true);
-    }
-  }
-
-  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
-  // default ResponseCache. We try to keep this case working as much as possible because apps break
-  // if we don't.
-  @Test public void otherStacks_cacheHitWithoutVary() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("FAIL"));
-
-    // Set the cache as the shared cache.
-    ResponseCache.setDefault(cache);
-
-    // Use the platform's HTTP stack.
-    URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof OkHttpURLConnection);
-    assertEquals("A", readAscii(connection));
-
-    URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof OkHttpURLConnection);
-    assertEquals("A", readAscii(connection2));
-  }
-
-  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
-  // default ResponseCache. We can't keep the Vary case working because we can't get to the Vary
-  // request headers after connect(). Accept-Encoding has special behavior so we test it explicitly.
-  @Test public void otherStacks_cacheMissWithVaryAcceptEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    // Set the cache as the shared cache.
-    ResponseCache.setDefault(cache);
-
-    // Use the platform's HTTP stack.
-    URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof OkHttpURLConnection);
-    assertEquals("A", readAscii(connection));
-
-    URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof OkHttpURLConnection);
-    assertEquals("B", readAscii(connection2));
-  }
-
-  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
-  // default ResponseCache. We can't keep the Vary case working because we can't get to the Vary
-  // request headers after connect().
-  @Test public void otherStacks_cacheMissWithVary() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    // Set the cache as the shared cache.
-    ResponseCache.setDefault(cache);
-
-    // Use the platform's HTTP stack.
-    URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof OkHttpURLConnection);
-    connection.setRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection));
-
-    URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof OkHttpURLConnection);
-    assertEquals("B", readAscii(connection2));
-  }
-
-  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
-  // default ResponseCache. We can't keep the Vary case working, because we can't get to the Vary
-  // request headers after connect().
-  @Test public void otherStacks_cacheMissWithVaryAsterisk() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: *")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    // Set the cache as the shared cache.
-    ResponseCache.setDefault(cache);
-
-    // Use the platform's HTTP stack.
-    URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof OkHttpURLConnection);
-    assertEquals("A", readAscii(connection));
-
-    URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof OkHttpURLConnection);
-    assertEquals("B", readAscii(connection2));
-  }
-
-  private void setInternalCache(InternalCache internalCache) {
-    OkHttpClient.Builder builder = urlFactory.client().newBuilder();
-    Internal.instance.setCache(builder, internalCache);
-    urlFactory.setClient(builder.build());
-  }
-
-  private String getPlatform() {
-    return System.getProperty("okhttp.platform", "platform");
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
deleted file mode 100644
index 8f6bbbd628..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ /dev/null
@@ -1,2514 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.CookieManager;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.NoSuchElementException;
-import java.util.TimeZone;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
-import okhttp3.internal.Internal;
-import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.internal.platform.Platform;
-import okhttp3.internal.tls.SslClient;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class CacheTest {
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    @Override public boolean verify(String s, SSLSession sslSession) {
-      return true;
-    }
-  };
-
-  @Rule public MockWebServer server = new MockWebServer();
-  @Rule public MockWebServer server2 = new MockWebServer();
-  @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
-
-  private final SslClient sslClient = SslClient.localhost();
-  private OkHttpClient client;
-  private Cache cache;
-  private final CookieManager cookieManager = new CookieManager();
-
-  @Before public void setUp() throws Exception {
-    server.setProtocolNegotiationEnabled(false);
-    cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-    client = defaultClient().newBuilder()
-        .cache(cache)
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-  }
-
-  @After public void tearDown() throws Exception {
-    ResponseCache.setDefault(null);
-    cache.delete();
-  }
-
-  /**
-   * Test that response caching is consistent with the RI and the spec.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
-   */
-  @Test public void responseCachingByResponseCode() throws Exception {
-    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
-    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
-
-    // We can't test 100 because it's not really a response.
-    // assertCached(false, 100);
-    assertCached(false, 101);
-    assertCached(false, 102);
-    assertCached(true, 200);
-    assertCached(false, 201);
-    assertCached(false, 202);
-    assertCached(true, 203);
-    assertCached(true, 204);
-    assertCached(false, 205);
-    assertCached(false, 206); //Electing to not cache partial responses
-    assertCached(false, 207);
-    assertCached(true, 300);
-    assertCached(true, 301);
-    assertCached(true, 302);
-    assertCached(false, 303);
-    assertCached(false, 304);
-    assertCached(false, 305);
-    assertCached(false, 306);
-    assertCached(true, 307);
-    assertCached(true, 308);
-    assertCached(false, 400);
-    assertCached(false, 401);
-    assertCached(false, 402);
-    assertCached(false, 403);
-    assertCached(true, 404);
-    assertCached(true, 405);
-    assertCached(false, 406);
-    assertCached(false, 408);
-    assertCached(false, 409);
-    // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true, 410);
-    assertCached(false, 411);
-    assertCached(false, 412);
-    assertCached(false, 413);
-    assertCached(true, 414);
-    assertCached(false, 415);
-    assertCached(false, 416);
-    assertCached(false, 417);
-    assertCached(false, 418);
-
-    assertCached(false, 500);
-    assertCached(true, 501);
-    assertCached(false, 502);
-    assertCached(false, 503);
-    assertCached(false, 504);
-    assertCached(false, 505);
-    assertCached(false, 506);
-  }
-
-  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
-    int expectedResponseCode = responseCode;
-
-    server = new MockWebServer();
-    MockResponse mockResponse = new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(responseCode)
-        .setBody("ABCDE")
-        .addHeader("WWW-Authenticate: challenge");
-    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
-      mockResponse.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
-      mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
-        || responseCode == HttpURLConnection.HTTP_RESET) {
-      mockResponse.setBody(""); // We forbid bodies for 204 and 205.
-    }
-    server.enqueue(mockResponse);
-
-    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
-      // 408's are a bit of an outlier because we may repeat the request if we encounter this
-      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
-      // because of the retry. We just want to ensure the initial 408 isn't cached.
-      expectedResponseCode = 200;
-      server.enqueue(new MockResponse()
-          .setHeader("Cache-Control", "no-store")
-          .setBody("FGHIJ"));
-    }
-
-    server.start();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals(expectedResponseCode, response.code());
-
-    // Exhaust the content stream.
-    response.body().string();
-
-    Response cached = cache.get(request);
-    if (shouldPut) {
-      assertNotNull(Integer.toString(responseCode), cached);
-      cached.body().close();
-    } else {
-      assertNull(Integer.toString(responseCode), cached);
-    }
-    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
-    testResponseCaching(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
-    testResponseCaching(TransferKind.CHUNKED);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
-    testResponseCaching(TransferKind.END_OF_STREAM);
-  }
-
-  /**
-   * Skipping bytes in the input stream caused ResponseCache corruption.
-   * http://code.google.com/p/android/issues/detail?id=8175
-   */
-  private void testResponseCaching(TransferKind transferKind) throws IOException {
-    MockResponse mockResponse = new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setStatus("HTTP/1.1 200 Fantastic");
-    transferKind.setBody(mockResponse, "I love puppies but hate spiders", 1);
-    server.enqueue(mockResponse);
-
-    // Make sure that calling skip() doesn't omit bytes from the cache.
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request).execute();
-
-    BufferedSource in1 = response1.body().source();
-    assertEquals("I love ", in1.readUtf8("I love ".length()));
-    in1.skip("puppies but hate ".length());
-    assertEquals("spiders", in1.readUtf8("spiders".length()));
-    assertTrue(in1.exhausted());
-    in1.close();
-    assertEquals(1, cache.writeSuccessCount());
-    assertEquals(0, cache.writeAbortCount());
-
-    Response response2 = client.newCall(request).execute();
-    BufferedSource in2 = response2.body().source();
-    assertEquals("I love puppies but hate spiders",
-        in2.readUtf8("I love puppies but hate spiders".length()));
-    assertEquals(200, response2.code());
-    assertEquals("Fantastic", response2.message());
-
-    assertTrue(in2.exhausted());
-    in2.close();
-    assertEquals(1, cache.writeSuccessCount());
-    assertEquals(0, cache.writeAbortCount());
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.hitCount());
-  }
-
-  @Test public void secureResponseCaching() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request).execute();
-    BufferedSource in = response1.body().source();
-    assertEquals("ABC", in.readUtf8());
-
-    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    CipherSuite cipherSuite = response1.handshake().cipherSuite();
-    List<Certificate> localCerts = response1.handshake().localCertificates();
-    List<Certificate> serverCerts = response1.handshake().peerCertificates();
-    Principal peerPrincipal = response1.handshake().peerPrincipal();
-    Principal localPrincipal = response1.handshake().localPrincipal();
-
-    Response response2 = client.newCall(request).execute(); // Cached!
-    assertEquals("ABC", response2.body().string());
-
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(1, cache.hitCount());
-
-    assertEquals(cipherSuite, response2.handshake().cipherSuite());
-    assertEquals(localCerts, response2.handshake().localCertificates());
-    assertEquals(serverCerts, response2.handshake().peerCertificates());
-    assertEquals(peerPrincipal, response2.handshake().peerPrincipal());
-    assertEquals(localPrincipal, response2.handshake().localPrincipal());
-  }
-
-  @Test public void responseCachingAndRedirects() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request).execute();
-    assertEquals("ABC", response1.body().string());
-
-    Response response2 = client.newCall(request).execute(); // Cached!
-    assertEquals("ABC", response2.body().string());
-
-    assertEquals(4, cache.requestCount()); // 2 requests + 2 redirects
-    assertEquals(2, cache.networkCount());
-    assertEquals(2, cache.hitCount());
-  }
-
-  @Test public void redirectToCachedResult() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    Request request1 = new Request.Builder().url(server.url("/foo")).build();
-    Response response1 = client.newCall(request1).execute();
-    assertEquals("ABC", response1.body().string());
-    RecordedRequest recordedRequest1 = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", recordedRequest1.getRequestLine());
-    assertEquals(0, recordedRequest1.getSequenceNumber());
-
-    Request request2 = new Request.Builder().url(server.url("/bar")).build();
-    Response response2 = client.newCall(request2).execute();
-    assertEquals("ABC", response2.body().string());
-    RecordedRequest recordedRequest2 = server.takeRequest();
-    assertEquals("GET /bar HTTP/1.1", recordedRequest2.getRequestLine());
-    assertEquals(1, recordedRequest2.getSequenceNumber());
-
-    // an unrelated request should reuse the pooled connection
-    Request request3 = new Request.Builder().url(server.url("/baz")).build();
-    Response response3 = client.newCall(request3).execute();
-    assertEquals("DEF", response3.body().string());
-    RecordedRequest recordedRequest3 = server.takeRequest();
-    assertEquals("GET /baz HTTP/1.1", recordedRequest3.getRequestLine());
-    assertEquals(2, recordedRequest3.getSequenceNumber());
-  }
-
-  @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
-        .build();
-
-    Response response1 = get(server.url("/"));
-    assertEquals("ABC", response1.body().string());
-    assertNotNull(response1.handshake().cipherSuite());
-
-    // Cached!
-    Response response2 = get(server.url("/"));
-    assertEquals("ABC", response2.body().string());
-    assertNotNull(response2.handshake().cipherSuite());
-
-    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.hitCount());
-    assertEquals(response1.handshake().cipherSuite(), response2.handshake().cipherSuite());
-  }
-
-  /**
-   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
-   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
-   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
-   *
-   * https://github.com/square/okhttp/issues/214
-   */
-  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslClient.socketFactory, false);
-    server2.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server2.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: " + server2.url("/")));
-
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
-        .build();
-
-    Response response1 = get(server.url("/"));
-    assertEquals("ABC", response1.body().string());
-
-    // Cached!
-    Response response2 = get(server.url("/"));
-    assertEquals("ABC", response2.body().string());
-
-    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.hitCount());
-  }
-
-  @Test public void foundCachedWithExpiresHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(302, "Expires", formatDate(1, TimeUnit.HOURS));
-  }
-
-  @Test public void foundCachedWithCacheControlHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(302, "Cache-Control", "max-age=60");
-  }
-
-  @Test public void temporaryRedirectCachedWithExpiresHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(307, "Expires", formatDate(1, TimeUnit.HOURS));
-  }
-
-  @Test public void temporaryRedirectCachedWithCacheControlHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(307, "Cache-Control", "max-age=60");
-  }
-
-  @Test public void foundNotCachedWithoutCacheHeader() throws Exception {
-    temporaryRedirectNotCachedWithoutCachingHeader(302);
-  }
-
-  @Test public void temporaryRedirectNotCachedWithoutCacheHeader() throws Exception {
-    temporaryRedirectNotCachedWithoutCachingHeader(307);
-  }
-
-  private void temporaryRedirectCachedWithCachingHeader(
-      int responseCode, String headerName, String headerValue) throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader(headerName, headerValue)
-        .addHeader("Location", "/a"));
-    server.enqueue(new MockResponse()
-        .addHeader(headerName, headerValue)
-        .setBody("a"));
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-    server.enqueue(new MockResponse()
-        .setBody("c"));
-
-    HttpUrl url = server.url("/");
-    assertEquals("a", get(url).body().string());
-    assertEquals("a", get(url).body().string());
-  }
-
-  private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader("Location", "/a"));
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-
-    HttpUrl url = server.url("/");
-    assertEquals("a", get(url).body().string());
-    assertEquals("b", get(url).body().string());
-  }
-
-  /** https://github.com/square/okhttp/issues/2198 */
-  @Test public void cachedRedirect() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Location: /bar"));
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    Request request1 = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request1).execute();
-    assertEquals("ABC", response1.body().string());
-
-    Request request2 = new Request.Builder().url(server.url("/")).build();
-    Response response2 = client.newCall(request2).execute();
-    assertEquals("ABC", response2.body().string());
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
-    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
-    testServerPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
-    // Intentionally empty. This case doesn't make sense because there's no
-    // such thing as a premature disconnect when the disconnect itself
-    // indicates the end of the data stream.
-  }
-
-  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
-    MockResponse mockResponse = new MockResponse();
-    transferKind.setBody(mockResponse, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
-    server.enqueue(truncateViolently(mockResponse, 16));
-    server.enqueue(new MockResponse()
-        .setBody("Request #2"));
-
-    BufferedSource bodySource = get(server.url("/")).body().source();
-    assertEquals("ABCDE", bodySource.readUtf8Line());
-    try {
-      bodySource.readUtf8Line();
-      fail("This implementation silently ignored a truncated HTTP body.");
-    } catch (IOException expected) {
-    } finally {
-      bodySource.close();
-    }
-
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(0, cache.writeSuccessCount());
-    Response response = get(server.url("/"));
-    assertEquals("Request #2", response.body().string());
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(1, cache.writeSuccessCount());
-  }
-
-  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
-    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
-    testClientPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
-    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
-  }
-
-  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
-    // Setting a low transfer speed ensures that stream discarding will time out.
-    MockResponse mockResponse = new MockResponse()
-        .throttleBody(6, 1, TimeUnit.SECONDS);
-    transferKind.setBody(mockResponse, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(mockResponse);
-    server.enqueue(new MockResponse()
-        .setBody("Request #2"));
-
-    Response response1 = get(server.url("/"));
-    BufferedSource in = response1.body().source();
-    assertEquals("ABCDE", in.readUtf8(5));
-    in.close();
-    try {
-      in.readByte();
-      fail("Expected an IllegalStateException because the source is closed.");
-    } catch (IllegalStateException expected) {
-    }
-
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(0, cache.writeSuccessCount());
-    Response response2 = get(server.url("/"));
-    assertEquals("Request #2", response2.body().string());
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(1, cache.writeSuccessCount());
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
-    //      last modified: 105 seconds ago
-    //             served:   5 seconds ago
-    //   default lifetime: (105 - 5) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds from now
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-        .setBody("A"));
-
-    HttpUrl url = server.url("/");
-    Response response1 = get(url);
-    assertEquals("A", response1.body().string());
-
-    Response response2 = get(url);
-    assertEquals("A", response2.body().string());
-    assertNull(response2.header("Warning"));
-  }
-
-  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
-    //      last modified: 115 seconds ago
-    //             served:  15 seconds ago
-    //   default lifetime: (115 - 15) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds ago
-    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
-    //      last modified: 105 days ago
-    //             served:   5 days ago
-    //   default lifetime: (105 - 5) / 10 = 10 days
-    //            expires:  10 days from served date = 5 days from now
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
-        .setBody("A"));
-
-    assertEquals("A", get(server.url("/")).body().string());
-    Response response = get(server.url("/"));
-    assertEquals("A", response.body().string());
-    assertEquals("113 HttpURLConnection \"Heuristic expiration\"", response.header("Warning"));
-  }
-
-  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/").newBuilder().addQueryParameter("foo", "bar").build();
-    assertEquals("A", get(url).body().string());
-    assertEquals("B", get(url).body().string());
-  }
-
-  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void expirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Cache-Control: max-age=60"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
-    // Chrome interprets max-age relative to the local clock. Both our cache
-    // and Firefox both use the earlier of the local and server's clock.
-    assertNotCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=60")
-        .addHeader("Cache-Control: max-age=180"));
-  }
-
-  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=180")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void requestMethodOptionsIsNotCached() throws Exception {
-    testRequestMethod("OPTIONS", false);
-  }
-
-  @Test public void requestMethodGetIsCached() throws Exception {
-    testRequestMethod("GET", true);
-  }
-
-  @Test public void requestMethodHeadIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("HEAD", false);
-  }
-
-  @Test public void requestMethodPostIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("POST", false);
-  }
-
-  @Test public void requestMethodPutIsNotCached() throws Exception {
-    testRequestMethod("PUT", false);
-  }
-
-  @Test public void requestMethodDeleteIsNotCached() throws Exception {
-    testRequestMethod("DELETE", false);
-  }
-
-  @Test public void requestMethodTraceIsNotCached() throws Exception {
-    testRequestMethod("TRACE", false);
-  }
-
-  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
-    // 1. seed the cache (potentially)
-    // 2. expect a cache hit or miss
-    server.enqueue(new MockResponse()
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("X-Response-ID: 1"));
-    server.enqueue(new MockResponse()
-        .addHeader("X-Response-ID: 2"));
-
-    HttpUrl url = server.url("/");
-
-    Request request = new Request.Builder()
-        .url(url)
-        .method(requestMethod, requestBodyOrNull(requestMethod))
-        .build();
-    Response response1 = client.newCall(request).execute();
-    response1.body().close();
-    assertEquals("1", response1.header("X-Response-ID"));
-
-    Response response2 = get(url);
-    response2.body().close();
-    if (expectCached) {
-      assertEquals("1", response2.header("X-Response-ID"));
-    } else {
-      assertEquals("2", response2.header("X-Response-ID"));
-    }
-  }
-
-  private RequestBody requestBodyOrNull(String requestMethod) {
-    return (requestMethod.equals("POST") || requestMethod.equals("PUT"))
-        ? RequestBody.create(MediaType.parse("text/plain"), "foo")
-        : null;
-  }
-
-  @Test public void postInvalidatesCache() throws Exception {
-    testMethodInvalidates("POST");
-  }
-
-  @Test public void putInvalidatesCache() throws Exception {
-    testMethodInvalidates("PUT");
-  }
-
-  @Test public void deleteMethodInvalidatesCache() throws Exception {
-    testMethodInvalidates("DELETE");
-  }
-
-  private void testMethodInvalidates(String requestMethod) throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it
-    // 3. expect a cache miss
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    HttpUrl url = server.url("/");
-
-    assertEquals("A", get(url).body().string());
-
-    Request request = new Request.Builder()
-        .url(url)
-        .method(requestMethod, requestBodyOrNull(requestMethod))
-        .build();
-    Response invalidate = client.newCall(request).execute();
-    assertEquals("B", invalidate.body().string());
-
-    assertEquals("C", get(url).body().string());
-  }
-
-  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it with uncacheable response
-    // 3. expect a cache miss
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .setResponseCode(500));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    HttpUrl url = server.url("/");
-
-    assertEquals("A", get(url).body().string());
-
-    Request request = new Request.Builder()
-        .url(url)
-        .method("POST", requestBodyOrNull("POST"))
-        .build();
-    Response invalidate = client.newCall(request).execute();
-    assertEquals("B", invalidate.body().string());
-
-    assertEquals("C", get(url).body().string());
-  }
-
-  @Test public void etag() throws Exception {
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("ETag: v1"));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-  }
-
-  /** If both If-Modified-Since and If-None-Match conditions apply, send only If-None-Match. */
-  @Test public void etagAndExpirationDateInThePast() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void cacheControlNoCache() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Cache-Control: no-cache"));
-  }
-
-  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void pragmaNoCache() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Pragma: no-cache"));
-  }
-
-  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Pragma: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void cacheControlNoStore() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
-    // 1. request a range
-    // 2. request a full document, expecting a cache miss
-    server.enqueue(new MockResponse()
-        .setBody("AA")
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 1000-1001/2000"));
-    server.enqueue(new MockResponse()
-        .setBody("BB"));
-
-    HttpUrl url = server.url("/");
-
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Range", "bytes=1000-1001")
-        .build();
-    Response range = client.newCall(request).execute();
-    assertEquals("AA", range.body().string());
-
-    assertEquals("BB", get(url).body().string());
-  }
-
-  /**
-   * When the server returns a full response body we will store it and return it regardless of what
-   * its Last-Modified date is. This behavior was different prior to OkHttp 3.5 when we would prefer
-   * the response with the later Last-Modified date.
-   *
-   * https://github.com/square/okhttp/issues/2886
-   */
-  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpUrl url = server.url("/");
-
-    assertEquals("A", get(url).body().string());
-    assertEquals("B", get(url).body().string());
-    assertEquals("B", get(url).body().string());
-  }
-
-  @Test public void clientSideNoStore() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("B"));
-
-    Request request1 = new Request.Builder()
-        .url(server.url("/"))
-        .cacheControl(new CacheControl.Builder().noStore().build())
-        .build();
-    Response response1 = client.newCall(request1).execute();
-    assertEquals("A", response1.body().string());
-
-    Request request2 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertEquals("B", response2.body().string());
-  }
-
-  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
-    assertNonIdentityEncodingCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
-    assertNonIdentityEncodingCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
-    server.enqueue(response
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // At least three request/response pairs are required because after the first request is cached
-    // a different execution path might be taken. Thus modifications to the cache applied during
-    // the second request might not be visible until another request is performed.
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-  }
-
-  @Test public void notModifiedSpecifiesEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setBody("DEFDEFDEF"));
-
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("DEFDEFDEF", get(server.url("/")).body().string());
-  }
-
-  /** https://github.com/square/okhttp/issues/947 */
-  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Vary: Accept-Encoding")
-        .addHeader("Cache-Control: max-age=60"));
-    server.enqueue(new MockResponse()
-        .setBody("FAIL"));
-
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-  }
-
-  @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
-    // Ensure that the (shared) connection pool is in a consistent state.
-    client.connectionPool().evictAll();
-    assertEquals(0, client.connectionPool().idleConnectionCount());
-
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, client.connectionPool().idleConnectionCount());
-  }
-
-  @Test public void expiresDateBeforeModifiedDate() throws Exception {
-    assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
-  }
-
-  @Test public void requestMaxAge() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", get(server.url("/")).body().string());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "max-age=30")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
-  }
-
-  @Test public void requestMinFresh() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", get(server.url("/")).body().string());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "min-fresh=120")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
-  }
-
-  @Test public void requestMaxStale() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", get(server.url("/")).body().string());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "max-stale=180")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("A", response.body().string());
-    assertEquals("110 HttpURLConnection \"Response is stale\"", response.header("Warning"));
-  }
-
-  @Test public void requestMaxStaleDirectiveWithNoValue() throws IOException {
-    // Add a stale response to the cache.
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", get(server.url("/")).body().string());
-
-    // With max-stale, we'll return that stale response.
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "max-stale")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("A", response.body().string());
-    assertEquals("110 HttpURLConnection \"Response is stale\"", response.header("Warning"));
-  }
-
-  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120, must-revalidate")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", get(server.url("/")).body().string());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "max-stale=180")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
-  }
-
-  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
-    // (no responses enqueued)
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "only-if-cached")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertTrue(response.body().source().exhausted());
-    assertEquals(504, response.code());
-    assertEquals(1, cache.requestCount());
-    assertEquals(0, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-  }
-
-  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", get(server.url("/")).body().string());
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "only-if-cached")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("A", response.body().string());
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(1, cache.hitCount());
-  }
-
-  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
-
-    assertEquals("A", get(server.url("/")).body().string());
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "only-if-cached")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertTrue(response.body().source().exhausted());
-    assertEquals(504, response.code());
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-  }
-
-  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    assertEquals("A", get(server.url("/")).body().string());
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "only-if-cached")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertTrue(response.body().source().exhausted());
-    assertEquals(504, response.code());
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-  }
-
-  @Test public void requestCacheControlNoCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Cache-Control", "no-cache")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
-  }
-
-  @Test public void requestPragmaNoCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Pragma", "no-cache")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
-  }
-
-  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
-    MockResponse response = new MockResponse()
-        .addHeader("ETag: v3")
-        .addHeader("Cache-Control: max-age=0");
-    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
-    RecordedRequest request =
-        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
-    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
-    assertNull(request.getHeader("If-None-Match"));
-  }
-
-  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
-    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
-    MockResponse response = new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: max-age=0");
-    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
-    assertEquals("v1", request.getHeader("If-None-Match"));
-    assertNull(request.getHeader("If-Modified-Since"));
-  }
-
-  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
-      String conditionValue) throws Exception {
-    server.enqueue(seed.setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-
-    Request request = new Request.Builder()
-        .url(url)
-        .header(conditionName, conditionValue)
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, response.code());
-    assertEquals("", response.body().string());
-
-    server.takeRequest(); // seed
-    return server.takeRequest();
-  }
-
-  /**
-   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
-   * served.
-   */
-  @Test public void retainServedDateFormat() throws Exception {
-    // Serve a response with a non-standard date format that OkHttp supports.
-    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
-    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
-    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
-    String lastModifiedString = dateFormat.format(lastModifiedDate);
-    String servedString = dateFormat.format(servedDate);
-
-    // This response should be conditionally cached.
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedString)
-        .addHeader("Expires: " + servedString)
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("A", get(server.url("/")).body().string());
-
-    // The first request has no conditions.
-    RecordedRequest request1 = server.takeRequest();
-    assertNull(request1.getHeader("If-Modified-Since"));
-
-    // The 2nd request uses the server's date format.
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("If-Modified-Since", formatDate(-24, TimeUnit.HOURS))
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, response.code());
-    assertEquals("", response.body().string());
-  }
-
-  @Test public void authorizationRequestFullyCached() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Authorization", "password")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("A", response.body().string());
-    assertEquals("A", get(url).body().string());
-  }
-
-  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Content-Location: /bar")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", get(server.url("/foo")).body().string());
-    assertEquals("B", get(server.url("/bar")).body().string());
-  }
-
-  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", get(server.url("/a")).body().string());
-    assertEquals("A", get(server.url("/a")).body().string());
-    assertEquals("B", get(server.url("/b")).body().string());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void statisticsConditionalCacheMiss() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("B", get(server.url("/")).body().string());
-    assertEquals("C", get(server.url("/")).body().string());
-    assertEquals(3, cache.requestCount());
-    assertEquals(3, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-  }
-
-  @Test public void statisticsConditionalCacheHit() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(3, cache.requestCount());
-    assertEquals(3, cache.networkCount());
-    assertEquals(2, cache.hitCount());
-  }
-
-  @Test public void statisticsFullCacheHit() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(3, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(2, cache.hitCount());
-  }
-
-  @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request frRequest = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .build();
-    Response frResponse = client.newCall(frRequest).execute();
-    assertEquals("A", frResponse.body().string());
-
-    Request enRequest = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "en-US")
-        .build();
-    Response enResponse = client.newCall(enRequest).execute();
-    assertEquals("B", enResponse.body().string());
-  }
-
-  @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .build();
-    Response response1 = client.newCall(request).execute();
-    assertEquals("A", response1.body().string());
-    Request request1 = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .build();
-    Response response2 = client.newCall(request1).execute();
-    assertEquals("A", response2.body().string());
-  }
-
-  @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("A", get(server.url("/")).body().string());
-  }
-
-  @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", get(server.url("/")).body().string());
-    Request request = new Request.Builder()
-        .url(server.url("/")).header("Foo", "bar")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
-  }
-
-  @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/")).header("Foo", "bar")
-        .build();
-    Response fooresponse = client.newCall(request).execute();
-    assertEquals("A", fooresponse.body().string());
-    assertEquals("B", get(server.url("/")).body().string());
-  }
-
-  @Test public void varyFieldsAreCaseInsensitive() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: ACCEPT-LANGUAGE")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .build();
-    Response response1 = client.newCall(request).execute();
-    assertEquals("A", response1.body().string());
-    Request request1 = new Request.Builder()
-        .url(url)
-        .header("accept-language", "fr-CA")
-        .build();
-    Response response2 = client.newCall(request1).execute();
-    assertEquals("A", response2.body().string());
-  }
-
-  @Test public void varyMultipleFieldsWithMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .header("Accept-Charset", "UTF-8")
-        .header("Accept-Encoding", "identity")
-        .build();
-    Response response1 = client.newCall(request).execute();
-    assertEquals("A", response1.body().string());
-    Request request1 = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .header("Accept-Charset", "UTF-8")
-        .header("Accept-Encoding", "identity")
-        .build();
-    Response response2 = client.newCall(request1).execute();
-    assertEquals("A", response2.body().string());
-  }
-
-  @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request frRequest = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .header("Accept-Charset", "UTF-8")
-        .header("Accept-Encoding", "identity")
-        .build();
-    Response frResponse = client.newCall(frRequest).execute();
-    assertEquals("A", frResponse.body().string());
-    Request enRequest = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "en-CA")
-        .header("Accept-Charset", "UTF-8")
-        .header("Accept-Encoding", "identity")
-        .build();
-    Response enResponse = client.newCall(enRequest).execute();
-    assertEquals("B", enResponse.body().string());
-  }
-
-  @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request1 = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "fr-CA, fr-FR")
-        .addHeader("Accept-Language", "en-US")
-        .build();
-    Response response1 = client.newCall(request1).execute();
-    assertEquals("A", response1.body().string());
-
-    Request request2 = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "fr-CA, fr-FR")
-        .addHeader("Accept-Language", "en-US")
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertEquals("A", response2.body().string());
-  }
-
-  @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request1 = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "fr-CA, fr-FR")
-        .addHeader("Accept-Language", "en-US")
-        .build();
-    Response response1 = client.newCall(request1).execute();
-    assertEquals("A", response1.body().string());
-
-    Request request2 = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "fr-CA")
-        .addHeader("Accept-Language", "en-US")
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertEquals("B", response2.body().string());
-  }
-
-  @Test public void varyAsterisk() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: *")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("B", get(server.url("/")).body().string());
-  }
-
-  @Test public void varyAndHttps() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
-        .build();
-
-    HttpUrl url = server.url("/");
-    Request request1 = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "en-US")
-        .build();
-    Response response1 = client.newCall(request1).execute();
-    assertEquals("A", response1.body().string());
-
-    Request request2 = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "en-US")
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertEquals("A", response2.body().string());
-  }
-
-  @Test public void cachePlusCookies() throws Exception {
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-    client = client.newBuilder()
-        .cookieJar(cookieJar)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=FIRST")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=SECOND")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    cookieJar.assertResponseCookies("a=FIRST; path=/");
-    assertEquals("A", get(url).body().string());
-    cookieJar.assertResponseCookies("a=SECOND; path=/");
-  }
-
-  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Allow: GET, HEAD")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Allow: GET, HEAD, PUT")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertEquals("A", response1.body().string());
-    assertEquals("GET, HEAD", response1.header("Allow"));
-
-    Response response2 = get(server.url("/"));
-    assertEquals("A", response2.body().string());
-    assertEquals("GET, HEAD, PUT", response2.header("Allow"));
-  }
-
-  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Transfer-Encoding: identity")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Transfer-Encoding: none")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertEquals("A", response1.body().string());
-    assertEquals("identity", response1.header("Transfer-Encoding"));
-
-    Response response2 = get(server.url("/"));
-    assertEquals("A", response2.body().string());
-    assertEquals("identity", response2.header("Transfer-Encoding"));
-  }
-
-  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Warning: 199 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertEquals("A", response1.body().string());
-    assertEquals("199 test danger", response1.header("Warning"));
-
-    Response response2 = get(server.url("/"));
-    assertEquals("A", response2.body().string());
-    assertEquals(null, response2.header("Warning"));
-  }
-
-  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Warning: 299 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertEquals("A", response1.body().string());
-    assertEquals("299 test danger", response1.header("Warning"));
-
-    Response response2 = get(server.url("/"));
-    assertEquals("A", response2.body().string());
-    assertEquals("299 test danger", response2.header("Warning"));
-  }
-
-  @Test public void doNotCachePartialResponse() throws Exception {
-    assertNotCached(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 100-100/200")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void conditionalHitUpdatesCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Allow: GET, HEAD")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    // A cache miss writes the cache.
-    long t0 = System.currentTimeMillis();
-    Response response1 = get(server.url("/a"));
-    assertEquals("A", response1.body().string());
-    assertEquals(null, response1.header("Allow"));
-    assertEquals(0, response1.receivedResponseAtMillis() - t0, 250.0);
-
-    // A conditional cache hit updates the cache.
-    Thread.sleep(500); // Make sure t0 and t1 are distinct.
-    long t1 = System.currentTimeMillis();
-    Response response2 = get(server.url("/a"));
-    assertEquals(HttpURLConnection.HTTP_OK, response2.code());
-    assertEquals("A", response2.body().string());
-    assertEquals("GET, HEAD", response2.header("Allow"));
-    assertEquals(0, response2.receivedResponseAtMillis() - t1, 250.0);
-
-    // A full cache hit reads the cache.
-    Thread.sleep(500); // Make sure t1 and t2 are distinct.
-    long t2 = System.currentTimeMillis();
-    Response response3 = get(server.url("/a"));
-    assertEquals("A", response3.body().string());
-    assertEquals("GET, HEAD", response3.header("Allow"));
-    assertEquals(0, response3.receivedResponseAtMillis() - t1, 250.0);
-
-    assertEquals(2, server.getRequestCount());
-  }
-
-  @Test public void responseSourceHeaderCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", get(server.url("/")).body().string());
-    Request request = new Request.Builder()
-        .url(server.url("/")).header("Cache-Control", "only-if-cached")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertEquals("A", response.body().string());
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", get(server.url("/")).body().string());
-    Response response = get(server.url("/"));
-    assertEquals("B", response.body().string());
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=0")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(304));
-
-    assertEquals("A", get(server.url("/")).body().string());
-    Response response = get(server.url("/"));
-    assertEquals("A", response.body().string());
-  }
-
-  @Test public void responseSourceHeaderFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    Response response = get(server.url("/"));
-    assertEquals("A", response.body().string());
-  }
-
-  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
-    Headers.Builder headers = new Headers.Builder()
-        .add("Cache-Control: max-age=120");
-    Internal.instance.addLenient(headers, ": A");
-    server.enqueue(new MockResponse()
-        .setHeaders(headers.build())
-        .setBody("body"));
-
-    Response response = get(server.url("/"));
-    assertEquals("A", response.header(""));
-    assertEquals("body", response.body().string());
-  }
-
-  /**
-   * Old implementations of OkHttp's response cache wrote header fields like ":status: 200 OK". This
-   * broke our cached response parser because it split on the first colon. This regression test
-   * exists to help us read these old bad cache entries.
-   *
-   * https://github.com/square/okhttp/issues/227
-   */
-  @Test public void testGoldenCacheResponse() throws Exception {
-    cache.close();
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpUrl url = server.url("/");
-    String urlKey = Cache.key(url);
-    String entryMetadata = ""
-        + "" + url + "\n"
-        + "GET\n"
-        + "0\n"
-        + "HTTP/1.1 200 OK\n"
-        + "7\n"
-        + ":status: 200 OK\n"
-        + ":version: HTTP/1.1\n"
-        + "etag: foo\n"
-        + "content-length: 3\n"
-        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + "X-Android-Response-Source: NETWORK 200\n"
-        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
-        + "\n"
-        + "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n"
-        + "1\n"
-        + "MIIBpDCCAQ2gAwIBAgIBATANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDEw1qd2lsc29uLmxvY2FsMB4XDTEzMDgy"
-        + "OTA1MDE1OVoXDTEzMDgzMDA1MDE1OVowGDEWMBQGA1UEAxMNandpbHNvbi5sb2NhbDCBnzANBgkqhkiG9w0BAQEF"
-        + "AAOBjQAwgYkCgYEAlFW+rGo/YikCcRghOyKkJanmVmJSce/p2/jH1QvNIFKizZdh8AKNwojt3ywRWaDULA/RlCUc"
-        + "ltF3HGNsCyjQI/+Lf40x7JpxXF8oim1E6EtDoYtGWAseelawus3IQ13nmo6nWzfyCA55KhAWf4VipelEy8DjcuFK"
-        + "v6L0xwXnI0ECAwEAATANBgkqhkiG9w0BAQsFAAOBgQAuluNyPo1HksU3+Mr/PyRQIQS4BI7pRXN8mcejXmqyscdP"
-        + "7S6J21FBFeRR8/XNjVOp4HT9uSc2hrRtTEHEZCmpyoxixbnM706ikTmC7SN/GgM+SmcoJ1ipJcNcl8N0X6zym4dm"
-        + "yFfXKHu2PkTo7QFdpOJFvP3lIigcSZXozfmEDg==\n"
-        + "-1\n";
-    String entryBody = "abc";
-    String journalBody = ""
-        + "libcore.io.DiskLruCache\n"
-        + "1\n"
-        + "201105\n"
-        + "2\n"
-        + "\n"
-        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.directory(), urlKey + ".1", entryBody);
-    writeFile(cache.directory(), "journal", journalBody);
-    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Response response = get(url);
-    assertEquals(entryBody, response.body().string());
-    assertEquals("3", response.header("Content-Length"));
-    assertEquals("foo", response.header("etag"));
-  }
-
-  /** Exercise the cache format in OkHttp 2.7 and all earlier releases. */
-  @Test public void testGoldenCacheHttpsResponseOkHttp27() throws Exception {
-    HttpUrl url = server.url("/");
-    String urlKey = Cache.key(url);
-    String prefix = Platform.get().getPrefix();
-    String entryMetadata = ""
-        + "" + url + "\n"
-        + "GET\n"
-        + "0\n"
-        + "HTTP/1.1 200 OK\n"
-        + "4\n"
-        + "Content-Length: 3\n"
-        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n"
-        + "Cache-Control: max-age=60\n"
-        + "\n"
-        + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
-        + "1\n"
-        + "MIIBnDCCAQWgAwIBAgIBATANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTUxMjIyMDEx"
-        + "MTQwWhcNMTUxMjIzMDExMTQwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ"
-        + "AoGBAJTn2Dh8xYmegvpOSmsKb2Os6Cxf1L4fYbnHr/turInUD5r1P7ZAuxurY880q3GT5bUDoirS3IfucddrT1Ac"
-        + "AmUzEmk/FDjggiP8DlxFkY/XwXBlhRDVIp/mRuASPMGInckc0ZaixOkRFyrxADj+r1eaSmXCIvV5yTY6IaIokLj1"
-        + "AgMBAAEwDQYJKoZIhvcNAQELBQADgYEAFblnedqtfRqI9j2WDyPPoG0NTZf9xwjeUu+ju+Ktty8u9k7Lgrrd/DH2"
-        + "mQEtBD1Ctvp91MJfAClNg3faZzwClUyu5pd0QXRZEUwSwZQNen2QWDHRlVsItclBJ4t+AJLqTbwofWi4m4K8REOl"
-        + "593hD55E4+lY22JZiVQyjsQhe6I=\n"
-        + "0\n";
-    String entryBody = "abc";
-    String journalBody = ""
-        + "libcore.io.DiskLruCache\n"
-        + "1\n"
-        + "201105\n"
-        + "2\n"
-        + "\n"
-        + "DIRTY " + urlKey + "\n"
-        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.directory(), urlKey + ".1", entryBody);
-    writeFile(cache.directory(), "journal", journalBody);
-    cache.close();
-    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Response response = get(url);
-    assertEquals(entryBody, response.body().string());
-    assertEquals("3", response.header("Content-Length"));
-  }
-
-  /** The TLS version is present in OkHttp 3.0 and beyond. */
-  @Test public void testGoldenCacheHttpsResponseOkHttp30() throws Exception {
-    HttpUrl url = server.url("/");
-    String urlKey = Cache.key(url);
-    String prefix = Platform.get().getPrefix();
-    String entryMetadata = ""
-        + "" + url + "\n"
-        + "GET\n"
-        + "0\n"
-        + "HTTP/1.1 200 OK\n"
-        + "4\n"
-        + "Content-Length: 3\n"
-        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n"
-        + "Cache-Control: max-age=60\n"
-        + "\n"
-        + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
-        + "1\n"
-        + "MIIBnDCCAQWgAwIBAgIBATANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTUxMjIyMDEx"
-        + "MTQwWhcNMTUxMjIzMDExMTQwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ"
-        + "AoGBAJTn2Dh8xYmegvpOSmsKb2Os6Cxf1L4fYbnHr/turInUD5r1P7ZAuxurY880q3GT5bUDoirS3IfucddrT1Ac"
-        + "AmUzEmk/FDjggiP8DlxFkY/XwXBlhRDVIp/mRuASPMGInckc0ZaixOkRFyrxADj+r1eaSmXCIvV5yTY6IaIokLj1"
-        + "AgMBAAEwDQYJKoZIhvcNAQELBQADgYEAFblnedqtfRqI9j2WDyPPoG0NTZf9xwjeUu+ju+Ktty8u9k7Lgrrd/DH2"
-        + "mQEtBD1Ctvp91MJfAClNg3faZzwClUyu5pd0QXRZEUwSwZQNen2QWDHRlVsItclBJ4t+AJLqTbwofWi4m4K8REOl"
-        + "593hD55E4+lY22JZiVQyjsQhe6I=\n"
-        + "0\n"
-        + "TLSv1.2\n";
-    String entryBody = "abc";
-    String journalBody = ""
-        + "libcore.io.DiskLruCache\n"
-        + "1\n"
-        + "201105\n"
-        + "2\n"
-        + "\n"
-        + "DIRTY " + urlKey + "\n"
-        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.directory(), urlKey + ".1", entryBody);
-    writeFile(cache.directory(), "journal", journalBody);
-    cache.close();
-    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Response response = get(url);
-    assertEquals(entryBody, response.body().string());
-    assertEquals("3", response.header("Content-Length"));
-  }
-
-  @Test public void testGoldenCacheHttpResponseOkHttp30() throws Exception {
-    HttpUrl url = server.url("/");
-    String urlKey = Cache.key(url);
-    String prefix = Platform.get().getPrefix();
-    String entryMetadata = ""
-        + "" + url + "\n"
-        + "GET\n"
-        + "0\n"
-        + "HTTP/1.1 200 OK\n"
-        + "4\n"
-        + "Cache-Control: max-age=60\n"
-        + "Content-Length: 3\n"
-        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n";
-    String entryBody = "abc";
-    String journalBody = ""
-        + "libcore.io.DiskLruCache\n"
-        + "1\n"
-        + "201105\n"
-        + "2\n"
-        + "\n"
-        + "DIRTY " + urlKey + "\n"
-        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.directory(), urlKey + ".1", entryBody);
-    writeFile(cache.directory(), "journal", journalBody);
-    cache.close();
-    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Response response = get(url);
-    assertEquals(entryBody, response.body().string());
-    assertEquals("3", response.header("Content-Length"));
-  }
-
-  @Test public void evictAll() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    client.cache().evictAll();
-    assertEquals(0, client.cache().size());
-    assertEquals("B", get(url).body().string());
-  }
-
-  @Test public void networkInterceptorInvokedForConditionalGet() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // Seed the cache.
-    HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-
-    final AtomicReference<String> ifNoneMatch = new AtomicReference<>();
-    client = client.newBuilder()
-        .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            ifNoneMatch.compareAndSet(null, chain.request().header("If-None-Match"));
-            return chain.proceed(chain.request());
-          }
-        }).build();
-
-    // Confirm the value is cached and intercepted.
-    assertEquals("A", get(url).body().string());
-    assertEquals("v1", ifNoneMatch.get());
-  }
-
-  @Test public void networkInterceptorNotInvokedForFullyCached() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-
-    // Seed the cache.
-    HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-
-    // Confirm the interceptor isn't exercised.
-    client = client.newBuilder()
-        .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            throw new AssertionError();
-          }
-        }).build();
-    assertEquals("A", get(url).body().string());
-  }
-
-  @Test public void iterateCache() throws Exception {
-    // Put some responses in the cache.
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    HttpUrl urlA = server.url("/a");
-    assertEquals("a", get(urlA).body().string());
-
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-    HttpUrl urlB = server.url("/b");
-    assertEquals("b", get(urlB).body().string());
-
-    server.enqueue(new MockResponse()
-        .setBody("c"));
-    HttpUrl urlC = server.url("/c");
-    assertEquals("c", get(urlC).body().string());
-
-    // Confirm the iterator returns those responses...
-    Iterator<String> i = cache.urls();
-    assertTrue(i.hasNext());
-    assertEquals(urlA.toString(), i.next());
-    assertTrue(i.hasNext());
-    assertEquals(urlB.toString(), i.next());
-    assertTrue(i.hasNext());
-    assertEquals(urlC.toString(), i.next());
-
-    // ... and nothing else.
-    assertFalse(i.hasNext());
-    try {
-      i.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void iteratorRemoveFromCache() throws Exception {
-    // Put a response in the cache.
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("a"));
-    HttpUrl url = server.url("/a");
-    assertEquals("a", get(url).body().string());
-
-    // Remove it with iteration.
-    Iterator<String> i = cache.urls();
-    assertEquals(url.toString(), i.next());
-    i.remove();
-
-    // Confirm that subsequent requests suffer a cache miss.
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-    assertEquals("b", get(url).body().string());
-  }
-
-  @Test public void iteratorRemoveWithoutNextThrows() throws Exception {
-    // Put a response in the cache.
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    HttpUrl url = server.url("/a");
-    assertEquals("a", get(url).body().string());
-
-    Iterator<String> i = cache.urls();
-    assertTrue(i.hasNext());
-    try {
-      i.remove();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void iteratorRemoveOncePerCallToNext() throws Exception {
-    // Put a response in the cache.
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    HttpUrl url = server.url("/a");
-    assertEquals("a", get(url).body().string());
-
-    Iterator<String> i = cache.urls();
-    assertEquals(url.toString(), i.next());
-    i.remove();
-
-    // Too many calls to remove().
-    try {
-      i.remove();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void elementEvictedBetweenHasNextAndNext() throws Exception {
-    // Put a response in the cache.
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    HttpUrl url = server.url("/a");
-    assertEquals("a", get(url).body().string());
-
-    // The URL will remain available if hasNext() returned true...
-    Iterator<String> i = cache.urls();
-    assertTrue(i.hasNext());
-
-    // ...so even when we evict the element, we still get something back.
-    cache.evictAll();
-    assertEquals(url.toString(), i.next());
-
-    // Remove does nothing. But most importantly, it doesn't throw!
-    i.remove();
-  }
-
-  @Test public void elementEvictedBeforeHasNextIsOmitted() throws Exception {
-    // Put a response in the cache.
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    HttpUrl url = server.url("/a");
-    assertEquals("a", get(url).body().string());
-
-    Iterator<String> i = cache.urls();
-    cache.evictAll();
-
-    // The URL was evicted before hasNext() made any promises.
-    assertFalse(i.hasNext());
-    try {
-      i.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  /** Test https://github.com/square/okhttp/issues/1712. */
-  @Test public void conditionalMissUpdatesCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v2")
-        .setBody("B"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    assertEquals("A", get(url).body().string());
-    assertEquals("B", get(url).body().string());
-    assertEquals("B", get(url).body().string());
-
-    assertEquals(null, server.takeRequest().getHeader("If-None-Match"));
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
-    assertEquals("v2", server.takeRequest().getHeader("If-None-Match"));
-  }
-
-  @Test public void combinedCacheHeadersCanBeNonAscii() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .addHeaderLenient("Alpha", "")
-        .addHeaderLenient("", "Beta")
-        .setBody("abcd"));
-    server.enqueue(new MockResponse()
-        .addHeader("Transfer-Encoding: none")
-        .addHeaderLenient("Gamma", "")
-        .addHeaderLenient("", "Delta")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertEquals("", response1.header("Alpha"));
-    assertEquals("Beta", response1.header(""));
-    assertEquals("abcd", response1.body().string());
-
-    Response response2 = get(server.url("/"));
-    assertEquals("", response2.header("Alpha"));
-    assertEquals("Beta", response2.header(""));
-    assertEquals("", response2.header("Gamma"));
-    assertEquals("Delta", response2.header(""));
-    assertEquals("abcd", response2.body().string());
-  }
-
-  @Test public void etagConditionCanBeNonAscii() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeaderLenient("Etag", "")
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("abcd"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertEquals("abcd", response1.body().string());
-
-    Response response2 = get(server.url("/"));
-    assertEquals("abcd", response2.body().string());
-
-    assertEquals(null, server.takeRequest().getHeader("If-None-Match"));
-    assertEquals("", server.takeRequest().getHeader("If-None-Match"));
-  }
-
-  private Response get(HttpUrl url) throws IOException {
-    Request request = new Request.Builder()
-        .url(url)
-        .build();
-    return client.newCall(request).execute();
-  }
-
-  private void writeFile(File directory, String file, String content) throws IOException {
-    BufferedSink sink = Okio.buffer(fileSystem.sink(new File(directory, file)));
-    sink.writeUtf8(content);
-    sink.close();
-  }
-
-  /**
-   * @param delta the offset from the current date to use. Negative values yield dates in the past;
-   * positive values yield dates in the future.
-   */
-  private String formatDate(long delta, TimeUnit timeUnit) {
-    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private String formatDate(Date date) {
-    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
-    return rfc1123.format(date);
-  }
-
-  private void assertNotCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    assertEquals("B", get(url).body().string());
-  }
-
-  /** @return the request with the conditional get headers. */
-  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
-    // scenario 1: condition succeeds
-    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // scenario 2: condition fails
-    server.enqueue(response.setBody("B")
-        .setStatus("HTTP/1.1 200 B-OK"));
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 200 C-OK")
-        .setBody("C"));
-
-    HttpUrl valid = server.url("/valid");
-    Response response1 = get(valid);
-    assertEquals("A", response1.body().string());
-    assertEquals(HttpURLConnection.HTTP_OK, response1.code());
-    assertEquals("A-OK", response1.message());
-    Response response2 = get(valid);
-    assertEquals("A", response2.body().string());
-    assertEquals(HttpURLConnection.HTTP_OK, response2.code());
-    assertEquals("A-OK", response2.message());
-
-    HttpUrl invalid = server.url("/invalid");
-    Response response3 = get(invalid);
-    assertEquals("B", response3.body().string());
-    assertEquals(HttpURLConnection.HTTP_OK, response3.code());
-    assertEquals("B-OK", response3.message());
-    Response response4 = get(invalid);
-    assertEquals("C", response4.body().string());
-    assertEquals(HttpURLConnection.HTTP_OK, response4.code());
-    assertEquals("C-OK", response4.message());
-
-    server.takeRequest(); // regular get
-    return server.takeRequest(); // conditional get
-  }
-
-  private void assertFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(response.setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    assertEquals("A", get(url).body().string());
-  }
-
-  /**
-   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
-   * how clients respond to the premature conclusion of the HTTP body.
-   */
-  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
-    response.setSocketPolicy(DISCONNECT_AT_END);
-    Headers headers = response.getHeaders();
-    Buffer truncatedBody = new Buffer();
-    truncatedBody.write(response.getBody(), numBytesToKeep);
-    response.setBody(truncatedBody);
-    response.setHeaders(headers);
-    return response;
-  }
-
-  enum TransferKind {
-    CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
-        response.setChunkedBody(content, chunkSize);
-      }
-    },
-    FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-      }
-    },
-    END_OF_STREAM() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(DISCONNECT_AT_END);
-        response.removeHeader("Content-Length");
-      }
-    };
-
-    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, new Buffer().writeUtf8(content), chunkSize);
-    }
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(result));
-    sink.writeUtf8(data);
-    sink.close();
-    return result;
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index 4782581167..277d565a3f 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -103,7 +103,6 @@
   private OkHttpClient client = defaultClient();
   private RecordingCallback callback = new RecordingCallback();
   private TestLogHandler logHandler = new TestLogHandler();
-  private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
   private ServerSocket nullServer;
   private Logger logger = Logger.getLogger(OkHttpClient.class.getName());
 
@@ -112,7 +111,6 @@
   }
 
   @After public void tearDown() throws Exception {
-    cache.delete();
     Util.closeQuietly(nullServer);
     logger.removeHandler(logHandler);
   }
@@ -1274,7 +1272,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setBody("A"));
 
     client = client.newBuilder()
-        .cache(cache)
         .build();
 
     // Store a response in the cache.
@@ -1336,7 +1333,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     client = client.newBuilder()
-        .cache(cache)
         .build();
 
     // Store a response in the cache.
@@ -1397,7 +1393,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     client = client.newBuilder()
-        .cache(cache)
         .build();
 
     Request request1 = new Request.Builder()
@@ -1426,7 +1421,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setBody("B"));
 
     client = client.newBuilder()
-        .cache(cache)
         .build();
 
     long request1SentAt = System.currentTimeMillis();
@@ -1476,7 +1470,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     server.enqueue(new MockResponse().setBody("B"));
 
     client = client.newBuilder()
-        .cache(cache)
         .build();
 
     Request request1 = new Request.Builder()
@@ -1504,7 +1497,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
   @Test public void networkDropsOnConditionalGet() throws IOException {
     client = client.newBuilder()
-        .cache(cache)
         .build();
 
     // Seed the cache.
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
deleted file mode 100644
index a566babadb..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ /dev/null
@@ -1,3835 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.Authenticator;
-import java.net.ConnectException;
-import java.net.CookieManager;
-import java.net.HttpRetryException;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.net.SocketTimeoutException;
-import java.net.URI;
-import java.net.URL;
-import java.net.URLConnection;
-import java.net.UnknownHostException;
-import java.security.KeyStore;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.HashSet;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.zip.GZIPInputStream;
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLProtocolException;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.DoubleInetAddressDns;
-import okhttp3.internal.Internal;
-import okhttp3.internal.RecordingAuthenticator;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.internal.Util;
-import okhttp3.internal.Version;
-import okhttp3.internal.huc.OkHttpURLConnection;
-import okhttp3.internal.tls.SslClient;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.internal.Util.UTF_8;
-import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-import static okhttp3.internal.huc.OkHttpURLConnection.SELECTED_PROTOCOL;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
-import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeTrue;
-
-/** Android's URLConnectionTest. */
-public final class URLConnectionTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final MockWebServer server2 = new MockWebServer();
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-
-  private SslClient sslClient = SslClient.localhost();
-  private OkUrlFactory urlFactory;
-  private HttpURLConnection connection;
-  private Cache cache;
-
-  @Before public void setUp() throws Exception {
-    server.setProtocolNegotiationEnabled(false);
-    urlFactory = new OkUrlFactory(defaultClient());
-  }
-
-  @After public void tearDown() throws Exception {
-    Authenticator.setDefault(null);
-    System.clearProperty("proxyHost");
-    System.clearProperty("proxyPort");
-    System.clearProperty("http.agent");
-    System.clearProperty("http.proxyHost");
-    System.clearProperty("http.proxyPort");
-    System.clearProperty("https.proxyHost");
-    System.clearProperty("https.proxyPort");
-    if (cache != null) {
-      cache.delete();
-    }
-  }
-
-  @Test public void requestHeaders() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse());
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("D", "e");
-    connection.addRequestProperty("D", "f");
-    assertEquals("f", connection.getRequestProperty("D"));
-    assertEquals("f", connection.getRequestProperty("d"));
-    Map<String, List<String>> requestHeaders = connection.getRequestProperties();
-    assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("D")));
-    assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("d")));
-    try {
-      requestHeaders.put("G", Arrays.asList("h"));
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      requestHeaders.get("D").add("i");
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      connection.setRequestProperty(null, "j");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      connection.addRequestProperty(null, "k");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    connection.setRequestProperty("NullValue", null);
-    assertNull(connection.getRequestProperty("NullValue"));
-    connection.addRequestProperty("AnotherNullValue", null);
-    assertNull(connection.getRequestProperty("AnotherNullValue"));
-
-    connection.getResponseCode();
-    RecordedRequest request = server.takeRequest();
-    assertEquals(Arrays.asList("e", "f"), request.getHeaders().values("D"));
-    assertNull(request.getHeader("NullValue"));
-    assertNull(request.getHeader("AnotherNullValue"));
-    assertNull(request.getHeader("G"));
-    assertNull(request.getHeader("null"));
-
-    try {
-      connection.addRequestProperty("N", "o");
-      fail("Set header after connect");
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      connection.setRequestProperty("P", "q");
-      fail("Set header after connect");
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      connection.getRequestProperties();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void getRequestPropertyReturnsLastValue() throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("A", "value1");
-    connection.addRequestProperty("A", "value2");
-    assertEquals("value2", connection.getRequestProperty("A"));
-  }
-
-  @Test public void responseHeaders() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 Fantastic")
-        .addHeader("A: c")
-        .addHeader("B: d")
-        .addHeader("A: e")
-        .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
-
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Fantastic", connection.getResponseMessage());
-    assertEquals("HTTP/1.0 200 Fantastic", connection.getHeaderField(null));
-    Map<String, List<String>> responseHeaders = connection.getHeaderFields();
-    assertEquals(Arrays.asList("HTTP/1.0 200 Fantastic"), responseHeaders.get(null));
-    assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("A")));
-    assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("a")));
-    try {
-      responseHeaders.put("N", Arrays.asList("o"));
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      responseHeaders.get("A").add("f");
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    assertEquals("A", connection.getHeaderFieldKey(0));
-    assertEquals("c", connection.getHeaderField(0));
-    assertEquals("B", connection.getHeaderFieldKey(1));
-    assertEquals("d", connection.getHeaderField(1));
-    assertEquals("A", connection.getHeaderFieldKey(2));
-    assertEquals("e", connection.getHeaderField(2));
-    connection.getInputStream().close();
-  }
-
-  @Test public void serverSendsInvalidResponseHeaders() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
-    server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void connectRetriesUntilConnectedOrFailed() throws Exception {
-    URL url = server.url("/foo").url();
-    server.shutdown();
-
-    connection = urlFactory.open(url);
-    try {
-      connection.connect();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void requestBodySurvivesRetriesWithFixedLength() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void requestBodySurvivesRetriesWithChunkedStreaming() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.CHUNKED);
-  }
-
-  @Test public void requestBodySurvivesRetriesWithBufferedBody() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.END_OF_STREAM);
-  }
-
-  private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    // Use a misconfigured proxy to guarantee that the request is retried.
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxySelector(new FakeProxySelector()
-            .addProxy(server2.toProxyAddress())
-            .addProxy(Proxy.NO_PROXY))
-        .build());
-    server2.shutdown();
-
-    connection = urlFactory.open(server.url("/def").url());
-    connection.setDoOutput(true);
-    transferKind.setForRequest(connection, 4);
-    connection.getOutputStream().write("body".getBytes("UTF-8"));
-    assertContent("abc", connection);
-
-    assertEquals("body", server.takeRequest().getBody().readUtf8());
-  }
-
-  @Test public void streamedBodyIsNotRetried() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-
-    urlFactory = new OkUrlFactory(defaultClient().newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build());
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    connection.setChunkedStreamingMode(100);
-    OutputStream os = connection.getOutputStream();
-    os.write("OutputStream is no fun.".getBytes("UTF-8"));
-    os.close();
-
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    assertEquals(1, server.getRequestCount());
-  }
-
-  @Test public void getErrorStreamOnSuccessfulRequest() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    assertNull(connection.getErrorStream());
-    connection.getInputStream().close();
-  }
-
-  @Test public void getErrorStreamOnUnsuccessfulRequest() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection.getErrorStream(), Integer.MAX_VALUE));
-  }
-
-  // Check that if we don't read to the end of a response, the next request on the
-  // recycled connection doesn't get the unread tail of the first request's response.
-  // http://code.google.com/p/android/issues/detail?id=2939
-  @Test public void bug2939() throws Exception {
-    MockResponse response = new MockResponse().setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8);
-
-    server.enqueue(response);
-    server.enqueue(response);
-
-    HttpURLConnection c1 = urlFactory.open(server.url("/").url());
-    assertContent("ABCDE", c1, 5);
-    HttpURLConnection c2 = urlFactory.open(server.url("/").url());
-    assertContent("ABCDE", c2, 5);
-
-    c1.getInputStream().close();
-    c2.getInputStream().close();
-  }
-
-  // Check that we recognize a few basic mime types by extension.
-  // http://code.google.com/p/android/issues/detail?id=10100
-  @Test public void bug10100() throws Exception {
-    assertEquals("image/jpeg", URLConnection.guessContentTypeFromName("someFile.jpg"));
-    assertEquals("application/pdf", URLConnection.guessContentTypeFromName("stuff.pdf"));
-  }
-
-  @Test public void connectionsArePooled() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDEFGHIJKLMNOPQR");
-
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/foo").url()));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/bar?baz=quux").url()));
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/z").url()));
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void chunkedConnectionsArePooled() throws Exception {
-    MockResponse response = new MockResponse().setChunkedBody("ABCDEFGHIJKLMNOPQR", 5);
-
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/foo").url()));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/bar?baz=quux").url()));
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/z").url()));
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void serverClosesSocket() throws Exception {
-    testServerClosesOutput(DISCONNECT_AT_END);
-  }
-
-  @Test public void serverShutdownInput() throws Exception {
-    testServerClosesOutput(SHUTDOWN_INPUT_AT_END);
-  }
-
-  @Test public void serverShutdownOutput() throws Exception {
-    testServerClosesOutput(SHUTDOWN_OUTPUT_AT_END);
-  }
-
-  @Test public void invalidHost() throws Exception {
-    // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
-    URL url = new URL("http://1234.1.1.1/index.html");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new FakeDns())
-        .build());
-    HttpURLConnection connection = urlFactory.open(url);
-    try {
-      connection.connect();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception {
-    server.enqueue(new MockResponse().setBody("This connection won't pool properly")
-        .setSocketPolicy(socketPolicy));
-    MockResponse responseAfter = new MockResponse().setBody("This comes after a busted connection");
-    server.enqueue(responseAfter);
-    server.enqueue(responseAfter); // Enqueue 2x because the broken connection may be reused.
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/a").url());
-    connection1.setReadTimeout(100);
-    assertContent("This connection won't pool properly", connection1);
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-
-    // Give the server time to enact the socket policy if it's one that could happen after the
-    // client has received the response.
-    Thread.sleep(500);
-
-    HttpURLConnection connection2 = urlFactory.open(server.url("/b").url());
-    connection2.setReadTimeout(100);
-    assertContent("This comes after a busted connection", connection2);
-
-    // Check that a fresh connection was created, either immediately or after attempting reuse.
-    RecordedRequest requestAfter = server.takeRequest();
-    if (server.getRequestCount() == 3) {
-      requestAfter = server.takeRequest(); // The failure consumed a response.
-    }
-    // sequence number 0 means the HTTP socket connection was not reused
-    assertEquals(0, requestAfter.getSequenceNumber());
-  }
-
-  enum WriteKind {BYTE_BY_BYTE, SMALL_BUFFERS, LARGE_BUFFERS}
-
-  @Test public void chunkedUpload_byteByByte() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.BYTE_BY_BYTE);
-  }
-
-  @Test public void chunkedUpload_smallBuffers() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.SMALL_BUFFERS);
-  }
-
-  @Test public void chunkedUpload_largeBuffers() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.LARGE_BUFFERS);
-  }
-
-  @Test public void fixedLengthUpload_byteByByte() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.BYTE_BY_BYTE);
-  }
-
-  @Test public void fixedLengthUpload_smallBuffers() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.SMALL_BUFFERS);
-  }
-
-  @Test public void fixedLengthUpload_largeBuffers() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.LARGE_BUFFERS);
-  }
-
-  private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Exception {
-    int n = 512 * 1024;
-    server.setBodyLimit(0);
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection conn = urlFactory.open(server.url("/").url());
-    conn.setDoOutput(true);
-    conn.setRequestMethod("POST");
-    if (uploadKind == TransferKind.CHUNKED) {
-      conn.setChunkedStreamingMode(-1);
-    } else {
-      conn.setFixedLengthStreamingMode(n);
-    }
-    OutputStream out = conn.getOutputStream();
-    if (writeKind == WriteKind.BYTE_BY_BYTE) {
-      for (int i = 0; i < n; ++i) {
-        out.write('x');
-      }
-    } else {
-      byte[] buf = new byte[writeKind == WriteKind.SMALL_BUFFERS ? 256 : 64 * 1024];
-      Arrays.fill(buf, (byte) 'x');
-      for (int i = 0; i < n; i += buf.length) {
-        out.write(buf, 0, Math.min(buf.length, n - i));
-      }
-    }
-    out.close();
-    assertEquals(200, conn.getResponseCode());
-    RecordedRequest request = server.takeRequest();
-    assertEquals(n, request.getBodySize());
-    if (uploadKind == TransferKind.CHUNKED) {
-      assertTrue(request.getChunkSizes().size() > 0);
-    } else {
-      assertTrue(request.getChunkSizes().isEmpty());
-    }
-  }
-
-  @Test public void getResponseCodeNoResponseBody() throws Exception {
-    server.enqueue(new MockResponse().addHeader("abc: def"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection conn = urlFactory.open(url);
-    conn.setDoInput(false);
-    assertEquals("def", conn.getHeaderField("abc"));
-    assertEquals(200, conn.getResponseCode());
-    try {
-      conn.getInputStream();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void connectViaHttps() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    connection = urlFactory.open(server.url("/foo").url());
-
-    assertContent("this response comes via HTTPS", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-  }
-
-  @Test public void inspectHandshakeThroughoutRequestLifecycle() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse());
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-
-    HttpsURLConnection httpsConnection
-        = (HttpsURLConnection) urlFactory.open(server.url("/foo").url());
-
-    // Prior to calling connect(), getting the cipher suite is forbidden.
-    try {
-      httpsConnection.getCipherSuite();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    // Calling connect establishes a handshake...
-    httpsConnection.connect();
-    assertNotNull(httpsConnection.getCipherSuite());
-
-    // ...which remains after we read the response body...
-    assertContent("", httpsConnection);
-    assertNotNull(httpsConnection.getCipherSuite());
-
-    // ...and after we disconnect.
-    httpsConnection.disconnect();
-    assertNotNull(httpsConnection.getCipherSuite());
-  }
-
-  @Test public void connectViaHttpsReusingConnections() throws Exception {
-    connectViaHttpsReusingConnections(false);
-  }
-
-  @Test public void connectViaHttpsReusingConnectionsAfterRebuildingClient() throws Exception {
-    connectViaHttpsReusingConnections(true);
-  }
-
-  private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-    server.enqueue(new MockResponse().setBody("another response via HTTPS"));
-
-    // The pool will only reuse sockets if the SSL socket factories are the same.
-    SSLSocketFactory clientSocketFactory = sslClient.socketFactory;
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    CookieJar cookieJar = new JavaNetCookieJar(new CookieManager());
-    ConnectionPool connectionPool = new ConnectionPool();
-
-    urlFactory.setClient(new OkHttpClient.Builder()
-        .cache(cache)
-        .connectionPool(connectionPool)
-        .cookieJar(cookieJar)
-        .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertContent("this response comes via HTTPS", connection);
-
-    if (rebuildClient) {
-      urlFactory.setClient(new OkHttpClient.Builder()
-          .cache(cache)
-          .connectionPool(connectionPool)
-          .cookieJar(cookieJar)
-          .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
-          .hostnameVerifier(hostnameVerifier)
-          .build());
-    }
-
-    connection = urlFactory.open(server.url("/").url());
-    assertContent("another response via HTTPS", connection);
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectViaHttpsReusingConnectionsDifferentFactories() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-    server.enqueue(new MockResponse().setBody("another response via HTTPS"));
-
-    // install a custom SSL socket factory so the server can be authorized
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    assertContent("this response comes via HTTPS", connection1);
-
-    SSLContext sslContext2 = SSLContext.getInstance("TLS");
-    sslContext2.init(null, null, null);
-    SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
-
-    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-        TrustManagerFactory.getDefaultAlgorithm());
-    trustManagerFactory.init((KeyStore) null);
-    X509TrustManager trustManager = (X509TrustManager) trustManagerFactory.getTrustManagers()[0];
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslSocketFactory2, trustManager)
-        .build());
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    try {
-      readAscii(connection2.getInputStream(), Integer.MAX_VALUE);
-      fail("without an SSL socket factory, the connection should fail");
-    } catch (SSLException expected) {
-    }
-  }
-
-  // TODO(jwilson): tests below this marker need to be migrated to OkHttp's request/response API.
-
-  @Test public void connectViaHttpsWithSSLFallback() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("this response comes via SSL"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
-        .build());
-    connection = urlFactory.open(server.url("/foo").url());
-
-    assertContent("this response comes via SSL", connection);
-
-    RecordedRequest failHandshakeRequest = server.takeRequest();
-    assertNull(failHandshakeRequest.getRequestLine());
-
-    RecordedRequest fallbackRequest = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", fallbackRequest.getRequestLine());
-    assertEquals(TlsVersion.TLS_1_0, fallbackRequest.getTlsVersion());
-  }
-
-  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new SingleInetAddressDns())
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
-        .build());
-    connection = urlFactory.open(server.url("/foo").url());
-
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-      assertEquals(1, expected.getSuppressed().length);
-    }
-  }
-
-  /**
-   * When a pooled connection fails, don't blame the route. Otherwise pooled connection failures can
-   * cause unnecessary SSL fallbacks.
-   *
-   * https://github.com/square/okhttp/issues/515
-   */
-  @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .setSocketPolicy(DISCONNECT_AT_END));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
-        .build());
-
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-
-    // Give the server time to disconnect.
-    Thread.sleep(500);
-
-    assertContent("def", urlFactory.open(server.url("/").url()));
-
-    Set<TlsVersion> tlsVersions =
-        EnumSet.of(TlsVersion.TLS_1_0, TlsVersion.TLS_1_2); // v1.2 on OpenJDK 8.
-
-    RecordedRequest request1 = server.takeRequest();
-    assertTrue(tlsVersions.contains(request1.getTlsVersion()));
-
-    RecordedRequest request2 = server.takeRequest();
-    assertTrue(tlsVersions.contains(request2.getTlsVersion()));
-  }
-
-  /**
-   * Verify that we don't retry connections on certificate verification errors.
-   *
-   * http://code.google.com/p/android/issues/detail?id=13178
-   */
-  @Test public void connectViaHttpsToUntrustedServer() throws IOException, InterruptedException {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse()); // unused
-
-    connection = urlFactory.open(server.url("/foo").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (SSLHandshakeException expected) {
-      assertTrue(expected.getCause() instanceof CertificateException);
-    }
-    assertEquals(0, server.getRequestCount());
-  }
-
-  @Test public void connectViaProxyUsingProxyArg() throws Exception {
-    testConnectViaProxy(ProxyConfig.CREATE_ARG);
-  }
-
-  @Test public void connectViaProxyUsingProxySystemProperty() throws Exception {
-    testConnectViaProxy(ProxyConfig.PROXY_SYSTEM_PROPERTY);
-  }
-
-  @Test public void connectViaProxyUsingHttpProxySystemProperty() throws Exception {
-    testConnectViaProxy(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
-  }
-
-  private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
-    MockResponse mockResponse = new MockResponse().setBody("this response comes via a proxy");
-    server.enqueue(mockResponse);
-
-    URL url = new URL("http://android.com/foo");
-    connection = proxyConfig.connect(server, urlFactory, url);
-    assertContent("this response comes via a proxy", connection);
-    assertTrue(connection.usingProxy());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET http://android.com/foo HTTP/1.1", request.getRequestLine());
-    assertEquals("android.com", request.getHeader("Host"));
-  }
-
-  @Test public void contentDisagreesWithContentLengthHeaderBodyTooLong() throws IOException {
-    server.enqueue(new MockResponse().setBody("abc\r\nYOU SHOULD NOT SEE THIS")
-        .clearHeaders()
-        .addHeader("Content-Length: 3"));
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-  }
-
-  @Test public void contentDisagreesWithContentLengthHeaderBodyTooShort() throws IOException {
-    server.enqueue(new MockResponse().setBody("abc")
-        .setHeader("Content-Length", "5")
-        .setSocketPolicy(DISCONNECT_AT_END));
-    try {
-      readAscii(urlFactory.open(server.url("/").url()).getInputStream(), 5);
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  public void testConnectViaSocketFactory(boolean useHttps) throws IOException {
-    SocketFactory uselessSocketFactory = new SocketFactory() {
-      public Socket createSocket() {
-        throw new IllegalArgumentException("useless");
-      }
-
-      public Socket createSocket(InetAddress host, int port) {
-        return null;
-      }
-
-      public Socket createSocket(InetAddress address, int port, InetAddress localAddress,
-          int localPort) {
-        return null;
-      }
-
-      public Socket createSocket(String host, int port) {
-        return null;
-      }
-
-      public Socket createSocket(String host, int port, InetAddress localHost, int localPort) {
-        return null;
-      }
-    };
-
-    if (useHttps) {
-      server.useHttps(sslClient.socketFactory, false);
-      urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-          .hostnameVerifier(new RecordingHostnameVerifier())
-          .build());
-    }
-
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .socketFactory(uselessSocketFactory)
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .socketFactory(SocketFactory.getDefault())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(200, connection.getResponseCode());
-  }
-
-  @Test public void connectHttpViaSocketFactory() throws Exception {
-    testConnectViaSocketFactory(false);
-  }
-
-  @Test public void connectHttpsViaSocketFactory() throws Exception {
-    testConnectViaSocketFactory(true);
-  }
-
-  @Test public void contentDisagreesWithChunkedHeaderBodyTooLong() throws IOException {
-    MockResponse mockResponse = new MockResponse();
-    mockResponse.setChunkedBody("abc", 3);
-    Buffer buffer = mockResponse.getBody();
-    buffer.writeUtf8("\r\nYOU SHOULD NOT SEE THIS");
-    mockResponse.setBody(buffer);
-    mockResponse.clearHeaders();
-    mockResponse.addHeader("Transfer-encoding: chunked");
-
-    server.enqueue(mockResponse);
-
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-  }
-
-  @Test public void contentDisagreesWithChunkedHeaderBodyTooShort() throws IOException {
-    MockResponse mockResponse = new MockResponse();
-    mockResponse.setChunkedBody("abcde", 5);
-
-    Buffer truncatedBody = new Buffer();
-    Buffer fullBody = mockResponse.getBody();
-    truncatedBody.write(fullBody, fullBody.indexOf((byte) 'e'));
-    mockResponse.setBody(truncatedBody);
-
-    mockResponse.clearHeaders();
-    mockResponse.addHeader("Transfer-encoding: chunked");
-    mockResponse.setSocketPolicy(DISCONNECT_AT_END);
-
-    server.enqueue(mockResponse);
-
-    try {
-      readAscii(urlFactory.open(server.url("/").url()).getInputStream(), 5);
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingProxyArgWithNoProxy() throws Exception {
-    testConnectViaDirectProxyToHttps(ProxyConfig.NO_PROXY);
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingHttpProxySystemProperty() throws Exception {
-    // https should not use http proxy
-    testConnectViaDirectProxyToHttps(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
-  }
-
-  private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-
-    URL url = server.url("/foo").url();
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    connection = proxyConfig.connect(server, urlFactory, url);
-
-    assertContent("this response comes via HTTPS", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingProxyArg() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.CREATE_ARG);
-  }
-
-  /**
-   * We weren't honoring all of the appropriate proxy system properties when connecting via HTTPS.
-   * http://b/3097518
-   */
-  @Test public void connectViaHttpProxyToHttpsUsingProxySystemProperty() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.PROXY_SYSTEM_PROPERTY);
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingHttpsProxySystemProperty() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.HTTPS_PROXY_SYSTEM_PROPERTY);
-  }
-
-  /**
-   * We were verifying the wrong hostname when connecting to an HTTPS site through a proxy.
-   * http://b/3097277
-   */
-  private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(sslClient.socketFactory, true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
-
-    URL url = new URL("https://android.com/foo");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-    connection = proxyConfig.connect(server, urlFactory, url);
-
-    assertContent("this response comes via a secure proxy", connection);
-
-    RecordedRequest connect = server.takeRequest();
-    assertEquals("Connect line failure on proxy", "CONNECT android.com:443 HTTP/1.1",
-        connect.getRequestLine());
-    assertEquals("android.com:443", connect.getHeader("Host"));
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
-    assertEquals("android.com", get.getHeader("Host"));
-    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
-  }
-
-  /** Tolerate bad https proxy response when using HttpResponseCache. Android bug 6754912. */
-  @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
-    initResponseCache();
-
-    server.useHttps(sslClient.socketFactory, true);
-    // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
-    MockResponse badProxyResponse = new MockResponse()
-        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
-        .setBody("bogus proxy connect response content");
-    server.enqueue(badProxyResponse);
-    server.enqueue(new MockResponse().setBody("response"));
-
-    // Configure a single IP address for the host and a single configuration, so we only need one
-    // failure to fail permanently.
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new SingleInetAddressDns())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .proxy(server.toProxyAddress())
-        .build());
-
-    URL url = new URL("https://android.com/foo");
-    connection = urlFactory.open(url);
-    assertContent("response", connection);
-
-    RecordedRequest connect = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
-    assertEquals("android.com:443", connect.getHeader("Host"));
-  }
-
-  private void initResponseCache() throws IOException {
-    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .cache(cache)
-        .build());
-  }
-
-  /** Test which headers are sent unencrypted to the HTTP proxy. */
-  @Test public void proxyConnectIncludesProxyHeadersOnly()
-      throws IOException, InterruptedException {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(sslClient.socketFactory, true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-
-    URL url = new URL("https://android.com/foo");
-    connection = urlFactory.open(url);
-    connection.addRequestProperty("Private", "Secret");
-    connection.addRequestProperty("Proxy-Authorization", "bar");
-    connection.addRequestProperty("User-Agent", "baz");
-    assertContent("encrypted response from the origin server", connection);
-
-    RecordedRequest connect = server.takeRequest();
-    assertNull(connect.getHeader("Private"));
-    assertNull(connect.getHeader("Proxy-Authorization"));
-    assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
-    assertEquals("android.com:443", connect.getHeader("Host"));
-    assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("Secret", get.getHeader("Private"));
-    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
-  }
-
-  @Test public void proxyAuthenticateOnConnect() throws Exception {
-    Authenticator.setDefault(new RecordingAuthenticator());
-    server.useHttps(sslClient.socketFactory, true);
-    server.enqueue(new MockResponse().setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
-    server.enqueue(
-        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("A"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxyAuthenticator(new JavaNetAuthenticator())
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-
-    URL url = new URL("https://android.com/foo");
-    connection = urlFactory.open(url);
-    assertContent("A", connection);
-
-    RecordedRequest connect1 = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect1.getRequestLine());
-    assertNull(connect1.getHeader("Proxy-Authorization"));
-
-    RecordedRequest connect2 = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect2.getRequestLine());
-    assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-        connect2.getHeader("Proxy-Authorization"));
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
-    assertNull(get.getHeader("Proxy-Authorization"));
-  }
-
-  // Don't disconnect after building a tunnel with CONNECT
-  // http://code.google.com/p/android/issues/detail?id=37221
-  @Test public void proxyWithConnectionClose() throws IOException {
-    server.useHttps(sslClient.socketFactory, true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-
-    URL url = new URL("https://android.com/foo");
-    connection = urlFactory.open(url);
-    connection.setRequestProperty("Connection", "close");
-
-    assertContent("this response comes via a proxy", connection);
-  }
-
-  @Test public void proxyWithConnectionReuse() throws IOException {
-    SSLSocketFactory socketFactory = sslClient.socketFactory;
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(socketFactory, true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("response 1"));
-    server.enqueue(new MockResponse().setBody("response 2"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-    URL url = new URL("https://android.com/foo");
-    assertContent("response 1", urlFactory.open(url));
-    assertContent("response 2", urlFactory.open(url));
-  }
-
-  @Test public void disconnectedConnection() throws IOException {
-    server.enqueue(new MockResponse()
-        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
-        .setBody("ABCD"));
-
-    connection = urlFactory.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals('A', (char) in.read());
-    connection.disconnect();
-    try {
-      // Reading 'B' may succeed if it's buffered.
-      in.read();
-
-      // But 'C' shouldn't be buffered (the response is throttled) and this should fail.
-      in.read();
-      fail("Expected a connection closed exception");
-    } catch (IOException expected) {
-    }
-    in.close();
-  }
-
-  @Test public void disconnectDuringConnect_cookieJar() throws Exception {
-    final AtomicReference<HttpURLConnection> connectionHolder = new AtomicReference<>();
-    class DisconnectingCookieJar implements CookieJar {
-      @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) { }
-      @Override
-      public List<Cookie> loadForRequest(HttpUrl url) {
-        connectionHolder.get().disconnect();
-        return Collections.emptyList();
-      }
-    }
-    OkHttpClient client = new okhttp3.OkHttpClient.Builder()
-            .cookieJar(new DisconnectingCookieJar())
-            .build();
-
-    URL url = server.url("path that should never be accessed").url();
-    HttpURLConnection connection = new OkHttpURLConnection(url, client);
-    connectionHolder.set(connection);
-    try {
-      connection.getInputStream();
-      fail("Connection should not be established");
-    } catch (IOException expected) {
-      assertEquals("Canceled", expected.getMessage());
-    } finally {
-      connection.disconnect();
-    }
-  }
-
-  @Test public void disconnectBeforeConnect() throws IOException {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.disconnect();
-    assertContent("A", connection);
-    assertEquals(200, connection.getResponseCode());
-  }
-
-  @SuppressWarnings("deprecation") @Test public void defaultRequestProperty() throws Exception {
-    URLConnection.setDefaultRequestProperty("X-testSetDefaultRequestProperty", "A");
-    assertNull(URLConnection.getDefaultRequestProperty("X-setDefaultRequestProperty"));
-  }
-
-  /**
-   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
-   * characters can be read, the remaining characters are returned and the stream is closed.
-   */
-  private String readAscii(InputStream in, int count) throws IOException {
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  @Test public void markAndResetWithContentLengthHeader() throws IOException {
-    testMarkAndReset(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void markAndResetWithChunkedEncoding() throws IOException {
-    testMarkAndReset(TransferKind.CHUNKED);
-  }
-
-  @Test public void markAndResetWithNoLengthHeaders() throws IOException {
-    testMarkAndReset(TransferKind.END_OF_STREAM);
-  }
-
-  private void testMarkAndReset(TransferKind transferKind) throws IOException {
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    InputStream in = urlFactory.open(server.url("/").url()).getInputStream();
-    assertFalse("This implementation claims to support mark().", in.markSupported());
-    in.mark(5);
-    assertEquals("ABCDE", readAscii(in, 5));
-    try {
-      in.reset();
-      fail();
-    } catch (IOException expected) {
-    }
-    assertEquals("FGHIJKLMNOPQRSTUVWXYZ", readAscii(in, Integer.MAX_VALUE));
-    in.close();
-    assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", urlFactory.open(server.url("/").url()));
-  }
-
-  /**
-   * We've had a bug where we forget the HTTP response when we see response code 401. This causes a
-   * new HTTP request to be issued for every call into the URLConnection.
-   */
-  @Test public void unauthorizedResponseHandling() throws IOException {
-    MockResponse response = new MockResponse().addHeader("WWW-Authenticate: challenge")
-        .setResponseCode(401) // UNAUTHORIZED
-        .setBody("Unauthorized");
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    URL url = server.url("/").url();
-    HttpURLConnection conn = urlFactory.open(url);
-
-    assertEquals(401, conn.getResponseCode());
-    assertEquals(401, conn.getResponseCode());
-    assertEquals(401, conn.getResponseCode());
-    assertEquals(1, server.getRequestCount());
-    conn.getErrorStream().close();
-  }
-
-  @Test public void nonHexChunkSize() throws IOException {
-    server.enqueue(new MockResponse().setBody("5\r\nABCDE\r\nG\r\nFGHIJKLMNOPQRSTU\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException e) {
-    }
-    connection.getInputStream().close();
-  }
-
-  @Test public void malformedChunkSize() throws IOException {
-    server.enqueue(new MockResponse().setBody("5:x\r\nABCDE\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException e) {
-    } finally {
-      connection.getInputStream().close();
-    }
-  }
-
-  @Test public void extensionAfterChunkSize() throws IOException {
-    server.enqueue(new MockResponse().setBody("5;x\r\nABCDE\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertContent("ABCDE", connection);
-  }
-
-  @Test public void missingChunkBody() throws IOException {
-    server.enqueue(new MockResponse().setBody("5")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked")
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException e) {
-    } finally {
-      connection.getInputStream().close();
-    }
-  }
-
-  /**
-   * This test checks whether connections are gzipped by default. This behavior in not required by
-   * the API, so a failure of this test does not imply a bug in the implementation.
-   */
-  @Test public void gzipEncodingEnabledByDefault() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("ABCABCABC", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    assertNull(connection.getContentEncoding());
-    assertEquals(-1, connection.getContentLength());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("gzip", request.getHeader("Accept-Encoding"));
-  }
-
-  @Test public void clientConfiguredGzipContentEncoding() throws Exception {
-    Buffer bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
-    server.enqueue(new MockResponse()
-        .setBody(bodyBytes)
-        .addHeader("Content-Encoding: gzip"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Accept-Encoding", "gzip");
-    InputStream gunzippedIn = new GZIPInputStream(connection.getInputStream());
-    assertEquals("ABCDEFGHIJKLMNOPQRSTUVWXYZ", readAscii(gunzippedIn, Integer.MAX_VALUE));
-    assertEquals(bodyBytes.size(), connection.getContentLength());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("gzip", request.getHeader("Accept-Encoding"));
-  }
-
-  @Test public void gzipAndConnectionReuseWithFixedLength() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, false);
-  }
-
-  @Test public void gzipAndConnectionReuseWithChunkedEncoding() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, false);
-  }
-
-  @Test public void gzipAndConnectionReuseWithFixedLengthAndTls() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, true);
-  }
-
-  @Test public void gzipAndConnectionReuseWithChunkedEncodingAndTls() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, true);
-  }
-
-  @Test public void clientConfiguredCustomContentEncoding() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE").addHeader("Content-Encoding: custom"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Accept-Encoding", "custom");
-    assertEquals("ABCDE", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("custom", request.getHeader("Accept-Encoding"));
-  }
-
-  /**
-   * Test a bug where gzip input streams weren't exhausting the input stream, which corrupted the
-   * request that followed or prevented connection reuse.
-   * http://code.google.com/p/android/issues/detail?id=7059
-   * http://code.google.com/p/android/issues/detail?id=38817
-   */
-  private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind transferKind,
-      boolean tls) throws Exception {
-    if (tls) {
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
-      RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-      server.useHttps(socketFactory, false);
-      urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(socketFactory, sslClient.trustManager)
-          .hostnameVerifier(hostnameVerifier)
-          .build());
-    }
-
-    MockResponse responseOne = new MockResponse();
-    responseOne.addHeader("Content-Encoding: gzip");
-    transferKind.setBody(responseOne, gzip("one (gzipped)"), 5);
-    server.enqueue(responseOne);
-    MockResponse responseTwo = new MockResponse();
-    transferKind.setBody(responseTwo, "two (identity)", 5);
-    server.enqueue(responseTwo);
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    connection1.addRequestProperty("Accept-Encoding", "gzip");
-    InputStream gunzippedIn = new GZIPInputStream(connection1.getInputStream());
-    assertEquals("one (gzipped)", readAscii(gunzippedIn, Integer.MAX_VALUE));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertEquals("two (identity)", readAscii(connection2.getInputStream(), Integer.MAX_VALUE));
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void transparentGzipWorksAfterExceptionRecovery() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("a")
-        .setSocketPolicy(SHUTDOWN_INPUT_AT_END));
-    server.enqueue(new MockResponse()
-        .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("b")));
-
-    // Seed the pool with a bad connection.
-    assertContent("a", urlFactory.open(server.url("/").url()));
-
-    // Give the server time to disconnect.
-    Thread.sleep(500);
-
-    // This connection will need to be recovered. When it is, transparent gzip should still work!
-    assertContent("b", urlFactory.open(server.url("/").url()));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
-  }
-
-  @Test public void endOfStreamResponseIsNotPooled() throws Exception {
-    urlFactory.client().connectionPool().evictAll();
-    server.enqueue(new MockResponse()
-        .setBody("{}")
-        .clearHeaders()
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertContent("{}", connection);
-    assertEquals(0, urlFactory.client().connectionPool().idleConnectionCount());
-  }
-
-  @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
-    testEarlyDisconnectDoesntHarmPooling(TransferKind.CHUNKED);
-  }
-
-  @Test public void earlyDisconnectDoesntHarmPoolingWithFixedLengthEncoding() throws Exception {
-    testEarlyDisconnectDoesntHarmPooling(TransferKind.FIXED_LENGTH);
-  }
-
-  private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) throws Exception {
-    MockResponse response1 = new MockResponse();
-    transferKind.setBody(response1, "ABCDEFGHIJK", 1024);
-    server.enqueue(response1);
-
-    MockResponse response2 = new MockResponse();
-    transferKind.setBody(response2, "LMNOPQRSTUV", 1024);
-    server.enqueue(response2);
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    InputStream in1 = connection1.getInputStream();
-    assertEquals("ABCDE", readAscii(in1, 5));
-    in1.close();
-    connection1.disconnect();
-
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    InputStream in2 = connection2.getInputStream();
-    assertEquals("LMNOP", readAscii(in2, 5));
-    in2.close();
-    connection2.disconnect();
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection is pooled!
-  }
-
-  @Test public void streamDiscardingIsTimely() throws Exception {
-    // This response takes at least a full second to serve: 10,000 bytes served 100 bytes at a time.
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[10000]))
-        .throttleBody(100, 10, MILLISECONDS));
-    server.enqueue(new MockResponse().setBody("A"));
-
-    long startNanos = System.nanoTime();
-    URLConnection connection1 = urlFactory.open(server.url("/").url());
-    InputStream in = connection1.getInputStream();
-    in.close();
-    long elapsedNanos = System.nanoTime() - startNanos;
-    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-
-    // If we're working correctly, this should be greater than 100ms, but less than double that.
-    // Previously we had a bug where we would download the entire response body as long as no
-    // individual read took longer than 100ms.
-    assertTrue(Util.format("Time to close: %sms", elapsedMillis), elapsedMillis < 500);
-
-    // Do another request to confirm that the discarded connection was not pooled.
-    assertContent("A", urlFactory.open(server.url("/").url()));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
-  }
-
-  @Test public void setChunkedStreamingMode() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse());
-
-    String body = "ABCDEFGHIJKLMNOPQ";
-    connection = urlFactory.open(server.url("/").url());
-    connection.setChunkedStreamingMode(0); // OkHttp does not honor specific chunk sizes.
-    connection.setDoOutput(true);
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(body.getBytes("US-ASCII"));
-    assertEquals(200, connection.getResponseCode());
-    connection.getInputStream().close();
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(body, request.getBody().readUtf8());
-    assertEquals(Arrays.asList(body.length()), request.getChunkSizes());
-  }
-
-  @Test public void authenticateWithFixedLengthStreaming() throws Exception {
-    testAuthenticateWithStreamingPost(StreamingMode.FIXED_LENGTH);
-  }
-
-  @Test public void authenticateWithChunkedStreaming() throws Exception {
-    testAuthenticateWithStreamingPost(StreamingMode.CHUNKED);
-  }
-
-  private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    byte[] requestBody = {'A', 'B', 'C', 'D'};
-    if (streamingMode == StreamingMode.FIXED_LENGTH) {
-      connection.setFixedLengthStreamingMode(requestBody.length);
-    } else if (streamingMode == StreamingMode.CHUNKED) {
-      connection.setChunkedStreamingMode(0);
-    }
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (HttpRetryException expected) {
-    }
-
-    // no authorization header for the request...
-    RecordedRequest request = server.takeRequest();
-    assertNull(request.getHeader("Authorization"));
-    assertEquals("ABCD", request.getBody().readUtf8());
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(401));
-    server.enqueue(new MockResponse());
-
-    String credential = Credentials.basic("jesse", "secret");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
-        .build());
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(body.getBytes("UTF-8"));
-    outputStream.close();
-    assertEquals(200, connection.getResponseCode());
-    connection.getInputStream().close();
-
-    RecordedRequest recordedRequest1 = server.takeRequest();
-    assertEquals("POST", recordedRequest1.getMethod());
-    assertEquals(body, recordedRequest1.getBody().readUtf8());
-    assertNull(recordedRequest1.getHeader("Authorization"));
-
-    RecordedRequest recordedRequest2 = server.takeRequest();
-    assertEquals("POST", recordedRequest2.getMethod());
-    assertEquals(body, recordedRequest2.getBody().readUtf8());
-    assertEquals(credential, recordedRequest2.getHeader("Authorization"));
-  }
-
-  @Test public void nonStandardAuthenticationScheme() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo");
-    assertEquals(Collections.<String>emptyList(), calls);
-  }
-
-  @Test public void nonStandardAuthenticationSchemeWithRealm() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo realm=\"Bar\"");
-    assertEquals(0, calls.size());
-  }
-
-  // Digest auth is currently unsupported. Test that digest requests should fail reasonably.
-  // http://code.google.com/p/android/issues/detail?id=11140
-  @Test public void digestAuthentication() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Digest "
-        + "realm=\"testrealm@host.com\", qop=\"auth,auth-int\", "
-        + "nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", "
-        + "opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"");
-    assertEquals(0, calls.size());
-  }
-
-  @Test public void allAttributesSetInServerAuthenticationCallbacks() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Basic realm=\"Bar\"");
-    assertEquals(1, calls.size());
-    URL url = server.url("/").url();
-    String call = calls.get(0);
-    assertTrue(call, call.contains("host=" + url.getHost()));
-    assertTrue(call, call.contains("port=" + url.getPort()));
-    assertTrue(call, call.contains("site=" + url.getHost()));
-    assertTrue(call, call.contains("url=" + url));
-    assertTrue(call, call.contains("type=" + Authenticator.RequestorType.SERVER));
-    assertTrue(call, call.contains("prompt=Bar"));
-    assertTrue(call, call.contains("protocol=http"));
-    assertTrue(call, call.toLowerCase().contains("scheme=basic")); // lowercase for the RI.
-  }
-
-  @Test public void allAttributesSetInProxyAuthenticationCallbacks() throws Exception {
-    List<String> calls = authCallsForHeader("Proxy-Authenticate: Basic realm=\"Bar\"");
-    assertEquals(1, calls.size());
-    URL url = server.url("/").url();
-    String call = calls.get(0);
-    assertTrue(call, call.contains("host=" + url.getHost()));
-    assertTrue(call, call.contains("port=" + url.getPort()));
-    assertTrue(call, call.contains("site=" + url.getHost()));
-    assertTrue(call, call.contains("url=http://android.com"));
-    assertTrue(call, call.contains("type=" + Authenticator.RequestorType.PROXY));
-    assertTrue(call, call.contains("prompt=Bar"));
-    assertTrue(call, call.contains("protocol=http"));
-    assertTrue(call, call.toLowerCase().contains("scheme=basic")); // lowercase for the RI.
-  }
-
-  private List<String> authCallsForHeader(String authHeader) throws IOException {
-    boolean proxy = authHeader.startsWith("Proxy-");
-    int responseCode = proxy ? 407 : 401;
-    RecordingAuthenticator authenticator = new RecordingAuthenticator(null);
-    Authenticator.setDefault(authenticator);
-    MockResponse pleaseAuthenticate = new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader(authHeader)
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-
-    if (proxy) {
-      urlFactory.setClient(urlFactory.client().newBuilder()
-          .proxy(server.toProxyAddress())
-          .proxyAuthenticator(new JavaNetAuthenticator())
-          .build());
-      connection = urlFactory.open(new URL("http://android.com/"));
-    } else {
-      urlFactory.setClient(urlFactory.client().newBuilder()
-          .authenticator(new JavaNetAuthenticator())
-          .build());
-      connection = urlFactory.open(server.url("/").url());
-    }
-    assertEquals(responseCode, connection.getResponseCode());
-    connection.getErrorStream().close();
-    return authenticator.calls;
-  }
-
-  @Test public void setValidRequestMethod() throws Exception {
-    assertValidRequestMethod("GET");
-    assertValidRequestMethod("DELETE");
-    assertValidRequestMethod("HEAD");
-    assertValidRequestMethod("OPTIONS");
-    assertValidRequestMethod("POST");
-    assertValidRequestMethod("PUT");
-    assertValidRequestMethod("TRACE");
-    assertValidRequestMethod("PATCH");
-  }
-
-  private void assertValidRequestMethod(String requestMethod) throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    connection.setRequestMethod(requestMethod);
-    assertEquals(requestMethod, connection.getRequestMethod());
-  }
-
-  @Test public void setInvalidRequestMethodLowercase() throws Exception {
-    assertInvalidRequestMethod("get");
-  }
-
-  @Test public void setInvalidRequestMethodConnect() throws Exception {
-    assertInvalidRequestMethod("CONNECT");
-  }
-
-  private void assertInvalidRequestMethod(String requestMethod) throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.setRequestMethod(requestMethod);
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void shoutcast() throws Exception {
-    server.enqueue(new MockResponse().setStatus("ICY 200 OK")
-        // .addHeader("HTTP/1.0 200 OK")
-        .addHeader("Accept-Ranges: none")
-        .addHeader("Content-Type: audio/mpeg")
-        .addHeader("icy-br:128")
-        .addHeader("ice-audio-info: bitrate=128;samplerate=44100;channels=2")
-        .addHeader("icy-br:128")
-        .addHeader("icy-description:Rock")
-        .addHeader("icy-genre:riders")
-        .addHeader("icy-name:A2RRock")
-        .addHeader("icy-pub:1")
-        .addHeader("icy-url:http://www.A2Rradio.com")
-        .addHeader("Server: Icecast 2.3.3-kh8")
-        .addHeader("Cache-Control: no-cache")
-        .addHeader("Pragma: no-cache")
-        .addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT")
-        .addHeader("icy-metaint:16000")
-        .setBody("mp3 data"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("OK", connection.getResponseMessage());
-    assertContent("mp3 data", connection);
-  }
-
-  @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.setFixedLengthStreamingMode(-2);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void canSetNegativeChunkedStreamingMode() throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    connection.setChunkedStreamingMode(-2);
-  }
-
-  @Test public void cannotSetFixedLengthStreamingModeAfterConnect() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    try {
-      connection.setFixedLengthStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cannotSetChunkedStreamingModeAfterConnect() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    try {
-      connection.setChunkedStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    connection.setChunkedStreamingMode(1);
-    try {
-      connection.setFixedLengthStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    connection.setFixedLengthStreamingMode(1);
-    try {
-      connection.setChunkedStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void secureFixedLengthStreaming() throws Exception {
-    testSecureStreamingPost(StreamingMode.FIXED_LENGTH);
-  }
-
-  @Test public void secureChunkedStreaming() throws Exception {
-    testSecureStreamingPost(StreamingMode.CHUNKED);
-  }
-
-  /**
-   * Users have reported problems using HTTPS with streaming request bodies.
-   * http://code.google.com/p/android/issues/detail?id=12860
-   */
-  private void testSecureStreamingPost(StreamingMode streamingMode) throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    byte[] requestBody = {'A', 'B', 'C', 'D'};
-    if (streamingMode == StreamingMode.FIXED_LENGTH) {
-      connection.setFixedLengthStreamingMode(requestBody.length);
-    } else if (streamingMode == StreamingMode.CHUNKED) {
-      connection.setChunkedStreamingMode(0);
-    }
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    assertEquals("Success!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST / HTTP/1.1", request.getRequestLine());
-    if (streamingMode == StreamingMode.FIXED_LENGTH) {
-      assertEquals(Collections.<Integer>emptyList(), request.getChunkSizes());
-    } else if (streamingMode == StreamingMode.CHUNKED) {
-      assertEquals(Arrays.asList(4), request.getChunkSizes());
-    }
-    assertEquals("ABCD", request.getBody().readUtf8());
-  }
-
-  enum StreamingMode {
-    FIXED_LENGTH, CHUNKED
-  }
-
-  @Test public void authenticateWithPost() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    byte[] requestBody = {'A', 'B', 'C', 'D'};
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    // no authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertNull(request.getHeader("Authorization"));
-
-    // ...but the three requests that follow include an authorization header
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertEquals("POST / HTTP/1.1", request.getRequestLine());
-      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-          request.getHeader("Authorization"));
-      assertEquals("ABCD", request.getBody().readUtf8());
-    }
-  }
-
-  @Test public void authenticateWithGet() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    // no authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertNull(request.getHeader("Authorization"));
-
-    // ...but the three requests that follow requests include an authorization header
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertEquals("GET / HTTP/1.1", request.getRequestLine());
-      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-          request.getHeader("Authorization"));
-    }
-  }
-
-  /** https://code.google.com/p/android/issues/detail?id=74026 */
-  @Test public void authenticateWithGetAndTransparentGzip() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time
-    MockResponse successfulResponse = new MockResponse()
-        .addHeader("Content-Encoding", "gzip")
-        .setBody(gzip("Successful auth!"));
-    server.enqueue(successfulResponse);
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    // no authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertNull(request.getHeader("Authorization"));
-
-    // ...but the three requests that follow requests include an authorization header
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertEquals("GET / HTTP/1.1", request.getRequestLine());
-      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-          request.getHeader("Authorization"));
-    }
-  }
-
-  /** https://github.com/square/okhttp/issues/342 */
-  @Test public void authenticateRealmUppercase() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(401)
-        .addHeader("wWw-aUtHeNtIcAtE: bAsIc rEaLm=\"pRoTeCtEd aReA\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  @Test public void redirectedWithChunkedEncoding() throws Exception {
-    testRedirected(TransferKind.CHUNKED, true);
-  }
-
-  @Test public void redirectedWithContentLengthHeader() throws Exception {
-    testRedirected(TransferKind.FIXED_LENGTH, true);
-  }
-
-  @Test public void redirectedWithNoLengthHeaders() throws Exception {
-    testRedirected(TransferKind.END_OF_STREAM, false);
-  }
-
-  private void testRedirected(TransferKind transferKind, boolean reuse) throws Exception {
-    MockResponse response = new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo");
-    transferKind.setBody(response, "This page has moved!", 10);
-    server.enqueue(response);
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("This is the new location!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest first = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", first.getRequestLine());
-    RecordedRequest retry = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", retry.getRequestLine());
-    if (reuse) {
-      assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
-    }
-  }
-
-  @Test public void redirectedOnHttps() throws IOException, InterruptedException {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("This is the new location!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest first = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", first.getRequestLine());
-    RecordedRequest retry = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", retry.getRequestLine());
-    assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
-  }
-
-  @Test public void notRedirectedFromHttpsToHttp() throws IOException, InterruptedException {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: http://anyhost/foo")
-        .setBody("This page has moved!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .followSslRedirects(false)
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  @Test public void notRedirectedFromHttpToHttps() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: https://anyhost/foo")
-        .setBody("This page has moved!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .followSslRedirects(false)
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
-    server2.enqueue(new MockResponse().setBody("This is insecure HTTP!"));
-
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url())
-        .setBody("This page has moved!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .followSslRedirects(true)
-        .build());
-    HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(server.url("/").url());
-    assertContent("This is insecure HTTP!", connection);
-    assertNull(connection.getCipherSuite());
-    assertNull(connection.getLocalCertificates());
-    assertNull(connection.getServerCertificates());
-    assertNull(connection.getPeerPrincipal());
-    assertNull(connection.getLocalPrincipal());
-  }
-
-  @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
-    server2.useHttps(sslClient.socketFactory, false);
-    server2.enqueue(new MockResponse().setBody("This is secure HTTPS!"));
-
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url())
-        .setBody("This page has moved!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .followSslRedirects(true)
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertContent("This is secure HTTPS!", connection);
-    assertFalse(connection instanceof HttpsURLConnection);
-  }
-
-  @Test public void redirectToAnotherOriginServer() throws Exception {
-    redirectToAnotherOriginServer(false);
-  }
-
-  @Test public void redirectToAnotherOriginServerWithHttps() throws Exception {
-    redirectToAnotherOriginServer(true);
-  }
-
-  private void redirectToAnotherOriginServer(boolean https) throws Exception {
-    if (https) {
-      server.useHttps(sslClient.socketFactory, false);
-      server2.useHttps(sslClient.socketFactory, false);
-      server2.setProtocolNegotiationEnabled(false);
-      urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-          .hostnameVerifier(new RecordingHostnameVerifier())
-          .build());
-    }
-
-    server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
-    server2.enqueue(new MockResponse().setBody("This is the 2nd server, again!"));
-
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url().toString())
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the first server again!"));
-
-    connection = urlFactory.open(server.url("/").url());
-    assertContent("This is the 2nd server!", connection);
-    assertEquals(server2.url("/").url(), connection.getURL());
-
-    // make sure the first server was careful to recycle the connection
-    assertContent("This is the first server again!", urlFactory.open(server.url("/").url()));
-    assertContent("This is the 2nd server, again!", urlFactory.open(server2.url("/").url()));
-
-    String server1Host = server.getHostName() + ":" + server.getPort();
-    String server2Host = server2.getHostName() + ":" + server2.getPort();
-    assertEquals(server1Host, server.takeRequest().getHeader("Host"));
-    assertEquals(server2Host, server2.takeRequest().getHeader("Host"));
-    assertEquals("Expected connection reuse", 1, server.takeRequest().getSequenceNumber());
-    assertEquals("Expected connection reuse", 1, server2.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void redirectWithProxySelector() throws Exception {
-    final List<URI> proxySelectionRequests = new ArrayList<>();
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxySelector(new ProxySelector() {
-          @Override public List<Proxy> select(URI uri) {
-            proxySelectionRequests.add(uri);
-            MockWebServer proxyServer = (uri.getPort() == server.getPort())
-                ? server
-                : server2;
-            return Arrays.asList(proxyServer.toProxyAddress());
-          }
-
-          @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
-            throw new AssertionError();
-          }
-        })
-        .build());
-
-    server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
-
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/b").url().toString())
-        .setBody("This page has moved!"));
-
-    assertContent("This is the 2nd server!", urlFactory.open(server.url("/a").url()));
-
-    assertEquals(Arrays.asList(server.url("/").url().toURI(), server2.url("/").url().toURI()),
-        proxySelectionRequests);
-  }
-
-  @Test public void redirectWithAuthentication() throws Exception {
-    server2.enqueue(new MockResponse().setBody("Page 2"));
-
-    server.enqueue(new MockResponse().setResponseCode(401));
-    server.enqueue(new MockResponse().setResponseCode(302)
-        .addHeader("Location: " + server2.url("/b").url()));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
-        .build());
-    assertContent("Page 2", urlFactory.open(server.url("/a").url()));
-
-    RecordedRequest redirectRequest = server2.takeRequest();
-    assertNull(redirectRequest.getHeader("Authorization"));
-    assertEquals("/b", redirectRequest.getPath());
-  }
-
-  @Test public void response300MultipleChoiceWithPost() throws Exception {
-    // Chrome doesn't follow the redirect, but Firefox and the RI both do
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MULT_CHOICE, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response301MovedPermanentlyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_PERM, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response302MovedTemporarilyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response303SeeOtherWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_SEE_OTHER, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void postRedirectToGetWithChunkedRequest() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.CHUNKED);
-  }
-
-  @Test public void postRedirectToGetWithStreamedRequest() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.FIXED_LENGTH);
-  }
-
-  private void testResponseRedirectedWithPost(int redirectCode, TransferKind transferKind)
-      throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(redirectCode)
-        .addHeader("Location: /page2")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    connection = urlFactory.open(server.url("/page1").url());
-    connection.setDoOutput(true);
-    transferKind.setForRequest(connection, 4);
-    byte[] requestBody = {'A', 'B', 'C', 'D'};
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    assertEquals("Page 2", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    assertTrue(connection.getDoOutput());
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
-    assertEquals("ABCD", page1.getBody().readUtf8());
-
-    RecordedRequest page2 = server.takeRequest();
-    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
-  }
-
-  @Test public void redirectedPostStripsRequestBodyHeaders() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /page2"));
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    connection = urlFactory.open(server.url("/page1").url());
-    connection.setDoOutput(true);
-    connection.addRequestProperty("Content-Length", "4");
-    connection.addRequestProperty("Content-Type", "text/plain; charset=utf-8");
-    connection.addRequestProperty("Transfer-Encoding", "identity");
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write("ABCD".getBytes("UTF-8"));
-    outputStream.close();
-    assertEquals("Page 2", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    assertEquals("POST /page1 HTTP/1.1", server.takeRequest().getRequestLine());
-
-    RecordedRequest page2 = server.takeRequest();
-    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
-    assertNull(page2.getHeader("Content-Length"));
-    assertNull(page2.getHeader("Content-Type"));
-    assertNull(page2.getHeader("Transfer-Encoding"));
-  }
-
-  @Test public void response305UseProxy() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_USE_PROXY)
-        .addHeader("Location: " + server.url("/").url())
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("Proxy Response"));
-
-    connection = urlFactory.open(server.url("/foo").url());
-    // Fails on the RI, which gets "Proxy Response"
-    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", page1.getRequestLine());
-    assertEquals(1, server.getRequestCount());
-  }
-
-  @Test public void response307WithGet() throws Exception {
-    testRedirect(true, "GET");
-  }
-
-  @Test public void response307WithHead() throws Exception {
-    testRedirect(true, "HEAD");
-  }
-
-  @Test public void response307WithOptions() throws Exception {
-    testRedirect(true, "OPTIONS");
-  }
-
-  @Test public void response307WithPost() throws Exception {
-    testRedirect(true, "POST");
-  }
-
-  @Test public void response308WithGet() throws Exception {
-    testRedirect(false, "GET");
-  }
-
-  @Test public void response308WithHead() throws Exception {
-    testRedirect(false, "HEAD");
-  }
-
-  @Test public void response308WithOptions() throws Exception {
-    testRedirect(false, "OPTIONS");
-  }
-
-  @Test public void response308WithPost() throws Exception {
-    testRedirect(false, "POST");
-  }
-
-  private void testRedirect(boolean temporary, String method) throws Exception {
-    MockResponse response1 = new MockResponse()
-        .setResponseCode(temporary ? HTTP_TEMP_REDIRECT : HTTP_PERM_REDIRECT)
-        .addHeader("Location: /page2");
-    if (!method.equals("HEAD")) {
-      response1.setBody("This page has moved!");
-    }
-    server.enqueue(response1);
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    connection = urlFactory.open(server.url("/page1").url());
-    connection.setRequestMethod(method);
-    byte[] requestBody = {'A', 'B', 'C', 'D'};
-    if (method.equals("POST")) {
-      connection.setDoOutput(true);
-      OutputStream outputStream = connection.getOutputStream();
-      outputStream.write(requestBody);
-      outputStream.close();
-    }
-
-    String response = readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals(method + " /page1 HTTP/1.1", page1.getRequestLine());
-
-    if (method.equals("GET")) {
-      assertEquals("Page 2", response);
-    } else if (method.equals("HEAD")) {
-      assertEquals("", response);
-    } else {
-      // Methods other than GET/HEAD shouldn't follow the redirect
-      if (method.equals("POST")) {
-        assertTrue(connection.getDoOutput());
-        assertEquals("ABCD", page1.getBody().readUtf8());
-      }
-      assertEquals(1, server.getRequestCount());
-      assertEquals("This page has moved!", response);
-      return;
-    }
-
-    // GET/HEAD requests should have followed the redirect with the same method
-    assertFalse(connection.getDoOutput());
-    assertEquals(2, server.getRequestCount());
-    RecordedRequest page2 = server.takeRequest();
-    assertEquals(method + " /page2 HTTP/1.1", page2.getRequestLine());
-  }
-
-  @Test public void follow20Redirects() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    connection = urlFactory.open(server.url("/0").url());
-    assertContent("Success!", connection);
-    assertEquals(server.url("/20").url(), connection.getURL());
-  }
-
-  @Test public void doesNotFollow21Redirects() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-
-    connection = urlFactory.open(server.url("/0").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (ProtocolException expected) {
-      assertEquals(HttpURLConnection.HTTP_MOVED_TEMP, connection.getResponseCode());
-      assertEquals("Too many follow-up requests: 21", expected.getMessage());
-      assertEquals(server.url("/20").url(), connection.getURL());
-    }
-  }
-
-  @Test public void httpsWithCustomTrustManager() throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    RecordingTrustManager trustManager = new RecordingTrustManager(sslClient.trustManager);
-    SSLContext sslContext = SSLContext.getInstance("TLS");
-    sslContext.init(null, new TrustManager[] { trustManager }, null);
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .hostnameVerifier(hostnameVerifier)
-        .sslSocketFactory(sslContext.getSocketFactory(), trustManager)
-        .build());
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-    server.enqueue(new MockResponse().setBody("GHI"));
-
-    URL url = server.url("/").url();
-    assertContent("ABC", urlFactory.open(url));
-    assertContent("DEF", urlFactory.open(url));
-    assertContent("GHI", urlFactory.open(url));
-
-    assertEquals(Arrays.asList("verify " + server.getHostName()), hostnameVerifier.calls);
-    assertEquals(Arrays.asList("checkServerTrusted [CN=" + server.getHostName() + " 1]"),
-        trustManager.calls);
-  }
-
-  @Test public void getClientRequestTimeout() throws Exception {
-    enqueueClientRequestTimeoutResponses();
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Body", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  private void enqueueClientRequestTimeoutResponses() {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(HttpURLConnection.HTTP_CLIENT_TIMEOUT)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse().setBody("Body"));
-  }
-
-  @Test public void bufferedBodyWithClientRequestTimeout() throws Exception {
-    enqueueClientRequestTimeoutResponses();
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setRequestMethod("POST");
-    connection.getOutputStream().write("Hello".getBytes("UTF-8"));
-
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Body", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("Hello", request1.getBody().readUtf8());
-
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("Hello", request2.getBody().readUtf8());
-  }
-
-  @Test public void streamedBodyWithClientRequestTimeout() throws Exception {
-    enqueueClientRequestTimeoutResponses();
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setRequestMethod("POST");
-    connection.setChunkedStreamingMode(0);
-    connection.getOutputStream().write("Hello".getBytes("UTF-8"));
-
-    assertEquals(408, connection.getResponseCode());
-    assertEquals(1, server.getRequestCount());
-    connection.getErrorStream().close();
-  }
-
-  @Test public void readTimeouts() throws IOException {
-    // This relies on the fact that MockWebServer doesn't close the
-    // connection after a response has been sent. This causes the client to
-    // try to read more bytes than are sent, which results in a timeout.
-    MockResponse timeout =
-        new MockResponse().setBody("ABC").clearHeaders().addHeader("Content-Length: 4");
-    server.enqueue(timeout);
-    server.enqueue(new MockResponse().setBody("unused")); // to keep the server alive
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setReadTimeout(1000);
-    InputStream in = connection.getInputStream();
-    assertEquals('A', in.read());
-    assertEquals('B', in.read());
-    assertEquals('C', in.read());
-    try {
-      in.read(); // if Content-Length was accurate, this would return -1 immediately
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-    in.close();
-  }
-
-  /** Confirm that an unacknowledged write times out. */
-  @Test public void writeTimeouts() throws IOException {
-    MockWebServer server = new MockWebServer();
-    // Sockets on some platforms can have large buffers that mean writes do not block when
-    // required. These socket factories explicitly set the buffer sizes on sockets created.
-    final int SOCKET_BUFFER_SIZE = 4 * 1024;
-    server.setServerSocketFactory(
-        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
-          @Override
-          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
-              throws IOException {
-            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            return serverSocket;
-          }
-        });
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-          @Override protected Socket configureSocket(Socket socket) throws IOException {
-            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-            return socket;
-          }
-        })
-        .writeTimeout(500, TimeUnit.MILLISECONDS)
-        .build());
-
-    server.start();
-    server.enqueue(new MockResponse()
-        .throttleBody(1, 1, TimeUnit.SECONDS)); // Prevent the server from reading!
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    connection.setChunkedStreamingMode(0);
-    OutputStream out = connection.getOutputStream();
-    try {
-      byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
-      out.write(data);
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-  }
-
-  @Test public void setChunkedEncodingAsRequestProperty() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse());
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setRequestProperty("Transfer-encoding", "chunked");
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("ABC".getBytes("UTF-8"));
-    assertEquals(200, connection.getResponseCode());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("ABC", request.getBody().readUtf8());
-  }
-
-  @Test public void connectionCloseInRequest() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse()); // server doesn't honor the connection: close header!
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection a = urlFactory.open(server.url("/").url());
-    a.setRequestProperty("Connection", "close");
-    assertEquals(200, a.getResponseCode());
-
-    HttpURLConnection b = urlFactory.open(server.url("/").url());
-    assertEquals(200, b.getResponseCode());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals("When connection: close is used, each request should get its own connection", 0,
-        server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectionCloseInResponse() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().addHeader("Connection: close"));
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection a = urlFactory.open(server.url("/").url());
-    assertEquals(200, a.getResponseCode());
-
-    HttpURLConnection b = urlFactory.open(server.url("/").url());
-    assertEquals(200, b.getResponseCode());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals("When connection: close is used, each request should get its own connection", 0,
-        server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectionCloseWithRedirect() throws IOException, InterruptedException {
-    MockResponse response = new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .addHeader("Connection: close");
-    server.enqueue(response);
-    server.enqueue(new MockResponse()
-        .setBody("This is the new location!"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("This is the new location!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals("When connection: close is used, each request should get its own connection", 0,
-        server.takeRequest().getSequenceNumber());
-  }
-
-  /**
-   * Retry redirects if the socket is closed.
-   * https://code.google.com/p/android/issues/detail?id=41576
-   */
-  @Test public void sameConnectionRedirectAndReuse() throws Exception {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new SingleInetAddressDns())
-        .build());
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .setBody("This is the new page!"));
-
-    assertContent("This is the new page!", urlFactory.open(server.url("/").url()));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void responseCodeDisagreesWithHeaders() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
-        .setBody("This body is not allowed!"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("HTTP 204 had non-zero Content-Length: 25", expected.getMessage());
-    }
-  }
-
-  @Test public void singleByteReadIsSigned() throws IOException {
-    server.enqueue(new MockResponse().setBody(new Buffer().writeByte(-2).writeByte(-1)));
-
-    connection = urlFactory.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals(254, in.read());
-    assertEquals(255, in.read());
-    assertEquals(-1, in.read());
-  }
-
-  @Test public void flushAfterStreamTransmittedWithChunkedEncoding() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.CHUNKED);
-  }
-
-  @Test public void flushAfterStreamTransmittedWithFixedLength() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void flushAfterStreamTransmittedWithNoLengthHeaders() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.END_OF_STREAM);
-  }
-
-  /**
-   * We explicitly permit apps to close the upload stream even after it has been transmitted.  We
-   * also permit flush so that buffered streams can do a no-op flush when they are closed.
-   * http://b/3038470
-   */
-  private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws IOException {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    byte[] upload = "def".getBytes("UTF-8");
-
-    if (transferKind == TransferKind.CHUNKED) {
-      connection.setChunkedStreamingMode(0);
-    } else if (transferKind == TransferKind.FIXED_LENGTH) {
-      connection.setFixedLengthStreamingMode(upload.length);
-    }
-
-    OutputStream out = connection.getOutputStream();
-    out.write(upload);
-    assertEquals("abc", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    out.flush(); // Dubious but permitted.
-    try {
-      out.write("ghi".getBytes("UTF-8"));
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void getHeadersThrows() throws IOException {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void dnsFailureThrowsIOException() throws IOException {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new FakeDns())
-        .build());
-    connection = urlFactory.open(new URL("http://host.unlikelytld"));
-    try {
-      connection.connect();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
-    connection = urlFactory.open(new URL("http://./foo.html"));
-    try {
-      connection.connect();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void getKeepAlive() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC"));
-
-    // The request should work once and then fail
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    connection1.setReadTimeout(100);
-    InputStream input = connection1.getInputStream();
-    assertEquals("ABC", readAscii(input, Integer.MAX_VALUE));
-    server.shutdown();
-    try {
-      HttpURLConnection connection2 = urlFactory.open(server.url("").url());
-      connection2.setReadTimeout(100);
-      connection2.getInputStream();
-      fail();
-    } catch (ConnectException expected) {
-    }
-  }
-
-  /** http://code.google.com/p/android/issues/detail?id=14562 */
-  @Test public void readAfterLastByte() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC")
-        .clearHeaders()
-        .addHeader("Connection: close")
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    connection = urlFactory.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals("ABC", readAscii(in, 3));
-    assertEquals(-1, in.read());
-    assertEquals(-1, in.read()); // throws IOException in Gingerbread
-  }
-
-  @Test public void getContent() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    InputStream in = (InputStream) connection.getContent();
-    assertEquals("A", readAscii(in, Integer.MAX_VALUE));
-  }
-
-  @Test public void getContentOfType() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getContent(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      connection.getContent(new Class[] {null});
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    assertNull(connection.getContent(new Class[] {getClass()}));
-    connection.getInputStream().close();
-  }
-
-  @Test public void getOutputStreamOnGetFails() throws Exception {
-    server.enqueue(new MockResponse());
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getOutputStream();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-    connection.getInputStream().close();
-  }
-
-  @Test public void getOutputAfterGetInputStreamFails() throws Exception {
-    server.enqueue(new MockResponse());
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    try {
-      connection.getInputStream();
-      connection.getOutputStream();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void setDoOutputOrDoInputAfterConnectFails() throws Exception {
-    server.enqueue(new MockResponse());
-    connection = urlFactory.open(server.url("/").url());
-    connection.connect();
-    try {
-      connection.setDoOutput(true);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      connection.setDoInput(true);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    connection.getInputStream().close();
-  }
-
-  @Test public void clientSendsContentLength() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    OutputStream out = connection.getOutputStream();
-    out.write(new byte[] {'A', 'B', 'C'});
-    out.close();
-    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    RecordedRequest request = server.takeRequest();
-    assertEquals("3", request.getHeader("Content-Length"));
-    connection.getInputStream().close();
-  }
-
-  @Test public void getContentLengthConnects() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(3, connection.getContentLength());
-    connection.getInputStream().close();
-  }
-
-  @Test public void getContentTypeConnects() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("ABC"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("text/plain", connection.getContentType());
-    connection.getInputStream().close();
-  }
-
-  @Test public void getContentEncodingConnects() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Encoding: identity").setBody("ABC"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("identity", connection.getContentEncoding());
-    connection.getInputStream().close();
-  }
-
-  // http://b/4361656
-  @Test public void urlContainsQueryButNoPath() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    URL url = new URL("http", server.getHostName(), server.getPort(), "?query");
-    assertEquals("A", readAscii(urlFactory.open(url).getInputStream(), Integer.MAX_VALUE));
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /?query HTTP/1.1", request.getRequestLine());
-  }
-
-  @Test public void doOutputForMethodThatDoesntSupportOutput() throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    connection.setRequestMethod("HEAD");
-    connection.setDoOutput(true);
-    try {
-      connection.connect();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  // http://code.google.com/p/android/issues/detail?id=20442
-  @Test public void inputStreamAvailableWithChunkedEncoding() throws Exception {
-    testInputStreamAvailable(TransferKind.CHUNKED);
-  }
-
-  @Test public void inputStreamAvailableWithContentLengthHeader() throws Exception {
-    testInputStreamAvailable(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void inputStreamAvailableWithNoLengthHeaders() throws Exception {
-    testInputStreamAvailable(TransferKind.END_OF_STREAM);
-  }
-
-  private void testInputStreamAvailable(TransferKind transferKind) throws IOException {
-    String body = "ABCDEFGH";
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, body, 4);
-    server.enqueue(response);
-    connection = urlFactory.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    for (int i = 0; i < body.length(); i++) {
-      assertTrue(in.available() >= 0);
-      assertEquals(body.charAt(i), in.read());
-    }
-    assertEquals(0, in.available());
-    assertEquals(-1, in.read());
-  }
-
-  @Test public void postFailsWithBufferedRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 1024);
-  }
-
-  @Test public void postFailsWithBufferedRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 16384);
-  }
-
-  @Test public void postFailsWithChunkedRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 1024);
-  }
-
-  @Test public void postFailsWithChunkedRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 16384);
-  }
-
-  @Test public void postFailsWithFixedLengthRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 1024);
-  }
-
-  @Test public void postFailsWithFixedLengthRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 16384);
-  }
-
-  private void reusedConnectionFailsWithPost(TransferKind transferKind, int requestSize)
-      throws Exception {
-    server.enqueue(new MockResponse().setBody("A").setSocketPolicy(DISCONNECT_AT_END));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    assertContent("A", urlFactory.open(server.url("/a").url()));
-
-    // Give the server time to disconnect.
-    Thread.sleep(500);
-
-    // If the request body is larger than OkHttp's replay buffer, the failure may still occur.
-    byte[] requestBody = new byte[requestSize];
-    new Random(0).nextBytes(requestBody);
-
-    for (int j = 0; j < 2; j++) {
-      try {
-        connection = urlFactory.open(server.url("/b").url());
-        connection.setRequestMethod("POST");
-        transferKind.setForRequest(connection, requestBody.length);
-        for (int i = 0; i < requestBody.length; i += 1024) {
-          connection.getOutputStream().write(requestBody, i, 1024);
-        }
-        connection.getOutputStream().close();
-        assertContent("B", connection);
-        break;
-      } catch (IOException socketException) {
-        // If there's a socket exception, this must have a streamed request body.
-        assertEquals(0, j);
-        assertTrue(transferKind == TransferKind.CHUNKED
-            || transferKind == TransferKind.FIXED_LENGTH);
-      }
-    }
-
-    RecordedRequest requestA = server.takeRequest();
-    assertEquals("/a", requestA.getPath());
-    RecordedRequest requestB = server.takeRequest();
-    assertEquals("/b", requestB.getPath());
-    assertEquals(Arrays.toString(requestBody), Arrays.toString(requestB.getBody().readByteArray()));
-  }
-
-  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    // Seed the connection pool so we have something that can fail.
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-
-    HttpURLConnection post = urlFactory.open(server.url("/").url());
-    post.setDoOutput(true);
-    post.getOutputStream().write("body!".getBytes(UTF_8));
-    assertContent("def", post);
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals(0, get.getSequenceNumber());
-
-    RecordedRequest post1 = server.takeRequest();
-    assertEquals("body!", post1.getBody().readUtf8());
-    assertEquals(1, post1.getSequenceNumber());
-
-    RecordedRequest post2 = server.takeRequest();
-    assertEquals("body!", post2.getBody().readUtf8());
-    assertEquals(0, post2.getSequenceNumber());
-  }
-
-  @Test public void fullyBufferedPostIsTooShort() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    connection = urlFactory.open(server.url("/b").url());
-    connection.setRequestProperty("Content-Length", "4");
-    connection.setRequestMethod("POST");
-    OutputStream out = connection.getOutputStream();
-    out.write('a');
-    out.write('b');
-    out.write('c');
-    try {
-      out.close();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void fullyBufferedPostIsTooLong() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    connection = urlFactory.open(server.url("/b").url());
-    connection.setRequestProperty("Content-Length", "3");
-    connection.setRequestMethod("POST");
-    OutputStream out = connection.getOutputStream();
-    out.write('a');
-    out.write('b');
-    out.write('c');
-    try {
-      out.write('d');
-      out.flush();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test @Ignore public void testPooledConnectionsDetectHttp10() {
-    // TODO: write a test that shows pooled connections detect HTTP/1.0 (vs. HTTP/1.1)
-    fail("TODO");
-  }
-
-  @Test @Ignore public void postBodiesRetransmittedOnAuthProblems() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void cookiesAndTrailers() {
-    // Do cookie headers get processed too many times?
-    fail("TODO");
-  }
-
-  @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
-    server.enqueue(new MockResponse().setBody("body"));
-    connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("B", "");
-    assertContent("body", connection);
-    assertEquals("", connection.getRequestProperty("B"));
-  }
-
-  @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
-    server.enqueue(new MockResponse().addHeader("A:").setBody("body"));
-    connection = urlFactory.open(server.url("/").url());
-    assertContent("body", connection);
-    assertEquals("", connection.getHeaderField("A"));
-  }
-
-  @Test public void emptyRequestHeaderNameIsStrict() throws Exception {
-    server.enqueue(new MockResponse().setBody("body"));
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.setRequestProperty("", "A");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void emptyResponseHeaderNameIsLenient() throws Exception {
-    Headers.Builder headers = new Headers.Builder();
-    Internal.instance.addLenient(headers, ":A");
-    server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
-    connection = urlFactory.open(server.url("/").url());
-    connection.getResponseCode();
-    assertEquals("A", connection.getHeaderField(""));
-    connection.getInputStream().close();
-  }
-
-  @Test public void requestHeaderValidationIsStrict() throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.addRequestProperty("a\tb", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      connection.addRequestProperty("Name", "c\u007fd");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      connection.addRequestProperty("", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      connection.addRequestProperty("\ud83c\udf69", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      connection.addRequestProperty("Name", "\u2615\ufe0f");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void responseHeaderParsingIsLenient() throws Exception {
-    Headers headers = new Headers.Builder()
-        .add("Content-Length", "0")
-        .addLenient("a\tb: c\u007fd")
-        .addLenient(": ef")
-        .addLenient("\ud83c\udf69: \u2615\ufe0f")
-        .build();
-    server.enqueue(new MockResponse().setHeaders(headers));
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.getResponseCode();
-    assertEquals("c\u007fd", connection.getHeaderField("a\tb"));
-    assertEquals("\u2615\ufe0f", connection.getHeaderField("\ud83c\udf69"));
-    assertEquals("ef", connection.getHeaderField(""));
-  }
-
-  @Test @Ignore public void deflateCompression() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void postBodiesRetransmittedOnIpAddressProblems() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void pooledConnectionProblemsNotReportedToProxySelector() {
-    fail("TODO");
-  }
-
-  @Test public void customBasicAuthenticator() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(new MockResponse().setBody("A"));
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential);
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(authenticator)
-        .build());
-    assertContent("A", urlFactory.open(server.url("/private").url()));
-
-    assertNull(server.takeRequest().getHeader("Authorization"));
-    assertEquals(credential, server.takeRequest().getHeader("Authorization"));
-
-    assertEquals(Proxy.NO_PROXY, authenticator.onlyProxy());
-    Response response = authenticator.onlyResponse();
-    assertEquals("/private", response.request().url().url().getPath());
-    assertEquals(Arrays.asList(new Challenge("Basic", "protected area")), response.challenges());
-  }
-
-  @Test public void customTokenAuthenticator() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(new MockResponse().setBody("A"));
-
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator("oauthed abc123");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(authenticator)
-        .build());
-    assertContent("A", urlFactory.open(server.url("/private").url()));
-
-    assertNull(server.takeRequest().getHeader("Authorization"));
-    assertEquals("oauthed abc123", server.takeRequest().getHeader("Authorization"));
-
-    Response response = authenticator.onlyResponse();
-    assertEquals("/private", response.request().url().url().getPath());
-    assertEquals(Arrays.asList(new Challenge("Bearer", "oauthed")), response.challenges());
-  }
-
-  @Test public void authenticateCallsTrackedAsRedirects() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /b"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\""));
-    server.enqueue(new MockResponse().setBody("c"));
-
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
-        Credentials.basic("jesse", "peanutbutter"));
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(authenticator)
-        .build());
-    assertContent("c", urlFactory.open(server.url("/a").url()));
-
-    Response challengeResponse = authenticator.responses.get(0);
-    assertEquals("/b", challengeResponse.request().url().url().getPath());
-
-    Response redirectedBy = challengeResponse.priorResponse();
-    assertEquals("/a", redirectedBy.request().url().url().getPath());
-  }
-
-  @Test public void attemptAuthorization20Times() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse().setResponseCode(401));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
-        .build());
-
-    connection = urlFactory.open(server.url("/0").url());
-    assertContent("Success!", connection);
-  }
-
-  @Test public void doesNotAttemptAuthorization21Times() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse().setResponseCode(401));
-    }
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
-        .build());
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (ProtocolException expected) {
-      assertEquals(401, connection.getResponseCode());
-      assertEquals("Too many follow-up requests: 21", expected.getMessage());
-    }
-  }
-
-  @Test public void setsNegotiatedProtocolHeader_HTTP_2() throws Exception {
-    setsNegotiatedProtocolHeader(Protocol.HTTP_2);
-  }
-
-  private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException {
-    enableProtocol(protocol);
-    server.enqueue(new MockResponse().setBody("A"));
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    assertEquals(Arrays.asList(protocol.toString()), protocolValues);
-    assertContent("A", connection);
-  }
-
-  @Test public void http10SelectedProtocol() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 OK"));
-    connection = urlFactory.open(server.url("/").url());
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    assertEquals(Arrays.asList("http/1.0"), protocolValues);
-  }
-
-  @Test public void http11SelectedProtocol() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
-    connection = urlFactory.open(server.url("/").url());
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    assertEquals(Arrays.asList("http/1.1"), protocolValues);
-  }
-
-  /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
-  @Test public void zeroLengthPost() throws IOException, InterruptedException {
-    zeroLengthPayload("POST");
-  }
-
-  @Test public void zeroLengthPost_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    zeroLengthPost();
-  }
-
-  /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
-  @Test public void zeroLengthPut() throws IOException, InterruptedException {
-    zeroLengthPayload("PUT");
-  }
-
-  @Test public void zeroLengthPut_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    zeroLengthPut();
-  }
-
-  private void zeroLengthPayload(String method)
-      throws IOException, InterruptedException {
-    server.enqueue(new MockResponse());
-    connection = urlFactory.open(server.url("/").url());
-    connection.setRequestProperty("Content-Length", "0");
-    connection.setRequestMethod(method);
-    connection.setFixedLengthStreamingMode(0);
-    connection.setDoOutput(true);
-    assertContent("", connection);
-    RecordedRequest zeroLengthPayload = server.takeRequest();
-    assertEquals(method, zeroLengthPayload.getMethod());
-    assertEquals("0", zeroLengthPayload.getHeader("content-length"));
-    assertEquals(0L, zeroLengthPayload.getBodySize());
-  }
-
-  @Test public void unspecifiedRequestBodyContentTypeGetsDefault() throws Exception {
-    server.enqueue(new MockResponse());
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("abc".getBytes(UTF_8));
-    assertEquals(200, connection.getResponseCode());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("application/x-www-form-urlencoded", request.getHeader("Content-Type"));
-    assertEquals("3", request.getHeader("Content-Length"));
-    assertEquals("abc", request.getBody().readUtf8());
-  }
-
-  @Test public void setProtocols() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .protocols(Arrays.asList(Protocol.HTTP_1_1))
-        .build());
-    assertContent("A", urlFactory.open(server.url("/").url()));
-  }
-
-  @Test public void setProtocolsWithoutHttp11() throws Exception {
-    try {
-      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_2));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setProtocolsWithNull() throws Exception {
-    try {
-      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_1_1, null));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void veryLargeFixedLengthRequest() throws Exception {
-    server.setBodyLimit(0);
-    server.enqueue(new MockResponse());
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    long contentLength = Integer.MAX_VALUE + 1L;
-    connection.setFixedLengthStreamingMode(contentLength);
-    OutputStream out = connection.getOutputStream();
-    byte[] buffer = new byte[1024 * 1024];
-    for (long bytesWritten = 0; bytesWritten < contentLength; ) {
-      int byteCount = (int) Math.min(buffer.length, contentLength - bytesWritten);
-      out.write(buffer, 0, byteCount);
-      bytesWritten += byteCount;
-    }
-    assertContent("", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(Long.toString(contentLength), request.getHeader("Content-Length"));
-  }
-
-  @Test public void testNoSslFallback() throws Exception {
-    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);
-    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("Response that would have needed fallbacks"));
-
-    HttpsURLConnection connection = (HttpsURLConnection) server.url("/").url().openConnection();
-    connection.setSSLSocketFactory(sslClient.socketFactory);
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (SSLProtocolException expected) {
-      // RI response to the FAIL_HANDSHAKE
-    } catch (SSLHandshakeException expected) {
-      // Android's response to the FAIL_HANDSHAKE
-    }
-  }
-
-  /**
-   * We had a bug where we attempted to gunzip responses that didn't have a body. This only came up
-   * with 304s since that response code can include headers (like "Content-Encoding") without any
-   * content to go along with it. https://github.com/square/okhttp/issues/358
-   */
-  @Test public void noTransparentGzipFor304NotModified() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection1.getResponseCode());
-    assertContent("", connection1);
-
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertContent("b", connection2);
-
-    RecordedRequest requestA = server.takeRequest();
-    assertEquals(0, requestA.getSequenceNumber());
-
-    RecordedRequest requestB = server.takeRequest();
-    assertEquals(1, requestB.getSequenceNumber());
-  }
-
-  /**
-   * We had a bug where we weren't closing Gzip streams on redirects.
-   * https://github.com/square/okhttp/issues/441
-   */
-  @Test public void gzipWithRedirectAndConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("Moved! Moved! Moved!")));
-    server.enqueue(new MockResponse().setBody("This is the new page!"));
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertContent("This is the new page!", connection);
-
-    RecordedRequest requestA = server.takeRequest();
-    assertEquals(0, requestA.getSequenceNumber());
-
-    RecordedRequest requestB = server.takeRequest();
-    assertEquals(1, requestB.getSequenceNumber());
-  }
-
-  /**
-   * The RFC is unclear in this regard as it only specifies that this should invalidate the cache
-   * entry (if any).
-   */
-  @Test public void bodyPermittedOnDelete() throws Exception {
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setRequestMethod("DELETE");
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("BODY".getBytes(UTF_8));
-    assertEquals(200, connection.getResponseCode());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("DELETE", request.getMethod());
-    assertEquals("BODY", request.getBody().readUtf8());
-  }
-
-  @Test public void userAgentPicksUpHttpAgentSystemProperty() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    System.setProperty("http.agent", "foo");
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("foo", request.getHeader("User-Agent"));
-  }
-
-  /** https://github.com/square/okhttp/issues/891 */
-  @Test public void userAgentSystemPropertyIsNotAscii() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    System.setProperty("http.agent", "a\nb\ud83c\udf69c\ud83c\udf68d\u007fe");
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("a?b?c?d?e", request.getHeader("User-Agent"));
-  }
-
-  @Test public void userAgentDefaultsToOkHttpVersion() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(Version.userAgent(), request.getHeader("User-Agent"));
-  }
-
-  @Test public void interceptorsNotInvoked() throws Exception {
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        throw new AssertionError();
-      }
-    };
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .addInterceptor(interceptor)
-        .addNetworkInterceptor(interceptor)
-        .build());
-
-    server.enqueue(new MockResponse().setBody("abc"));
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-  }
-
-  @Test public void urlWithSpaceInHost() throws Exception {
-    URLConnection urlConnection = urlFactory.open(new URL("http://and roid.com/"));
-    try {
-      urlConnection.getInputStream();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void urlWithSpaceInHostViaHttpProxy() throws Exception {
-    server.enqueue(new MockResponse());
-    URLConnection urlConnection =
-        urlFactory.open(new URL("http://and roid.com/"), server.toProxyAddress());
-
-    try {
-      // This test is to check that a NullPointerException is not thrown.
-      urlConnection.getInputStream();
-      fail(); // the RI makes a bogus proxy request for "GET http://and roid.com/ HTTP/1.1"
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void urlHostWithNul() throws Exception {
-    URLConnection urlConnection = urlFactory.open(new URL("http://host\u0000/"));
-    try {
-      urlConnection.getInputStream();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void urlRedirectToHostWithNul() throws Exception {
-    String redirectUrl = "http://host\u0000/";
-    server.enqueue(new MockResponse().setResponseCode(302)
-        .addHeaderLenient("Location", redirectUrl));
-
-    HttpURLConnection urlConnection = urlFactory.open(server.url("/").url());
-    assertEquals(302, urlConnection.getResponseCode());
-    assertEquals(redirectUrl, urlConnection.getHeaderField("Location"));
-  }
-
-  @Test public void urlWithBadAsciiHost() throws Exception {
-    URLConnection urlConnection = urlFactory.open(new URL("http://host\u0001/"));
-    try {
-      urlConnection.getInputStream();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void instanceFollowsRedirects() throws Exception {
-    testInstanceFollowsRedirects("http://www.google.com/");
-    testInstanceFollowsRedirects("https://www.google.com/");
-  }
-
-  @Test public void setSslSocketFactoryFailsOnJdk9() throws Exception {
-    assumeTrue(getPlatform().equals("jdk9"));
-
-    enableProtocol(Protocol.HTTP_2);
-    URL url = server.url("/").url();
-    HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(url);
-    try {
-      connection.setSSLSocketFactory(sslClient.socketFactory);
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-
-  /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
-  @Test public void unexpectedExceptionSync() throws Exception {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new Dns() {
-          @Override public List<InetAddress> lookup(String hostname) {
-            throw new RuntimeException("boom!");
-          }
-        })
-        .build());
-
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode(); // Use the synchronous implementation.
-      fail();
-    } catch (RuntimeException expected) {
-      assertEquals("boom!", expected.getMessage());
-    }
-  }
-
-  /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
-  @Test public void unexpectedExceptionAsync() throws Exception {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new Dns() {
-          @Override public List<InetAddress> lookup(String hostname) {
-            throw new RuntimeException("boom!");
-          }
-        })
-        .build());
-
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.connect(); // Force the async implementation.
-      fail();
-    } catch (RuntimeException expected) {
-      assertEquals("boom!", expected.getMessage());
-    }
-  }
-
-  @Test public void callsNotManagedByDispatcher() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Dispatcher dispatcher = urlFactory.client().dispatcher();
-    assertEquals(0, dispatcher.runningCallsCount());
-
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(0, dispatcher.runningCallsCount());
-
-    connection.connect();
-    assertEquals(0, dispatcher.runningCallsCount());
-
-    assertContent("abc", connection);
-    assertEquals(0, dispatcher.runningCallsCount());
-  }
-
-  @Test public void streamedBodyIsRetriedOnHttp2Shutdown() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setBody("abc"));
-    server.enqueue(new MockResponse()
-        .setBody("def"));
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    connection1.setChunkedStreamingMode(4096);
-    connection1.setRequestMethod("POST");
-    connection1.connect(); // Establish healthy HTTP/2 connection, but don't write yet.
-
-    // Send a separate request which will trigger a GOAWAY frame on the healthy connection.
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertContent("abc", connection2);
-
-    // Ensure the GOAWAY frame has time to be read and processed.
-    Thread.sleep(500);
-
-    OutputStream os = connection1.getOutputStream();
-    os.write(new byte[] { '1', '2', '3' });
-    os.close();
-    assertContent("def", connection1);
-
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals(0, request1.getSequenceNumber());
-
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("123", request2.getBody().readUtf8());
-    assertEquals(0, request2.getSequenceNumber());
-  }
-
-  private void testInstanceFollowsRedirects(String spec) throws Exception {
-    URL url = new URL(spec);
-    HttpURLConnection urlConnection = urlFactory.open(url);
-    urlConnection.setInstanceFollowRedirects(true);
-    assertTrue(urlConnection.getInstanceFollowRedirects());
-    urlConnection.setInstanceFollowRedirects(false);
-    assertFalse(urlConnection.getInstanceFollowRedirects());
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink gzipSink = Okio.buffer(new GzipSink(result));
-    gzipSink.writeUtf8(data);
-    gzipSink.close();
-    return result;
-  }
-
-  /**
-   * Reads at most {@code limit} characters from {@code in} and asserts that content equals {@code
-   * expected}.
-   */
-  private void assertContent(String expected, HttpURLConnection connection, int limit)
-      throws IOException {
-    connection.connect();
-    assertEquals(expected, readAscii(connection.getInputStream(), limit));
-  }
-
-  private void assertContent(String expected, HttpURLConnection connection) throws IOException {
-    assertContent(expected, connection, Integer.MAX_VALUE);
-  }
-
-  private Set<String> newSet(String... elements) {
-    return new LinkedHashSet<>(Arrays.asList(elements));
-  }
-
-  enum TransferKind {
-    CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
-        response.setChunkedBody(content, chunkSize);
-      }
-
-      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
-        connection.setChunkedStreamingMode(5);
-      }
-    },
-    FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-      }
-
-      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
-        connection.setFixedLengthStreamingMode(contentLength);
-      }
-    },
-    END_OF_STREAM() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(DISCONNECT_AT_END);
-        response.removeHeader("Content-Length");
-      }
-
-      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
-      }
-    };
-
-    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
-
-    abstract void setForRequest(HttpURLConnection connection, int contentLength);
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, new Buffer().writeUtf8(content), chunkSize);
-    }
-  }
-
-  enum ProxyConfig {
-    NO_PROXY() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
-        streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
-            .proxy(Proxy.NO_PROXY)
-            .build());
-        return streamHandlerFactory.open(url);
-      }
-    },
-
-    CREATE_ARG() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
-        streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
-            .proxy(server.toProxyAddress())
-            .build());
-        return streamHandlerFactory.open(url);
-      }
-    },
-
-    PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
-        System.setProperty("proxyHost", server.getHostName());
-        System.setProperty("proxyPort", Integer.toString(server.getPort()));
-        return streamHandlerFactory.open(url);
-      }
-    },
-
-    HTTP_PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
-        System.setProperty("http.proxyHost", server.getHostName());
-        System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
-        return streamHandlerFactory.open(url);
-      }
-    },
-
-    HTTPS_PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
-        System.setProperty("https.proxyHost", server.getHostName());
-        System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
-        return streamHandlerFactory.open(url);
-      }
-    };
-
-    public abstract HttpURLConnection connect(
-        MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-        throws IOException;
-  }
-
-  private static class RecordingTrustManager implements X509TrustManager {
-    private final List<String> calls = new ArrayList<>();
-    private final X509TrustManager delegate;
-
-    public RecordingTrustManager(X509TrustManager delegate) {
-      this.delegate = delegate;
-    }
-
-    public X509Certificate[] getAcceptedIssuers() {
-      return delegate.getAcceptedIssuers();
-    }
-
-    public void checkClientTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
-      calls.add("checkClientTrusted " + certificatesToString(chain));
-    }
-
-    public void checkServerTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
-      calls.add("checkServerTrusted " + certificatesToString(chain));
-    }
-
-    private String certificatesToString(X509Certificate[] certificates) {
-      List<String> result = new ArrayList<>();
-      for (X509Certificate certificate : certificates) {
-        result.add(certificate.getSubjectDN() + " " + certificate.getSerialNumber());
-      }
-      return result.toString();
-    }
-  }
-
-  /**
-   * Tests that use this will fail unless boot classpath is set. Ex. {@code
-   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
-   */
-  private void enableProtocol(Protocol protocol) {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
-        .build());
-    server.useHttps(sslClient.socketFactory, false);
-    server.setProtocolNegotiationEnabled(true);
-    server.setProtocols(urlFactory.client().protocols());
-  }
-
-  /**
-   * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
-   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
-   * for details.
-   */
-  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(sslClient.socketFactory);
-  }
-
-  private String getPlatform() {
-    return System.getProperty("okhttp.platform", "platform");
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
deleted file mode 100644
index 04ba57126b..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
+++ /dev/null
@@ -1,1815 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Deque;
-import java.util.Iterator;
-import java.util.List;
-import java.util.NoSuchElementException;
-import java.util.concurrent.Executor;
-import okhttp3.internal.io.FaultyFileSystem;
-import okhttp3.internal.io.FileSystem;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Source;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-import org.junit.rules.Timeout;
-
-import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE;
-import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE_BACKUP;
-import static okhttp3.internal.cache.DiskLruCache.MAGIC;
-import static okhttp3.internal.cache.DiskLruCache.VERSION_1;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class DiskLruCacheTest {
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-  @Rule public final Timeout timeout = new Timeout(60 * 1000);
-
-  private final FaultyFileSystem fileSystem = new FaultyFileSystem(FileSystem.SYSTEM);
-  private final int appVersion = 100;
-  private File cacheDir;
-  private File journalFile;
-  private File journalBkpFile;
-  private final TestExecutor executor = new TestExecutor();
-
-  private DiskLruCache cache;
-  private final Deque<DiskLruCache> toClose = new ArrayDeque<>();
-
-  private void createNewCache() throws IOException {
-    createNewCacheWithSize(Integer.MAX_VALUE);
-  }
-
-  private void createNewCacheWithSize(int maxSize) throws IOException {
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, maxSize, executor);
-    synchronized (cache) {
-      cache.initialize();
-    }
-    toClose.add(cache);
-  }
-
-  @Before public void setUp() throws Exception {
-    cacheDir = tempDir.getRoot();
-    journalFile = new File(cacheDir, JOURNAL_FILE);
-    journalBkpFile = new File(cacheDir, JOURNAL_FILE_BACKUP);
-    createNewCache();
-  }
-
-  @After public void tearDown() throws Exception {
-    while (!toClose.isEmpty()) {
-      toClose.pop().close();
-    }
-  }
-
-  @Test public void emptyCache() throws Exception {
-    cache.close();
-    assertJournalEquals();
-  }
-
-  @Test public void recoverFromInitializationFailure() throws IOException {
-    // Add an uncommitted entry. This will get detected on initialization, and the cache will
-    // attempt to delete the file. Do not explicitly close the cache here so the entry is left as
-    // incomplete.
-    DiskLruCache.Editor creator = cache.edit("k1");
-    BufferedSink sink = Okio.buffer(creator.newSink(0));
-    sink.writeUtf8("Hello");
-    sink.close();
-
-    // Simulate a severe filesystem failure on the first initialization.
-    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), true);
-    fileSystem.setFaultyDelete(cacheDir, true);
-
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    toClose.add(cache);
-
-    try {
-      cache.get("k1");
-      fail();
-    } catch (IOException expected) {
-    }
-
-    // Now let it operate normally.
-    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), false);
-    fileSystem.setFaultyDelete(cacheDir, false);
-
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertNull(snapshot);
-  }
-
-  @Test public void validateKey() throws Exception {
-    String key = null;
-    try {
-      key = "has_space ";
-      cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
-    }
-    try {
-      key = "has_CR\r";
-      cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
-    }
-    try {
-      key = "has_LF\n";
-      cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
-    }
-    try {
-      key = "has_invalid/";
-      cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
-    }
-    try {
-      key = "has_invalid\u2603";
-      cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
-    }
-    try {
-      key = "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long_"
-          + "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long";
-      cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was too long.");
-    } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
-    }
-
-    // Test valid cases.
-
-    // Exactly 120.
-    key = "0123456789012345678901234567890123456789012345678901234567890123456789"
-        + "01234567890123456789012345678901234567890123456789";
-    cache.edit(key).abort();
-    // Contains all valid characters.
-    key = "abcdefghijklmnopqrstuvwxyz_0123456789";
-    cache.edit(key).abort();
-    // Contains dash.
-    key = "-20384573948576";
-    cache.edit(key).abort();
-  }
-
-  @Test public void writeAndReadEntry() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "ABC");
-    setString(creator, 1, "DE");
-    assertNull(creator.newSource(0));
-    assertNull(creator.newSource(1));
-    creator.commit();
-
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "ABC");
-    assertSnapshotValue(snapshot, 1, "DE");
-  }
-
-  @Test public void readAndWriteEntryAcrossCacheOpenAndClose() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "A");
-    setString(creator, 1, "B");
-    creator.commit();
-    cache.close();
-
-    createNewCache();
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "A");
-    assertSnapshotValue(snapshot, 1, "B");
-    snapshot.close();
-  }
-
-  @Test public void readAndWriteEntryWithoutProperClose() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "A");
-    setString(creator, 1, "B");
-    creator.commit();
-
-    // Simulate a dirty close of 'cache' by opening the cache directory again.
-    createNewCache();
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "A");
-    assertSnapshotValue(snapshot, 1, "B");
-    snapshot.close();
-  }
-
-  @Test public void journalWithEditAndPublish() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
-    setString(creator, 0, "AB");
-    setString(creator, 1, "C");
-    creator.commit();
-    cache.close();
-    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1");
-  }
-
-  @Test public void revertedNewFileIsRemoveInJournal() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
-    setString(creator, 0, "AB");
-    setString(creator, 1, "C");
-    creator.abort();
-    cache.close();
-    assertJournalEquals("DIRTY k1", "REMOVE k1");
-  }
-
-  @Test public void unterminatedEditIsRevertedOnClose() throws Exception {
-    cache.edit("k1");
-    cache.close();
-    assertJournalEquals("DIRTY k1", "REMOVE k1");
-  }
-
-  @Test public void journalDoesNotIncludeReadOfYetUnpublishedValue() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    assertNull(cache.get("k1"));
-    setString(creator, 0, "A");
-    setString(creator, 1, "BC");
-    creator.commit();
-    cache.close();
-    assertJournalEquals("DIRTY k1", "CLEAN k1 1 2");
-  }
-
-  @Test public void journalWithEditAndPublishAndRead() throws Exception {
-    DiskLruCache.Editor k1Creator = cache.edit("k1");
-    setString(k1Creator, 0, "AB");
-    setString(k1Creator, 1, "C");
-    k1Creator.commit();
-    DiskLruCache.Editor k2Creator = cache.edit("k2");
-    setString(k2Creator, 0, "DEF");
-    setString(k2Creator, 1, "G");
-    k2Creator.commit();
-    DiskLruCache.Snapshot k1Snapshot = cache.get("k1");
-    k1Snapshot.close();
-    cache.close();
-    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1", "DIRTY k2", "CLEAN k2 3 1", "READ k1");
-  }
-
-  @Test public void cannotOperateOnEditAfterPublish() throws Exception {
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "A");
-    setString(editor, 1, "B");
-    editor.commit();
-    assertInoperable(editor);
-  }
-
-  @Test public void cannotOperateOnEditAfterRevert() throws Exception {
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "A");
-    setString(editor, 1, "B");
-    editor.abort();
-    assertInoperable(editor);
-  }
-
-  @Test public void explicitRemoveAppliedToDiskImmediately() throws Exception {
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "ABC");
-    setString(editor, 1, "B");
-    editor.commit();
-    File k1 = getCleanFile("k1", 0);
-    assertEquals("ABC", readFile(k1));
-    cache.remove("k1");
-    assertFalse(fileSystem.exists(k1));
-  }
-
-  @Test public void removePreventsActiveEditFromStoringAValue() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Editor a = cache.edit("a");
-    setString(a, 0, "a1");
-    assertTrue(cache.remove("a"));
-    setString(a, 1, "a2");
-    a.commit();
-    assertAbsent("a");
-  }
-
-  /**
-   * Each read sees a snapshot of the file at the time read was called. This means that two reads of
-   * the same key can see different data.
-   */
-  @Test public void readAndWriteOverlapsMaintainConsistency() throws Exception {
-    DiskLruCache.Editor v1Creator = cache.edit("k1");
-    setString(v1Creator, 0, "AAaa");
-    setString(v1Creator, 1, "BBbb");
-    v1Creator.commit();
-
-    DiskLruCache.Snapshot snapshot1 = cache.get("k1");
-    BufferedSource inV1 = Okio.buffer(snapshot1.getSource(0));
-    assertEquals('A', inV1.readByte());
-    assertEquals('A', inV1.readByte());
-
-    DiskLruCache.Editor v1Updater = cache.edit("k1");
-    setString(v1Updater, 0, "CCcc");
-    setString(v1Updater, 1, "DDdd");
-    v1Updater.commit();
-
-    DiskLruCache.Snapshot snapshot2 = cache.get("k1");
-    assertSnapshotValue(snapshot2, 0, "CCcc");
-    assertSnapshotValue(snapshot2, 1, "DDdd");
-    snapshot2.close();
-
-    assertEquals('a', inV1.readByte());
-    assertEquals('a', inV1.readByte());
-    assertSnapshotValue(snapshot1, 1, "BBbb");
-    snapshot1.close();
-  }
-
-  @Test public void openWithDirtyKeyDeletesAllFilesForThatKey() throws Exception {
-    cache.close();
-    File cleanFile0 = getCleanFile("k1", 0);
-    File cleanFile1 = getCleanFile("k1", 1);
-    File dirtyFile0 = getDirtyFile("k1", 0);
-    File dirtyFile1 = getDirtyFile("k1", 1);
-    writeFile(cleanFile0, "A");
-    writeFile(cleanFile1, "B");
-    writeFile(dirtyFile0, "C");
-    writeFile(dirtyFile1, "D");
-    createJournal("CLEAN k1 1 1", "DIRTY   k1");
-    createNewCache();
-    assertFalse(fileSystem.exists(cleanFile0));
-    assertFalse(fileSystem.exists(cleanFile1));
-    assertFalse(fileSystem.exists(dirtyFile0));
-    assertFalse(fileSystem.exists(dirtyFile1));
-    assertNull(cache.get("k1"));
-  }
-
-  @Test public void openWithInvalidVersionClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournalWithHeader(MAGIC, "0", "100", "2", "");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-  }
-
-  @Test public void openWithInvalidAppVersionClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournalWithHeader(MAGIC, "1", "101", "2", "");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-  }
-
-  @Test public void openWithInvalidValueCountClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournalWithHeader(MAGIC, "1", "100", "1", "");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-  }
-
-  @Test public void openWithInvalidBlankLineClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournalWithHeader(MAGIC, "1", "100", "2", "x");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-  }
-
-  @Test public void openWithInvalidJournalLineClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournal("CLEAN k1 1 1", "BOGUS");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-    assertNull(cache.get("k1"));
-  }
-
-  @Test public void openWithInvalidFileSizeClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournal("CLEAN k1 0000x001 1");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-    assertNull(cache.get("k1"));
-  }
-
-  @Test public void openWithTruncatedLineDiscardsThatLine() throws Exception {
-    cache.close();
-    writeFile(getCleanFile("k1", 0), "A");
-    writeFile(getCleanFile("k1", 1), "B");
-
-    BufferedSink sink = Okio.buffer(fileSystem.sink(journalFile));
-    sink.writeUtf8(MAGIC + "\n" + VERSION_1 + "\n100\n2\n\nCLEAN k1 1 1"); // no trailing newline
-    sink.close();
-    createNewCache();
-    assertNull(cache.get("k1"));
-
-    // The journal is not corrupt when editing after a truncated line.
-    set("k1", "C", "D");
-
-    cache.close();
-    createNewCache();
-    assertValue("k1", "C", "D");
-  }
-
-  @Test public void openWithTooManyFileSizesClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournal("CLEAN k1 1 1 1");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-    assertNull(cache.get("k1"));
-  }
-
-  @Test public void keyWithSpaceNotPermitted() throws Exception {
-    try {
-      cache.edit("my key");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void keyWithNewlineNotPermitted() throws Exception {
-    try {
-      cache.edit("my\nkey");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void keyWithCarriageReturnNotPermitted() throws Exception {
-    try {
-      cache.edit("my\rkey");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void nullKeyThrows() throws Exception {
-    try {
-      cache.edit(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-  }
-
-  @Test public void createNewEntryWithTooFewValuesFails() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 1, "A");
-    try {
-      creator.commit();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    assertFalse(fileSystem.exists(getCleanFile("k1", 0)));
-    assertFalse(fileSystem.exists(getCleanFile("k1", 1)));
-    assertFalse(fileSystem.exists(getDirtyFile("k1", 0)));
-    assertFalse(fileSystem.exists(getDirtyFile("k1", 1)));
-    assertNull(cache.get("k1"));
-
-    DiskLruCache.Editor creator2 = cache.edit("k1");
-    setString(creator2, 0, "B");
-    setString(creator2, 1, "C");
-    creator2.commit();
-  }
-
-  @Test public void revertWithTooFewValues() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 1, "A");
-    creator.abort();
-    assertFalse(fileSystem.exists(getCleanFile("k1", 0)));
-    assertFalse(fileSystem.exists(getCleanFile("k1", 1)));
-    assertFalse(fileSystem.exists(getDirtyFile("k1", 0)));
-    assertFalse(fileSystem.exists(getDirtyFile("k1", 1)));
-    assertNull(cache.get("k1"));
-  }
-
-  @Test public void updateExistingEntryWithTooFewValuesReusesPreviousValues() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "A");
-    setString(creator, 1, "B");
-    creator.commit();
-
-    DiskLruCache.Editor updater = cache.edit("k1");
-    setString(updater, 0, "C");
-    updater.commit();
-
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "C");
-    assertSnapshotValue(snapshot, 1, "B");
-    snapshot.close();
-  }
-
-  @Test public void growMaxSize() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "a", "aaa"); // size 4
-    set("b", "bb", "bbbb"); // size 6
-    cache.setMaxSize(20);
-    set("c", "c", "c"); // size 12
-    assertEquals(12, cache.size());
-  }
-
-  @Test public void shrinkMaxSizeEvicts() throws Exception {
-    cache.close();
-    createNewCacheWithSize(20);
-    set("a", "a", "aaa"); // size 4
-    set("b", "bb", "bbbb"); // size 6
-    set("c", "c", "c"); // size 12
-    cache.setMaxSize(10);
-    assertEquals(1, executor.jobs.size());
-  }
-
-  @Test public void evictOnInsert() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-
-    set("a", "a", "aaa"); // size 4
-    set("b", "bb", "bbbb"); // size 6
-    assertEquals(10, cache.size());
-
-    // Cause the size to grow to 12 should evict 'A'.
-    set("c", "c", "c");
-    cache.flush();
-    assertEquals(8, cache.size());
-    assertAbsent("a");
-    assertValue("b", "bb", "bbbb");
-    assertValue("c", "c", "c");
-
-    // Causing the size to grow to 10 should evict nothing.
-    set("d", "d", "d");
-    cache.flush();
-    assertEquals(10, cache.size());
-    assertAbsent("a");
-    assertValue("b", "bb", "bbbb");
-    assertValue("c", "c", "c");
-    assertValue("d", "d", "d");
-
-    // Causing the size to grow to 18 should evict 'B' and 'C'.
-    set("e", "eeee", "eeee");
-    cache.flush();
-    assertEquals(10, cache.size());
-    assertAbsent("a");
-    assertAbsent("b");
-    assertAbsent("c");
-    assertValue("d", "d", "d");
-    assertValue("e", "eeee", "eeee");
-  }
-
-  @Test public void evictOnUpdate() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-
-    set("a", "a", "aa"); // size 3
-    set("b", "b", "bb"); // size 3
-    set("c", "c", "cc"); // size 3
-    assertEquals(9, cache.size());
-
-    // Causing the size to grow to 11 should evict 'A'.
-    set("b", "b", "bbbb");
-    cache.flush();
-    assertEquals(8, cache.size());
-    assertAbsent("a");
-    assertValue("b", "b", "bbbb");
-    assertValue("c", "c", "cc");
-  }
-
-  @Test public void evictionHonorsLruFromCurrentSession() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "a", "a");
-    set("b", "b", "b");
-    set("c", "c", "c");
-    set("d", "d", "d");
-    set("e", "e", "e");
-    cache.get("b").close(); // 'B' is now least recently used.
-
-    // Causing the size to grow to 12 should evict 'A'.
-    set("f", "f", "f");
-    // Causing the size to grow to 12 should evict 'C'.
-    set("g", "g", "g");
-    cache.flush();
-    assertEquals(10, cache.size());
-    assertAbsent("a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertValue("d", "d", "d");
-    assertValue("e", "e", "e");
-    assertValue("f", "f", "f");
-  }
-
-  @Test public void evictionHonorsLruFromPreviousSession() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    set("c", "c", "c");
-    set("d", "d", "d");
-    set("e", "e", "e");
-    set("f", "f", "f");
-    cache.get("b").close(); // 'B' is now least recently used.
-    assertEquals(12, cache.size());
-    cache.close();
-    createNewCacheWithSize(10);
-
-    set("g", "g", "g");
-    cache.flush();
-    assertEquals(10, cache.size());
-    assertAbsent("a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertValue("d", "d", "d");
-    assertValue("e", "e", "e");
-    assertValue("f", "f", "f");
-    assertValue("g", "g", "g");
-  }
-
-  @Test public void cacheSingleEntryOfSizeGreaterThanMaxSize() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "aaaaa", "aaaaaa"); // size=11
-    cache.flush();
-    assertAbsent("a");
-  }
-
-  @Test public void cacheSingleValueOfSizeGreaterThanMaxSize() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "aaaaaaaaaaa", "a"); // size=12
-    cache.flush();
-    assertAbsent("a");
-  }
-
-  @Test public void constructorDoesNotAllowZeroCacheSize() throws Exception {
-    try {
-      DiskLruCache.create(fileSystem, cacheDir, appVersion, 2, 0);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void constructorDoesNotAllowZeroValuesPerEntry() throws Exception {
-    try {
-      DiskLruCache.create(fileSystem, cacheDir, appVersion, 0, 10);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void removeAbsentElement() throws Exception {
-    cache.remove("a");
-  }
-
-  @Test public void readingTheSameStreamMultipleTimes() throws Exception {
-    set("a", "a", "b");
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    assertSame(snapshot.getSource(0), snapshot.getSource(0));
-    snapshot.close();
-  }
-
-  @Test public void rebuildJournalOnRepeatedReads() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    while (executor.jobs.isEmpty()) {
-      assertValue("a", "a", "a");
-      assertValue("b", "b", "b");
-    }
-  }
-
-  @Test public void rebuildJournalOnRepeatedEdits() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-    executor.jobs.removeFirst().run();
-
-    // Sanity check that a rebuilt journal behaves normally.
-    assertValue("a", "a", "a");
-    assertValue("b", "b", "b");
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
-  @Test public void rebuildJournalOnRepeatedReadsWithOpenAndClose() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    while (executor.jobs.isEmpty()) {
-      assertValue("a", "a", "a");
-      assertValue("b", "b", "b");
-      cache.close();
-      createNewCache();
-    }
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
-  @Test public void rebuildJournalOnRepeatedEditsWithOpenAndClose() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-      cache.close();
-      createNewCache();
-    }
-  }
-
-  @Test public void rebuildJournalFailurePreventsEditors() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    // Don't allow edits under any circumstances.
-    assertNull(cache.edit("a"));
-    assertNull(cache.edit("c"));
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    assertNull(snapshot.edit());
-    snapshot.close();
-  }
-
-  @Test public void rebuildJournalFailureIsRetried() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    // The rebuild is retried on cache hits and on cache edits.
-    DiskLruCache.Snapshot snapshot = cache.get("b");
-    snapshot.close();
-    assertNull(cache.edit("d"));
-    assertEquals(2, executor.jobs.size());
-
-    // On cache misses, no retry job is queued.
-    assertNull(cache.get("c"));
-    assertEquals(2, executor.jobs.size());
-
-    // Let the rebuild complete successfully.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
-    executor.jobs.removeFirst().run();
-    assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1");
-  }
-
-  @Test public void rebuildJournalFailureWithInFlightEditors() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-    DiskLruCache.Editor commitEditor = cache.edit("c");
-    DiskLruCache.Editor abortEditor = cache.edit("d");
-    cache.edit("e"); // Grab an editor, but don't do anything with it.
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    // In-flight editors can commit and have their values retained.
-    setString(commitEditor, 0, "c");
-    setString(commitEditor, 1, "c");
-    commitEditor.commit();
-    assertValue("c", "c", "c");
-
-    abortEditor.abort();
-
-    // Let the rebuild complete successfully.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
-    executor.jobs.removeFirst().run();
-    assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1", "DIRTY e", "CLEAN c 1 1");
-  }
-
-  @Test public void rebuildJournalFailureWithEditorsInFlightThenClose() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-    DiskLruCache.Editor commitEditor = cache.edit("c");
-    DiskLruCache.Editor abortEditor = cache.edit("d");
-    cache.edit("e"); // Grab an editor, but don't do anything with it.
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    setString(commitEditor, 0, "c");
-    setString(commitEditor, 1, "c");
-    commitEditor.commit();
-    assertValue("c", "c", "c");
-
-    abortEditor.abort();
-
-    cache.close();
-    createNewCache();
-
-    // Although 'c' successfully committed above, the journal wasn't available to issue a CLEAN op.
-    // Because the last state of 'c' was DIRTY before the journal failed, it should be removed
-    // entirely on a subsequent open.
-    assertEquals(4, cache.size());
-    assertAbsent("c");
-    assertAbsent("d");
-    assertAbsent("e");
-  }
-
-  @Test public void rebuildJournalFailureAllowsRemovals() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    assertTrue(cache.remove("a"));
-    assertAbsent("a");
-
-    // Let the rebuild complete successfully.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
-    executor.jobs.removeFirst().run();
-
-    assertJournalEquals("CLEAN b 1 1");
-  }
-
-  @Test public void rebuildJournalFailureWithRemovalThenClose() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    assertTrue(cache.remove("a"));
-    assertAbsent("a");
-
-    cache.close();
-    createNewCache();
-
-    // The journal will have no record that 'a' was removed. It will have an entry for 'a', but when
-    // it tries to read the cache files, it will find they were deleted. Once it encounters an entry
-    // with missing cache files, it should remove it from the cache entirely.
-    assertEquals(4, cache.size());
-    assertNull(cache.get("a"));
-    assertEquals(2, cache.size());
-  }
-
-  @Test public void rebuildJournalFailureAllowsEvictAll() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    cache.evictAll();
-
-    assertEquals(0, cache.size());
-    assertAbsent("a");
-    assertAbsent("b");
-
-    cache.close();
-    createNewCache();
-
-    // The journal has no record that 'a' and 'b' were removed. It will have an entry for both, but
-    // when it tries to read the cache files for either entry, it will discover the cache files are
-    // missing and remove the entries from the cache.
-    assertEquals(4, cache.size());
-    assertNull(cache.get("a"));
-    assertNull(cache.get("b"));
-    assertEquals(0, cache.size());
-  }
-
-  @Test public void rebuildJournalFailureWithCacheTrim() throws Exception {
-    while (executor.jobs.isEmpty()) {
-      set("a", "aa", "aa");
-      set("b", "bb", "bb");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    executor.jobs.removeFirst().run();
-
-    // Trigger a job to trim the cache.
-    cache.setMaxSize(4);
-    executor.jobs.removeFirst().run();
-
-    assertAbsent("a");
-    assertValue("b", "bb", "bb");
-  }
-
-  @Test public void restoreBackupFile() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "ABC");
-    setString(creator, 1, "DE");
-    creator.commit();
-    cache.close();
-
-    fileSystem.rename(journalFile, journalBkpFile);
-    assertFalse(fileSystem.exists(journalFile));
-
-    createNewCache();
-
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "ABC");
-    assertSnapshotValue(snapshot, 1, "DE");
-
-    assertFalse(fileSystem.exists(journalBkpFile));
-    assertTrue(fileSystem.exists(journalFile));
-  }
-
-  @Test public void journalFileIsPreferredOverBackupFile() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "ABC");
-    setString(creator, 1, "DE");
-    creator.commit();
-    cache.flush();
-
-    copyFile(journalFile, journalBkpFile);
-
-    creator = cache.edit("k2");
-    setString(creator, 0, "F");
-    setString(creator, 1, "GH");
-    creator.commit();
-    cache.close();
-
-    assertTrue(fileSystem.exists(journalFile));
-    assertTrue(fileSystem.exists(journalBkpFile));
-
-    createNewCache();
-
-    DiskLruCache.Snapshot snapshotA = cache.get("k1");
-    assertSnapshotValue(snapshotA, 0, "ABC");
-    assertSnapshotValue(snapshotA, 1, "DE");
-
-    DiskLruCache.Snapshot snapshotB = cache.get("k2");
-    assertSnapshotValue(snapshotB, 0, "F");
-    assertSnapshotValue(snapshotB, 1, "GH");
-
-    assertFalse(fileSystem.exists(journalBkpFile));
-    assertTrue(fileSystem.exists(journalFile));
-  }
-
-  @Test public void openCreatesDirectoryIfNecessary() throws Exception {
-    cache.close();
-    File dir = tempDir.newFolder("testOpenCreatesDirectoryIfNecessary");
-    cache = DiskLruCache.create(fileSystem, dir, appVersion, 2, Integer.MAX_VALUE);
-    set("a", "a", "a");
-    assertTrue(fileSystem.exists(new File(dir, "a.0")));
-    assertTrue(fileSystem.exists(new File(dir, "a.1")));
-    assertTrue(fileSystem.exists(new File(dir, "journal")));
-  }
-
-  @Test public void fileDeletedExternally() throws Exception {
-    set("a", "a", "a");
-    fileSystem.delete(getCleanFile("a", 1));
-    assertNull(cache.get("a"));
-    assertEquals(0, cache.size());
-  }
-
-  @Test public void editSameVersion() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    DiskLruCache.Editor editor = snapshot.edit();
-    setString(editor, 1, "a2");
-    editor.commit();
-    assertValue("a", "a", "a2");
-  }
-
-  @Test public void editSnapshotAfterChangeAborted() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    DiskLruCache.Editor toAbort = snapshot.edit();
-    setString(toAbort, 0, "b");
-    toAbort.abort();
-    DiskLruCache.Editor editor = snapshot.edit();
-    setString(editor, 1, "a2");
-    editor.commit();
-    assertValue("a", "a", "a2");
-  }
-
-  @Test public void editSnapshotAfterChangeCommitted() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    DiskLruCache.Editor toAbort = snapshot.edit();
-    setString(toAbort, 0, "b");
-    toAbort.commit();
-    assertNull(snapshot.edit());
-  }
-
-  @Test public void editSinceEvicted() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "aa", "aaa"); // size 5
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    set("b", "bb", "bbb"); // size 5
-    set("c", "cc", "ccc"); // size 5; will evict 'A'
-    cache.flush();
-    assertNull(snapshot.edit());
-  }
-
-  @Test public void editSinceEvictedAndRecreated() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "aa", "aaa"); // size 5
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    set("b", "bb", "bbb"); // size 5
-    set("c", "cc", "ccc"); // size 5; will evict 'A'
-    set("a", "a", "aaaa"); // size 5; will evict 'B'
-    cache.flush();
-    assertNull(snapshot.edit());
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
-  @Test public void aggressiveClearingHandlesWrite() throws Exception {
-    fileSystem.deleteContents(tempDir.getRoot());
-    set("a", "a", "a");
-    assertValue("a", "a", "a");
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
-  @Test public void aggressiveClearingHandlesEdit() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Editor a = cache.get("a").edit();
-    fileSystem.deleteContents(tempDir.getRoot());
-    setString(a, 1, "a2");
-    a.commit();
-  }
-
-  @Test public void removeHandlesMissingFile() throws Exception {
-    set("a", "a", "a");
-    getCleanFile("a", 0).delete();
-    cache.remove("a");
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
-  @Test public void aggressiveClearingHandlesPartialEdit() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    DiskLruCache.Editor a = cache.get("a").edit();
-    setString(a, 0, "a1");
-    fileSystem.deleteContents(tempDir.getRoot());
-    setString(a, 1, "a2");
-    a.commit();
-    assertNull(cache.get("a"));
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
-  @Test public void aggressiveClearingHandlesRead() throws Exception {
-    fileSystem.deleteContents(tempDir.getRoot());
-    assertNull(cache.get("a"));
-  }
-
-  /**
-   * We had a long-lived bug where {@link DiskLruCache#trimToSize} could infinite loop if entries
-   * being edited required deletion for the operation to complete.
-   */
-  @Test public void trimToSizeWithActiveEdit() throws Exception {
-    set("a", "a1234", "a1234");
-    DiskLruCache.Editor a = cache.edit("a");
-    setString(a, 0, "a123");
-
-    cache.setMaxSize(8); // Smaller than the sum of active edits!
-    cache.flush(); // Force trimToSize().
-    assertEquals(0, cache.size());
-    assertNull(cache.get("a"));
-
-    // After the edit is completed, its entry is still gone.
-    setString(a, 1, "a1");
-    a.commit();
-    assertAbsent("a");
-    assertEquals(0, cache.size());
-  }
-
-  @Test public void evictAll() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    cache.evictAll();
-    assertEquals(0, cache.size());
-    assertAbsent("a");
-    assertAbsent("b");
-  }
-
-  @Test public void evictAllWithPartialCreate() throws Exception {
-    DiskLruCache.Editor a = cache.edit("a");
-    setString(a, 0, "a1");
-    setString(a, 1, "a2");
-    cache.evictAll();
-    assertEquals(0, cache.size());
-    a.commit();
-    assertAbsent("a");
-  }
-
-  @Test public void evictAllWithPartialEditDoesNotStoreAValue() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Editor a = cache.edit("a");
-    setString(a, 0, "a1");
-    setString(a, 1, "a2");
-    cache.evictAll();
-    assertEquals(0, cache.size());
-    a.commit();
-    assertAbsent("a");
-  }
-
-  @Test public void evictAllDoesntInterruptPartialRead() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot a = cache.get("a");
-    assertSnapshotValue(a, 0, "a");
-    cache.evictAll();
-    assertEquals(0, cache.size());
-    assertAbsent("a");
-    assertSnapshotValue(a, 1, "a");
-    a.close();
-  }
-
-  @Test public void editSnapshotAfterEvictAllReturnsNullDueToStaleValue() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot a = cache.get("a");
-    cache.evictAll();
-    assertEquals(0, cache.size());
-    assertAbsent("a");
-    assertNull(a.edit());
-    a.close();
-  }
-
-  @Test public void iterator() throws Exception {
-    set("a", "a1", "a2");
-    set("b", "b1", "b2");
-    set("c", "c1", "c2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    assertTrue(iterator.hasNext());
-    DiskLruCache.Snapshot a = iterator.next();
-    assertEquals("a", a.key());
-    assertSnapshotValue(a, 0, "a1");
-    assertSnapshotValue(a, 1, "a2");
-    a.close();
-
-    assertTrue(iterator.hasNext());
-    DiskLruCache.Snapshot b = iterator.next();
-    assertEquals("b", b.key());
-    assertSnapshotValue(b, 0, "b1");
-    assertSnapshotValue(b, 1, "b2");
-    b.close();
-
-    assertTrue(iterator.hasNext());
-    DiskLruCache.Snapshot c = iterator.next();
-    assertEquals("c", c.key());
-    assertSnapshotValue(c, 0, "c1");
-    assertSnapshotValue(c, 1, "c2");
-    c.close();
-
-    assertFalse(iterator.hasNext());
-    try {
-      iterator.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void iteratorElementsAddedDuringIterationAreOmitted() throws Exception {
-    set("a", "a1", "a2");
-    set("b", "b1", "b2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    DiskLruCache.Snapshot a = iterator.next();
-    assertEquals("a", a.key());
-    a.close();
-
-    set("c", "c1", "c2");
-
-    DiskLruCache.Snapshot b = iterator.next();
-    assertEquals("b", b.key());
-    b.close();
-
-    assertFalse(iterator.hasNext());
-  }
-
-  @Test public void iteratorElementsUpdatedDuringIterationAreUpdated() throws Exception {
-    set("a", "a1", "a2");
-    set("b", "b1", "b2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    DiskLruCache.Snapshot a = iterator.next();
-    assertEquals("a", a.key());
-    a.close();
-
-    set("b", "b3", "b4");
-
-    DiskLruCache.Snapshot b = iterator.next();
-    assertEquals("b", b.key());
-    assertSnapshotValue(b, 0, "b3");
-    assertSnapshotValue(b, 1, "b4");
-    b.close();
-  }
-
-  @Test public void iteratorElementsRemovedDuringIterationAreOmitted() throws Exception {
-    set("a", "a1", "a2");
-    set("b", "b1", "b2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    cache.remove("b");
-
-    DiskLruCache.Snapshot a = iterator.next();
-    assertEquals("a", a.key());
-    a.close();
-
-    assertFalse(iterator.hasNext());
-  }
-
-  @Test public void iteratorRemove() throws Exception {
-    set("a", "a1", "a2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    DiskLruCache.Snapshot a = iterator.next();
-    a.close();
-    iterator.remove();
-
-    assertEquals(null, cache.get("a"));
-  }
-
-  @Test public void iteratorRemoveBeforeNext() throws Exception {
-    set("a", "a1", "a2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-    try {
-      iterator.remove();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void iteratorRemoveOncePerCallToNext() throws Exception {
-    set("a", "a1", "a2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    DiskLruCache.Snapshot a = iterator.next();
-    iterator.remove();
-    a.close();
-
-    try {
-      iterator.remove();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cacheClosedTruncatesIterator() throws Exception {
-    set("a", "a1", "a2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-    cache.close();
-    assertFalse(iterator.hasNext());
-  }
-
-  @Test public void isClosed_uninitializedCache() throws Exception {
-    // Create an uninitialized cache.
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    toClose.add(cache);
-
-    assertFalse(cache.isClosed());
-    cache.close();
-    assertTrue(cache.isClosed());
-  }
-
-  @Test public void journalWriteFailsDuringEdit() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-
-    // We can't begin the edit if writing 'DIRTY' fails.
-    fileSystem.setFaultyWrite(journalFile, true);
-    assertNull(cache.edit("c"));
-
-    // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaultyWrite(journalFile, false);
-    assertNull(cache.edit("d"));
-
-    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
-    cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    assertValue("a", "a", "a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertAbsent("d");
-  }
-
-  /**
-   * We had a bug where the cache was left in an inconsistent state after a journal write failed.
-   * https://github.com/square/okhttp/issues/1211
-   */
-  @Test public void journalWriteFailsDuringEditorCommit() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-
-    // Create an entry that fails to write to the journal during commit.
-    DiskLruCache.Editor editor = cache.edit("c");
-    setString(editor, 0, "c");
-    setString(editor, 1, "c");
-    fileSystem.setFaultyWrite(journalFile, true);
-    editor.commit();
-
-    // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaultyWrite(journalFile, false);
-    assertNull(cache.edit("d"));
-
-    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
-    cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    assertValue("a", "a", "a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertAbsent("d");
-  }
-
-  @Test public void journalWriteFailsDuringEditorAbort() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-
-    // Create an entry that fails to write to the journal during abort.
-    DiskLruCache.Editor editor = cache.edit("c");
-    setString(editor, 0, "c");
-    setString(editor, 1, "c");
-    fileSystem.setFaultyWrite(journalFile, true);
-    editor.abort();
-
-    // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaultyWrite(journalFile, false);
-    assertNull(cache.edit("d"));
-
-    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
-    cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    assertValue("a", "a", "a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertAbsent("d");
-  }
-
-  @Test public void journalWriteFailsDuringRemove() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-
-    // Remove, but the journal write will fail.
-    fileSystem.setFaultyWrite(journalFile, true);
-    assertTrue(cache.remove("a"));
-
-    // Confirm that the entry was still removed.
-    fileSystem.setFaultyWrite(journalFile, false);
-    cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
-    assertAbsent("a");
-    assertValue("b", "b", "b");
-  }
-
-  @Test public void cleanupTrimFailurePreventsNewEditors() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm that edits are prevented after a cache trim failure.
-    assertNull(cache.edit("a"));
-    assertNull(cache.edit("b"));
-    assertNull(cache.edit("c"));
-
-    // Allow the test to clean up.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-  }
-
-  @Test public void cleanupTrimFailureRetriedOnEditors() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // An edit should now add a job to clean up if the most recent trim failed.
-    assertNull(cache.edit("b"));
-    executor.jobs.pop().run();
-
-    // Confirm a successful cache trim now allows edits.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    assertNull(cache.edit("c"));
-    executor.jobs.pop().run();
-    set("c", "cc", "cc");
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void cleanupTrimFailureWithInFlightEditor() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aaa");
-    set("b", "bb", "bb");
-    DiskLruCache.Editor inFlightEditor = cache.edit("c");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // The in-flight editor can still write after a trim failure.
-    setString(inFlightEditor, 0, "cc");
-    setString(inFlightEditor, 1, "cc");
-    inFlightEditor.commit();
-
-    // Confirm the committed values are present after a successful cache trim.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    executor.jobs.pop().run();
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void cleanupTrimFailureAllowsSnapshotReads() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm we still allow snapshot reads after a trim failure.
-    assertValue("a", "aa", "aa");
-    assertValue("b", "bb", "bbb");
-
-    // Allow the test to clean up.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-  }
-
-  @Test public void cleanupTrimFailurePreventsSnapshotWrites() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm snapshot writes are prevented after a trim failure.
-    DiskLruCache.Snapshot snapshot1 = cache.get("a");
-    assertNull(snapshot1.edit());
-    snapshot1.close();
-    DiskLruCache.Snapshot snapshot2 = cache.get("b");
-    assertNull(snapshot2.edit());
-    snapshot2.close();
-
-    // Allow the test to clean up.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-  }
-
-  @Test public void evictAllAfterCleanupTrimFailure() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm we prevent edits after a trim failure.
-    assertNull(cache.edit("c"));
-
-    // A successful eviction should allow new writes.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    cache.evictAll();
-    set("c", "cc", "cc");
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void manualRemovalAfterCleanupTrimFailure() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm we prevent edits after a trim failure.
-    assertNull(cache.edit("c"));
-
-    // A successful removal which trims the cache should allow new writes.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    cache.remove("a");
-    set("c", "cc", "cc");
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void flushingAfterCleanupTrimFailure() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    executor.jobs.pop().run();
-
-    // Confirm we prevent edits after a trim failure.
-    assertNull(cache.edit("c"));
-
-    // A successful flush trims the cache and should allow new writes.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    cache.flush();
-    set("c", "cc", "cc");
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void cleanupTrimFailureWithPartialSnapshot() throws Exception {
-    cache.setMaxSize(8);
-    executor.jobs.pop();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim to fail on the second value leaving a partial snapshot.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), true);
-    executor.jobs.pop().run();
-
-    // Confirm the partial snapshot is not returned.
-    assertNull(cache.get("a"));
-
-    // Confirm we prevent edits after a trim failure.
-    assertNull(cache.edit("a"));
-
-    // Confirm the partial snapshot is not returned after a successful trim.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), false);
-    executor.jobs.pop().run();
-    assertNull(cache.get("a"));
-  }
-
-  @Test public void noSizeCorruptionAfterCreatorDetached() throws Exception {
-    // Create an editor for k1. Detach it by clearing the cache.
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "a");
-    setString(editor, 1, "a");
-    cache.evictAll();
-
-    // Create a new value in its place.
-    set("k1", "bb", "bb");
-    assertEquals(4, cache.size());
-
-    // Committing the detached editor should not change the cache's size.
-    editor.commit();
-    assertEquals(4, cache.size());
-    assertValue("k1", "bb", "bb");
-  }
-
-  @Test public void noSizeCorruptionAfterEditorDetached() throws Exception {
-    set("k1", "a", "a");
-
-    // Create an editor for k1. Detach it by clearing the cache.
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "bb");
-    setString(editor, 1, "bb");
-    cache.evictAll();
-
-    // Create a new value in its place.
-    set("k1", "ccc", "ccc");
-    assertEquals(6, cache.size());
-
-    // Committing the detached editor should not change the cache's size.
-    editor.commit();
-    assertEquals(6, cache.size());
-    assertValue("k1", "ccc", "ccc");
-  }
-
-  @Test public void noNewSourceAfterEditorDetached() throws Exception {
-    set("k1", "a", "a");
-
-    DiskLruCache.Editor editor = cache.edit("k1");
-    cache.evictAll();
-
-    assertNull(editor.newSource(0));
-  }
-
-  @Test public void editsDiscardedAfterEditorDetached() throws Exception {
-    set("k1", "a", "a");
-
-    // Create an editor, then detach it.
-    DiskLruCache.Editor editor = cache.edit("k1");
-    BufferedSink sink = Okio.buffer(editor.newSink(0));
-    cache.evictAll();
-
-    // Create another value in its place.
-    set("k1", "ccc", "ccc");
-
-    // Complete the original edit. It goes into a black hole.
-    sink.writeUtf8("bb");
-    sink.close();
-
-    assertValue("k1", "ccc", "ccc");
-  }
-
-  @Test public void abortAfterDetach() throws Exception {
-    set("k1", "a", "a");
-
-    DiskLruCache.Editor editor = cache.edit("k1");
-    cache.evictAll();
-
-    editor.abort();
-    assertEquals(0, cache.size());
-    assertAbsent("k1");
-  }
-
-  private void assertJournalEquals(String... expectedBodyLines) throws Exception {
-    List<String> expectedLines = new ArrayList<>();
-    expectedLines.add(MAGIC);
-    expectedLines.add(VERSION_1);
-    expectedLines.add("100");
-    expectedLines.add("2");
-    expectedLines.add("");
-    expectedLines.addAll(Arrays.asList(expectedBodyLines));
-    assertEquals(expectedLines, readJournalLines());
-  }
-
-  private void createJournal(String... bodyLines) throws Exception {
-    createJournalWithHeader(MAGIC, VERSION_1, "100", "2", "", bodyLines);
-  }
-
-  private void createJournalWithHeader(String magic, String version, String appVersion,
-      String valueCount, String blank, String... bodyLines) throws Exception {
-    BufferedSink sink = Okio.buffer(fileSystem.sink(journalFile));
-    sink.writeUtf8(magic + "\n");
-    sink.writeUtf8(version + "\n");
-    sink.writeUtf8(appVersion + "\n");
-    sink.writeUtf8(valueCount + "\n");
-    sink.writeUtf8(blank + "\n");
-    for (String line : bodyLines) {
-      sink.writeUtf8(line);
-      sink.writeUtf8("\n");
-    }
-    sink.close();
-  }
-
-  private List<String> readJournalLines() throws Exception {
-    List<String> result = new ArrayList<>();
-    BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
-    for (String line; (line = source.readUtf8Line()) != null; ) {
-      result.add(line);
-    }
-    source.close();
-    return result;
-  }
-
-  private File getCleanFile(String key, int index) {
-    return new File(cacheDir, key + "." + index);
-  }
-
-  private File getDirtyFile(String key, int index) {
-    return new File(cacheDir, key + "." + index + ".tmp");
-  }
-
-  private String readFile(File file) throws Exception {
-    BufferedSource source = Okio.buffer(fileSystem.source(file));
-    String result = source.readUtf8();
-    source.close();
-    return result;
-  }
-
-  public void writeFile(File file, String content) throws Exception {
-    BufferedSink sink = Okio.buffer(fileSystem.sink(file));
-    sink.writeUtf8(content);
-    sink.close();
-  }
-
-  private static void assertInoperable(DiskLruCache.Editor editor) throws Exception {
-    try {
-      setString(editor, 0, "A");
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.newSource(0);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.newSink(0);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.commit();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.abort();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  private void generateSomeGarbageFiles() throws Exception {
-    File dir1 = new File(cacheDir, "dir1");
-    File dir2 = new File(dir1, "dir2");
-    writeFile(getCleanFile("g1", 0), "A");
-    writeFile(getCleanFile("g1", 1), "B");
-    writeFile(getCleanFile("g2", 0), "C");
-    writeFile(getCleanFile("g2", 1), "D");
-    writeFile(getCleanFile("g2", 1), "D");
-    writeFile(new File(cacheDir, "otherFile0"), "E");
-    writeFile(new File(dir2, "otherFile1"), "F");
-  }
-
-  private void assertGarbageFilesAllDeleted() {
-    assertFalse(fileSystem.exists(getCleanFile("g1", 0)));
-    assertFalse(fileSystem.exists(getCleanFile("g1", 1)));
-    assertFalse(fileSystem.exists(getCleanFile("g2", 0)));
-    assertFalse(fileSystem.exists(getCleanFile("g2", 1)));
-    assertFalse(fileSystem.exists(new File(cacheDir, "otherFile0")));
-    assertFalse(fileSystem.exists(new File(cacheDir, "dir1")));
-  }
-
-  private void set(String key, String value0, String value1) throws Exception {
-    DiskLruCache.Editor editor = cache.edit(key);
-    setString(editor, 0, value0);
-    setString(editor, 1, value1);
-    editor.commit();
-  }
-
-  public static void setString(DiskLruCache.Editor editor, int index, String value)
-      throws IOException {
-    BufferedSink writer = Okio.buffer(editor.newSink(index));
-    writer.writeUtf8(value);
-    writer.close();
-  }
-
-  private void assertAbsent(String key) throws Exception {
-    DiskLruCache.Snapshot snapshot = cache.get(key);
-    if (snapshot != null) {
-      snapshot.close();
-      fail();
-    }
-    assertFalse(fileSystem.exists(getCleanFile(key, 0)));
-    assertFalse(fileSystem.exists(getCleanFile(key, 1)));
-    assertFalse(fileSystem.exists(getDirtyFile(key, 0)));
-    assertFalse(fileSystem.exists(getDirtyFile(key, 1)));
-  }
-
-  private void assertValue(String key, String value0, String value1) throws Exception {
-    DiskLruCache.Snapshot snapshot = cache.get(key);
-    assertSnapshotValue(snapshot, 0, value0);
-    assertSnapshotValue(snapshot, 1, value1);
-    assertTrue(fileSystem.exists(getCleanFile(key, 0)));
-    assertTrue(fileSystem.exists(getCleanFile(key, 1)));
-    snapshot.close();
-  }
-
-  private void assertSnapshotValue(DiskLruCache.Snapshot snapshot, int index, String value)
-      throws IOException {
-    assertEquals(value, sourceAsString(snapshot.getSource(index)));
-    assertEquals(value.length(), snapshot.getLength(index));
-  }
-
-  private String sourceAsString(Source source) throws IOException {
-    return source != null ? Okio.buffer(source).readUtf8() : null;
-  }
-
-  private void copyFile(File from, File to) throws IOException {
-    Source source = fileSystem.source(from);
-    BufferedSink sink = Okio.buffer(fileSystem.sink(to));
-    sink.writeAll(source);
-    source.close();
-    sink.close();
-  }
-
-  private static class TestExecutor implements Executor {
-    final Deque<Runnable> jobs = new ArrayDeque<>();
-
-    @Override public void execute(Runnable command) {
-      jobs.addLast(command);
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
deleted file mode 100644
index 21bbd49358..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache2;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import java.util.Random;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-public final class FileOperatorTest {
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-
-  private File file;
-  private RandomAccessFile randomAccessFile;
-
-  @Before public void setUp() throws Exception {
-    file = tempDir.newFile();
-    randomAccessFile = new RandomAccessFile(file, "rw");
-  }
-
-  @After public void tearDown() throws Exception {
-    randomAccessFile.close();
-  }
-
-  @Test public void read() throws Exception {
-    write(ByteString.encodeUtf8("Hello, World"));
-
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-
-    Buffer buffer = new Buffer();
-    operator.read(0, buffer, 5);
-    assertEquals("Hello", buffer.readUtf8());
-
-    operator.read(4, buffer, 5);
-    assertEquals("o, Wo", buffer.readUtf8());
-  }
-
-  @Test public void write() throws Exception {
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-
-    Buffer buffer1 = new Buffer().writeUtf8("Hello, World");
-    operator.write(0, buffer1, 5);
-    assertEquals(", World", buffer1.readUtf8());
-
-    Buffer buffer2 = new Buffer().writeUtf8("icopter!");
-    operator.write(3, buffer2, 7);
-    assertEquals("!", buffer2.readUtf8());
-
-    assertEquals(ByteString.encodeUtf8("Helicopter"), snapshot());
-  }
-
-  @Test public void readAndWrite() throws Exception {
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-
-    write(ByteString.encodeUtf8("woman god creates dinosaurs destroys. "));
-    Buffer buffer = new Buffer();
-    operator.read(6, buffer, 21);
-    operator.read(36, buffer, 1);
-    operator.read(5, buffer, 5);
-    operator.read(28, buffer, 8);
-    operator.read(17, buffer, 10);
-    operator.read(36, buffer, 2);
-    operator.read(2, buffer, 4);
-    operator.write(0, buffer, buffer.size());
-    operator.read(0, buffer, 12);
-    operator.read(47, buffer, 3);
-    operator.read(45, buffer, 2);
-    operator.read(47, buffer, 3);
-    operator.read(26, buffer, 10);
-    operator.read(23, buffer, 3);
-    operator.write(47, buffer, buffer.size());
-    operator.read(62, buffer, 6);
-    operator.read(4, buffer, 19);
-    operator.write(80, buffer, buffer.size());
-
-    assertEquals(snapshot(), ByteString.encodeUtf8(""
-        + "god creates dinosaurs. "
-        + "god destroys dinosaurs. "
-        + "god creates man. "
-        + "man destroys god. "
-        + "man creates dinosaurs. "));
-  }
-
-  @Test public void multipleOperatorsShareOneFile() throws Exception {
-    FileOperator operatorA = new FileOperator(randomAccessFile.getChannel());
-    FileOperator operatorB = new FileOperator(randomAccessFile.getChannel());
-
-    Buffer bufferA = new Buffer();
-    Buffer bufferB = new Buffer();
-
-    bufferA.writeUtf8("Dodgson!\n");
-    operatorA.write(0, bufferA, 9);
-
-    bufferB.writeUtf8("You shouldn't use my name.\n");
-    operatorB.write(9, bufferB, 27);
-
-    bufferA.writeUtf8("Dodgson, we've got Dodgson here!\n");
-    operatorA.write(36, bufferA, 33);
-
-    operatorB.read(0, bufferB, 9);
-    assertEquals("Dodgson!\n", bufferB.readUtf8());
-
-    operatorA.read(9, bufferA, 27);
-    assertEquals("You shouldn't use my name.\n", bufferA.readUtf8());
-
-    operatorB.read(36, bufferB, 33);
-    assertEquals("Dodgson, we've got Dodgson here!\n", bufferB.readUtf8());
-  }
-
-  @Test public void largeRead() throws Exception {
-    ByteString data = randomByteString(1000000);
-    write(data);
-
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-
-    Buffer buffer = new Buffer();
-    operator.read(0, buffer, data.size());
-    assertEquals(data, buffer.readByteString());
-  }
-
-  @Test public void largeWrite() throws Exception {
-    ByteString data = randomByteString(1000000);
-
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-
-    Buffer buffer = new Buffer().write(data);
-    operator.write(0, buffer, data.size());
-
-    assertEquals(data, snapshot());
-  }
-
-  @Test public void readBounds() throws Exception {
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-    Buffer buffer = new Buffer();
-    try {
-      operator.read(0, buffer, -1L);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void writeBounds() throws Exception {
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-    Buffer buffer = new Buffer().writeUtf8("abc");
-    try {
-      operator.write(0, buffer, -1L);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-    try {
-      operator.write(0, buffer, 4L);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  private ByteString randomByteString(int byteCount) {
-    byte[] bytes = new byte[byteCount];
-    new Random(0).nextBytes(bytes);
-    return ByteString.of(bytes);
-  }
-
-  private ByteString snapshot() throws IOException {
-    randomAccessFile.getChannel().force(false);
-    BufferedSource source = Okio.buffer(Okio.source(file));
-    return source.readByteString();
-  }
-
-  private void write(ByteString data) throws IOException {
-    BufferedSink sink = Okio.buffer(Okio.sink(file));
-    sink.write(data);
-    sink.close();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
deleted file mode 100644
index cbffa87d09..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache2;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-import okio.Pipe;
-import okio.Source;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class RelayTest {
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-
-  private ExecutorService executor = Executors.newCachedThreadPool();
-  private ByteString metadata = ByteString.encodeUtf8("great metadata!");
-  private File file;
-
-  @Before public void setUp() throws Exception {
-    file = tempDir.newFile();
-  }
-
-  @After public void tearDown() throws Exception {
-    executor.shutdown();
-  }
-
-  @Test public void singleSource() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghijklm");
-
-    Relay relay = Relay.edit(file, upstream, metadata, 1024);
-    Source source = relay.newSource();
-    Buffer sourceBuffer = new Buffer();
-
-    assertEquals(5, source.read(sourceBuffer, 5));
-    assertEquals("abcde", sourceBuffer.readUtf8());
-
-    assertEquals(8, source.read(sourceBuffer, 1024));
-    assertEquals("fghijklm", sourceBuffer.readUtf8());
-
-    assertEquals(-1, source.read(sourceBuffer, 1024));
-    assertEquals(0, sourceBuffer.size());
-
-    source.close();
-    assertTrue(relay.isClosed());
-    assertFile(Relay.PREFIX_CLEAN, 13L, metadata.size(), "abcdefghijklm", metadata);
-  }
-
-  @Test public void multipleSources() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghijklm");
-
-    Relay relay = Relay.edit(file, upstream, metadata, 1024);
-    BufferedSource source1 = Okio.buffer(relay.newSource());
-    BufferedSource source2 = Okio.buffer(relay.newSource());
-
-    assertEquals("abcdefghijklm", source1.readUtf8());
-    assertEquals("abcdefghijklm", source2.readUtf8());
-    source1.close();
-    source2.close();
-    assertTrue(relay.isClosed());
-
-    assertFile(Relay.PREFIX_CLEAN, 13L, metadata.size(), "abcdefghijklm", metadata);
-  }
-
-  @Test public void readFromBuffer() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghij");
-
-    Relay relay = Relay.edit(file, upstream, metadata, 5);
-    BufferedSource source1 = Okio.buffer(relay.newSource());
-    BufferedSource source2 = Okio.buffer(relay.newSource());
-
-    assertEquals("abcde", source1.readUtf8(5));
-    assertEquals("abcde", source2.readUtf8(5));
-    assertEquals("fghij", source2.readUtf8(5));
-    assertEquals("fghij", source1.readUtf8(5));
-    assertTrue(source1.exhausted());
-    assertTrue(source2.exhausted());
-    source1.close();
-    source2.close();
-    assertTrue(relay.isClosed());
-
-    assertFile(Relay.PREFIX_CLEAN, 10L, metadata.size(), "abcdefghij", metadata);
-  }
-
-  @Test public void readFromFile() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghijklmnopqrst");
-
-    Relay relay = Relay.edit(file, upstream, metadata, 5);
-    BufferedSource source1 = Okio.buffer(relay.newSource());
-    BufferedSource source2 = Okio.buffer(relay.newSource());
-
-    assertEquals("abcdefghij", source1.readUtf8(10));
-    assertEquals("abcdefghij", source2.readUtf8(10));
-    assertEquals("klmnopqrst", source2.readUtf8(10));
-    assertEquals("klmnopqrst", source1.readUtf8(10));
-    assertTrue(source1.exhausted());
-    assertTrue(source2.exhausted());
-    source1.close();
-    source2.close();
-    assertTrue(relay.isClosed());
-
-    assertFile(Relay.PREFIX_CLEAN, 20L, metadata.size(), "abcdefghijklmnopqrst", metadata);
-  }
-
-  @Test public void readAfterEdit() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghij");
-
-    Relay relay1 = Relay.edit(file, upstream, metadata, 5);
-    BufferedSource source1 = Okio.buffer(relay1.newSource());
-    assertEquals("abcdefghij", source1.readUtf8(10));
-    assertTrue(source1.exhausted());
-    source1.close();
-    assertTrue(relay1.isClosed());
-
-    // Since relay1 is closed, new sources cannot be created.
-    assertNull(relay1.newSource());
-
-    Relay relay2 = Relay.read(file);
-    assertEquals(metadata, relay2.metadata());
-    BufferedSource source2 = Okio.buffer(relay2.newSource());
-    assertEquals("abcdefghij", source2.readUtf8(10));
-    assertTrue(source2.exhausted());
-    source2.close();
-    assertTrue(relay2.isClosed());
-
-    // Since relay2 is closed, new sources cannot be created.
-    assertNull(relay2.newSource());
-
-    assertFile(Relay.PREFIX_CLEAN, 10L, metadata.size(), "abcdefghij", metadata);
-  }
-
-  @Test public void closeBeforeExhaustLeavesDirtyFile() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghij");
-
-    Relay relay1 = Relay.edit(file, upstream, metadata, 5);
-    BufferedSource source1 = Okio.buffer(relay1.newSource());
-    assertEquals("abcdefghij", source1.readUtf8(10));
-    source1.close(); // Not exhausted!
-    assertTrue(relay1.isClosed());
-
-    try {
-      Relay.read(file);
-      fail();
-    } catch (IOException expected) {
-      assertEquals("unreadable cache file", expected.getMessage());
-    }
-
-    assertFile(Relay.PREFIX_DIRTY, -1L, -1, null, null);
-  }
-
-  @Test public void redundantCallsToCloseAreIgnored() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcde");
-
-    Relay relay = Relay.edit(file, upstream, metadata, 1024);
-    Source source1 = relay.newSource();
-    Source source2 = relay.newSource();
-
-    source1.close();
-    source1.close(); // Unnecessary. Shouldn't decrement the reference count.
-    assertFalse(relay.isClosed());
-
-    source2.close();
-    assertTrue(relay.isClosed());
-    assertFile(Relay.PREFIX_DIRTY, -1L, -1, null, null);
-  }
-
-  @Test public void racingReaders() throws Exception {
-    Pipe pipe = new Pipe(1024);
-    BufferedSink sink = Okio.buffer(pipe.sink());
-
-    Relay relay = Relay.edit(file, pipe.source(), metadata, 5);
-
-    Future<ByteString> future1 = executor.submit(sourceReader(relay.newSource()));
-    Future<ByteString> future2 = executor.submit(sourceReader(relay.newSource()));
-
-    Thread.sleep(500);
-    sink.writeUtf8("abcdefghij");
-
-    Thread.sleep(500);
-    sink.writeUtf8("klmnopqrst");
-    sink.close();
-
-    assertEquals(ByteString.encodeUtf8("abcdefghijklmnopqrst"), future1.get());
-    assertEquals(ByteString.encodeUtf8("abcdefghijklmnopqrst"), future2.get());
-
-    assertTrue(relay.isClosed());
-
-    assertFile(Relay.PREFIX_CLEAN, 20L, metadata.size(), "abcdefghijklmnopqrst", metadata);
-  }
-
-  /** Returns a callable that reads all of source, closes it, and returns the bytes. */
-  private Callable<ByteString> sourceReader(final Source source) {
-    return new Callable<ByteString>() {
-      @Override public ByteString call() throws Exception {
-        Buffer buffer = new Buffer();
-        while (source.read(buffer, 16384) != -1) {
-        }
-        source.close();
-        return buffer.readByteString();
-      }
-    };
-  }
-
-  private void assertFile(ByteString prefix, long upstreamSize, int metadataSize, String upstream,
-      ByteString metadata) throws IOException {
-    BufferedSource source = Okio.buffer(Okio.source(file));
-    assertEquals(prefix, source.readByteString(prefix.size()));
-    assertEquals(upstreamSize, source.readLong());
-    assertEquals(metadataSize, source.readLong());
-    if (upstream != null) {
-      assertEquals(upstream, source.readUtf8(upstreamSize));
-    }
-    if (metadata != null) {
-      assertEquals(metadata, source.readByteString(metadataSize));
-    }
-    source.close();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 3ef429a957..370b07ddc7 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -28,7 +28,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import javax.net.ssl.HostnameVerifier;
-import okhttp3.Cache;
+
 import okhttp3.Call;
 import okhttp3.Cookie;
 import okhttp3.Credentials;
@@ -86,11 +86,9 @@
   private SslClient sslClient = SslClient.localhost();
   private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private OkHttpClient client;
-  private Cache cache;
 
   @Before public void setUp() throws Exception {
     server.useHttps(sslClient.socketFactory, false);
-    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
     client = defaultClient().newBuilder()
         .protocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
         .dns(new SingleInetAddressDns())
@@ -473,7 +471,6 @@
 
   @Test public void responsesAreCached() throws IOException {
     client = client.newBuilder()
-        .cache(cache)
         .build();
 
     server.enqueue(new MockResponse()
@@ -486,9 +483,6 @@
     Response response1 = call1.execute();
 
     assertEquals("A", response1.body().string());
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
 
     Call call2 = client.newCall(new Request.Builder()
         .url(server.url("/"))
@@ -502,14 +496,10 @@
     Response response3 = call3.execute();
     assertEquals("A", response3.body().string());
 
-    assertEquals(3, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(2, cache.hitCount());
   }
 
   @Test public void conditionalCache() throws IOException {
     client = client.newBuilder()
-        .cache(cache)
         .build();
 
     server.enqueue(new MockResponse()
@@ -524,24 +514,16 @@
     Response response1 = call1.execute();
     assertEquals("A", response1.body().string());
 
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-
     Call call2 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
     assertEquals("A", response2.body().string());
 
-    assertEquals(2, cache.requestCount());
-    assertEquals(2, cache.networkCount());
-    assertEquals(1, cache.hitCount());
   }
 
   @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
     client = client.newBuilder()
-        .cache(cache)
         .build();
 
     server.enqueue(new MockResponse()
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
index 2a7f9c41e6..3713be0332 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
@@ -388,11 +388,6 @@ private Call buildCall() throws IOException {
     // Use a separate dispatcher so that limits aren't impacted. But use the same executor service!
     clientBuilder.dispatcher(new Dispatcher(client.dispatcher().executorService()));
 
-    // If we're currently not using caches, make sure the engine's client doesn't have one.
-    if (!getUseCaches()) {
-      clientBuilder.cache(null);
-    }
-
     return call = clientBuilder.build().newCall(request);
   }
 
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
index d0f706f0d0..5eba582cc4 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
@@ -34,20 +34,13 @@
   @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
   private OkUrlFactory factory;
-  private Cache cache;
 
   @Before public void setUp() throws IOException {
-    cache = new Cache(new File("/cache/"), 10 * 1024 * 1024, fileSystem);
     OkHttpClient client = new OkHttpClient.Builder()
-        .cache(cache)
         .build();
     factory = new OkUrlFactory(client);
   }
 
-  @After public void tearDown() throws IOException {
-    cache.delete();
-  }
-
   /**
    * Response code 407 should only come from proxy servers. Android's client throws if it is sent by
    * an origin server.
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
index ab4af9a350..287e8777ca 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
@@ -81,133 +81,8 @@
 
   private final SslClient sslClient = SslClient.localhost();
   private OkUrlFactory urlFactory = new OkUrlFactory(new OkHttpClient());
-  private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
 
-  @Before public void setUp() throws Exception {
-    server.setProtocolNegotiationEnabled(false);
-    cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-    urlFactory = new OkUrlFactory(new OkHttpClient.Builder()
-        .cache(cache)
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build());
-  }
-
-  @After public void tearDown() throws Exception {
-    ResponseCache.setDefault(null);
-    cache.delete();
-  }
-
-  @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
-    assertSame(cache, urlFactory.client().cache());
-  }
-
-  /**
-   * Test that response caching is consistent with the RI and the spec.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
-   */
-  @Test public void responseCachingByResponseCode() throws Exception {
-    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
-    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
-
-    // We can't test 100 because it's not really a response.
-    // assertCached(false, 100);
-    assertCached(false, 101);
-    assertCached(false, 102);
-    assertCached(true, 200);
-    assertCached(false, 201);
-    assertCached(false, 202);
-    assertCached(true, 203);
-    assertCached(true, 204);
-    assertCached(false, 205);
-    assertCached(false, 206); //Electing to not cache partial responses
-    assertCached(false, 207);
-    assertCached(true, 300);
-    assertCached(true, 301);
-    assertCached(true, 302);
-    assertCached(false, 303);
-    assertCached(false, 304);
-    assertCached(false, 305);
-    assertCached(false, 306);
-    assertCached(true, 307);
-    assertCached(true, 308);
-    assertCached(false, 400);
-    assertCached(false, 401);
-    assertCached(false, 402);
-    assertCached(false, 403);
-    assertCached(true, 404);
-    assertCached(true, 405);
-    assertCached(false, 406);
-    assertCached(false, 408);
-    assertCached(false, 409);
-    // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true, 410);
-    assertCached(false, 411);
-    assertCached(false, 412);
-    assertCached(false, 413);
-    assertCached(true, 414);
-    assertCached(false, 415);
-    assertCached(false, 416);
-    assertCached(false, 417);
-    assertCached(false, 418);
-
-    assertCached(false, 500);
-    assertCached(true, 501);
-    assertCached(false, 502);
-    assertCached(false, 503);
-    assertCached(false, 504);
-    assertCached(false, 505);
-    assertCached(false, 506);
-  }
-
-  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
-    int expectedResponseCode = responseCode;
-
-    server = new MockWebServer();
-    MockResponse response = new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(responseCode)
-        .setBody("ABCDE")
-        .addHeader("WWW-Authenticate: challenge");
-    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
-      response.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
-      response.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
-        || responseCode == HttpURLConnection.HTTP_RESET) {
-      response.setBody(""); // We forbid bodies for 204 and 205.
-    }
-    server.enqueue(response);
-
-    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
-      // 408's are a bit of an outlier because we may repeat the request if we encounter this
-      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
-      // because of the retry. We just want to ensure the initial 408 isn't cached.
-      expectedResponseCode = 200;
-      server.enqueue(new MockResponse()
-          .addHeader("Cache-Control", "no-store")
-          .setBody("FGHIJ"));
-    }
-
-    server.start();
-
-    URL url = server.url("/").url();
-    HttpURLConnection conn = urlFactory.open(url);
-    assertEquals(expectedResponseCode, conn.getResponseCode());
-
-    // exhaust the content stream
-    readAscii(conn);
-
-    Response cached = cache.get(new Request.Builder().url(url).build());
-    if (shouldPut) {
-      assertNotNull(Integer.toString(responseCode), cached);
-      cached.body().close();
-    } else {
-      assertNull(Integer.toString(responseCode), cached);
-    }
-    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
-  }
 
   @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
     testResponseCaching(TransferKind.FIXED_LENGTH);
@@ -241,8 +116,6 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
     assertEquals(-1, in.read());
     in.close();
-    assertEquals(1, cache.writeSuccessCount());
-    assertEquals(0, cache.writeAbortCount());
 
     urlConnection = urlFactory.open(server.url("/").url()); // cached!
     in = urlConnection.getInputStream();
@@ -253,10 +126,6 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
     assertEquals(-1, in.read());
     in.close();
-    assertEquals(1, cache.writeSuccessCount());
-    assertEquals(0, cache.writeAbortCount());
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.hitCount());
   }
 
   @Test public void secureResponseCaching() throws IOException {
@@ -284,9 +153,6 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     assertEquals("ABC", readAscii(c2));
 
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(1, cache.hitCount());
 
     assertEquals(suite, c2.getCipherSuite());
     assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
@@ -310,10 +176,6 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
     connection = urlFactory.open(server.url("/").url()); // cached!
     assertEquals("ABC", readAscii(connection));
-
-    assertEquals(4, cache.requestCount()); // 2 requests + 2 redirects
-    assertEquals(2, cache.networkCount());
-    assertEquals(2, cache.hitCount());
   }
 
   @Test public void redirectToCachedResult() throws Exception {
@@ -364,8 +226,6 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals("ABC", readAscii(connection2));
     assertNotNull(connection2.getCipherSuite());
 
-    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.hitCount());
     assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
   }
 
@@ -400,8 +260,6 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
     assertEquals("ABC", readAscii(connection2));
 
-    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.hitCount());
   }
 
   @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
@@ -435,12 +293,8 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
       reader.close();
     }
 
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(0, cache.writeSuccessCount());
     URLConnection connection = urlFactory.open(server.url("/").url());
     assertEquals("Request #2", readAscii(connection));
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(1, cache.writeSuccessCount());
   }
 
   @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
@@ -471,13 +325,6 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
       fail("Expected an IOException because the stream is closed.");
     } catch (IOException expected) {
     }
-
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(0, cache.writeSuccessCount());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("Request #2", readAscii(connection));
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(1, cache.writeSuccessCount());
   }
 
   @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
@@ -934,56 +781,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     assertEquals("B", readAscii(connection));
   }
 
-  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
-    // (no responses enqueued)
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-    assertEquals(1, cache.requestCount());
-    assertEquals(0, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-  }
-
-  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertEquals("A", readAscii(connection));
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(1, cache.hitCount());
-  }
 
-  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-  }
-
-  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-  }
 
   @Test public void requestCacheControlNoCache() throws Exception {
     server.enqueue(
@@ -1188,55 +986,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals(2, server.takeRequest().getSequenceNumber());
   }
 
-  @Test public void statisticsConditionalCacheMiss() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("C", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(3, cache.requestCount());
-    assertEquals(3, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-  }
-
-  @Test public void statisticsConditionalCacheHit() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(3, cache.requestCount());
-    assertEquals(3, cache.networkCount());
-    assertEquals(2, cache.hitCount());
-  }
-
-  @Test public void statisticsFullCacheHit() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
 
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(3, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(2, cache.hitCount());
-  }
 
   @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
     server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
@@ -1611,60 +1361,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
    *
    * https://github.com/square/okhttp/issues/227
    */
-  @Test public void testGoldenCacheResponse() throws Exception {
-    cache.close();
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    URL url = server.url("/").url();
-    String urlKey = Cache.key(HttpUrl.get(url));
-    String prefix = Platform.get().getPrefix();
-    String entryMetadata = ""
-        + "" + url + "\n"
-        + "GET\n"
-        + "0\n"
-        + "HTTP/1.1 200 OK\n"
-        + "7\n"
-        + ":status: 200 OK\n"
-        + ":version: HTTP/1.1\n"
-        + "etag: foo\n"
-        + "content-length: 3\n"
-        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + "X-Android-Response-Source: NETWORK 200\n"
-        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
-        + "\n"
-        + "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n"
-        + "1\n"
-        + "MIIBpDCCAQ2gAwIBAgIBATANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDEw1qd2lsc29uLmxvY2FsMB4XDTEzMDgy"
-        + "OTA1MDE1OVoXDTEzMDgzMDA1MDE1OVowGDEWMBQGA1UEAxMNandpbHNvbi5sb2NhbDCBnzANBgkqhkiG9w0BAQEF"
-        + "AAOBjQAwgYkCgYEAlFW+rGo/YikCcRghOyKkJanmVmJSce/p2/jH1QvNIFKizZdh8AKNwojt3ywRWaDULA/RlCUc"
-        + "ltF3HGNsCyjQI/+Lf40x7JpxXF8oim1E6EtDoYtGWAseelawus3IQ13nmo6nWzfyCA55KhAWf4VipelEy8DjcuFK"
-        + "v6L0xwXnI0ECAwEAATANBgkqhkiG9w0BAQsFAAOBgQAuluNyPo1HksU3+Mr/PyRQIQS4BI7pRXN8mcejXmqyscdP"
-        + "7S6J21FBFeRR8/XNjVOp4HT9uSc2hrRtTEHEZCmpyoxixbnM706ikTmC7SN/GgM+SmcoJ1ipJcNcl8N0X6zym4dm"
-        + "yFfXKHu2PkTo7QFdpOJFvP3lIigcSZXozfmEDg==\n"
-        + "-1\n";
-    String entryBody = "abc";
-    String journalBody = ""
-        + "libcore.io.DiskLruCache\n"
-        + "1\n"
-        + "201105\n"
-        + "2\n"
-        + "\n"
-        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.directory(), urlKey + ".1", entryBody);
-    writeFile(cache.directory(), "journal", journalBody);
-    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .cache(cache)
-        .build());
-
-    HttpURLConnection connection = urlFactory.open(url);
-    assertEquals(entryBody, readAscii(connection));
-    assertEquals("3", connection.getHeaderField("Content-Length"));
-    assertEquals("foo", connection.getHeaderField("etag"));
-  }
 
   private void writeFile(File directory, String file, String content) throws IOException {
     BufferedSink sink = Okio.buffer(fileSystem.sink(new File(directory, file)));
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
index ec0de83e52..68aeb7a195 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
@@ -27,9 +27,6 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.internal.Internal;
-import okhttp3.internal.cache.CacheRequest;
-import okhttp3.internal.cache.CacheStrategy;
-import okhttp3.internal.cache.InternalCache;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -124,37 +121,6 @@ private URI backdoorUrlToUri(URL url) throws Exception {
     final AtomicReference<URI> uriReference = new AtomicReference<>();
 
     OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    Internal.instance.setCache(builder, new InternalCache() {
-      @Override public Response get(Request request) throws IOException {
-        uriReference.set(request.url().uri());
-        throw new UnsupportedOperationException();
-      }
-
-      @Override public CacheRequest put(Response response) throws IOException {
-        return null;
-      }
-
-      @Override public void remove(Request request) throws IOException {
-      }
-
-      @Override public void update(Response cached, Response network) {
-      }
-
-      @Override public void trackConditionalCacheHit() {
-      }
-
-      @Override public void trackResponse(CacheStrategy cacheStrategy) {
-      }
-    });
-
-    try {
-      HttpURLConnection connection = new OkUrlFactory(builder.build()).open(url);
-      connection.getResponseCode();
-    } catch (Exception expected) {
-      if (expected.getCause() instanceof URISyntaxException) {
-        expected.printStackTrace();
-      }
-    }
 
     return uriReference.get();
   }
diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
deleted file mode 100644
index 6ed941b8f2..0000000000
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ /dev/null
@@ -1,773 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.Closeable;
-import java.io.File;
-import java.io.Flushable;
-import java.io.IOException;
-import java.security.cert.Certificate;
-import java.security.cert.CertificateEncodingException;
-import java.security.cert.CertificateException;
-import java.security.cert.CertificateFactory;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.NoSuchElementException;
-import okhttp3.internal.Util;
-import okhttp3.internal.cache.CacheRequest;
-import okhttp3.internal.cache.CacheStrategy;
-import okhttp3.internal.cache.DiskLruCache;
-import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.StatusLine;
-import okhttp3.internal.io.FileSystem;
-import okhttp3.internal.platform.Platform;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.ForwardingSink;
-import okio.ForwardingSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-
-/**
- * Caches HTTP and HTTPS responses to the filesystem so they may be reused, saving time and
- * bandwidth.
- *
- * <h3>Cache Optimization</h3>
- *
- * <p>To measure cache effectiveness, this class tracks three statistics:
- * <ul>
- *     <li><strong>{@linkplain #requestCount() Request Count:}</strong> the number of HTTP
- *         requests issued since this cache was created.
- *     <li><strong>{@linkplain #networkCount() Network Count:}</strong> the number of those
- *         requests that required network use.
- *     <li><strong>{@linkplain #hitCount() Hit Count:}</strong> the number of those requests
- *         whose responses were served by the cache.
- * </ul>
- *
- * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
- * the response, the client will issue a conditional {@code GET}. The server will then send either
- * the updated response if it has changed, or a short 'not modified' response if the client's copy
- * is still valid. Such responses increment both the network count and hit count.
- *
- * <p>The best way to improve the cache hit rate is by configuring the web server to return
- * cacheable responses. Although this client honors all <a
- * href="http://tools.ietf.org/html/rfc7234">HTTP/1.1 (RFC 7234)</a> cache headers, it doesn't cache
- * partial responses.
- *
- * <h3>Force a Network Response</h3>
- *
- * <p>In some situations, such as after a user clicks a 'refresh' button, it may be necessary to
- * skip the cache, and fetch data directly from the server. To force a full refresh, add the {@code
- * no-cache} directive: <pre>   {@code
- *
- *   Request request = new Request.Builder()
- *       .cacheControl(new CacheControl.Builder().noCache().build())
- *       .url("http://publicobject.com/helloworld.txt")
- *       .build();
- * }</pre>
- *
- * If it is only necessary to force a cached response to be validated by the server, use the more
- * efficient {@code max-age=0} directive instead: <pre>   {@code
- *
- *   Request request = new Request.Builder()
- *       .cacheControl(new CacheControl.Builder()
- *           .maxAge(0, TimeUnit.SECONDS)
- *           .build())
- *       .url("http://publicobject.com/helloworld.txt")
- *       .build();
- * }</pre>
- *
- * <h3>Force a Cache Response</h3>
- *
- * <p>Sometimes you'll want to show resources if they are available immediately, but not otherwise.
- * This can be used so your application can show <i>something</i> while waiting for the latest data
- * to be downloaded. To restrict a request to locally-cached resources, add the {@code
- * only-if-cached} directive: <pre>   {@code
- *
- *     Request request = new Request.Builder()
- *         .cacheControl(new CacheControl.Builder()
- *             .onlyIfCached()
- *             .build())
- *         .url("http://publicobject.com/helloworld.txt")
- *         .build();
- *     Response forceCacheResponse = client.newCall(request).execute();
- *     if (forceCacheResponse.code() != 504) {
- *       // The resource was cached! Show it.
- *     } else {
- *       // The resource was not cached.
- *     }
- * }</pre>
- * This technique works even better in situations where a stale response is better than no response.
- * To permit stale cached responses, use the {@code max-stale} directive with the maximum staleness
- * in seconds: <pre>   {@code
- *
- *   Request request = new Request.Builder()
- *       .cacheControl(new CacheControl.Builder()
- *           .maxStale(365, TimeUnit.DAYS)
- *           .build())
- *       .url("http://publicobject.com/helloworld.txt")
- *       .build();
- * }</pre>
- *
- * <p>The {@link CacheControl} class can configure request caching directives and parse response
- * caching directives. It even offers convenient constants {@link CacheControl#FORCE_NETWORK} and
- * {@link CacheControl#FORCE_CACHE} that address the use cases above.
- */
-public final class Cache implements Closeable, Flushable {
-  private static final int VERSION = 201105;
-  private static final int ENTRY_METADATA = 0;
-  private static final int ENTRY_BODY = 1;
-  private static final int ENTRY_COUNT = 2;
-
-  final InternalCache internalCache = new InternalCache() {
-    @Override public Response get(Request request) throws IOException {
-      return Cache.this.get(request);
-    }
-
-    @Override public CacheRequest put(Response response) throws IOException {
-      return Cache.this.put(response);
-    }
-
-    @Override public void remove(Request request) throws IOException {
-      Cache.this.remove(request);
-    }
-
-    @Override public void update(Response cached, Response network) {
-      Cache.this.update(cached, network);
-    }
-
-    @Override public void trackConditionalCacheHit() {
-      Cache.this.trackConditionalCacheHit();
-    }
-
-    @Override public void trackResponse(CacheStrategy cacheStrategy) {
-      Cache.this.trackResponse(cacheStrategy);
-    }
-  };
-
-  final DiskLruCache cache;
-
-  /* read and write statistics, all guarded by 'this' */
-  int writeSuccessCount;
-  int writeAbortCount;
-  private int networkCount;
-  private int hitCount;
-  private int requestCount;
-
-  public Cache(File directory, long maxSize) {
-    this(directory, maxSize, FileSystem.SYSTEM);
-  }
-
-  Cache(File directory, long maxSize, FileSystem fileSystem) {
-    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);
-  }
-
-  public static String key(HttpUrl url) {
-    return ByteString.encodeUtf8(url.toString()).md5().hex();
-  }
-
-  Response get(Request request) {
-    String key = key(request.url());
-    DiskLruCache.Snapshot snapshot;
-    Entry entry;
-    try {
-      snapshot = cache.get(key);
-      if (snapshot == null) {
-        return null;
-      }
-    } catch (IOException e) {
-      // Give up because the cache cannot be read.
-      return null;
-    }
-
-    try {
-      entry = new Entry(snapshot.getSource(ENTRY_METADATA));
-    } catch (IOException e) {
-      Util.closeQuietly(snapshot);
-      return null;
-    }
-
-    Response response = entry.response(snapshot);
-
-    if (!entry.matches(request, response)) {
-      Util.closeQuietly(response.body());
-      return null;
-    }
-
-    return response;
-  }
-
-  CacheRequest put(Response response) {
-    String requestMethod = response.request().method();
-
-    if (HttpMethod.invalidatesCache(response.request().method())) {
-      try {
-        remove(response.request());
-      } catch (IOException ignored) {
-        // The cache cannot be written.
-      }
-      return null;
-    }
-    if (!requestMethod.equals("GET")) {
-      // Don't cache non-GET responses. We're technically allowed to cache
-      // HEAD requests and some POST requests, but the complexity of doing
-      // so is high and the benefit is low.
-      return null;
-    }
-
-    if (HttpHeaders.hasVaryAll(response)) {
-      return null;
-    }
-
-    Entry entry = new Entry(response);
-    DiskLruCache.Editor editor = null;
-    try {
-      editor = cache.edit(key(response.request().url()));
-      if (editor == null) {
-        return null;
-      }
-      entry.writeTo(editor);
-      return new CacheRequestImpl(editor);
-    } catch (IOException e) {
-      abortQuietly(editor);
-      return null;
-    }
-  }
-
-  void remove(Request request) throws IOException {
-    cache.remove(key(request.url()));
-  }
-
-  void update(Response cached, Response network) {
-    Entry entry = new Entry(network);
-    DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
-    DiskLruCache.Editor editor = null;
-    try {
-      editor = snapshot.edit(); // Returns null if snapshot is not current.
-      if (editor != null) {
-        entry.writeTo(editor);
-        editor.commit();
-      }
-    } catch (IOException e) {
-      abortQuietly(editor);
-    }
-  }
-
-  private void abortQuietly(DiskLruCache.Editor editor) {
-    // Give up because the cache cannot be written.
-    try {
-      if (editor != null) {
-        editor.abort();
-      }
-    } catch (IOException ignored) {
-    }
-  }
-
-  /**
-   * Initialize the cache. This will include reading the journal files from the storage and building
-   * up the necessary in-memory cache information.
-   *
-   * <p>The initialization time may vary depending on the journal file size and the current actual
-   * cache size. The application needs to be aware of calling this function during the
-   * initialization phase and preferably in a background worker thread.
-   *
-   * <p>Note that if the application chooses to not call this method to initialize the cache. By
-   * default, the okhttp will perform lazy initialization upon the first usage of the cache.
-   */
-  public void initialize() throws IOException {
-    cache.initialize();
-  }
-
-  /**
-   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
-   * directory including files that weren't created by the cache.
-   */
-  public void delete() throws IOException {
-    cache.delete();
-  }
-
-  /**
-   * Deletes all values stored in the cache. In-flight writes to the cache will complete normally,
-   * but the corresponding responses will not be stored.
-   */
-  public void evictAll() throws IOException {
-    cache.evictAll();
-  }
-
-  /**
-   * Returns an iterator over the URLs in this cache. This iterator doesn't throw {@code
-   * ConcurrentModificationException}, but if new responses are added while iterating, their URLs
-   * will not be returned. If existing responses are evicted during iteration, they will be absent
-   * (unless they were already returned).
-   *
-   * <p>The iterator supports {@linkplain Iterator#remove}. Removing a URL from the iterator evicts
-   * the corresponding response from the cache. Use this to evict selected responses.
-   */
-  public Iterator<String> urls() throws IOException {
-    return new Iterator<String>() {
-      final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
-
-      String nextUrl;
-      boolean canRemove;
-
-      @Override public boolean hasNext() {
-        if (nextUrl != null) return true;
-
-        canRemove = false; // Prevent delegate.remove() on the wrong item!
-        while (delegate.hasNext()) {
-          DiskLruCache.Snapshot snapshot = delegate.next();
-          try {
-            BufferedSource metadata = Okio.buffer(snapshot.getSource(ENTRY_METADATA));
-            nextUrl = metadata.readUtf8LineStrict();
-            return true;
-          } catch (IOException ignored) {
-            // We couldn't read the metadata for this snapshot; possibly because the host filesystem
-            // has disappeared! Skip it.
-          } finally {
-            snapshot.close();
-          }
-        }
-
-        return false;
-      }
-
-      @Override public String next() {
-        if (!hasNext()) throw new NoSuchElementException();
-        String result = nextUrl;
-        nextUrl = null;
-        canRemove = true;
-        return result;
-      }
-
-      @Override public void remove() {
-        if (!canRemove) throw new IllegalStateException("remove() before next()");
-        delegate.remove();
-      }
-    };
-  }
-
-  public synchronized int writeAbortCount() {
-    return writeAbortCount;
-  }
-
-  public synchronized int writeSuccessCount() {
-    return writeSuccessCount;
-  }
-
-  public long size() throws IOException {
-    return cache.size();
-  }
-
-  public long maxSize() {
-    return cache.getMaxSize();
-  }
-
-  @Override public void flush() throws IOException {
-    cache.flush();
-  }
-
-  @Override public void close() throws IOException {
-    cache.close();
-  }
-
-  public File directory() {
-    return cache.getDirectory();
-  }
-
-  public boolean isClosed() {
-    return cache.isClosed();
-  }
-
-  synchronized void trackResponse(CacheStrategy cacheStrategy) {
-    requestCount++;
-
-    if (cacheStrategy.networkRequest != null) {
-      // If this is a conditional request, we'll increment hitCount if/when it hits.
-      networkCount++;
-    } else if (cacheStrategy.cacheResponse != null) {
-      // This response uses the cache and not the network. That's a cache hit.
-      hitCount++;
-    }
-  }
-
-  synchronized void trackConditionalCacheHit() {
-    hitCount++;
-  }
-
-  public synchronized int networkCount() {
-    return networkCount;
-  }
-
-  public synchronized int hitCount() {
-    return hitCount;
-  }
-
-  public synchronized int requestCount() {
-    return requestCount;
-  }
-
-  private final class CacheRequestImpl implements CacheRequest {
-    private final DiskLruCache.Editor editor;
-    private Sink cacheOut;
-    private Sink body;
-    boolean done;
-
-    public CacheRequestImpl(final DiskLruCache.Editor editor) {
-      this.editor = editor;
-      this.cacheOut = editor.newSink(ENTRY_BODY);
-      this.body = new ForwardingSink(cacheOut) {
-        @Override public void close() throws IOException {
-          synchronized (Cache.this) {
-            if (done) {
-              return;
-            }
-            done = true;
-            writeSuccessCount++;
-          }
-          super.close();
-          editor.commit();
-        }
-      };
-    }
-
-    @Override public void abort() {
-      synchronized (Cache.this) {
-        if (done) {
-          return;
-        }
-        done = true;
-        writeAbortCount++;
-      }
-      Util.closeQuietly(cacheOut);
-      try {
-        editor.abort();
-      } catch (IOException ignored) {
-      }
-    }
-
-    @Override public Sink body() {
-      return body;
-    }
-  }
-
-  private static final class Entry {
-    /** Synthetic response header: the local time when the request was sent. */
-    private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
-
-    /** Synthetic response header: the local time when the response was received. */
-    private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
-
-    private final String url;
-    private final Headers varyHeaders;
-    private final String requestMethod;
-    private final Protocol protocol;
-    private final int code;
-    private final String message;
-    private final Headers responseHeaders;
-    private final Handshake handshake;
-    private final long sentRequestMillis;
-    private final long receivedResponseMillis;
-
-    /**
-     * Reads an entry from an input stream. A typical entry looks like this:
-     * <pre>{@code
-     *   http://google.com/foo
-     *   GET
-     *   2
-     *   Accept-Language: fr-CA
-     *   Accept-Charset: UTF-8
-     *   HTTP/1.1 200 OK
-     *   3
-     *   Content-Type: image/png
-     *   Content-Length: 100
-     *   Cache-Control: max-age=600
-     * }</pre>
-     *
-     * <p>A typical HTTPS file looks like this:
-     * <pre>{@code
-     *   https://google.com/foo
-     *   GET
-     *   2
-     *   Accept-Language: fr-CA
-     *   Accept-Charset: UTF-8
-     *   HTTP/1.1 200 OK
-     *   3
-     *   Content-Type: image/png
-     *   Content-Length: 100
-     *   Cache-Control: max-age=600
-     *
-     *   AES_256_WITH_MD5
-     *   2
-     *   base64-encoded peerCertificate[0]
-     *   base64-encoded peerCertificate[1]
-     *   -1
-     *   TLSv1.2
-     * }</pre>
-     * The file is newline separated. The first two lines are the URL and the request method. Next
-     * is the number of HTTP Vary request header lines, followed by those lines.
-     *
-     * <p>Next is the response status line, followed by the number of HTTP response header lines,
-     * followed by those lines.
-     *
-     * <p>HTTPS responses also contain SSL session information. This begins with a blank line, and
-     * then a line containing the cipher suite. Next is the length of the peer certificate chain.
-     * These certificates are base64-encoded and appear each on their own line. The next line
-     * contains the length of the local certificate chain. These certificates are also
-     * base64-encoded and appear each on their own line. A length of -1 is used to encode a null
-     * array. The last line is optional. If present, it contains the TLS version.
-     */
-    public Entry(Source in) throws IOException {
-      try {
-        BufferedSource source = Okio.buffer(in);
-        url = source.readUtf8LineStrict();
-        requestMethod = source.readUtf8LineStrict();
-        Headers.Builder varyHeadersBuilder = new Headers.Builder();
-        int varyRequestHeaderLineCount = readInt(source);
-        for (int i = 0; i < varyRequestHeaderLineCount; i++) {
-          varyHeadersBuilder.addLenient(source.readUtf8LineStrict());
-        }
-        varyHeaders = varyHeadersBuilder.build();
-
-        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
-        protocol = statusLine.protocol;
-        code = statusLine.code;
-        message = statusLine.message;
-        Headers.Builder responseHeadersBuilder = new Headers.Builder();
-        int responseHeaderLineCount = readInt(source);
-        for (int i = 0; i < responseHeaderLineCount; i++) {
-          responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
-        }
-        String sendRequestMillisString = responseHeadersBuilder.get(SENT_MILLIS);
-        String receivedResponseMillisString = responseHeadersBuilder.get(RECEIVED_MILLIS);
-        responseHeadersBuilder.removeAll(SENT_MILLIS);
-        responseHeadersBuilder.removeAll(RECEIVED_MILLIS);
-        sentRequestMillis = sendRequestMillisString != null
-            ? Long.parseLong(sendRequestMillisString)
-            : 0L;
-        receivedResponseMillis = receivedResponseMillisString != null
-            ? Long.parseLong(receivedResponseMillisString)
-            : 0L;
-        responseHeaders = responseHeadersBuilder.build();
-
-        if (isHttps()) {
-          String blank = source.readUtf8LineStrict();
-          if (blank.length() > 0) {
-            throw new IOException("expected \"\" but was \"" + blank + "\"");
-          }
-          String cipherSuiteString = source.readUtf8LineStrict();
-          CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-          List<Certificate> peerCertificates = readCertificateList(source);
-          List<Certificate> localCertificates = readCertificateList(source);
-          TlsVersion tlsVersion = !source.exhausted()
-              ? TlsVersion.forJavaName(source.readUtf8LineStrict())
-              : null;
-          handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);
-        } else {
-          handshake = null;
-        }
-      } finally {
-        in.close();
-      }
-    }
-
-    public Entry(Response response) {
-      this.url = response.request().url().toString();
-      this.varyHeaders = HttpHeaders.varyHeaders(response);
-      this.requestMethod = response.request().method();
-      this.protocol = response.protocol();
-      this.code = response.code();
-      this.message = response.message();
-      this.responseHeaders = response.headers();
-      this.handshake = response.handshake();
-      this.sentRequestMillis = response.sentRequestAtMillis();
-      this.receivedResponseMillis = response.receivedResponseAtMillis();
-    }
-
-    public void writeTo(DiskLruCache.Editor editor) throws IOException {
-      BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
-
-      sink.writeUtf8(url)
-          .writeByte('\n');
-      sink.writeUtf8(requestMethod)
-          .writeByte('\n');
-      sink.writeDecimalLong(varyHeaders.size())
-          .writeByte('\n');
-      for (int i = 0, size = varyHeaders.size(); i < size; i++) {
-        sink.writeUtf8(varyHeaders.name(i))
-            .writeUtf8(": ")
-            .writeUtf8(varyHeaders.value(i))
-            .writeByte('\n');
-      }
-
-      sink.writeUtf8(new StatusLine(protocol, code, message).toString())
-          .writeByte('\n');
-      sink.writeDecimalLong(responseHeaders.size() + 2)
-          .writeByte('\n');
-      for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-        sink.writeUtf8(responseHeaders.name(i))
-            .writeUtf8(": ")
-            .writeUtf8(responseHeaders.value(i))
-            .writeByte('\n');
-      }
-      sink.writeUtf8(SENT_MILLIS)
-          .writeUtf8(": ")
-          .writeDecimalLong(sentRequestMillis)
-          .writeByte('\n');
-      sink.writeUtf8(RECEIVED_MILLIS)
-          .writeUtf8(": ")
-          .writeDecimalLong(receivedResponseMillis)
-          .writeByte('\n');
-
-      if (isHttps()) {
-        sink.writeByte('\n');
-        sink.writeUtf8(handshake.cipherSuite().javaName())
-            .writeByte('\n');
-        writeCertList(sink, handshake.peerCertificates());
-        writeCertList(sink, handshake.localCertificates());
-        // The handshakes TLS version is null on HttpsURLConnection and on older cached responses.
-        if (handshake.tlsVersion() != null) {
-          sink.writeUtf8(handshake.tlsVersion().javaName())
-              .writeByte('\n');
-        }
-      }
-      sink.close();
-    }
-
-    private boolean isHttps() {
-      return url.startsWith("https://");
-    }
-
-    private List<Certificate> readCertificateList(BufferedSource source) throws IOException {
-      int length = readInt(source);
-      if (length == -1) return Collections.emptyList(); // OkHttp v1.2 used -1 to indicate null.
-
-      try {
-        CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-        List<Certificate> result = new ArrayList<>(length);
-        for (int i = 0; i < length; i++) {
-          String line = source.readUtf8LineStrict();
-          Buffer bytes = new Buffer();
-          bytes.write(ByteString.decodeBase64(line));
-          result.add(certificateFactory.generateCertificate(bytes.inputStream()));
-        }
-        return result;
-      } catch (CertificateException e) {
-        throw new IOException(e.getMessage());
-      }
-    }
-
-    private void writeCertList(BufferedSink sink, List<Certificate> certificates)
-        throws IOException {
-      try {
-        sink.writeDecimalLong(certificates.size())
-            .writeByte('\n');
-        for (int i = 0, size = certificates.size(); i < size; i++) {
-          byte[] bytes = certificates.get(i).getEncoded();
-          String line = ByteString.of(bytes).base64();
-          sink.writeUtf8(line)
-              .writeByte('\n');
-        }
-      } catch (CertificateEncodingException e) {
-        throw new IOException(e.getMessage());
-      }
-    }
-
-    public boolean matches(Request request, Response response) {
-      return url.equals(request.url().toString())
-          && requestMethod.equals(request.method())
-          && HttpHeaders.varyMatches(response, varyHeaders, request);
-    }
-
-    public Response response(DiskLruCache.Snapshot snapshot) {
-      String contentType = responseHeaders.get("Content-Type");
-      String contentLength = responseHeaders.get("Content-Length");
-      Request cacheRequest = new Request.Builder()
-          .url(url)
-          .method(requestMethod, null)
-          .headers(varyHeaders)
-          .build();
-      return new Response.Builder()
-          .request(cacheRequest)
-          .protocol(protocol)
-          .code(code)
-          .message(message)
-          .headers(responseHeaders)
-          .body(new CacheResponseBody(snapshot, contentType, contentLength))
-          .handshake(handshake)
-          .sentRequestAtMillis(sentRequestMillis)
-          .receivedResponseAtMillis(receivedResponseMillis)
-          .build();
-    }
-  }
-
-  static int readInt(BufferedSource source) throws IOException {
-    try {
-      long result = source.readDecimalLong();
-      String line = source.readUtf8LineStrict();
-      if (result < 0 || result > Integer.MAX_VALUE || !line.isEmpty()) {
-        throw new IOException("expected an int but was \"" + result + line + "\"");
-      }
-      return (int) result;
-    } catch (NumberFormatException e) {
-      throw new IOException(e.getMessage());
-    }
-  }
-
-  private static class CacheResponseBody extends ResponseBody {
-    final DiskLruCache.Snapshot snapshot;
-    private final BufferedSource bodySource;
-    private final String contentType;
-    private final String contentLength;
-
-    public CacheResponseBody(final DiskLruCache.Snapshot snapshot,
-        String contentType, String contentLength) {
-      this.snapshot = snapshot;
-      this.contentType = contentType;
-      this.contentLength = contentLength;
-
-      Source source = snapshot.getSource(ENTRY_BODY);
-      bodySource = Okio.buffer(new ForwardingSource(source) {
-        @Override public void close() throws IOException {
-          snapshot.close();
-          super.close();
-        }
-      });
-    }
-
-    @Override public MediaType contentType() {
-      return contentType != null ? MediaType.parse(contentType) : null;
-    }
-
-    @Override public long contentLength() {
-      try {
-        return contentLength != null ? Long.parseLong(contentLength) : -1;
-      } catch (NumberFormatException e) {
-        return -1;
-      }
-    }
-
-    @Override public BufferedSource source() {
-      return bodySource;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index da648d84cf..8d4bfd3d65 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -17,7 +17,6 @@
 
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
-import okhttp3.internal.cache.InternalCache;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
 import okhttp3.internal.connection.StreamAllocation;
@@ -99,12 +98,6 @@
  *     client.connectionPool().evictAll();
  * }</pre>
  *
- * <p>If your client has a cache, call {@link Cache#close close()}. Note that it is an error to
- * create calls against a cache that is closed, and doing so will cause the call to crash.
- * <pre>   {@code
- *
- *     client.cache().close();
- * }</pre>
  *
  * <p>OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
  * remain idle.
@@ -126,10 +119,6 @@
         builder.addLenient(name, value);
       }
 
-      @Override public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) {
-        builder.setInternalCache(internalCache);
-      }
-
       @Override public boolean connectionBecameIdle(
           ConnectionPool pool, RealConnection connection) {
         return pool.connectionBecameIdle(connection);
@@ -189,8 +178,6 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
   final List<Interceptor> networkInterceptors;
   final ProxySelector proxySelector;
   final CookieJar cookieJar;
-  final Cache cache;
-  final InternalCache internalCache;
   final SocketFactory socketFactory;
   final SSLSocketFactory sslSocketFactory;
   final CertificateChainCleaner certificateChainCleaner;
@@ -221,8 +208,6 @@ public OkHttpClient() {
     this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
     this.proxySelector = builder.proxySelector;
     this.cookieJar = builder.cookieJar;
-    this.cache = builder.cache;
-    this.internalCache = builder.internalCache;
     this.socketFactory = builder.socketFactory;
 
     boolean isTLS = false;
@@ -313,14 +298,6 @@ public CookieJar cookieJar() {
     return cookieJar;
   }
 
-  public Cache cache() {
-    return cache;
-  }
-
-  InternalCache internalCache() {
-    return cache != null ? cache.internalCache : internalCache;
-  }
-
   public Dns dns() {
     return dns;
   }
@@ -424,8 +401,6 @@ public Builder newBuilder() {
     final List<Interceptor> networkInterceptors = new ArrayList<>();
     ProxySelector proxySelector;
     CookieJar cookieJar;
-    Cache cache;
-    InternalCache internalCache;
     SocketFactory socketFactory;
     SSLSocketFactory sslSocketFactory;
     CertificateChainCleaner certificateChainCleaner;
@@ -474,8 +449,6 @@ public Builder() {
       this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
       this.proxySelector = okHttpClient.proxySelector;
       this.cookieJar = okHttpClient.cookieJar;
-      this.internalCache = okHttpClient.internalCache;
-      this.cache = okHttpClient.cache;
       this.socketFactory = okHttpClient.socketFactory;
       this.sslSocketFactory = okHttpClient.sslSocketFactory;
       this.certificateChainCleaner = okHttpClient.certificateChainCleaner;
@@ -579,18 +552,6 @@ public Builder cookieJar(CookieJar cookieJar) {
       return this;
     }
 
-    /** Sets the response cache to be used to read and write cached responses. */
-    void setInternalCache(InternalCache internalCache) {
-      this.internalCache = internalCache;
-      this.cache = null;
-    }
-
-    /** Sets the response cache to be used to read and write cached responses. */
-    public Builder cache(Cache cache) {
-      this.cache = cache;
-      this.internalCache = null;
-      return this;
-    }
 
     /**
      * Sets the DNS service used to lookup IP addresses for hostnames.
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index 1be96fd3e7..66aebfbf5f 100644
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -29,7 +29,6 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.Route;
-import okhttp3.internal.cache.InternalCache;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
 import okhttp3.internal.connection.StreamAllocation;
@@ -51,8 +50,6 @@ public static void initializeInstanceForTests() {
 
   public abstract void addLenient(Headers.Builder builder, String name, String value);
 
-  public abstract void setCache(OkHttpClient.Builder builder, InternalCache internalCache);
-
   public abstract RealConnection get(ConnectionPool pool, Address address,
       StreamAllocation streamAllocation, Route route);
 
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java
deleted file mode 100644
index b4432b4e1d..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.io.IOException;
-import okio.Sink;
-
-public interface CacheRequest {
-  Sink body() throws IOException;
-
-  void abort();
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
deleted file mode 100644
index dae556bb98..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ /dev/null
@@ -1,324 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.util.Date;
-import okhttp3.CacheControl;
-import okhttp3.Headers;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Internal;
-import okhttp3.internal.http.HttpDate;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.StatusLine;
-
-import static java.net.HttpURLConnection.HTTP_BAD_METHOD;
-import static java.net.HttpURLConnection.HTTP_GONE;
-import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
-import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
-import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
-import static java.net.HttpURLConnection.HTTP_NOT_AUTHORITATIVE;
-import static java.net.HttpURLConnection.HTTP_NOT_FOUND;
-import static java.net.HttpURLConnection.HTTP_NOT_IMPLEMENTED;
-import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
-import static java.net.HttpURLConnection.HTTP_OK;
-import static java.net.HttpURLConnection.HTTP_REQ_TOO_LONG;
-import static java.util.concurrent.TimeUnit.SECONDS;
-
-/**
- * Given a request and cached response, this figures out whether to use the network, the cache, or
- * both.
- *
- * <p>Selecting a cache strategy may add conditions to the request (like the "If-Modified-Since"
- * header for conditional GETs) or warnings to the cached response (if the cached data is
- * potentially stale).
- */
-public final class CacheStrategy {
-  /** The request to send on the network, or null if this call doesn't use the network. */
-  public final Request networkRequest;
-
-  /** The cached response to return or validate; or null if this call doesn't use a cache. */
-  public final Response cacheResponse;
-
-  CacheStrategy(Request networkRequest, Response cacheResponse) {
-    this.networkRequest = networkRequest;
-    this.cacheResponse = cacheResponse;
-  }
-
-  /** Returns true if {@code response} can be stored to later serve another request. */
-  public static boolean isCacheable(Response response, Request request) {
-    // Always go to network for uncacheable response codes (RFC 7231 section 6.1),
-    // This implementation doesn't support caching partial content.
-    switch (response.code()) {
-      case HTTP_OK:
-      case HTTP_NOT_AUTHORITATIVE:
-      case HTTP_NO_CONTENT:
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_NOT_FOUND:
-      case HTTP_BAD_METHOD:
-      case HTTP_GONE:
-      case HTTP_REQ_TOO_LONG:
-      case HTTP_NOT_IMPLEMENTED:
-      case StatusLine.HTTP_PERM_REDIRECT:
-        // These codes can be cached unless headers forbid it.
-        break;
-
-      case HTTP_MOVED_TEMP:
-      case StatusLine.HTTP_TEMP_REDIRECT:
-        // These codes can only be cached with the right response headers.
-        // http://tools.ietf.org/html/rfc7234#section-3
-        // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.
-        if (response.header("Expires") != null
-            || response.cacheControl().maxAgeSeconds() != -1
-            || response.cacheControl().isPublic()
-            || response.cacheControl().isPrivate()) {
-          break;
-        }
-        // Fall-through.
-
-      default:
-        // All other codes cannot be cached.
-        return false;
-    }
-
-    // A 'no-store' directive on request or response prevents the response from being cached.
-    return !response.cacheControl().noStore() && !request.cacheControl().noStore();
-  }
-
-  public static class Factory {
-    final long nowMillis;
-    final Request request;
-    final Response cacheResponse;
-
-    /** The server's time when the cached response was served, if known. */
-    private Date servedDate;
-    private String servedDateString;
-
-    /** The last modified date of the cached response, if known. */
-    private Date lastModified;
-    private String lastModifiedString;
-
-    /**
-     * The expiration date of the cached response, if known. If both this field and the max age are
-     * set, the max age is preferred.
-     */
-    private Date expires;
-
-    /**
-     * Extension header set by OkHttp specifying the timestamp when the cached HTTP request was
-     * first initiated.
-     */
-    private long sentRequestMillis;
-
-    /**
-     * Extension header set by OkHttp specifying the timestamp when the cached HTTP response was
-     * first received.
-     */
-    private long receivedResponseMillis;
-
-    /** Etag of the cached response. */
-    private String etag;
-
-    /** Age of the cached response. */
-    private int ageSeconds = -1;
-
-    public Factory(long nowMillis, Request request, Response cacheResponse) {
-      this.nowMillis = nowMillis;
-      this.request = request;
-      this.cacheResponse = cacheResponse;
-
-      if (cacheResponse != null) {
-        this.sentRequestMillis = cacheResponse.sentRequestAtMillis();
-        this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();
-        Headers headers = cacheResponse.headers();
-        for (int i = 0, size = headers.size(); i < size; i++) {
-          String fieldName = headers.name(i);
-          String value = headers.value(i);
-          if ("Date".equalsIgnoreCase(fieldName)) {
-            servedDate = HttpDate.parse(value);
-            servedDateString = value;
-          } else if ("Expires".equalsIgnoreCase(fieldName)) {
-            expires = HttpDate.parse(value);
-          } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
-            lastModified = HttpDate.parse(value);
-            lastModifiedString = value;
-          } else if ("ETag".equalsIgnoreCase(fieldName)) {
-            etag = value;
-          } else if ("Age".equalsIgnoreCase(fieldName)) {
-            ageSeconds = HttpHeaders.parseSeconds(value, -1);
-          }
-        }
-      }
-    }
-
-    /**
-     * Returns a strategy to satisfy {@code request} using the a cached response {@code response}.
-     */
-    public CacheStrategy get() {
-      CacheStrategy candidate = getCandidate();
-
-      if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {
-        // We're forbidden from using the network and the cache is insufficient.
-        return new CacheStrategy(null, null);
-      }
-
-      return candidate;
-    }
-
-    /** Returns a strategy to use assuming the request can use the network. */
-    private CacheStrategy getCandidate() {
-      // No cached response.
-      if (cacheResponse == null) {
-        return new CacheStrategy(request, null);
-      }
-
-      // Drop the cached response if it's missing a required handshake.
-      if (request.isHttps() && cacheResponse.handshake() == null) {
-        return new CacheStrategy(request, null);
-      }
-
-      // If this response shouldn't have been stored, it should never be used
-      // as a response source. This check should be redundant as long as the
-      // persistence store is well-behaved and the rules are constant.
-      if (!isCacheable(cacheResponse, request)) {
-        return new CacheStrategy(request, null);
-      }
-
-      CacheControl requestCaching = request.cacheControl();
-      if (requestCaching.noCache() || hasConditions(request)) {
-        return new CacheStrategy(request, null);
-      }
-
-      long ageMillis = cacheResponseAge();
-      long freshMillis = computeFreshnessLifetime();
-
-      if (requestCaching.maxAgeSeconds() != -1) {
-        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
-      }
-
-      long minFreshMillis = 0;
-      if (requestCaching.minFreshSeconds() != -1) {
-        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
-      }
-
-      long maxStaleMillis = 0;
-      CacheControl responseCaching = cacheResponse.cacheControl();
-      if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
-        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
-      }
-
-      if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
-        Response.Builder builder = cacheResponse.newBuilder();
-        if (ageMillis + minFreshMillis >= freshMillis) {
-          builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
-        }
-        long oneDayMillis = 24 * 60 * 60 * 1000L;
-        if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
-          builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
-        }
-        return new CacheStrategy(null, builder.build());
-      }
-
-      // Find a condition to add to the request. If the condition is satisfied, the response body
-      // will not be transmitted.
-      String conditionName;
-      String conditionValue;
-      if (etag != null) {
-        conditionName = "If-None-Match";
-        conditionValue = etag;
-      } else if (lastModified != null) {
-        conditionName = "If-Modified-Since";
-        conditionValue = lastModifiedString;
-      } else if (servedDate != null) {
-        conditionName = "If-Modified-Since";
-        conditionValue = servedDateString;
-      } else {
-        return new CacheStrategy(request, null); // No condition! Make a regular request.
-      }
-
-      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();
-      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);
-
-      Request conditionalRequest = request.newBuilder()
-          .headers(conditionalRequestHeaders.build())
-          .build();
-      return new CacheStrategy(conditionalRequest, cacheResponse);
-    }
-
-    /**
-     * Returns the number of milliseconds that the response was fresh for, starting from the served
-     * date.
-     */
-    private long computeFreshnessLifetime() {
-      CacheControl responseCaching = cacheResponse.cacheControl();
-      if (responseCaching.maxAgeSeconds() != -1) {
-        return SECONDS.toMillis(responseCaching.maxAgeSeconds());
-      } else if (expires != null) {
-        long servedMillis = servedDate != null
-            ? servedDate.getTime()
-            : receivedResponseMillis;
-        long delta = expires.getTime() - servedMillis;
-        return delta > 0 ? delta : 0;
-      } else if (lastModified != null
-          && cacheResponse.request().url().query() == null) {
-        // As recommended by the HTTP RFC and implemented in Firefox, the
-        // max age of a document should be defaulted to 10% of the
-        // document's age at the time it was served. Default expiration
-        // dates aren't used for URIs containing a query.
-        long servedMillis = servedDate != null
-            ? servedDate.getTime()
-            : sentRequestMillis;
-        long delta = servedMillis - lastModified.getTime();
-        return delta > 0 ? (delta / 10) : 0;
-      }
-      return 0;
-    }
-
-    /**
-     * Returns the current age of the response, in milliseconds. The calculation is specified by RFC
-     * 2616, 13.2.3 Age Calculations.
-     */
-    private long cacheResponseAge() {
-      long apparentReceivedAge = servedDate != null
-          ? Math.max(0, receivedResponseMillis - servedDate.getTime())
-          : 0;
-      long receivedAge = ageSeconds != -1
-          ? Math.max(apparentReceivedAge, SECONDS.toMillis(ageSeconds))
-          : apparentReceivedAge;
-      long responseDuration = receivedResponseMillis - sentRequestMillis;
-      long residentDuration = nowMillis - receivedResponseMillis;
-      return receivedAge + responseDuration + residentDuration;
-    }
-
-    /**
-     * Returns true if computeFreshnessLifetime used a heuristic. If we used a heuristic to serve a
-     * cached response older than 24 hours, we are required to attach a warning.
-     */
-    private boolean isFreshnessLifetimeHeuristic() {
-      return cacheResponse.cacheControl().maxAgeSeconds() == -1 && expires == null;
-    }
-
-    /**
-     * Returns true if the request contains conditions that save the server from sending a response
-     * that the client has locally. When a request is enqueued with its own conditions, the built-in
-     * response cache won't be used.
-     */
-    private static boolean hasConditions(Request request) {
-      return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
deleted file mode 100644
index eac6ca0300..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
+++ /dev/null
@@ -1,1053 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.io.Closeable;
-import java.io.EOFException;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.Flushable;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.NoSuchElementException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import okhttp3.internal.Util;
-import okhttp3.internal.io.FileSystem;
-import okhttp3.internal.platform.Platform;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-import okio.ForwardingSink;
-
-import static okhttp3.internal.platform.Platform.WARN;
-
-/**
- * A cache that uses a bounded amount of space on a filesystem. Each cache entry has a string key
- * and a fixed number of values. Each key must match the regex <strong>[a-z0-9_-]{1,64}</strong>.
- * Values are byte sequences, accessible as streams or files. Each value must be between {@code 0}
- * and {@code Integer.MAX_VALUE} bytes in length.
- *
- * <p>The cache stores its data in a directory on the filesystem. This directory must be exclusive
- * to the cache; the cache may delete or overwrite files from its directory. It is an error for
- * multiple processes to use the same cache directory at the same time.
- *
- * <p>This cache limits the number of bytes that it will store on the filesystem. When the number of
- * stored bytes exceeds the limit, the cache will remove entries in the background until the limit
- * is satisfied. The limit is not strict: the cache may temporarily exceed it while waiting for
- * files to be deleted. The limit does not include filesystem overhead or the cache journal so
- * space-sensitive applications should set a conservative limit.
- *
- * <p>Clients call {@link #edit} to create or update the values of an entry. An entry may have only
- * one editor at one time; if a value is not available to be edited then {@link #edit} will return
- * null.
- *
- * <ul>
- *     <li>When an entry is being <strong>created</strong> it is necessary to supply a full set of
- *         values; the empty value should be used as a placeholder if necessary.
- *     <li>When an entry is being <strong>edited</strong>, it is not necessary to supply data for
- *         every value; values default to their previous value.
- * </ul>
- *
- * <p>Every {@link #edit} call must be matched by a call to {@link Editor#commit} or {@link
- * Editor#abort}. Committing is atomic: a read observes the full set of values as they were before
- * or after the commit, but never a mix of values.
- *
- * <p>Clients call {@link #get} to read a snapshot of an entry. The read will observe the value at
- * the time that {@link #get} was called. Updates and removals after the call do not impact ongoing
- * reads.
- *
- * <p>This class is tolerant of some I/O errors. If files are missing from the filesystem, the
- * corresponding entries will be dropped from the cache. If an error occurs while writing a cache
- * value, the edit will fail silently. Callers should handle other problems by catching {@code
- * IOException} and responding appropriately.
- */
-public final class DiskLruCache implements Closeable, Flushable {
-  static final String JOURNAL_FILE = "journal";
-  static final String JOURNAL_FILE_TEMP = "journal.tmp";
-  static final String JOURNAL_FILE_BACKUP = "journal.bkp";
-  static final String MAGIC = "libcore.io.DiskLruCache";
-  static final String VERSION_1 = "1";
-  static final long ANY_SEQUENCE_NUMBER = -1;
-  static final Pattern LEGAL_KEY_PATTERN = Pattern.compile("[a-z0-9_-]{1,120}");
-  private static final String CLEAN = "CLEAN";
-  private static final String DIRTY = "DIRTY";
-  private static final String REMOVE = "REMOVE";
-  private static final String READ = "READ";
-
-    /*
-     * This cache uses a journal file named "journal". A typical journal file
-     * looks like this:
-     *     libcore.io.DiskLruCache
-     *     1
-     *     100
-     *     2
-     *
-     *     CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054
-     *     DIRTY 335c4c6028171cfddfbaae1a9c313c52
-     *     CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
-     *     REMOVE 335c4c6028171cfddfbaae1a9c313c52
-     *     DIRTY 1ab96a171faeeee38496d8b330771a7a
-     *     CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
-     *     READ 335c4c6028171cfddfbaae1a9c313c52
-     *     READ 3400330d1dfc7f3f7f4b8d4d803dfcf6
-     *
-     * The first five lines of the journal form its header. They are the
-     * constant string "libcore.io.DiskLruCache", the disk cache's version,
-     * the application's version, the value count, and a blank line.
-     *
-     * Each of the subsequent lines in the file is a record of the state of a
-     * cache entry. Each line contains space-separated values: a state, a key,
-     * and optional state-specific values.
-     *   o DIRTY lines track that an entry is actively being created or updated.
-     *     Every successful DIRTY action should be followed by a CLEAN or REMOVE
-     *     action. DIRTY lines without a matching CLEAN or REMOVE indicate that
-     *     temporary files may need to be deleted.
-     *   o CLEAN lines track a cache entry that has been successfully published
-     *     and may be read. A publish line is followed by the lengths of each of
-     *     its values.
-     *   o READ lines track accesses for LRU.
-     *   o REMOVE lines track entries that have been deleted.
-     *
-     * The journal file is appended to as cache operations occur. The journal may
-     * occasionally be compacted by dropping redundant lines. A temporary file named
-     * "journal.tmp" will be used during compaction; that file should be deleted if
-     * it exists when the cache is opened.
-     */
-
-  final FileSystem fileSystem;
-  final File directory;
-  private final File journalFile;
-  private final File journalFileTmp;
-  private final File journalFileBackup;
-  private final int appVersion;
-  private long maxSize;
-  final int valueCount;
-  private long size = 0;
-  BufferedSink journalWriter;
-  final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
-  int redundantOpCount;
-  boolean hasJournalErrors;
-
-  // Must be read and written when synchronized on 'this'.
-  boolean initialized;
-  boolean closed;
-  boolean mostRecentTrimFailed;
-  boolean mostRecentRebuildFailed;
-
-  /**
-   * To differentiate between old and current snapshots, each entry is given a sequence number each
-   * time an edit is committed. A snapshot is stale if its sequence number is not equal to its
-   * entry's sequence number.
-   */
-  private long nextSequenceNumber = 0;
-
-  /** Used to run 'cleanupRunnable' for journal rebuilds. */
-  private final Executor executor;
-  private final Runnable cleanupRunnable = new Runnable() {
-    public void run() {
-      synchronized (DiskLruCache.this) {
-        if (!initialized | closed) {
-          return; // Nothing to do
-        }
-
-        try {
-          trimToSize();
-        } catch (IOException ignored) {
-          mostRecentTrimFailed = true;
-        }
-
-        try {
-          if (journalRebuildRequired()) {
-            rebuildJournal();
-            redundantOpCount = 0;
-          }
-        } catch (IOException e) {
-          mostRecentRebuildFailed = true;
-          journalWriter = Okio.buffer(Okio.blackhole());
-        }
-      }
-    }
-  };
-
-  DiskLruCache(FileSystem fileSystem, File directory, int appVersion, int valueCount, long maxSize,
-      Executor executor) {
-    this.fileSystem = fileSystem;
-    this.directory = directory;
-    this.appVersion = appVersion;
-    this.journalFile = new File(directory, JOURNAL_FILE);
-    this.journalFileTmp = new File(directory, JOURNAL_FILE_TEMP);
-    this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP);
-    this.valueCount = valueCount;
-    this.maxSize = maxSize;
-    this.executor = executor;
-  }
-
-  public synchronized void initialize() throws IOException {
-    assert Thread.holdsLock(this);
-
-    if (initialized) {
-      return; // Already initialized.
-    }
-
-    // If a bkp file exists, use it instead.
-    if (fileSystem.exists(journalFileBackup)) {
-      // If journal file also exists just delete backup file.
-      if (fileSystem.exists(journalFile)) {
-        fileSystem.delete(journalFileBackup);
-      } else {
-        fileSystem.rename(journalFileBackup, journalFile);
-      }
-    }
-
-    // Prefer to pick up where we left off.
-    if (fileSystem.exists(journalFile)) {
-      try {
-        readJournal();
-        processJournal();
-        initialized = true;
-        return;
-      } catch (IOException journalIsCorrupt) {
-        Platform.get().log(WARN, "DiskLruCache " + directory + " is corrupt: "
-            + journalIsCorrupt.getMessage() + ", removing", journalIsCorrupt);
-      }
-
-      // The cache is corrupted, attempt to delete the contents of the directory. This can throw and
-      // we'll let that propagate out as it likely means there is a severe filesystem problem.
-      try {
-        delete();
-      } finally {
-        closed = false;
-      }
-    }
-
-    rebuildJournal();
-
-    initialized = true;
-  }
-
-  /**
-   * Create a cache which will reside in {@code directory}. This cache is lazily initialized on
-   * first access and will be created if it does not exist.
-   *
-   * @param directory a writable directory
-   * @param valueCount the number of values per cache entry. Must be positive.
-   * @param maxSize the maximum number of bytes this cache should use to store
-   */
-  public static DiskLruCache create(FileSystem fileSystem, File directory, int appVersion,
-      int valueCount, long maxSize) {
-    if (maxSize <= 0) {
-      throw new IllegalArgumentException("maxSize <= 0");
-    }
-    if (valueCount <= 0) {
-      throw new IllegalArgumentException("valueCount <= 0");
-    }
-
-    // Use a single background thread to evict entries.
-    Executor executor = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
-        new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp DiskLruCache", true));
-
-    return new DiskLruCache(fileSystem, directory, appVersion, valueCount, maxSize, executor);
-  }
-
-  private void readJournal() throws IOException {
-    BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
-    try {
-      String magic = source.readUtf8LineStrict();
-      String version = source.readUtf8LineStrict();
-      String appVersionString = source.readUtf8LineStrict();
-      String valueCountString = source.readUtf8LineStrict();
-      String blank = source.readUtf8LineStrict();
-      if (!MAGIC.equals(magic)
-          || !VERSION_1.equals(version)
-          || !Integer.toString(appVersion).equals(appVersionString)
-          || !Integer.toString(valueCount).equals(valueCountString)
-          || !"".equals(blank)) {
-        throw new IOException("unexpected journal header: [" + magic + ", " + version + ", "
-            + valueCountString + ", " + blank + "]");
-      }
-
-      int lineCount = 0;
-      while (true) {
-        try {
-          readJournalLine(source.readUtf8LineStrict());
-          lineCount++;
-        } catch (EOFException endOfJournal) {
-          break;
-        }
-      }
-      redundantOpCount = lineCount - lruEntries.size();
-
-      // If we ended on a truncated line, rebuild the journal before appending to it.
-      if (!source.exhausted()) {
-        rebuildJournal();
-      } else {
-        journalWriter = newJournalWriter();
-      }
-    } finally {
-      Util.closeQuietly(source);
-    }
-  }
-
-  private BufferedSink newJournalWriter() throws FileNotFoundException {
-    Sink fileSink = fileSystem.appendingSink(journalFile);
-    Sink forwardingSink = new ForwardingSink(fileSink) {
-      protected void onException(IOException e) {
-        assert (Thread.holdsLock(DiskLruCache.this));
-        hasJournalErrors = true;
-      }
-    };
-    return Okio.buffer(forwardingSink);
-  }
-
-  private void readJournalLine(String line) throws IOException {
-    int firstSpace = line.indexOf(' ');
-    if (firstSpace == -1) {
-      throw new IOException("unexpected journal line: " + line);
-    }
-
-    int keyBegin = firstSpace + 1;
-    int secondSpace = line.indexOf(' ', keyBegin);
-    final String key;
-    if (secondSpace == -1) {
-      key = line.substring(keyBegin);
-      if (firstSpace == REMOVE.length() && line.startsWith(REMOVE)) {
-        lruEntries.remove(key);
-        return;
-      }
-    } else {
-      key = line.substring(keyBegin, secondSpace);
-    }
-
-    Entry entry = lruEntries.get(key);
-    if (entry == null) {
-      entry = new Entry(key);
-      lruEntries.put(key, entry);
-    }
-
-    if (secondSpace != -1 && firstSpace == CLEAN.length() && line.startsWith(CLEAN)) {
-      String[] parts = line.substring(secondSpace + 1).split(" ");
-      entry.readable = true;
-      entry.currentEditor = null;
-      entry.setLengths(parts);
-    } else if (secondSpace == -1 && firstSpace == DIRTY.length() && line.startsWith(DIRTY)) {
-      entry.currentEditor = new Editor(entry);
-    } else if (secondSpace == -1 && firstSpace == READ.length() && line.startsWith(READ)) {
-      // This work was already done by calling lruEntries.get().
-    } else {
-      throw new IOException("unexpected journal line: " + line);
-    }
-  }
-
-  /**
-   * Computes the initial size and collects garbage as a part of opening the cache. Dirty entries
-   * are assumed to be inconsistent and will be deleted.
-   */
-  private void processJournal() throws IOException {
-    fileSystem.delete(journalFileTmp);
-    for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {
-      Entry entry = i.next();
-      if (entry.currentEditor == null) {
-        for (int t = 0; t < valueCount; t++) {
-          size += entry.lengths[t];
-        }
-      } else {
-        entry.currentEditor = null;
-        for (int t = 0; t < valueCount; t++) {
-          fileSystem.delete(entry.cleanFiles[t]);
-          fileSystem.delete(entry.dirtyFiles[t]);
-        }
-        i.remove();
-      }
-    }
-  }
-
-  /**
-   * Creates a new journal that omits redundant information. This replaces the current journal if it
-   * exists.
-   */
-  synchronized void rebuildJournal() throws IOException {
-    if (journalWriter != null) {
-      journalWriter.close();
-    }
-
-    BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp));
-    try {
-      writer.writeUtf8(MAGIC).writeByte('\n');
-      writer.writeUtf8(VERSION_1).writeByte('\n');
-      writer.writeDecimalLong(appVersion).writeByte('\n');
-      writer.writeDecimalLong(valueCount).writeByte('\n');
-      writer.writeByte('\n');
-
-      for (Entry entry : lruEntries.values()) {
-        if (entry.currentEditor != null) {
-          writer.writeUtf8(DIRTY).writeByte(' ');
-          writer.writeUtf8(entry.key);
-          writer.writeByte('\n');
-        } else {
-          writer.writeUtf8(CLEAN).writeByte(' ');
-          writer.writeUtf8(entry.key);
-          entry.writeLengths(writer);
-          writer.writeByte('\n');
-        }
-      }
-    } finally {
-      writer.close();
-    }
-
-    if (fileSystem.exists(journalFile)) {
-      fileSystem.rename(journalFile, journalFileBackup);
-    }
-    fileSystem.rename(journalFileTmp, journalFile);
-    fileSystem.delete(journalFileBackup);
-
-    journalWriter = newJournalWriter();
-    hasJournalErrors = false;
-    mostRecentRebuildFailed = false;
-  }
-
-  /**
-   * Returns a snapshot of the entry named {@code key}, or null if it doesn't exist is not currently
-   * readable. If a value is returned, it is moved to the head of the LRU queue.
-   */
-  public synchronized Snapshot get(String key) throws IOException {
-    initialize();
-
-    checkNotClosed();
-    validateKey(key);
-    Entry entry = lruEntries.get(key);
-    if (entry == null || !entry.readable) return null;
-
-    Snapshot snapshot = entry.snapshot();
-    if (snapshot == null) return null;
-
-    redundantOpCount++;
-    journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\n');
-    if (journalRebuildRequired()) {
-      executor.execute(cleanupRunnable);
-    }
-
-    return snapshot;
-  }
-
-  /**
-   * Returns an editor for the entry named {@code key}, or null if another edit is in progress.
-   */
-  public Editor edit(String key) throws IOException {
-    return edit(key, ANY_SEQUENCE_NUMBER);
-  }
-
-  synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
-    initialize();
-
-    checkNotClosed();
-    validateKey(key);
-    Entry entry = lruEntries.get(key);
-    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER && (entry == null
-        || entry.sequenceNumber != expectedSequenceNumber)) {
-      return null; // Snapshot is stale.
-    }
-    if (entry != null && entry.currentEditor != null) {
-      return null; // Another edit is in progress.
-    }
-    if (mostRecentTrimFailed || mostRecentRebuildFailed) {
-      // The OS has become our enemy! If the trim job failed, it means we are storing more data than
-      // requested by the user. Do not allow edits so we do not go over that limit any further. If
-      // the journal rebuild failed, the journal writer will not be active, meaning we will not be
-      // able to record the edit, causing file leaks. In both cases, we want to retry the clean up
-      // so we can get out of this state!
-      executor.execute(cleanupRunnable);
-      return null;
-    }
-
-    // Flush the journal before creating files to prevent file leaks.
-    journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
-    journalWriter.flush();
-
-    if (hasJournalErrors) {
-      return null; // Don't edit; the journal can't be written.
-    }
-
-    if (entry == null) {
-      entry = new Entry(key);
-      lruEntries.put(key, entry);
-    }
-    Editor editor = new Editor(entry);
-    entry.currentEditor = editor;
-    return editor;
-  }
-
-  /** Returns the directory where this cache stores its data. */
-  public File getDirectory() {
-    return directory;
-  }
-
-  /**
-   * Returns the maximum number of bytes that this cache should use to store its data.
-   */
-  public synchronized long getMaxSize() {
-    return maxSize;
-  }
-
-  /**
-   * Changes the maximum number of bytes the cache can store and queues a job to trim the existing
-   * store, if necessary.
-   */
-  public synchronized void setMaxSize(long maxSize) {
-    this.maxSize = maxSize;
-    if (initialized) {
-      executor.execute(cleanupRunnable);
-    }
-  }
-
-  /**
-   * Returns the number of bytes currently being used to store the values in this cache. This may be
-   * greater than the max size if a background deletion is pending.
-   */
-  public synchronized long size() throws IOException {
-    initialize();
-    return size;
-  }
-
-  synchronized void completeEdit(Editor editor, boolean success) throws IOException {
-    Entry entry = editor.entry;
-    if (entry.currentEditor != editor) {
-      throw new IllegalStateException();
-    }
-
-    // If this edit is creating the entry for the first time, every index must have a value.
-    if (success && !entry.readable) {
-      for (int i = 0; i < valueCount; i++) {
-        if (!editor.written[i]) {
-          editor.abort();
-          throw new IllegalStateException("Newly created entry didn't create value for index " + i);
-        }
-        if (!fileSystem.exists(entry.dirtyFiles[i])) {
-          editor.abort();
-          return;
-        }
-      }
-    }
-
-    for (int i = 0; i < valueCount; i++) {
-      File dirty = entry.dirtyFiles[i];
-      if (success) {
-        if (fileSystem.exists(dirty)) {
-          File clean = entry.cleanFiles[i];
-          fileSystem.rename(dirty, clean);
-          long oldLength = entry.lengths[i];
-          long newLength = fileSystem.size(clean);
-          entry.lengths[i] = newLength;
-          size = size - oldLength + newLength;
-        }
-      } else {
-        fileSystem.delete(dirty);
-      }
-    }
-
-    redundantOpCount++;
-    entry.currentEditor = null;
-    if (entry.readable | success) {
-      entry.readable = true;
-      journalWriter.writeUtf8(CLEAN).writeByte(' ');
-      journalWriter.writeUtf8(entry.key);
-      entry.writeLengths(journalWriter);
-      journalWriter.writeByte('\n');
-      if (success) {
-        entry.sequenceNumber = nextSequenceNumber++;
-      }
-    } else {
-      lruEntries.remove(entry.key);
-      journalWriter.writeUtf8(REMOVE).writeByte(' ');
-      journalWriter.writeUtf8(entry.key);
-      journalWriter.writeByte('\n');
-    }
-    journalWriter.flush();
-
-    if (size > maxSize || journalRebuildRequired()) {
-      executor.execute(cleanupRunnable);
-    }
-  }
-
-  /**
-   * We only rebuild the journal when it will halve the size of the journal and eliminate at least
-   * 2000 ops.
-   */
-  boolean journalRebuildRequired() {
-    final int redundantOpCompactThreshold = 2000;
-    return redundantOpCount >= redundantOpCompactThreshold
-        && redundantOpCount >= lruEntries.size();
-  }
-
-  /**
-   * Drops the entry for {@code key} if it exists and can be removed. If the entry for {@code key}
-   * is currently being edited, that edit will complete normally but its value will not be stored.
-   *
-   * @return true if an entry was removed.
-   */
-  public synchronized boolean remove(String key) throws IOException {
-    initialize();
-
-    checkNotClosed();
-    validateKey(key);
-    Entry entry = lruEntries.get(key);
-    if (entry == null) return false;
-    boolean removed = removeEntry(entry);
-    if (removed && size <= maxSize) mostRecentTrimFailed = false;
-    return removed;
-  }
-
-  boolean removeEntry(Entry entry) throws IOException {
-    if (entry.currentEditor != null) {
-      entry.currentEditor.detach(); // Prevent the edit from completing normally.
-    }
-
-    for (int i = 0; i < valueCount; i++) {
-      fileSystem.delete(entry.cleanFiles[i]);
-      size -= entry.lengths[i];
-      entry.lengths[i] = 0;
-    }
-
-    redundantOpCount++;
-    journalWriter.writeUtf8(REMOVE).writeByte(' ').writeUtf8(entry.key).writeByte('\n');
-    lruEntries.remove(entry.key);
-
-    if (journalRebuildRequired()) {
-      executor.execute(cleanupRunnable);
-    }
-
-    return true;
-  }
-
-  /** Returns true if this cache has been closed. */
-  public synchronized boolean isClosed() {
-    return closed;
-  }
-
-  private synchronized void checkNotClosed() {
-    if (isClosed()) {
-      throw new IllegalStateException("cache is closed");
-    }
-  }
-
-  /** Force buffered operations to the filesystem. */
-  @Override public synchronized void flush() throws IOException {
-    if (!initialized) return;
-
-    checkNotClosed();
-    trimToSize();
-    journalWriter.flush();
-  }
-
-  /** Closes this cache. Stored values will remain on the filesystem. */
-  @Override public synchronized void close() throws IOException {
-    if (!initialized || closed) {
-      closed = true;
-      return;
-    }
-    // Copying for safe iteration.
-    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
-      if (entry.currentEditor != null) {
-        entry.currentEditor.abort();
-      }
-    }
-    trimToSize();
-    journalWriter.close();
-    journalWriter = null;
-    closed = true;
-  }
-
-  void trimToSize() throws IOException {
-    while (size > maxSize) {
-      Entry toEvict = lruEntries.values().iterator().next();
-      removeEntry(toEvict);
-    }
-    mostRecentTrimFailed = false;
-  }
-
-  /**
-   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
-   * directory including files that weren't created by the cache.
-   */
-  public void delete() throws IOException {
-    close();
-    fileSystem.deleteContents(directory);
-  }
-
-  /**
-   * Deletes all stored values from the cache. In-flight edits will complete normally but their
-   * values will not be stored.
-   */
-  public synchronized void evictAll() throws IOException {
-    initialize();
-    // Copying for safe iteration.
-    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
-      removeEntry(entry);
-    }
-    mostRecentTrimFailed = false;
-  }
-
-  private void validateKey(String key) {
-    Matcher matcher = LEGAL_KEY_PATTERN.matcher(key);
-    if (!matcher.matches()) {
-      throw new IllegalArgumentException(
-          "keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"");
-    }
-  }
-
-  /**
-   * Returns an iterator over the cache's current entries. This iterator doesn't throw {@code
-   * ConcurrentModificationException}, but if new entries are added while iterating, those new
-   * entries will not be returned by the iterator. If existing entries are removed during iteration,
-   * they will be absent (unless they were already returned).
-   *
-   * <p>If there are I/O problems during iteration, this iterator fails silently. For example, if
-   * the hosting filesystem becomes unreachable, the iterator will omit elements rather than
-   * throwing exceptions.
-   *
-   * <p><strong>The caller must {@link Snapshot#close close}</strong> each snapshot returned by
-   * {@link Iterator#next}. Failing to do so leaks open files!
-   *
-   * <p>The returned iterator supports {@link Iterator#remove}.
-   */
-  public synchronized Iterator<Snapshot> snapshots() throws IOException {
-    initialize();
-    return new Iterator<Snapshot>() {
-      /** Iterate a copy of the entries to defend against concurrent modification errors. */
-      final Iterator<Entry> delegate = new ArrayList<>(lruEntries.values()).iterator();
-
-      /** The snapshot to return from {@link #next}. Null if we haven't computed that yet. */
-      Snapshot nextSnapshot;
-
-      /** The snapshot to remove with {@link #remove}. Null if removal is illegal. */
-      Snapshot removeSnapshot;
-
-      @Override public boolean hasNext() {
-        if (nextSnapshot != null) return true;
-
-        synchronized (DiskLruCache.this) {
-          // If the cache is closed, truncate the iterator.
-          if (closed) return false;
-
-          while (delegate.hasNext()) {
-            Entry entry = delegate.next();
-            Snapshot snapshot = entry.snapshot();
-            if (snapshot == null) continue; // Evicted since we copied the entries.
-            nextSnapshot = snapshot;
-            return true;
-          }
-        }
-
-        return false;
-      }
-
-      @Override public Snapshot next() {
-        if (!hasNext()) throw new NoSuchElementException();
-        removeSnapshot = nextSnapshot;
-        nextSnapshot = null;
-        return removeSnapshot;
-      }
-
-      @Override public void remove() {
-        if (removeSnapshot == null) throw new IllegalStateException("remove() before next()");
-        try {
-          DiskLruCache.this.remove(removeSnapshot.key);
-        } catch (IOException ignored) {
-          // Nothing useful to do here. We failed to remove from the cache. Most likely that's
-          // because we couldn't update the journal, but the cached entry will still be gone.
-        } finally {
-          removeSnapshot = null;
-        }
-      }
-    };
-  }
-
-  /** A snapshot of the values for an entry. */
-  public final class Snapshot implements Closeable {
-    private final String key;
-    private final long sequenceNumber;
-    private final Source[] sources;
-    private final long[] lengths;
-
-    Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
-      this.key = key;
-      this.sequenceNumber = sequenceNumber;
-      this.sources = sources;
-      this.lengths = lengths;
-    }
-
-    public String key() {
-      return key;
-    }
-
-    /**
-     * Returns an editor for this snapshot's entry, or null if either the entry has changed since
-     * this snapshot was created or if another edit is in progress.
-     */
-    public Editor edit() throws IOException {
-      return DiskLruCache.this.edit(key, sequenceNumber);
-    }
-
-    /** Returns the unbuffered stream with the value for {@code index}. */
-    public Source getSource(int index) {
-      return sources[index];
-    }
-
-    /** Returns the byte length of the value for {@code index}. */
-    public long getLength(int index) {
-      return lengths[index];
-    }
-
-    public void close() {
-      for (Source in : sources) {
-        Util.closeQuietly(in);
-      }
-    }
-  }
-
-  /** Edits the values for an entry. */
-  public final class Editor {
-    final Entry entry;
-    final boolean[] written;
-    private boolean done;
-
-    Editor(Entry entry) {
-      this.entry = entry;
-      this.written = (entry.readable) ? null : new boolean[valueCount];
-    }
-
-    /**
-     * Prevents this editor from completing normally. This is necessary either when the edit causes
-     * an I/O error, or if the target entry is evicted while this editor is active. In either case
-     * we delete the editor's created files and prevent new files from being created. Note that once
-     * an editor has been detached it is possible for another editor to edit the entry.
-     */
-    void detach() {
-      if (entry.currentEditor == this) {
-        for (int i = 0; i < valueCount; i++) {
-          try {
-            fileSystem.delete(entry.dirtyFiles[i]);
-          } catch (IOException e) {
-            // This file is potentially leaked. Not much we can do about that.
-          }
-        }
-        entry.currentEditor = null;
-      }
-    }
-
-    /**
-     * Returns an unbuffered input stream to read the last committed value, or null if no value has
-     * been committed.
-     */
-    public Source newSource(int index) {
-      synchronized (DiskLruCache.this) {
-        if (done) {
-          throw new IllegalStateException();
-        }
-        if (!entry.readable || entry.currentEditor != this) {
-          return null;
-        }
-        try {
-          return fileSystem.source(entry.cleanFiles[index]);
-        } catch (FileNotFoundException e) {
-          return null;
-        }
-      }
-    }
-
-    /**
-     * Returns a new unbuffered output stream to write the value at {@code index}. If the underlying
-     * output stream encounters errors when writing to the filesystem, this edit will be aborted
-     * when {@link #commit} is called. The returned output stream does not throw IOExceptions.
-     */
-    public Sink newSink(int index) {
-      synchronized (DiskLruCache.this) {
-        if (done) {
-          throw new IllegalStateException();
-        }
-        if (entry.currentEditor != this) {
-          return Okio.blackhole();
-        }
-        if (!entry.readable) {
-          written[index] = true;
-        }
-        File dirtyFile = entry.dirtyFiles[index];
-        Sink sink;
-        try {
-          sink = fileSystem.sink(dirtyFile);
-        } catch (FileNotFoundException e) {
-          return Okio.blackhole();
-        }
-        return new ForwardingSink(sink) {
-          protected void onException(IOException e) {
-            synchronized (DiskLruCache.this) {
-              detach();
-            }
-          }
-        };
-      }
-    }
-
-    /**
-     * Commits this edit so it is visible to readers.  This releases the edit lock so another edit
-     * may be started on the same key.
-     */
-    public void commit() throws IOException {
-      synchronized (DiskLruCache.this) {
-        if (done) {
-          throw new IllegalStateException();
-        }
-        if (entry.currentEditor == this) {
-          completeEdit(this, true);
-        }
-        done = true;
-      }
-    }
-
-    /**
-     * Aborts this edit. This releases the edit lock so another edit may be started on the same
-     * key.
-     */
-    public void abort() throws IOException {
-      synchronized (DiskLruCache.this) {
-        if (done) {
-          throw new IllegalStateException();
-        }
-        if (entry.currentEditor == this) {
-          completeEdit(this, false);
-        }
-        done = true;
-      }
-    }
-
-    public void abortUnlessCommitted() {
-      synchronized (DiskLruCache.this) {
-        if (!done && entry.currentEditor == this) {
-          try {
-            completeEdit(this, false);
-          } catch (IOException ignored) {
-          }
-        }
-      }
-    }
-  }
-
-  private final class Entry {
-    final String key;
-
-    /** Lengths of this entry's files. */
-    final long[] lengths;
-    final File[] cleanFiles;
-    final File[] dirtyFiles;
-
-    /** True if this entry has ever been published. */
-    boolean readable;
-
-    /** The ongoing edit or null if this entry is not being edited. */
-    Editor currentEditor;
-
-    /** The sequence number of the most recently committed edit to this entry. */
-    long sequenceNumber;
-
-    Entry(String key) {
-      this.key = key;
-
-      lengths = new long[valueCount];
-      cleanFiles = new File[valueCount];
-      dirtyFiles = new File[valueCount];
-
-      // The names are repetitive so re-use the same builder to avoid allocations.
-      StringBuilder fileBuilder = new StringBuilder(key).append('.');
-      int truncateTo = fileBuilder.length();
-      for (int i = 0; i < valueCount; i++) {
-        fileBuilder.append(i);
-        cleanFiles[i] = new File(directory, fileBuilder.toString());
-        fileBuilder.append(".tmp");
-        dirtyFiles[i] = new File(directory, fileBuilder.toString());
-        fileBuilder.setLength(truncateTo);
-      }
-    }
-
-    /** Set lengths using decimal numbers like "10123". */
-    void setLengths(String[] strings) throws IOException {
-      if (strings.length != valueCount) {
-        throw invalidLengths(strings);
-      }
-
-      try {
-        for (int i = 0; i < strings.length; i++) {
-          lengths[i] = Long.parseLong(strings[i]);
-        }
-      } catch (NumberFormatException e) {
-        throw invalidLengths(strings);
-      }
-    }
-
-    /** Append space-prefixed lengths to {@code writer}. */
-    void writeLengths(BufferedSink writer) throws IOException {
-      for (long length : lengths) {
-        writer.writeByte(' ').writeDecimalLong(length);
-      }
-    }
-
-    private IOException invalidLengths(String[] strings) throws IOException {
-      throw new IOException("unexpected journal line: " + Arrays.toString(strings));
-    }
-
-    /**
-     * Returns a snapshot of this entry. This opens all streams eagerly to guarantee that we see a
-     * single published snapshot. If we opened streams lazily then the streams could come from
-     * different edits.
-     */
-    Snapshot snapshot() {
-      if (!Thread.holdsLock(DiskLruCache.this)) throw new AssertionError();
-
-      Source[] sources = new Source[valueCount];
-      long[] lengths = this.lengths.clone(); // Defensive copy since these can be zeroed out.
-      try {
-        for (int i = 0; i < valueCount; i++) {
-          sources[i] = fileSystem.source(cleanFiles[i]);
-        }
-        return new Snapshot(key, sequenceNumber, sources, lengths);
-      } catch (FileNotFoundException e) {
-        // A file must have been deleted manually!
-        for (int i = 0; i < valueCount; i++) {
-          if (sources[i] != null) {
-            Util.closeQuietly(sources[i]);
-          } else {
-            break;
-          }
-        }
-        // Since the entry is no longer valid, remove it so the metadata is accurate (i.e. the cache
-        // size.)
-        try {
-          removeEntry(this);
-        } catch (IOException ignored) {
-        }
-        return null;
-      }
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
deleted file mode 100644
index 6c70465b59..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.io.IOException;
-import okhttp3.Request;
-import okhttp3.Response;
-
-/**
- * OkHttp's internal cache interface. Applications shouldn't implement this: instead use {@link
- * okhttp3.Cache}.
- */
-public interface InternalCache {
-  Response get(Request request) throws IOException;
-
-  CacheRequest put(Response response) throws IOException;
-
-  /**
-   * Remove any cache entries for the supplied {@code request}. This is invoked when the client
-   * invalidates the cache, such as when making POST requests.
-   */
-  void remove(Request request) throws IOException;
-
-  /**
-   * Handles a conditional request hit by updating the stored cache response with the headers from
-   * {@code network}. The cached response body is not updated. If the stored response has changed
-   * since {@code cached} was returned, this does nothing.
-   */
-  void update(Response cached, Response network);
-
-  /** Track an conditional GET that was satisfied by this cache. */
-  void trackConditionalCacheHit();
-
-  /** Track an HTTP response being satisfied with {@code cacheStrategy}. */
-  void trackResponse(CacheStrategy cacheStrategy);
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
deleted file mode 100644
index 70914226c3..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache2;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.FileChannel;
-import okio.Buffer;
-import okio.Okio;
-
-/**
- * Read and write a target file. Unlike Okio's built-in {@linkplain Okio#source(java.io.File) file
- * source} and {@linkplain Okio#sink(java.io.File) file sink} this class offers:
- *
- * <ul>
- *   <li><strong>Read/write:</strong> read and write using the same operator.
- *   <li><strong>Random access:</strong> access any position within the file.
- *   <li><strong>Shared channels:</strong> read and write a file channel that's shared between
- *       multiple operators. Note that although the underlying {@code FileChannel} may be shared,
- *       each {@code FileOperator} should not be.
- * </ul>
- */
-final class FileOperator {
-  private static final int BUFFER_SIZE = 8192;
-
-  private final byte[] byteArray = new byte[BUFFER_SIZE];
-  private final ByteBuffer byteBuffer = ByteBuffer.wrap(byteArray);
-  private final FileChannel fileChannel;
-
-  public FileOperator(FileChannel fileChannel) {
-    this.fileChannel = fileChannel;
-  }
-
-  /** Write {@code byteCount} bytes from {@code source} to the file at {@code pos}. */
-  public void write(long pos, Buffer source, long byteCount) throws IOException {
-    if (byteCount < 0 || byteCount > source.size()) throw new IndexOutOfBoundsException();
-
-    while (byteCount > 0L) {
-      try {
-        // Write bytes to the byte[], and tell the ByteBuffer wrapper about 'em.
-        int toWrite = (int) Math.min(BUFFER_SIZE, byteCount);
-        source.read(byteArray, 0, toWrite);
-        byteBuffer.limit(toWrite);
-
-        // Copy bytes from the ByteBuffer to the file.
-        do {
-          int bytesWritten = fileChannel.write(byteBuffer, pos);
-          pos += bytesWritten;
-        } while (byteBuffer.hasRemaining());
-
-        byteCount -= toWrite;
-      } finally {
-        byteBuffer.clear();
-      }
-    }
-  }
-
-  /**
-   * Copy {@code byteCount} bytes from the file at {@code pos} into to {@code source}. It is the
-   * caller's responsibility to make sure there are sufficient bytes to read: if there aren't this
-   * method throws an {@link EOFException}.
-   */
-  public void read(long pos, Buffer sink, long byteCount) throws IOException {
-    if (byteCount < 0) throw new IndexOutOfBoundsException();
-
-    while (byteCount > 0L) {
-      try {
-        // Read up to byteCount bytes.
-        byteBuffer.limit((int) Math.min(BUFFER_SIZE, byteCount));
-        if (fileChannel.read(byteBuffer, pos) == -1) throw new EOFException();
-        int bytesRead = byteBuffer.position();
-
-        // Write those bytes to sink.
-        sink.write(byteArray, 0, bytesRead);
-        pos += bytesRead;
-        byteCount -= bytesRead;
-      } finally {
-        byteBuffer.clear();
-      }
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java b/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
deleted file mode 100644
index 5131e6cd16..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache2/Relay.java
+++ /dev/null
@@ -1,361 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache2;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import okio.Buffer;
-import okio.ByteString;
-import okio.Source;
-import okio.Timeout;
-
-import static okhttp3.internal.Util.closeQuietly;
-
-/**
- * Replicates a single upstream source into multiple downstream sources. Each downstream source
- * returns the same bytes as the upstream source. Downstream sources may read data either as it
- * is returned by upstream, or after the upstream source has been exhausted.
- *
- * <p>As bytes are returned from upstream they are written to a local file. Downstream sources read
- * from this file as necessary.
- *
- * <p>This class also keeps a small buffer of bytes recently read from upstream. This is intended to
- * save a small amount of file I/O and data copying.
- */
-// TODO(jwilson): what to do about timeouts? They could be different and unfortunately when any
-//     timeout is hit we like to tear down the whole stream.
-final class Relay {
-  private static final int SOURCE_UPSTREAM = 1;
-  private static final int SOURCE_FILE = 2;
-
-  static final ByteString PREFIX_CLEAN = ByteString.encodeUtf8("OkHttp cache v1\n");
-  static final ByteString PREFIX_DIRTY = ByteString.encodeUtf8("OkHttp DIRTY :(\n");
-  private static final long FILE_HEADER_SIZE = 32L;
-
-  /**
-   * Read/write persistence of the upstream source and its metadata. Its layout is as follows:
-   *
-   * <ul>
-   *   <li>16 bytes: either {@code OkHttp cache v1\n} if the persisted file is complete. This is
-   *       another sequence of bytes if the file is incomplete and should not be used.
-   *   <li>8 bytes: <i>n</i>: upstream data size
-   *   <li>8 bytes: <i>m</i>: metadata size
-   *   <li><i>n</i> bytes: upstream data
-   *   <li><i>m</i> bytes: metadata
-   * </ul>
-   *
-   * <p>This is closed and assigned to null when the last source is closed and no further sources
-   * are permitted.
-   */
-  RandomAccessFile file;
-
-  /** The thread that currently has access to upstream. Possibly null. Guarded by this. */
-  Thread upstreamReader;
-
-  /**
-   * Null once the file has a complete copy of the upstream bytes. Only the {@code upstreamReader}
-   * thread may access this source.
-   */
-  Source upstream;
-
-  /**
-   * A buffer for {@code upstreamReader} to use when pulling bytes from upstream. Only the {@code
-   * upstreamReader} thread may access this buffer.
-   */
-  final Buffer upstreamBuffer = new Buffer();
-
-  /** The number of bytes consumed from {@link #upstream}. Guarded by this. */
-  long upstreamPos;
-
-  /** True if there are no further bytes to read from {@code upstream}. Guarded by this. */
-  boolean complete;
-
-  /** User-supplied additional data persisted with the source data. */
-  private final ByteString metadata;
-
-  /**
-   * The most recently read bytes from {@link #upstream}. This is a suffix of {@link #file}. Guarded
-   * by this.
-   */
-  final Buffer buffer = new Buffer();
-
-  /** The maximum size of {@code buffer}. */
-  final long bufferMaxSize;
-
-  /**
-   * Reference count of the number of active sources reading this stream. When decremented to 0
-   * resources are released and all following calls to {@link #newSource} return null. Guarded by
-   * this.
-   */
-  int sourceCount;
-
-  private Relay(RandomAccessFile file, Source upstream, long upstreamPos, ByteString metadata,
-      long bufferMaxSize) {
-    this.file = file;
-    this.upstream = upstream;
-    this.complete = upstream == null;
-    this.upstreamPos = upstreamPos;
-    this.metadata = metadata;
-    this.bufferMaxSize = bufferMaxSize;
-  }
-
-  /**
-   * Creates a new relay that reads a live stream from {@code upstream}, using {@code file} to share
-   * that data with other sources.
-   *
-   * <p><strong>Warning:</strong> callers to this method must immediately call {@link #newSource} to
-   * create a source and close that when they're done. Otherwise a handle to {@code file} will be
-   * leaked.
-   */
-  public static Relay edit(
-      File file, Source upstream, ByteString metadata, long bufferMaxSize) throws IOException {
-    RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw");
-    Relay result = new Relay(randomAccessFile, upstream, 0L, metadata, bufferMaxSize);
-
-    // Write a dirty header. That way if we crash we won't attempt to recover this.
-    randomAccessFile.setLength(0L);
-    result.writeHeader(PREFIX_DIRTY, -1L, -1L);
-
-    return result;
-  }
-
-  /**
-   * Creates a relay that reads a recorded stream from {@code file}.
-   *
-   * <p><strong>Warning:</strong> callers to this method must immediately call {@link #newSource} to
-   * create a source and close that when they're done. Otherwise a handle to {@code file} will be
-   * leaked.
-   */
-  public static Relay read(File file) throws IOException {
-    RandomAccessFile randomAccessFile = new RandomAccessFile(file, "rw");
-    FileOperator fileOperator = new FileOperator(randomAccessFile.getChannel());
-
-    // Read the header.
-    Buffer header = new Buffer();
-    fileOperator.read(0, header, FILE_HEADER_SIZE);
-    ByteString prefix = header.readByteString(PREFIX_CLEAN.size());
-    if (!prefix.equals(PREFIX_CLEAN)) throw new IOException("unreadable cache file");
-    long upstreamSize = header.readLong();
-    long metadataSize = header.readLong();
-
-    // Read the metadata.
-    Buffer metadataBuffer = new Buffer();
-    fileOperator.read(FILE_HEADER_SIZE + upstreamSize, metadataBuffer, metadataSize);
-    ByteString metadata = metadataBuffer.readByteString();
-
-    // Return the result.
-    return new Relay(randomAccessFile, null, upstreamSize, metadata, 0L);
-  }
-
-  private void writeHeader(
-      ByteString prefix, long upstreamSize, long metadataSize) throws IOException {
-    Buffer header = new Buffer();
-    header.write(prefix);
-    header.writeLong(upstreamSize);
-    header.writeLong(metadataSize);
-    if (header.size() != FILE_HEADER_SIZE) throw new IllegalArgumentException();
-
-    FileOperator fileOperator = new FileOperator(file.getChannel());
-    fileOperator.write(0, header, FILE_HEADER_SIZE);
-  }
-
-  private void writeMetadata(long upstreamSize) throws IOException {
-    Buffer metadataBuffer = new Buffer();
-    metadataBuffer.write(metadata);
-
-    FileOperator fileOperator = new FileOperator(file.getChannel());
-    fileOperator.write(FILE_HEADER_SIZE + upstreamSize, metadataBuffer, metadata.size());
-  }
-
-  void commit(long upstreamSize) throws IOException {
-    // Write metadata to the end of the file.
-    writeMetadata(upstreamSize);
-    file.getChannel().force(false);
-
-    // Once everything else is in place we can swap the dirty header for a clean one.
-    writeHeader(PREFIX_CLEAN, upstreamSize, metadata.size());
-    file.getChannel().force(false);
-
-    // This file is complete.
-    synchronized (Relay.this) {
-      complete = true;
-    }
-
-    closeQuietly(upstream);
-    upstream = null;
-  }
-
-  boolean isClosed() {
-    return file == null;
-  }
-
-  public ByteString metadata() {
-    return metadata;
-  }
-
-  /**
-   * Returns a new source that returns the same bytes as upstream. Returns null if this relay has
-   * been closed and no further sources are possible. In that case callers should retry after
-   * building a new relay with {@link #read}.
-   */
-  public Source newSource() {
-    synchronized (Relay.this) {
-      if (file == null) return null;
-      sourceCount++;
-    }
-
-    return new RelaySource();
-  }
-
-  class RelaySource implements Source {
-    private final Timeout timeout = new Timeout();
-
-    /** The operator to read and write the shared file. Null if this source is closed. */
-    private FileOperator fileOperator = new FileOperator(file.getChannel());
-
-    /** The next byte to read. This is always less than or equal to {@code upstreamPos}. */
-    private long sourcePos;
-
-    /**
-     * Selects where to find the bytes for a read and read them. This is one of three sources.
-     *
-     * <h3>Upstream:</h3>
-     * In this case the current thread is assigned as the upstream reader. We read bytes from
-     * upstream and copy them to both the file and to the buffer. Finally we release the upstream
-     * reader lock and return the new bytes.
-     *
-     * <h3>The file</h3>
-     * In this case we copy bytes from the file to the {@code sink}.
-     *
-     * <h3>The buffer</h3>
-     * In this case the bytes are immediately copied into {@code sink} and the number of bytes
-     * copied is returned.
-     *
-     * <p>If upstream would be selected but another thread is already reading upstream this will
-     * block until that read completes. It is possible to time out while waiting for that.
-     */
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (fileOperator == null) throw new IllegalStateException("closed");
-
-      long upstreamPos;
-      int source;
-
-      selectSource:
-      synchronized (Relay.this) {
-        // We need new data from upstream.
-        while (sourcePos == (upstreamPos = Relay.this.upstreamPos)) {
-          // No more data upstream. We're done.
-          if (complete) return -1L;
-
-          // Another thread is already reading. Wait for that.
-          if (upstreamReader != null) {
-            timeout.waitUntilNotified(Relay.this);
-            continue;
-          }
-
-          // We will do the read.
-          upstreamReader = Thread.currentThread();
-          source = SOURCE_UPSTREAM;
-          break selectSource;
-        }
-
-        long bufferPos = upstreamPos - buffer.size();
-
-        // Bytes of the read precede the buffer. Read from the file.
-        if (sourcePos < bufferPos) {
-          source = SOURCE_FILE;
-          break selectSource;
-        }
-
-        // The buffer has the data we need. Read from there and return immediately.
-        long bytesToRead = Math.min(byteCount, upstreamPos - sourcePos);
-        buffer.copyTo(sink, sourcePos - bufferPos, bytesToRead);
-        sourcePos += bytesToRead;
-        return bytesToRead;
-      }
-
-      // Read from the file.
-      if (source == SOURCE_FILE) {
-        long bytesToRead = Math.min(byteCount, upstreamPos - sourcePos);
-        fileOperator.read(FILE_HEADER_SIZE + sourcePos, sink, bytesToRead);
-        sourcePos += bytesToRead;
-        return bytesToRead;
-      }
-
-      // Read from upstream. This always reads a full buffer: that might be more than what the
-      // current call to Source.read() has requested.
-      try {
-        long upstreamBytesRead = upstream.read(upstreamBuffer, bufferMaxSize);
-
-        // If we've exhausted upstream, we're done.
-        if (upstreamBytesRead == -1L) {
-          commit(upstreamPos);
-          return -1L;
-        }
-
-        // Update this source and prepare this call's result.
-        long bytesRead = Math.min(upstreamBytesRead, byteCount);
-        upstreamBuffer.copyTo(sink, 0, bytesRead);
-        sourcePos += bytesRead;
-
-        // Append the upstream bytes to the file.
-        fileOperator.write(
-            FILE_HEADER_SIZE + upstreamPos, upstreamBuffer.clone(), upstreamBytesRead);
-
-        synchronized (Relay.this) {
-          // Append new upstream bytes into the buffer. Trim it to its max size.
-          buffer.write(upstreamBuffer, upstreamBytesRead);
-          if (buffer.size() > bufferMaxSize) {
-            buffer.skip(buffer.size() - bufferMaxSize);
-          }
-
-          // Now that the file and buffer have bytes, adjust upstreamPos.
-          Relay.this.upstreamPos += upstreamBytesRead;
-        }
-
-        return bytesRead;
-      } finally {
-        synchronized (Relay.this) {
-          upstreamReader = null;
-          Relay.this.notifyAll();
-        }
-      }
-    }
-
-    @Override public Timeout timeout() {
-      return timeout;
-    }
-
-    @Override public void close() throws IOException {
-      if (fileOperator == null) return; // Already closed.
-      fileOperator = null;
-
-      RandomAccessFile fileToClose = null;
-      synchronized (Relay.this) {
-        sourceCount--;
-        if (sourceCount == 0) {
-          fileToClose = file;
-          file = null;
-        }
-      }
-
-      if (fileToClose != null) {
-        closeQuietly(fileToClose);
-      }
-    }
-  }
-}
diff --git a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
index 0818961703..f449ab276d 100644
--- a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
+++ b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
@@ -25,7 +25,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.atomic.AtomicInteger;
-import okhttp3.Cache;
+
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
@@ -133,10 +133,7 @@ public static void main(String[] args) throws IOException {
     int threadCount = 20;
     long cacheByteCount = 1024L * 1024L * 100L;
 
-    Cache cache = new Cache(new File(args[0]), cacheByteCount);
-    OkHttpClient client = new OkHttpClient.Builder()
-        .cache(cache)
-        .build();
+    OkHttpClient client = new OkHttpClient.Builder().build();
 
     Crawler crawler = new Crawler(client);
     crawler.queue.add(HttpUrl.parse(args[1]));
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java b/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
index c43f9214ab..36a3811ff1 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CacheResponse.java
@@ -17,7 +17,7 @@
 
 import java.io.File;
 import java.io.IOException;
-import okhttp3.Cache;
+
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
@@ -27,10 +27,8 @@
 
   public CacheResponse(File cacheDirectory) throws Exception {
     int cacheSize = 10 * 1024 * 1024; // 10 MiB
-    Cache cache = new Cache(cacheDirectory, cacheSize);
 
     client = new OkHttpClient.Builder()
-        .cache(cache)
         .build();
   }
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java b/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
deleted file mode 100644
index 92d65d8169..0000000000
--- a/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.recipes;
-
-import java.io.File;
-import java.io.IOException;
-import okhttp3.Cache;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-
-public final class RewriteResponseCacheControl {
-  /** Dangerous interceptor that rewrites the server's cache-control header. */
-  private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() {
-    @Override public Response intercept(Chain chain) throws IOException {
-      Response originalResponse = chain.proceed(chain.request());
-      return originalResponse.newBuilder()
-          .header("Cache-Control", "max-age=60")
-          .build();
-    }
-  };
-
-  private final OkHttpClient client;
-
-  public RewriteResponseCacheControl(File cacheDirectory) throws Exception {
-    Cache cache = new Cache(cacheDirectory, 1024 * 1024);
-    cache.evictAll();
-
-    client = new OkHttpClient.Builder()
-        .cache(cache)
-        .build();
-  }
-
-  public void run() throws Exception {
-    for (int i = 0; i < 5; i++) {
-      System.out.println("    Request: " + i);
-
-      Request request = new Request.Builder()
-          .url("https://api.github.com/search/repositories?q=http")
-          .build();
-
-      OkHttpClient clientForCall;
-      if (i == 2) {
-        // Force this request's response to be written to the cache. This way, subsequent responses
-        // can be read from the cache.
-        System.out.println("Force cache: true");
-        clientForCall = client.newBuilder()
-            .addNetworkInterceptor(REWRITE_CACHE_CONTROL_INTERCEPTOR)
-            .build();
-      } else {
-        System.out.println("Force cache: false");
-        clientForCall = client;
-      }
-
-      try (Response response = clientForCall.newCall(request).execute()) {
-        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-        System.out.println("    Network: " + (response.networkResponse() != null));
-        System.out.println();
-      }
-    }
-  }
-
-  public static void main(String... args) throws Exception {
-    new RewriteResponseCacheControl(new File("RewriteResponseCacheControl.tmp")).run();
-  }
-}
