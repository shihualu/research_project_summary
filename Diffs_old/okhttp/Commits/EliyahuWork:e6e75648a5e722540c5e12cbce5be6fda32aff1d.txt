diff --git a/.travis.yml b/.travis.yml
index 7769867d9d..bc088e91bd 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -3,5 +3,8 @@ language: java
 notifications:
   email: false
 
+before_install:
+ - mvn -version
+
 jdk:
   - oraclejdk7
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 57820a45c4..f52d93ada6 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,25 @@
 Change Log
 ==========
 
+Version 1.3.0 *(2014-01-11)*
+----------------------------
+
+ * New: Support for "PATCH" HTTP method in client and MockWebServer.
+ * Fix: Drop `Content-Length` header when redirected from POST to GET.
+ * Fix: Correctly read cached header entries with malformed header names.
+ * Fix: Do not directly support any authentication schemes other than "Basic".
+ * Fix: Respect read timeouts on recycled connections.
+ * Fix: Transmit multiple cookie values as a single header with delimiter.
+ * Fix: Ensure `null` is never returned from a connection's `getHeaderFields()`.
+ * Fix: Persist proper `Content-Encoding` header to cache for GZip responses.
+ * Fix: Eliminate rare race condition in SPDY streams that would prevent connection reuse.
+ * Fix: Change HTTP date formats to UTC to conform to RFC2616 section 3.3.
+ * Fix: Support SPDY header blocks with trailing bytes.
+ * Fix: Allow `;` as separator for `Cache-Control` header.
+ * Fix: Correct bug where HTTPS POST requests were always automatically buffered.
+ * Fix: Honor read timeout when parsing SPDY headers.
+
+
 Version 1.2.1 *(2013-08-23)*
 ----------------------------
 
diff --git a/README.md b/README.md
index e206f237ec..0e7c94a054 100644
--- a/README.md
+++ b/README.md
@@ -45,10 +45,31 @@ Java 6, otherwise the test class will be silently omitted from the `.dex` file.
 mvn clean
 mvn package -DskipTests
 vogar \
-    --classpath ~/.m2/repository/org/bouncycastle/bcprov-jdk15on/1.47/bcprov-jdk15on-1.47.jar \
-    --classpath ~/.m2/repository/com/google/mockwebserver/mockwebserver/20130122/mockwebserver-20130122.jar \
-    --classpath target/okhttp-0.9-SNAPSHOT.jar \
-    ./src/test/java
+    --classpath ~/.m2/repository/org/bouncycastle/bcprov-jdk15on/1.48/bcprov-jdk15on-1.48.jar \
+    --classpath mockwebserver/target/mockwebserver-2.0.0-SNAPSHOT.jar \
+    --classpath okhttp-protocols/target/okhttp-protocols-2.0.0-SNAPSHOT.jar \
+    --classpath okhttp/target/okhttp-2.0.0-SNAPSHOT.jar \
+    okhttp/src/test
+```
+
+MockWebServer
+-------------
+
+A library for testing HTTP, HTTPS, HTTP/2.0, and SPDY clients.
+
+MockWebServer coupling with OkHttp is essential for proper testing of SPDY and HTTP/2.0 so that code can be shared.
+
+### Download
+
+Download [the latest JAR][5] or grab via Maven:
+
+```xml
+<dependency>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>mockwebserver</artifactId>
+    <version>(insert latest version)</version>
+    <scope>test</scope>
+</dependency>
 ```
 
 
@@ -71,6 +92,7 @@ License
 
 
  [1]: http://square.github.io/okhttp
- [2]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=okhttp&v=LATEST
+ [2]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=okhttp&v=LATEST&c=jar-with-dependencies
  [3]: http://wiki.eclipse.org/Jetty/Feature/NPN
  [4]: https://code.google.com/p/vogar/
+ [5]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=mockwebserver&v=LATEST
diff --git a/benchmarks/README.md b/benchmarks/README.md
new file mode 100644
index 0000000000..59f571fc55
--- /dev/null
+++ b/benchmarks/README.md
@@ -0,0 +1,8 @@
+OkHttp Benchmarks
+=======================================
+
+This module allows you to test the performance of HTTP clients.
+
+### Running
+  1. If you made modifications to `com.squareup.okhttp.benchmarks.Benchmark` run `mvn compile`.
+  2. Run `mvn exec:exec` to launch a new JVM, which will execute the benchmark.
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
new file mode 100644
index 0000000000..fb67f50eeb
--- /dev/null
+++ b/benchmarks/pom.xml
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>benchmarks</artifactId>
+  <name>Benchmarks</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.google.caliper</groupId>
+      <artifactId>caliper</artifactId>
+      <version>1.0-beta-1</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.bouncycastle</groupId>
+      <artifactId>bcprov-jdk15on</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.mortbay.jetty.npn</groupId>
+      <artifactId>npn-boot</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.httpcomponents</groupId>
+      <artifactId>httpclient</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-transport</artifactId>
+      <version>4.0.15.Final</version>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-handler</artifactId>
+      <version>4.0.15.Final</version>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-codec-http</artifactId>
+      <version>4.0.15.Final</version>
+    </dependency>
+    <!-- Netty needs this if gzip is enabled. -->
+    <dependency>
+      <groupId>com.jcraft</groupId>
+      <artifactId>jzlib</artifactId>
+      <version>1.1.2</version>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+    <plugin>
+      <groupId>org.codehaus.mojo</groupId>
+      <artifactId>exec-maven-plugin</artifactId>
+      <executions>
+        <execution>
+          <goals>
+            <goal>java</goal>
+          </goals>
+        </execution>
+      </executions>
+      <configuration>
+        <executable>java</executable>
+        <arguments>
+          <argument>-Xms512m</argument>
+          <argument>-Xmx512m</argument>
+          <commandlineArgs>-Xbootclasspath/p:${settings.localRepository}/org/mortbay/jetty/npn/npn-boot/${npn.version}/npn-boot-${npn.version}.jar</commandlineArgs>
+          <argument>-classpath</argument>
+          <classpath/>
+          <argument>com.squareup.okhttp.benchmarks.Benchmark</argument>
+        </arguments>
+      </configuration>
+    </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java
new file mode 100644
index 0000000000..cb8e719111
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.internal.SslContextBuilder;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.concurrent.TimeUnit;
+import java.util.zip.GZIPInputStream;
+import javax.net.ssl.SSLContext;
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.conn.ssl.SSLSocketFactory;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.conn.PoolingClientConnectionManager;
+
+/** Benchmark Apache HTTP client. */
+class ApacheHttpClient extends SynchronousHttpClient {
+  private static final boolean VERBOSE = false;
+
+  private HttpClient client;
+
+  @Override public void prepare(Benchmark benchmark) {
+    super.prepare(benchmark);
+    ClientConnectionManager connectionManager = new PoolingClientConnectionManager();
+    if (benchmark.tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      connectionManager.getSchemeRegistry().register(
+          new Scheme("https", 443, new SSLSocketFactory(sslContext)));
+    }
+    client = new DefaultHttpClient(connectionManager);
+  }
+
+  @Override public Runnable request(URL url) {
+    return new ApacheHttpClientRequest(url);
+  }
+
+  class ApacheHttpClientRequest implements Runnable {
+    private final URL url;
+
+    public ApacheHttpClientRequest(URL url) {
+      this.url = url;
+    }
+
+    public void run() {
+      long start = System.nanoTime();
+      try {
+        HttpResponse response = client.execute(new HttpGet(url.toString()));
+        InputStream in = response.getEntity().getContent();
+        Header contentEncoding = response.getFirstHeader("Content-Encoding");
+        if (contentEncoding != null && contentEncoding.getValue().equals("gzip")) {
+          in = new GZIPInputStream(in);
+        }
+
+        long total = readAllAndClose(in);
+        long finish = System.nanoTime();
+
+        if (VERBOSE) {
+          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+        }
+      } catch (IOException e) {
+        System.out.println("Failed: " + e);
+      }
+    }
+  }
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
new file mode 100644
index 0000000000..151128d6c0
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.google.caliper.Param;
+import com.google.caliper.model.ArbitraryMeasurement;
+import com.google.caliper.runner.CaliperMain;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.Dispatcher;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import java.util.zip.GZIPOutputStream;
+import javax.net.ssl.SSLContext;
+
+/**
+ * This benchmark is fake, but may be useful for certain relative comparisons.
+ * It uses a local connection to a MockWebServer to measure how many identical
+ * requests per second can be carried over a fixed number of threads.
+ */
+public class Benchmark extends com.google.caliper.Benchmark {
+  private static final int NUM_REPORTS = 10;
+  private static final boolean VERBOSE = false;
+
+  private final Random random = new Random(0);
+
+  /** Which client to run.*/
+  @Param
+  Client client;
+
+  /** How many concurrent requests to execute. */
+  @Param({ "1", "10" })
+  int concurrencyLevel;
+
+  /** How many requests to enqueue to await threads to execute them. */
+  @Param({ "10" })
+  int targetBacklog;
+
+  /** True to use TLS. */
+  // TODO: compare different ciphers?
+  @Param
+  boolean tls;
+
+  /** True to use gzip content-encoding for the response body. */
+  @Param
+  boolean gzip;
+
+  /** Don't combine chunked with SPDY_3 or HTTP_2; that's not allowed. */
+  @Param
+  boolean chunked;
+
+  /** The size of the HTTP response body, in uncompressed bytes. */
+  @Param({ "128", "1048576" })
+  int bodyByteCount;
+
+  /** How many additional headers were included, beyond the built-in ones. */
+  @Param({ "0", "20" })
+  int headerCount;
+
+  /** Which ALPN/NPN protocols are in use. Only useful with TLS. */
+  List<Protocol> protocols = Arrays.asList(Protocol.HTTP_11);
+
+  public static void main(String[] args) {
+    List<String> allArgs = new ArrayList<String>();
+    allArgs.add("--instrument");
+    allArgs.add("arbitrary");
+    allArgs.addAll(Arrays.asList(args));
+
+    CaliperMain.main(Benchmark.class, allArgs.toArray(new String[allArgs.size()]));
+  }
+
+  @ArbitraryMeasurement(description = "requests per second")
+  public double run() throws Exception {
+    if (VERBOSE) System.out.println(toString());
+    HttpClient httpClient = client.create();
+
+    // Prepare the client & server
+    httpClient.prepare(this);
+    MockWebServer server = startServer();
+    URL url = server.getUrl("/");
+
+    int requestCount = 0;
+    long reportStart = System.nanoTime();
+    long reportPeriod = TimeUnit.SECONDS.toNanos(1);
+    int reports = 0;
+    double best = 0.0;
+
+    // Run until we've printed enough reports.
+    while (reports < NUM_REPORTS) {
+      // Print a report if we haven't recently.
+      long now = System.nanoTime();
+      double reportDuration = now - reportStart;
+      if (reportDuration > reportPeriod) {
+        double requestsPerSecond = requestCount / reportDuration * TimeUnit.SECONDS.toNanos(1);
+        if (VERBOSE) {
+          System.out.println(String.format("Requests per second: %.1f", requestsPerSecond));
+        }
+        best = Math.max(best, requestsPerSecond);
+        requestCount = 0;
+        reportStart = now;
+        reports++;
+      }
+
+      // Fill the job queue with work.
+      while (httpClient.acceptingJobs()) {
+        httpClient.enqueue(url);
+        requestCount++;
+      }
+
+      // The job queue is full. Take a break.
+      sleep(1);
+    }
+
+    return best;
+  }
+
+  @Override public String toString() {
+    List<Object> modifiers = new ArrayList<Object>();
+    if (tls) modifiers.add("tls");
+    if (gzip) modifiers.add("gzip");
+    if (chunked) modifiers.add("chunked");
+    modifiers.addAll(protocols);
+
+    return String.format("%s %s\nbodyByteCount=%s headerCount=%s concurrencyLevel=%s",
+        client, modifiers, bodyByteCount, headerCount, concurrencyLevel);
+  }
+
+  private void sleep(int millis) {
+    try {
+      Thread.sleep(millis);
+    } catch (InterruptedException ignored) {
+    }
+  }
+
+  private MockWebServer startServer() throws IOException {
+    Logger.getLogger(MockWebServer.class.getName()).setLevel(Level.WARNING);
+    MockWebServer server = new MockWebServer();
+
+    if (tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      server.useHttps(sslContext.getSocketFactory(), false);
+      server.setNpnEnabled(true);
+      server.setNpnProtocols(protocols);
+    }
+
+    final MockResponse response = newResponse();
+    server.setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        return response;
+      }
+    });
+
+    server.play();
+    return server;
+  }
+
+  private MockResponse newResponse() throws IOException {
+    byte[] body = new byte[bodyByteCount];
+    random.nextBytes(body);
+
+    MockResponse result = new MockResponse();
+
+    if (gzip) {
+      body = gzip(body);
+      result.addHeader("Content-Encoding: gzip");
+    }
+
+    if (chunked) {
+      result.setChunkedBody(body, 1024);
+    } else {
+      result.setBody(body);
+    }
+
+    for (int i = 0; i < headerCount; i++) {
+      result.addHeader(randomString(12), randomString(20));
+    }
+
+    return result;
+  }
+
+  private String randomString(int length) {
+    String alphabet = "-abcdefghijklmnopqrstuvwxyz";
+    char[] result = new char[length];
+    for (int i = 0; i < length; i++) {
+      result[i] = alphabet.charAt(random.nextInt(alphabet.length()));
+    }
+    return new String(result);
+  }
+
+  /** Returns a gzipped copy of {@code bytes}. */
+  private byte[] gzip(byte[] bytes) throws IOException {
+    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
+    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
+    gzippedOut.write(bytes);
+    gzippedOut.close();
+    return bytesOut.toByteArray();
+  }
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java
new file mode 100644
index 0000000000..bd777aa359
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+enum Client {
+  OkHttp {
+    @Override HttpClient create() {
+      return new OkHttp();
+    }
+  },
+
+  OkHttpAsync {
+    @Override HttpClient create() {
+      return new OkHttpAsync();
+    }
+  },
+
+  Apache {
+    @Override HttpClient create() {
+      return new ApacheHttpClient();
+    }
+  },
+
+  UrlConnection {
+    @Override HttpClient create() {
+      return new UrlConnection();
+    }
+  },
+
+  Netty {
+    @Override HttpClient create() {
+      return new NettyHttpClient();
+    }
+  };
+
+  abstract HttpClient create();
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java
new file mode 100644
index 0000000000..136c5d86d3
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import java.net.URL;
+
+/** An HTTP client to benchmark. */
+interface HttpClient {
+  void prepare(Benchmark benchmark);
+  void enqueue(URL url) throws Exception;
+  boolean acceptingJobs();
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
new file mode 100644
index 0000000000..9044d0a33c
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
+import io.netty.bootstrap.Bootstrap;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.PooledByteBufAllocator;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.SimpleChannelInboundHandler;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.codec.http.DefaultFullHttpRequest;
+import io.netty.handler.codec.http.HttpClientCodec;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpContentDecompressor;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpMethod;
+import io.netty.handler.codec.http.HttpObject;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpVersion;
+import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.handler.ssl.SslHandler;
+import java.net.URL;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+
+/** Netty isn't an HTTP client, but it's almost one. */
+class NettyHttpClient implements HttpClient {
+  private static final boolean VERBOSE = false;
+
+  // Guarded by this. Real apps need more capable connection management.
+  private final Deque<HttpChannel> freeChannels = new ArrayDeque<HttpChannel>();
+  private final Deque<URL> backlog = new ArrayDeque<URL>();
+
+  private int totalChannels = 0;
+  private int concurrencyLevel;
+  private int targetBacklog;
+  private Bootstrap bootstrap;
+
+  @Override public void prepare(final Benchmark benchmark) {
+    this.concurrencyLevel = benchmark.concurrencyLevel;
+    this.targetBacklog = benchmark.targetBacklog;
+
+    ChannelInitializer<SocketChannel> channelInitializer = new ChannelInitializer<SocketChannel>() {
+      @Override public void initChannel(SocketChannel channel) throws Exception {
+        ChannelPipeline pipeline = channel.pipeline();
+
+        if (benchmark.tls) {
+          SSLContext sslContext = SslContextBuilder.localhost();
+          SSLEngine engine = sslContext.createSSLEngine();
+          engine.setUseClientMode(true);
+          pipeline.addLast("ssl", new SslHandler(engine));
+        }
+
+        pipeline.addLast("codec", new HttpClientCodec());
+        pipeline.addLast("inflater", new HttpContentDecompressor());
+        pipeline.addLast("handler", new HttpChannel(channel));
+      }
+    };
+
+    bootstrap = new Bootstrap();
+    bootstrap.group(new NioEventLoopGroup(concurrencyLevel))
+        .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
+        .channel(NioSocketChannel.class)
+        .handler(channelInitializer);
+  }
+
+  @Override public void enqueue(URL url) throws Exception {
+    HttpChannel httpChannel = null;
+    synchronized (this) {
+      if (!freeChannels.isEmpty()) {
+        httpChannel = freeChannels.pop();
+      } else if (totalChannels < concurrencyLevel) {
+        totalChannels++; // Create a new channel. (outside of the synchronized block).
+      } else {
+        backlog.add(url); // Enqueue this for later, to be picked up when another request completes.
+        return;
+      }
+    }
+    if (httpChannel == null) {
+      Channel channel = bootstrap.connect(url.getHost(), Util.getEffectivePort(url))
+          .sync().channel();
+      httpChannel = (HttpChannel) channel.pipeline().last();
+    }
+    httpChannel.sendRequest(url);
+  }
+
+  @Override public synchronized boolean acceptingJobs() {
+    return backlog.size() < targetBacklog || hasFreeChannels();
+  }
+
+  private boolean hasFreeChannels() {
+    int activeChannels = totalChannels - freeChannels.size();
+    return activeChannels < concurrencyLevel;
+  }
+
+  private void release(HttpChannel httpChannel) {
+    URL url;
+    synchronized (this) {
+      url = backlog.pop();
+      if (url == null) {
+        // There were no URLs in the backlog. Pool this channel for later.
+        freeChannels.push(httpChannel);
+        return;
+      }
+    }
+
+    // We removed a URL from the backlog. Schedule it right away.
+    httpChannel.sendRequest(url);
+  }
+
+  class HttpChannel extends SimpleChannelInboundHandler<HttpObject> {
+    private final SocketChannel channel;
+    byte[] buffer = new byte[1024];
+    int total;
+    long start;
+
+    public HttpChannel(SocketChannel channel) {
+      this.channel = channel;
+    }
+
+    private void sendRequest(URL url) {
+      start = System.nanoTime();
+      total = 0;
+      HttpRequest request = new DefaultFullHttpRequest(
+          HttpVersion.HTTP_1_1, HttpMethod.GET, url.getPath());
+      request.headers().set(HttpHeaders.Names.HOST, url.getHost());
+      request.headers().set(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
+      channel.writeAndFlush(request);
+    }
+
+    @Override protected void channelRead0(
+        ChannelHandlerContext context, HttpObject message) throws Exception {
+      if (message instanceof HttpResponse) {
+        receive((HttpResponse) message);
+      }
+      if (message instanceof HttpContent) {
+        receive((HttpContent) message);
+        if (message instanceof LastHttpContent) {
+          release(this);
+        }
+      }
+    }
+
+    @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+      super.channelInactive(ctx);
+    }
+
+    void receive(HttpResponse response) {
+      // Don't do anything with headers.
+    }
+
+    void receive(HttpContent content) {
+      // Consume the response body.
+      ByteBuf byteBuf = content.content();
+      for (int toRead; (toRead = byteBuf.readableBytes()) > 0; ) {
+        byteBuf.readBytes(buffer, 0, Math.min(buffer.length, toRead));
+        total += toRead;
+      }
+
+      if (VERBOSE && content instanceof LastHttpContent) {
+        long finish = System.nanoTime();
+        System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+            total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+      }
+    }
+
+    @Override public void exceptionCaught(ChannelHandlerContext context, Throwable cause) {
+      System.out.println("Failed: " + cause);
+    }
+  }
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
new file mode 100644
index 0000000000..03b9e3c6f1
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+
+class OkHttp extends SynchronousHttpClient {
+  private static final boolean VERBOSE = false;
+
+  private OkHttpClient client;
+
+  @Override public void prepare(Benchmark benchmark) {
+    super.prepare(benchmark);
+    client = new OkHttpClient();
+    client.setProtocols(benchmark.protocols);
+
+    if (benchmark.tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
+        @Override public boolean verify(String s, SSLSession session) {
+          return true;
+        }
+      };
+      client.setSslSocketFactory(socketFactory);
+      client.setHostnameVerifier(hostnameVerifier);
+    }
+  }
+
+  @Override public Runnable request(URL url) {
+    return new OkHttpRequest(url);
+  }
+
+  class OkHttpRequest implements Runnable {
+    private final URL url;
+
+    public OkHttpRequest(URL url) {
+      this.url = url;
+    }
+
+    public void run() {
+      long start = System.nanoTime();
+      try {
+        HttpURLConnection urlConnection = client.open(url);
+        long total = readAllAndClose(urlConnection.getInputStream());
+        long finish = System.nanoTime();
+
+        if (VERBOSE) {
+          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+        }
+      } catch (IOException e) {
+        System.out.println("Failed: " + e);
+      }
+    }
+  }
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
new file mode 100644
index 0000000000..b7633b76aa
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.Dispatcher;
+import com.squareup.okhttp.Failure;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import java.io.IOException;
+import java.net.URL;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+
+class OkHttpAsync implements HttpClient {
+  private static final boolean VERBOSE = false;
+
+  private final AtomicInteger requestsInFlight = new AtomicInteger();
+
+  private OkHttpClient client;
+  private Response.Receiver receiver;
+  private int concurrencyLevel;
+  private int targetBacklog;
+
+  @Override public void prepare(final Benchmark benchmark) {
+    concurrencyLevel = benchmark.concurrencyLevel;
+    targetBacklog = benchmark.targetBacklog;
+
+    client = new OkHttpClient();
+    client.setProtocols(benchmark.protocols);
+    client.setDispatcher(new Dispatcher(new ThreadPoolExecutor(benchmark.concurrencyLevel,
+        benchmark.concurrencyLevel, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>())));
+
+    if (benchmark.tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
+        @Override public boolean verify(String s, SSLSession session) {
+          return true;
+        }
+      };
+      client.setSslSocketFactory(socketFactory);
+      client.setHostnameVerifier(hostnameVerifier);
+    }
+
+    receiver = new Response.Receiver() {
+      @Override public void onFailure(Failure failure) {
+        System.out.println("Failed: " + failure.exception());
+      }
+
+      @Override public boolean onResponse(Response response) throws IOException {
+        Response.Body body = response.body();
+        long total = SynchronousHttpClient.readAllAndClose(body.byteStream());
+        long finish = System.nanoTime();
+        if (VERBOSE) {
+          long start = (Long) response.request().tag();
+          System.out.printf("Transferred % 8d bytes in %4d ms%n",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start));
+        }
+        requestsInFlight.decrementAndGet();
+        return true;
+      }
+    };
+  }
+
+  @Override public void enqueue(URL url) throws Exception {
+    requestsInFlight.incrementAndGet();
+    client.enqueue(new Request.Builder().tag(System.nanoTime()).url(url).build(), receiver);
+  }
+
+  @Override public synchronized boolean acceptingJobs() {
+    return requestsInFlight.get() < (concurrencyLevel + targetBacklog);
+  }
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
new file mode 100644
index 0000000000..b15eedcd88
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+/** Any HTTP client with a blocking API. */
+abstract class SynchronousHttpClient implements HttpClient {
+  ThreadPoolExecutor executor;
+  int targetBacklog;
+
+  @Override public void prepare(Benchmark benchmark) {
+    this.targetBacklog = benchmark.targetBacklog;
+    executor = new ThreadPoolExecutor(benchmark.concurrencyLevel, benchmark.concurrencyLevel,
+        1, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
+  }
+
+  @Override public void enqueue(URL url) {
+    executor.execute(request(url));
+  }
+
+  @Override public boolean acceptingJobs() {
+    return executor.getQueue().size() < targetBacklog;
+  }
+
+  static long readAllAndClose(InputStream in) throws IOException {
+    byte[] buffer = new byte[1024];
+    long total = 0;
+    for (int count; (count = in.read(buffer)) != -1; ) {
+      total += count;
+    }
+    in.close();
+    return total;
+  }
+
+  abstract Runnable request(URL url);
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
new file mode 100644
index 0000000000..79abb69eeb
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.concurrent.TimeUnit;
+import java.util.zip.GZIPInputStream;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+
+class UrlConnection extends SynchronousHttpClient {
+  private static final boolean VERBOSE = false;
+
+  @Override public void prepare(Benchmark benchmark) {
+    super.prepare(benchmark);
+    if (benchmark.tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
+        @Override public boolean verify(String s, SSLSession session) {
+          return true;
+        }
+      };
+      HttpsURLConnectionImpl.setDefaultHostnameVerifier(hostnameVerifier);
+      HttpsURLConnectionImpl.setDefaultSSLSocketFactory(socketFactory);
+    }
+  }
+
+  @Override public Runnable request(URL url) {
+    return new UrlConnectionRequest(url);
+  }
+
+  static class UrlConnectionRequest implements Runnable {
+    private final URL url;
+
+    public UrlConnectionRequest(URL url) {
+      this.url = url;
+    }
+
+    public void run() {
+      long start = System.nanoTime();
+      try {
+        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
+        InputStream in = urlConnection.getInputStream();
+        if ("gzip".equals(urlConnection.getHeaderField("Content-Encoding"))) {
+          in = new GZIPInputStream(in);
+        }
+
+        long total = readAllAndClose(in);
+        long finish = System.nanoTime();
+
+        if (VERBOSE) {
+          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+        }
+      } catch (IOException e) {
+        System.out.println("Failed: " + e);
+      }
+    }
+  }
+}
diff --git a/concurrency.md b/concurrency.md
new file mode 100644
index 0000000000..0858133a31
--- /dev/null
+++ b/concurrency.md
@@ -0,0 +1,63 @@
+# Concurrency in OkHttp
+
+The HttpURLConnection API is a blocking API. You make a blocking write to send a request, and a blocking read to receive the response.
+
+#### Blocking APIs
+
+Blocking APIs are convenient because you get top-to-bottom procedural code without indirection. Network calls work like regular method calls: ask for data and it is returned. If the request fails, you get a stacktrace right were the call was made.
+
+Blocking APIs may be inefficient because you hold a thread idle while waiting on the network. Threads are expensive because they have both a memory overhead and a context-switching overhead.
+
+#### Framed protocols
+
+Framed protocols like spdy/3 and http/2 don't lend themselves to blocking APIs. Each application-layer thread wants to do blocking I/O for a specific stream, but the streams are multiplexed on the socket. You can't just talk to the socket, you need to cooperate with the other application-layer threads that you're sharing it with.
+
+Framing rules make it impractical to implement spdy/3 or http/2 correctly on a single blocking thread. The flow-control features introduce feedback between reads and writes, requiring writes to acknowledge reads and reads to throttle writes.
+
+In OkHttp we expose a blocking API over a framed protocol. This document explains the code and policy that makes that work.
+
+## Threads
+
+#### Application's calling thread
+
+The application-layer must block on writing I/O. We can't return from a write until we've pushed its bytes onto the socket. Otherwise, if the write fails we are unable to deliver its IOException to the application. We would have told the application layer that the write succeeded, but it didn't!
+
+The application-layer can also do blocking reads. If the application asks to read and there's nothing available, we need to hold that thread until either the bytes arrive, the stream is closed, or a timeout elapses. If we get bytes but there's nobody asking for them, we buffer them. We don't consider bytes as delivered for flow control until they're consumed by the application.
+
+Consider an application streaming a video over http/2. Perhaps the user pauses the video and the application stops reading bytes from this stream. The buffer will fill up, and flow control prevents the server from sending more data on this stream. When the user unpauses her video the buffer drains, the read is acknowledged, and the server proceeds to stream data.
+
+#### Shared reader thread
+
+We can't rely on application threads to read data from the socket. Application threads are transient: sometimes they're reading and writing and sometimes they're off doing application-layer things. But the socket is permanent, and it needs constant attention: we dispatch all incoming frames so the connection is good-to-go when the application layer needs it.
+
+So we have a dedicated thread for every socket that just reads frames and dispatches them.
+
+The reader thread must never run application-layer code. Otherwise one slow stream can hold up the entire connection.
+
+Similarly, the reader thread must never block on writing because this can deadlock the connection. Consider a client and server that both violate this rule. If you get unlucky, they could fill up their TCP buffers (so that writes block) and then use their reader threads to write a frame. Nobody is reading on either end, and the buffers are never drained.
+
+#### Do-stuff-later pool
+
+Sometimes there's an action required like calling the application layer or responding to a ping, and the thread discovering the action is not the thread that should do the work. We enqueue a runnable on this executor and it gets handled by one of the executor's threads.
+
+## Locks
+
+We have 3 different things that we synchronize on.
+
+#### SpdyConnection
+
+This lock guards internal state of each connection. This lock is never held for blocking operations. That means that we acquire the lock, read or write a few fields and release the lock. No I/O and no application-layer callbacks.
+
+#### SpdyStream
+
+This lock guards the internal state of each stream. As above, it is never held for blocking operations. When we need to hold an application thread to block a read, we use wait/notify on this lock. This works because the lock is released while `wait()` is waiting.
+
+#### FrameWriter
+
+Socket writes are guarded by the FrameWriter. Only one stream can write at a time so that messages are not interleaved. Writes are either made by application-layer threads or the do-stuff-later pool.
+
+### Holding multiple locks
+
+You're allowed to take the SpdyConnection lock while holding the FrameWriter lock. But not vice-versa. Because taking the FrameWriter lock can block.
+
+This is necessary for bookkeeping when creating new streams. Correct framing requires that stream IDs are sequential on the socket, so we need to bundle assigning the ID with sending the `SYN_STREAM` frame.
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index f33f156ea1..b935acbc68 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
@@ -35,18 +35,23 @@
   </dependencies>
 
   <build>
-    <!-- Don't restrict test code to Java 1.5 APIs. -->
     <plugins>
       <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
         <configuration>
-          <signature>
-            <groupId>org.codehaus.mojo.signature</groupId>
-            <artifactId>java16</artifactId>
-            <version>1.0</version>
-          </signature>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
         </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
       </plugin>
     </plugins>
   </build>
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
index 067726354f..253fcbda87 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/internal/SslContextBuilder.java
@@ -19,6 +19,8 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.math.BigInteger;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
 import java.security.GeneralSecurityException;
 import java.security.KeyPair;
 import java.security.KeyPairGenerator;
@@ -48,6 +50,8 @@
   }
 
   private static final long ONE_DAY_MILLIS = 1000L * 60 * 60 * 24;
+  private static SSLContext localhost; // Lazily initialized.
+
   private final String hostName;
   private long notBefore = System.currentTimeMillis();
   private long notAfter = System.currentTimeMillis() + ONE_DAY_MILLIS;
@@ -60,6 +64,20 @@ public SslContextBuilder(String hostName) {
     this.hostName = hostName;
   }
 
+  /** Returns a new SSL context for this host's current localhost address. */
+  public static synchronized SSLContext localhost() {
+    if (localhost == null) {
+      try {
+        localhost = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
+      } catch (GeneralSecurityException e) {
+        throw new RuntimeException(e);
+      } catch (UnknownHostException e) {
+        throw new RuntimeException(e);
+      }
+    }
+    return localhost;
+  }
+
   public SSLContext build() throws GeneralSecurityException {
     char[] password = "password".toCharArray();
 
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
index 7371f2e3dc..79dc4bbb41 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
@@ -16,7 +16,9 @@
 
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -24,16 +26,16 @@
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
-import java.net.InetAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.Arrays;
 import java.util.List;
-import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import org.eclipse.jetty.npn.NextProtoNego;
 
+import static com.squareup.okhttp.internal.Util.headerEntries;
+
 /** A basic SPDY server that serves the contents of a local directory. */
 public final class SpdyServer implements IncomingStreamHandler {
   private final File baseDirectory;
@@ -70,7 +72,7 @@ private Socket doSsl(Socket socket) throws IOException {
         System.out.println("UNSUPPORTED");
       }
       @Override public List<String> protocols() {
-        return Arrays.asList("spdy/3");
+        return Arrays.asList(Protocol.SPDY_3.name.utf8());
       }
       @Override public void protocolSelected(String protocol) {
         System.out.println("PROTOCOL SELECTED: " + protocol);
@@ -80,12 +82,11 @@ private Socket doSsl(Socket socket) throws IOException {
   }
 
   @Override public void receive(final SpdyStream stream) throws IOException {
-    List<String> requestHeaders = stream.getRequestHeaders();
+    List<Header> requestHeaders = stream.getRequestHeaders();
     String path = null;
-    for (int i = 0; i < requestHeaders.size(); i += 2) {
-      String s = requestHeaders.get(i);
-      if (":path".equals(s)) {
-        path = requestHeaders.get(i + 1);
+    for (int i = 0; i < requestHeaders.size(); i++) {
+      if (requestHeaders.get(i).name.equals(Header.TARGET_PATH)) {
+        path = requestHeaders.get(i).value.utf8();
         break;
       }
     }
@@ -107,8 +108,8 @@ private Socket doSsl(Socket socket) throws IOException {
   }
 
   private void send404(SpdyStream stream, String path) throws IOException {
-    List<String> responseHeaders =
-        Arrays.asList(":status", "404", ":version", "HTTP/1.1", "content-type", "text/plain");
+    List<Header> responseHeaders =
+        headerEntries(":status", "404", ":version", "HTTP/1.1", "content-type", "text/plain");
     stream.reply(responseHeaders, true);
     OutputStream out = stream.getOutputStream();
     String text = "Not found: " + path;
@@ -117,8 +118,8 @@ private void send404(SpdyStream stream, String path) throws IOException {
   }
 
   private void serveDirectory(SpdyStream stream, String[] files) throws IOException {
-    List<String> responseHeaders =
-        Arrays.asList(":status", "200", ":version", "HTTP/1.1", "content-type",
+    List<Header> responseHeaders =
+        headerEntries(":status", "200", ":version", "HTTP/1.1", "content-type",
             "text/html; charset=UTF-8");
     stream.reply(responseHeaders, true);
     OutputStream out = stream.getOutputStream();
@@ -130,17 +131,21 @@ private void serveDirectory(SpdyStream stream, String[] files) throws IOExceptio
   }
 
   private void serveFile(SpdyStream stream, File file) throws IOException {
-    InputStream in = new FileInputStream(file);
     byte[] buffer = new byte[8192];
     stream.reply(
-        Arrays.asList(":status", "200", ":version", "HTTP/1.1", "content-type", contentType(file)),
+        headerEntries(":status", "200", ":version", "HTTP/1.1", "content-type", contentType(file)),
         true);
+    InputStream in = new FileInputStream(file);
     OutputStream out = stream.getOutputStream();
-    int count;
-    while ((count = in.read(buffer)) != -1) {
-      out.write(buffer, 0, count);
+    try {
+      int count;
+      while ((count = in.read(buffer)) != -1) {
+        out.write(buffer, 0, count);
+      }
+    } finally {
+      Util.closeQuietly(in);
+      Util.closeQuietly(out);
     }
-    out.close();
   }
 
   private String contentType(File file) {
@@ -154,8 +159,7 @@ public static void main(String... args) throws Exception {
     }
 
     SpdyServer server = new SpdyServer(new File(args[0]));
-    SSLContext sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    server.useHttps(sslContext.getSocketFactory());
+    server.useHttps(SslContextBuilder.localhost().getSocketFactory());
     server.run();
   }
 }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
index b073c11a7d..beb4adb36f 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
@@ -24,6 +24,7 @@
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
 
 /** A scripted response to be replayed by the mock web server. */
 public final class MockResponse implements Cloneable {
@@ -37,9 +38,14 @@
   /** The response body content, or null if {@code body} is set. */
   private InputStream bodyStream;
 
-  private int bytesPerSecond = Integer.MAX_VALUE;
+  private int throttleBytesPerPeriod = Integer.MAX_VALUE;
+  private long throttlePeriod = 1;
+  private TimeUnit throttleUnit = TimeUnit.SECONDS;
+
   private SocketPolicy socketPolicy = SocketPolicy.KEEP_OPEN;
 
+  private int bodyDelayTimeMs = 0;
+
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
     setBody(new byte[0]);
@@ -204,19 +210,43 @@ public MockResponse setSocketPolicy(SocketPolicy socketPolicy) {
     return this;
   }
 
-  public int getBytesPerSecond() {
-    return bytesPerSecond;
+  /**
+   * Throttles the response body writer to sleep for the given period after each
+   * series of {@code bytesPerPeriod} bytes are written. Use this to simulate
+   * network behavior.
+   */
+  public MockResponse throttleBody(int bytesPerPeriod, long period, TimeUnit unit) {
+    this.throttleBytesPerPeriod = bytesPerPeriod;
+    this.throttlePeriod = period;
+    this.throttleUnit = unit;
+    return this;
+  }
+
+  public int getThrottleBytesPerPeriod() {
+    return throttleBytesPerPeriod;
+  }
+
+  public long getThrottlePeriod() {
+    return throttlePeriod;
+  }
+
+  public TimeUnit getThrottleUnit() {
+    return throttleUnit;
   }
 
   /**
-   * Set simulated network speed, in bytes per second. This applies to the
-   * response body only; response headers are not throttled.
+   * Set the delayed time of the response body to {@code delay}. This applies to the
+   * response body only; response headers are not affected.
    */
-  public MockResponse setBytesPerSecond(int bytesPerSecond) {
-    this.bytesPerSecond = bytesPerSecond;
+  public MockResponse setBodyDelayTimeMs(int delay) {
+    bodyDelayTimeMs = delay;
     return this;
   }
 
+  public int getBodyDelayTimeMs() {
+    return bodyDelayTimeMs;
+  }
+
   @Override public String toString() {
     return status;
   }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 6ab78ad5ca..5e51fa61cd 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -17,8 +17,12 @@
 
 package com.squareup.okhttp.mockwebserver;
 
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.ByteString;
+import com.squareup.okhttp.internal.spdy.Header;
 import com.squareup.okhttp.internal.spdy.IncomingStreamHandler;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
@@ -42,7 +46,6 @@
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
@@ -70,22 +73,6 @@
  * replays them upon request in sequence.
  */
 public final class MockWebServer {
-  private static final byte[] NPN_PROTOCOLS = {
-      // TODO: support HTTP/2.0.
-      // 17, 'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '4', '/', '2', '.', '0',
-      6, 's', 'p', 'd', 'y', '/', '3',
-      8, 'h', 't', 't', 'p', '/', '1', '.', '1'
-  };
-  private static final byte[] SPDY3 = new byte[] {
-      's', 'p', 'd', 'y', '/', '3'
-  };
-  private static final byte[] HTTP_20_DRAFT_04 = new byte[] {
-      'H', 'T', 'T', 'P', '-', 'd', 'r', 'a', 'f', 't', '-', '0', '4', '/', '2', '.', '0'
-  };
-  private static final byte[] HTTP_11 = new byte[] {
-      'h', 't', 't', 'p', '/', '1', '.', '1'
-  };
-
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
     @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
         throws CertificateException {
@@ -120,6 +107,7 @@
 
   private int port = -1;
   private boolean npnEnabled = true;
+  private List<Protocol> npnProtocols = Protocol.HTTP2_SPDY3_AND_HTTP;
 
   public int getPort() {
     if (port == -1) throw new IllegalStateException("Cannot retrieve port before calling play()");
@@ -172,13 +160,31 @@ public void setBodyLimit(int maxBodyLength) {
 
   /**
    * Sets whether NPN is used on incoming HTTPS connections to negotiate a
-   * transport like HTTP/1.1 or SPDY/3. Call this method to disable NPN and
+   * protocol like HTTP/1.1 or SPDY/3. Call this method to disable NPN and
    * SPDY.
    */
   public void setNpnEnabled(boolean npnEnabled) {
     this.npnEnabled = npnEnabled;
   }
 
+  /**
+   * Indicates the protocols supported by NPN on incoming HTTPS connections.
+   * This list is ignored when npn is disabled.
+   *
+   * @param protocols the protocols to use, in order of preference. The list
+   *     must contain "http/1.1". It must not contain null.
+   */
+  public void setNpnProtocols(List<Protocol> protocols) {
+    protocols = Util.immutableList(protocols);
+    if (!protocols.contains(Protocol.HTTP_11)) {
+      throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
+    }
+    if (protocols.contains(null)) {
+      throw new IllegalArgumentException("protocols must not contain null");
+    }
+    this.npnProtocols = Util.immutableList(protocols);
+  }
+
   /**
    * Serve requests with HTTPS rather than otherwise.
    * @param tunnelProxy true to expect the HTTP CONNECT method before
@@ -232,13 +238,13 @@ public void play() throws IOException {
    */
   public void play(int port) throws IOException {
     if (executor != null) throw new IllegalStateException("play() already called");
-    executor = Executors.newCachedThreadPool();
+    executor = Executors.newCachedThreadPool(Util.threadFactory("MockWebServer", false));
     serverSocket = new ServerSocket(port);
     serverSocket.setReuseAddress(true);
 
     this.port = serverSocket.getLocalPort();
-    executor.execute(namedRunnable("MockWebServer-accept-" + port, new Runnable() {
-      public void run() {
+    executor.execute(new NamedRunnable("MockWebServer %s", port) {
+      @Override protected void execute() {
         try {
           acceptConnections();
         } catch (Throwable e) {
@@ -277,7 +283,7 @@ private void acceptConnections() throws Exception {
           }
         }
       }
-    }));
+    });
   }
 
   public void shutdown() throws IOException {
@@ -287,11 +293,10 @@ public void shutdown() throws IOException {
   }
 
   private void serveConnection(final Socket raw) {
-    String name = "MockWebServer-" + raw.getRemoteSocketAddress();
-    executor.execute(namedRunnable(name, new Runnable() {
+    executor.execute(new NamedRunnable("MockWebServer %s", raw.getRemoteSocketAddress()) {
       int sequenceNumber = 0;
 
-      public void run() {
+      @Override protected void execute() {
         try {
           processConnection();
         } catch (Exception e) {
@@ -300,7 +305,7 @@ public void run() {
       }
 
       public void processConnection() throws Exception {
-        Transport transport = Transport.HTTP_11;
+        Protocol protocol = Protocol.HTTP_11;
         Socket socket;
         if (sslSocketFactory != null) {
           if (tunnelProxy) {
@@ -319,39 +324,25 @@ public void processConnection() throws Exception {
           openClientSockets.put(socket, true);
 
           if (npnEnabled) {
-            Platform.get().setNpnProtocols(sslSocket, NPN_PROTOCOLS);
+            Platform.get().setNpnProtocols(sslSocket, npnProtocols);
           }
 
           sslSocket.startHandshake();
 
           if (npnEnabled) {
-            byte[] selectedProtocol = Platform.get().getNpnSelectedProtocol(sslSocket);
-            if (selectedProtocol == null || Arrays.equals(selectedProtocol, HTTP_11)) {
-              transport = Transport.HTTP_11;
-            } else if (Arrays.equals(selectedProtocol, HTTP_20_DRAFT_04)) {
-              transport = Transport.HTTP_20_DRAFT_04;
-            } else if (Arrays.equals(selectedProtocol, SPDY3)) {
-              transport = Transport.SPDY_3;
-            } else {
-              throw new IllegalStateException(
-                  "Unexpected transport: " + new String(selectedProtocol, Util.US_ASCII));
-            }
+            ByteString selectedProtocol = Platform.get().getNpnSelectedProtocol(sslSocket);
+            protocol = Protocol.find(selectedProtocol);
           }
           openClientSockets.remove(raw);
         } else {
           socket = raw;
         }
 
-        if (transport == Transport.SPDY_3 || transport == Transport.HTTP_20_DRAFT_04) {
-          SpdySocketHandler spdySocketHandler = new SpdySocketHandler(socket, transport);
-          SpdyConnection.Builder builder = new SpdyConnection.Builder(false, socket)
-              .handler(spdySocketHandler);
-          if (transport == Transport.SPDY_3) {
-            builder.spdy3();
-          } else {
-            builder.http20Draft04();
-          }
-          SpdyConnection spdyConnection = builder.build();
+        if (protocol.spdyVariant) {
+          SpdySocketHandler spdySocketHandler = new SpdySocketHandler(socket, protocol);
+          SpdyConnection spdyConnection = new SpdyConnection.Builder(false, socket)
+              .protocol(protocol)
+              .handler(spdySocketHandler).build();
           openSpdyConnections.put(spdyConnection, Boolean.TRUE);
           openClientSockets.remove(socket);
           spdyConnection.readConnectionHeader();
@@ -408,11 +399,13 @@ private boolean processOneRequest(Socket socket, InputStream in, OutputStream ou
         } else if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_OUTPUT_AT_END) {
           socket.shutdownOutput();
         }
-        logger.info("Received request: " + request + " and responded: " + response);
+        if (logger.isLoggable(Level.INFO)) {
+          logger.info("Received request: " + request + " and responded: " + response);
+        }
         sequenceNumber++;
         return true;
       }
-    }));
+    });
   }
 
   private void processHandshakeFailure(Socket raw) throws Exception {
@@ -506,7 +499,9 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
       if (hasBody) {
         throw new IllegalArgumentException("Request must not have a body: " + request);
       }
-    } else if (!request.startsWith("POST ") && !request.startsWith("PUT ")) {
+    } else if (!request.startsWith("POST ")
+        && !request.startsWith("PUT ")
+        && !request.startsWith("PATCH ")) {
       throw new UnsupportedOperationException("Unexpected method: " + request);
     }
 
@@ -516,7 +511,9 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
 
   private void writeResponse(OutputStream out, MockResponse response) throws IOException {
     out.write((response.getStatus() + "\r\n").getBytes(Util.US_ASCII));
-    for (String header : response.getHeaders()) {
+    List<String> headers = response.getHeaders();
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String header = headers.get(i);
       out.write((header + "\r\n").getBytes(Util.US_ASCII));
     }
     out.write(("\r\n").getBytes(Util.US_ASCII));
@@ -524,28 +521,25 @@ private void writeResponse(OutputStream out, MockResponse response) throws IOExc
 
     InputStream in = response.getBodyStream();
     if (in == null) return;
-    int bytesPerSecond = response.getBytesPerSecond();
-
-    // Stream data in MTU-sized increments, with a minimum of one packet per second.
-    byte[] buffer = bytesPerSecond >= 1452 ? new byte[1452] : new byte[bytesPerSecond];
-    long delayMs = bytesPerSecond == Integer.MAX_VALUE
-        ? 0
-        : (1000 * buffer.length) / bytesPerSecond;
-
-    int read;
-    long sinceDelay = 0;
-    while ((read = in.read(buffer)) != -1) {
-      out.write(buffer, 0, read);
-      out.flush();
 
-      sinceDelay += read;
-      if (sinceDelay >= buffer.length && delayMs > 0) {
-        sinceDelay %= buffer.length;
-        try {
-          Thread.sleep(delayMs);
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
+    // Stream data in MTU-sized increments, sleeping every bytesPerPeriod bytes.
+    byte[] buffer = new byte[1452];
+    while (true) {
+      int bytesPerPeriod = response.getThrottleBytesPerPeriod();
+      for (int b = 0; b < bytesPerPeriod; ) {
+        int read = in.read(buffer, 0, Math.min(buffer.length, bytesPerPeriod - b));
+        if (read == -1) return;
+
+        out.write(buffer, 0, read);
+        out.flush();
+        b += read;
+      }
+
+      try {
+        long delayMs = response.getThrottleUnit().toMillis(response.getThrottlePeriod());
+        if (delayMs != 0) Thread.sleep(delayMs);
+      } catch (InterruptedException e) {
+        throw new AssertionError();
       }
     }
   }
@@ -616,29 +610,15 @@ public void setDispatcher(Dispatcher dispatcher) {
     }
   }
 
-  private static Runnable namedRunnable(final String name, final Runnable runnable) {
-    return new Runnable() {
-      public void run() {
-        String originalName = Thread.currentThread().getName();
-        Thread.currentThread().setName(name);
-        try {
-          runnable.run();
-        } finally {
-          Thread.currentThread().setName(originalName);
-        }
-      }
-    };
-  }
-
   /** Processes HTTP requests layered over SPDY/3. */
   private class SpdySocketHandler implements IncomingStreamHandler {
     private final Socket socket;
-    private final Transport transport;
+    private final Protocol protocol;
     private final AtomicInteger sequenceNumber = new AtomicInteger();
 
-    private SpdySocketHandler(Socket socket, Transport transport) {
+    private SpdySocketHandler(Socket socket, Protocol protocol) {
       this.socket = socket;
-      this.transport = transport;
+      this.protocol = protocol;
     }
 
     @Override public void receive(SpdyStream stream) throws IOException {
@@ -651,27 +631,29 @@ private SpdySocketHandler(Socket socket, Transport transport) {
         throw new AssertionError(e);
       }
       writeResponse(stream, response);
-      logger.info("Received request: " + request + " and responded: " + response
-          + " transport is " + transport);
+      if (logger.isLoggable(Level.INFO)) {
+        logger.info("Received request: " + request + " and responded: " + response
+            + " protocol is " + protocol.name.utf8());
+      }
     }
 
     private RecordedRequest readRequest(SpdyStream stream) throws IOException {
-      List<String> spdyHeaders = stream.getRequestHeaders();
+      List<Header> spdyHeaders = stream.getRequestHeaders();
       List<String> httpHeaders = new ArrayList<String>();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
-      String version = "<:version omitted>";
-      for (Iterator<String> i = spdyHeaders.iterator(); i.hasNext(); ) {
-        String name = i.next();
-        String value = i.next();
-        if (":method".equals(name)) {
+      String version = protocol == Protocol.SPDY_3 ? "<:version omitted>" : "HTTP/1.1";
+      for (int i = 0, size = spdyHeaders.size(); i < size; i++) {
+        ByteString name = spdyHeaders.get(i).name;
+        String value = spdyHeaders.get(i).value.utf8();
+        if (name.equals(Header.TARGET_METHOD)) {
           method = value;
-        } else if (":path".equals(name)) {
+        } else if (name.equals(Header.TARGET_PATH)) {
           path = value;
-        } else if (":version".equals(name)) {
+        } else if (name.equals(Header.VERSION)) {
           version = value;
         } else {
-          httpHeaders.add(name + ": " + value);
+          httpHeaders.add(name.utf8() + ": " + value);
         }
       }
 
@@ -690,34 +672,41 @@ private RecordedRequest readRequest(SpdyStream stream) throws IOException {
     }
 
     private void writeResponse(SpdyStream stream, MockResponse response) throws IOException {
-      List<String> spdyHeaders = new ArrayList<String>();
+      if (response.getSocketPolicy() == SocketPolicy.NO_RESPONSE) {
+        return;
+      }
+      List<Header> spdyHeaders = new ArrayList<Header>();
       String[] statusParts = response.getStatus().split(" ", 2);
       if (statusParts.length != 2) {
         throw new AssertionError("Unexpected status: " + response.getStatus());
       }
-      spdyHeaders.add(":status");
-      spdyHeaders.add(statusParts[1]);
-      // TODO: no ":version" header for HTTP/2.0, only SPDY.
-      spdyHeaders.add(":version");
-      spdyHeaders.add(statusParts[0]);
-      for (String header : response.getHeaders()) {
+      // TODO: constants for well-known header names.
+      spdyHeaders.add(new Header(Header.RESPONSE_STATUS, statusParts[1]));
+      if (protocol == Protocol.SPDY_3) {
+        spdyHeaders.add(new Header(Header.VERSION, statusParts[0]));
+      }
+      List<String> headers = response.getHeaders();
+      for (int i = 0, size = headers.size(); i < size; i++) {
+        String header = headers.get(i);
         String[] headerParts = header.split(":", 2);
         if (headerParts.length != 2) {
           throw new AssertionError("Unexpected header: " + header);
         }
-        spdyHeaders.add(headerParts[0].toLowerCase(Locale.US).trim());
-        spdyHeaders.add(headerParts[1].trim());
+        spdyHeaders.add(new Header(headerParts[0], headerParts[1]));
       }
       byte[] body = response.getBody();
       stream.reply(spdyHeaders, body.length > 0);
       if (body.length > 0) {
+        if (response.getBodyDelayTimeMs() != 0) {
+          try {
+            Thread.sleep(response.getBodyDelayTimeMs());
+          } catch (InterruptedException e) {
+            throw new AssertionError(e);
+          }
+        }
         stream.getOutputStream().write(body);
         stream.getOutputStream().close();
       }
     }
   }
-
-  enum Transport {
-    HTTP_11, SPDY_3, HTTP_20_DRAFT_04
-  }
 }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
index aceacd1845..58b5d107c9 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
@@ -80,7 +80,8 @@ public String getPath() {
    */
   public String getHeader(String name) {
     name += ":";
-    for (String header : headers) {
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String header = headers.get(i);
       if (name.regionMatches(true, 0, header, 0, name.length())) {
         return header.substring(name.length()).trim();
       }
@@ -92,7 +93,8 @@ public String getHeader(String name) {
   public List<String> getHeaders(String name) {
     List<String> result = new ArrayList<String>();
     name += ":";
-    for (String header : headers) {
+    for (int i = 0, size = headers.size(); i < size; i++) {
+      String header = headers.get(i);
       if (name.regionMatches(true, 0, header, 0, name.length())) {
         result.add(header.substring(name.length()).trim());
       }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
index 7912f3a773..76701c4c92 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/SocketPolicy.java
@@ -57,5 +57,11 @@
    * Shutdown the socket output after sending the response. For testing bad
    * behavior.
    */
-  SHUTDOWN_OUTPUT_AT_END
+  SHUTDOWN_OUTPUT_AT_END,
+
+  /**
+   * Don't response to the request but keep the socket open. For testing
+   * read response header timeout issue.
+   */
+  NO_RESPONSE
 }
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
index 22e6a95916..7b7e1125cc 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
@@ -15,8 +15,6 @@
  */
 package com.squareup.okhttp.mockwebserver;
 
-import junit.framework.TestCase;
-
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.net.URL;
@@ -24,6 +22,7 @@
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
+import junit.framework.TestCase;
 
 public class CustomDispatcherTest extends TestCase {
 
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index f8fa6a4a2d..14eb349b8d 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
diff --git a/okhttp-protocols/pom.xml b/okhttp-protocols/pom.xml
index 0ecb915146..190af43cf3 100644
--- a/okhttp-protocols/pom.xml
+++ b/okhttp-protocols/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-protocols</artifactId>
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java
new file mode 100644
index 0000000000..1cdf23ccff
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.bytes.ByteString;
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Contains protocols that OkHttp supports
+ * <a href="http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04">NPN</a> or
+ * <a href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> selection.
+ *
+ * <p>
+ * <h3>Protocol vs Scheme</h3>
+ * Despite its name, {@link java.net.URL#getProtocol()} returns the
+ * {@link java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not
+ * the protocol (http/1.1, spdy/3.1, etc.).  OkHttp uses the word protocol to
+ * indicate how HTTP messages are framed.
+ */
+public enum Protocol {
+  HTTP_2("HTTP-draft-09/2.0", true),
+  SPDY_3("spdy/3.1", true),
+  HTTP_11("http/1.1", false);
+
+  public static final List<Protocol> HTTP2_SPDY3_AND_HTTP =
+      Util.immutableList(Arrays.asList(HTTP_2, SPDY_3, HTTP_11));
+  public static final List<Protocol> SPDY3_AND_HTTP11 =
+      Util.immutableList(Arrays.asList(SPDY_3, HTTP_11));
+  public static final List<Protocol> HTTP2_AND_HTTP_11 =
+      Util.immutableList(Arrays.asList(HTTP_2, HTTP_11));
+
+  /** Identifier string used in NPN or ALPN selection. */
+  public final ByteString name;
+
+  /**
+   * When true the protocol is binary framed and derived from SPDY.
+   *
+   * @see com.squareup.okhttp.internal.spdy.Variant
+   */
+  public final boolean spdyVariant;
+
+  Protocol(String name, boolean spdyVariant) {
+    this.name = ByteString.encodeUtf8(name);
+    this.spdyVariant = spdyVariant;
+  }
+
+  /**
+   * Returns the protocol matching {@code input} or {@link #HTTP_11} is on
+   * {@code null}. Throws an {@link IOException} when {@code input} doesn't
+   * match the {@link #name} of a supported protocol.
+   */
+  public static Protocol find(ByteString input) throws IOException {
+    if (input == null) return HTTP_11;
+    for (Protocol protocol : values()) {
+      if (protocol.name.equals(input)) return protocol;
+    }
+    throw new IOException("Unexpected protocol: " + input.utf8());
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Base64.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Base64.java
similarity index 100%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/Base64.java
rename to okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Base64.java
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java
new file mode 100644
index 0000000000..c83f1dd50d
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright 2014 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static java.lang.String.format;
+
+/** A simple bitset which supports left shifting. */
+public interface BitArray {
+
+  void clear();
+
+  void set(int index);
+
+  void toggle(int index);
+
+  boolean get(int index);
+
+  void shiftLeft(int count);
+
+  /** Bit set that only supports settings bits 0 - 63. */
+  public final class FixedCapacity implements BitArray {
+    long data = 0x0000000000000000L;
+
+    @Override public void clear() {
+      data = 0x0000000000000000L;
+    }
+
+    @Override public void set(int index) {
+      data |= (1L << checkInput(index));
+    }
+
+    @Override public void toggle(int index) {
+      data ^= (1L << checkInput(index));
+    }
+
+    @Override public boolean get(int index) {
+      return ((data >> checkInput(index)) & 1L) == 1;
+    }
+
+    @Override public void shiftLeft(int count) {
+      data = data << checkInput(count);
+    }
+
+    @Override public String toString() {
+      return Long.toBinaryString(data);
+    }
+
+    public BitArray toVariableCapacity() {
+      return new VariableCapacity(this);
+    }
+
+    private static int checkInput(int index) {
+      if (index < 0 || index > 63) {
+        throw new IllegalArgumentException(format("input must be between 0 and 63: %s", index));
+      }
+      return index;
+    }
+  }
+
+  /** Bit set that grows as needed. */
+  public final class VariableCapacity implements BitArray {
+
+    long[] data;
+
+    // Start offset which allows for cheap shifting. Data is always kept on 64-bit bounds but we
+    // offset the outward facing index to support shifts without having to move the underlying bits.
+    private int start; // Valid values are [0..63]
+
+    public VariableCapacity() {
+      data = new long[1];
+    }
+
+    private VariableCapacity(FixedCapacity small) {
+      data = new long[] {small.data, 0};
+    }
+
+    private void growToSize(int size) {
+      long[] newData = new long[size];
+      if (data != null) {
+        System.arraycopy(data, 0, newData, 0, data.length);
+      }
+      data = newData;
+    }
+
+    private int offsetOf(int index) {
+      index += start;
+      int offset = index / 64;
+      if (offset > data.length - 1) {
+        growToSize(offset + 1);
+      }
+      return offset;
+    }
+
+    private int shiftOf(int index) {
+      return (index + start) % 64;
+    }
+
+    @Override public void clear() {
+      Arrays.fill(data, 0);
+    }
+
+    @Override public void set(int index) {
+      checkInput(index);
+      int offset = offsetOf(index);
+      data[offset] |= 1L << shiftOf(index);
+    }
+
+    @Override public void toggle(int index) {
+      checkInput(index);
+      int offset = offsetOf(index);
+      data[offset] ^= 1L << shiftOf(index);
+    }
+
+    @Override public boolean get(int index) {
+      checkInput(index);
+      int offset = offsetOf(index);
+      return (data[offset] & (1L << shiftOf(index))) != 0;
+    }
+
+    @Override public void shiftLeft(int count) {
+      start -= checkInput(count);
+      if (start < 0) {
+        int arrayShift = (start / -64) + 1;
+        long[] newData = new long[data.length + arrayShift];
+        System.arraycopy(data, 0, newData, arrayShift, data.length);
+        data = newData;
+        start = 64 + (start % 64);
+      }
+    }
+
+    @Override public String toString() {
+      StringBuilder builder = new StringBuilder("{");
+      List<Integer> ints = toIntegerList();
+      for (int i = 0, count = ints.size(); i < count; i++) {
+        if (i > 0) {
+          builder.append(',');
+        }
+        builder.append(ints.get(i));
+      }
+      return builder.append('}').toString();
+    }
+
+    List<Integer> toIntegerList() {
+      List<Integer> ints = new ArrayList<Integer>();
+      for (int i = 0, count = data.length * 64 - start; i < count; i++) {
+        if (get(i)) {
+          ints.add(i);
+        }
+      }
+      return ints;
+    }
+
+    private static int checkInput(int index) {
+      if (index < 0) {
+        throw new IllegalArgumentException(format("input must be a positive number: %s", index));
+      }
+      return index;
+    }
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
index 905641a30a..ed4ba10e1c 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -16,16 +16,16 @@
  */
 package com.squareup.okhttp.internal;
 
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.IOException;
 import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.net.InetSocketAddress;
-import java.net.NetworkInterface;
 import java.net.Socket;
 import java.net.SocketException;
 import java.net.URI;
@@ -42,11 +42,25 @@
 /**
  * Access to Platform-specific features necessary for SPDY and advanced TLS.
  *
- * <h3>SPDY</h3>
- * SPDY requires a TLS extension called NPN (Next Protocol Negotiation) that's
- * available in Android 4.1+ and OpenJDK 7+ (with the npn-boot extension). It
- * also requires a recent version of {@code DeflaterOutputStream} that is
- * public API in Java 7 and callable via reflection in Android 4.1+.
+ * <h3>ALPN and NPN</h3>
+ * This class uses TLS extensions ALPN and NPN to negotiate the upgrade from
+ * HTTP/1.1 (the default protocol to use with TLS on port 443) to either SPDY
+ * or HTTP/2.
+ *
+ * <p>NPN (Next Protocol Negotiation) was developed for SPDY. It is widely
+ * available and we support it on both Android (4.1+) and OpenJDK 7 (via the
+ * Jetty NPN-boot library).
+ *
+ * <p>ALPN (Application Layer Protocol Negotiation) is the successor to NPN. It
+ * has some technical advantages over NPN. We support it on Android (4.4+) only.
+ *
+ * <p>On platforms that support both extensions, OkHttp will use both,
+ * preferring ALPN's result. Future versions of OkHttp will drop support NPN.
+ *
+ * <h3>Deflater Sync Flush</h3>
+ * SPDY header compression requires a recent version of {@code
+ * DeflaterOutputStream} that is public API in Java 7 and callable via
+ * reflection in Android 4.1+.
  */
 public class Platform {
   private static final Platform PLATFORM = findPlatform();
@@ -93,7 +107,7 @@ public void supportTlsIntolerantServer(SSLSocket socket) {
   }
 
   /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  public byte[] getNpnSelectedProtocol(SSLSocket socket) {
+  public ByteString getNpnSelectedProtocol(SSLSocket socket) {
     return null;
   }
 
@@ -101,7 +115,7 @@ public void supportTlsIntolerantServer(SSLSocket socket) {
    * Sets client-supported protocols on a socket to send to a server. The
    * protocols are only sent if the socket implementation supports NPN.
    */
-  public void setNpnProtocols(SSLSocket socket, byte[] npnProtocols) {
+  public void setNpnProtocols(SSLSocket socket, List<Protocol> npnProtocols) {
   }
 
   public void connectSocket(Socket socket, InetSocketAddress address,
@@ -135,27 +149,8 @@ public OutputStream newDeflaterOutputStream(OutputStream out, Deflater deflater,
     }
   }
 
-  /**
-   * Returns the maximum transmission unit of the network interface used by
-   * {@code socket}, or a reasonable default if this platform doesn't expose the
-   * MTU to the application layer.
-   *
-   * <p>The returned value should only be used as an optimization; such as to
-   * size buffers efficiently.
-   */
-  public int getMtu(Socket socket) throws IOException {
-    return 1400; // Smaller than 1500 to leave room for headers on interfaces like PPPoE.
-  }
-
   /** Attempt to match the host runtime to a capable Platform implementation. */
   private static Platform findPlatform() {
-    Method getMtu;
-    try {
-      getMtu = NetworkInterface.class.getMethod("getMTU");
-    } catch (NoSuchMethodException e) {
-      return new Platform(); // No Java 1.6 APIs. It's either Java 1.5, Android 2.2 or earlier.
-    }
-
     // Attempt to find Android 2.3+ APIs.
     Class<?> openSslSocketClass;
     Method setUseSessionTickets;
@@ -173,14 +168,23 @@ private static Platform findPlatform() {
       setHostname = openSslSocketClass.getMethod("setHostname", String.class);
 
       // Attempt to find Android 4.1+ APIs.
+      Method setNpnProtocols = null;
+      Method getNpnSelectedProtocol = null;
+      Method setAlpnProtocols = null;
+      Method getAlpnSelectedProtocol = null;
       try {
-        Method setNpnProtocols = openSslSocketClass.getMethod("setNpnProtocols", byte[].class);
-        Method getNpnSelectedProtocol = openSslSocketClass.getMethod("getNpnSelectedProtocol");
-        return new Android41(getMtu, openSslSocketClass, setUseSessionTickets, setHostname,
-            setNpnProtocols, getNpnSelectedProtocol);
+        setNpnProtocols = openSslSocketClass.getMethod("setNpnProtocols", byte[].class);
+        getNpnSelectedProtocol = openSslSocketClass.getMethod("getNpnSelectedProtocol");
+        try {
+          setAlpnProtocols = openSslSocketClass.getMethod("setAlpnProtocols", byte[].class);
+          getAlpnSelectedProtocol = openSslSocketClass.getMethod("getAlpnSelectedProtocol");
+        } catch (NoSuchMethodException ignored) {
+        }
       } catch (NoSuchMethodException ignored) {
-        return new Android23(getMtu, openSslSocketClass, setUseSessionTickets, setHostname);
       }
+
+      return new Android(openSslSocketClass, setUseSessionTickets, setHostname, setNpnProtocols,
+          getNpnSelectedProtocol, setAlpnProtocols, getAlpnSelectedProtocol);
     } catch (ClassNotFoundException ignored) {
       // This isn't an Android runtime.
     } catch (NoSuchMethodException ignored) {
@@ -196,59 +200,46 @@ private static Platform findPlatform() {
       Class<?> serverProviderClass = Class.forName(npnClassName + "$ServerProvider");
       Method putMethod = nextProtoNegoClass.getMethod("put", SSLSocket.class, providerClass);
       Method getMethod = nextProtoNegoClass.getMethod("get", SSLSocket.class);
-      return new JdkWithJettyNpnPlatform(getMtu, putMethod, getMethod, clientProviderClass,
-          serverProviderClass);
+      return new JdkWithJettyNpnPlatform(
+          putMethod, getMethod, clientProviderClass, serverProviderClass);
     } catch (ClassNotFoundException ignored) {
       // NPN isn't on the classpath.
     } catch (NoSuchMethodException ignored) {
       // The NPN version isn't what we expect.
     }
 
-    return new Java6(getMtu);
+    return new Platform();
   }
 
-  private static class Java6 extends Platform {
-    private final Method getMtu;
-
-    private Java6(Method getMtu) {
-      this.getMtu = getMtu;
-    }
-
-    @Override public int getMtu(Socket socket) throws IOException {
-      try {
-        NetworkInterface networkInterface = NetworkInterface.getByInetAddress(
-            socket.getLocalAddress());
-        if (networkInterface == null) {
-          return super.getMtu(socket); // There's no longer an interface with this local address.
-        }
-        return (Integer) getMtu.invoke(networkInterface);
-      } catch (NullPointerException e) {
-        // Certain Alcatel devices throw on getByInetAddress. Return default.
-        return super.getMtu(socket);
-      } catch (SocketException e) {
-        // Certain Motorola devices always throw on getByInetAddress. Return the default for those.
-        return super.getMtu(socket);
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      } catch (InvocationTargetException e) {
-        if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
-        throw new RuntimeException(e.getCause());
-      }
-    }
-  }
-
-  /** Android version 2.3 and newer support TLS session tickets and server name indication (SNI). */
-  private static class Android23 extends Java6 {
+  /**
+   * Android 2.3 or better. Version 2.3 supports TLS session tickets and server
+   * name indication (SNI). Versions 4.1 supports NPN.
+   */
+  private static class Android extends Platform {
+    // Non-null.
     protected final Class<?> openSslSocketClass;
     private final Method setUseSessionTickets;
     private final Method setHostname;
 
-    private Android23(Method getMtu, Class<?> openSslSocketClass, Method setUseSessionTickets,
-        Method setHostname) {
-      super(getMtu);
+    // Non-null on Android 4.1+.
+    private final Method setNpnProtocols;
+    private final Method getNpnSelectedProtocol;
+
+    // Non-null on Android 4.4+.
+    private final Method setAlpnProtocols;
+    private final Method getAlpnSelectedProtocol;
+
+    private Android(
+        Class<?> openSslSocketClass, Method setUseSessionTickets, Method setHostname,
+        Method setNpnProtocols, Method getNpnSelectedProtocol, Method setAlpnProtocols,
+        Method getAlpnSelectedProtocol) {
       this.openSslSocketClass = openSslSocketClass;
       this.setUseSessionTickets = setUseSessionTickets;
       this.setHostname = setHostname;
+      this.setNpnProtocols = setNpnProtocols;
+      this.getNpnSelectedProtocol = getNpnSelectedProtocol;
+      this.setAlpnProtocols = setAlpnProtocols;
+      this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
     }
 
     @Override public void connectSocket(Socket socket, InetSocketAddress address,
@@ -266,38 +257,26 @@ private Android23(Method getMtu, Class<?> openSslSocketClass, Method setUseSessi
 
     @Override public void enableTlsExtensions(SSLSocket socket, String uriHost) {
       super.enableTlsExtensions(socket, uriHost);
-      if (openSslSocketClass.isInstance(socket)) {
-        // This is Android: use reflection on OpenSslSocketImpl.
-        try {
-          setUseSessionTickets.invoke(socket, true);
-          setHostname.invoke(socket, uriHost);
-        } catch (InvocationTargetException e) {
-          throw new RuntimeException(e);
-        } catch (IllegalAccessException e) {
-          throw new AssertionError(e);
-        }
+      if (!openSslSocketClass.isInstance(socket)) return;
+      try {
+        setUseSessionTickets.invoke(socket, true);
+        setHostname.invoke(socket, uriHost);
+      } catch (InvocationTargetException e) {
+        throw new RuntimeException(e);
+      } catch (IllegalAccessException e) {
+        throw new AssertionError(e);
       }
     }
-  }
-
-  /** Android version 4.1 and newer support NPN. */
-  private static class Android41 extends Android23 {
-    private final Method setNpnProtocols;
-    private final Method getNpnSelectedProtocol;
 
-    private Android41(Method getMtu, Class<?> openSslSocketClass, Method setUseSessionTickets,
-        Method setHostname, Method setNpnProtocols, Method getNpnSelectedProtocol) {
-      super(getMtu, openSslSocketClass, setUseSessionTickets, setHostname);
-      this.setNpnProtocols = setNpnProtocols;
-      this.getNpnSelectedProtocol = getNpnSelectedProtocol;
-    }
-
-    @Override public void setNpnProtocols(SSLSocket socket, byte[] npnProtocols) {
-      if (!openSslSocketClass.isInstance(socket)) {
-        return;
-      }
+    @Override public void setNpnProtocols(SSLSocket socket, List<Protocol> npnProtocols) {
+      if (setNpnProtocols == null) return;
+      if (!openSslSocketClass.isInstance(socket)) return;
       try {
-        setNpnProtocols.invoke(socket, new Object[] {npnProtocols});
+        Object[] parameters = { concatLengthPrefixed(npnProtocols) };
+        if (setAlpnProtocols != null) {
+          setAlpnProtocols.invoke(socket, parameters);
+        }
+        setNpnProtocols.invoke(socket, parameters);
       } catch (IllegalAccessException e) {
         throw new AssertionError(e);
       } catch (InvocationTargetException e) {
@@ -305,12 +284,18 @@ private Android41(Method getMtu, Class<?> openSslSocketClass, Method setUseSessi
       }
     }
 
-    @Override public byte[] getNpnSelectedProtocol(SSLSocket socket) {
-      if (!openSslSocketClass.isInstance(socket)) {
-        return null;
-      }
+    @Override public ByteString getNpnSelectedProtocol(SSLSocket socket) {
+      if (getNpnSelectedProtocol == null) return null;
+      if (!openSslSocketClass.isInstance(socket)) return null;
       try {
-        return (byte[]) getNpnSelectedProtocol.invoke(socket);
+        if (getAlpnSelectedProtocol != null) {
+          // Prefer ALPN's result if it is present.
+          byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invoke(socket);
+          if (alpnResult != null) return ByteString.of(alpnResult);
+        }
+        byte[] npnResult = (byte[]) getNpnSelectedProtocol.invoke(socket);
+        if (npnResult == null) return null;
+        return ByteString.of(npnResult);
       } catch (InvocationTargetException e) {
         throw new RuntimeException(e);
       } catch (IllegalAccessException e) {
@@ -320,35 +305,29 @@ private Android41(Method getMtu, Class<?> openSslSocketClass, Method setUseSessi
   }
 
   /** OpenJDK 7 plus {@code org.mortbay.jetty.npn/npn-boot} on the boot class path. */
-  private static class JdkWithJettyNpnPlatform extends Java6 {
+  private static class JdkWithJettyNpnPlatform extends Platform {
     private final Method getMethod;
     private final Method putMethod;
     private final Class<?> clientProviderClass;
     private final Class<?> serverProviderClass;
 
-    public JdkWithJettyNpnPlatform(Method getMtu, Method putMethod, Method getMethod,
-        Class<?> clientProviderClass, Class<?> serverProviderClass) {
-      super(getMtu);
+    public JdkWithJettyNpnPlatform(Method putMethod, Method getMethod, Class<?> clientProviderClass,
+        Class<?> serverProviderClass) {
       this.putMethod = putMethod;
       this.getMethod = getMethod;
       this.clientProviderClass = clientProviderClass;
       this.serverProviderClass = serverProviderClass;
     }
 
-    @Override public void setNpnProtocols(SSLSocket socket, byte[] npnProtocols) {
+    @Override public void setNpnProtocols(SSLSocket socket, List<Protocol> npnProtocols) {
       try {
-        List<String> strings = new ArrayList<String>();
-        for (int i = 0; i < npnProtocols.length; ) {
-          int length = npnProtocols[i++];
-          strings.add(new String(npnProtocols, i, length, "US-ASCII"));
-          i += length;
+        List<String> names = new ArrayList<String>(npnProtocols.size());
+        for (int i = 0, size = npnProtocols.size(); i < size; i++) {
+          names.add(npnProtocols.get(i).name.utf8());
         }
         Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
-            new Class[] {clientProviderClass, serverProviderClass},
-            new JettyNpnProvider(strings));
+            new Class[] { clientProviderClass, serverProviderClass }, new JettyNpnProvider(names));
         putMethod.invoke(null, socket, provider);
-      } catch (UnsupportedEncodingException e) {
-        throw new AssertionError(e);
       } catch (InvocationTargetException e) {
         throw new AssertionError(e);
       } catch (IllegalAccessException e) {
@@ -356,19 +335,17 @@ public JdkWithJettyNpnPlatform(Method getMtu, Method putMethod, Method getMethod
       }
     }
 
-    @Override public byte[] getNpnSelectedProtocol(SSLSocket socket) {
+    @Override public ByteString getNpnSelectedProtocol(SSLSocket socket) {
       try {
         JettyNpnProvider provider =
             (JettyNpnProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
         if (!provider.unsupported && provider.selected == null) {
           Logger logger = Logger.getLogger("com.squareup.okhttp.OkHttpClient");
           logger.log(Level.INFO,
-              "NPN callback dropped so SPDY is disabled. " + "Is npn-boot on the boot class path?");
+              "NPN callback dropped so SPDY is disabled. Is npn-boot on the boot class path?");
           return null;
         }
-        return provider.unsupported ? null : provider.selected.getBytes("US-ASCII");
-      } catch (UnsupportedEncodingException e) {
-        throw new AssertionError();
+        return provider.unsupported ? null : ByteString.encodeUtf8(provider.selected);
       } catch (InvocationTargetException e) {
         throw new AssertionError();
       } catch (IllegalAccessException e) {
@@ -382,8 +359,11 @@ public JdkWithJettyNpnPlatform(Method getMtu, Method putMethod, Method getMethod
    * without a compile-time dependency on those interfaces.
    */
   private static class JettyNpnProvider implements InvocationHandler {
+    /** This peer's supported protocols. */
     private final List<String> protocols;
+    /** Set when remote peer notifies NPN is unsupported. */
     private boolean unsupported;
+    /** The protocol the client selected. */
     private String selected;
 
     public JettyNpnProvider(List<String> protocols) {
@@ -397,26 +377,53 @@ public JettyNpnProvider(List<String> protocols) {
         args = Util.EMPTY_STRING_ARRAY;
       }
       if (methodName.equals("supports") && boolean.class == returnType) {
-        return true;
+        return true; // Client supports NPN.
       } else if (methodName.equals("unsupported") && void.class == returnType) {
-        this.unsupported = true;
+        this.unsupported = true; // Remote peer doesn't support NPN.
         return null;
       } else if (methodName.equals("protocols") && args.length == 0) {
-        return protocols;
-      } else if (methodName.equals("selectProtocol")
+        return protocols; // Server advertises these protocols.
+      } else if (methodName.equals("selectProtocol") // Called when client.
           && String.class == returnType
           && args.length == 1
           && (args[0] == null || args[0] instanceof List)) {
-        // TODO: use OpenSSL's algorithm which uses both lists
-        List<?> serverProtocols = (List) args[0];
-        this.selected = protocols.get(0);
-        return selected;
+        List<String> serverProtocols = (List) args[0];
+        // Pick the first protocol the server advertises and client knows.
+        for (int i = 0, size = serverProtocols.size(); i < size; i++) {
+          if (protocols.contains(serverProtocols.get(i))) {
+            return selected = serverProtocols.get(i);
+          }
+        }
+        // On no intersection, try client's first protocol.
+        return selected = protocols.get(0);
       } else if (methodName.equals("protocolSelected") && args.length == 1) {
-        this.selected = (String) args[0];
+        this.selected = (String) args[0]; // Client selected this protocol.
         return null;
       } else {
         return method.invoke(this, args);
       }
     }
   }
+
+  /**
+   * Concatenation of 8-bit, length prefixed protocol names.
+   *
+   * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
+   */
+  static byte[] concatLengthPrefixed(List<Protocol> protocols) {
+    int size = 0;
+    for (Protocol protocol : protocols) {
+      size += protocol.name.size() + 1; // add a byte for 8-bit length prefix.
+    }
+    byte[] result = new byte[size];
+    int pos = 0;
+    for (Protocol protocol : protocols) {
+      int nameSize = protocol.name.size();
+      result[pos++] = (byte) nameSize;
+      // toByteArray allocates an array, but this is only called on new connections.
+      System.arraycopy(protocol.name.toByteArray(), 0, result, pos, nameSize);
+      pos += nameSize;
+    }
+    return result;
+  }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
index 29c6c255f0..e609db9528 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -16,6 +16,8 @@
 
 package com.squareup.okhttp.internal;
 
+import com.squareup.okhttp.internal.spdy.Header;
+import java.io.ByteArrayInputStream;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.File;
@@ -25,26 +27,28 @@
 import java.io.Reader;
 import java.io.StringWriter;
 import java.io.UnsupportedEncodingException;
+import java.net.ServerSocket;
 import java.net.Socket;
+import java.net.SocketTimeoutException;
 import java.net.URI;
 import java.net.URL;
-import java.nio.ByteOrder;
 import java.nio.charset.Charset;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.atomic.AtomicReference;
 
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+
 /** Junk drawer of utility methods. */
 public final class Util {
   public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
   public static final String[] EMPTY_STRING_ARRAY = new String[0];
-
-  /** A cheap and type-safe constant for the ISO-8859-1 Charset. */
-  public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
+  public static final InputStream EMPTY_INPUT_STREAM = new ByteArrayInputStream(EMPTY_BYTE_ARRAY);
 
   /** A cheap and type-safe constant for the US-ASCII Charset. */
   public static final Charset US_ASCII = Charset.forName("US-ASCII");
@@ -71,36 +75,18 @@ private static int getEffectivePort(String scheme, int specifiedPort) {
     return specifiedPort != -1 ? specifiedPort : getDefaultPort(scheme);
   }
 
-  public static int getDefaultPort(String scheme) {
-    if ("http".equalsIgnoreCase(scheme)) {
-      return 80;
-    } else if ("https".equalsIgnoreCase(scheme)) {
-      return 443;
-    } else {
-      return -1;
-    }
+  public static int getDefaultPort(String protocol) {
+    if ("http".equals(protocol)) return 80;
+    if ("https".equals(protocol)) return 443;
+    return -1;
   }
 
-  public static void checkOffsetAndCount(int arrayLength, int offset, int count) {
+  public static void checkOffsetAndCount(long arrayLength, long offset, long count) {
     if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
       throw new ArrayIndexOutOfBoundsException();
     }
   }
 
-  public static void pokeInt(byte[] dst, int offset, int value, ByteOrder order) {
-    if (order == ByteOrder.BIG_ENDIAN) {
-      dst[offset++] = (byte) ((value >> 24) & 0xff);
-      dst[offset++] = (byte) ((value >> 16) & 0xff);
-      dst[offset++] = (byte) ((value >> 8) & 0xff);
-      dst[offset] = (byte) ((value >> 0) & 0xff);
-    } else {
-      dst[offset++] = (byte) ((value >> 0) & 0xff);
-      dst[offset++] = (byte) ((value >> 8) & 0xff);
-      dst[offset++] = (byte) ((value >> 16) & 0xff);
-      dst[offset] = (byte) ((value >> 24) & 0xff);
-    }
-  }
-
   /** Returns true if two possibly-null objects are equal. */
   public static boolean equal(Object a, Object b) {
     return a == b || (a != null && a.equals(b));
@@ -136,6 +122,21 @@ public static void closeQuietly(Socket socket) {
     }
   }
 
+  /**
+   * Closes {@code serverSocket}, ignoring any checked exceptions. Does nothing if
+   * {@code serverSocket} is null.
+   */
+  public static void closeQuietly(ServerSocket serverSocket) {
+    if (serverSocket != null) {
+      try {
+        serverSocket.close();
+      } catch (RuntimeException rethrown) {
+        throw rethrown;
+      } catch (Exception ignored) {
+      }
+    }
+  }
+
   /**
    * Closes {@code a} and {@code b}. If either close fails, this completes
    * the other close and rethrows the first encountered exception.
@@ -250,12 +251,6 @@ public static String readFully(Reader reader) throws IOException {
     }
   }
 
-  public static void skipAll(InputStream in) throws IOException {
-    do {
-      in.skip(Long.MAX_VALUE);
-    } while (in.read() != -1);
-  }
-
   /**
    * Call {@code in.read()} repeatedly until either the stream is exhausted or
    * {@code byteCount} bytes have been read.
@@ -266,9 +261,16 @@ public static void skipAll(InputStream in) throws IOException {
    * other threads. A thread-local buffer is also insufficient because some
    * streams may call other streams in their skip() method, also clobbering the
    * buffer.
+   *
+   * <p>This method throws a SocketTimeoutException if {@code timeoutMillis}
+   * elapses before the bytes can be skipped.
+   *
+   * @param timeoutMillis the maximum time to wait, or 0 to wait indefinitely.
    */
-  public static long skipByReading(InputStream in, long byteCount) throws IOException {
+  public static long skipByReading(InputStream in, long byteCount, long timeoutMillis)
+      throws IOException {
     if (byteCount == 0) return 0L;
+    long startNanos = timeoutMillis != 0 ? System.nanoTime() : 0;
 
     // acquire the shared skip buffer.
     byte[] buffer = skipBuffer.getAndSet(null);
@@ -280,12 +282,11 @@ public static long skipByReading(InputStream in, long byteCount) throws IOExcept
     while (skipped < byteCount) {
       int toRead = (int) Math.min(byteCount - skipped, buffer.length);
       int read = in.read(buffer, 0, toRead);
-      if (read == -1) {
-        break;
-      }
+      if (read == -1) break;
       skipped += read;
-      if (read < toRead) {
-        break;
+      if (timeoutMillis != 0
+          && NANOSECONDS.toMillis(System.nanoTime() - startNanos) > timeoutMillis) {
+        throw new SocketTimeoutException("Timed out after reading " + skipped + " of " + byteCount);
       }
     }
 
@@ -295,6 +296,10 @@ public static long skipByReading(InputStream in, long byteCount) throws IOExcept
     return skipped;
   }
 
+  public static long skipByReading(InputStream in, long byteCount) throws IOException {
+    return skipByReading(in, byteCount, 0);
+  }
+
   /**
    * Copies all of the bytes from {@code in} to {@code out}. Neither stream is closed.
    * Returns the total number of bytes transferred.
@@ -366,13 +371,37 @@ private static String bytesToHexString(byte[] bytes) {
     return Collections.unmodifiableList(new ArrayList<T>(list));
   }
 
-  public static ThreadFactory daemonThreadFactory(final String name) {
+  /** Returns an immutable list containing {@code elements}. */
+  public static <T> List<T> immutableList(T[] elements) {
+    return Collections.unmodifiableList(Arrays.asList(elements.clone()));
+  }
+
+  public static ThreadFactory threadFactory(final String name, final boolean daemon) {
     return new ThreadFactory() {
       @Override public Thread newThread(Runnable runnable) {
         Thread result = new Thread(runnable, name);
-        result.setDaemon(true);
+        result.setDaemon(daemon);
         return result;
       }
     };
   }
+
+  public static List<Header> headerEntries(String... elements) {
+    List<Header> result = new ArrayList<Header>(elements.length / 2);
+    for (int i = 0; i < elements.length; i += 2) {
+      result.add(new Header(elements[i], elements[i + 1]));
+    }
+    return result;
+  }
+
+  /** Mutates the byte array to ensure all characters are lowercase. */
+  public static void asciiLowerCase(byte[] bytes) {
+    for (int i = 0; i < bytes.length; i++) {
+      bytes[i] = asciiLowerCase(bytes[i]);
+    }
+  }
+
+  public static byte asciiLowerCase(byte c) {
+    return 'A' <= c && c <= 'Z' ? (byte) (c + 'a' - 'A') : c;
+  }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/ByteString.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/ByteString.java
new file mode 100644
index 0000000000..9a6a799edc
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/ByteString.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2014 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Arrays;
+
+import static com.squareup.okhttp.internal.Util.asciiLowerCase;
+
+/**
+ * An immutable sequence of bytes.
+ *
+ * <p><strong>Full disclosure:</strong> this class provides untrusted input and
+ * output streams with raw access to the underlying byte array. A hostile
+ * stream implementation could keep a reference to the mutable byte string,
+ * violating the immutable guarantee of this class. For this reason a byte
+ * string's immutability guarantee cannot be relied upon for security in applets
+ * and other environments that run both trusted and untrusted code in the same
+ * process.
+ */
+public final class ByteString {
+  final byte[] data;
+  private transient int hashCode; // Lazily computed; 0 if unknown.
+  private transient String utf8; // Lazily computed.
+
+  /** A singleton empty {@code ByteString}. */
+  public static final ByteString EMPTY = new ByteString(Util.EMPTY_BYTE_ARRAY);
+
+  /**
+   * Returns a new byte string containing a clone of the bytes of {@code data}.
+   */
+  public static ByteString of(byte... data) {
+    return new ByteString(data.clone());
+  }
+
+  /** Returns a new byte string containing the {@code UTF-8} bytes of {@code s}. */
+  public static ByteString encodeUtf8(String s) {
+    ByteString byteString = new ByteString(s.getBytes(Util.UTF_8));
+    byteString.utf8 = s;
+    return byteString;
+  }
+
+  /** Constructs a new {@code String} by decoding the bytes as {@code UTF-8}. */
+  public String utf8() {
+    String result = utf8;
+    // We don't care if we double-allocate in racy code.
+    return result != null ? result : (utf8 = new String(data, Util.UTF_8));
+  }
+
+  /**
+   * Returns true when {@code ascii} is not null and equals the bytes wrapped
+   * by this byte string.
+   */
+  public boolean equalsAscii(String ascii) {
+    if (ascii == null || data.length != ascii.length()) {
+      return false;
+    }
+    if (ascii == this.utf8) { // not using String.equals to avoid looping twice.
+      return true;
+    }
+    for (int i = 0; i < data.length; i++) {
+      if (data[i] != ascii.charAt(i)) return false;
+    }
+    return true;
+  }
+
+  /**
+   * Reads {@code count} bytes from {@code in} and returns the result.
+   *
+   * @throws java.io.EOFException if {@code in} has fewer than {@code count}
+   * bytes to read.
+   */
+  public static ByteString read(InputStream in, int count) throws IOException {
+    byte[] result = new byte[count];
+    Util.readFully(in, result);
+    return new ByteString(result);
+  }
+
+  /**
+   * Reads {@code count} bytes from {@code in} and returns the result converted
+   * to ASCII lowercase.
+   *
+   * @throws java.io.EOFException if {@code in} has fewer than {@code count}
+   * bytes to read.
+   */
+  public static ByteString readLowerCase(InputStream in, int count) throws IOException {
+    byte[] result = new byte[count];
+    Util.readFully(in, result);
+    asciiLowerCase(result);
+    return new ByteString(result);
+  }
+
+  public static ByteString concat(ByteString... byteStrings) {
+    int size = 0;
+    for (ByteString byteString : byteStrings) {
+      size += byteString.size();
+    }
+    byte[] result = new byte[size];
+    int pos = 0;
+    for (ByteString byteString : byteStrings) {
+      System.arraycopy(byteString.data, 0, result, pos, byteString.size());
+      pos += byteString.size();
+    }
+    return new ByteString(result);
+  }
+
+  ByteString(byte[] data) {
+    this.data = data; // Trusted internal constructor doesn't clone data.
+  }
+
+  /**
+   * Returns the number of bytes in this ByteString.
+   */
+  public int size() {
+    return data.length;
+  }
+
+  /**
+   * Returns a byte array containing a copy of the bytes in this {@code ByteString}.
+   */
+  public byte[] toByteArray() {
+    return data.clone();
+  }
+
+  /** Writes the contents of this byte string to {@code out}. */
+  public void write(OutputStream out) throws IOException {
+    out.write(data);
+  }
+
+  @Override public boolean equals(Object o) {
+    return o == this || o instanceof ByteString && Arrays.equals(((ByteString) o).data, data);
+  }
+
+  @Override public int hashCode() {
+    int result = hashCode;
+    return result != 0 ? result : (hashCode = Arrays.hashCode(data));
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Deadline.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Deadline.java
new file mode 100644
index 0000000000..88188433dd
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Deadline.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * The time that a requested operation is due. If the deadline is reached before
+ * the operation has completed, the operation should be aborted.
+ */
+public class Deadline {
+  public static final Deadline NONE = new Deadline() {
+    @Override public Deadline start(long timeout, TimeUnit unit) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean reached() {
+      return false;
+    }
+  };
+
+  private long deadlineNanos;
+
+  public Deadline() {
+  }
+
+  public Deadline start(long timeout, TimeUnit unit) {
+    deadlineNanos = System.nanoTime() + unit.toNanos(timeout);
+    return this;
+  }
+
+  public boolean reached() {
+    return System.nanoTime() - deadlineNanos >= 0; // Subtract to avoid overflow!
+  }
+
+  public void throwIfReached() throws IOException {
+    // TODO: a more catchable exception type?
+    if (reached()) throw new IOException("Deadline reached");
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/InflaterSource.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/InflaterSource.java
new file mode 100644
index 0000000000..3a11d115db
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/InflaterSource.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.zip.DataFormatException;
+import java.util.zip.Inflater;
+
+/** A source that inflates another source. */
+public final class InflaterSource implements Source {
+  private final Source source;
+  private final Inflater inflater;
+  private final OkBuffer buffer = new OkBuffer();
+
+  /**
+   * When we call Inflater.setInput(), the inflater keeps our byte array until
+   * it needs input again. This tracks how many bytes the inflater is currently
+   * holding on to.
+   */
+  private int bufferBytesHeldByInflater;
+  private boolean closed;
+
+  public InflaterSource(Source source, Inflater inflater) {
+    if (source == null) throw new IllegalArgumentException("source == null");
+    if (inflater == null) throw new IllegalArgumentException("inflater == null");
+    this.source = source;
+    this.inflater = inflater;
+  }
+
+  @Override public long read(
+      OkBuffer sink, long byteCount, Deadline deadline) throws IOException {
+    if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+    if (closed) throw new IllegalStateException("closed");
+    if (byteCount == 0) return 0;
+
+    while (true) {
+      boolean sourceExhausted = false;
+      if (inflater.needsInput()) {
+        // Release buffer bytes from the inflater.
+        if (bufferBytesHeldByInflater > 0) {
+          Segment head = buffer.head;
+          head.pos += bufferBytesHeldByInflater;
+          buffer.byteCount -= bufferBytesHeldByInflater;
+          if (head.pos == head.limit) {
+            buffer.head = head.pop();
+            SegmentPool.INSTANCE.recycle(head);
+          }
+        }
+
+        // Refill the buffer with compressed data from the source.
+        if (buffer.byteCount == 0) {
+          sourceExhausted = source.read(buffer, Segment.SIZE, deadline) == -1;
+        }
+
+        // Acquire buffer bytes for the inflater.
+        if (buffer.byteCount > 0) {
+          Segment head = buffer.head;
+          bufferBytesHeldByInflater = head.limit - head.pos;
+          inflater.setInput(head.data, head.pos, bufferBytesHeldByInflater);
+        }
+      }
+
+      // Decompress the inflater's compressed data into the sink.
+      try {
+        Segment tail = sink.writableSegment(1);
+        int bytesInflated = inflater.inflate(tail.data, tail.limit, Segment.SIZE - tail.limit);
+        if (bytesInflated > 0) {
+          tail.limit += bytesInflated;
+          sink.byteCount += bytesInflated;
+          return bytesInflated;
+        }
+        if (inflater.finished() || inflater.needsDictionary()) return -1;
+        if (sourceExhausted) throw new EOFException("source exhausted prematurely");
+      } catch (DataFormatException e) {
+        throw new IOException(e);
+      }
+    }
+  }
+
+  @Override public void close(Deadline deadline) throws IOException {
+    if (closed) return;
+    inflater.end();
+    closed = true;
+    source.close(deadline);
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
new file mode 100644
index 0000000000..7fd538c92a
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffer.java
@@ -0,0 +1,403 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
+
+/**
+ * A collection of bytes in memory.
+ *
+ * <p><strong>Moving data from one OkBuffer to another is fast.</strong> Instead
+ * of copying bytes from one place in memory to another, this class just changes
+ * ownership of the underlying bytes.
+ *
+ * <p><strong>This buffer grows with your data.</strong> Just like ArrayList,
+ * each OkBuffer starts small. It consumes only the memory it needs to.
+ *
+ * <p><strong>This buffer pools its byte arrays.</strong> When you allocate a
+ * byte array in Java, the runtime must zero-fill the requested array before
+ * returning it to you. Even if you're going to write over that space anyway.
+ * This class avoids zero-fill and GC churn by pooling byte arrays.
+ */
+public final class OkBuffer implements Source, Sink {
+  private static final char[] HEX_DIGITS =
+      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
+
+  Segment head;
+  long byteCount;
+
+  public OkBuffer() {
+  }
+
+  /** Returns the number of bytes currently in this buffer. */
+  public long byteCount() {
+    return byteCount;
+  }
+
+  /** Reads a byte from the front of this buffer and returns it. */
+  public byte readByte() {
+    if (byteCount < 1) throw new IllegalArgumentException("byteCount < 1: " + byteCount);
+
+    Segment segment = head;
+    int pos = segment.pos;
+    int limit = segment.limit;
+
+    byte[] data = segment.data;
+    byte b = data[pos++];
+    byteCount -= 1;
+
+    if (pos == limit) {
+      head = segment.pop();
+      SegmentPool.INSTANCE.recycle(segment);
+    } else {
+      segment.pos = pos;
+    }
+
+    return b;
+  }
+
+  /** Reads a Big-Endian short from the front of this buffer and returns it. */
+  public short readShort() {
+    if (byteCount < 2) throw new IllegalArgumentException("byteCount < 2: " + byteCount);
+
+    Segment segment = head;
+    int pos = segment.pos;
+    int limit = segment.limit;
+
+    // If the short is split across multiple segments, delegate to readByte().
+    if (limit - pos < 2) {
+      int s = (readByte() & 0xff) << 8
+          |   (readByte() & 0xff);
+      return (short) s;
+    }
+
+    byte[] data = segment.data;
+    int s = (data[pos++] & 0xff) << 8
+        |   (data[pos++] & 0xff);
+    byteCount -= 2;
+
+    if (pos == limit) {
+      head = segment.pop();
+      SegmentPool.INSTANCE.recycle(segment);
+    } else {
+      segment.pos = pos;
+    }
+
+    return (short) s;
+  }
+
+  /** Reads a Big-Endian int from the front of this buffer and returns it. */
+  public int readInt() {
+    if (byteCount < 4) throw new IllegalArgumentException("byteCount < 4: " + byteCount);
+
+    Segment segment = head;
+    int pos = segment.pos;
+    int limit = segment.limit;
+
+    // If the int is split across multiple segments, delegate to readByte().
+    if (limit - pos < 4) {
+      return (readByte() & 0xff) << 24
+          |  (readByte() & 0xff) << 16
+          |  (readByte() & 0xff) << 8
+          |  (readByte() & 0xff);
+    }
+
+    byte[] data = segment.data;
+    int i = (data[pos++] & 0xff) << 24
+        |   (data[pos++] & 0xff) << 16
+        |   (data[pos++] & 0xff) << 8
+        |   (data[pos++] & 0xff);
+    byteCount -= 4;
+
+    if (pos == limit) {
+      head = segment.pop();
+      SegmentPool.INSTANCE.recycle(segment);
+    } else {
+      segment.pos = pos;
+    }
+
+    return i;
+  }
+
+  /** Removes {@code byteCount} bytes from this and returns them as a byte string. */
+  public ByteString readByteString(int byteCount) {
+    return new ByteString(readBytes(byteCount));
+  }
+
+  /** Removes {@code byteCount} bytes from this, decodes them as UTF-8 and returns the string. */
+  public String readUtf8(int byteCount) {
+    return new String(readBytes(byteCount), Util.UTF_8);
+  }
+
+  private byte[] readBytes(int byteCount) {
+    checkOffsetAndCount(this.byteCount, 0, byteCount);
+
+    int offset = 0;
+    byte[] result = new byte[byteCount];
+
+    while (offset < byteCount) {
+      int toCopy = Math.min(byteCount - offset, head.limit - head.pos);
+      System.arraycopy(head.data, head.pos, result, offset, toCopy);
+
+      offset += toCopy;
+      head.pos += toCopy;
+
+      if (head.pos == head.limit) {
+        Segment toRecycle = head;
+        head = toRecycle.pop();
+        SegmentPool.INSTANCE.recycle(toRecycle);
+      }
+    }
+
+    this.byteCount -= byteCount;
+    return result;
+  }
+
+  /** Appends {@code byteString} to this. */
+  public void write(ByteString byteString) {
+    write(byteString.data, 0, byteString.data.length);
+  }
+
+  /** Encodes {@code string} as UTF-8 and appends the bytes to this. */
+  public void writeUtf8(String string) {
+    byte[] data = string.getBytes(Util.UTF_8);
+    write(data, 0, data.length);
+  }
+
+  void write(byte[] data, int offset, int byteCount) {
+    int limit = offset + byteCount;
+    while (offset < limit) {
+      Segment tail = writableSegment(1);
+
+      int toCopy = Math.min(limit - offset, Segment.SIZE - tail.limit);
+      System.arraycopy(data, offset, tail.data, tail.limit, toCopy);
+
+      offset += toCopy;
+      tail.limit += toCopy;
+    }
+
+    this.byteCount += data.length;
+  }
+
+  /** Appends a Big-Endian byte to the end of this buffer. */
+  public OkBuffer writeByte(int b) {
+    Segment tail = writableSegment(1);
+    tail.data[tail.limit++] = (byte) b;
+    byteCount += 1;
+    return this;
+  }
+
+  /** Appends a Big-Endian short to the end of this buffer. */
+  public OkBuffer writeShort(int s) {
+    Segment tail = writableSegment(2);
+    byte[] data = tail.data;
+    int limit = tail.limit;
+    data[limit++] = (byte) ((s >> 8) & 0xff);
+    data[limit++] = (byte)  (s       & 0xff);
+    tail.limit = limit;
+    byteCount += 2;
+    return this;
+  }
+
+  /** Appends a Big-Endian int to the end of this buffer. */
+  public OkBuffer writeInt(int i) {
+    Segment tail = writableSegment(4);
+    byte[] data = tail.data;
+    int limit = tail.limit;
+    data[limit++] = (byte) ((i >> 24) & 0xff);
+    data[limit++] = (byte) ((i >> 16) & 0xff);
+    data[limit++] = (byte) ((i >>  8) & 0xff);
+    data[limit++] = (byte)  (i        & 0xff);
+    tail.limit = limit;
+    byteCount += 4;
+    return this;
+  }
+
+  /**
+   * Returns a tail segment that we can write at least {@code minimumCapacity}
+   * bytes to, creating it if necessary.
+   */
+  Segment writableSegment(int minimumCapacity) {
+    if (minimumCapacity < 1 || minimumCapacity > Segment.SIZE) throw new IllegalArgumentException();
+
+    if (head == null) {
+      head = SegmentPool.INSTANCE.take(); // Acquire a first segment.
+      return head.next = head.prev = head;
+    }
+
+    Segment tail = head.prev;
+    if (tail.limit + minimumCapacity > Segment.SIZE) {
+      tail = tail.push(SegmentPool.INSTANCE.take()); // Append a new empty segment to fill up.
+    }
+    return tail;
+  }
+
+  @Override public void write(OkBuffer source, long byteCount, Deadline deadline) {
+    // Move bytes from the head of the source buffer to the tail of this buffer
+    // while balancing two conflicting goals: don't waste CPU and don't waste
+    // memory.
+    //
+    //
+    // Don't waste CPU (ie. don't copy data around).
+    //
+    // Copying large amounts of data is expensive. Instead, we prefer to
+    // reassign entire segments from one OkBuffer to the other.
+    //
+    //
+    // Don't waste memory.
+    //
+    // As an invariant, adjacent pairs of segments in an OkBuffer should be at
+    // least 50% full, except for the head segment and the tail segment.
+    //
+    // The head segment cannot maintain the invariant because the application is
+    // consuming bytes from this segment, decreasing its level.
+    //
+    // The tail segment cannot maintain the invariant because the application is
+    // producing bytes, which may require new nearly-empty tail segments to be
+    // appended.
+    //
+    //
+    // Moving segments between buffers
+    //
+    // When writing one buffer to another, we prefer to reassign entire segments
+    // over copying bytes into their most compact form. Suppose we have a buffer
+    // with these segment levels [91%, 61%]. If we append a buffer with a
+    // single [72%] segment, that yields [91%, 61%, 72%]. No bytes are copied.
+    //
+    // Or suppose we have a buffer with these segment levels: [100%, 2%], and we
+    // want to append it to a buffer with these segment levels [99%, 3%]. This
+    // operation will yield the following segments: [100%, 2%, 99%, 3%]. That
+    // is, we do not spend time copying bytes around to achieve more efficient
+    // memory use like [100%, 100%, 4%].
+    //
+    // When combining buffers, we will compact adjacent buffers when their
+    // combined level doesn't exceed 100%. For example, when we start with
+    // [100%, 40%] and append [30%, 80%], the result is [100%, 70%, 80%].
+    //
+    //
+    // Splitting segments
+    //
+    // Occasionally we write only part of a source buffer to a sink buffer. For
+    // example, given a sink [51%, 91%], we may want to write the first 30% of
+    // a source [92%, 82%] to it. To simplify, we first transform the source to
+    // an equivalent buffer [30%, 62%, 82%] and then move the head segment,
+    // yielding sink [51%, 91%, 30%] and source [62%, 82%].
+
+    if (source == this) throw new IllegalArgumentException("source == this");
+    checkOffsetAndCount(source.byteCount, 0, byteCount);
+
+    while (byteCount > 0) {
+      // Is a prefix of the source's head segment all that we need to move?
+      if (byteCount < (source.head.limit - source.head.pos)) {
+        Segment tail = head.prev;
+        if (head == null || byteCount + (tail.limit - tail.pos) > Segment.SIZE) {
+          // We're going to need another segment. Split the source's head
+          // segment in two, then move the first of those two to this buffer.
+          source.head = source.head.split((int) byteCount);
+        } else {
+          // Our existing segments are sufficient. Move bytes from source's head to our tail.
+          source.head.writeTo(tail, (int) byteCount);
+          source.byteCount -= byteCount;
+          this.byteCount += byteCount;
+          return;
+        }
+      }
+
+      // Remove the source's head segment and append it to our tail.
+      Segment segmentToMove = source.head;
+      long movedByteCount = segmentToMove.limit - segmentToMove.pos;
+      source.head = segmentToMove.pop();
+      if (head == null) {
+        head = segmentToMove;
+        head.next = head.prev = head;
+      } else {
+        Segment tail = head.prev;
+        tail = tail.push(segmentToMove);
+        tail.compact();
+      }
+      source.byteCount -= movedByteCount;
+      this.byteCount += movedByteCount;
+      byteCount -= movedByteCount;
+    }
+  }
+
+  @Override public long read(OkBuffer sink, long byteCount, Deadline deadline) throws IOException {
+    if (this.byteCount == 0) return -1L;
+    if (byteCount > this.byteCount) byteCount = this.byteCount;
+    sink.write(this, byteCount, deadline);
+    return byteCount;
+  }
+
+  /**
+   * Returns the index of {@code b} in this, or -1 if this buffer does not
+   * contain {@code b}.
+   */
+  public long indexOf(byte b) throws IOException {
+    Segment s = head;
+    if (s == null) return -1L;
+    long offset = 0L;
+    do {
+      byte[] data = s.data;
+      for (int pos = s.pos, limit = s.limit; pos < limit; pos++) {
+        if (data[pos] == b) return offset + pos - s.pos;
+      }
+      offset += s.limit - s.pos;
+      s = s.next;
+    } while (s != head);
+    return -1L;
+  }
+
+  @Override public void flush(Deadline deadline) {
+  }
+
+  @Override public void close(Deadline deadline) {
+  }
+
+  /** For testing. This returns the sizes of the segments in this buffer. */
+  List<Integer> segmentSizes() {
+    if (head == null) return Collections.emptyList();
+    List<Integer> result = new ArrayList<Integer>();
+    result.add(head.limit - head.pos);
+    for (Segment s = head.next; s != head; s = s.next) {
+      result.add(s.limit - s.pos);
+    }
+    return result;
+  }
+
+  /**
+   * Returns the contents of this buffer in hex. For buffers larger than 1 MiB
+   * this method is undefined.
+   */
+  @Override public String toString() {
+    if (byteCount > 0x100000) return super.toString();
+    int charCount = (int) (byteCount * 2);
+    char[] result = new char[charCount];
+    int offset = 0;
+    for (Segment s = head; offset < charCount; s = s.next) {
+      for (int i = s.pos; i < s.limit; i++) {
+        result[offset++] = HEX_DIGITS[(s.data[i] >> 4) & 0xf];
+        result[offset++] = HEX_DIGITS[s.data[i] & 0xf];
+      }
+    }
+    return new String(result);
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
new file mode 100644
index 0000000000..230ab4c76d
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/OkBuffers.java
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
+
+public final class OkBuffers {
+  private OkBuffers() {
+  }
+
+  /** Returns a sink that writes to {@code out}. */
+  public static Sink sink(final OutputStream out) {
+    return new Sink() {
+      @Override public void write(OkBuffer source, long byteCount, Deadline deadline)
+          throws IOException {
+        checkOffsetAndCount(source.byteCount, 0, byteCount);
+        while (byteCount > 0) {
+          deadline.throwIfReached();
+          Segment head = source.head;
+          int toCopy = (int) Math.min(byteCount, head.limit - head.pos);
+          out.write(head.data, head.pos, toCopy);
+
+          head.pos += toCopy;
+          byteCount -= toCopy;
+          source.byteCount -= toCopy;
+
+          if (head.pos == head.limit) {
+            source.head = head.pop();
+            SegmentPool.INSTANCE.recycle(head);
+          }
+        }
+      }
+
+      @Override public void flush(Deadline deadline) throws IOException {
+        out.flush();
+      }
+
+      @Override public void close(Deadline deadline) throws IOException {
+        out.close();
+      }
+
+      @Override public String toString() {
+        return "sink(" + out + ")";
+      }
+    };
+  }
+
+  /**
+   * Returns an output stream that writes to {@code sink}. This may buffer data
+   * by deferring writes.
+   */
+  public static OutputStream outputStream(final Sink sink) {
+    return new OutputStream() {
+      final OkBuffer buffer = new OkBuffer(); // Buffer at most one segment of data.
+
+      @Override public void write(int b) throws IOException {
+        buffer.writeByte((byte) b);
+        if (buffer.byteCount == Segment.SIZE) {
+          sink.write(buffer, buffer.byteCount, Deadline.NONE);
+        }
+      }
+
+      @Override public void write(byte[] data, int offset, int byteCount) throws IOException {
+        checkOffsetAndCount(data.length, offset, byteCount);
+        int limit = offset + byteCount;
+        while (offset < limit) {
+          Segment onlySegment = buffer.writableSegment(1);
+          int toCopy = Math.min(limit - offset, Segment.SIZE - onlySegment.limit);
+          System.arraycopy(data, offset, onlySegment.data, onlySegment.limit, toCopy);
+          offset += toCopy;
+          onlySegment.limit += toCopy;
+          buffer.byteCount += toCopy;
+          if (buffer.byteCount == Segment.SIZE) {
+            sink.write(buffer, buffer.byteCount, Deadline.NONE);
+          }
+        }
+      }
+
+      @Override public void flush() throws IOException {
+        sink.write(buffer, buffer.byteCount, Deadline.NONE); // Flush the buffer.
+        sink.flush(Deadline.NONE);
+      }
+
+      @Override public void close() throws IOException {
+        sink.write(buffer, buffer.byteCount, Deadline.NONE); // Flush the buffer.
+        sink.close(Deadline.NONE);
+      }
+
+      @Override public String toString() {
+        return "outputStream(" + sink + ")";
+      }
+    };
+  }
+
+  /** Returns a source that reads from {@code in}. */
+  public static Source source(final InputStream in) {
+    return new Source() {
+      @Override public long read(
+          OkBuffer sink, long byteCount, Deadline deadline) throws IOException {
+        if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+        deadline.throwIfReached();
+        Segment tail = sink.writableSegment(1);
+        int maxToCopy = (int) Math.min(byteCount, Segment.SIZE - tail.limit);
+        int bytesRead = in.read(tail.data, tail.limit, maxToCopy);
+        if (bytesRead == -1) return -1;
+        tail.limit += bytesRead;
+        sink.byteCount += bytesRead;
+        return bytesRead;
+      }
+
+      @Override public void close(Deadline deadline) throws IOException {
+        in.close();
+      }
+
+      @Override public String toString() {
+        return "source(" + in + ")";
+      }
+    };
+  }
+
+  /**
+   * Returns an input stream that reads from {@code source}. This may buffer
+   * data by reading extra data eagerly.
+   */
+  public static InputStream inputStream(final Source source) {
+    return new InputStream() {
+      final OkBuffer buffer = new OkBuffer();
+
+      @Override public int read() throws IOException {
+        if (buffer.byteCount == 0) {
+          long count = source.read(buffer, Segment.SIZE, Deadline.NONE);
+          if (count == -1) return -1;
+        }
+        return buffer.readByte();
+      }
+
+      @Override public int read(byte[] data, int offset, int byteCount) throws IOException {
+        checkOffsetAndCount(data.length, offset, byteCount);
+
+        if (buffer.byteCount == 0) {
+          long count = source.read(buffer, Segment.SIZE, Deadline.NONE);
+          if (count == -1) return -1;
+        }
+
+        Segment head = buffer.head;
+        int toCopy = Math.min(byteCount, head.limit - head.pos);
+        System.arraycopy(head.data, head.pos, data, offset, toCopy);
+
+        head.pos += toCopy;
+        buffer.byteCount -= toCopy;
+
+        if (head.pos == head.limit) {
+          buffer.head = head.pop();
+          SegmentPool.INSTANCE.recycle(head);
+        }
+
+        return toCopy;
+      }
+
+      @Override public int available() throws IOException {
+        return (int) Math.min(buffer.byteCount, Integer.MAX_VALUE);
+      }
+
+      @Override public void close() throws IOException {
+        super.close();
+      }
+
+      @Override public String toString() {
+        return "inputStream(" + source + ")";
+      }
+    };
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Segment.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Segment.java
new file mode 100644
index 0000000000..a3fe7c08ed
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Segment.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+/**
+ * A segment of an OkBuffer.
+ *
+ * <p>Each segment in an OkBuffer is a circularly-linked list node referencing
+ * the following and preceding segments in the buffer.
+ *
+ * <p>Each segment in the pool is a singly-linked list node referencing the rest
+ * of segments in the pool.
+ */
+final class Segment {
+  /** The size of all segments in bytes. */
+  // TODO: Using fixed-size segments makes pooling easier. But it harms memory
+  //       efficiency and encourages copying. Try variable sized segments?
+  // TODO: Is 2 KiB a good default segment size?
+  static final int SIZE = 2048;
+
+  final byte[] data = new byte[SIZE];
+
+  /** The next byte of application data byte to read in this segment. */
+  int pos;
+
+  /** The first byte of available data ready to be written to. */
+  int limit;
+
+  /** Next segment in a linked or circularly-linked list. */
+  Segment next;
+
+  /** Previous segment in a circularly-linked list. */
+  Segment prev;
+
+  /**
+   * Removes this segment of a circularly-linked list and returns its successor.
+   * Returns null if the list is now empty.
+   */
+  public Segment pop() {
+    Segment result = next != this ? next : null;
+    prev.next = next;
+    next.prev = prev;
+    next = null;
+    prev = null;
+    return result;
+  }
+
+  /**
+   * Appends {@code segment} after this segment in the circularly-linked list.
+   * Returns the pushed segment.
+   */
+  public Segment push(Segment segment) {
+    segment.prev = this;
+    segment.next = next;
+    next.prev = segment;
+    next = segment;
+    return segment;
+  }
+
+  /**
+   * Splits this head of a circularly-linked list into two segments. The first
+   * segment contains the data in {@code [pos..pos+byteCount)}. The second
+   * segment contains the data in {@code [pos+byteCount..limit)}. This can be
+   * useful when moving partial segments from one OkBuffer to another.
+   *
+   * <p>Returns the new head of the circularly-linked list.
+   */
+  public Segment split(int byteCount) {
+    int aSize = byteCount;
+    int bSize = (limit - pos) - byteCount;
+    if (aSize <= 0 || bSize <= 0) throw new IllegalArgumentException();
+
+    // Which side of the split is larger? We want to copy as few bytes as possible.
+    if (aSize < bSize) {
+      // Create a segment of size 'aSize' before this segment.
+      Segment before = SegmentPool.INSTANCE.take();
+      System.arraycopy(data, pos, before.data, before.pos, aSize);
+      pos += aSize;
+      before.limit += aSize;
+      prev.push(before);
+      return before;
+    } else {
+      // Create a new segment of size 'bSize' after this segment.
+      Segment after = SegmentPool.INSTANCE.take();
+      System.arraycopy(data, pos + aSize, after.data, after.pos, bSize);
+      limit -= bSize;
+      after.limit += bSize;
+      push(after);
+      return this;
+    }
+  }
+
+  /**
+   * Call this when the tail and its predecessor may both be less than half
+   * full. This will copy data so that segments can be recycled.
+   */
+  public void compact() {
+    if (prev == this) throw new IllegalStateException();
+    if ((prev.limit - prev.pos) + (limit - pos) > SIZE) return; // Cannot compact.
+    writeTo(prev, limit - pos);
+    pop();
+    SegmentPool.INSTANCE.recycle(this);
+  }
+
+  /** Moves {@code byteCount} bytes from {@code sink} to this segment. */
+  // TODO: if sink has fewer bytes than this, it may be cheaper to reverse the
+  //       direction of the copy and swap the segments!
+  public void writeTo(Segment sink, int byteCount) {
+    if (byteCount + (sink.limit - sink.pos) > SIZE) throw new IllegalArgumentException();
+
+    if (sink.limit + byteCount > SIZE) {
+      // We can't fit byteCount bytes at the sink's current position. Compact sink first.
+      System.arraycopy(sink.data, sink.pos, sink.data, 0, sink.limit - sink.pos);
+      sink.limit -= sink.pos;
+      sink.pos = 0;
+    }
+
+    System.arraycopy(data, pos, sink.data, sink.limit, byteCount);
+    sink.limit += byteCount;
+    pos += byteCount;
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/SegmentPool.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/SegmentPool.java
new file mode 100644
index 0000000000..ba9703e584
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/SegmentPool.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+/**
+ * A collection of unused segments, necessary to avoid GC churn and zero-fill.
+ * This pool is a thread-safe static singleton.
+ */
+final class SegmentPool {
+  static final SegmentPool INSTANCE = new SegmentPool();
+
+  /** The maximum number of bytes to pool. */
+  // TODO: Is 64 KiB a good maximum size? Do we ever have that many idle segments?
+  static final long MAX_SIZE = 64 * 1024; // 64 KiB.
+
+  /** Singly-linked list of segments. */
+  private Segment next;
+
+  /** Total bytes in this pool. */
+  long byteCount;
+
+  private SegmentPool() {
+  }
+
+  Segment take() {
+    synchronized (this) {
+      if (next != null) {
+        Segment result = next;
+        next = result.next;
+        result.next = null;
+        byteCount -= Segment.SIZE;
+        return result;
+      }
+    }
+    return new Segment(); // Pool is empty. Don't zero-fill while holding a lock.
+  }
+
+  void recycle(Segment segment) {
+    if (segment.next != null || segment.prev != null) throw new IllegalArgumentException();
+    synchronized (this) {
+      if (byteCount + Segment.SIZE > MAX_SIZE) return; // Pool is full.
+      byteCount += Segment.SIZE;
+      segment.next = next;
+      segment.pos = segment.limit = 0;
+      next = segment;
+    }
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Sink.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Sink.java
new file mode 100644
index 0000000000..1531366be0
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Sink.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.io.IOException;
+
+/**
+ * An alternative to OutputStream.
+ */
+public interface Sink {
+  /** Removes {@code byteCount} bytes from {@code source} and appends them to this. */
+  void write(OkBuffer source, long byteCount, Deadline deadline) throws IOException;
+
+  /** Pushes all buffered bytes to their final destination. */
+  void flush(Deadline deadline) throws IOException;
+
+  /**
+   * Pushes all buffered bytes to their final destination and releases the
+   * resources held by this sink. It is an error to write a closed sink. It is
+   * safe to close a sink more than once.
+   */
+  void close(Deadline deadline) throws IOException;
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Source.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Source.java
new file mode 100644
index 0000000000..5b9a87a002
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/Source.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.io.IOException;
+
+/**
+ * An alternative to InputStream.
+ */
+public interface Source {
+  /**
+   * Removes at least 1, and up to {@code byteCount} bytes from this and appends
+   * them to {@code sink}. Returns the number of bytes read, or -1 if this
+   * source is exhausted.
+   */
+  long read(OkBuffer sink, long byteCount, Deadline deadline) throws IOException;
+
+  /**
+   * Closes this source and releases the resources held by this source. It is an
+   * error to read a closed source. It is safe to close a source more than once.
+   */
+  void close(Deadline deadline) throws IOException;
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ByteArrayPool.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ByteArrayPool.java
new file mode 100644
index 0000000000..5961172e1f
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ByteArrayPool.java
@@ -0,0 +1,133 @@
+  /*
+   * Copyright (C) 2012 The Android Open Source Project
+   *
+   * Licensed under the Apache License, Version 2.0 (the "License");
+   * you may not use this file except in compliance with the License.
+   * You may obtain a copy of the License at
+   *
+   *      http://www.apache.org/licenses/LICENSE-2.0
+   *
+   * Unless required by applicable law or agreed to in writing, software
+   * distributed under the License is distributed on an "AS IS" BASIS,
+   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   * See the License for the specific language governing permissions and
+   * limitations under the License.
+   */
+
+  package com.squareup.okhttp.internal.spdy;
+
+  import java.util.ArrayList;
+  import java.util.Collections;
+  import java.util.Comparator;
+  import java.util.List;
+
+  /**
+   * ByteArrayPool is a source and repository of <code>byte[]</code> objects. Its purpose is to
+   * supply those buffers to consumers who need to use them for a short period of time and then
+   * dispose of them. Simply creating and disposing such buffers in the conventional manner can
+   * considerable heap churn and garbage collection delays on Android, which lacks good management
+   * of short-lived heap objects. It may be advantageous to trade off some memory in the form of a
+   * permanently allocated pool of buffers in order to gain heap performance improvements; that is
+   * what this class does.
+   * <p>
+   * A good candidate user for this class is something like an I/O system that uses large temporary
+   * <code>byte[]</code> buffers to copy data around. In these use cases, often the consumer wants
+   * the buffer to be a certain minimum size to ensure good performance (e.g. when copying data
+   * chunks off of a stream), but doesn't mind if the buffer is larger than the minimum. Taking this
+   * into account and also to maximize the odds of being able to reuse a recycled buffer, this
+   * class is free to return buffers larger than the requested size. The caller needs to be able
+   * to gracefully deal with getting buffers any size over the minimum.
+   * <p>
+   * If there is not a suitably-sized buffer in its recycling pool when a buffer is requested, this
+   * class will allocate a new buffer and return it.
+   * <p>
+   * This class has no special ownership of buffers it creates; the caller is free to take a buffer
+   * it receives from this pool, use it permanently, and never return it to the pool; additionally,
+   * it is not harmful to return to this pool a buffer that was allocated elsewhere, provided there
+   * are no other lingering references to it.
+   * <p>
+   * This class ensures that the total size of the buffers in its recycling pool never exceeds a
+   * certain byte limit. When a buffer is returned that would cause the pool to exceed the limit,
+   * least-recently-used buffers are disposed.
+   */
+  public class ByteArrayPool {
+    /** The buffer pool, arranged both by last use and by buffer size. */
+    private List<byte[]> mBuffersByLastUse = new ArrayList<byte[]>();
+    private List<byte[]> mBuffersBySize = new ArrayList<byte[]>(64);
+
+    /** The total size of the buffers in the pool. */
+    private int mCurrentSize = 0;
+
+    /**
+     * The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay
+     * under this limit.
+     */
+    private final int mSizeLimit;
+
+    /** Compares buffers by size. */
+    protected static final Comparator<byte[]> BUF_COMPARATOR = new Comparator<byte[]>() {
+      @Override
+      public int compare(byte[] lhs, byte[] rhs) {
+        return lhs.length - rhs.length;
+      }
+    };
+
+    /**
+     * @param sizeLimit the maximum size of the pool, in bytes
+     */
+    public ByteArrayPool(int sizeLimit) {
+      mSizeLimit = sizeLimit;
+    }
+
+    /**
+     * Returns a buffer from the pool if one is available in the requested size, or
+     * allocates a new one if a pooled one is not available.
+     *
+     * @param len the minimum size, in bytes, of the requested buffer. The returned buffer may be
+     * larger.
+     * @return a byte[] buffer is always returned.
+     */
+    public synchronized byte[] getBuf(int len) {
+      for (int i = 0; i < mBuffersBySize.size(); i++) {
+        byte[] buf = mBuffersBySize.get(i);
+        if (buf.length >= len) {
+          mCurrentSize -= buf.length;
+          mBuffersBySize.remove(i);
+          mBuffersByLastUse.remove(buf);
+          return buf;
+        }
+      }
+      return new byte[len];
+    }
+
+    /**
+     * Returns a buffer to the pool, throwing away old buffers if the pool would exceed its
+     * allotted size.
+     *
+     * @param buf the buffer to return to the pool.
+     */
+    public synchronized void returnBuf(byte[] buf) {
+      if (buf == null || buf.length > mSizeLimit) {
+        return;
+      }
+      mBuffersByLastUse.add(buf);
+      int pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);
+      if (pos < 0) {
+        pos = -pos - 1;
+      }
+      mBuffersBySize.add(pos, buf);
+      mCurrentSize += buf.length;
+      trim();
+    }
+
+    /**
+     * Removes buffers from the pool until it is under its size limit.
+     */
+    private synchronized void trim() {
+      while (mCurrentSize > mSizeLimit) {
+        byte[] buf = mBuffersByLastUse.remove(0);
+        mBuffersBySize.remove(buf);
+        mCurrentSize -= buf.length;
+      }
+    }
+  }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
index d3a32e1172..045677b5dd 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
@@ -1,5 +1,7 @@
 package com.squareup.okhttp.internal.spdy;
 
+// TODO: revisit for http/2 draft 9
+// http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-7
 public enum ErrorCode {
   /** Not an error! For SPDY stream resets, prefer null over NO_ERROR. */
   NO_ERROR(0, -1, 0),
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index 1371262e6c..9d4c233c6a 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -21,35 +21,85 @@
 import java.io.InputStream;
 import java.util.List;
 
-/** Reads transport frames for SPDY/3 or HTTP/2.0. */
+/** Reads transport frames for SPDY/3 or HTTP/2. */
 public interface FrameReader extends Closeable {
   void readConnectionHeader() throws IOException;
   boolean nextFrame(Handler handler) throws IOException;
 
   public interface Handler {
     void data(boolean inFinished, int streamId, InputStream in, int length) throws IOException;
+
     /**
      * Create or update incoming headers, creating the corresponding streams
      * if necessary. Frames that trigger this are SPDY SYN_STREAM, HEADERS, and
-     * SYN_REPLY, and HTTP/2.0 HEADERS and PUSH_PROMISE.
+     * SYN_REPLY, and HTTP/2 HEADERS and PUSH_PROMISE.
      *
-     * @param inFinished true if the sender will not send further frames.
      * @param outFinished true if the receiver should not send further frames.
+     * @param inFinished true if the sender will not send further frames.
      * @param streamId the stream owning these headers.
      * @param associatedStreamId the stream that triggered the sender to create
-     *     this stream.
+     * this stream.
      * @param priority or -1 for no priority. For SPDY, priorities range from 0
-     *     (highest) thru 7 (lowest). For HTTP/2.0, priorities range from 0
-     *     (highest) thru 2**31-1 (lowest).
+     * (highest) thru 7 (lowest). For HTTP/2, priorities range from 0
+     * (highest) thru 2^31-1 (lowest), defaulting to 2^30.
      */
     void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-        int priority, List<String> nameValueBlock, HeadersMode headersMode);
+        int priority, List<Header> headerBlock, HeadersMode headersMode);
     void rstStream(int streamId, ErrorCode errorCode);
     void settings(boolean clearPrevious, Settings settings);
-    void noop();
-    void ping(boolean reply, int payload1, int payload2);
-    void goAway(int lastGoodStreamId, ErrorCode errorCode);
-    void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl);
+
+    /** HTTP/2 only. */
+    void ackSettings();
+
+    /**
+     *  Read a connection-level ping from the peer.  {@code ack} indicates this
+     *  is a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
+     *  <p>
+     *  In SPDY/3, only the first {@code payload1} parameter is set.  If the
+     *  reader is a client, it is an unsigned even number.  Likewise, a server
+     *  will receive an odd number.
+     *  <p>
+     *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
+     *  set. The data is opaque binary, and there are no rules on the content.
+     */
+    void ping(boolean ack, int payload1, int payload2);
+
+    /**
+     * The peer tells us to stop creating streams.  It is safe to replay
+     * streams with {@code ID > lastGoodStreamId} on a new connection.  In-
+     * flight streams with {@code ID <= lastGoodStreamId} can only be replayed
+     * on a new connection if they are idempotent.
+     *
+     * @param lastGoodStreamId the last stream ID the peer processed before
+     * sending this message. If {@lastGoodStreamId} is zero, the peer processed no frames.
+     * @param errorCode reason for closing the connection.
+     * @param debugData only valid for http/2; opaque debug data to send.
+     */
+    void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData);
+
+    /**
+     * Notifies that an additional {@code windowSizeIncrement} bytes can be
+     * sent on {@code streamId}, or the connection if {@code streamId} is zero.
+     */
+    void windowUpdate(int streamId, long windowSizeIncrement);
     void priority(int streamId, int priority);
+
+    /**
+     * HTTP/2 only. Receive a push promise header block.
+     * <p>
+     * A push promise contains all the headers that pertain to a server-initiated
+     * request, and a {@code promisedStreamId} to which response frames will be
+     * delivered. Push promise frames are sent as a part of the response to
+     * {@code streamId}.  The {@code promisedStreamId} has a priority of one
+     * greater than {@code streamId}.
+     *
+     * @param streamId client-initiated stream ID.  Must be an odd number.
+     * @param promisedStreamId server-initiated stream ID.  Must be an even
+     * number.
+     * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
+     * {@code :authority}, and (@code :path}.
+     */
+    void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+        throws IOException;
   }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index 354f43d1d1..db1134e8b6 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -20,24 +20,82 @@
 import java.io.IOException;
 import java.util.List;
 
-/** Writes transport frames for SPDY/3 or HTTP/2.0. */
+/** Writes transport frames for SPDY/3 or HTTP/2. */
 public interface FrameWriter extends Closeable {
-  /** HTTP/2.0 only. */
+  /** HTTP/2 only. */
   void connectionHeader() throws IOException;
+  void ackSettings() throws IOException;
+
+  /**
+   * HTTP/2 only. Send a push promise header block.
+   * <p>
+   * A push promise contains all the headers that pertain to a server-initiated
+   * request, and a {@code promisedStreamId} to which response frames will be
+   * delivered. Push promise frames are sent as a part of the response to
+   * {@code streamId}.  The {@code promisedStreamId} has a priority of one
+   * greater than {@code streamId}.
+   *
+   * @param streamId client-initiated stream ID.  Must be an odd number.
+   * @param promisedStreamId server-initiated stream ID.  Must be an even
+   * number.
+   * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
+   * {@code :authority}, and (@code :path}.
+   */
+  void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+      throws IOException;
 
   /** SPDY/3 only. */
   void flush() throws IOException;
   void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      int priority, int slot, List<String> nameValueBlock) throws IOException;
-  void synReply(boolean outFinished, int streamId, List<String> nameValueBlock) throws IOException;
-  void headers(int streamId, List<String> nameValueBlock) throws IOException;
+      int priority, int slot, List<Header> headerBlock) throws IOException;
+  void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
+      throws IOException;
+  void headers(int streamId, List<Header> headerBlock) throws IOException;
   void rstStream(int streamId, ErrorCode errorCode) throws IOException;
+
+  /**
+   * {@code data.length} may be longer than the max length of the variant's data frame.
+   * Implementations must send multiple frames as necessary.
+   */
   void data(boolean outFinished, int streamId, byte[] data) throws IOException;
+
+  /**
+   * {@code byteCount} may be longer than the max length of the variant's data frame.
+   * Implementations must send multiple frames as necessary.
+   */
   void data(boolean outFinished, int streamId, byte[] data, int offset, int byteCount)
       throws IOException;
-  void settings(Settings settings) throws IOException;
-  void noop() throws IOException;
-  void ping(boolean reply, int payload1, int payload2) throws IOException;
-  void goAway(int lastGoodStreamId, ErrorCode errorCode) throws IOException;
-  void windowUpdate(int streamId, int deltaWindowSize) throws IOException;
+
+  /** Write okhttp's settings to the peer. */
+  void settings(Settings okHttpSettings) throws IOException;
+
+  /**
+   *  Send a connection-level ping to the peer.  {@code ack} indicates this is
+   *  a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
+   *  <p>
+   *  In SPDY/3, only the first {@code payload1} parameter is sent.  If the
+   *  sender is a client, it is an unsigned odd number.  Likewise, a server
+   *  will send an even number.
+   *  <p>
+   *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
+   *  sent.  The data is opaque binary, and there are no rules on the content.
+   */
+  void ping(boolean ack, int payload1, int payload2) throws IOException;
+
+  /**
+   * Tell the peer to stop creating streams and that we last processed
+   * {@code lastGoodStreamId}, or zero if no streams were processed.
+   *
+   * @param lastGoodStreamId the last stream ID processed, or zero if no
+   * streams were processed.
+   * @param errorCode reason for closing the connection.
+   * @param debugData only valid for http/2; opaque debug data to send.
+   */
+  void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) throws IOException;
+
+  /**
+   * Inform peer that an additional {@code windowSizeIncrement} bytes can be
+   * sent on {@code streamId}, or the connection if {@code streamId} is zero.
+   */
+  void windowUpdate(int streamId, long windowSizeIncrement) throws IOException;
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Header.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
new file mode 100644
index 0000000000..45fa213186
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
@@ -0,0 +1,56 @@
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.bytes.ByteString;
+
+/** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
+public final class Header {
+  // Special header names defined in the SPDY and HTTP/2 specs.
+  public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(":status");
+  public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(":method");
+  public static final ByteString TARGET_PATH = ByteString.encodeUtf8(":path");
+  public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(":scheme");
+  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority"); // http/2
+  public static final ByteString TARGET_HOST = ByteString.encodeUtf8(":host"); // spdy/3
+  public static final ByteString VERSION = ByteString.encodeUtf8(":version"); // spdy/3
+
+  /** Name in case-insensitive ASCII encoding. */
+  public final ByteString name;
+  /** Value in UTF-8 encoding. */
+  public final ByteString value;
+  final int hpackSize;
+
+  // TODO: search for toLowerCase and consider moving logic here.
+  public Header(String name, String value) {
+    this(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value));
+  }
+
+  public Header(ByteString name, String value) {
+    this(name, ByteString.encodeUtf8(value));
+  }
+
+  public Header(ByteString name, ByteString value) {
+    this.name = name;
+    this.value = value;
+    this.hpackSize = 32 + name.size() + value.size();
+  }
+
+  @Override public boolean equals(Object other) {
+    if (other instanceof Header) {
+      Header that = (Header) other;
+      return this.name.equals(that.name)
+          && this.value.equals(that.value);
+    }
+    return false;
+  }
+
+  @Override public int hashCode() {
+    int result = 17;
+    result = 31 * result + name.hashCode();
+    result = 31 * result + value.hashCode();
+    return result;
+  }
+
+  @Override public String toString() {
+    return String.format("%s: %s", name.utf8(), value.utf8());
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
deleted file mode 100644
index 1e799b4994..0000000000
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Hpack.java
+++ /dev/null
@@ -1,360 +0,0 @@
-package com.squareup.okhttp.internal.spdy;
-
-import java.io.DataInputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.BitSet;
-import java.util.List;
-
-/**
- * Read and write HPACK v01.
- * http://http2.github.io/compression-spec/compression-spec.html#rfc.status
- */
-final class Hpack {
-  static final int PREFIX_5_BITS = 0x1f;
-  static final int PREFIX_6_BITS = 0x3f;
-  static final int PREFIX_7_BITS = 0x7f;
-  static final int PREFIX_8_BITS = 0xff;
-
-  static final List<String> INITIAL_CLIENT_TO_SERVER_HEADER_TABLE = Arrays.asList(
-      ":scheme", "http",
-      ":scheme", "https",
-      ":host", "",
-      ":path", "/",
-      ":method", "GET",
-      "accept", "",
-      "accept-charset", "",
-      "accept-encoding", "",
-      "accept-language", "",
-      "cookie", "",
-      "if-modified-since", "",
-      "user-agent", "",
-      "referer", "",
-      "authorization", "",
-      "allow", "",
-      "cache-control", "",
-      "connection", "",
-      "content-length", "",
-      "content-type", "",
-      "date", "",
-      "expect", "",
-      "from", "",
-      "if-match", "",
-      "if-none-match", "",
-      "if-range", "",
-      "if-unmodified-since", "",
-      "max-forwards", "",
-      "proxy-authorization", "",
-      "range", "",
-      "via", ""
-  );
-
-  static final List<String> INITIAL_SERVER_TO_CLIENT_HEADER_TABLE = Arrays.asList(
-      ":status", "200",
-      "age", "",
-      "cache-control", "",
-      "content-length", "",
-      "content-type", "",
-      "date", "",
-      "etag", "",
-      "expires", "",
-      "last-modified", "",
-      "server", "",
-      "set-cookie", "",
-      "vary", "",
-      "via", "",
-      "access-control-allow-origin", "",
-      "accept-ranges", "",
-      "allow", "",
-      "connection", "",
-      "content-disposition", "",
-      "content-encoding", "",
-      "content-language", "",
-      "content-location", "",
-      "content-range", "",
-      "link", "",
-      "location", "",
-      "proxy-authenticate", "",
-      "refresh", "",
-      "retry-after", "",
-      "strict-transport-security", "",
-      "transfer-encoding", "",
-      "www-authenticate", ""
-  );
-
-  private Hpack() {
-  }
-
-  static class Reader {
-    private final long maxBufferSize = 4096; // TODO: needs to come from settings.
-    private final DataInputStream in;
-
-    private final BitSet referenceSet = new BitSet();
-    private final List<String> headerTable;
-    private final List<String> emittedHeaders = new ArrayList<String>();
-    private long bufferSize = 4096;
-    private long bytesLeft = 0;
-
-    Reader(DataInputStream in, boolean client) {
-      this.in = in;
-      this.headerTable = new ArrayList<String>(client
-          ? INITIAL_CLIENT_TO_SERVER_HEADER_TABLE
-          : INITIAL_SERVER_TO_CLIENT_HEADER_TABLE);
-    }
-
-    /**
-     * Read {@code byteCount} bytes of headers from the source stream into the
-     * set of emitted headers.
-     */
-    public void readHeaders(int byteCount) throws IOException {
-      bytesLeft += byteCount;
-      // TODO: limit to 'byteCount' bytes?
-
-      while (bytesLeft > 0) {
-        int b = readByte();
-
-        if ((b & 0x80) != 0) {
-          int index = readInt(b, PREFIX_7_BITS);
-          readIndexedHeader(index);
-        } else if (b == 0x60) {
-          readLiteralHeaderWithoutIndexingNewName();
-        } else if ((b & 0xe0) == 0x60) {
-          int index = readInt(b, PREFIX_5_BITS);
-          readLiteralHeaderWithoutIndexingIndexedName(index - 1);
-        } else if (b == 0x40) {
-          readLiteralHeaderWithIncrementalIndexingNewName();
-        } else if ((b & 0xe0) == 0x40) {
-          int index = readInt(b, PREFIX_5_BITS);
-          readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
-        } else if (b == 0) {
-          readLiteralHeaderWithSubstitutionIndexingNewName();
-        } else if ((b & 0xc0) == 0) {
-          int index = readInt(b, PREFIX_6_BITS);
-          readLiteralHeaderWithSubstitutionIndexingIndexedName(index - 1);
-        } else {
-          throw new AssertionError();
-        }
-      }
-    }
-
-    public void emitReferenceSet() {
-      for (int i = referenceSet.nextSetBit(0); i != -1; i = referenceSet.nextSetBit(i + 1)) {
-        emittedHeaders.add(getName(i));
-        emittedHeaders.add(getValue(i));
-      }
-    }
-
-    /**
-     * Returns all headers emitted since they were last cleared, then clears the
-     * emitted headers.
-     */
-    public List<String> getAndReset() {
-      List<String> result = new ArrayList<String>(emittedHeaders);
-      emittedHeaders.clear();
-      return result;
-    }
-
-    private void readIndexedHeader(int index) {
-      if (referenceSet.get(index)) {
-        referenceSet.clear(index);
-      } else {
-        referenceSet.set(index);
-        emittedHeaders.add(getName(index));
-        emittedHeaders.add(getValue(index));
-      }
-    }
-
-    private void readLiteralHeaderWithoutIndexingIndexedName(int index)
-        throws IOException {
-      String name = getName(index);
-      String value = readString();
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-    }
-
-    private void readLiteralHeaderWithoutIndexingNewName()
-        throws IOException {
-      String name = readString();
-      String value = readString();
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-    }
-
-    private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
-        throws IOException {
-      int index = headerTable.size();
-      String name = getName(nameIndex);
-      String value = readString();
-      appendToHeaderTable(name, value);
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-      referenceSet.set(index);
-    }
-
-    private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
-      int index = headerTable.size();
-      String name = readString();
-      String value = readString();
-      appendToHeaderTable(name, value);
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-      referenceSet.set(index);
-    }
-
-    private void readLiteralHeaderWithSubstitutionIndexingIndexedName(int nameIndex)
-        throws IOException {
-      int index = readInt(readByte(), PREFIX_8_BITS);
-      String name = getName(nameIndex);
-      String value = readString();
-      replaceInHeaderTable(index, name, value);
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-      referenceSet.set(index);
-    }
-
-    private void readLiteralHeaderWithSubstitutionIndexingNewName() throws IOException {
-      String name = readString();
-      int index = readInt(readByte(), PREFIX_8_BITS);
-      String value = readString();
-      replaceInHeaderTable(index, name, value);
-      emittedHeaders.add(name);
-      emittedHeaders.add(value);
-      referenceSet.set(index);
-    }
-
-    private String getName(int index) {
-      return headerTable.get(index * 2);
-    }
-
-    private String getValue(int index) {
-      return headerTable.get(index * 2 + 1);
-    }
-
-    private void appendToHeaderTable(String name, String value) {
-      insertIntoHeaderTable(headerTable.size() * 2, name, value);
-    }
-
-    private void replaceInHeaderTable(int index, String name, String value) {
-      remove(index);
-      insertIntoHeaderTable(index, name, value);
-    }
-
-    private void insertIntoHeaderTable(int index, String name, String value) {
-      // TODO: This needs to be the length in UTF-8 bytes, not the length in chars.
-
-      int delta = 32 + name.length() + value.length();
-
-      // Prune headers to the required length.
-      while (bufferSize + delta > maxBufferSize) {
-        remove(0);
-        index--;
-      }
-
-      if (delta > maxBufferSize) {
-        return; // New values won't fit in the buffer; skip 'em.
-      }
-
-      if (index == 0) index = 0;
-
-      headerTable.add(index * 2, name);
-      headerTable.add(index * 2 + 1, value);
-      bufferSize += delta;
-    }
-
-    private void remove(int index) {
-      String name = headerTable.remove(index * 2);
-      String value = headerTable.remove(index * 2); // No +1 because it's shifted by remove() above.
-      // TODO: This needs to be the length in UTF-8 bytes, not the length in chars.
-      bufferSize -= (32 + name.length() + value.length());
-    }
-
-    private int readByte() throws IOException {
-      bytesLeft--;
-      return in.readByte() & 0xff;
-    }
-
-    int readInt(int firstByte, int prefixMask) throws IOException {
-      int prefix = firstByte & prefixMask;
-      if (prefix < prefixMask) {
-        return prefix; // This was a single byte value.
-      }
-
-      // This is a multibyte value. Read 7 bits at a time.
-      int result = prefixMask;
-      int shift = 0;
-      while (true) {
-        int b = readByte();
-        if ((b & 0x80) != 0) { // Equivalent to (b >= 128) since b is in [0..255].
-          result += (b & 0x7f) << shift;
-          shift += 7;
-        } else {
-          result += b << shift; // Last byte.
-          break;
-        }
-      }
-      return result;
-    }
-
-    /**
-     * Reads a UTF-8 encoded string. Since ASCII is a subset of UTF-8, this method
-     * may be used to read strings that are known to be ASCII-only.
-     */
-    public String readString() throws IOException {
-      int firstByte = readByte();
-      int length = readInt(firstByte, PREFIX_8_BITS);
-      byte[] encoded = new byte[length];
-      bytesLeft -= length;
-      in.readFully(encoded);
-      return new String(encoded, "UTF-8");
-    }
-  }
-
-  static class Writer {
-    private final OutputStream out;
-
-    Writer(OutputStream out) {
-      this.out = out;
-    }
-
-    public void writeHeaders(List<String> nameValueBlock) throws IOException {
-      // TODO: implement a compression strategy.
-      for (int i = 0, size = nameValueBlock.size(); i < size; i += 2) {
-        out.write(0x60); // Literal Header without Indexing - New Name.
-        writeString(nameValueBlock.get(i));
-        writeString(nameValueBlock.get(i + 1));
-      }
-    }
-
-    public void writeInt(int value, int prefixMask, int bits) throws IOException {
-      // Write the raw value for a single byte value.
-      if (value < prefixMask) {
-        out.write(bits | value);
-        return;
-      }
-
-      // Write the mask to start a multibyte value.
-      out.write(bits | prefixMask);
-      value -= prefixMask;
-
-      // Write 7 bits at a time 'til we're done.
-      while (value >= 0x80) {
-        int b = value & 0x7f;
-        out.write(b | 0x80);
-        value >>>= 7;
-      }
-      out.write(value);
-    }
-
-    /**
-     * Writes a UTF-8 encoded string. Since ASCII is a subset of UTF-8, this
-     * method can be used to write strings that are known to be ASCII-only.
-     */
-    public void writeString(String headerName) throws IOException {
-      byte[] bytes = headerName.getBytes("UTF-8");
-      writeInt(bytes.length, PREFIX_8_BITS, 0);
-      out.write(bytes);
-    }
-  }
-}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
new file mode 100644
index 0000000000..0bd8b06779
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -0,0 +1,444 @@
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.BitArray;
+import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.ByteString;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+import static com.squareup.okhttp.internal.Util.asciiLowerCase;
+
+/**
+ * Read and write HPACK v05.
+ *
+ * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05
+ *
+ * This implementation uses an array for the header table with a bitset for
+ * references.  Dynamic entries are added to the array, starting in the last
+ * position moving forward.  When the array fills, it is doubled.
+ */
+final class HpackDraft05 {
+  private static final int PREFIX_6_BITS = 0x3f;
+  private static final int PREFIX_7_BITS = 0x7f;
+  private static final int PREFIX_8_BITS = 0xff;
+
+  private static final Header[] STATIC_HEADER_TABLE = new Header[] {
+      new Header(Header.TARGET_AUTHORITY, ""),
+      new Header(Header.TARGET_METHOD, "GET"),
+      new Header(Header.TARGET_METHOD, "POST"),
+      new Header(Header.TARGET_PATH, "/"),
+      new Header(Header.TARGET_PATH, "/index.html"),
+      new Header(Header.TARGET_SCHEME, "http"),
+      new Header(Header.TARGET_SCHEME, "https"),
+      new Header(Header.RESPONSE_STATUS, "200"),
+      new Header(Header.RESPONSE_STATUS, "500"),
+      new Header(Header.RESPONSE_STATUS, "404"),
+      new Header(Header.RESPONSE_STATUS, "403"),
+      new Header(Header.RESPONSE_STATUS, "400"),
+      new Header(Header.RESPONSE_STATUS, "401"),
+      new Header("accept-charset", ""),
+      new Header("accept-encoding", ""),
+      new Header("accept-language", ""),
+      new Header("accept-ranges", ""),
+      new Header("accept", ""),
+      new Header("access-control-allow-origin", ""),
+      new Header("age", ""),
+      new Header("allow", ""),
+      new Header("authorization", ""),
+      new Header("cache-control", ""),
+      new Header("content-disposition", ""),
+      new Header("content-encoding", ""),
+      new Header("content-language", ""),
+      new Header("content-length", ""),
+      new Header("content-location", ""),
+      new Header("content-range", ""),
+      new Header("content-type", ""),
+      new Header("cookie", ""),
+      new Header("date", ""),
+      new Header("etag", ""),
+      new Header("expect", ""),
+      new Header("expires", ""),
+      new Header("from", ""),
+      new Header("host", ""),
+      new Header("if-match", ""),
+      new Header("if-modified-since", ""),
+      new Header("if-none-match", ""),
+      new Header("if-range", ""),
+      new Header("if-unmodified-since", ""),
+      new Header("last-modified", ""),
+      new Header("link", ""),
+      new Header("location", ""),
+      new Header("max-forwards", ""),
+      new Header("proxy-authenticate", ""),
+      new Header("proxy-authorization", ""),
+      new Header("range", ""),
+      new Header("referer", ""),
+      new Header("refresh", ""),
+      new Header("retry-after", ""),
+      new Header("server", ""),
+      new Header("set-cookie", ""),
+      new Header("strict-transport-security", ""),
+      new Header("transfer-encoding", ""),
+      new Header("user-agent", ""),
+      new Header("vary", ""),
+      new Header("via", ""),
+      new Header("www-authenticate", "")
+  };
+
+  private HpackDraft05() {
+  }
+
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.2
+  static final class Reader {
+    private final Huffman.Codec huffmanCodec;
+
+    private final InputStream in;
+    private final List<Header> emittedHeaders = new ArrayList<Header>();
+    private int maxHeaderTableByteCount;
+
+    // Visible for testing.
+    Header[] headerTable = new Header[8];
+    // Array is populated back to front, so new entries always have lowest index.
+    int nextHeaderIndex = headerTable.length - 1;
+    int headerCount = 0;
+
+    /**
+     * Set bit positions indicate {@code headerTable[pos]} should be emitted.
+     */
+    // Using a BitArray as it has left-shift operator.
+    BitArray referencedHeaders = new BitArray.FixedCapacity();
+
+    /**
+     * Set bit positions indicate {@code STATIC_HEADER_TABLE[pos]} should be
+     * emitted.
+     */
+    // Using a long since the static table < 64 entries.
+    long referencedStaticHeaders = 0L;
+    int headerTableByteCount = 0;
+
+    Reader(boolean client, int maxHeaderTableByteCount, InputStream in) {
+      this.huffmanCodec = client ? Huffman.Codec.RESPONSE : Huffman.Codec.REQUEST;
+      this.maxHeaderTableByteCount = maxHeaderTableByteCount;
+      this.in = in;
+    }
+
+    int maxHeaderTableByteCount() {
+      return maxHeaderTableByteCount;
+    }
+
+    /**
+     * Called by the reader when the peer sent a new header table size setting.
+     * <p>
+     * Evicts entries or clears the table as needed.
+     */
+    void maxHeaderTableByteCount(int newMaxHeaderTableByteCount) {
+      this.maxHeaderTableByteCount = newMaxHeaderTableByteCount;
+      if (maxHeaderTableByteCount < headerTableByteCount) {
+        if (maxHeaderTableByteCount == 0) {
+          clearHeaderTable();
+        } else {
+          evictToRecoverBytes(headerTableByteCount - maxHeaderTableByteCount);
+        }
+      }
+    }
+
+    private void clearHeaderTable() {
+      clearReferenceSet();
+      Arrays.fill(headerTable, null);
+      nextHeaderIndex = headerTable.length - 1;
+      headerCount = 0;
+      headerTableByteCount = 0;
+    }
+
+    /** Returns the count of entries evicted. */
+    private int evictToRecoverBytes(int bytesToRecover) {
+      int entriesToEvict = 0;
+      if (bytesToRecover > 0) {
+        // determine how many headers need to be evicted.
+        for (int j = headerTable.length - 1; j >= nextHeaderIndex && bytesToRecover > 0; j--) {
+          bytesToRecover -= headerTable[j].hpackSize;
+          headerTableByteCount -= headerTable[j].hpackSize;
+          headerCount--;
+          entriesToEvict++;
+        }
+        referencedHeaders.shiftLeft(entriesToEvict);
+        System.arraycopy(headerTable, nextHeaderIndex + 1, headerTable,
+            nextHeaderIndex + 1 + entriesToEvict, headerCount);
+        nextHeaderIndex += entriesToEvict;
+      }
+      return entriesToEvict;
+    }
+
+    /**
+     * Read {@code byteCount} bytes of headers from the source stream into the
+     * set of emitted headers.
+     */
+    void readHeaders() throws IOException {
+      while (in.available() > 0) {
+        int b = in.read() & 0xff;
+        if (b == 0x80) { // 10000000
+          clearReferenceSet();
+        } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
+          int index = readInt(b, PREFIX_7_BITS);
+          readIndexedHeader(index - 1);
+        } else { // 0NNNNNNN
+          if (b == 0x40) { // 01000000
+            readLiteralHeaderWithoutIndexingNewName();
+          } else if ((b & 0x40) == 0x40) {  // 01NNNNNN
+            int index = readInt(b, PREFIX_6_BITS);
+            readLiteralHeaderWithoutIndexingIndexedName(index - 1);
+          } else if (b == 0) { // 00000000
+            readLiteralHeaderWithIncrementalIndexingNewName();
+          } else if ((b & 0xc0) == 0) { // 00NNNNNN
+            int index = readInt(b, PREFIX_6_BITS);
+            readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
+          } else {
+            // TODO: we should throw something that we can coerce to a PROTOCOL_ERROR
+            throw new AssertionError("unhandled byte: " + Integer.toBinaryString(b));
+          }
+        }
+      }
+    }
+
+    private void clearReferenceSet() {
+      referencedStaticHeaders = 0L;
+      referencedHeaders.clear();
+    }
+
+    void emitReferenceSet() {
+      for (int i = 0; i < STATIC_HEADER_TABLE.length; ++i) {
+        if (((referencedStaticHeaders >> i) & 1L) == 1) {
+          emittedHeaders.add(STATIC_HEADER_TABLE[i]);
+        }
+      }
+      for (int i = headerTable.length - 1; i != nextHeaderIndex; --i) {
+        if (referencedHeaders.get(i)) {
+          emittedHeaders.add(headerTable[i]);
+        }
+      }
+    }
+
+    /**
+     * Returns all headers emitted since they were last cleared, then clears the
+     * emitted headers.
+     */
+    List<Header> getAndReset() {
+      List<Header> result = new ArrayList<Header>(emittedHeaders);
+      emittedHeaders.clear();
+      return result;
+    }
+
+    private void readIndexedHeader(int index) {
+      if (isStaticHeader(index)) {
+        if (maxHeaderTableByteCount == 0) {
+          referencedStaticHeaders |= (1L << (index - headerCount));
+        } else {
+          Header staticEntry = STATIC_HEADER_TABLE[index - headerCount];
+          insertIntoHeaderTable(-1, staticEntry);
+        }
+      } else {
+        referencedHeaders.toggle(headerTableIndex(index));
+      }
+    }
+
+    // referencedHeaders is relative to nextHeaderIndex + 1.
+    private int headerTableIndex(int index) {
+      return nextHeaderIndex + 1 + index;
+    }
+
+    private void readLiteralHeaderWithoutIndexingIndexedName(int index) throws IOException {
+      ByteString name = getName(index);
+      ByteString value = readByteString(false);
+      emittedHeaders.add(new Header(name, value));
+    }
+
+    private void readLiteralHeaderWithoutIndexingNewName() throws IOException {
+      ByteString name = readByteString(true);
+      ByteString value = readByteString(false);
+      emittedHeaders.add(new Header(name, value));
+    }
+
+    private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
+        throws IOException {
+      ByteString name = getName(nameIndex);
+      ByteString value = readByteString(false);
+      insertIntoHeaderTable(-1, new Header(name, value));
+    }
+
+    private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
+      ByteString name = readByteString(true);
+      ByteString value = readByteString(false);
+      insertIntoHeaderTable(-1, new Header(name, value));
+    }
+
+    private ByteString getName(int index) {
+      if (isStaticHeader(index)) {
+        return STATIC_HEADER_TABLE[index - headerCount].name;
+      } else {
+        return headerTable[headerTableIndex(index)].name;
+      }
+    }
+
+    private boolean isStaticHeader(int index) {
+      return index >= headerCount;
+    }
+
+    /** index == -1 when new. */
+    private void insertIntoHeaderTable(int index, Header entry) {
+      int delta = entry.hpackSize;
+      if (index != -1) { // Index -1 == new header.
+        delta -= headerTable[headerTableIndex(index)].hpackSize;
+      }
+
+      // if the new or replacement header is too big, drop all entries.
+      if (delta > maxHeaderTableByteCount) {
+        clearHeaderTable();
+        // emit the large header to the callback.
+        emittedHeaders.add(entry);
+        return;
+      }
+
+      // Evict headers to the required length.
+      int bytesToRecover = (headerTableByteCount + delta) - maxHeaderTableByteCount;
+      int entriesEvicted = evictToRecoverBytes(bytesToRecover);
+
+      if (index == -1) {
+        if (headerCount + 1 > headerTable.length) {
+          Header[] doubled = new Header[headerTable.length * 2];
+          System.arraycopy(headerTable, 0, doubled, headerTable.length, headerTable.length);
+          if (doubled.length == 64) {
+            referencedHeaders = ((BitArray.FixedCapacity) referencedHeaders).toVariableCapacity();
+          }
+          referencedHeaders.shiftLeft(headerTable.length);
+          nextHeaderIndex = headerTable.length - 1;
+          headerTable = doubled;
+        }
+        index = nextHeaderIndex--;
+        referencedHeaders.set(index);
+        headerTable[index] = entry;
+        headerCount++;
+      } else { // Replace value at same position.
+        index += headerTableIndex(index) + entriesEvicted;
+        referencedHeaders.set(index);
+        headerTable[index] = entry;
+      }
+      headerTableByteCount += delta;
+    }
+
+    private int readByte() throws IOException {
+      return in.read() & 0xff;
+    }
+
+    int readInt(int firstByte, int prefixMask) throws IOException {
+      int prefix = firstByte & prefixMask;
+      if (prefix < prefixMask) {
+        return prefix; // This was a single byte value.
+      }
+
+      // This is a multibyte value. Read 7 bits at a time.
+      int result = prefixMask;
+      int shift = 0;
+      while (true) {
+        int b = readByte();
+        if ((b & 0x80) != 0) { // Equivalent to (b >= 128) since b is in [0..255].
+          result += (b & 0x7f) << shift;
+          shift += 7;
+        } else {
+          result += b << shift; // Last byte.
+          break;
+        }
+      }
+      return result;
+    }
+
+    /**
+     * Reads a potentially Huffman encoded string byte string. When
+     * {@code asciiLowercase} is true, bytes will be converted to lowercase.
+     */
+    ByteString readByteString(boolean asciiLowercase) throws IOException {
+      int firstByte = readByte();
+      int length = readInt(firstByte, PREFIX_8_BITS);
+      if ((length & 0x80) == 0x80) { // 1NNNNNNN
+        length &= ~0x80;
+        byte[] buff = new byte[length];
+        Util.readFully(in, buff);
+        buff = huffmanCodec.decode(buff); // TODO: streaming Huffman!
+        if (asciiLowercase) asciiLowerCase(buff);
+        return ByteString.of(buff);
+      }
+      return length == 0 ? ByteString.EMPTY
+          : asciiLowercase ? ByteString.readLowerCase(in, length) : ByteString.read(in, length);
+    }
+  }
+
+  private static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
+
+  private static Map<ByteString, Integer> nameToFirstIndex() {
+    Map<ByteString, Integer> result =
+        new LinkedHashMap<ByteString, Integer>(STATIC_HEADER_TABLE.length);
+    for (int i = 0; i < STATIC_HEADER_TABLE.length; i++) {
+      if (!result.containsKey(STATIC_HEADER_TABLE[i].name)) {
+        result.put(STATIC_HEADER_TABLE[i].name, i);
+      }
+    }
+    return Collections.unmodifiableMap(result);
+  }
+
+  static final class Writer {
+    private final OutputStream out;
+
+    Writer(OutputStream out) {
+      this.out = out;
+    }
+
+    void writeHeaders(List<Header> headerBlock) throws IOException {
+      // TODO: implement index tracking
+      for (int i = 0, size = headerBlock.size(); i < size; i++) {
+        ByteString name = headerBlock.get(i).name;
+        Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);
+        if (staticIndex != null) {
+          // Literal Header Field without Indexing - Indexed Name.
+          writeInt(staticIndex + 1, PREFIX_6_BITS, 0x40);
+          writeByteString(headerBlock.get(i).value);
+        } else {
+          out.write(0x40); // Literal Header without Indexing - New Name.
+          writeByteString(name);
+          writeByteString(headerBlock.get(i).value);
+        }
+      }
+    }
+
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.1
+    void writeInt(int value, int prefixMask, int bits) throws IOException {
+      // Write the raw value for a single byte value.
+      if (value < prefixMask) {
+        out.write(bits | value);
+        return;
+      }
+
+      // Write the mask to start a multibyte value.
+      out.write(bits | prefixMask);
+      value -= prefixMask;
+
+      // Write 7 bits at a time 'til we're done.
+      while (value >= 0x80) {
+        int b = value & 0x7f;
+        out.write(b | 0x80);
+        value >>>= 7;
+      }
+      out.write(value);
+    }
+
+    void writeByteString(ByteString data) throws IOException {
+      writeInt(data.size(), PREFIX_8_BITS, 0);
+      data.write(out);
+    }
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft04.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft04.java
deleted file mode 100644
index 1d48defe51..0000000000
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft04.java
+++ /dev/null
@@ -1,371 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.spdy;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
-import java.util.Arrays;
-import java.util.List;
-
-final class Http20Draft04 implements Variant {
-  private static final byte[] CONNECTION_HEADER;
-  static {
-    try {
-      CONNECTION_HEADER = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n".getBytes("UTF-8");
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
-  }
-
-  static final int TYPE_DATA = 0x0;
-  static final int TYPE_HEADERS = 0x1;
-  static final int TYPE_PRIORITY = 0x2;
-  static final int TYPE_RST_STREAM = 0x3;
-  static final int TYPE_SETTINGS = 0x4;
-  static final int TYPE_PUSH_PROMISE = 0x5;
-  static final int TYPE_PING = 0x6;
-  static final int TYPE_GOAWAY = 0x7;
-  static final int TYPE_WINDOW_UPDATE = 0x9;
-
-  static final int FLAG_END_STREAM = 0x1;
-  static final int FLAG_END_HEADERS = 0x4;
-  static final int FLAG_PRIORITY = 0x8;
-  static final int FLAG_PONG = 0x1;
-  static final int FLAG_END_FLOW_CONTROL = 0x1;
-
-  @Override public FrameReader newReader(InputStream in, boolean client) {
-    return new Reader(in, client);
-  }
-
-  @Override public FrameWriter newWriter(OutputStream out, boolean client) {
-    return new Writer(out, client);
-  }
-
-  static final class Reader implements FrameReader {
-    private final DataInputStream in;
-    private final boolean client;
-    private final Hpack.Reader hpackReader;
-
-    Reader(InputStream in, boolean client) {
-      this.in = new DataInputStream(in);
-      this.client = client;
-      this.hpackReader = new Hpack.Reader(this.in, client);
-    }
-
-    @Override public void readConnectionHeader() throws IOException {
-      if (client) return; // Nothing to read; servers don't send connection headers!
-      byte[] connectionHeader = new byte[CONNECTION_HEADER.length];
-      in.readFully(connectionHeader);
-      if (!Arrays.equals(connectionHeader, CONNECTION_HEADER)) {
-        throw ioException("Expected a connection header but was "
-            + Arrays.toString(connectionHeader));
-      }
-    }
-
-    @Override public boolean nextFrame(Handler handler) throws IOException {
-      int w1;
-      try {
-        w1 = in.readInt();
-      } catch (IOException e) {
-        return false; // This might be a normal socket close.
-      }
-      int w2 = in.readInt();
-
-      int length = (w1 & 0xffff0000) >> 16;
-      int type = (w1 & 0xff00) >> 8;
-      int flags = w1 & 0xff;
-      // boolean r = (w2 & 0x80000000) != 0; // Reserved.
-      int streamId = (w2 & 0x7fffffff);
-
-      switch (type) {
-        case TYPE_DATA:
-          readData(handler, flags, length, streamId);
-          return true;
-
-        case TYPE_HEADERS:
-          readHeaders(handler, flags, length, streamId);
-          return true;
-
-        case TYPE_PRIORITY:
-          readPriority(handler, flags, length, streamId);
-          return true;
-
-        case TYPE_RST_STREAM:
-          readRstStream(handler, flags, length, streamId);
-          return true;
-
-        case TYPE_SETTINGS:
-          readSettings(handler, flags, length, streamId);
-          return true;
-
-        case TYPE_PUSH_PROMISE:
-          readPushPromise(handler, flags, length, streamId);
-          return true;
-
-        case TYPE_PING:
-          readPing(handler, flags, length, streamId);
-          return true;
-
-        case TYPE_GOAWAY:
-          readGoAway(handler, flags, length, streamId);
-          return true;
-
-        case TYPE_WINDOW_UPDATE:
-          readWindowUpdate(handler, flags, length, streamId);
-          return true;
-      }
-
-      throw new UnsupportedOperationException("TODO");
-    }
-
-    private void readHeaders(Handler handler, int flags, int length, int streamId)
-        throws IOException {
-      if (streamId == 0) throw ioException("TYPE_HEADERS streamId == 0");
-
-      while (true) {
-        hpackReader.readHeaders(length);
-
-        if ((flags & FLAG_END_HEADERS) != 0) {
-          hpackReader.emitReferenceSet();
-          List<String> namesAndValues = hpackReader.getAndReset();
-          boolean inFinished = (flags & FLAG_END_STREAM) != 0;
-          int priority = -1; // TODO: priority
-          handler.headers(false, inFinished, streamId, -1, priority, namesAndValues,
-              HeadersMode.HTTP_20_HEADERS);
-          return;
-        }
-
-        // Read another frame of headers.
-        int w1 = in.readInt();
-        int w2 = in.readInt();
-
-        length = (w1 & 0xffff0000) >> 16;
-        int newType = (w1 & 0xff00) >> 8;
-        flags = w1 & 0xff;
-        // boolean r = (w2 & 0x80000000) != 0; // Reserved.
-        int newStreamId = (w2 & 0x7fffffff);
-
-        if (newType != TYPE_HEADERS) throw ioException("TYPE_HEADERS didn't have FLAG_END_HEADERS");
-        if (newStreamId != streamId) throw ioException("TYPE_HEADERS streamId changed");
-      }
-    }
-
-    private void readData(Handler handler, int flags, int length, int streamId) throws IOException {
-      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
-      handler.data(inFinished, streamId, in, length);
-    }
-
-    private void readPriority(Handler handler, int flags, int length, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_PRIORITY length: %d != 4", length);
-      if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
-      int w1 = in.readInt();
-      // boolean r = (w1 & 0x80000000) != 0; // Reserved.
-      int priority = (w1 & 0x7fffffff);
-      handler.priority(streamId, priority);
-    }
-
-    private void readRstStream(Handler handler, int flags, int length, int streamId)
-        throws IOException {
-      if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
-      if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
-      int errorCodeInt = in.readInt();
-      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
-      }
-      handler.rstStream(streamId, errorCode);
-    }
-
-    private void readSettings(Handler handler, int flags, int length, int streamId)
-        throws IOException {
-      if (length % 8 != 0) throw ioException("TYPE_SETTINGS length %% 8 != 0: %s", length);
-      if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
-      Settings settings = new Settings();
-      for (int i = 0; i < length; i += 8) {
-        int w1 = in.readInt();
-        int value = in.readInt();
-        // int r = (w1 & 0xff000000) >>> 24; // Reserved.
-        int id = w1 & 0xffffff;
-        settings.set(id, 0, value);
-      }
-      handler.settings(false, settings);
-    }
-
-    private void readPushPromise(Handler handler, int flags, int length, int streamId) {
-      // TODO:
-    }
-
-    private void readPing(Handler handler, int flags, int length, int streamId) throws IOException {
-      if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
-      if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
-      int payload1 = in.readInt();
-      int payload2 = in.readInt();
-      boolean reply = (flags & FLAG_PONG) != 0;
-      handler.ping(reply, payload1, payload2);
-    }
-
-    private void readGoAway(Handler handler, int flags, int length, int streamId)
-        throws IOException {
-      if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
-      int lastStreamId = in.readInt();
-      int errorCodeInt = in.readInt();
-      int opaqueDataLength = length - 8;
-      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
-      if (errorCode == null) {
-        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
-      }
-      if (Util.skipByReading(in, opaqueDataLength) != opaqueDataLength) {
-        throw new IOException("TYPE_GOAWAY opaque data was truncated");
-      }
-      handler.goAway(lastStreamId, errorCode);
-    }
-
-    private void readWindowUpdate(Handler handler, int flags, int length, int streamId)
-        throws IOException {
-      int w1 = in.readInt();
-      // boolean r = (w1 & 0x80000000) != 0; // Reserved.
-      int windowSizeIncrement = (w1 & 0x7fffffff);
-      boolean endFlowControl = (flags & FLAG_END_FLOW_CONTROL) != 0;
-      handler.windowUpdate(streamId, windowSizeIncrement, endFlowControl);
-    }
-
-    private static IOException ioException(String message, Object... args) throws IOException {
-      throw new IOException(String.format(message, args));
-    }
-
-    @Override public void close() throws IOException {
-      in.close();
-    }
-  }
-
-  static final class Writer implements FrameWriter {
-    private final DataOutputStream out;
-    private final boolean client;
-    private final ByteArrayOutputStream hpackBuffer;
-    private final Hpack.Writer hpackWriter;
-
-    Writer(OutputStream out, boolean client) {
-      this.out = new DataOutputStream(out);
-      this.client = client;
-      this.hpackBuffer = new ByteArrayOutputStream();
-      this.hpackWriter = new Hpack.Writer(hpackBuffer);
-    }
-
-    @Override public synchronized void flush() throws IOException {
-      out.flush();
-    }
-
-    @Override public synchronized void connectionHeader() throws IOException {
-      if (!client) return; // Nothing to write; servers don't send connection headers!
-      out.write(CONNECTION_HEADER);
-    }
-
-    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, int priority, int slot, List<String> nameValueBlock)
-        throws IOException {
-      if (inFinished) throw new UnsupportedOperationException();
-      headers(outFinished, streamId, priority, nameValueBlock);
-    }
-
-    @Override public synchronized void synReply(boolean outFinished, int streamId,
-        List<String> nameValueBlock) throws IOException {
-      headers(outFinished, streamId, -1, nameValueBlock);
-    }
-
-    @Override public synchronized void headers(int streamId, List<String> nameValueBlock)
-        throws IOException {
-      headers(false, streamId, -1, nameValueBlock);
-    }
-
-    private void headers(boolean outFinished, int streamId, int priority,
-        List<String> nameValueBlock) throws IOException {
-      hpackBuffer.reset();
-      hpackWriter.writeHeaders(nameValueBlock);
-      int type = TYPE_HEADERS;
-      int length = hpackBuffer.size();
-      int flags = FLAG_END_HEADERS;
-      if (outFinished) flags |= FLAG_END_STREAM;
-      if (priority != -1) flags |= FLAG_PRIORITY;
-      out.writeInt((length & 0xffff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
-      out.writeInt(streamId & 0x7fffffff);
-      if (priority != -1) out.writeInt(priority & 0x7fffffff);
-      hpackBuffer.writeTo(out);
-    }
-
-    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
-        throws IOException {
-      throw new UnsupportedOperationException("TODO");
-    }
-
-    @Override public void data(boolean outFinished, int streamId, byte[] data) throws IOException {
-      data(outFinished, streamId, data, 0, data.length);
-    }
-
-    @Override public synchronized void data(boolean outFinished, int streamId, byte[] data,
-        int offset, int byteCount) throws IOException {
-      int type = TYPE_DATA;
-      int flags = 0;
-      if (outFinished) flags |= FLAG_END_STREAM;
-      out.writeInt((byteCount & 0xffff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
-      out.writeInt(streamId & 0x7fffffff);
-      out.write(data, offset, byteCount);
-    }
-
-    @Override public synchronized void settings(Settings settings) throws IOException {
-      int type = TYPE_SETTINGS;
-      int length = settings.size() * 8;
-      int flags = 0;
-      int streamId = 0;
-      out.writeInt((length & 0xffff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
-      out.writeInt(streamId & 0x7fffffff);
-      for (int i = 0; i < Settings.COUNT; i++) {
-        if (!settings.isSet(i)) continue;
-        out.writeInt(i & 0xffffff);
-        out.writeInt(settings.get(i));
-      }
-    }
-
-    @Override public synchronized void noop() throws IOException {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public synchronized void ping(boolean reply, int payload1, int payload2)
-        throws IOException {
-      // TODO
-    }
-
-    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode)
-        throws IOException {
-      // TODO
-    }
-
-    @Override public synchronized void windowUpdate(int streamId, int deltaWindowSize)
-        throws IOException {
-      // TODO
-    }
-
-    @Override public void close() throws IOException {
-      out.close();
-    }
-  }
-}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
new file mode 100644
index 0000000000..0bc07a87bf
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -0,0 +1,563 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.Util;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Read and write http/2 v09 frames.
+ * http://tools.ietf.org/html/draft-ietf-httpbis-http2-09
+ */
+public final class Http20Draft09 implements Variant {
+
+  @Override public Protocol getProtocol() {
+    return Protocol.HTTP_2;
+  }
+
+  private static final byte[] CONNECTION_HEADER =
+      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n".getBytes(Util.UTF_8);
+
+  static final byte TYPE_DATA = 0x0;
+  static final byte TYPE_HEADERS = 0x1;
+  static final byte TYPE_PRIORITY = 0x2;
+  static final byte TYPE_RST_STREAM = 0x3;
+  static final byte TYPE_SETTINGS = 0x4;
+  static final byte TYPE_PUSH_PROMISE = 0x5;
+  static final byte TYPE_PING = 0x6;
+  static final byte TYPE_GOAWAY = 0x7;
+  static final byte TYPE_WINDOW_UPDATE = 0x9;
+  static final byte TYPE_CONTINUATION = 0xa;
+
+  static final byte FLAG_NONE = 0x0;
+  static final byte FLAG_ACK = 0x1;
+  static final byte FLAG_END_STREAM = 0x1;
+  static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
+  static final byte FLAG_END_PUSH_PROMISE = 0x4;
+  static final byte FLAG_PRIORITY = 0x8;
+
+  @Override public FrameReader newReader(InputStream in, boolean client) {
+    return new Reader(in, 4096, client);
+  }
+
+  @Override public FrameWriter newWriter(OutputStream out, boolean client) {
+    return new Writer(out, client);
+  }
+
+  static final class Reader implements FrameReader {
+    private final DataInputStream in;
+    private final ContinuationInputStream continuation;
+    private final boolean client;
+
+    // Visible for testing.
+    final HpackDraft05.Reader hpackReader;
+
+    Reader(InputStream in, int headerTableSize, boolean client) {
+      this.in = new DataInputStream(in);
+      this.client = client;
+      this.continuation = new ContinuationInputStream(this.in);
+      this.hpackReader = new HpackDraft05.Reader(client, headerTableSize, continuation);
+    }
+
+    @Override public void readConnectionHeader() throws IOException {
+      if (client) return; // Nothing to read; servers don't send connection headers!
+      byte[] connectionHeader = new byte[CONNECTION_HEADER.length];
+      Util.readFully(in, connectionHeader);
+      if (!Arrays.equals(connectionHeader, CONNECTION_HEADER)) {
+        throw ioException("Expected a connection header but was %s",
+            Arrays.toString(connectionHeader));
+      }
+    }
+
+    @Override public boolean nextFrame(Handler handler) throws IOException {
+      int w1;
+      try {
+        w1 = in.readInt();
+      } catch (IOException e) {
+        return false; // This might be a normal socket close.
+      }
+
+      int w2 = in.readInt();
+
+      // boolean r = (w1 & 0xc0000000) != 0; // Reserved: Ignore first 2 bits.
+      short length = (short) ((w1 & 0x3fff0000) >> 16); // 14-bit unsigned == max 16383
+      byte type = (byte) ((w1 & 0xff00) >> 8);
+      byte flags = (byte) (w1 & 0xff);
+      // boolean r = (w2 & 0x80000000) != 0; // Reserved: Ignore first bit.
+      int streamId = (w2 & 0x7fffffff); // 31-bit opaque identifier.
+
+      switch (type) {
+        case TYPE_DATA:
+          readData(handler, length, flags, streamId);
+          break;
+
+        case TYPE_HEADERS:
+          readHeaders(handler, length, flags, streamId);
+          break;
+
+        case TYPE_PRIORITY:
+          readPriority(handler, length, flags, streamId);
+          break;
+
+        case TYPE_RST_STREAM:
+          readRstStream(handler, length, flags, streamId);
+          break;
+
+        case TYPE_SETTINGS:
+          readSettings(handler, length, flags, streamId);
+          break;
+
+        case TYPE_PUSH_PROMISE:
+          readPushPromise(handler, length, flags, streamId);
+          break;
+
+        case TYPE_PING:
+          readPing(handler, length, flags, streamId);
+          break;
+
+        case TYPE_GOAWAY:
+          readGoAway(handler, length, flags, streamId);
+          break;
+
+        case TYPE_WINDOW_UPDATE:
+          readWindowUpdate(handler, length, flags, streamId);
+          break;
+
+        default:
+          // Implementations MUST ignore frames of unsupported or unrecognized types.
+          Util.skipByReading(in, length);
+      }
+      return true;
+    }
+
+    private void readHeaders(Handler handler, short length, byte flags, int streamId)
+        throws IOException {
+      if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_HEADERS streamId == 0");
+
+      boolean endStream = (flags & FLAG_END_STREAM) != 0;
+
+      int priority = -1;
+      if ((flags & FLAG_PRIORITY) != 0) {
+        priority = in.readInt() & 0x7fffffff;
+        length -= 4; // account for above read.
+      }
+
+      List<Header> headerBlock = readHeaderBlock(length, flags, streamId);
+
+      handler.headers(false, endStream, streamId, -1, priority, headerBlock,
+          HeadersMode.HTTP_20_HEADERS);
+    }
+
+    private List<Header> readHeaderBlock(short length, byte flags, int streamId)
+        throws IOException {
+      continuation.length = continuation.left = length;
+      continuation.flags = flags;
+      continuation.streamId = streamId;
+
+      hpackReader.readHeaders();
+      hpackReader.emitReferenceSet();
+      // TODO: Concat multi-value headers with 0x0, except COOKIE, which uses 0x3B, 0x20.
+      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
+      return hpackReader.getAndReset();
+    }
+
+    private void readData(Handler handler, short length, byte flags, int streamId)
+        throws IOException {
+      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
+      // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
+      handler.data(inFinished, streamId, in, length);
+    }
+
+    private void readPriority(Handler handler, short length, byte flags, int streamId)
+        throws IOException {
+      if (length != 4) throw ioException("TYPE_PRIORITY length: %d != 4", length);
+      if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
+      int w1 = in.readInt();
+      // boolean r = (w1 & 0x80000000) != 0; // Reserved.
+      int priority = (w1 & 0x7fffffff);
+      handler.priority(streamId, priority);
+    }
+
+    private void readRstStream(Handler handler, short length, byte flags, int streamId)
+        throws IOException {
+      if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
+      if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
+      int errorCodeInt = in.readInt();
+      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+      if (errorCode == null) {
+        throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
+      }
+      handler.rstStream(streamId, errorCode);
+    }
+
+    private void readSettings(Handler handler, short length, byte flags, int streamId)
+        throws IOException {
+      if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
+      if ((flags & FLAG_ACK) != 0) {
+        if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
+        handler.ackSettings();
+        return;
+      }
+
+      if (length % 8 != 0) throw ioException("TYPE_SETTINGS length %% 8 != 0: %s", length);
+      Settings settings = new Settings();
+      for (int i = 0; i < length; i += 8) {
+        int w1 = in.readInt();
+        int value = in.readInt();
+        // int r = (w1 & 0xff000000) >>> 24; // Reserved.
+        int id = w1 & 0xffffff;
+        settings.set(id, 0, value);
+      }
+      handler.settings(false, settings);
+      if (settings.getHeaderTableSize() >= 0) {
+        hpackReader.maxHeaderTableByteCount(settings.getHeaderTableSize());
+      }
+    }
+
+    private void readPushPromise(Handler handler, short length, byte flags, int streamId)
+        throws IOException {
+      if (streamId == 0) {
+        throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
+      }
+      int promisedStreamId = in.readInt() & 0x7fffffff;
+      length -= 4; // account for above read.
+      List<Header> headerBlock = readHeaderBlock(length, flags, streamId);
+      handler.pushPromise(streamId, promisedStreamId, headerBlock);
+    }
+
+    private void readPing(Handler handler, short length, byte flags, int streamId)
+        throws IOException {
+      if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
+      if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
+      int payload1 = in.readInt();
+      int payload2 = in.readInt();
+      boolean ack = (flags & FLAG_ACK) != 0;
+      handler.ping(ack, payload1, payload2);
+    }
+
+    private void readGoAway(Handler handler, short length, byte flags, int streamId)
+        throws IOException {
+      if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
+      if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
+      int lastStreamId = in.readInt();
+      int errorCodeInt = in.readInt();
+      int opaqueDataLength = length - 8;
+      ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
+      if (errorCode == null) {
+        throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
+      }
+      byte[] debugData = Util.EMPTY_BYTE_ARRAY;
+      if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
+        debugData = new byte[opaqueDataLength];
+        Util.readFully(in, debugData);
+      }
+      handler.goAway(lastStreamId, errorCode, debugData);
+    }
+
+    private void readWindowUpdate(Handler handler, short length, byte flags, int streamId)
+        throws IOException {
+      if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
+      long increment = (in.readInt() & 0x7fffffff);
+      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
+      handler.windowUpdate(streamId, increment);
+    }
+
+    @Override public void close() throws IOException {
+      in.close();
+    }
+  }
+
+  static final class Writer implements FrameWriter {
+    private final DataOutputStream out;
+    private final boolean client;
+    private final ByteArrayOutputStream hpackBuffer;
+    private final HpackDraft05.Writer hpackWriter;
+
+    Writer(OutputStream out, boolean client) {
+      this.out = new DataOutputStream(out);
+      this.client = client;
+      this.hpackBuffer = new ByteArrayOutputStream();
+      this.hpackWriter = new HpackDraft05.Writer(hpackBuffer);
+    }
+
+    @Override public synchronized void flush() throws IOException {
+      out.flush();
+    }
+
+    @Override public synchronized void ackSettings() throws IOException {
+      int length = 0;
+      byte type = TYPE_SETTINGS;
+      byte flags = FLAG_ACK;
+      int streamId = 0;
+      frameHeader(length, type, flags, streamId);
+    }
+
+    @Override public synchronized void connectionHeader() throws IOException {
+      if (!client) return; // Nothing to write; servers don't send connection headers!
+      out.write(CONNECTION_HEADER);
+      out.flush();
+    }
+
+    @Override
+    public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId,
+        int associatedStreamId, int priority, int slot, List<Header> headerBlock)
+        throws IOException {
+      if (inFinished) throw new UnsupportedOperationException();
+      headers(outFinished, streamId, priority, headerBlock);
+    }
+
+    @Override public synchronized void synReply(boolean outFinished, int streamId,
+        List<Header> headerBlock) throws IOException {
+      headers(outFinished, streamId, -1, headerBlock);
+    }
+
+    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
+        throws IOException {
+      headers(false, streamId, -1, headerBlock);
+    }
+
+    @Override
+    public synchronized void pushPromise(int streamId, int promisedStreamId,
+        List<Header> requestHeaders) throws IOException {
+      hpackBuffer.reset();
+      hpackWriter.writeHeaders(requestHeaders);
+
+      int length = 4 + hpackBuffer.size();
+      byte type = TYPE_PUSH_PROMISE;
+      byte flags = FLAG_END_HEADERS;
+      frameHeader(length, type, flags, streamId); // TODO: CONTINUATION
+      out.writeInt(promisedStreamId & 0x7fffffff);
+      hpackBuffer.writeTo(out);
+    }
+
+    private void headers(boolean outFinished, int streamId, int priority,
+        List<Header> headerBlock) throws IOException {
+      hpackBuffer.reset();
+      hpackWriter.writeHeaders(headerBlock);
+
+      int length = hpackBuffer.size();
+      byte type = TYPE_HEADERS;
+      byte flags = FLAG_END_HEADERS;
+      if (outFinished) flags |= FLAG_END_STREAM;
+      if (priority != -1) flags |= FLAG_PRIORITY;
+      if (priority != -1) length += 4;
+      frameHeader(length, type, flags, streamId); // TODO: CONTINUATION
+      if (priority != -1) out.writeInt(priority & 0x7fffffff);
+      hpackBuffer.writeTo(out);
+    }
+
+    @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
+        throws IOException {
+      if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
+
+      int length = 4;
+      byte type = TYPE_RST_STREAM;
+      byte flags = FLAG_NONE;
+      frameHeader(length, type, flags, streamId);
+      out.writeInt(errorCode.httpCode);
+      out.flush();
+    }
+
+    @Override public synchronized void data(boolean outFinished, int streamId, byte[] data)
+        throws IOException {
+      data(outFinished, streamId, data, 0, data.length);
+    }
+
+    @Override public synchronized void data(boolean outFinished, int streamId, byte[] data,
+        int offset, int byteCount) throws IOException {
+      byte flags = FLAG_NONE;
+      if (outFinished) flags |= FLAG_END_STREAM;
+      dataFrame(streamId, flags, data, offset, byteCount); // TODO: Implement looping strategy
+    }
+
+    void dataFrame(int streamId, byte flags, byte[] data, int offset, int length)
+        throws IOException {
+      byte type = TYPE_DATA;
+      frameHeader(length, type, flags, streamId);
+      out.write(data, offset, length);
+    }
+
+    @Override public synchronized void settings(Settings settings) throws IOException {
+      int length = settings.size() * 8;
+      byte type = TYPE_SETTINGS;
+      byte flags = FLAG_NONE;
+      int streamId = 0;
+      frameHeader(length, type, flags, streamId);
+      for (int i = 0; i < Settings.COUNT; i++) {
+        if (!settings.isSet(i)) continue;
+        out.writeInt(i & 0xffffff);
+        out.writeInt(settings.get(i));
+      }
+      out.flush();
+    }
+
+    @Override public synchronized void ping(boolean ack, int payload1, int payload2)
+        throws IOException {
+      int length = 8;
+      byte type = TYPE_PING;
+      byte flags = ack ? FLAG_ACK : FLAG_NONE;
+      int streamId = 0;
+      frameHeader(length, type, flags, streamId);
+      out.writeInt(payload1);
+      out.writeInt(payload2);
+      out.flush();
+    }
+
+    @Override
+    public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+        throws IOException {
+      if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
+      int length = 8 + debugData.length;
+      byte type = TYPE_GOAWAY;
+      byte flags = FLAG_NONE;
+      int streamId = 0;
+      frameHeader(length, type, flags, streamId);
+      out.writeInt(lastGoodStreamId);
+      out.writeInt(errorCode.httpCode);
+      if (debugData.length > 0) {
+        out.write(debugData);
+      }
+      out.flush();
+    }
+
+    @Override public synchronized void windowUpdate(int streamId, long windowSizeIncrement)
+        throws IOException {
+      if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
+        throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
+            windowSizeIncrement);
+      }
+      int length = 4;
+      byte type = TYPE_WINDOW_UPDATE;
+      byte flags = FLAG_NONE;
+      frameHeader(length, type, flags, streamId);
+      out.writeInt((int) windowSizeIncrement);
+      out.flush();
+    }
+
+    @Override public void close() throws IOException {
+      out.close();
+    }
+
+    void frameHeader(int length, byte type, byte flags, int streamId) throws IOException {
+      if (length > 16383) throw illegalArgument("FRAME_SIZE_ERROR length > 16383: %s", length);
+      if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
+      out.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
+      out.writeInt(streamId & 0x7fffffff);
+    }
+  }
+
+  private static IllegalArgumentException illegalArgument(String message, Object... args) {
+    throw new IllegalArgumentException(String.format(message, args));
+  }
+
+  private static IOException ioException(String message, Object... args) throws IOException {
+    throw new IOException(String.format(message, args));
+  }
+
+  /**
+   * Decompression of the header block occurs above the framing layer.  This class lazily reads
+   * continuation frames as they are needed by {@link HpackDraft05.Reader#readHeaders()}.
+   */
+  static final class ContinuationInputStream extends InputStream {
+    private final DataInputStream in;
+
+    int length;
+    byte flags;
+    int streamId;
+
+    int left;
+
+    ContinuationInputStream(DataInputStream in) {
+      this.in = in;
+    }
+
+    @Override public int read() throws IOException {
+      if (left == 0) {
+        if (endHeaders()) {
+          throw eofReading(1);
+        } else {
+          readContinuationHeader();
+        }
+      }
+      left--;
+      return in.read();
+    }
+
+    @Override public int available() throws IOException {
+      if (left == 0) {
+        if (endHeaders()) {
+          return 0;
+        } else {
+          readContinuationHeader();
+        }
+      }
+      return left;
+    }
+
+    @Override public int read(byte[] dst, int offset, int byteCount) throws IOException {
+      if (byteCount > left) {
+        if (endHeaders()) {
+          throw eofReading(byteCount);
+        } else {
+          int beforeContinuation = left;
+          Util.readFully(in, dst, offset, beforeContinuation);
+          readContinuationHeader();
+          int afterContinuation = byteCount - beforeContinuation;
+          offset += beforeContinuation;
+          Util.readFully(in, dst, offset, afterContinuation);
+          left -= afterContinuation;
+          return byteCount;
+        }
+      } else {
+        Util.readFully(in, dst, offset, byteCount);
+        left -= byteCount;
+        return byteCount;
+      }
+    }
+
+    private EOFException eofReading(int byteCount) throws EOFException {
+      int read = length - left;
+      throw new EOFException(
+          String.format("EOF reading %s more bytes; read %s/%s of frame.", byteCount, read,
+              length));
+    }
+
+    private void readContinuationHeader() throws IOException {
+      int previousStreamId = streamId;
+      int w1 = in.readInt();
+      int w2 = in.readInt();
+      length = left = (short) ((w1 & 0x3fff0000) >> 16);
+      byte type = (byte) ((w1 & 0xff00) >> 8);
+      flags = (byte) (w1 & 0xff);
+      streamId = (w2 & 0x7fffffff);
+      if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
+      if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
+    }
+
+    private boolean endHeaders() {
+      return (flags & FLAG_END_HEADERS) != 0;
+    }
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
new file mode 100644
index 0000000000..a7768d0ae3
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
@@ -0,0 +1,279 @@
+/*
+ * Copyright 2013 Twitter, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * This class was originally composed from the following classes in
+ * <a href="https://github.com/twitter/hpack">Twitter Hpack</a>.
+ * <ul>
+ * <li>{@code com.twitter.hpack.HuffmanEncoder}</li>
+ * <li>{@code com.twitter.hpack.HuffmanDecoder}</li>
+ * <li>{@code com.twitter.hpack.HpackUtil}</li>
+ * </ul>
+ */
+class Huffman {
+  enum Codec {
+    REQUEST(REQUEST_CODES, REQUEST_CODE_LENGTHS),
+    RESPONSE(RESPONSE_CODES, RESPONSE_CODE_LENGTHS);
+
+    private final Node root = new Node();
+    private final int[] codes;
+    private final byte[] lengths;
+
+    /**
+     * @param codes Index designates the symbol this code represents.
+     * @param lengths Index designates the symbol this code represents.
+     */
+    Codec(int[] codes, byte[] lengths) {
+      buildTree(codes, lengths);
+      this.codes = codes;
+      this.lengths = lengths;
+    }
+
+    void encode(byte[] data, OutputStream out) throws IOException {
+      long current = 0;
+      int n = 0;
+
+      for (int i = 0; i < data.length; i++) {
+        int b = data[i] & 0xFF;
+        int code = codes[b];
+        int nbits = lengths[b];
+
+        current <<= nbits;
+        current |= code;
+        n += nbits;
+
+        while (n >= 8) {
+          n -= 8;
+          out.write(((int) (current >> n)));
+        }
+      }
+
+      if (n > 0) {
+        current <<= (8 - n);
+        current |= (0xFF >>> n);
+        out.write((int) current);
+      }
+    }
+
+    int encodedLength(byte[] bytes) {
+      long len = 0;
+
+      for (int i = 0; i < bytes.length; i++) {
+        int b = bytes[i] & 0xFF;
+        len += lengths[b];
+      }
+
+      return (int) ((len + 7) >> 3);
+    }
+
+    byte[] decode(byte[] buf) throws IOException {
+      // FIXME
+      ByteArrayOutputStream baos = new ByteArrayOutputStream();
+      Node node = root;
+      int current = 0;
+      int nbits = 0;
+      for (int i = 0; i < buf.length; i++) {
+        int b = buf[i] & 0xFF;
+        current = (current << 8) | b;
+        nbits += 8;
+        while (nbits >= 8) {
+          int c = (current >>> (nbits - 8)) & 0xFF;
+          node = node.children[c];
+          if (node.children == null) {
+            // terminal node
+            baos.write(node.symbol);
+            nbits -= node.terminalBits;
+            node = root;
+          } else {
+            // non-terminal node
+            nbits -= 8;
+          }
+        }
+      }
+
+      while (nbits > 0) {
+        int c = (current << (8 - nbits)) & 0xFF;
+        node = node.children[c];
+        if (node.children != null || node.terminalBits > nbits) {
+          break;
+        }
+        baos.write(node.symbol);
+        nbits -= node.terminalBits;
+        node = root;
+      }
+
+      return baos.toByteArray();
+    }
+
+    private void buildTree(int[] codes, byte[] lengths) {
+      for (int i = 0; i < lengths.length; i++) {
+        addCode(i, codes[i], lengths[i]);
+      }
+    }
+
+    private void addCode(int sym, int code, byte len) {
+      Node terminal = new Node(sym, len);
+
+      Node current = root;
+      while (len > 8) {
+        len -= 8;
+        int i = ((code >>> len) & 0xFF);
+        if (current.children == null) {
+          throw new IllegalStateException("invalid dictionary: prefix not unique");
+        }
+        if (current.children[i] == null) {
+          current.children[i] = new Node();
+        }
+        current = current.children[i];
+      }
+
+      int shift = 8 - len;
+      int start = (code << shift) & 0xFF;
+      int end = 1 << shift;
+      for (int i = start; i < start + end; i++) {
+        current.children[i] = terminal;
+      }
+    }
+  }
+
+  private static final class Node {
+
+    // Null if terminal.
+    private final Node[] children;
+
+    // Terminal nodes have a symbol.
+    private final int symbol;
+
+    // Number of bits represented in the terminal node.
+    private final int terminalBits;
+
+    /** Construct an internal node. */
+    Node() {
+      this.children = new Node[256];
+      this.symbol = 0; // Not read.
+      this.terminalBits = 0; // Not read.
+    }
+
+    /**
+     * Construct a terminal node.
+     *
+     * @param symbol symbol the node represents
+     * @param bits length of Huffman code in bits
+     */
+    Node(int symbol, int bits) {
+      this.children = null;
+      this.symbol = symbol;
+      int b = bits & 0x07;
+      this.terminalBits = b == 0 ? 8 : b;
+    }
+  }
+
+  // Appendix C: Huffman Codes For Requests
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-C
+  private static final int[] REQUEST_CODES = {
+      0x7ffffba, 0x7ffffbb, 0x7ffffbc, 0x7ffffbd, 0x7ffffbe, 0x7ffffbf, 0x7ffffc0, 0x7ffffc1,
+      0x7ffffc2, 0x7ffffc3, 0x7ffffc4, 0x7ffffc5, 0x7ffffc6, 0x7ffffc7, 0x7ffffc8, 0x7ffffc9,
+      0x7ffffca, 0x7ffffcb, 0x7ffffcc, 0x7ffffcd, 0x7ffffce, 0x7ffffcf, 0x7ffffd0, 0x7ffffd1,
+      0x7ffffd2, 0x7ffffd3, 0x7ffffd4, 0x7ffffd5, 0x7ffffd6, 0x7ffffd7, 0x7ffffd8, 0x7ffffd9, 0xe8,
+      0xffc, 0x3ffa, 0x7ffc, 0x7ffd, 0x24, 0x6e, 0x7ffe, 0x7fa, 0x7fb, 0x3fa, 0x7fc, 0xe9, 0x25,
+      0x4, 0x0, 0x5, 0x6, 0x7, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x1ec, 0xea, 0x3fffe, 0x2d,
+      0x1fffc, 0x1ed, 0x3ffb, 0x6f, 0xeb, 0xec, 0xed, 0xee, 0x70, 0x1ee, 0x1ef, 0x1f0, 0x1f1, 0x3fb,
+      0x1f2, 0xef, 0x1f3, 0x1f4, 0x1f5, 0x1f6, 0x1f7, 0xf0, 0xf1, 0x1f8, 0x1f9, 0x1fa, 0x1fb, 0x1fc,
+      0x3fc, 0x3ffc, 0x7ffffda, 0x1ffc, 0x3ffd, 0x2e, 0x7fffe, 0x8, 0x2f, 0x9, 0x30, 0x1, 0x31,
+      0x32, 0x33, 0xa, 0x71, 0x72, 0xb, 0x34, 0xc, 0xd, 0xe, 0xf2, 0xf, 0x10, 0x11, 0x35, 0x73,
+      0x36, 0xf3, 0xf4, 0xf5, 0x1fffd, 0x7fd, 0x1fffe, 0xffd, 0x7ffffdb, 0x7ffffdc, 0x7ffffdd,
+      0x7ffffde, 0x7ffffdf, 0x7ffffe0, 0x7ffffe1, 0x7ffffe2, 0x7ffffe3, 0x7ffffe4, 0x7ffffe5,
+      0x7ffffe6, 0x7ffffe7, 0x7ffffe8, 0x7ffffe9, 0x7ffffea, 0x7ffffeb, 0x7ffffec, 0x7ffffed,
+      0x7ffffee, 0x7ffffef, 0x7fffff0, 0x7fffff1, 0x7fffff2, 0x7fffff3, 0x7fffff4, 0x7fffff5,
+      0x7fffff6, 0x7fffff7, 0x7fffff8, 0x7fffff9, 0x7fffffa, 0x7fffffb, 0x7fffffc, 0x7fffffd,
+      0x7fffffe, 0x7ffffff, 0x3ffff80, 0x3ffff81, 0x3ffff82, 0x3ffff83, 0x3ffff84, 0x3ffff85,
+      0x3ffff86, 0x3ffff87, 0x3ffff88, 0x3ffff89, 0x3ffff8a, 0x3ffff8b, 0x3ffff8c, 0x3ffff8d,
+      0x3ffff8e, 0x3ffff8f, 0x3ffff90, 0x3ffff91, 0x3ffff92, 0x3ffff93, 0x3ffff94, 0x3ffff95,
+      0x3ffff96, 0x3ffff97, 0x3ffff98, 0x3ffff99, 0x3ffff9a, 0x3ffff9b, 0x3ffff9c, 0x3ffff9d,
+      0x3ffff9e, 0x3ffff9f, 0x3ffffa0, 0x3ffffa1, 0x3ffffa2, 0x3ffffa3, 0x3ffffa4, 0x3ffffa5,
+      0x3ffffa6, 0x3ffffa7, 0x3ffffa8, 0x3ffffa9, 0x3ffffaa, 0x3ffffab, 0x3ffffac, 0x3ffffad,
+      0x3ffffae, 0x3ffffaf, 0x3ffffb0, 0x3ffffb1, 0x3ffffb2, 0x3ffffb3, 0x3ffffb4, 0x3ffffb5,
+      0x3ffffb6, 0x3ffffb7, 0x3ffffb8, 0x3ffffb9, 0x3ffffba, 0x3ffffbb, 0x3ffffbc, 0x3ffffbd,
+      0x3ffffbe, 0x3ffffbf, 0x3ffffc0, 0x3ffffc1, 0x3ffffc2, 0x3ffffc3, 0x3ffffc4, 0x3ffffc5,
+      0x3ffffc6, 0x3ffffc7, 0x3ffffc8, 0x3ffffc9, 0x3ffffca, 0x3ffffcb, 0x3ffffcc, 0x3ffffcd,
+      0x3ffffce, 0x3ffffcf, 0x3ffffd0, 0x3ffffd1, 0x3ffffd2, 0x3ffffd3, 0x3ffffd4, 0x3ffffd5,
+      0x3ffffd6, 0x3ffffd7, 0x3ffffd8, 0x3ffffd9, 0x3ffffda, 0x3ffffdb
+  };
+
+  private static final byte[] REQUEST_CODE_LENGTHS = {
+      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+      27, 27, 27, 27, 27, 27, 27, 27, 27, 8, 12, 14, 15, 15, 6, 7, 15, 11, 11, 10, 11, 8, 6, 5, 4,
+      5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 9, 8, 18, 6, 17, 9, 14, 7, 8, 8, 8, 8, 7, 9, 9, 9, 9, 10, 9, 8,
+      9, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9, 9, 10, 14, 27, 13, 14, 6, 19, 5, 6, 5, 6, 4, 6, 6, 6, 5, 7,
+      7, 5, 6, 5, 5, 5, 8, 5, 5, 5, 6, 7, 6, 8, 8, 8, 17, 11, 17, 12, 27, 27, 27, 27, 27, 27, 27,
+      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+      27, 27, 27, 27, 27, 27, 27, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+      26, 26, 26, 26, 26, 26, 26
+  };
+
+  // Appendix D: Huffman Codes For Responses
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-D
+  private static final int[] RESPONSE_CODES = {
+      0x1ffffbc, 0x1ffffbd, 0x1ffffbe, 0x1ffffbf, 0x1ffffc0, 0x1ffffc1, 0x1ffffc2, 0x1ffffc3,
+      0x1ffffc4, 0x1ffffc5, 0x1ffffc6, 0x1ffffc7, 0x1ffffc8, 0x1ffffc9, 0x1ffffca, 0x1ffffcb,
+      0x1ffffcc, 0x1ffffcd, 0x1ffffce, 0x1ffffcf, 0x1ffffd0, 0x1ffffd1, 0x1ffffd2, 0x1ffffd3,
+      0x1ffffd4, 0x1ffffd5, 0x1ffffd6, 0x1ffffd7, 0x1ffffd8, 0x1ffffd9, 0x1ffffda, 0x1ffffdb, 0x0,
+      0xffa, 0x6a, 0x1ffa, 0x3ffc, 0x1ec, 0x3f8, 0x1ffb, 0x1ed, 0x1ee, 0xffb, 0x7fa, 0x22, 0x23,
+      0x24, 0x6b, 0x1, 0x2, 0x3, 0x8, 0x9, 0xa, 0x25, 0x26, 0xb, 0xc, 0xd, 0x1ef, 0xfffa, 0x6c,
+      0x1ffc, 0xffc, 0xfffb, 0x6d, 0xea, 0xeb, 0xec, 0xed, 0xee, 0x27, 0x1f0, 0xef, 0xf0, 0x3f9,
+      0x1f1, 0x28, 0xf1, 0xf2, 0x1f2, 0x3fa, 0x1f3, 0x29, 0xe, 0x1f4, 0x1f5, 0xf3, 0x3fb, 0x1f6,
+      0x3fc, 0x7fb, 0x1ffd, 0x7fc, 0x7ffc, 0x1f7, 0x1fffe, 0xf, 0x6e, 0x2a, 0x2b, 0x10, 0x6f, 0x70,
+      0x71, 0x2c, 0x1f8, 0x1f9, 0x72, 0x2d, 0x2e, 0x2f, 0x30, 0x1fa, 0x31, 0x32, 0x33, 0x34, 0x73,
+      0xf4, 0x74, 0xf5, 0x1fb, 0xfffc, 0x3ffd, 0xfffd, 0xfffe, 0x1ffffdc, 0x1ffffdd, 0x1ffffde,
+      0x1ffffdf, 0x1ffffe0, 0x1ffffe1, 0x1ffffe2, 0x1ffffe3, 0x1ffffe4, 0x1ffffe5, 0x1ffffe6,
+      0x1ffffe7, 0x1ffffe8, 0x1ffffe9, 0x1ffffea, 0x1ffffeb, 0x1ffffec, 0x1ffffed, 0x1ffffee,
+      0x1ffffef, 0x1fffff0, 0x1fffff1, 0x1fffff2, 0x1fffff3, 0x1fffff4, 0x1fffff5, 0x1fffff6,
+      0x1fffff7, 0x1fffff8, 0x1fffff9, 0x1fffffa, 0x1fffffb, 0x1fffffc, 0x1fffffd, 0x1fffffe,
+      0x1ffffff, 0xffff80, 0xffff81, 0xffff82, 0xffff83, 0xffff84, 0xffff85, 0xffff86, 0xffff87,
+      0xffff88, 0xffff89, 0xffff8a, 0xffff8b, 0xffff8c, 0xffff8d, 0xffff8e, 0xffff8f, 0xffff90,
+      0xffff91, 0xffff92, 0xffff93, 0xffff94, 0xffff95, 0xffff96, 0xffff97, 0xffff98, 0xffff99,
+      0xffff9a, 0xffff9b, 0xffff9c, 0xffff9d, 0xffff9e, 0xffff9f, 0xffffa0, 0xffffa1, 0xffffa2,
+      0xffffa3, 0xffffa4, 0xffffa5, 0xffffa6, 0xffffa7, 0xffffa8, 0xffffa9, 0xffffaa, 0xffffab,
+      0xffffac, 0xffffad, 0xffffae, 0xffffaf, 0xffffb0, 0xffffb1, 0xffffb2, 0xffffb3, 0xffffb4,
+      0xffffb5, 0xffffb6, 0xffffb7, 0xffffb8, 0xffffb9, 0xffffba, 0xffffbb, 0xffffbc, 0xffffbd,
+      0xffffbe, 0xffffbf, 0xffffc0, 0xffffc1, 0xffffc2, 0xffffc3, 0xffffc4, 0xffffc5, 0xffffc6,
+      0xffffc7, 0xffffc8, 0xffffc9, 0xffffca, 0xffffcb, 0xffffcc, 0xffffcd, 0xffffce, 0xffffcf,
+      0xffffd0, 0xffffd1, 0xffffd2, 0xffffd3, 0xffffd4, 0xffffd5, 0xffffd6, 0xffffd7, 0xffffd8,
+      0xffffd9, 0xffffda, 0xffffdb, 0xffffdc
+  };
+
+  private static final byte[] RESPONSE_CODE_LENGTHS = {
+      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+      25, 25, 25, 25, 25, 25, 25, 25, 25, 4, 12, 7, 13, 14, 9, 10, 13, 9, 9, 12, 11, 6, 6, 6, 7, 4,
+      4, 4, 5, 5, 5, 6, 6, 5, 5, 5, 9, 16, 7, 13, 12, 16, 7, 8, 8, 8, 8, 8, 6, 9, 8, 8, 10, 9, 6, 8,
+      8, 9, 10, 9, 6, 5, 9, 9, 8, 10, 9, 10, 11, 13, 11, 15, 9, 17, 5, 7, 6, 6, 5, 7, 7, 7, 6, 9, 9,
+      7, 6, 6, 6, 6, 9, 6, 6, 6, 6, 7, 8, 7, 8, 9, 16, 14, 16, 16, 25, 25, 25, 25, 25, 25, 25, 25,
+      25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+      25, 25, 25, 25, 25, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+      24, 24, 24, 24, 24, 24
+  };
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
new file mode 100644
index 0000000000..0d6d6bf7d7
--- /dev/null
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
@@ -0,0 +1,112 @@
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.bytes.ByteString;
+import com.squareup.okhttp.internal.Util;
+import java.io.Closeable;
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.zip.DataFormatException;
+import java.util.zip.Inflater;
+import java.util.zip.InflaterInputStream;
+
+/**
+ * Reads a SPDY/3 Name/Value header block. This class is made complicated by the
+ * requirement that we're strict with which bytes we put in the compressed bytes
+ * buffer. We need to put all compressed bytes into that buffer -- but no other
+ * bytes.
+ */
+class NameValueBlockReader implements Closeable {
+  private final DataInputStream headerBlockIn;
+  private final FillableInflaterInputStream fillableInflaterInputStream;
+  private int compressedLimit;
+
+  NameValueBlockReader(final InputStream in) {
+    // Limit the inflater input stream to only those bytes in the Name/Value block. We cut the
+    // inflater off at its source because we can't predict the ratio of compressed bytes to
+    // uncompressed bytes.
+    InputStream throttleStream = new InputStream() {
+      @Override public int read() throws IOException {
+        return Util.readSingleByte(this);
+      }
+
+      @Override public int read(byte[] buffer, int offset, int byteCount) throws IOException {
+        byteCount = Math.min(byteCount, compressedLimit);
+        int consumed = in.read(buffer, offset, byteCount);
+        compressedLimit -= consumed;
+        return consumed;
+      }
+
+      @Override public void close() throws IOException {
+        in.close();
+      }
+    };
+
+    // Subclass inflater to install a dictionary when it's needed.
+    Inflater inflater = new Inflater() {
+      @Override public int inflate(byte[] buffer, int offset, int count)
+          throws DataFormatException {
+        int result = super.inflate(buffer, offset, count);
+        if (result == 0 && needsDictionary()) {
+          setDictionary(Spdy3.DICTIONARY);
+          result = super.inflate(buffer, offset, count);
+        }
+        return result;
+      }
+    };
+
+    fillableInflaterInputStream = new FillableInflaterInputStream(throttleStream, inflater);
+    headerBlockIn = new DataInputStream(fillableInflaterInputStream);
+  }
+
+  /** Extend the inflater stream so we can eagerly fill the compressed bytes buffer if necessary. */
+  static class FillableInflaterInputStream extends InflaterInputStream {
+    public FillableInflaterInputStream(InputStream in, Inflater inf) {
+      super(in, inf);
+    }
+
+    @Override public void fill() throws IOException {
+      super.fill(); // This method is protected in the superclass.
+    }
+  }
+
+  public List<Header> readNameValueBlock(int length) throws IOException {
+    this.compressedLimit += length;
+    int numberOfPairs = headerBlockIn.readInt();
+    if (numberOfPairs < 0) {
+      throw new IOException("numberOfPairs < 0: " + numberOfPairs);
+    }
+    if (numberOfPairs > 1024) {
+      throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
+    }
+    List<Header> entries = new ArrayList<Header>(numberOfPairs);
+    for (int i = 0; i < numberOfPairs; i++) {
+      ByteString name = ByteString.readLowerCase(headerBlockIn, headerBlockIn.readInt());
+      ByteString values = ByteString.read(headerBlockIn, headerBlockIn.readInt());
+      if (name.size() == 0) throw new IOException("name.size == 0");
+      entries.add(new Header(name, values));
+    }
+
+    doneReading();
+
+    return entries;
+  }
+
+  private void doneReading() throws IOException {
+    if (compressedLimit == 0) return;
+
+    // Read any outstanding unread bytes. One side-effect of deflate compression is that sometimes
+    // there are bytes remaining in the stream after we've consumed all of the content.
+    fillableInflaterInputStream.fill();
+
+    if (compressedLimit != 0) {
+      throw new IOException("compressedLimit > 0: " + compressedLimit);
+    }
+  }
+
+  @Override public void close() throws IOException {
+    headerBlockIn.close();
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
index 05380e27e1..c05d6b174f 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
@@ -15,13 +15,13 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-final class Settings {
-  /**
-   * From the spdy/3 spec, the default initial window size for all streams is
-   * 64 KiB. (Chrome 25 uses 10 MiB).
-   */
-  static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
+import java.util.Arrays;
 
+/**
+ * Settings describe characteristics of the sending peer, which are used by the receiving peer.
+ * Settings are {@link com.squareup.okhttp.internal.spdy.SpdyConnection connection} scoped.
+ */
+final class Settings {
   /** Peer request to clear durable settings. */
   static final int FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS = 0x1;
 
@@ -30,24 +30,28 @@
   /** Sent by clients only. The client is reminding the server of a persisted value. */
   static final int PERSISTED = 0x2;
 
-  /** Sender's estimate of max incoming kbps. */
+  /** spdy/3: Sender's estimate of max incoming kbps. */
   static final int UPLOAD_BANDWIDTH = 1;
-  /** Sender's estimate of max outgoing kbps. */
+  /** http/2: Size in bytes of the table used to decode the sender's header blocks. */
+  static final int HEADER_TABLE_SIZE = 1;
+  /** spdy/3: Sender's estimate of max outgoing kbps. */
   static final int DOWNLOAD_BANDWIDTH = 2;
-  /** Sender's estimate of milliseconds between sending a request and receiving a response. */
+  /** http/2: An endpoint must not send a PUSH_PROMISE frame when this is 0. */
+  static final int ENABLE_PUSH = 2;
+  /** spdy/3: Sender's estimate of millis between sending a request and receiving a response. */
   static final int ROUND_TRIP_TIME = 3;
   /** Sender's maximum number of concurrent streams. */
   static final int MAX_CONCURRENT_STREAMS = 4;
-  /** Current CWND in Packets. */
+  /** spdy/3: Current CWND in Packets. */
   static final int CURRENT_CWND = 5;
-  /** Retransmission rate. Percentage */
+  /** spdy/3: Retransmission rate. Percentage */
   static final int DOWNLOAD_RETRANS_RATE = 6;
   /** Window size in bytes. */
   static final int INITIAL_WINDOW_SIZE = 7;
-  /** Window size in bytes. */
+  /** spdy/3: Window size in bytes. */
   static final int CLIENT_CERTIFICATE_VECTOR_SIZE = 8;
   /** Flow control options. */
-  static final int FLOW_CONTROL_OPTIONS = 9;
+  static final int FLOW_CONTROL_OPTIONS = 10;
 
   /** Total number of settings. */
   static final int COUNT = 10;
@@ -67,9 +71,14 @@
   /** Flag values. */
   private final int[] values = new int[COUNT];
 
-  void set(int id, int idFlags, int value) {
+  void clear() {
+    set = persistValue = persisted = 0;
+    Arrays.fill(values, 0);
+  }
+
+  Settings set(int id, int idFlags, int value) {
     if (id >= values.length) {
-      return; // Discard unknown settings.
+      return this; // Discard unknown settings.
     }
 
     int bit = 1 << id;
@@ -86,6 +95,7 @@ void set(int id, int idFlags, int value) {
     }
 
     values[id] = value;
+    return this;
   }
 
   /** Returns true if a value has been assigned for the setting {@code id}. */
@@ -112,47 +122,69 @@ int size() {
     return Integer.bitCount(set);
   }
 
+  /** spdy/3 only. */
   int getUploadBandwidth(int defaultValue) {
     int bit = 1 << UPLOAD_BANDWIDTH;
     return (bit & set) != 0 ? values[UPLOAD_BANDWIDTH] : defaultValue;
   }
 
+  /** http/2 only. Returns -1 if unset. */
+  int getHeaderTableSize() {
+    int bit = 1 << HEADER_TABLE_SIZE;
+    return (bit & set) != 0 ? values[HEADER_TABLE_SIZE] : -1;
+  }
+
+  /** spdy/3 only. */
   int getDownloadBandwidth(int defaultValue) {
     int bit = 1 << DOWNLOAD_BANDWIDTH;
     return (bit & set) != 0 ? values[DOWNLOAD_BANDWIDTH] : defaultValue;
   }
 
+  /** http/2 only. */
+  // TODO: honor this setting in http/2.
+  boolean getEnablePush(boolean defaultValue) {
+    int bit = 1 << ENABLE_PUSH;
+    return ((bit & set) != 0 ? values[ENABLE_PUSH] : defaultValue ? 1 : 0) == 1;
+  }
+
+  /** spdy/3 only. */
   int getRoundTripTime(int defaultValue) {
     int bit = 1 << ROUND_TRIP_TIME;
     return (bit & set) != 0 ? values[ROUND_TRIP_TIME] : defaultValue;
   }
 
+  // TODO: honor this setting in spdy/3 and http/2.
   int getMaxConcurrentStreams(int defaultValue) {
     int bit = 1 << MAX_CONCURRENT_STREAMS;
     return (bit & set) != 0 ? values[MAX_CONCURRENT_STREAMS] : defaultValue;
   }
 
+  /** spdy/3 only. */
   int getCurrentCwnd(int defaultValue) {
     int bit = 1 << CURRENT_CWND;
     return (bit & set) != 0 ? values[CURRENT_CWND] : defaultValue;
   }
 
+  /** spdy/3 only. */
   int getDownloadRetransRate(int defaultValue) {
     int bit = 1 << DOWNLOAD_RETRANS_RATE;
     return (bit & set) != 0 ? values[DOWNLOAD_RETRANS_RATE] : defaultValue;
   }
 
-  int getInitialWindowSize(int defaultValue) {
+  // TODO: honor this setting in http/2.
+  /** Returns -1 if unset. */
+  int getInitialWindowSize() {
     int bit = 1 << INITIAL_WINDOW_SIZE;
-    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : defaultValue;
+    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : -1;
   }
 
+  /** spdy/3 only. */
   int getClientCertificateVectorSize(int defaultValue) {
     int bit = 1 << CLIENT_CERTIFICATE_VECTOR_SIZE;
     return (bit & set) != 0 ? values[CLIENT_CERTIFICATE_VECTOR_SIZE] : defaultValue;
   }
 
-  // TODO: honor this setting.
+  // TODO: honor this setting in spdy/3 and http/2.
   boolean isFlowControlDisabled() {
     int bit = 1 << FLOW_CONTROL_OPTIONS;
     int value = (bit & set) != 0 ? values[FLOW_CONTROL_OPTIONS] : 0;
@@ -160,7 +192,7 @@ boolean isFlowControlDisabled() {
   }
 
   /**
-   * Returns true if this user agent should use this setting in future SPDY
+   * Returns true if this user agent should use this setting in future spdy/3
    * connections to the same host.
    */
   boolean persistValue(int id) {
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 4a1cbb28e6..75afc37555 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -15,8 +15,10 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import java.io.ByteArrayOutputStream;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
@@ -25,26 +27,30 @@
 import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.ProtocolException;
-import java.util.ArrayList;
 import java.util.List;
+import java.util.logging.Level;
 import java.util.logging.Logger;
-import java.util.zip.DataFormatException;
 import java.util.zip.Deflater;
-import java.util.zip.Inflater;
-import java.util.zip.InflaterInputStream;
 
+/**
+ * Read and write spdy/3.1 frames.
+ * http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1
+ */
 final class Spdy3 implements Variant {
+
+  @Override public Protocol getProtocol() {
+    return Protocol.SPDY_3;
+  }
+
   static final int TYPE_DATA = 0x0;
   static final int TYPE_SYN_STREAM = 0x1;
   static final int TYPE_SYN_REPLY = 0x2;
   static final int TYPE_RST_STREAM = 0x3;
   static final int TYPE_SETTINGS = 0x4;
-  static final int TYPE_NOOP = 0x5;
   static final int TYPE_PING = 0x6;
   static final int TYPE_GOAWAY = 0x7;
   static final int TYPE_HEADERS = 0x8;
   static final int TYPE_WINDOW_UPDATE = 0x9;
-  static final int TYPE_CREDENTIAL = 0x10;
 
   static final int FLAG_FIN = 0x1;
   static final int FLAG_UNIDIRECTIONAL = 0x2;
@@ -103,13 +109,12 @@
   /** Read spdy/3 frames. */
   static final class Reader implements FrameReader {
     private final DataInputStream in;
-    private final DataInputStream nameValueBlockIn;
     private final boolean client;
-    private int compressedLimit;
+    private final NameValueBlockReader headerBlockReader;
 
     Reader(InputStream in, boolean client) {
       this.in = new DataInputStream(in);
-      this.nameValueBlockIn = newNameValueBlockStream();
+      this.headerBlockReader = new NameValueBlockReader(in);
       this.client = client;
     }
 
@@ -158,11 +163,6 @@
             readSettings(handler, flags, length);
             return true;
 
-          case TYPE_NOOP:
-            if (length != 0) throw ioException("TYPE_NOOP length: %d != 0", length);
-            handler.noop();
-            return true;
-
           case TYPE_PING:
             readPing(handler, flags, length);
             return true;
@@ -179,12 +179,11 @@
             readWindowUpdate(handler, flags, length);
             return true;
 
-          case TYPE_CREDENTIAL:
-            Util.skipByReading(in, length);
-            throw new UnsupportedOperationException("TODO"); // TODO: implement
-
           default:
-            throw new IOException("Unexpected frame");
+            Logger logger = Logger.getLogger("com.squareup.okhttp.internal.spdy.Spdy3");
+            logger.log(Level.INFO, "Ignoring unknown frame type " + type);
+            Util.skipByReading(in, length);
+            return true;
         }
       } else {
         int streamId = w1 & 0x7fffffff;
@@ -201,21 +200,21 @@ private void readSynStream(Handler handler, int flags, int length) throws IOExce
       int streamId = w1 & 0x7fffffff;
       int associatedStreamId = w2 & 0x7fffffff;
       int priority = (s3 & 0xe000) >>> 13;
-      int slot = s3 & 0xff;
-      List<String> nameValueBlock = readNameValueBlock(length - 10);
+      // int slot = s3 & 0xff;
+      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 10);
 
       boolean inFinished = (flags & FLAG_FIN) != 0;
       boolean outFinished = (flags & FLAG_UNIDIRECTIONAL) != 0;
       handler.headers(outFinished, inFinished, streamId, associatedStreamId, priority,
-          nameValueBlock, HeadersMode.SPDY_SYN_STREAM);
+          headerBlock, HeadersMode.SPDY_SYN_STREAM);
     }
 
     private void readSynReply(Handler handler, int flags, int length) throws IOException {
       int w1 = in.readInt();
       int streamId = w1 & 0x7fffffff;
-      List<String> nameValueBlock = readNameValueBlock(length - 4);
+      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
       boolean inFinished = (flags & FLAG_FIN) != 0;
-      handler.headers(false, inFinished, streamId, -1, -1, nameValueBlock, HeadersMode.SPDY_REPLY);
+      handler.headers(false, inFinished, streamId, -1, -1, headerBlock, HeadersMode.SPDY_REPLY);
     }
 
     private void readRstStream(Handler handler, int flags, int length) throws IOException {
@@ -232,8 +231,8 @@ private void readRstStream(Handler handler, int flags, int length) throws IOExce
     private void readHeaders(Handler handler, int flags, int length) throws IOException {
       int w1 = in.readInt();
       int streamId = w1 & 0x7fffffff;
-      List<String> nameValueBlock = readNameValueBlock(length - 4);
-      handler.headers(false, false, streamId, -1, -1, nameValueBlock, HeadersMode.SPDY_HEADERS);
+      List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
+      handler.headers(false, false, streamId, -1, -1, headerBlock, HeadersMode.SPDY_HEADERS);
     }
 
     private void readWindowUpdate(Handler handler, int flags, int length) throws IOException {
@@ -241,88 +240,16 @@ private void readWindowUpdate(Handler handler, int flags, int length) throws IOE
       int w1 = in.readInt();
       int w2 = in.readInt();
       int streamId = w1 & 0x7fffffff;
-      int deltaWindowSize = w2 & 0x7fffffff;
-      handler.windowUpdate(streamId, deltaWindowSize, false);
-    }
-
-    private DataInputStream newNameValueBlockStream() {
-      // Limit the inflater input stream to only those bytes in the Name/Value block.
-      final InputStream throttleStream = new InputStream() {
-        @Override public int read() throws IOException {
-          return Util.readSingleByte(this);
-        }
-
-        @Override public int read(byte[] buffer, int offset, int byteCount) throws IOException {
-          byteCount = Math.min(byteCount, compressedLimit);
-          int consumed = in.read(buffer, offset, byteCount);
-          compressedLimit -= consumed;
-          return consumed;
-        }
-
-        @Override public void close() throws IOException {
-          in.close();
-        }
-      };
-
-      // Subclass inflater to install a dictionary when it's needed.
-      Inflater inflater = new Inflater() {
-        @Override public int inflate(byte[] buffer, int offset, int count)
-            throws DataFormatException {
-          int result = super.inflate(buffer, offset, count);
-          if (result == 0 && needsDictionary()) {
-            setDictionary(DICTIONARY);
-            result = super.inflate(buffer, offset, count);
-          }
-          return result;
-        }
-      };
-
-      return new DataInputStream(new InflaterInputStream(throttleStream, inflater));
-    }
-
-    private List<String> readNameValueBlock(int length) throws IOException {
-      this.compressedLimit += length;
-      try {
-        int numberOfPairs = nameValueBlockIn.readInt();
-        if (numberOfPairs < 0) {
-          Logger.getLogger(getClass().getName()).warning("numberOfPairs < 0: " + numberOfPairs);
-          throw ioException("numberOfPairs < 0");
-        }
-        if (numberOfPairs > 1024) {
-          Logger.getLogger(getClass().getName()).warning("numberOfPairs > 1024: " + numberOfPairs);
-          throw ioException("numberOfPairs > 1024");
-        }
-        List<String> entries = new ArrayList<String>(numberOfPairs * 2);
-        for (int i = 0; i < numberOfPairs; i++) {
-          String name = readString();
-          String values = readString();
-          if (name.length() == 0) throw ioException("name.length == 0");
-          entries.add(name);
-          entries.add(values);
-        }
-
-        if (compressedLimit != 0) {
-          Logger.getLogger(getClass().getName()).warning("compressedLimit > 0: " + compressedLimit);
-        }
-
-        return entries;
-      } catch (DataFormatException e) {
-        throw new IOException(e.getMessage());
-      }
-    }
-
-    private String readString() throws DataFormatException, IOException {
-      int length = nameValueBlockIn.readInt();
-      byte[] bytes = new byte[length];
-      Util.readFully(nameValueBlockIn, bytes);
-      return new String(bytes, 0, length, "UTF-8");
+      long increment = w2 & 0x7fffffff;
+      if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
+      handler.windowUpdate(streamId, increment);
     }
 
     private void readPing(Handler handler, int flags, int length) throws IOException {
       if (length != 4) throw ioException("TYPE_PING length: %d != 4", length);
       int id = in.readInt();
-      boolean reply = client == ((id % 2) == 1);
-      handler.ping(reply, id, 0);
+      boolean ack = client == ((id & 1) == 1);
+      handler.ping(ack, id, 0);
     }
 
     private void readGoAway(Handler handler, int flags, int length) throws IOException {
@@ -333,7 +260,7 @@ private void readGoAway(Handler handler, int flags, int length) throws IOExcepti
       if (errorCode == null) {
         throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
       }
-      handler.goAway(lastGoodStreamId, errorCode);
+      handler.goAway(lastGoodStreamId, errorCode, Util.EMPTY_BYTE_ARRAY);
     }
 
     private void readSettings(Handler handler, int flags, int length) throws IOException {
@@ -358,15 +285,15 @@ private static IOException ioException(String message, Object... args) throws IO
     }
 
     @Override public void close() throws IOException {
-      Util.closeAll(in, nameValueBlockIn);
+      Util.closeAll(in, headerBlockReader);
     }
   }
 
   /** Write spdy/3 frames. */
   static final class Writer implements FrameWriter {
     private final DataOutputStream out;
-    private final ByteArrayOutputStream nameValueBlockBuffer;
-    private final DataOutputStream nameValueBlockOut;
+    private final ByteArrayOutputStream headerBlockBuffer;
+    private final DataOutputStream headerBlockOut;
     private final boolean client;
 
     Writer(OutputStream out, boolean client) {
@@ -375,9 +302,19 @@ private static IOException ioException(String message, Object... args) throws IO
 
       Deflater deflater = new Deflater();
       deflater.setDictionary(DICTIONARY);
-      nameValueBlockBuffer = new ByteArrayOutputStream();
-      nameValueBlockOut = new DataOutputStream(
-          Platform.get().newDeflaterOutputStream(nameValueBlockBuffer, deflater, true));
+      headerBlockBuffer = new ByteArrayOutputStream();
+      headerBlockOut = new DataOutputStream(
+          Platform.get().newDeflaterOutputStream(headerBlockBuffer, deflater, true));
+    }
+
+    @Override public void ackSettings() {
+      // Do nothing: no ACK for SPDY/3 settings.
+    }
+
+    @Override
+    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+        throws IOException {
+      // Do nothing: no push promise for SPDY/3.
     }
 
     @Override public synchronized void connectionHeader() {
@@ -388,11 +325,12 @@ private static IOException ioException(String message, Object... args) throws IO
       out.flush();
     }
 
-    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, int priority, int slot, List<String> nameValueBlock)
+    @Override
+    public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId,
+        int associatedStreamId, int priority, int slot, List<Header> headerBlock)
         throws IOException {
-      writeNameValueBlockToBuffer(nameValueBlock);
-      int length = 10 + nameValueBlockBuffer.size();
+      writeNameValueBlockToBuffer(headerBlock);
+      int length = 10 + headerBlockBuffer.size();
       int type = TYPE_SYN_STREAM;
       int flags = (outFinished ? FLAG_FIN : 0) | (inFinished ? FLAG_UNIDIRECTIONAL : 0);
 
@@ -402,36 +340,35 @@ private static IOException ioException(String message, Object... args) throws IO
       out.writeInt(streamId & 0x7fffffff);
       out.writeInt(associatedStreamId & 0x7fffffff);
       out.writeShort((priority & 0x7) << 13 | (unused & 0x1f) << 8 | (slot & 0xff));
-      nameValueBlockBuffer.writeTo(out);
+      headerBlockBuffer.writeTo(out);
       out.flush();
     }
 
-    @Override public synchronized void synReply(
-        boolean outFinished, int streamId, List<String> nameValueBlock) throws IOException {
-      writeNameValueBlockToBuffer(nameValueBlock);
+    @Override public synchronized void synReply(boolean outFinished, int streamId,
+        List<Header> headerBlock) throws IOException {
+      writeNameValueBlockToBuffer(headerBlock);
       int type = TYPE_SYN_REPLY;
       int flags = (outFinished ? FLAG_FIN : 0);
-      int length = nameValueBlockBuffer.size() + 4;
+      int length = headerBlockBuffer.size() + 4;
 
       out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
       out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
       out.writeInt(streamId & 0x7fffffff);
-      nameValueBlockBuffer.writeTo(out);
+      headerBlockBuffer.writeTo(out);
       out.flush();
     }
 
-    @Override public synchronized void headers(int streamId, List<String> nameValueBlock)
+    @Override public synchronized void headers(int streamId, List<Header> headerBlock)
         throws IOException {
-      writeNameValueBlockToBuffer(nameValueBlock);
+      writeNameValueBlockToBuffer(headerBlock);
       int flags = 0;
       int type = TYPE_HEADERS;
-      int length = nameValueBlockBuffer.size() + 4;
+      int length = headerBlockBuffer.size() + 4;
 
       out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
       out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
       out.writeInt(streamId & 0x7fffffff);
-      nameValueBlockBuffer.writeTo(out);
-      out.flush();
+      headerBlockBuffer.writeTo(out);
     }
 
     @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
@@ -454,21 +391,33 @@ private static IOException ioException(String message, Object... args) throws IO
 
     @Override public synchronized void data(boolean outFinished, int streamId, byte[] data,
         int offset, int byteCount) throws IOException {
+      // TODO: Implement looping strategy.
       int flags = (outFinished ? FLAG_FIN : 0);
+      sendDataFrame(streamId, flags, data, offset, byteCount);
+    }
+
+    void sendDataFrame(int streamId, int flags, byte[] data, int offset, int byteCount)
+        throws IOException {
+      if (byteCount > 0xffffffL) {
+        throw new IllegalArgumentException("FRAME_TOO_LARGE max size is 16Mib: " + byteCount);
+      }
       out.writeInt(streamId & 0x7fffffff);
       out.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
       out.write(data, offset, byteCount);
     }
 
-    private void writeNameValueBlockToBuffer(List<String> nameValueBlock) throws IOException {
-      nameValueBlockBuffer.reset();
-      int numberOfPairs = nameValueBlock.size() / 2;
-      nameValueBlockOut.writeInt(numberOfPairs);
-      for (String s : nameValueBlock) {
-        nameValueBlockOut.writeInt(s.length());
-        nameValueBlockOut.write(s.getBytes("UTF-8"));
+    private void writeNameValueBlockToBuffer(List<Header> headerBlock) throws IOException {
+      headerBlockBuffer.reset();
+      headerBlockOut.writeInt(headerBlock.size());
+      for (int i = 0, size = headerBlock.size(); i < size; i++) {
+        ByteString name = headerBlock.get(i).name;
+        headerBlockOut.writeInt(name.size());
+        name.write(headerBlockOut);
+        ByteString value = headerBlock.get(i).value;
+        headerBlockOut.writeInt(value.size());
+        value.write(headerBlockOut);
       }
-      nameValueBlockOut.flush();
+      headerBlockOut.flush();
     }
 
     @Override public synchronized void settings(Settings settings) throws IOException {
@@ -488,18 +437,9 @@ private void writeNameValueBlockToBuffer(List<String> nameValueBlock) throws IOE
       out.flush();
     }
 
-    @Override public synchronized void noop() throws IOException {
-      int type = TYPE_NOOP;
-      int length = 0;
-      int flags = 0;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.flush();
-    }
-
     @Override public synchronized void ping(boolean reply, int payload1, int payload2)
         throws IOException {
-      boolean payloadIsReply = client != ((payload1 % 2) == 1);
+      boolean payloadIsReply = client != ((payload1 & 1) == 1);
       if (reply != payloadIsReply) throw new IllegalArgumentException("payload != reply");
       int type = TYPE_PING;
       int flags = 0;
@@ -510,9 +450,12 @@ private void writeNameValueBlockToBuffer(List<String> nameValueBlock) throws IOE
       out.flush();
     }
 
-    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode)
+    @Override
+    public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] ignored)
         throws IOException {
-      if (errorCode.spdyGoAwayCode == -1) throw new IllegalArgumentException();
+      if (errorCode.spdyGoAwayCode == -1) {
+        throw new IllegalArgumentException("errorCode.spdyGoAwayCode == -1");
+      }
       int type = TYPE_GOAWAY;
       int flags = 0;
       int length = 8;
@@ -523,20 +466,24 @@ private void writeNameValueBlockToBuffer(List<String> nameValueBlock) throws IOE
       out.flush();
     }
 
-    @Override public synchronized void windowUpdate(int streamId, int deltaWindowSize)
+    @Override public synchronized void windowUpdate(int streamId, long increment)
         throws IOException {
+      if (increment == 0 || increment > 0x7fffffffL) {
+        throw new IllegalArgumentException(
+            "windowSizeIncrement must be between 1 and 0x7fffffff: " + increment);
+      }
       int type = TYPE_WINDOW_UPDATE;
       int flags = 0;
       int length = 8;
       out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
       out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
       out.writeInt(streamId);
-      out.writeInt(deltaWindowSize);
+      out.writeInt((int) increment);
       out.flush();
     }
 
     @Override public void close() throws IOException {
-      Util.closeAll(out, nameValueBlockOut);
+      Util.closeAll(out, headerBlockOut);
     }
   }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index b19bd44c0a..daec4ce2ae 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Util;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.InterruptedIOException;
 import java.io.OutputStream;
 import java.net.Socket;
 import java.util.HashMap;
@@ -57,10 +58,10 @@
 
   private static final ExecutorService executor = new ThreadPoolExecutor(0,
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
-      Util.daemonThreadFactory("OkHttp SpdyConnection"));
+      Util.threadFactory("OkHttp SpdyConnection", true));
 
-  /** The protocol variant, like SPDY/3 or HTTP-draft-04/2.0. */
-  final Variant variant;
+  /** The protocol variant, like {@link com.squareup.okhttp.internal.spdy.Spdy3}. */
+  final Protocol protocol;
 
   /** True if this peer initiated the connection. */
   final boolean client;
@@ -70,9 +71,6 @@
    * run on the callback executor.
    */
   private final IncomingStreamHandler handler;
-  private final FrameReader frameReader;
-  private final FrameWriter frameWriter;
-
   private final Map<Integer, SpdyStream> streams = new HashMap<Integer, SpdyStream>();
   private final String hostName;
   private int lastGoodStreamId;
@@ -84,21 +82,70 @@
   private Map<Integer, Ping> pings;
   private int nextPingId;
 
-  /** Lazily-created settings for the peer. */
-  Settings settings;
+  static final int INITIAL_WINDOW_SIZE = 65535;
+
+  /**
+   * The total number of bytes consumed by the application, but not yet
+   * acknowledged by sending a {@code WINDOW_UPDATE} frame on this connection.
+   */
+  // Visible for testing
+  long unacknowledgedBytesRead = 0;
+
+  /**
+   * Count of bytes that can be written on the connection before receiving a
+   * window update.
+   */
+  // Visible for testing
+  long bytesLeftInWriteWindow;
+
+  /** Settings we communicate to the peer. */
+  // TODO: Do we want to dynamically adjust settings, or KISS and only set once?
+  final Settings okHttpSettings = new Settings()
+      .set(Settings.INITIAL_WINDOW_SIZE, 0, INITIAL_WINDOW_SIZE);
+      // TODO: implement stream limit
+      // okHttpSettings.set(Settings.MAX_CONCURRENT_STREAMS, 0, max);
+
+  /** Settings we receive from the peer. */
+  // TODO: MWS will need to guard on this setting before attempting to push.
+  final Settings peerSettings = new Settings()
+      .set(Settings.INITIAL_WINDOW_SIZE, 0, INITIAL_WINDOW_SIZE);
+
+  private boolean receivedInitialPeerSettings = false;
+  final FrameReader frameReader;
+  final FrameWriter frameWriter;
+
+  // Visible for testing
+  final Reader readerRunnable;
+  final ByteArrayPool bufferPool;
 
   private SpdyConnection(Builder builder) {
-    variant = builder.variant;
+    protocol = builder.protocol;
     client = builder.client;
     handler = builder.handler;
-    frameReader = variant.newReader(builder.in, client);
-    frameWriter = variant.newWriter(builder.out, client);
     nextStreamId = builder.client ? 1 : 2;
     nextPingId = builder.client ? 1 : 2;
-
     hostName = builder.hostName;
 
-    new Thread(new Reader(), "Spdy Reader " + hostName).start();
+    Variant variant;
+    if (protocol == Protocol.HTTP_2) {
+      variant = new Http20Draft09();
+    } else if (protocol == Protocol.SPDY_3) {
+      variant = new Spdy3();
+    } else {
+      throw new AssertionError(protocol);
+    }
+    bytesLeftInWriteWindow = peerSettings.getInitialWindowSize();
+    bufferPool = new ByteArrayPool(INITIAL_WINDOW_SIZE * 8); // TODO: revisit size limit!
+    frameReader = variant.newReader(builder.in, client);
+    frameWriter = variant.newWriter(builder.out, client);
+
+    readerRunnable = new Reader();
+    new Thread(readerRunnable).start(); // Not a daemon thread.
+  }
+
+  /** The protocol as selected using NPN or ALPN. */
+  public Protocol getProtocol() {
+     return protocol;
   }
 
   /**
@@ -109,7 +156,7 @@ public synchronized int openStreamCount() {
     return streams.size();
   }
 
-  private synchronized SpdyStream getStream(int id) {
+  synchronized SpdyStream getStream(int id) {
     return streams.get(id);
   }
 
@@ -146,12 +193,12 @@ public synchronized long getIdleStartTimeNs() {
    * @param in true to create an input stream that the remote peer can use to
    *     send data to us. Corresponds to {@code FLAG_UNIDIRECTIONAL}.
    */
-  public SpdyStream newStream(List<String> requestHeaders, boolean out, boolean in)
+  public SpdyStream newStream(List<Header> requestHeaders, boolean out, boolean in)
       throws IOException {
     boolean outFinished = !out;
     boolean inFinished = !in;
     int associatedStreamId = 0;  // TODO: permit the caller to specify an associated stream?
-    int priority = 0; // TODO: permit the caller to specify a priority?
+    int priority = -1; // TODO: permit the caller to specify a priority?
     int slot = 0; // TODO: permit the caller to specify a slot?
     SpdyStream stream;
     int streamId;
@@ -163,8 +210,7 @@ public SpdyStream newStream(List<String> requestHeaders, boolean out, boolean in
         }
         streamId = nextStreamId;
         nextStreamId += 2;
-        stream = new SpdyStream(
-            streamId, this, outFinished, inFinished, priority, requestHeaders, settings);
+        stream = new SpdyStream(streamId, this, outFinished, inFinished, priority, requestHeaders);
         if (stream.isOpen()) {
           streams.put(streamId, stream);
           setIdle(false);
@@ -178,18 +224,61 @@ public SpdyStream newStream(List<String> requestHeaders, boolean out, boolean in
     return stream;
   }
 
-  void writeSynReply(int streamId, boolean outFinished, List<String> alternating)
+  void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
       throws IOException {
     frameWriter.synReply(outFinished, streamId, alternating);
   }
 
+  /**
+   * Callers of this method are not thread safe, and sometimes on application
+   * threads.  Most often, this method will be called to send a buffer worth of
+   * data to the peer.
+   * <p>
+   * Writes are subject to the write window of the stream and the connection.
+   * Until there is a window sufficient to send {@code byteCount}, the caller
+   * will block.  For example, a user of {@code HttpURLConnection} who flushes
+   * more bytes to the output stream than the connection's write window will
+   * block.
+   * <p>
+   * Zero {@code byteCount} writes are not subject to flow control and
+   * will not block.  The only use case for zero {@code byteCount} is closing
+   * a flushed output stream.
+   */
   public void writeData(int streamId, boolean outFinished, byte[] buffer, int offset, int byteCount)
       throws IOException {
+    if (byteCount == 0) { // Empty data frames are not flow-controlled.
+      frameWriter.data(outFinished, streamId, buffer, offset, byteCount);
+      return;
+    }
+    synchronized (SpdyConnection.this) {
+      waitUntilWritable(byteCount);
+      bytesLeftInWriteWindow -= byteCount;
+    }
     frameWriter.data(outFinished, streamId, buffer, offset, byteCount);
   }
 
+  /** Returns once the peer is ready to receive {@code byteCount} bytes. */
+  private void waitUntilWritable(int byteCount) throws IOException {
+    try {
+      while (byteCount > bytesLeftInWriteWindow) {
+        SpdyConnection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
+      }
+    } catch (InterruptedException e) {
+      throw new InterruptedIOException();
+    }
+  }
+
+  /**
+   * {@code delta} will be negative if a settings frame initial window is
+   * smaller than the last.
+   */
+  void addBytesToWriteWindow(long delta) {
+    bytesLeftInWriteWindow += delta;
+    if (delta > 0) SpdyConnection.this.notifyAll();
+  }
+
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
-    executor.submit(new NamedRunnable("OkHttp SPDY Writer %s stream %d", hostName, streamId) {
+    executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
       @Override public void execute() {
         try {
           writeSynReset(streamId, errorCode);
@@ -203,21 +292,17 @@ void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
     frameWriter.rstStream(streamId, statusCode);
   }
 
-  void writeWindowUpdateLater(final int streamId, final int deltaWindowSize) {
-    executor.submit(new NamedRunnable("OkHttp SPDY Writer %s stream %d", hostName, streamId) {
+  void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
+    executor.submit(new NamedRunnable("OkHttp Window Update %s stream %d", hostName, streamId) {
       @Override public void execute() {
         try {
-          writeWindowUpdate(streamId, deltaWindowSize);
+          frameWriter.windowUpdate(streamId, unacknowledgedBytesRead);
         } catch (IOException ignored) {
         }
       }
     });
   }
 
-  void writeWindowUpdate(int streamId, int deltaWindowSize) throws IOException {
-    frameWriter.windowUpdate(streamId, deltaWindowSize);
-  }
-
   /**
    * Sends a ping frame to the peer. Use the returned object to await the
    * ping's response and observe its round trip time.
@@ -240,7 +325,7 @@ public Ping ping() throws IOException {
 
   private void writePingLater(
       final boolean reply, final int payload1, final int payload2, final Ping ping) {
-    executor.submit(new NamedRunnable("OkHttp SPDY Writer %s ping %08x%08x",
+    executor.submit(new NamedRunnable("OkHttp %s ping %08x%08x",
         hostName, payload1, payload2) {
       @Override public void execute() {
         try {
@@ -263,11 +348,6 @@ private synchronized Ping removePing(int id) {
     return pings != null ? pings.remove(id) : null;
   }
 
-  /** Sends a noop frame to the peer. */
-  public void noop() throws IOException {
-    frameWriter.noop();
-  }
-
   public void flush() throws IOException {
     frameWriter.flush();
   }
@@ -288,7 +368,8 @@ public void shutdown(ErrorCode statusCode) throws IOException {
         shutdown = true;
         lastGoodStreamId = this.lastGoodStreamId;
       }
-      frameWriter.goAway(lastGoodStreamId, statusCode);
+      // TODO: propagate exception message into debugData
+      frameWriter.goAway(lastGoodStreamId, statusCode, Util.EMPTY_BYTE_ARRAY);
     }
   }
 
@@ -360,7 +441,7 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
    */
   public void sendConnectionHeader() throws IOException {
     frameWriter.connectionHeader();
-    frameWriter.settings(new Settings());
+    frameWriter.settings(okHttpSettings);
   }
 
   /**
@@ -376,7 +457,7 @@ public void readConnectionHeader() throws IOException {
     private InputStream in;
     private OutputStream out;
     private IncomingStreamHandler handler = IncomingStreamHandler.REFUSE_INCOMING_STREAMS;
-    private Variant variant = Variant.SPDY3;
+    private Protocol protocol = Protocol.SPDY_3;
     private boolean client;
 
     public Builder(boolean client, Socket socket) throws IOException {
@@ -411,13 +492,8 @@ public Builder handler(IncomingStreamHandler handler) {
       return this;
     }
 
-    public Builder spdy3() {
-      this.variant = Variant.SPDY3;
-      return this;
-    }
-
-    public Builder http20Draft04() {
-      this.variant = Variant.HTTP_20_DRAFT_04;
+    public Builder protocol(Protocol protocol) {
+      this.protocol = protocol;
       return this;
     }
 
@@ -426,8 +502,16 @@ public SpdyConnection build() {
     }
   }
 
-  private class Reader implements Runnable, FrameReader.Handler {
-    @Override public void run() {
+  /**
+   * Methods in this class must not lock FrameWriter.  If a method needs to
+   * write a frame, create an async task to do so.
+   */
+  class Reader extends NamedRunnable implements FrameReader.Handler {
+    private Reader() {
+      super("OkHttp %s", hostName);
+    }
+
+    @Override protected void execute() {
       ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
       ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
       try {
@@ -461,7 +545,7 @@ public SpdyConnection build() {
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<String> nameValueBlock,
+        int associatedStreamId, int priority, List<Header> headerBlock,
         HeadersMode headersMode) {
       SpdyStream stream;
       synchronized (SpdyConnection.this) {
@@ -485,10 +569,10 @@ public SpdyConnection build() {
 
           // Create a stream.
           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,
-              inFinished, priority, nameValueBlock, settings);
+              inFinished, priority, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
-          executor.submit(new NamedRunnable("OkHttp Callback %s stream %d", hostName, streamId) {
+          executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
             @Override public void execute() {
               try {
                 handler.receive(newStream);
@@ -509,7 +593,7 @@ public SpdyConnection build() {
       }
 
       // Update an existing stream.
-      stream.receiveHeaders(nameValueBlock, headersMode);
+      stream.receiveHeaders(headerBlock, headersMode);
       if (inFinished) stream.receiveFin();
     }
 
@@ -521,33 +605,52 @@ public SpdyConnection build() {
     }
 
     @Override public void settings(boolean clearPrevious, Settings newSettings) {
+      long delta = 0;
       SpdyStream[] streamsToNotify = null;
       synchronized (SpdyConnection.this) {
-        if (settings == null || clearPrevious) {
-          settings = newSettings;
+        int priorWriteWindowSize = peerSettings.getInitialWindowSize();
+        if (clearPrevious) {
+          peerSettings.clear();
         } else {
-          settings.merge(newSettings);
+          peerSettings.merge(newSettings);
+        }
+        if (getProtocol() == Protocol.HTTP_2) {
+          ackSettingsLater();
         }
-        if (!streams.isEmpty()) {
-          streamsToNotify = streams.values().toArray(new SpdyStream[streams.size()]);
+        int peerInitialWindowSize = peerSettings.getInitialWindowSize();
+        if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
+          delta = peerInitialWindowSize - priorWriteWindowSize;
+          if (!receivedInitialPeerSettings) {
+            addBytesToWriteWindow(delta);
+            receivedInitialPeerSettings = true;
+          }
+          if (!streams.isEmpty()) {
+            streamsToNotify = streams.values().toArray(new SpdyStream[streams.size()]);
+          }
         }
       }
-      if (streamsToNotify != null) {
-        for (SpdyStream stream : streamsToNotify) {
-          // The synchronization here is ugly. We need to synchronize on 'this' to guard
-          // reads to 'settings'. We synchronize on 'stream' to guard the state change.
-          // And we need to acquire the 'stream' lock first, since that may block.
-          // TODO: this can block the reader thread until a write completes. That's bad!
+      if (streamsToNotify != null && delta != 0) {
+        for (SpdyStream stream : streams.values()) {
           synchronized (stream) {
-            synchronized (SpdyConnection.this) {
-              stream.receiveSettings(settings);
-            }
+            stream.addBytesToWriteWindow(delta);
           }
         }
       }
     }
 
-    @Override public void noop() {
+    private void ackSettingsLater() {
+      executor.submit(new NamedRunnable("OkHttp %s ACK Settings", hostName) {
+        @Override public void execute() {
+          try {
+            frameWriter.ackSettings();
+          } catch (IOException ignored) {
+          }
+        }
+      });
+    }
+
+    @Override public void ackSettings() {
+      // TODO: If we don't get this callback after sending settings to the peer, SETTINGS_TIMEOUT.
     }
 
     @Override public void ping(boolean reply, int payload1, int payload2) {
@@ -562,7 +665,9 @@ public SpdyConnection build() {
       }
     }
 
-    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode) {
+    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+      if (debugData.length > 0) { // TODO: log the debugData
+      }
       synchronized (SpdyConnection.this) {
         shutdown = true;
 
@@ -579,21 +684,42 @@ public SpdyConnection build() {
       }
     }
 
-    @Override public void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl) {
+    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
       if (streamId == 0) {
-        // TODO: honor whole-stream flow control
-        return;
-      }
-
-      // TODO: honor endFlowControl
-      SpdyStream stream = getStream(streamId);
-      if (stream != null) {
-        stream.receiveWindowUpdate(deltaWindowSize);
+        synchronized (SpdyConnection.this) {
+          bytesLeftInWriteWindow += windowSizeIncrement;
+          SpdyConnection.this.notifyAll();
+        }
+      } else {
+        SpdyStream stream = getStream(streamId);
+        if (stream != null) {
+          synchronized (stream) {
+            stream.addBytesToWriteWindow(windowSizeIncrement);
+          }
+        }
       }
     }
 
     @Override public void priority(int streamId, int priority) {
       // TODO: honor priority.
     }
+
+    @Override
+    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
+        throws IOException {
+      // TODO: Wire up properly and only cancel when local settings disable push.
+      cancelStreamLater(promisedStreamId);
+    }
+
+    private void cancelStreamLater(final int streamId) {
+      executor.submit(new NamedRunnable("OkHttp %s Cancelling Stream %s", hostName, streamId) {
+        @Override public void execute() {
+          try {
+            frameWriter.rstStream(streamId, ErrorCode.CANCEL);
+          } catch (IOException ignored) {
+          }
+        }
+      });
+    }
   }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index e550022030..e36c8ebadf 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -29,32 +29,40 @@
 
 /** A logical bidirectional stream. */
 public final class SpdyStream {
+  static final int OUTPUT_BUFFER_SIZE = 8192;
 
   // Internal state is guarded by this. No long-running or potentially
   // blocking operations are performed while the lock is held.
 
   /**
-   * The number of unacknowledged bytes at which the input stream will send
-   * the peer a {@code WINDOW_UPDATE} frame. Must be less than this client's
-   * window size, otherwise the remote peer will stop sending data on this
-   * stream. (Chrome 25 uses 5 MiB.)
+   * The total number of bytes consumed by the application
+   * (with {@link SpdyDataInputStream#read}), but not yet acknowledged by
+   * sending a {@code WINDOW_UPDATE} frame on this stream.
    */
-  public static final int WINDOW_UPDATE_THRESHOLD = Settings.DEFAULT_INITIAL_WINDOW_SIZE / 2;
+  // Visible for testing
+  long unacknowledgedBytesRead = 0;
+
+  /**
+   * Count of bytes that can be written on the stream before receiving a
+   * window update. Even if this is positive, writes will block until there
+   * available bytes in {@code connection.bytesLeftInWriteWindow}.
+   */
+  // guarded by this
+  long bytesLeftInWriteWindow;
 
   private final int id;
   private final SpdyConnection connection;
   private final int priority;
   private long readTimeoutMillis = 0;
-  private int writeWindowSize;
 
   /** Headers sent by the stream initiator. Immutable and non null. */
-  private final List<String> requestHeaders;
+  private final List<Header> requestHeaders;
 
   /** Headers sent in the stream reply. Null if reply is either not sent or not sent yet. */
-  private List<String> responseHeaders;
+  private List<Header> responseHeaders;
 
-  private final SpdyDataInputStream in = new SpdyDataInputStream();
-  private final SpdyDataOutputStream out = new SpdyDataOutputStream();
+  private final SpdyDataInputStream in;
+  final SpdyDataOutputStream out;
 
   /**
    * The reason why this stream was abnormally closed. If there are multiple
@@ -64,17 +72,18 @@
   private ErrorCode errorCode = null;
 
   SpdyStream(int id, SpdyConnection connection, boolean outFinished, boolean inFinished,
-      int priority, List<String> requestHeaders, Settings settings) {
+      int priority, List<Header> requestHeaders) {
     if (connection == null) throw new NullPointerException("connection == null");
     if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
     this.id = id;
     this.connection = connection;
+    this.bytesLeftInWriteWindow = connection.peerSettings.getInitialWindowSize();
+    this.in = new SpdyDataInputStream(connection.okHttpSettings.getInitialWindowSize());
+    this.out = new SpdyDataOutputStream();
     this.in.finished = inFinished;
     this.out.finished = outFinished;
     this.priority = priority;
     this.requestHeaders = requestHeaders;
-
-    setSettings(settings);
   }
 
   /**
@@ -99,7 +108,7 @@ public synchronized boolean isOpen() {
 
   /** Returns true if this stream was created by this peer. */
   public boolean isLocallyInitiated() {
-    boolean streamIsClient = (id % 2 == 1);
+    boolean streamIsClient = ((id & 1) == 1);
     return connection.client == streamIsClient;
   }
 
@@ -107,7 +116,7 @@ public SpdyConnection getConnection() {
     return connection;
   }
 
-  public List<String> getRequestHeaders() {
+  public List<Header> getRequestHeaders() {
     return requestHeaders;
   }
 
@@ -115,10 +124,24 @@ public SpdyConnection getConnection() {
    * Returns the stream's response headers, blocking if necessary if they
    * have not been received yet.
    */
-  public synchronized List<String> getResponseHeaders() throws IOException {
+  public synchronized List<Header> getResponseHeaders() throws IOException {
+    long remaining = 0;
+    long start = 0;
+    if (readTimeoutMillis != 0) {
+      start = (System.nanoTime() / 1000000);
+      remaining = readTimeoutMillis;
+    }
     try {
       while (responseHeaders == null && errorCode == null) {
-        wait();
+        if (readTimeoutMillis == 0) { // No timeout configured.
+          wait();
+        } else if (remaining > 0) {
+          wait(remaining);
+          remaining = start + readTimeoutMillis - (System.nanoTime() / 1000000);
+        } else {
+          throw new SocketTimeoutException("Read response header timeout. readTimeoutMillis: "
+                            + readTimeoutMillis);
+        }
       }
       if (responseHeaders != null) {
         return responseHeaders;
@@ -145,7 +168,7 @@ public synchronized ErrorCode getErrorCode() {
    * @param out true to create an output stream that we can use to send data
    * to the remote peer. Corresponds to {@code FLAG_FIN}.
    */
-  public void reply(List<String> responseHeaders, boolean out) throws IOException {
+  public void reply(List<Header> responseHeaders, boolean out) throws IOException {
     assert (!Thread.holdsLock(SpdyStream.this));
     boolean outFinished = false;
     synchronized (this) {
@@ -238,7 +261,7 @@ private boolean closeInternal(ErrorCode errorCode) {
     return true;
   }
 
-  void receiveHeaders(List<String> headers, HeadersMode headersMode) {
+  void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
     assert (!Thread.holdsLock(SpdyStream.this));
     ErrorCode errorCode = null;
     boolean open = true;
@@ -255,7 +278,7 @@ void receiveHeaders(List<String> headers, HeadersMode headersMode) {
         if (headersMode.failIfHeadersPresent()) {
           errorCode = ErrorCode.STREAM_IN_USE;
         } else {
-          List<String> newHeaders = new ArrayList<String>();
+          List<Header> newHeaders = new ArrayList<Header>();
           newHeaders.addAll(responseHeaders);
           newHeaders.addAll(headers);
           this.responseHeaders = newHeaders;
@@ -294,26 +317,6 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     }
   }
 
-  private void setSettings(Settings settings) {
-    // TODO: For HTTP/2.0, also adjust the stream flow control window size
-    // by the difference between the new value and the old value.
-    assert (Thread.holdsLock(connection)); // Because 'settings' is guarded by 'connection'.
-    this.writeWindowSize = settings != null
-        ? settings.getInitialWindowSize(Settings.DEFAULT_INITIAL_WINDOW_SIZE)
-        : Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-  }
-
-  void receiveSettings(Settings settings) {
-    assert (Thread.holdsLock(this));
-    setSettings(settings);
-    notifyAll();
-  }
-
-  synchronized void receiveWindowUpdate(int deltaWindowSize) {
-    out.unacknowledgedBytes -= deltaWindowSize;
-    notifyAll();
-  }
-
   int getPriority() {
     return priority;
   }
@@ -324,6 +327,7 @@ int getPriority() {
    * it is not intended for use by multiple readers.
    */
   private final class SpdyDataInputStream extends InputStream {
+
     // Store incoming data bytes in a circular buffer. When the buffer is
     // empty, pos == -1. Otherwise pos is the first byte to read and limit
     // is the first byte to write.
@@ -335,8 +339,13 @@ int getPriority() {
     // { X X X - - - - X X X }
     //         ^       ^
     //       limit    pos
+    private final byte[] buffer;
 
-    private final byte[] buffer = new byte[Settings.DEFAULT_INITIAL_WINDOW_SIZE];
+    private SpdyDataInputStream(int bufferLength) {
+      // TODO: We probably need to change to growable buffers here pretty soon.
+      // Otherwise we have a performance problem where we pay for 64 KiB even if we aren't using it.
+      buffer = connection.bufferPool.getBuf(bufferLength);
+    }
 
     /** the next byte to be read, or -1 if the buffer is empty. Never buffer.length */
     private int pos = -1;
@@ -353,13 +362,6 @@ int getPriority() {
      */
     private boolean finished;
 
-    /**
-     * The total number of bytes consumed by the application (with {@link
-     * #read}), but not yet acknowledged by sending a {@code WINDOW_UPDATE}
-     * frame.
-     */
-    private int unacknowledgedBytes = 0;
-
     @Override public int available() throws IOException {
       synchronized (SpdyStream.this) {
         checkNotClosed();
@@ -378,6 +380,7 @@ int getPriority() {
     }
 
     @Override public int read(byte[] b, int offset, int count) throws IOException {
+      int copied = 0;
       synchronized (SpdyStream.this) {
         checkOffsetAndCount(b.length, offset, count);
         waitUntilReadable();
@@ -387,8 +390,6 @@ int getPriority() {
           return -1;
         }
 
-        int copied = 0;
-
         // drain from [pos..buffer.length)
         if (limit <= pos) {
           int bytesToCopy = Math.min(count, buffer.length - pos);
@@ -409,19 +410,27 @@ int getPriority() {
         }
 
         // Flow control: notify the peer that we're ready for more data!
-        unacknowledgedBytes += copied;
-        if (unacknowledgedBytes >= WINDOW_UPDATE_THRESHOLD) {
-          connection.writeWindowUpdateLater(id, unacknowledgedBytes);
-          unacknowledgedBytes = 0;
+        unacknowledgedBytesRead += copied;
+        if (unacknowledgedBytesRead >= connection.okHttpSettings.getInitialWindowSize() / 2) {
+          connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
+          unacknowledgedBytesRead = 0;
         }
 
         if (pos == limit) {
           pos = -1;
           limit = 0;
         }
-
-        return copied;
       }
+      // Update connection.unacknowledgedBytesRead outside the stream lock.
+      synchronized (connection) { // Multiple application threads may hit this section.
+        connection.unacknowledgedBytesRead += copied;
+        if (connection.unacknowledgedBytesRead
+            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
+          connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
+          connection.unacknowledgedBytesRead = 0;
+        }
+      }
+      return copied;
     }
 
     /**
@@ -516,6 +525,7 @@ void receive(InputStream in, int byteCount) throws IOException {
       synchronized (SpdyStream.this) {
         closed = true;
         SpdyStream.this.notifyAll();
+        SpdyStream.this.connection.bufferPool.returnBuf(buffer);
       }
       cancelStreamIfNecessary();
     }
@@ -553,8 +563,8 @@ private void cancelStreamIfNecessary() throws IOException {
    * An output stream that writes outgoing data frames of a stream. This class
    * is not thread safe.
    */
-  private final class SpdyDataOutputStream extends OutputStream {
-    private final byte[] buffer = new byte[8192];
+  final class SpdyDataOutputStream extends OutputStream {
+    private final byte[] buffer = SpdyStream.this.connection.bufferPool.getBuf(OUTPUT_BUFFER_SIZE);
     private int pos = 0;
 
     /** True if the caller has closed this stream. */
@@ -566,13 +576,6 @@ private void cancelStreamIfNecessary() throws IOException {
      */
     private boolean finished;
 
-    /**
-     * The total number of bytes written out to the peer, but not yet
-     * acknowledged with an incoming {@code WINDOW_UPDATE} frame. Writes
-     * block if they cause this to exceed the {@code WINDOW_SIZE}.
-     */
-    private int unacknowledgedBytes = 0;
-
     @Override public void write(int b) throws IOException {
       Util.writeSingleByte(this, b);
     }
@@ -580,11 +583,13 @@ private void cancelStreamIfNecessary() throws IOException {
     @Override public void write(byte[] bytes, int offset, int count) throws IOException {
       assert (!Thread.holdsLock(SpdyStream.this));
       checkOffsetAndCount(bytes.length, offset, count);
-      checkNotClosed();
+      synchronized (SpdyStream.this) {
+        checkOutNotClosed();
+      }
 
       while (count > 0) {
         if (pos == buffer.length) {
-          writeFrame(false);
+          writeFrame();
         }
         int bytesToCopy = Math.min(count, buffer.length - pos);
         System.arraycopy(bytes, offset, buffer, pos, bytesToCopy);
@@ -596,9 +601,11 @@ private void cancelStreamIfNecessary() throws IOException {
 
     @Override public void flush() throws IOException {
       assert (!Thread.holdsLock(SpdyStream.this));
-      checkNotClosed();
+      synchronized (SpdyStream.this) {
+        checkOutNotClosed();
+      }
       if (pos > 0) {
-        writeFrame(false);
+        writeFrame();
         connection.flush();
       }
     }
@@ -610,61 +617,56 @@ private void cancelStreamIfNecessary() throws IOException {
           return;
         }
         closed = true;
+        SpdyStream.this.connection.bufferPool.returnBuf(buffer);
       }
       if (!out.finished) {
-        writeFrame(true);
+        connection.writeData(id, true, buffer, 0, pos);
       }
       connection.flush();
       cancelStreamIfNecessary();
     }
 
-    private void writeFrame(boolean outFinished) throws IOException {
+    private void writeFrame() throws IOException {
       assert (!Thread.holdsLock(SpdyStream.this));
 
       int length = pos;
       synchronized (SpdyStream.this) {
-        waitUntilWritable(length, outFinished);
-        unacknowledgedBytes += length;
+        waitUntilWritable(length);
+        checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
+        bytesLeftInWriteWindow -= length;
       }
-      connection.writeData(id, outFinished, buffer, 0, pos);
+      connection.writeData(id, false, buffer, 0, pos);
       pos = 0;
     }
+  }
 
-    /**
-     * Returns once the peer is ready to receive {@code count} bytes.
-     *
-     * @throws IOException if the stream was finished or closed, or the
-     * thread was interrupted.
-     */
-    private void waitUntilWritable(int count, boolean last) throws IOException {
-      try {
-        while (unacknowledgedBytes + count >= writeWindowSize) {
-          SpdyStream.this.wait(); // Wait until we receive a WINDOW_UPDATE.
-
-          // The stream may have been closed or reset while we were waiting!
-          if (!last && closed) {
-            throw new IOException("stream closed");
-          } else if (finished) {
-            throw new IOException("stream finished");
-          } else if (errorCode != null) {
-            throw new IOException("stream was reset: " + errorCode);
-          }
-        }
-      } catch (InterruptedException e) {
-        throw new InterruptedIOException();
+  /** Returns once the peer is ready to receive {@code byteCount} bytes. */
+  private void waitUntilWritable(int byteCount) throws IOException {
+    try {
+      while (byteCount > bytesLeftInWriteWindow) {
+        SpdyStream.this.wait(); // Wait until we receive a WINDOW_UPDATE.
       }
+    } catch (InterruptedException e) {
+      throw new InterruptedIOException();
     }
+  }
 
-    private void checkNotClosed() throws IOException {
-      synchronized (SpdyStream.this) {
-        if (closed) {
-          throw new IOException("stream closed");
-        } else if (finished) {
-          throw new IOException("stream finished");
-        } else if (errorCode != null) {
-          throw new IOException("stream was reset: " + errorCode);
-        }
-      }
+  /**
+   * {@code delta} will be negative if a settings frame initial window is
+   * smaller than the last.
+   */
+  void addBytesToWriteWindow(long delta) {
+    bytesLeftInWriteWindow += delta;
+    if (delta > 0) SpdyStream.this.notifyAll();
+  }
+
+  private void checkOutNotClosed() throws IOException {
+    if (out.closed) {
+      throw new IOException("stream closed");
+    } else if (out.finished) {
+      throw new IOException("stream finished");
+    } else if (errorCode != null) {
+      throw new IOException("stream was reset: " + errorCode);
     }
   }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
index 06de317852..784d02ef26 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
+++ b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
@@ -15,23 +15,23 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.Protocol;
 import java.io.InputStream;
 import java.io.OutputStream;
 
 /** A version and dialect of the framed socket protocol. */
 interface Variant {
-  Variant SPDY3 = new Spdy3();
-  Variant HTTP_20_DRAFT_04 = new Http20Draft04();
+
+  /** The protocol as selected using NPN or ALPN. */
+  Protocol getProtocol();
 
   /**
-   * @param client true if this is the HTTP client's reader, reading frames from
-   *     a peer SPDY or HTTP/2 server.
+   * @param client true if this is the HTTP client's reader, reading frames from a server.
    */
   FrameReader newReader(InputStream in, boolean client);
 
   /**
-   * @param client true if this is the HTTP client's writer, writing frames to a
-   *     peer SPDY or HTTP/2 server.
+   * @param client true if this is the HTTP client's writer, writing frames to a server.
    */
   FrameWriter newWriter(OutputStream out, boolean client);
 }
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
new file mode 100644
index 0000000000..7f80c3b949
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
@@ -0,0 +1,190 @@
+/*
+ * Copyright 2014 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import java.math.BigInteger;
+import org.junit.Test;
+
+import static java.util.Arrays.asList;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class BitArrayTest {
+
+  /** Lazy grow into a variable capacity bit set. */
+  @Test public void hpackUseCase() {
+    BitArray b = new BitArray.FixedCapacity();
+    for (int i = 0; i < 64; i++) {
+      b.set(i);
+    }
+    assertTrue(b.get(0));
+    assertTrue(b.get(1));
+    assertTrue(b.get(63));
+    try {
+      b.get(64);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    b = ((BitArray.FixedCapacity) b).toVariableCapacity();
+    assertTrue(b.get(0));
+    assertTrue(b.get(1));
+    assertTrue(b.get(63));
+    assertFalse(b.get(64));
+    b.set(64);
+    assertTrue(b.get(64));
+  }
+
+  @Test public void setExpandsData_FixedCapacity() {
+    BitArray.FixedCapacity b = new BitArray.FixedCapacity();
+    b.set(63);
+    assertEquals(b.data, BigInteger.ZERO.setBit(63).longValue());
+  }
+
+  @Test public void toggleBit_FixedCapacity() {
+    BitArray.FixedCapacity b = new BitArray.FixedCapacity();
+    b.set(63);
+    b.toggle(63);
+    assertEquals(b.data, 0l);
+    b.toggle(1);
+    assertEquals(b.data, 2l);
+  }
+
+  @Test public void shiftLeft_FixedCapacity() {
+    BitArray.FixedCapacity b = new BitArray.FixedCapacity();
+    b.set(0);
+    b.shiftLeft(1);
+    assertEquals(b.data, 2l);
+  }
+
+  @Test public void multipleShifts_FixedCapacity() {
+    BitArray.FixedCapacity b = new BitArray.FixedCapacity();
+    b.set(10);
+    b.shiftLeft(2);
+    b.shiftLeft(2);
+    assertEquals(b.data, BigInteger.ZERO.setBit(10).shiftLeft(2).shiftLeft(2).longValue());
+  }
+
+  @Test public void clearBits_FixedCapacity() {
+    BitArray.FixedCapacity b = new BitArray.FixedCapacity();
+    b.set(1);
+    b.set(3);
+    b.set(5);
+    b.clear();
+    assertEquals(b.data, 0l);
+  }
+
+  @Test public void setExpandsData_VariableCapacity() {
+    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
+    b.set(64);
+    assertEquals(asList(64), b.toIntegerList());
+  }
+
+  @Test public void toggleBit_VariableCapacity() {
+    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
+    b.set(100);
+    b.toggle(100);
+    assertTrue(b.toIntegerList().isEmpty());
+    b.toggle(1);
+    assertEquals(asList(1), b.toIntegerList());
+  }
+
+  @Test public void shiftLeftExpandsData_VariableCapacity() {
+    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
+    b.set(0);
+    b.shiftLeft(64);
+    assertEquals(asList(64), b.toIntegerList());
+  }
+
+  @Test public void shiftLeftFromZero_VariableCapacity() {
+    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
+    b.set(0);
+    b.shiftLeft(1);
+    assertEquals(asList(1), b.toIntegerList());
+  }
+
+  @Test public void shiftLeftAcrossOffset_VariableCapacity() {
+    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
+    b.set(63);
+    assertEquals(1, b.data.length);
+    b.shiftLeft(1);
+    assertEquals(asList(64), b.toIntegerList());
+    assertEquals(2, b.data.length);
+  }
+
+  @Test public void multipleShiftsLeftAcrossOffset_VariableCapacity() {
+    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
+    b.set(1000);
+    b.shiftLeft(67);
+    assertEquals(asList(1067), b.toIntegerList());
+    b.shiftLeft(69);
+    assertEquals(asList(1136), b.toIntegerList());
+  }
+
+  @Test public void clearBits_VariableCapacity() {
+    BitArray.VariableCapacity b = new BitArray.VariableCapacity();
+    b.set(10);
+    b.set(100);
+    b.set(1000);
+    b.clear();
+    assertTrue(b.toIntegerList().isEmpty());
+  }
+
+  @Test public void bigIntegerSanityCheck_VariableCapacity() {
+    BitArray a = new BitArray.VariableCapacity();
+    BigInteger b = BigInteger.ZERO;
+
+    a.set(64);
+    b = b.setBit(64);
+    assertEquals(bigIntegerToString(b), a.toString());
+
+    a.set(1000000);
+    b = b.setBit(1000000);
+    assertEquals(bigIntegerToString(b), a.toString());
+
+    a.shiftLeft(100);
+    b = b.shiftLeft(100);
+    assertEquals(bigIntegerToString(b), a.toString());
+
+    a.set(0xF00D);
+    b = b.setBit(0xF00D);
+    a.set(0xBEEF);
+    b = b.setBit(0xBEEF);
+    a.set(0xDEAD);
+    b = b.setBit(0xDEAD);
+    assertEquals(bigIntegerToString(b), a.toString());
+
+    a.shiftLeft(0xB0B);
+    b = b.shiftLeft(0xB0B);
+    assertEquals(bigIntegerToString(b), a.toString());
+
+    a.toggle(64280);
+    b = b.clearBit(64280);
+    assertEquals(bigIntegerToString(b), a.toString());
+  }
+
+  private static String bigIntegerToString(BigInteger b) {
+    StringBuilder builder = new StringBuilder("{");
+    for (int i = 0, count = b.bitLength(); i < count; i++) {
+      if (b.testBit(i)) {
+        builder.append(i).append(',');
+      }
+    }
+    builder.setCharAt(builder.length() - 1, '}');
+    return builder.toString();
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
new file mode 100644
index 0000000000..34d37e049c
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2014 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal;
+
+import com.squareup.okhttp.internal.bytes.ByteString;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
+import java.util.Arrays;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class ByteStringTest {
+
+  @Test public void equals() throws Exception {
+    ByteString byteString = ByteString.of((byte) 0x0, (byte) 0x1, (byte) 0x2);
+    assertTrue(byteString.equals(byteString));
+    assertTrue(byteString.equals(ByteString.of((byte) 0x0, (byte) 0x1, (byte) 0x2)));
+    assertTrue(ByteString.of().equals(ByteString.EMPTY));
+    assertTrue(ByteString.EMPTY.equals(ByteString.of()));
+    assertFalse(byteString.equals(new Object()));
+    assertFalse(byteString.equals(ByteString.of((byte) 0x0, (byte) 0x2, (byte) 0x1)));
+  }
+
+  private final String bronzeHorseman = "   ";
+
+  @Test public void utf8() throws Exception {
+    ByteString byteString = ByteString.encodeUtf8(bronzeHorseman);
+    assertByteArraysEquals(byteString.toByteArray(), bronzeHorseman.getBytes(Util.UTF_8));
+    assertTrue(byteString.equals(ByteString.of(bronzeHorseman.getBytes(Util.UTF_8))));
+    assertEquals(byteString.utf8(), bronzeHorseman);
+  }
+
+  @Test public void equalsAscii() throws Exception {
+    ByteString byteString = ByteString.encodeUtf8("Content-Length");
+    assertTrue(byteString.equalsAscii("Content-Length"));
+    assertFalse(byteString.equalsAscii("content-length"));
+    assertFalse(ByteString.of((byte) 0x63).equalsAscii(null));
+    assertFalse(byteString.equalsAscii(bronzeHorseman));
+    assertFalse(ByteString.encodeUtf8("Content-Length").equalsAscii("content-length"));
+  }
+
+  @Test public void testHashCode() throws Exception {
+    ByteString byteString = ByteString.of((byte) 0x1, (byte) 0x2);
+    assertEquals(byteString.hashCode(), byteString.hashCode());
+    assertEquals(byteString.hashCode(), ByteString.of((byte) 0x1, (byte) 0x2).hashCode());
+  }
+
+  @Test public void read() throws Exception {
+    InputStream in = new ByteArrayInputStream("abc".getBytes(Util.UTF_8));
+    assertEquals(ByteString.of((byte) 0x61, (byte) 0x62), ByteString.read(in, 2));
+    assertEquals(ByteString.of((byte) 0x63), ByteString.read(in, 1));
+    assertEquals(ByteString.of(), ByteString.read(in, 0));
+  }
+
+  @Test public void readLowerCase() throws Exception {
+    InputStream in = new ByteArrayInputStream("ABC".getBytes(Util.UTF_8));
+    assertEquals(ByteString.of((byte) 0x61, (byte) 0x62), ByteString.readLowerCase(in, 2));
+    assertEquals(ByteString.of((byte) 0x63), ByteString.readLowerCase(in, 1));
+    assertEquals(ByteString.of(), ByteString.readLowerCase(in, 0));
+  }
+
+  @Test public void write() throws Exception {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    ByteString.of((byte) 0x61, (byte) 0x62, (byte) 0x63).write(out);
+    assertByteArraysEquals(new byte[] { 0x61, 0x62, 0x63 }, out.toByteArray());
+  }
+
+  @Test public void concat() {
+    assertEquals(ByteString.of(), ByteString.concat());
+    assertEquals(ByteString.of(), ByteString.concat(ByteString.EMPTY));
+    assertEquals(ByteString.of(), ByteString.concat(ByteString.EMPTY, ByteString.EMPTY));
+    ByteString foo = ByteString.encodeUtf8("foo");
+    ByteString bar = ByteString.encodeUtf8("bar");
+    assertEquals(foo, ByteString.concat(foo));
+    assertEquals(ByteString.encodeUtf8("foobar"), ByteString.concat(foo, bar));
+  }
+
+  private static void assertByteArraysEquals(byte[] a, byte[] b) {
+    assertEquals(Arrays.toString(a), Arrays.toString(b));
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/InflaterSourceTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/InflaterSourceTest.java
new file mode 100644
index 0000000000..df07f65649
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/InflaterSourceTest.java
@@ -0,0 +1,111 @@
+package com.squareup.okhttp.internal.bytes;
+
+import com.squareup.okhttp.internal.Base64;
+import com.squareup.okhttp.internal.Util;
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.Inflater;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class InflaterSourceTest {
+  @Test public void inflate() throws Exception {
+    OkBuffer deflated = decodeBase64("eJxzz09RyEjNKVAoLdZRKE9VL0pVyMxTKMlIVchIzEspVshPU0jNS8/MS00tK"
+        + "tYDAF6CD5s=");
+    OkBuffer inflated = inflate(deflated);
+    assertEquals("God help us, we're in the hands of engineers.", readUtf8(inflated));
+  }
+
+  @Test public void inflateTruncated() throws Exception {
+    OkBuffer deflated = decodeBase64("eJxzz09RyEjNKVAoLdZRKE9VL0pVyMxTKMlIVchIzEspVshPU0jNS8/MS00tK"
+        + "tYDAF6CDw==");
+    try {
+      inflate(deflated);
+      fail();
+    } catch (EOFException expected) {
+    }
+  }
+
+  @Test public void inflateWellCompressed() throws Exception {
+    OkBuffer deflated = decodeBase64("eJztwTEBAAAAwqCs61/CEL5AAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8B"
+        + "tFeWvE=\n");
+    String original = repeat('a', 1024 * 1024);
+    OkBuffer inflated = inflate(deflated);
+    assertEquals(original, readUtf8(inflated));
+  }
+
+  @Test public void inflatePoorlyCompressed() throws Exception {
+    ByteString original = randomBytes(1024 * 1024);
+    OkBuffer deflated = deflate(toBuffer(original));
+    OkBuffer inflated = inflate(deflated);
+    assertEquals(original, inflated.readByteString((int) inflated.byteCount()));
+  }
+
+  private OkBuffer decodeBase64(String s) {
+    OkBuffer result = new OkBuffer();
+    byte[] data = Base64.decode(s.getBytes(Util.UTF_8));
+    result.write(data, 0, data.length);
+    return result;
+  }
+
+  private String readUtf8(OkBuffer buffer) {
+    return buffer.readUtf8((int) buffer.byteCount());
+  }
+
+  /** Use DeflaterOutputStream to deflate source. */
+  private OkBuffer deflate(OkBuffer buffer) throws IOException {
+    OkBuffer result = new OkBuffer();
+    Sink sink = OkBuffers.sink(new DeflaterOutputStream(OkBuffers.outputStream(result)));
+    sink.write(buffer, buffer.byteCount(), Deadline.NONE);
+    sink.close(Deadline.NONE);
+    return result;
+  }
+
+  private OkBuffer toBuffer(ByteString byteString) {
+    OkBuffer byteStringBuffer = new OkBuffer();
+    byteStringBuffer.write(byteString);
+    return byteStringBuffer;
+  }
+
+  /** Returns a new buffer containing the inflated contents of {@code deflated}. */
+  private OkBuffer inflate(OkBuffer deflated) throws IOException {
+    OkBuffer result = new OkBuffer();
+    InflaterSource source = new InflaterSource(deflated, new Inflater());
+    while (source.read(result, Integer.MAX_VALUE, Deadline.NONE) != -1) {
+    }
+    return result;
+  }
+
+  private ByteString randomBytes(int length) {
+    Random random = new Random(0);
+    byte[] randomBytes = new byte[length];
+    random.nextBytes(randomBytes);
+    return ByteString.of(randomBytes);
+  }
+
+  private String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
new file mode 100644
index 0000000000..eedb9def75
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/bytes/OkBufferTest.java
@@ -0,0 +1,502 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.bytes;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.Util.UTF_8;
+import static java.util.Arrays.asList;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class OkBufferTest {
+  @Test public void readAndWriteUtf8() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8("ab");
+    assertEquals(2, buffer.byteCount());
+    buffer.writeUtf8("cdef");
+    assertEquals(6, buffer.byteCount());
+    assertEquals("abcd", buffer.readUtf8(4));
+    assertEquals(2, buffer.byteCount());
+    assertEquals("ef", buffer.readUtf8(2));
+    assertEquals(0, buffer.byteCount());
+    try {
+      buffer.readUtf8(1);
+      fail();
+    } catch (ArrayIndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void bufferToString() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8("\u0000\u0001\u0002\u007f");
+    assertEquals("0001027f", buffer.toString());
+  }
+
+  @Test public void multipleSegmentBuffers() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(repeat('a',  1000));
+    buffer.writeUtf8(repeat('b', 2500));
+    buffer.writeUtf8(repeat('c', 5000));
+    buffer.writeUtf8(repeat('d', 10000));
+    buffer.writeUtf8(repeat('e', 25000));
+    buffer.writeUtf8(repeat('f', 50000));
+
+    assertEquals(repeat('a', 999), buffer.readUtf8(999)); // a...a
+    assertEquals("a" + repeat('b', 2500) + "c", buffer.readUtf8(2502)); // ab...bc
+    assertEquals(repeat('c', 4998), buffer.readUtf8(4998)); // c...c
+    assertEquals("c" + repeat('d', 10000) + "e", buffer.readUtf8(10002)); // cd...de
+    assertEquals(repeat('e', 24998), buffer.readUtf8(24998)); // e...e
+    assertEquals("e" + repeat('f', 50000), buffer.readUtf8(50001)); // ef...f
+    assertEquals(0, buffer.byteCount());
+  }
+
+  @Test public void fillAndDrainPool() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+
+    // Take 2 * MAX_SIZE segments. This will drain the pool, even if other tests filled it.
+    buffer.write(ByteString.of(new byte[(int) SegmentPool.MAX_SIZE]));
+    buffer.write(ByteString.of(new byte[(int) SegmentPool.MAX_SIZE]));
+    assertEquals(0, SegmentPool.INSTANCE.byteCount);
+
+    // Recycle MAX_SIZE segments. They're all in the pool.
+    buffer.readByteString((int) SegmentPool.MAX_SIZE);
+    assertEquals(SegmentPool.MAX_SIZE, SegmentPool.INSTANCE.byteCount);
+
+    // Recycle MAX_SIZE more segments. The pool is full so they get garbage collected.
+    buffer.readByteString((int) SegmentPool.MAX_SIZE);
+    assertEquals(SegmentPool.MAX_SIZE, SegmentPool.INSTANCE.byteCount);
+
+    // Take MAX_SIZE segments to drain the pool.
+    buffer.write(ByteString.of(new byte[(int) SegmentPool.MAX_SIZE]));
+    assertEquals(0, SegmentPool.INSTANCE.byteCount);
+
+    // Take MAX_SIZE more segments. The pool is drained so these will need to be allocated.
+    buffer.write(ByteString.of(new byte[(int) SegmentPool.MAX_SIZE]));
+    assertEquals(0, SegmentPool.INSTANCE.byteCount);
+  }
+
+  @Test public void moveBytesBetweenBuffersShareSegment() throws Exception {
+    int size = (Segment.SIZE / 2) - 1;
+    List<Integer> segmentSizes = moveBytesBetweenBuffers(repeat('a', size), repeat('b', size));
+    assertEquals(asList(size * 2), segmentSizes);
+  }
+
+  @Test public void moveBytesBetweenBuffersReassignSegment() throws Exception {
+    int size = (Segment.SIZE / 2) + 1;
+    List<Integer> segmentSizes = moveBytesBetweenBuffers(repeat('a', size), repeat('b', size));
+    assertEquals(asList(size, size), segmentSizes);
+  }
+
+  @Test public void moveBytesBetweenBuffersMultipleSegments() throws Exception {
+    int size = 3 * Segment.SIZE + 1;
+    List<Integer> segmentSizes = moveBytesBetweenBuffers(repeat('a', size), repeat('b', size));
+    assertEquals(asList(Segment.SIZE, Segment.SIZE, Segment.SIZE, 1,
+        Segment.SIZE, Segment.SIZE, Segment.SIZE, 1), segmentSizes);
+  }
+
+  private List<Integer> moveBytesBetweenBuffers(String... contents) {
+    StringBuilder expected = new StringBuilder();
+    OkBuffer buffer = new OkBuffer();
+    for (String s : contents) {
+      OkBuffer source = new OkBuffer();
+      source.writeUtf8(s);
+      buffer.write(source, source.byteCount(), Deadline.NONE);
+      expected.append(s);
+    }
+    List<Integer> segmentSizes = buffer.segmentSizes();
+    assertEquals(expected.toString(), buffer.readUtf8(expected.length()));
+    return segmentSizes;
+  }
+
+  /** The big part of source's first segment is being moved. */
+  @Test public void writeSplitSourceBufferLeft() throws Exception {
+    int writeSize = Segment.SIZE / 2 + 1;
+
+    OkBuffer sink = new OkBuffer();
+    sink.writeUtf8(repeat('b', Segment.SIZE - 10));
+
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('a', Segment.SIZE * 2));
+    sink.write(source, writeSize, Deadline.NONE);
+
+    assertEquals(asList(Segment.SIZE - 10, writeSize), sink.segmentSizes());
+    assertEquals(asList(Segment.SIZE - writeSize, Segment.SIZE), source.segmentSizes());
+  }
+
+  /** The big part of source's first segment is staying put. */
+  @Test public void writeSplitSourceBufferRight() throws Exception {
+    int writeSize = Segment.SIZE / 2 - 1;
+
+    OkBuffer sink = new OkBuffer();
+    sink.writeUtf8(repeat('b', Segment.SIZE - 10));
+
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('a', Segment.SIZE * 2));
+    sink.write(source, writeSize, Deadline.NONE);
+
+    assertEquals(asList(Segment.SIZE - 10, writeSize), sink.segmentSizes());
+    assertEquals(asList(Segment.SIZE - writeSize, Segment.SIZE), source.segmentSizes());
+  }
+
+  @Test public void writePrefixDoesntSplit() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    sink.writeUtf8(repeat('b', 10));
+
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('a', Segment.SIZE * 2));
+    sink.write(source, 20, Deadline.NONE);
+
+    assertEquals(asList(30), sink.segmentSizes());
+    assertEquals(asList(Segment.SIZE - 20, Segment.SIZE), source.segmentSizes());
+    assertEquals(30, sink.byteCount());
+    assertEquals(Segment.SIZE * 2 - 20, source.byteCount());
+  }
+
+  @Test public void writePrefixDoesntSplitButRequiresCompact() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    sink.writeUtf8(repeat('b', Segment.SIZE - 10)); // limit = size - 10
+    sink.readUtf8(Segment.SIZE - 20); // pos = size = 20
+
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('a', Segment.SIZE * 2));
+    sink.write(source, 20, Deadline.NONE);
+
+    assertEquals(asList(30), sink.segmentSizes());
+    assertEquals(asList(Segment.SIZE - 20, Segment.SIZE), source.segmentSizes());
+    assertEquals(30, sink.byteCount());
+    assertEquals(Segment.SIZE * 2 - 20, source.byteCount());
+  }
+
+  @Test public void readExhaustedSource() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    sink.writeUtf8(repeat('a', 10));
+
+    OkBuffer source = new OkBuffer();
+
+    assertEquals(-1, source.read(sink, 10, Deadline.NONE));
+    assertEquals(10, sink.byteCount());
+    assertEquals(0, source.byteCount());
+  }
+
+  @Test public void readZeroBytesFromSource() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    sink.writeUtf8(repeat('a', 10));
+
+    OkBuffer source = new OkBuffer();
+
+    // Either 0 or -1 is reasonable here. For consistency with Android's
+    // ByteArrayInputStream we return 0.
+    assertEquals(-1, source.read(sink, 0, Deadline.NONE));
+    assertEquals(10, sink.byteCount());
+    assertEquals(0, source.byteCount());
+  }
+
+  @Test public void moveAllRequestedBytesWithRead() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    sink.writeUtf8(repeat('a', 10));
+
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('b', 15));
+
+    assertEquals(10, source.read(sink, 10, Deadline.NONE));
+    assertEquals(20, sink.byteCount());
+    assertEquals(5, source.byteCount());
+    assertEquals(repeat('a', 10) + repeat('b', 10), sink.readUtf8(20));
+  }
+
+  @Test public void moveFewerThanRequestedBytesWithRead() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    sink.writeUtf8(repeat('a', 10));
+
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('b', 20));
+
+    assertEquals(20, source.read(sink, 25, Deadline.NONE));
+    assertEquals(30, sink.byteCount());
+    assertEquals(0, source.byteCount());
+    assertEquals(repeat('a', 10) + repeat('b', 20), sink.readUtf8(30));
+  }
+
+  @Test public void indexOf() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+
+    // The segment is empty.
+    assertEquals(-1, buffer.indexOf((byte) 'a'));
+
+    // The segment has one value.
+    buffer.writeUtf8("a"); // a
+    assertEquals(0, buffer.indexOf((byte) 'a'));
+    assertEquals(-1, buffer.indexOf((byte) 'b'));
+
+    // The segment has lots of data.
+    buffer.writeUtf8(repeat('b', Segment.SIZE - 2)); // ab...b
+    assertEquals(0, buffer.indexOf((byte) 'a'));
+    assertEquals(1, buffer.indexOf((byte) 'b'));
+    assertEquals(-1, buffer.indexOf((byte) 'c'));
+
+    // The segment doesn't start at 0, it starts at 2.
+    buffer.readUtf8(2); // b...b
+    assertEquals(-1, buffer.indexOf((byte) 'a'));
+    assertEquals(0, buffer.indexOf((byte) 'b'));
+    assertEquals(-1, buffer.indexOf((byte) 'c'));
+
+    // The segment is full.
+    buffer.writeUtf8("c"); // b...bc
+    assertEquals(-1, buffer.indexOf((byte) 'a'));
+    assertEquals(0, buffer.indexOf((byte) 'b'));
+    assertEquals(Segment.SIZE - 3, buffer.indexOf((byte) 'c'));
+
+    // The segment doesn't start at 2, it starts at 4.
+    buffer.readUtf8(2); // b...bc
+    assertEquals(-1, buffer.indexOf((byte) 'a'));
+    assertEquals(0, buffer.indexOf((byte) 'b'));
+    assertEquals(Segment.SIZE - 5, buffer.indexOf((byte) 'c'));
+
+    // Two segments.
+    buffer.writeUtf8("d"); // b...bcd, d is in the 2nd segment.
+    assertEquals(asList(Segment.SIZE - 4, 1), buffer.segmentSizes());
+    assertEquals(Segment.SIZE - 4, buffer.indexOf((byte) 'd'));
+    assertEquals(-1, buffer.indexOf((byte) 'e'));
+  }
+
+  @Test public void sinkFromOutputStream() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8("a");
+    data.writeUtf8(repeat('b', 9998));
+    data.writeUtf8("c");
+
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    Sink sink = OkBuffers.sink(out);
+    sink.write(data, 3, Deadline.NONE);
+    assertEquals("abb", out.toString("UTF-8"));
+    sink.write(data, data.byteCount(), Deadline.NONE);
+    assertEquals("a" + repeat('b', 9998) + "c", out.toString("UTF-8"));
+  }
+
+  @Test public void outputStreamFromSink() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    OutputStream out = OkBuffers.outputStream(sink);
+    out.write('a');
+    out.write(repeat('b', 9998).getBytes(UTF_8));
+    out.write('c');
+    out.flush();
+    assertEquals("a" + repeat('b', 9998) + "c", sink.readUtf8(10000));
+  }
+
+  @Test public void outputStreamFromSinkBounds() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    OutputStream out = OkBuffers.outputStream(sink);
+    try {
+      out.write(new byte[100], 50, 51);
+      fail();
+    } catch (ArrayIndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void sourceFromInputStream() throws Exception {
+    InputStream in = new ByteArrayInputStream(
+        ("a" + repeat('b', Segment.SIZE * 2) + "c").getBytes(UTF_8));
+
+    // Source: ab...bc
+    Source source = OkBuffers.source(in);
+    OkBuffer sink = new OkBuffer();
+
+    // Source: b...bc. Sink: abb.
+    assertEquals(3, source.read(sink, 3, Deadline.NONE));
+    assertEquals("abb", sink.readUtf8(3));
+
+    // Source: b...bc. Sink: b...b.
+    assertEquals(Segment.SIZE, source.read(sink, 20000, Deadline.NONE));
+    assertEquals(repeat('b', Segment.SIZE), sink.readUtf8((int) sink.byteCount()));
+
+    // Source: b...bc. Sink: b...bc.
+    assertEquals(Segment.SIZE - 1, source.read(sink, 20000, Deadline.NONE));
+    assertEquals(repeat('b', Segment.SIZE - 2) + "c", sink.readUtf8((int) sink.byteCount()));
+
+    // Source and sink are empty.
+    assertEquals(-1, source.read(sink, 1, Deadline.NONE));
+  }
+
+  @Test public void sourceFromInputStreamBounds() throws Exception {
+    Source source = OkBuffers.source(new ByteArrayInputStream(new byte[100]));
+    try {
+      source.read(new OkBuffer(), -1, Deadline.NONE);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void inputStreamFromSource() throws Exception {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8("a");
+    source.writeUtf8(repeat('b', Segment.SIZE));
+    source.writeUtf8("c");
+
+    InputStream in = OkBuffers.inputStream(source);
+    assertEquals(0, in.available());
+    assertEquals(Segment.SIZE + 2, source.byteCount());
+
+    // Reading one byte buffers a full segment.
+    assertEquals('a', in.read());
+    assertEquals(Segment.SIZE - 1, in.available());
+    assertEquals(2, source.byteCount());
+
+    // Reading as much as possible reads the rest of that buffered segment.
+    byte[] data = new byte[Segment.SIZE * 2];
+    assertEquals(Segment.SIZE - 1, in.read(data, 0, data.length));
+    assertEquals(repeat('b', Segment.SIZE - 1), new String(data, 0, Segment.SIZE - 1, UTF_8));
+    assertEquals(2, source.byteCount());
+
+    // Continuing to read buffers the next segment.
+    assertEquals('b', in.read());
+    assertEquals(1, in.available());
+    assertEquals(0, source.byteCount());
+
+    // Continuing to read reads from the buffer.
+    assertEquals('c', in.read());
+    assertEquals(0, in.available());
+    assertEquals(0, source.byteCount());
+
+    // Once we've exhausted the source, we're done.
+    assertEquals(-1, in.read());
+    assertEquals(0, source.byteCount());
+  }
+
+  @Test public void inputStreamFromSourceBounds() throws IOException {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('a', 100));
+    InputStream in = OkBuffers.inputStream(source);
+    try {
+      in.read(new byte[100], 50, 51);
+      fail();
+    } catch (ArrayIndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void writeBytes() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeByte(0xab);
+    data.writeByte(0xcd);
+    assertEquals("abcd", data.toString());
+  }
+
+  @Test public void writeLastByteInSegment() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 1));
+    data.writeByte(0x20);
+    data.writeByte(0x21);
+    assertEquals(asList(Segment.SIZE, 1), data.segmentSizes());
+    assertEquals(repeat('a', Segment.SIZE - 1), data.readUtf8(Segment.SIZE - 1));
+    assertEquals("2021", data.toString());
+  }
+
+  @Test public void writeShort() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeShort(0xabcd);
+    data.writeShort(0x4321);
+    assertEquals("abcd4321", data.toString());
+  }
+
+  @Test public void writeInt() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeInt(0xabcdef01);
+    data.writeInt(0x87654321);
+    assertEquals("abcdef0187654321", data.toString());
+  }
+
+  @Test public void writeLastIntegerInSegment() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 4));
+    data.writeInt(0xabcdef01);
+    data.writeInt(0x87654321);
+    assertEquals(asList(Segment.SIZE, 4), data.segmentSizes());
+    assertEquals(repeat('a', Segment.SIZE - 4), data.readUtf8(Segment.SIZE - 4));
+    assertEquals("abcdef0187654321", data.toString());
+  }
+
+  @Test public void writeIntegerDoesntQuiteFitInSegment() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 3));
+    data.writeInt(0xabcdef01);
+    data.writeInt(0x87654321);
+    assertEquals(asList(Segment.SIZE - 3, 8), data.segmentSizes());
+    assertEquals(repeat('a', Segment.SIZE - 3), data.readUtf8(Segment.SIZE - 3));
+    assertEquals("abcdef0187654321", data.toString());
+  }
+
+  @Test public void readByte() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.write(new ByteString(new byte[] { (byte) 0xab, (byte) 0xcd }));
+    assertEquals((byte) 0xab, data.readByte());
+    assertEquals((byte) 0xcd, data.readByte());
+    assertEquals(0, data.byteCount());
+  }
+
+  @Test public void readShort() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.write(new ByteString(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01
+    }));
+    assertEquals((short) 0xabcd, data.readShort());
+    assertEquals((short) 0xef01, data.readShort());
+    assertEquals(0, data.byteCount());
+  }
+
+  @Test public void readShortSplitAcrossMultipleSegments() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 1));
+    data.write(new ByteString(new byte[] { (byte) 0xab, (byte) 0xcd }));
+    data.readUtf8(Segment.SIZE - 1);
+    assertEquals((short) 0xabcd, data.readShort());
+    assertEquals(0, data.byteCount());
+  }
+
+  @Test public void readInt() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.write(new ByteString(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01,
+        (byte) 0x87, (byte) 0x65, (byte) 0x43, (byte) 0x21
+    }));
+    assertEquals(0xabcdef01, data.readInt());
+    assertEquals(0x87654321, data.readInt());
+    assertEquals(0, data.byteCount());
+  }
+
+  @Test public void readIntSplitAcrossMultipleSegments() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 3));
+    data.write(new ByteString(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01
+    }));
+    data.readUtf8(Segment.SIZE - 3);
+    assertEquals(0xabcdef01, data.readInt());
+    assertEquals(0, data.byteCount());
+  }
+
+  private String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
new file mode 100644
index 0000000000..6dfc1e9a4c
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+
+import static org.junit.Assert.fail;
+
+class BaseTestHandler implements FrameReader.Handler {
+  @Override public void data(boolean inFinished, int streamId, InputStream in, int length)
+      throws IOException {
+    fail();
+  }
+
+  @Override
+  public void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
+      int priority, List<Header> headerBlock, HeadersMode headersMode) {
+    fail();
+  }
+
+  @Override public void rstStream(int streamId, ErrorCode errorCode) {
+    fail();
+  }
+
+  @Override public void settings(boolean clearPrevious, Settings settings) {
+    fail();
+  }
+
+  @Override public void ackSettings() {
+    fail();
+  }
+
+  @Override public void ping(boolean ack, int payload1, int payload2) {
+    fail();
+  }
+
+  @Override
+  public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+    fail();
+  }
+
+  @Override
+  public void windowUpdate(int streamId, long windowSizeIncrement) {
+    fail();
+  }
+
+  @Override public void priority(int streamId, int priority) {
+    fail();
+  }
+
+  @Override
+  public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
+    fail();
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ByteArrayPoolTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ByteArrayPoolTest.java
new file mode 100644
index 0000000000..30132d5c2d
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ByteArrayPoolTest.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.spdy;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+public class ByteArrayPoolTest {
+  @Test public void testReusesBuffer() {
+    ByteArrayPool pool = new ByteArrayPool(32);
+
+    byte[] buf1 = pool.getBuf(16);
+    byte[] buf2 = pool.getBuf(16);
+
+    pool.returnBuf(buf1);
+    pool.returnBuf(buf2);
+
+    byte[] buf3 = pool.getBuf(16);
+    byte[] buf4 = pool.getBuf(16);
+    assertTrue(buf3 == buf1 || buf3 == buf2);
+    assertTrue(buf4 == buf1 || buf4 == buf2);
+    assertTrue(buf3 != buf4);
+  }
+
+  @Test public void testObeysSizeLimit() {
+    ByteArrayPool pool = new ByteArrayPool(32);
+
+    byte[] buf1 = pool.getBuf(16);
+    byte[] buf2 = pool.getBuf(16);
+    byte[] buf3 = pool.getBuf(16);
+
+    pool.returnBuf(buf1);
+    pool.returnBuf(buf2);
+    pool.returnBuf(buf3);
+
+    byte[] buf4 = pool.getBuf(16);
+    byte[] buf5 = pool.getBuf(16);
+    byte[] buf6 = pool.getBuf(16);
+
+    assertTrue(buf4 == buf2 || buf4 == buf3);
+    assertTrue(buf5 == buf2 || buf5 == buf3);
+    assertTrue(buf4 != buf5);
+    assertTrue(buf6 != buf1 && buf6 != buf2 && buf6 != buf3);
+  }
+
+  @Test public void testReturnsBufferWithRightSize() {
+    ByteArrayPool pool = new ByteArrayPool(32);
+
+    byte[] buf1 = pool.getBuf(16);
+    pool.returnBuf(buf1);
+
+    byte[] buf2 = pool.getBuf(17);
+    assertNotSame(buf2, buf1);
+
+    byte[] buf3 = pool.getBuf(15);
+    assertSame(buf3, buf1);
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java
new file mode 100644
index 0000000000..67b53223de
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.Arrays;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.spdy.HpackDraft05Test.MutableByteArrayInputStream;
+import static com.squareup.okhttp.internal.spdy.Http20Draft09.ContinuationInputStream;
+import static com.squareup.okhttp.internal.spdy.Http20Draft09.FLAG_END_STREAM;
+import static com.squareup.okhttp.internal.spdy.Http20Draft09.TYPE_DATA;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class ContinuationInputStreamTest {
+  private final MutableByteArrayInputStream bytesIn = new MutableByteArrayInputStream();
+  private final ContinuationInputStream continuation =
+      new ContinuationInputStream(new DataInputStream(bytesIn));
+
+  @Test public void readCantOverrunHeaderPayload() throws IOException {
+    bytesIn.set(onlyHeadersPayloadFollowedByData());
+
+    continuation.length = continuation.left = 3;
+    continuation.flags = Http20Draft09.FLAG_END_HEADERS;
+    continuation.streamId = 12345;
+
+    assertEquals(1, continuation.read());
+    assertEquals(2, continuation.read());
+    assertEquals(3, continuation.read());
+
+    try {
+      continuation.read();
+      fail();
+    } catch (EOFException expected) {
+    }
+  }
+
+  @Test public void readCantOverrunHeaderContinuationPayload() throws IOException {
+    bytesIn.set(headersPayloadWithContinuationFollowedByData());
+
+    continuation.length = continuation.left = 2;
+    continuation.flags = Http20Draft09.FLAG_NONE;
+    continuation.streamId = 12345;
+
+    assertEquals(1, continuation.read());
+    assertEquals(2, continuation.read());
+    assertEquals(3, continuation.read());
+    assertEquals(0, continuation.available());
+
+    try {
+      continuation.read();
+      fail();
+    } catch (EOFException expected) {
+    }
+  }
+
+  @Test public void availableWithContinuation() throws IOException {
+    bytesIn.set(headersPayloadWithContinuationFollowedByData());
+
+    continuation.length = continuation.left = 2;
+    continuation.flags = Http20Draft09.FLAG_NONE;
+    continuation.streamId = 12345;
+
+    assertEquals(1, continuation.read());
+    assertEquals(2, continuation.read()); // exhaust frame one
+
+    assertEquals(0, continuation.left);
+    assertEquals(1, continuation.available()); // lazy reads next
+
+    assertEquals(1, continuation.length);
+    assertEquals(1, continuation.left);
+    assertEquals(3, continuation.read());
+
+    assertEquals(0, continuation.available());
+    assertEquals(0, continuation.left);
+
+    try {
+      continuation.read();
+      fail();
+    } catch (EOFException expected) {
+    }
+  }
+
+  @Test public void readArrayCantOverrunHeaderPayload() throws IOException {
+    bytesIn.set(onlyHeadersPayloadFollowedByData());
+
+    continuation.length = continuation.left = 3;
+    continuation.flags = Http20Draft09.FLAG_END_HEADERS;
+    continuation.streamId = 12345;
+
+    byte[] buff = new byte[3];
+    assertEquals(3, continuation.read(buff));
+    assertTrue(Arrays.equals(buff, new byte[] {1, 2, 3}));
+
+    try {
+      continuation.read(buff);
+      fail();
+    } catch (EOFException expected) {
+    }
+  }
+
+  @Test public void readArrayCantOverrunHeaderContinuationPayload() throws IOException {
+    bytesIn.set(headersPayloadWithContinuationFollowedByData());
+
+    continuation.length = continuation.left = 2;
+    continuation.flags = Http20Draft09.FLAG_NONE;
+    continuation.streamId = 12345;
+
+    byte[] buff = new byte[3];
+    assertEquals(3, continuation.read(buff));
+    assertTrue(Arrays.equals(buff, new byte[] {1, 2, 3}));
+
+    try {
+      continuation.read(buff);
+      fail();
+    } catch (EOFException expected) {
+    }
+  }
+
+  static byte[] onlyHeadersPayloadFollowedByData() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+    dataOut.write(new byte[] {1, 2, 3});
+    dataOut.writeShort(0);
+    dataOut.write(TYPE_DATA);
+    dataOut.write(FLAG_END_STREAM);
+    dataOut.writeInt(0xFFFFFFFF);
+    return out.toByteArray();
+  }
+
+  static byte[] headersPayloadWithContinuationFollowedByData() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+    dataOut.write(new byte[] {1, 2});
+    dataOut.writeShort(1);
+    dataOut.write(Http20Draft09.TYPE_CONTINUATION);
+    dataOut.write(Http20Draft09.FLAG_END_HEADERS);
+    dataOut.writeInt(12345);
+    dataOut.write(3);
+    dataOut.writeShort(0);
+    dataOut.write(TYPE_DATA);
+    dataOut.write(FLAG_END_STREAM);
+    dataOut.writeInt(0xFFFFFFFF);
+    return out.toByteArray();
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
new file mode 100644
index 0000000000..5f011835fa
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -0,0 +1,856 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.bytes.ByteString;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.Util.headerEntries;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+public class HpackDraft05Test {
+
+  private final MutableByteArrayInputStream bytesIn = new MutableByteArrayInputStream();
+  private HpackDraft05.Reader hpackReader;
+  private ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
+  private HpackDraft05.Writer hpackWriter;
+
+  @Before public void reset() {
+    hpackReader = newReader(bytesIn);
+    hpackWriter = new HpackDraft05.Writer(new DataOutputStream(bytesOut));
+  }
+
+  /**
+   * HPACK has a max header table size, which can be smaller than the max header message.
+   * Ensure the larger header content is not lost.
+   */
+  @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x00); // Literal indexed
+    out.write(0x0a); // Literal name (len = 10)
+    out.write("custom-key".getBytes(), 0, 10);
+
+    out.write(0x0d); // Literal value (len = 13)
+    out.write("custom-header".getBytes(), 0, 13);
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.maxHeaderTableByteCount(1);
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndReset());
+  }
+
+  /** Oldest entries are evicted to support newer ones. */
+  @Test public void testEviction() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x00); // Literal indexed
+    out.write(0x0a); // Literal name (len = 10)
+    out.write("custom-foo".getBytes(), 0, 10);
+
+    out.write(0x0d); // Literal value (len = 13)
+    out.write("custom-header".getBytes(), 0, 13);
+
+    out.write(0x00); // Literal indexed
+    out.write(0x0a); // Literal name (len = 10)
+    out.write("custom-bar".getBytes(), 0, 10);
+
+    out.write(0x0d); // Literal value (len = 13)
+    out.write("custom-header".getBytes(), 0, 13);
+
+    out.write(0x00); // Literal indexed
+    out.write(0x0a); // Literal name (len = 10)
+    out.write("custom-baz".getBytes(), 0, 10);
+
+    out.write(0x0d); // Literal value (len = 13)
+    out.write("custom-header".getBytes(), 0, 13);
+
+    bytesIn.set(out.toByteArray());
+    // Set to only support 110 bytes (enough for 2 headers).
+    hpackReader.maxHeaderTableByteCount(110);
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(2, hpackReader.headerCount);
+
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, "custom-bar", "custom-header", 55);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, "custom-baz", "custom-header", 55);
+    assertHeaderReferenced(headerTableLength() - 2);
+
+    // foo isn't here as it is no longer in the table.
+    // TODO: emit before eviction?
+    assertEquals(headerEntries("custom-bar", "custom-header", "custom-baz", "custom-header"),
+        hpackReader.getAndReset());
+
+    // Simulate receiving a small settings frame, that implies eviction.
+    hpackReader.maxHeaderTableByteCount(55);
+    assertEquals(1, hpackReader.headerCount);
+  }
+
+  /** Header table backing array is initially 8 long, let's ensure it grows. */
+  @Test public void dynamicallyGrowsBeyond64Entries() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    for (int i = 0; i < 256; i++) {
+      out.write(0x00); // Literal indexed
+      out.write(0x0a); // Literal name (len = 10)
+      out.write("custom-foo".getBytes(), 0, 10);
+
+      out.write(0x0d); // Literal value (len = 13)
+      out.write("custom-header".getBytes(), 0, 13);
+    }
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.maxHeaderTableByteCount(16384); // Lots of headers need more room!
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(256, hpackReader.headerCount);
+    assertHeaderReferenced(headerTableLength() - 1);
+    assertHeaderReferenced(headerTableLength() - hpackReader.headerCount);
+  }
+
+  @Test public void huffmanDecodingSupported() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x04); // == Literal indexed ==
+                     // Indexed name (idx = 4) -> :path
+    out.write(0x8b); // Literal value Huffman encoded 11 bytes
+                     // decodes to www.example.com which is length 15
+    byte[] huffmanBytes = new byte[] {
+        (byte) 0xdb, (byte) 0x6d, (byte) 0x88, (byte) 0x3e,
+        (byte) 0x68, (byte) 0xd1, (byte) 0xcb, (byte) 0x12,
+        (byte) 0x25, (byte) 0xba, (byte) 0x7f};
+    out.write(huffmanBytes, 0, huffmanBytes.length);
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(52, hpackReader.headerTableByteCount);
+
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":path", "www.example.com", 52);
+    assertHeaderReferenced(headerTableLength() - 1);
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.1
+   */
+  @Test public void readLiteralHeaderFieldWithIndexing() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x00); // Literal indexed
+    out.write(0x0a); // Literal name (len = 10)
+    out.write("custom-key".getBytes(), 0, 10);
+
+    out.write(0x0d); // Literal value (len = 13)
+    out.write("custom-header".getBytes(), 0, 13);
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(55, hpackReader.headerTableByteCount);
+
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, "custom-key", "custom-header", 55);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndReset());
+  }
+
+  /**
+   * Literal Header Field without Indexing - New Name
+   */
+  @Test public void literalHeaderFieldWithoutIndexingNewName() throws IOException {
+    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
+
+    ByteArrayOutputStream expectedBytes = new ByteArrayOutputStream();
+
+    expectedBytes.write(0x40); // Not indexed
+    expectedBytes.write(0x0a); // Literal name (len = 10)
+    expectedBytes.write("custom-key".getBytes(), 0, 10);
+
+    expectedBytes.write(0x0d); // Literal value (len = 13)
+    expectedBytes.write("custom-header".getBytes(), 0, 13);
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertArrayEquals(expectedBytes.toByteArray(), bytesOut.toByteArray());
+
+    bytesIn.set(bytesOut.toByteArray());
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndReset());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.2
+   */
+  @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {
+    List<Header> headerBlock = headerEntries(":path", "/sample/path");
+
+    ByteArrayOutputStream expectedBytes = new ByteArrayOutputStream();
+    expectedBytes.write(0x44); // == Literal not indexed ==
+                               // Indexed name (idx = 4) -> :path
+    expectedBytes.write(0x0c); // Literal value (len = 12)
+    expectedBytes.write("/sample/path".getBytes(), 0, 12);
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertArrayEquals(expectedBytes.toByteArray(), bytesOut.toByteArray());
+
+    bytesIn.set(bytesOut.toByteArray());
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndReset());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.3
+   */
+  @Test public void readIndexedHeaderField() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x82); // == Indexed - Add ==
+                     // idx = 2 -> :method: GET
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(42, hpackReader.headerTableByteCount);
+
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-3.2.1
+   */
+  @Test public void toggleIndex() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    // Static table entries are copied to the top of the reference set.
+    out.write(0x82); // == Indexed - Add ==
+                     // idx = 2 -> :method: GET
+    // Specifying an index to an entry in the reference set removes it.
+    out.write(0x81); // == Indexed - Remove ==
+                     // idx = 1 -> :method: GET
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(42, hpackReader.headerTableByteCount);
+
+    Header entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderNotReferenced(headerTableLength() - 1);
+
+    assertTrue(hpackReader.getAndReset().isEmpty());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.4
+   */
+  @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x82); // == Indexed - Add ==
+                     // idx = 2 -> :method: GET
+
+    bytesIn.set(out.toByteArray());
+    hpackReader.maxHeaderTableByteCount(0); // SETTINGS_HEADER_TABLE_SIZE == 0
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    // Not buffered in header table.
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.2
+   */
+  @Test public void readRequestExamplesWithoutHuffman() throws IOException {
+    ByteArrayOutputStream out = firstRequestWithoutHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    checkReadFirstRequestWithoutHuffman();
+
+    out = secondRequestWithoutHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    checkReadSecondRequestWithoutHuffman();
+
+    out = thirdRequestWithoutHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    checkReadThirdRequestWithoutHuffman();
+  }
+
+  private ByteArrayOutputStream firstRequestWithoutHuffman() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x82); // == Indexed - Add ==
+                     // idx = 2 -> :method: GET
+    out.write(0x87); // == Indexed - Add ==
+                     // idx = 7 -> :scheme: http
+    out.write(0x86); // == Indexed - Add ==
+                     // idx = 6 -> :path: /
+    out.write(0x04); // == Literal indexed ==
+                     // Indexed name (idx = 4) -> :authority
+    out.write(0x0f); // Literal value (len = 15)
+    out.write("www.example.com".getBytes(), 0, 15);
+
+    return out;
+  }
+
+  private void checkReadFirstRequestWithoutHuffman() {
+    assertEquals(4, hpackReader.headerCount);
+
+    // [  1] (s =  57) :authority: www.example.com
+    Header entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
+
+    // [  2] (s =  38) :path: /
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderReferenced(headerTableLength() - 3);
+
+    // [  3] (s =  43) :scheme: http
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderReferenced(headerTableLength() - 2);
+
+    // [  4] (s =  42) :method: GET
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    // Table size: 180
+    assertEquals(180, hpackReader.headerTableByteCount);
+
+    // Decoded header set:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com"), hpackReader.getAndReset());
+  }
+
+  private ByteArrayOutputStream secondRequestWithoutHuffman() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x1b); // == Literal indexed ==
+                     // Indexed name (idx = 27) -> cache-control
+    out.write(0x08); // Literal value (len = 8)
+    out.write("no-cache".getBytes(), 0, 8);
+
+    return out;
+  }
+
+  private void checkReadSecondRequestWithoutHuffman() {
+    assertEquals(5, hpackReader.headerCount);
+
+    // [  1] (s =  53) cache-control: no-cache
+    Header entry = hpackReader.headerTable[headerTableLength() - 5];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+    assertHeaderReferenced(headerTableLength() - 5);
+
+    // [  2] (s =  57) :authority: www.example.com
+    entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
+
+    // [  3] (s =  38) :path: /
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderReferenced(headerTableLength() - 3);
+
+    // [  4] (s =  43) :scheme: http
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderReferenced(headerTableLength() - 2);
+
+    // [  5] (s =  42) :method: GET
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    // Table size: 233
+    assertEquals(233, hpackReader.headerTableByteCount);
+
+    // Decoded header set:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com",
+        "cache-control", "no-cache"), hpackReader.getAndReset());
+  }
+
+  private ByteArrayOutputStream thirdRequestWithoutHuffman() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x80); // == Empty reference set ==
+    out.write(0x85); // == Indexed - Add ==
+                     // idx = 5 -> :method: GET
+    out.write(0x8c); // == Indexed - Add ==
+                     // idx = 12 -> :scheme: https
+    out.write(0x8b); // == Indexed - Add ==
+                     // idx = 11 -> :path: /index.html
+    out.write(0x84); // == Indexed - Add ==
+                     // idx = 4 -> :authority: www.example.com
+    out.write(0x00); // Literal indexed
+    out.write(0x0a); // Literal name (len = 10)
+    out.write("custom-key".getBytes(), 0, 10);
+    out.write(0x0c); // Literal value (len = 12)
+    out.write("custom-value".getBytes(), 0, 12);
+
+    return out;
+  }
+
+  private void checkReadThirdRequestWithoutHuffman() {
+    assertEquals(8, hpackReader.headerCount);
+
+    // [  1] (s =  54) custom-key: custom-value
+    Header entry = hpackReader.headerTable[headerTableLength() - 8];
+    checkEntry(entry, "custom-key", "custom-value", 54);
+    assertHeaderReferenced(headerTableLength() - 8);
+
+    // [  2] (s =  48) :path: /index.html
+    entry = hpackReader.headerTable[headerTableLength() - 7];
+    checkEntry(entry, ":path", "/index.html", 48);
+    assertHeaderReferenced(headerTableLength() - 7);
+
+    // [  3] (s =  44) :scheme: https
+    entry = hpackReader.headerTable[headerTableLength() - 6];
+    checkEntry(entry, ":scheme", "https", 44);
+    assertHeaderReferenced(headerTableLength() - 6);
+
+    // [  4] (s =  53) cache-control: no-cache
+    entry = hpackReader.headerTable[headerTableLength() - 5];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+    assertHeaderNotReferenced(headerTableLength() - 5);
+
+    // [  5] (s =  57) :authority: www.example.com
+    entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
+
+    // [  6] (s =  38) :path: /
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderNotReferenced(headerTableLength() - 3);
+
+    // [  7] (s =  43) :scheme: http
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderNotReferenced(headerTableLength() - 2);
+
+    // [  8] (s =  42) :method: GET
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    // Table size: 379
+    assertEquals(379, hpackReader.headerTableByteCount);
+
+    // Decoded header set:
+    // TODO: order is not correct per docs, but then again, the spec doesn't require ordering.
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":authority", "www.example.com",
+        ":scheme", "https",
+        ":path", "/index.html",
+        "custom-key", "custom-value"), hpackReader.getAndReset());
+  }
+
+  /**
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.3
+   */
+  @Test public void readRequestExamplesWithHuffman() throws IOException {
+    ByteArrayOutputStream out = firstRequestWithHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    checkReadFirstRequestWithHuffman();
+
+    out = secondRequestWithHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    checkReadSecondRequestWithHuffman();
+
+    out = thirdRequestWithHuffman();
+    bytesIn.set(out.toByteArray());
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    checkReadThirdRequestWithHuffman();
+  }
+
+  private ByteArrayOutputStream firstRequestWithHuffman() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x82); // == Indexed - Add ==
+                     // idx = 2 -> :method: GET
+    out.write(0x87); // == Indexed - Add ==
+                     // idx = 7 -> :scheme: http
+    out.write(0x86); // == Indexed - Add ==
+                     // idx = 6 -> :path: /
+    out.write(0x04); // == Literal indexed ==
+                     // Indexed name (idx = 4) -> :authority
+    out.write(0x8b); // Literal value Huffman encoded 11 bytes
+                     // decodes to www.example.com which is length 15
+    byte[] huffmanBytes = new byte[] {
+        (byte) 0xdb, (byte) 0x6d, (byte) 0x88, (byte) 0x3e,
+        (byte) 0x68, (byte) 0xd1, (byte) 0xcb, (byte) 0x12,
+        (byte) 0x25, (byte) 0xba, (byte) 0x7f};
+    out.write(huffmanBytes, 0, huffmanBytes.length);
+
+    return out;
+  }
+
+  private void checkReadFirstRequestWithHuffman() {
+    assertEquals(4, hpackReader.headerCount);
+
+    // [  1] (s =  57) :authority: www.example.com
+    Header entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
+
+    // [  2] (s =  38) :path: /
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderReferenced(headerTableLength() - 3);
+
+    // [  3] (s =  43) :scheme: http
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderReferenced(headerTableLength() - 2);
+
+    // [  4] (s =  42) :method: GET
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    // Table size: 180
+    assertEquals(180, hpackReader.headerTableByteCount);
+
+    // Decoded header set:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com"), hpackReader.getAndReset());
+  }
+
+  private ByteArrayOutputStream secondRequestWithHuffman() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x1b); // == Literal indexed ==
+                     // Indexed name (idx = 27) -> cache-control
+    out.write(0x86); // Literal value Huffman encoded 6 bytes
+                     // decodes to no-cache which is length 8
+    byte[] huffmanBytes = new byte[] {
+        (byte) 0x63, (byte) 0x65, (byte) 0x4a, (byte) 0x13,
+        (byte) 0x98, (byte) 0xff};
+    out.write(huffmanBytes, 0, huffmanBytes.length);
+
+    return out;
+  }
+
+  private void checkReadSecondRequestWithHuffman() {
+    assertEquals(5, hpackReader.headerCount);
+
+    // [  1] (s =  53) cache-control: no-cache
+    Header entry = hpackReader.headerTable[headerTableLength() - 5];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+    assertHeaderReferenced(headerTableLength() - 5);
+
+    // [  2] (s =  57) :authority: www.example.com
+    entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
+
+    // [  3] (s =  38) :path: /
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderReferenced(headerTableLength() - 3);
+
+    // [  4] (s =  43) :scheme: http
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderReferenced(headerTableLength() - 2);
+
+    // [  5] (s =  42) :method: GET
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    // Table size: 233
+    assertEquals(233, hpackReader.headerTableByteCount);
+
+    // Decoded header set:
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":scheme", "http",
+        ":path", "/",
+        ":authority", "www.example.com",
+        "cache-control", "no-cache"), hpackReader.getAndReset());
+  }
+
+  private ByteArrayOutputStream thirdRequestWithHuffman() {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+
+    out.write(0x80); // == Empty reference set ==
+    out.write(0x85); // == Indexed - Add ==
+                     // idx = 5 -> :method: GET
+    out.write(0x8c); // == Indexed - Add ==
+                     // idx = 12 -> :scheme: https
+    out.write(0x8b); // == Indexed - Add ==
+                     // idx = 11 -> :path: /index.html
+    out.write(0x84); // == Indexed - Add ==
+                     // idx = 4 -> :authority: www.example.com
+    out.write(0x00); // Literal indexed
+    out.write(0x88); // Literal name Huffman encoded 8 bytes
+                     // decodes to custom-key which is length 10
+    byte[] huffmanBytes = new byte[] {
+        (byte) 0x4e, (byte) 0xb0, (byte) 0x8b, (byte) 0x74,
+        (byte) 0x97, (byte) 0x90, (byte) 0xfa, (byte) 0x7f};
+    out.write(huffmanBytes, 0, huffmanBytes.length);
+    out.write(0x89); // Literal value Huffman encoded 6 bytes
+                     // decodes to custom-value which is length 12
+    huffmanBytes = new byte[] {
+        (byte) 0x4e, (byte) 0xb0, (byte) 0x8b, (byte) 0x74,
+        (byte) 0x97, (byte) 0x9a, (byte) 0x17, (byte) 0xa8,
+        (byte) 0xff};
+    out.write(huffmanBytes, 0, huffmanBytes.length);
+
+    return out;
+  }
+
+  private void checkReadThirdRequestWithHuffman() {
+    assertEquals(8, hpackReader.headerCount);
+
+    // [  1] (s =  54) custom-key: custom-value
+    Header entry = hpackReader.headerTable[headerTableLength() - 8];
+    checkEntry(entry, "custom-key", "custom-value", 54);
+    assertHeaderReferenced(headerTableLength() - 8);
+
+    // [  2] (s =  48) :path: /index.html
+    entry = hpackReader.headerTable[headerTableLength() - 7];
+    checkEntry(entry, ":path", "/index.html", 48);
+    assertHeaderReferenced(headerTableLength() - 7);
+
+    // [  3] (s =  44) :scheme: https
+    entry = hpackReader.headerTable[headerTableLength() - 6];
+    checkEntry(entry, ":scheme", "https", 44);
+    assertHeaderReferenced(headerTableLength() - 6);
+
+    // [  4] (s =  53) cache-control: no-cache
+    entry = hpackReader.headerTable[headerTableLength() - 5];
+    checkEntry(entry, "cache-control", "no-cache", 53);
+    assertHeaderNotReferenced(headerTableLength() - 5);
+
+    // [  5] (s =  57) :authority: www.example.com
+    entry = hpackReader.headerTable[headerTableLength() - 4];
+    checkEntry(entry, ":authority", "www.example.com", 57);
+    assertHeaderReferenced(headerTableLength() - 4);
+
+    // [  6] (s =  38) :path: /
+    entry = hpackReader.headerTable[headerTableLength() - 3];
+    checkEntry(entry, ":path", "/", 38);
+    assertHeaderNotReferenced(headerTableLength() - 3);
+
+    // [  7] (s =  43) :scheme: http
+    entry = hpackReader.headerTable[headerTableLength() - 2];
+    checkEntry(entry, ":scheme", "http", 43);
+    assertHeaderNotReferenced(headerTableLength() - 2);
+
+    // [  8] (s =  42) :method: GET
+    entry = hpackReader.headerTable[headerTableLength() - 1];
+    checkEntry(entry, ":method", "GET", 42);
+    assertHeaderReferenced(headerTableLength() - 1);
+
+    // Table size: 379
+    assertEquals(379, hpackReader.headerTableByteCount);
+
+    // Decoded header set:
+    // TODO: order is not correct per docs, but then again, the spec doesn't require ordering.
+    assertEquals(headerEntries(
+        ":method", "GET",
+        ":authority", "www.example.com",
+        ":scheme", "https",
+        ":path", "/index.html",
+        "custom-key", "custom-value"), hpackReader.getAndReset());
+  }
+
+  @Test public void readSingleByteInt() throws IOException {
+    assertEquals(10, newReader(byteStream()).readInt(10, 31));
+    assertEquals(10, newReader(byteStream()).readInt(0xe0 | 10, 31));
+  }
+
+  @Test public void readMultibyteInt() throws IOException {
+    assertEquals(1337, newReader(byteStream(154, 10)).readInt(31, 31));
+  }
+
+  @Test public void writeSingleByteInt() throws IOException {
+    hpackWriter.writeInt(10, 31, 0);
+    assertBytes(10);
+    hpackWriter.writeInt(10, 31, 0xe0);
+    assertBytes(0xe0 | 10);
+  }
+
+  @Test public void writeMultibyteInt() throws IOException {
+    hpackWriter.writeInt(1337, 31, 0);
+    assertBytes(31, 154, 10);
+    hpackWriter.writeInt(1337, 31, 0xe0);
+    assertBytes(0xe0 | 31, 154, 10);
+  }
+
+  @Test public void max31BitValue() throws IOException {
+    hpackWriter.writeInt(0x7fffffff, 31, 0);
+    assertBytes(31, 224, 255, 255, 255, 7);
+    assertEquals(0x7fffffff,
+        newReader(byteStream(224, 255, 255, 255, 7)).readInt(31, 31));
+  }
+
+  @Test public void prefixMask() throws IOException {
+    hpackWriter.writeInt(31, 31, 0);
+    assertBytes(31, 0);
+    assertEquals(31, newReader(byteStream(0)).readInt(31, 31));
+  }
+
+  @Test public void prefixMaskMinusOne() throws IOException {
+    hpackWriter.writeInt(30, 31, 0);
+    assertBytes(30);
+    assertEquals(31, newReader(byteStream(0)).readInt(31, 31));
+  }
+
+  @Test public void zero() throws IOException {
+    hpackWriter.writeInt(0, 31, 0);
+    assertBytes(0);
+    assertEquals(0, newReader(byteStream()).readInt(0, 31));
+  }
+
+  @Test public void headerName() throws IOException {
+    hpackWriter.writeByteString(ByteString.encodeUtf8("foo"));
+    assertBytes(3, 'f', 'o', 'o');
+    assertEquals("foo", newReader(byteStream(3, 'F', 'o', 'o')).readByteString(true).utf8());
+  }
+
+  @Test public void emptyHeaderName() throws IOException {
+    hpackWriter.writeByteString(ByteString.encodeUtf8(""));
+    assertBytes(0);
+    assertSame(ByteString.EMPTY, newReader(byteStream(0)).readByteString(true));
+    assertSame(ByteString.EMPTY, newReader(byteStream(0)).readByteString(false));
+  }
+
+  private HpackDraft05.Reader newReader(InputStream input) {
+    return new HpackDraft05.Reader(false, 4096, input);
+  }
+
+  private InputStream byteStream(int... bytes) {
+    byte[] data = intArrayToByteArray(bytes);
+    return new ByteArrayInputStream(data);
+  }
+
+  private void checkEntry(Header entry, String name, String value, int size) {
+    assertEquals(name, entry.name.utf8());
+    assertEquals(value, entry.value.utf8());
+    assertEquals(size, entry.hpackSize);
+  }
+
+  private void assertBytes(int... bytes) {
+    byte[] expected = intArrayToByteArray(bytes);
+    byte[] actual = bytesOut.toByteArray();
+    assertEquals(Arrays.toString(expected), Arrays.toString(actual));
+    bytesOut.reset(); // So the next test starts with a clean slate.
+  }
+
+  private byte[] intArrayToByteArray(int[] bytes) {
+    byte[] data = new byte[bytes.length];
+    for (int i = 0; i < bytes.length; i++) {
+      data[i] = (byte) bytes[i];
+    }
+    return data;
+  }
+
+  private void assertHeaderReferenced(int index) {
+    assertTrue(hpackReader.referencedHeaders.get(index));
+  }
+
+  private void assertHeaderNotReferenced(int index) {
+    assertFalse(hpackReader.referencedHeaders.get(index));
+  }
+
+  private int headerTableLength() {
+    return hpackReader.headerTable.length;
+  }
+
+  static class MutableByteArrayInputStream extends ByteArrayInputStream {
+
+    MutableByteArrayInputStream() {
+      super(new byte[] { });
+    }
+
+    void set(byte[] replacement) {
+      this.buf = replacement;
+      this.pos = 0;
+      this.count = replacement.length;
+    }
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackTest.java
deleted file mode 100644
index 0bcadce36e..0000000000
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackTest.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.spdy;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-public class HpackTest {
-  private ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-  private final Hpack.Writer hpackWriter = new Hpack.Writer(new DataOutputStream(bytesOut));
-
-  @Test public void readSingleByteInt() throws IOException {
-    assertEquals(10, new Hpack.Reader(byteStream(), true).readInt(10, 31));
-    assertEquals(10, new Hpack.Reader(byteStream(), true).readInt(0xe0 | 10, 31));
-  }
-
-  @Test public void readMultibyteInt() throws IOException {
-    assertEquals(1337, new Hpack.Reader(byteStream(154, 10), true).readInt(31, 31));
-  }
-
-  @Test public void writeSingleByteInt() throws IOException {
-    hpackWriter.writeInt(10, 31, 0);
-    assertBytes(10);
-    hpackWriter.writeInt(10, 31, 0xe0);
-    assertBytes(0xe0 | 10);
-  }
-
-  @Test public void writeMultibyteInt() throws IOException {
-    hpackWriter.writeInt(1337, 31, 0);
-    assertBytes(31, 154, 10);
-    hpackWriter.writeInt(1337, 31, 0xe0);
-    assertBytes(0xe0 | 31, 154, 10);
-  }
-
-  @Test public void max31BitValue() throws IOException {
-    hpackWriter.writeInt(0x7fffffff, 31, 0);
-    assertBytes(31, 224, 255, 255, 255, 7);
-    assertEquals(0x7fffffff,
-        new Hpack.Reader(byteStream(224, 255, 255, 255, 7), true).readInt(31, 31));
-  }
-
-  @Test public void prefixMask() throws IOException {
-    hpackWriter.writeInt(31, 31, 0);
-    assertBytes(31, 0);
-    assertEquals(31, new Hpack.Reader(byteStream(0), true).readInt(31, 31));
-  }
-
-  @Test public void prefixMaskMinusOne() throws IOException {
-    hpackWriter.writeInt(30, 31, 0);
-    assertBytes(30);
-    assertEquals(31, new Hpack.Reader(byteStream(0), true).readInt(31, 31));
-  }
-
-  @Test public void zero() throws IOException {
-    hpackWriter.writeInt(0, 31, 0);
-    assertBytes(0);
-    assertEquals(0, new Hpack.Reader(byteStream(), true).readInt(0, 31));
-  }
-
-  @Test public void headerName() throws IOException {
-    hpackWriter.writeString("foo");
-    assertBytes(3, 'f', 'o', 'o');
-    assertEquals("foo", new Hpack.Reader(byteStream(3, 'f', 'o', 'o'), true).readString());
-  }
-
-  @Test public void emptyHeaderName() throws IOException {
-    hpackWriter.writeString("");
-    assertBytes(0);
-    assertEquals("", new Hpack.Reader(byteStream(0), true).readString());
-  }
-
-  @Test public void headersRoundTrip() throws IOException {
-    List<String> sentHeaders = Arrays.asList("name", "value");
-    hpackWriter.writeHeaders(sentHeaders);
-    ByteArrayInputStream bytesIn = new ByteArrayInputStream(bytesOut.toByteArray());
-    Hpack.Reader reader = new Hpack.Reader(new DataInputStream(bytesIn), true);
-    reader.readHeaders(bytesOut.size());
-    reader.emitReferenceSet();
-    List<String> receivedHeaders = reader.getAndReset();
-    assertEquals(sentHeaders, receivedHeaders);
-  }
-
-  private DataInputStream byteStream(int... bytes) {
-    byte[] data = intArrayToByteArray(bytes);
-    return new DataInputStream(new ByteArrayInputStream(data));
-  }
-
-  private void assertBytes(int... bytes) {
-    byte[] expected = intArrayToByteArray(bytes);
-    byte[] actual = bytesOut.toByteArray();
-    assertEquals(Arrays.toString(expected), Arrays.toString(actual));
-    bytesOut.reset(); // So the next test starts with a clean slate.
-  }
-
-  private byte[] intArrayToByteArray(int[] bytes) {
-    byte[] data = new byte[bytes.length];
-    for (int i = 0; i < bytes.length; i++) {
-      data[i] = (byte) bytes[i];
-    }
-    return data;
-  }
-}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
new file mode 100644
index 0000000000..8023734130
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -0,0 +1,539 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.Util.headerEntries;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class Http20Draft09Test {
+  static final int expectedStreamId = 15;
+
+  @Test public void unknownFrameTypeIgnored() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    dataOut.writeShort(4); // has a 4-byte field
+    dataOut.write(99); // type 99
+    dataOut.write(0); // no flags
+    dataOut.writeInt(expectedStreamId);
+    dataOut.writeInt(111111111); // custom data
+
+    FrameReader fr = newReader(out);
+
+    // Consume the unknown frame.
+    fr.nextFrame(new BaseTestHandler());
+  }
+
+  @Test public void onlyOneLiteralHeadersFrame() throws IOException {
+    final List<Header> sentHeaders = headerEntries("name", "value");
+
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    // Write the headers frame, specifying no more frames are expected.
+    {
+      byte[] headerBytes = literalHeaders(sentHeaders);
+      dataOut.writeShort(headerBytes.length);
+      dataOut.write(Http20Draft09.TYPE_HEADERS);
+      dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_END_STREAM);
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
+      dataOut.write(headerBytes);
+    }
+
+    FrameReader fr = newReader(out);
+
+    // Consume the headers frame.
+    fr.nextFrame(new BaseTestHandler() {
+
+      @Override
+      public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, int priority, List<Header> headerBlock,
+          HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertTrue(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(-1, priority);
+        assertEquals(sentHeaders, headerBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  @Test public void headersWithPriority() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final List<Header> sentHeaders = headerEntries("name", "value");
+
+    { // Write the headers frame, specifying priority flag and value.
+      byte[] headerBytes = literalHeaders(sentHeaders);
+      dataOut.writeShort(headerBytes.length + 4);
+      dataOut.write(Http20Draft09.TYPE_HEADERS);
+      dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_PRIORITY);
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
+      dataOut.writeInt(0); // Highest priority is 0.
+      dataOut.write(headerBytes);
+    }
+
+    FrameReader fr = newReader(out);
+
+    // Consume the headers frame.
+    fr.nextFrame(new BaseTestHandler() {
+
+      @Override
+      public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, int priority, List<Header> nameValueBlock,
+          HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(0, priority);
+        assertEquals(sentHeaders, nameValueBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void headersFrameThenContinuation() throws IOException {
+
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    // Decoding the first header will cross frame boundaries.
+    byte[] headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+    { // Write the first headers frame.
+      dataOut.writeShort(headerBlock.length / 2);
+      dataOut.write(Http20Draft09.TYPE_HEADERS);
+      dataOut.write(0); // no flags
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
+      dataOut.write(headerBlock, 0, headerBlock.length / 2);
+    }
+
+    { // Write the continuation frame, specifying no more frames are expected.
+      dataOut.writeShort(headerBlock.length / 2);
+      dataOut.write(Http20Draft09.TYPE_CONTINUATION);
+      dataOut.write(Http20Draft09.FLAG_END_HEADERS);
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
+      dataOut.write(headerBlock, headerBlock.length / 2, headerBlock.length / 2);
+    }
+
+    FrameReader fr = newReader(out);
+
+    // Reading the above frames should result in a concatenated headerBlock.
+    fr.nextFrame(new BaseTestHandler() {
+
+      @Override
+      public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, int priority, List<Header> headerBlock,
+          HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(-1, priority);
+        assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  @Test public void pushPromise() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final int expectedPromisedStreamId = 11;
+
+    final List<Header> pushPromise = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/")
+    );
+
+    { // Write the push promise frame, specifying the associated stream ID.
+      byte[] headerBytes = literalHeaders(pushPromise);
+      dataOut.writeShort(headerBytes.length + 4);
+      dataOut.write(Http20Draft09.TYPE_PUSH_PROMISE);
+      dataOut.write(Http20Draft09.FLAG_END_PUSH_PROMISE);
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
+      dataOut.writeInt(expectedPromisedStreamId & 0x7fffffff);
+      dataOut.write(headerBytes);
+    }
+
+    FrameReader fr = newReader(out);
+
+    // Consume the headers frame.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedPromisedStreamId, promisedStreamId);
+        assertEquals(pushPromise, headerBlock);
+      }
+    });
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void pushPromiseThenContinuation() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final int expectedPromisedStreamId = 11;
+
+    final List<Header> pushPromise = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/")
+    );
+
+    // Decoding the first header will cross frame boundaries.
+    byte[] headerBlock = literalHeaders(pushPromise);
+    int firstFrameLength = headerBlock.length - 1;
+    { // Write the first headers frame.
+      dataOut.writeShort(firstFrameLength + 4);
+      dataOut.write(Http20Draft09.TYPE_PUSH_PROMISE);
+      dataOut.write(0); // no flags
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
+      dataOut.writeInt(expectedPromisedStreamId & 0x7fffffff);
+      dataOut.write(headerBlock, 0, firstFrameLength);
+    }
+
+    { // Write the continuation frame, specifying no more frames are expected.
+      dataOut.writeShort(1);
+      dataOut.write(Http20Draft09.TYPE_CONTINUATION);
+      dataOut.write(Http20Draft09.FLAG_END_HEADERS);
+      dataOut.writeInt(expectedStreamId & 0x7fffffff);
+      dataOut.write(headerBlock, firstFrameLength, 1);
+    }
+
+    FrameReader fr = newReader(out);
+
+    // Reading the above frames should result in a concatenated headerBlock.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedPromisedStreamId, promisedStreamId);
+        assertEquals(pushPromise, headerBlock);
+      }
+    });
+  }
+
+  @Test public void readRstStreamFrame() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    dataOut.writeShort(4);
+    dataOut.write(Http20Draft09.TYPE_RST_STREAM);
+    dataOut.write(0); // No flags
+    dataOut.writeInt(expectedStreamId & 0x7fffffff);
+    dataOut.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
+
+    FrameReader fr = newReader(out);
+
+    // Consume the reset frame.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void rstStream(int streamId, ErrorCode errorCode) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(ErrorCode.COMPRESSION_ERROR, errorCode);
+      }
+    });
+  }
+
+  @Test public void readSettingsFrame() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final int reducedTableSizeBytes = 16;
+
+    dataOut.writeShort(16); // 2 settings * 4 bytes for the code and 4 for the value.
+    dataOut.write(Http20Draft09.TYPE_SETTINGS);
+    dataOut.write(0); // No flags
+    dataOut.writeInt(0 & 0x7fffffff); // Settings are always on the connection stream 0.
+    dataOut.writeInt(Settings.HEADER_TABLE_SIZE & 0xffffff);
+    dataOut.writeInt(reducedTableSizeBytes);
+    dataOut.writeInt(Settings.ENABLE_PUSH & 0xffffff);
+    dataOut.writeInt(0);
+
+    final Http20Draft09.Reader fr = newReader(out);
+
+    // Consume the settings frame.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void settings(boolean clearPrevious, Settings settings) {
+        assertFalse(clearPrevious); // No clearPrevious in http/2.
+        assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
+        assertEquals(false, settings.getEnablePush(true));
+      }
+    });
+  }
+
+  @Test public void pingRoundTrip() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final int expectedPayload1 = 7;
+    final int expectedPayload2 = 8;
+
+    // Compose the expected PING frame.
+    dataOut.writeShort(8); // length
+    dataOut.write(Http20Draft09.TYPE_PING);
+    dataOut.write(Http20Draft09.FLAG_ACK);
+    dataOut.writeInt(0); // connection-level
+    dataOut.writeInt(expectedPayload1);
+    dataOut.writeInt(expectedPayload2);
+
+    // Check writer sends the same bytes.
+    assertArrayEquals(out.toByteArray(), sendPingFrame(true, expectedPayload1, expectedPayload2));
+
+    FrameReader fr = newReader(out);
+
+    fr.nextFrame(new BaseTestHandler() { // Consume the ping frame.
+      @Override public void ping(boolean ack, int payload1, int payload2) {
+        assertTrue(ack);
+        assertEquals(expectedPayload1, payload1);
+        assertEquals(expectedPayload2, payload2);
+      }
+    });
+  }
+
+  @Test public void maxLengthDataFrame() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final byte[] expectedData = new byte[16383];
+    Arrays.fill(expectedData, (byte) 2);
+
+    // Write the data frame.
+    dataOut.writeShort(expectedData.length);
+    dataOut.write(Http20Draft09.TYPE_DATA);
+    dataOut.write(0); // no flags
+    dataOut.writeInt(expectedStreamId & 0x7fffffff);
+    dataOut.write(expectedData);
+
+    // Check writer sends the same bytes.
+    assertArrayEquals(out.toByteArray(), sendDataFrame(expectedData));
+
+    FrameReader fr = newReader(out);
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void data(boolean inFinished, int streamId, InputStream in, int length)
+          throws IOException {
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(16383, length);
+        byte[] data = new byte[length];
+        Util.readFully(in, data);
+        for (byte b : data){
+          assertEquals(2, b);
+        }
+      }
+    });
+  }
+
+  @Test public void tooLargeDataFrame() throws IOException {
+    try {
+      sendDataFrame(new byte[0x1000000]);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("FRAME_SIZE_ERROR length > 16383: 16777216", e.getMessage());
+    }
+  }
+
+  @Test public void windowUpdateRoundTrip() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final long expectedWindowSizeIncrement = 0x7fffffff;
+
+    // Compose the expected window update frame.
+    dataOut.writeShort(4); // length
+    dataOut.write(Http20Draft09.TYPE_WINDOW_UPDATE);
+    dataOut.write(0); // No flags.
+    dataOut.writeInt(expectedStreamId);
+    dataOut.writeInt((int) expectedWindowSizeIncrement);
+
+    // Check writer sends the same bytes.
+    assertArrayEquals(out.toByteArray(), windowUpdate(expectedWindowSizeIncrement));
+
+    FrameReader fr = newReader(out);
+
+    fr.nextFrame(new BaseTestHandler() { // Consume the window update frame.
+      @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
+      }
+    });
+  }
+
+  @Test public void badWindowSizeIncrement() throws IOException {
+    try {
+      windowUpdate(0);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 0",
+          e.getMessage());
+    }
+    try {
+      windowUpdate(0x80000000L);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 2147483648",
+          e.getMessage());
+    }
+  }
+
+  @Test public void goAwayWithoutDebugDataRoundTrip() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+
+    // Compose the expected GOAWAY frame without debug data.
+    dataOut.writeShort(8); // Without debug data there's only 2 32-bit fields.
+    dataOut.write(Http20Draft09.TYPE_GOAWAY);
+    dataOut.write(0); // no flags.
+    dataOut.writeInt(0); // connection-scope
+    dataOut.writeInt(expectedStreamId); // last good stream.
+    dataOut.writeInt(expectedError.httpCode);
+
+    // Check writer sends the same bytes.
+    assertArrayEquals(out.toByteArray(),
+        sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
+
+    FrameReader fr = newReader(out);
+
+    fr.nextFrame(new BaseTestHandler() { // Consume the go away frame.
+      @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+        assertEquals(expectedStreamId, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertEquals(0, debugData.length);
+      }
+    });
+  }
+
+  @Test public void goAwayWithDebugDataRoundTrip() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+    final byte[] expectedData = new byte[8];
+    Arrays.fill(expectedData, (byte) '*');
+
+    // Compose the expected GOAWAY frame without debug data.
+    dataOut.writeShort(8 + expectedData.length);
+    dataOut.write(Http20Draft09.TYPE_GOAWAY);
+    dataOut.write(0); // no flags.
+    dataOut.writeInt(0); // connection-scope
+    dataOut.writeInt(0); // never read any stream!
+    dataOut.writeInt(expectedError.httpCode);
+    dataOut.write(expectedData);
+
+    // Check writer sends the same bytes.
+    assertArrayEquals(out.toByteArray(), sendGoAway(0, expectedError, expectedData));
+
+    FrameReader fr = newReader(out);
+
+    fr.nextFrame(new BaseTestHandler() { // Consume the go away frame.
+      @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+        assertEquals(0, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertArrayEquals(expectedData, debugData);
+      }
+    });
+  }
+
+  private Http20Draft09.Reader newReader(ByteArrayOutputStream out) {
+    return new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()), 4096, false);
+  }
+
+  @Test public void frameSizeError() throws IOException {
+    Http20Draft09.Writer writer = new Http20Draft09.Writer(new ByteArrayOutputStream(), true);
+
+    try {
+      writer.frameHeader(16384, Http20Draft09.TYPE_DATA, Http20Draft09.FLAG_NONE, 0);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("FRAME_SIZE_ERROR length > 16383: 16384", e.getMessage());
+    }
+  }
+
+  @Test public void streamIdHasReservedBit() throws IOException {
+      Http20Draft09.Writer writer = new Http20Draft09.Writer(new ByteArrayOutputStream(), true);
+
+      try {
+      int streamId = 3;
+      streamId |= 1L << 31; // set reserved bit
+      writer.frameHeader(16383, Http20Draft09.TYPE_DATA, Http20Draft09.FLAG_NONE, streamId);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("reserved bit set: -2147483645", e.getMessage());
+    }
+  }
+
+  private byte[] literalHeaders(List<Header> sentHeaders) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new HpackDraft05.Writer(new DataOutputStream(out)).writeHeaders(sentHeaders);
+    return out.toByteArray();
+  }
+
+  private byte[] sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Http20Draft09.Writer(out, true).ping(ack, payload1, payload2);
+    return out.toByteArray();
+  }
+
+  private byte[] sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+      throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Http20Draft09.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
+    return out.toByteArray();
+  }
+
+  private byte[] sendDataFrame(byte[] data) throws IOException {
+    return sendDataFrame(data, 0, data.length);
+  }
+
+  private byte[] sendDataFrame(byte[] data, int offset, int byteCount) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Http20Draft09.Writer(out, true).dataFrame(expectedStreamId, Http20Draft09.FLAG_NONE, data,
+        offset, byteCount);
+    return out.toByteArray();
+  }
+
+  private byte[] windowUpdate(long windowSizeIncrement) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Http20Draft09.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
+    return out.toByteArray();
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
new file mode 100644
index 0000000000..6206b7efbd
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2013 Twitter, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Original version of this class was lifted from {@code com.twitter.hpack.HuffmanTest}.
+ */
+public class HuffmanTest {
+
+  @Test public void roundTripForRequestAndResponse() throws IOException {
+    String s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
+    for (int i = 0; i < s.length(); i++) {
+      assertRoundTrip(s.substring(0, i).getBytes());
+    }
+
+    Random random = new Random(123456789L);
+    byte[] buf = new byte[4096];
+    random.nextBytes(buf);
+    assertRoundTrip(buf);
+  }
+
+  private void assertRoundTrip(byte[] buf) throws IOException {
+    assertRoundTrip(Huffman.Codec.REQUEST, buf);
+    assertRoundTrip(Huffman.Codec.RESPONSE, buf);
+  }
+
+  private static void assertRoundTrip(Huffman.Codec codec, byte[] buf) throws IOException {
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    DataOutputStream dos = new DataOutputStream(baos);
+
+    codec.encode(buf, dos);
+    assertEquals(baos.size(), codec.encodedLength(buf));
+
+    byte[] decodedBytes = codec.decode(baos.toByteArray());
+    assertTrue(Arrays.equals(buf, decodedBytes));
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index dfdd1d09ae..f890c001e9 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -28,39 +28,56 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
 
-import static java.util.concurrent.Executors.defaultThreadFactory;
-
 /** Replays prerecorded outgoing frames and records incoming frames. */
 public final class MockSpdyPeer implements Closeable {
   private int frameCount = 0;
-  private final boolean client;
+  private boolean client = false;
+  private Variant variant = new Spdy3();
   private final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-  private final FrameWriter frameWriter;
+  private FrameWriter frameWriter = variant.newWriter(bytesOut, client);;
   private final List<OutFrame> outFrames = new ArrayList<OutFrame>();
   private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<InFrame>();
   private int port;
-  private final Executor executor = Executors.newCachedThreadPool(defaultThreadFactory());
+  private final ExecutorService executor = Executors.newCachedThreadPool(
+      Util.threadFactory("MockSpdyPeer", false));
   private ServerSocket serverSocket;
   private Socket socket;
 
-  public MockSpdyPeer(boolean client) {
+  public void setVariantAndClient(Variant variant, boolean client) {
+    if (this.variant.getProtocol() == variant.getProtocol() && this.client == client) {
+      return;
+    }
     this.client = client;
-    this.frameWriter = Variant.SPDY3.newWriter(bytesOut, client);
+    this.variant = variant;
+    this.frameWriter = variant.newWriter(bytesOut, client);
   }
 
   public void acceptFrame() {
     frameCount++;
   }
 
+  public int frameCount() {
+    return frameCount;
+  }
+
   public FrameWriter sendFrame() {
     outFrames.add(new OutFrame(frameCount++, bytesOut.size(), Integer.MAX_VALUE));
     return frameWriter;
   }
 
+  /**
+   * Sends a manually-constructed frame. This is useful to test frames that
+   * won't be generated naturally.
+   */
+  public void sendFrame(byte[] frame) throws IOException {
+    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), Integer.MAX_VALUE));
+    bytesOut.write(frame);
+  }
+
   /**
    * Sends a frame, truncated to {@code truncateToLength} bytes. This is only
    * useful for testing error handling as the truncated frame will be
@@ -71,10 +88,6 @@ public FrameWriter sendTruncatedFrame(int truncateToLength) {
     return frameWriter;
   }
 
-  public int getPort() {
-    return port;
-  }
-
   public InFrame takeFrame() throws InterruptedException {
     return inFrames.take();
   }
@@ -83,12 +96,13 @@ public void play() throws IOException {
     if (serverSocket != null) throw new IllegalStateException();
     serverSocket = new ServerSocket(0);
     serverSocket.setReuseAddress(true);
-    this.port = serverSocket.getLocalPort();
+    port = serverSocket.getLocalPort();
     executor.execute(new Runnable() {
       @Override public void run() {
         try {
           readAndWriteFrames();
         } catch (IOException e) {
+          Util.closeQuietly(MockSpdyPeer.this);
           throw new RuntimeException(e);
         }
       }
@@ -100,7 +114,7 @@ private void readAndWriteFrames() throws IOException {
     socket = serverSocket.accept();
     OutputStream out = socket.getOutputStream();
     InputStream in = socket.getInputStream();
-    FrameReader reader = Variant.SPDY3.newReader(in, client);
+    FrameReader reader = variant.newReader(in, client);
 
     Iterator<OutFrame> outFramesIterator = outFrames.iterator();
     byte[] outBytes = bytesOut.toByteArray();
@@ -139,15 +153,16 @@ public Socket openSocket() throws IOException {
     return new Socket("localhost", port);
   }
 
-  @Override public void close() throws IOException {
+  @Override public synchronized void close() throws IOException {
+    executor.shutdown();
     Socket socket = this.socket;
     if (socket != null) {
-      socket.close();
+      Util.closeQuietly(socket);
       this.socket = null;
     }
     ServerSocket serverSocket = this.serverSocket;
     if (serverSocket != null) {
-      serverSocket.close();
+      Util.closeQuietly(serverSocket);
       this.serverSocket = null;
     }
   }
@@ -175,11 +190,14 @@ private OutFrame(int sequence, int start, int truncateToLength) {
     public int associatedStreamId;
     public int priority;
     public ErrorCode errorCode;
-    public int deltaWindowSize;
-    public List<String> nameValueBlock;
+    public long windowSizeIncrement;
+    public List<Header> headerBlock;
     public byte[] data;
     public Settings settings;
     public HeadersMode headersMode;
+    public boolean ack;
+    public int payload1;
+    public int payload2;
 
     public InFrame(int sequence, FrameReader reader) {
       this.sequence = sequence;
@@ -193,8 +211,14 @@ public InFrame(int sequence, FrameReader reader) {
       this.settings = settings;
     }
 
+    @Override public void ackSettings() {
+      if (this.type != -1) throw new IllegalStateException();
+      this.type = Spdy3.TYPE_SETTINGS;
+      this.ack = true;
+    }
+
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<String> nameValueBlock,
+        int associatedStreamId, int priority, List<Header> headerBlock,
         HeadersMode headersMode) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_HEADERS;
@@ -203,7 +227,7 @@ public InFrame(int sequence, FrameReader reader) {
       this.streamId = streamId;
       this.associatedStreamId = associatedStreamId;
       this.priority = priority;
-      this.nameValueBlock = nameValueBlock;
+      this.headerBlock = headerBlock;
       this.headersMode = headersMode;
     }
 
@@ -224,33 +248,40 @@ public InFrame(int sequence, FrameReader reader) {
       this.errorCode = errorCode;
     }
 
-    @Override public void ping(boolean reply, int payload1, int payload2) {
+    @Override public void ping(boolean ack, int payload1, int payload2) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_PING;
-      this.streamId = payload1;
+      this.ack = ack;
+      this.payload1 = payload1;
+      this.payload2 = payload2;
     }
 
-    @Override public void noop() {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_NOOP;
-    }
-
-    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode) {
+    @Override
+    public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_GOAWAY;
       this.streamId = lastGoodStreamId;
       this.errorCode = errorCode;
+      this.data = debugData;
     }
 
-    @Override public void windowUpdate(int streamId, int deltaWindowSize, boolean endFlowControl) {
+    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_WINDOW_UPDATE;
       this.streamId = streamId;
-      this.deltaWindowSize = deltaWindowSize;
+      this.windowSizeIncrement = windowSizeIncrement;
     }
 
     @Override public void priority(int streamId, int priority) {
       throw new UnsupportedOperationException();
     }
+
+    @Override
+    public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
+      this.type = Http20Draft09.TYPE_PUSH_PROMISE;
+      this.streamId = streamId;
+      this.associatedStreamId = associatedStreamId;
+      this.headerBlock = headerBlock;
+    }
   }
-}
\ No newline at end of file
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
index a906fc7cb9..31df6d2fa5 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
@@ -36,13 +36,21 @@
   @Test public void setFields() {
     Settings settings = new Settings();
 
+    // WARNING: clash on flags between spdy/3 and http/2!
     assertEquals(-3, settings.getUploadBandwidth(-3));
+    assertEquals(-1, settings.getHeaderTableSize());
     settings.set(Settings.UPLOAD_BANDWIDTH, 0, 42);
     assertEquals(42, settings.getUploadBandwidth(-3));
+    settings.set(Settings.HEADER_TABLE_SIZE, 0, 8096);
+    assertEquals(8096, settings.getHeaderTableSize());
 
+    // WARNING: clash on flags between spdy/3 and http/2!
     assertEquals(-3, settings.getDownloadBandwidth(-3));
+    assertEquals(true, settings.getEnablePush(true));
     settings.set(Settings.DOWNLOAD_BANDWIDTH, 0, 53);
     assertEquals(53, settings.getDownloadBandwidth(-3));
+    settings.set(Settings.ENABLE_PUSH, 0, 0);
+    assertEquals(false, settings.getEnablePush(true));
 
     assertEquals(-3, settings.getRoundTripTime(-3));
     settings.set(Settings.ROUND_TRIP_TIME, 0, 64);
@@ -60,9 +68,9 @@
     settings.set(Settings.DOWNLOAD_RETRANS_RATE, 0, 97);
     assertEquals(97, settings.getDownloadRetransRate(-3));
 
-    assertEquals(-3, settings.getInitialWindowSize(-3));
+    assertEquals(-1, settings.getInitialWindowSize());
     settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 108);
-    assertEquals(108, settings.getInitialWindowSize(-3));
+    assertEquals(108, settings.getInitialWindowSize());
 
     assertEquals(-3, settings.getClientCertificateVectorSize(-3));
     settings.set(Settings.CLIENT_CERTIFICATE_VECTOR_SIZE, 0, 117);
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
new file mode 100644
index 0000000000..c6adebb51a
--- /dev/null
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import org.junit.Test;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class Spdy3Test {
+  static final int expectedStreamId = 15;
+
+  @Test public void tooLargeDataFrame() throws IOException {
+    try {
+      sendDataFrame(new byte[0x1000000]);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("FRAME_TOO_LARGE max size is 16Mib: " + 0x1000000L, e.getMessage());
+    }
+  }
+
+  @Test public void badWindowSizeIncrement() throws IOException {
+    try {
+      windowUpdate(0);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 0", e.getMessage());
+    }
+    try {
+      windowUpdate(0x80000000L);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement must be between 1 and 0x7fffffff: 2147483648",
+          e.getMessage());
+    }
+  }
+
+  @Test public void goAwayRoundTrip() throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    DataOutputStream dataOut = new DataOutputStream(out);
+
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+
+    // Compose the expected GOAWAY frame without debug data
+    // |C| Version(15bits) | Type(16bits) |
+    dataOut.writeInt(0x80000000 | (Spdy3.VERSION & 0x7fff) << 16 | Spdy3.TYPE_GOAWAY & 0xffff);
+    // | Flags (8)  |  Length (24 bits)   |
+    dataOut.writeInt(8); // no flags and length is 8.
+    dataOut.writeInt(expectedStreamId); // last good stream.
+    dataOut.writeInt(expectedError.spdyGoAwayCode);
+
+    // Check writer sends the same bytes.
+    assertArrayEquals(out.toByteArray(),
+        sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
+
+    // SPDY/3 does not send debug data, so bytes should be same!
+    assertArrayEquals(out.toByteArray(), sendGoAway(expectedStreamId, expectedError, new byte[8]));
+
+    FrameReader fr = newReader(out);
+
+    fr.nextFrame(new BaseTestHandler() { // Consume the goAway frame.
+      @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+        assertEquals(expectedStreamId, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertEquals(0, debugData.length);
+      }
+    });
+  }
+
+  private Spdy3.Reader newReader(ByteArrayOutputStream out) {
+    return new Spdy3.Reader(new ByteArrayInputStream(out.toByteArray()), false);
+  }
+
+  private byte[] sendDataFrame(byte[] data) throws IOException {
+    return sendDataFrame(data, 0, data.length);
+  }
+
+  private byte[] sendDataFrame(byte[] data, int offset, int byteCount) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Spdy3.Writer(out, true).sendDataFrame(expectedStreamId, 0, data, offset, byteCount);
+    return out.toByteArray();
+  }
+
+  private byte[] windowUpdate(long increment) throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Spdy3.Writer(out, true).windowUpdate(expectedStreamId, increment);
+    return out.toByteArray();
+  }
+
+  private byte[] sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+      throws IOException {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    new Spdy3.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
+    return out.toByteArray();
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index ebc67603d3..acf2f5c44d 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.squareup.okhttp.internal.spdy;
 
+import com.squareup.okhttp.internal.Base64;
 import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -29,6 +29,7 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.UTF_8;
+import static com.squareup.okhttp.internal.Util.headerEntries;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.CANCEL;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.FLOW_CONTROL_ERROR;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.INTERNAL_ERROR;
@@ -37,26 +38,30 @@
 import static com.squareup.okhttp.internal.spdy.ErrorCode.REFUSED_STREAM;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.STREAM_IN_USE;
 import static com.squareup.okhttp.internal.spdy.Settings.PERSIST_VALUE;
+import static com.squareup.okhttp.internal.spdy.SpdyStream.OUTPUT_BUFFER_SIZE;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_DATA;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_GOAWAY;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_NOOP;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_PING;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_RST_STREAM;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_SETTINGS;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_WINDOW_UPDATE;
-import static com.squareup.okhttp.internal.spdy.SpdyStream.WINDOW_UPDATE_THRESHOLD;
+import static com.squareup.okhttp.internal.spdy.SpdyConnection.INITIAL_WINDOW_SIZE;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class SpdyConnectionTest {
+  private static final Variant SPDY3 = new Spdy3();
+  private static final Variant HTTP_20_DRAFT_09 = new Http20Draft09();
+
   private static final IncomingStreamHandler REJECT_INCOMING_STREAMS = new IncomingStreamHandler() {
     @Override public void receive(SpdyStream stream) throws IOException {
       throw new AssertionError();
     }
   };
-  private final MockSpdyPeer peer = new MockSpdyPeer(false);
+  private final MockSpdyPeer peer = new MockSpdyPeer();
 
   @After public void tearDown() throws Exception {
     peer.close();
@@ -65,15 +70,16 @@
   @Test public void clientCreatesStreamAndServerReplies() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
+    peer.sendFrame()
+        .synReply(false, 1, headerEntries("a", "android"));
     peer.sendFrame().data(true, 1, "robot".getBytes("UTF-8"));
     peer.acceptFrame(); // DATA
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
-    assertEquals(Arrays.asList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     assertStreamData("robot", stream.getInputStream());
     writeAndClose(stream, "c3po");
     assertEquals(0, connection.openStreamCount());
@@ -86,20 +92,20 @@
     assertFalse(synStream.outFinished);
     assertEquals(1, synStream.streamId);
     assertEquals(0, synStream.associatedStreamId);
-    assertEquals(Arrays.asList("b", "banana"), synStream.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
     MockSpdyPeer.InFrame requestData = peer.takeFrame();
     assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
   }
 
   @Test public void headersOnlyStreamIsClosedAfterReplyHeaders() throws Exception {
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.play();
 
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), false, false);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, false);
     assertEquals(1, connection.openStreamCount());
-    assertEquals(Arrays.asList("b", "banana"), stream.getResponseHeaders());
+    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
     assertEquals(0, connection.openStreamCount());
   }
 
@@ -107,13 +113,13 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(true, 1, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(true, 1, headerEntries("a", "android"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    connection.newStream(Arrays.asList("b", "banana"), false, true);
+    connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(1, connection.openStreamCount());
     connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
     assertEquals(0, connection.openStreamCount());
@@ -128,7 +134,7 @@
 
   @Test public void serverCreatesStreamAndClientReplies() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 5, 129, Arrays.asList("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, 5, 129, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
     peer.play();
 
@@ -137,10 +143,10 @@
     IncomingStreamHandler handler = new IncomingStreamHandler() {
       @Override public void receive(SpdyStream stream) throws IOException {
         receiveCount.incrementAndGet();
-        assertEquals(Arrays.asList("a", "android"), stream.getRequestHeaders());
+        assertEquals(headerEntries("a", "android"), stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
         assertEquals(5, stream.getPriority());
-        stream.reply(Arrays.asList("b", "banana"), true);
+        stream.reply(headerEntries("b", "banana"), true);
       }
     };
     new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
@@ -151,13 +157,24 @@
     assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
     assertFalse(reply.inFinished);
     assertEquals(2, reply.streamId);
-    assertEquals(Arrays.asList("b", "banana"), reply.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), reply.headerBlock);
     assertEquals(1, receiveCount.get());
   }
 
   @Test public void replyWithNoData() throws Exception {
+    MockSpdyPeer.InFrame reply = replyWithNoData(SPDY3);
+    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
+  }
+
+  @Test public void replyWithNoDataHttp2() throws Exception {
+    MockSpdyPeer.InFrame reply = replyWithNoData(HTTP_20_DRAFT_09);
+    assertEquals(HeadersMode.HTTP_20_HEADERS, reply.headersMode);
+  }
+
+  private MockSpdyPeer.InFrame replyWithNoData(Variant variant) throws Exception {
+    peer.setVariantAndClient(variant, false);
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, Arrays.asList("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
     peer.play();
 
@@ -165,62 +182,66 @@
     final AtomicInteger receiveCount = new AtomicInteger();
     IncomingStreamHandler handler = new IncomingStreamHandler() {
       @Override public void receive(SpdyStream stream) throws IOException {
-        stream.reply(Arrays.asList("b", "banana"), false);
+        stream.reply(headerEntries("b", "banana"), false);
         receiveCount.incrementAndGet();
       }
     };
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
+    connectionBuilder(peer, variant).handler(handler).build();
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame reply = peer.takeFrame();
     assertEquals(TYPE_HEADERS, reply.type);
-    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
     assertTrue(reply.inFinished);
-    assertEquals(Arrays.asList("b", "banana"), reply.nameValueBlock);
+    assertEquals(headerEntries("b", "banana"), reply.headerBlock);
     assertEquals(1, receiveCount.get());
+    return reply;
   }
 
-  @Test public void noop() throws Exception {
+  @Test public void serverPingsClient() throws Exception {
     // write the mocking script
-    peer.acceptFrame(); // NOOP
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    SpdyConnection connection =
-        new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS)
-            .build();
-    connection.noop();
+    connection(peer, SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_NOOP, ping.type);
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(0, ping.payload2); // ignored in spdy!
+    assertTrue(ping.ack);
   }
 
-  @Test public void serverPingsClient() throws Exception {
+  @Test public void serverPingsClientHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
+
     // write the mocking script
-    peer.sendFrame().ping(false, 2, 0);
+    peer.sendFrame().ping(false, 2, 3);
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
+    connection(peer, HTTP_20_DRAFT_09);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.streamId);
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(3, ping.payload2);
+    assertTrue(ping.ack);
   }
 
   @Test public void clientPingsServer() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
+    peer.sendFrame().ping(true, 1, 5); // payload2 ignored in spdy!
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, SPDY3);
     Ping ping = connection.ping();
     assertTrue(ping.roundTripTime() > 0);
     assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
@@ -228,7 +249,67 @@
     // verify the peer received what was expected
     MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
     assertEquals(TYPE_PING, pingFrame.type);
-    assertEquals(1, pingFrame.streamId);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(0, pingFrame.payload2);
+    assertFalse(pingFrame.ack);
+  }
+
+  @Test public void clientPingsServerHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
+
+    // write the mocking script
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 5);
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
+    Ping ping = connection.ping();
+    assertTrue(ping.roundTripTime() > 0);
+    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
+    assertEquals(0, pingFrame.streamId);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
+    assertFalse(pingFrame.ack);
+  }
+
+  @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
+
+    Settings initial = new Settings();
+    initial.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 1684);
+    Settings shouldntImpactConnection = new Settings();
+    shouldntImpactConnection.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 3368);
+
+    peer.sendFrame().settings(initial);
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().settings(shouldntImpactConnection);
+    peer.acceptFrame(); // ACK 2
+    peer.acceptFrame(); // HEADERS
+    peer.play();
+
+    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
+
+    // verify the peer received the ACK
+    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+    ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+
+    // This stream was created *after* the connection settings were adjusted.
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+
+    assertEquals(3368, connection.peerSettings.getInitialWindowSize());
+    assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
+    // New Stream is has the most recent initial window size.
+    assertEquals(3368, stream.bytesLeftInWriteWindow);
   }
 
   @Test public void unexpectedPingIsNotReturned() throws Exception {
@@ -241,13 +322,42 @@
     peer.play();
 
     // play it back
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
+    connection(peer, SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame ping2 = peer.takeFrame();
-    assertEquals(2, ping2.streamId);
+    assertEquals(2, ping2.payload1);
     MockSpdyPeer.InFrame ping4 = peer.takeFrame();
-    assertEquals(4, ping4.streamId);
+    assertEquals(4, ping4.payload1);
+  }
+
+  @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
+    boolean client = false; // Peer is server, so we are client.
+    Settings settings = new Settings();
+    settings.set(Settings.HEADER_TABLE_SIZE, PERSIST_VALUE, 0);
+
+    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+
+    // verify the peer's settings were read and applied.
+    synchronized (connection) {
+      assertEquals(0, connection.peerSettings.getHeaderTableSize());
+      Http20Draft09.Reader frameReader = (Http20Draft09.Reader) connection.frameReader;
+      assertEquals(0, frameReader.hpackReader.maxHeaderTableByteCount());
+      // TODO: when supported, check the frameWriter's compression table is unaffected.
+    }
+  }
+
+  @Test public void peerHttp2ClientDisablesPush() throws Exception {
+    boolean client = false; // Peer is client, so we are server.
+    Settings settings = new Settings();
+    settings.set(Settings.ENABLE_PUSH, 0, 0); // The peer client disables push.
+
+    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+
+    // verify the peer's settings were read and applied.
+    synchronized (connection) {
+      assertFalse(connection.peerSettings.getEnablePush(true));
+    }
   }
 
   @Test public void serverSendsSettingsToClient() throws Exception {
@@ -260,13 +370,11 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, SPDY3);
 
-    peer.takeFrame(); // Guarantees that the Settings frame has been processed.
+    peer.takeFrame(); // Guarantees that the peer Settings frame has been processed.
     synchronized (connection) {
-      assertEquals(10, connection.settings.getMaxConcurrentStreams(-1));
+      assertEquals(10, connection.peerSettings.getMaxConcurrentStreams(-1));
     }
   }
 
@@ -287,20 +395,18 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
+    SpdyConnection connection = connection(peer, SPDY3);
 
     peer.takeFrame(); // Guarantees that the Settings frame has been processed.
     synchronized (connection) {
-      assertEquals(100, connection.settings.getUploadBandwidth(-1));
-      assertEquals(PERSIST_VALUE, connection.settings.flags(Settings.UPLOAD_BANDWIDTH));
-      assertEquals(400, connection.settings.getDownloadBandwidth(-1));
-      assertEquals(0, connection.settings.flags(Settings.DOWNLOAD_BANDWIDTH));
-      assertEquals(500, connection.settings.getDownloadRetransRate(-1));
-      assertEquals(PERSIST_VALUE, connection.settings.flags(Settings.DOWNLOAD_RETRANS_RATE));
-      assertEquals(600, connection.settings.getMaxConcurrentStreams(-1));
-      assertEquals(PERSIST_VALUE, connection.settings.flags(Settings.MAX_CONCURRENT_STREAMS));
+      assertEquals(100, connection.peerSettings.getUploadBandwidth(-1));
+      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(Settings.UPLOAD_BANDWIDTH));
+      assertEquals(400, connection.peerSettings.getDownloadBandwidth(-1));
+      assertEquals(0, connection.peerSettings.flags(Settings.DOWNLOAD_BANDWIDTH));
+      assertEquals(500, connection.peerSettings.getDownloadRetransRate(-1));
+      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(Settings.DOWNLOAD_RETRANS_RATE));
+      assertEquals(600, connection.peerSettings.getMaxConcurrentStreams(-1));
+      assertEquals(PERSIST_VALUE, connection.peerSettings.flags(Settings.MAX_CONCURRENT_STREAMS));
     }
   }
 
@@ -313,7 +419,7 @@
     peer.play();
 
     // play it back
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
+    connection(peer, SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -321,19 +427,19 @@
     assertEquals(42, rstStream.streamId);
     assertEquals(INVALID_STREAM, rstStream.errorCode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void bogusReplyFrameDoesNotDisruptConnection() throws Exception {
     // write the mocking script
-    peer.sendFrame().synReply(false, 42, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(false, 42, headerEntries("a", "android"));
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(REJECT_INCOMING_STREAMS).build();
+    connection(peer, SPDY3);
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -341,13 +447,13 @@
     assertEquals(42, rstStream.streamId);
     assertEquals(INVALID_STREAM, rstStream.errorCode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void clientClosesClientOutputStream() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.acceptFrame(); // TYPE_DATA
     peer.acceptFrame(); // TYPE_DATA with FLAG_FIN
     peer.acceptFrame(); // PING
@@ -355,10 +461,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, false);
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, false);
     OutputStream out = stream.getOutputStream();
     out.write("square".getBytes(UTF_8));
     out.flush();
@@ -388,7 +492,7 @@
     assertTrue(fin.inFinished);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(1, ping.streamId);
+    assertEquals(1, ping.payload1);
   }
 
   @Test public void serverClosesClientOutputStream() throws Exception {
@@ -401,10 +505,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, true);
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     OutputStream out = stream.getOutputStream();
     connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
     try {
@@ -424,7 +526,7 @@
     assertFalse(synStream.outFinished);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(1, ping.streamId);
+    assertEquals(1, ping.payload1);
     MockSpdyPeer.InFrame data = peer.takeFrame();
     assertEquals(TYPE_DATA, data.type);
     assertEquals(1, data.streamId);
@@ -443,10 +545,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), false, true);
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     InputStream in = stream.getInputStream();
     OutputStream out = stream.getOutputStream();
     in.close();
@@ -488,10 +588,8 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, true);
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     InputStream in = stream.getInputStream();
     OutputStream out = stream.getOutputStream();
     in.close();
@@ -527,15 +625,13 @@
   @Test public void serverClosesClientInputStream() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.sendFrame().data(true, 1, "square".getBytes(UTF_8));
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket())
-        .handler(REJECT_INCOMING_STREAMS)
-        .build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), false, true);
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
     InputStream in = stream.getInputStream();
     assertStreamData("square", in);
     assertEquals(0, connection.openStreamCount());
@@ -551,17 +647,17 @@
   @Test public void remoteDoubleSynReply() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 1, Arrays.asList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("c", "cola"), true, true);
-    assertEquals(Arrays.asList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(headerEntries("c", "cola"), true, true);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
     try {
       stream.getInputStream().read();
@@ -584,9 +680,9 @@
 
   @Test public void remoteDoubleSynStream() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, Arrays.asList("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, Arrays.asList("b", "banana"));
+    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("b", "banana"));
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
@@ -595,9 +691,9 @@
     IncomingStreamHandler handler = new IncomingStreamHandler() {
       @Override public void receive(SpdyStream stream) throws IOException {
         receiveCount.incrementAndGet();
-        assertEquals(Arrays.asList("a", "android"), stream.getRequestHeaders());
+        assertEquals(headerEntries("a", "android"), stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
-        stream.reply(Arrays.asList("c", "cola"), true);
+        stream.reply(headerEntries("c", "cola"), true);
       }
     };
     new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
@@ -616,7 +712,7 @@
   @Test public void remoteSendsDataAfterInFinished() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     peer.sendFrame().data(true, 1, "robot".getBytes("UTF-8"));
     peer.sendFrame().data(true, 1, "c3po".getBytes("UTF-8")); // Ignored.
     peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
@@ -625,8 +721,8 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
-    assertEquals(Arrays.asList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     assertStreamData("robot", stream.getInputStream());
 
     // verify the peer received what was expected
@@ -635,13 +731,13 @@
     assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void remoteSendsTooMuchData() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.sendFrame().data(false, 1, new byte[64 * 1024 + 1]);
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
@@ -650,8 +746,8 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, true);
-    assertEquals(Arrays.asList("b", "banana"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
+    assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
@@ -663,7 +759,7 @@
     assertEquals(FLOW_CONTROL_ERROR, rstStream.errorCode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
   @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
@@ -676,7 +772,7 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     try {
       stream.getResponseHeaders();
       fail();
@@ -691,23 +787,34 @@
     assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
-    assertEquals(2, ping.streamId);
+    assertEquals(2, ping.payload1);
   }
 
+
   @Test public void receiveGoAway() throws Exception {
+    receiveGoAway(SPDY3);
+  }
+
+  @Test public void receiveGoAwayHttp2() throws Exception {
+    receiveGoAway(HTTP_20_DRAFT_09);
+  }
+
+  private void receiveGoAway(Variant variant) throws Exception {
+    peer.setVariantAndClient(variant, false);
+
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // SYN_STREAM 3
-    peer.sendFrame().goAway(1, PROTOCOL_ERROR);
+    peer.sendFrame().goAway(1, PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // DATA STREAM 1
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream1 = connection.newStream(Arrays.asList("a", "android"), true, true);
-    SpdyStream stream2 = connection.newStream(Arrays.asList("b", "banana"), true, true);
+    SpdyConnection connection = connection(peer, variant);
+    SpdyStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
+    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the GO_AWAY has been received.
     stream1.getOutputStream().write("abc".getBytes(UTF_8));
     try {
@@ -719,7 +826,7 @@
     stream1.getOutputStream().write("def".getBytes(UTF_8));
     stream1.getOutputStream().close();
     try {
-      connection.newStream(Arrays.asList("c", "cola"), true, true);
+      connection.newStream(headerEntries("c", "cola"), true, true);
       fail();
     } catch (IOException expected) {
       assertEquals("shutdown", expected.getMessage());
@@ -744,13 +851,13 @@
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // GOAWAY
     peer.acceptFrame(); // PING
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, Arrays.asList("b", "b")); // Should be ignored!
+    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("b", "b")); // Should be ignored!
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    connection.newStream(Arrays.asList("a", "android"), true, true);
+    connection.newStream(headerEntries("a", "android"), true, true);
     Ping ping = connection.ping();
     connection.shutdown(PROTOCOL_ERROR);
     assertEquals(1, connection.openStreamCount());
@@ -797,12 +904,12 @@
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("a", "android"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     assertEquals(1, connection.openStreamCount());
     connection.close();
     assertEquals(0, connection.openStreamCount());
     try {
-      connection.newStream(Arrays.asList("b", "banana"), true, true);
+      connection.newStream(headerEntries("b", "banana"), true, true);
       fail();
     } catch (IOException expected) {
       assertEquals("shutdown", expected.getMessage());
@@ -847,14 +954,14 @@
   @Test public void readTimeoutExpires() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     stream.setReadTimeout(1000);
     InputStream in = stream.getInputStream();
     long startNanos = System.nanoTime();
@@ -877,16 +984,16 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
-    peer.sendFrame().headers(1, Arrays.asList("c", "c3po"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().headers(1, headerEntries("c", "c3po"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
-    assertEquals(Arrays.asList("a", "android", "c", "c3po"), stream.getResponseHeaders());
+    assertEquals(headerEntries("a", "android", "c", "c3po"), stream.getResponseHeaders());
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
@@ -900,14 +1007,14 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().headers(1, Arrays.asList("c", "c3po"));
+    peer.sendFrame().headers(1, headerEntries("c", "c3po"));
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
     try {
       stream.getResponseHeaders();
@@ -928,80 +1035,227 @@
   }
 
   @Test public void readSendsWindowUpdate() throws Exception {
+    readSendsWindowUpdate(SPDY3);
+  }
+
+  @Test public void readSendsWindowUpdateHttp2() throws Exception {
+    readSendsWindowUpdate(HTTP_20_DRAFT_09);
+  }
+
+  private void readSendsWindowUpdate(Variant variant)
+      throws IOException, InterruptedException {
+    peer.setVariantAndClient(variant, false);
+
+    int windowUpdateThreshold = INITIAL_WINDOW_SIZE / 2;
+
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     for (int i = 0; i < 3; i++) {
-      peer.sendFrame().data(false, 1, new byte[WINDOW_UPDATE_THRESHOLD]);
-      peer.acceptFrame(); // WINDOW UPDATE
+      peer.sendFrame().data(false, 1, new byte[OUTPUT_BUFFER_SIZE]);
+      peer.sendFrame().data(false, 1, new byte[OUTPUT_BUFFER_SIZE]);
+      peer.sendFrame().data(false, 1, new byte[OUTPUT_BUFFER_SIZE]);
+      peer.sendFrame().data(false, 1, new byte[windowUpdateThreshold - OUTPUT_BUFFER_SIZE * 3]);
+      peer.acceptFrame(); // connection WINDOW UPDATE
+      peer.acceptFrame(); // stream WINDOW UPDATE
     }
     peer.sendFrame().data(true, 1, new byte[0]);
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
-    assertEquals(Arrays.asList("a", "android"), stream.getResponseHeaders());
+    SpdyConnection connection = connection(peer, variant);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals(0, stream.unacknowledgedBytesRead);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     InputStream in = stream.getInputStream();
     int total = 0;
     byte[] buffer = new byte[1024];
     int count;
     while ((count = in.read(buffer)) != -1) {
       total += count;
-      if (total == 3 * WINDOW_UPDATE_THRESHOLD) break;
+      if (total == 3 * windowUpdateThreshold) break;
     }
     assertEquals(-1, in.read());
 
     // Verify the peer received what was expected.
+    assertEquals(21, peer.frameCount());
+
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream.type);
     for (int i = 0; i < 3; i++) {
       MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
       assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
       assertEquals(1, windowUpdate.streamId);
-      assertEquals(WINDOW_UPDATE_THRESHOLD, windowUpdate.deltaWindowSize);
+      assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+      windowUpdate = peer.takeFrame();
+      assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
+      assertEquals(0, windowUpdate.streamId); // connection window update
+      assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
     }
   }
 
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
+    serverSendsEmptyDataClientDoesntSendWindowUpdate(SPDY3);
+  }
+
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
+    serverSendsEmptyDataClientDoesntSendWindowUpdate(HTTP_20_DRAFT_09);
+  }
+
+  private void serverSendsEmptyDataClientDoesntSendWindowUpdate(Variant variant)
+      throws IOException, InterruptedException {
+    peer.setVariantAndClient(variant, false);
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 1, new byte[0]);
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, variant);
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(-1, client.getInputStream().read());
+
+    // Verify the peer received what was expected.
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    assertEquals(3, peer.frameCount());
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
+    clientSendsEmptyDataServerDoesntSendWindowUpdate(SPDY3);
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
+    clientSendsEmptyDataServerDoesntSendWindowUpdate(HTTP_20_DRAFT_09);
+  }
+
+  private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
+      throws IOException, InterruptedException {
+    peer.setVariantAndClient(variant, false);
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, variant);
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals(0, client.getInputStream().available());
+    client.getOutputStream().write(Util.EMPTY_BYTE_ARRAY);
+    client.getOutputStream().flush();
+    client.getOutputStream().close();
+
+    // Verify the peer received what was expected.
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    assertEquals(2, peer.frameCount());
+  }
+
   @Test public void writeAwaitsWindowUpdate() throws Exception {
+    int framesThatFillWindow = roundUp(INITIAL_WINDOW_SIZE, OUTPUT_BUFFER_SIZE);
+
     // Write the mocking script. This accepts more data frames than necessary!
     peer.acceptFrame(); // SYN_STREAM
-    for (int i = 0; i < Settings.DEFAULT_INITIAL_WINDOW_SIZE / 1024; i++) {
+    for (int i = 0; i < framesThatFillWindow; i++) {
       peer.acceptFrame(); // DATA
     }
+    peer.acceptFrame(); // DATA we won't be able to flush until a window update.
     peer.play();
 
     // Play it back.
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     OutputStream out = stream.getOutputStream();
-    out.write(new byte[Settings.DEFAULT_INITIAL_WINDOW_SIZE]);
-    interruptAfterDelay(500);
-    try {
-      out.write('a');
-      out.flush();
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
+    out.write(new byte[INITIAL_WINDOW_SIZE]);
+    out.flush();
+
+    // Check that we've filled the window for both the stream and also the connection.
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+
+    out.write('a');
+    assertFlushBlocks(out);
+
+    // receiving a window update on the connection isn't enough.
+    connection.readerRunnable.windowUpdate(0, 1);
+    assertFlushBlocks(out);
+
+    // receiving a window update on the stream will unblock the stream.
+    connection.readerRunnable.windowUpdate(1, 1);
+    out.flush();
 
     // Verify the peer received what was expected.
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream.type);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(TYPE_DATA, data.type);
+    for (int i = 0; i < framesThatFillWindow; i++) {
+      MockSpdyPeer.InFrame data = peer.takeFrame();
+      assertEquals(TYPE_DATA, data.type);
+    }
+  }
+
+  @Test public void initialSettingsWithWindowSizeAdjustsConnection() throws Exception {
+    int framesThatFillWindow = roundUp(INITIAL_WINDOW_SIZE, OUTPUT_BUFFER_SIZE);
+
+    // Write the mocking script. This accepts more data frames than necessary!
+    peer.acceptFrame(); // SYN_STREAM
+    for (int i = 0; i < framesThatFillWindow; i++) {
+      peer.acceptFrame(); // DATA on stream 1
+    }
+    peer.acceptFrame(); // DATA on stream 2
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyStream stream = connection.newStream(headerEntries("a", "apple"), true, true);
+    OutputStream out = stream.getOutputStream();
+    out.write(new byte[INITIAL_WINDOW_SIZE]);
+    out.flush();
+
+    // write 1 more than the window size
+    out.write('a');
+    assertFlushBlocks(out);
+
+    // Check that we've filled the window for both the stream and also the connection.
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+
+    // Receiving a Settings with a larger window size will unblock the streams.
+    Settings initial = new Settings();
+    initial.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, INITIAL_WINDOW_SIZE + 1);
+    connection.readerRunnable.settings(false, initial);
+
+    assertEquals(1, connection.bytesLeftInWriteWindow);
+    assertEquals(1, connection.getStream(1).bytesLeftInWriteWindow);
+
+    // The stream should no longer be blocked.
+    out.flush();
+
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+
+    // Settings after the initial do not affect the connection window size.
+    Settings next = new Settings();
+    next.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, INITIAL_WINDOW_SIZE + 2);
+    connection.readerRunnable.settings(false, next);
+
+    assertEquals(0, connection.bytesLeftInWriteWindow); // connection wasn't affected.
+    assertEquals(1, connection.getStream(1).bytesLeftInWriteWindow);
   }
 
   @Test public void testTruncatedDataFrame() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 1, Arrays.asList("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     peer.sendTruncatedFrame(8 + 100).data(false, 1, new byte[1024]);
     peer.play();
 
     // play it back
     SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
-    SpdyStream stream = connection.newStream(Arrays.asList("b", "banana"), true, true);
-    assertEquals(Arrays.asList("a", "android"), stream.getResponseHeaders());
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     InputStream in = stream.getInputStream();
     try {
       Util.readFully(in, new byte[101]);
@@ -1011,6 +1265,160 @@
     }
   }
 
+  @Test public void blockedStreamDoesntStarveNewStream() throws Exception {
+    int framesThatFillWindow = roundUp(INITIAL_WINDOW_SIZE, SpdyStream.OUTPUT_BUFFER_SIZE);
+
+    // Write the mocking script. This accepts more data frames than necessary!
+    peer.acceptFrame(); // SYN_STREAM
+    for (int i = 0; i < framesThatFillWindow; i++) {
+      peer.acceptFrame(); // DATA on stream 1
+    }
+    peer.acceptFrame(); // DATA on stream 2
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyStream stream1 = connection.newStream(headerEntries("a", "apple"), true, true);
+    OutputStream out1 = stream1.getOutputStream();
+    out1.write(new byte[INITIAL_WINDOW_SIZE]);
+    out1.flush();
+
+    // Check that we've filled the window for both the stream and also the connection.
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+
+    // receiving a window update on the the connection will unblock new streams.
+    connection.readerRunnable.windowUpdate(0, 3);
+
+    assertEquals(3, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+
+    // Another stream should be able to send data even though 1 is blocked.
+    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
+    OutputStream out2 = stream2.getOutputStream();
+    out2.write("foo".getBytes(UTF_8));
+    out2.flush();
+
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+    assertEquals(INITIAL_WINDOW_SIZE - 3, connection.getStream(3).bytesLeftInWriteWindow);
+  }
+
+  /**
+   * This tests that data frames are written in chunks limited by the
+   * SpdyDataOutputStream buffer size.  A side-effect is that this size
+   * prevents us from overrunning the max frame size of SPDY/3 or HTTP/2.
+   */
+  @Test public void spdyStreamOutputBufferSizeLimitsDataFrameLength() throws Exception {
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
+
+    byte[] buff = new byte[SpdyStream.OUTPUT_BUFFER_SIZE * 2];
+    Arrays.fill(buff, (byte) '*');
+
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA 1
+    peer.acceptFrame(); // DATA 2
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    OutputStream out = stream.getOutputStream();
+    out.write(buff);
+    out.flush();
+    out.close();
+
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    MockSpdyPeer.InFrame data = peer.takeFrame();
+    assertEquals(SpdyStream.OUTPUT_BUFFER_SIZE, data.data.length);
+    data = peer.takeFrame();
+    assertEquals(SpdyStream.OUTPUT_BUFFER_SIZE, data.data.length);
+  }
+
+  /** https://github.com/square/okhttp/issues/333 */
+  @Test public void headerBlockHasTrailingCompressedBytes() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    // This specially-formatted frame has trailing deflated bytes after the name value block.
+    String frame = "gAMAAgAAAgkAAAABeLvjxqfCYgAAAAD//2IAAAAA//9iAAAAAP//YgQAAAD//2IAAAAA//9iAAAAAP/"
+        + "/YgAAAAD//2IEAAAA//9KBAAAAP//YgAAAAD//2IAAAAA//9iAAAAAP//sgEAAAD//2IAAAAA\n//9iBAAAAP//Y"
+        + "gIAAAD//2IGAAAA//9iAQAAAP//YgUAAAD//2IDAAAA//9iBwAAAP//4gAAAAD//+IEAAAA///iAgAAAP//4gYAA"
+        + "AD//+IBAAAA///iBQAAAP//4gMAAAD//+IHAAAA//8SAAAAAP//EgQAAAD//xICAAAA//8SBgAAAP//EgEAAAD//"
+        + "xIFAAAA//8SAwAAAP//EgcAAAD//5IAAAAA//+SBAAAAP//kgIAAAD//5IGAAAA//+SAQAAAP//kgUAAAD//5IDA"
+        + "AAA//+SBwAAAP//UgAAAAD//1IEAAAA//9SAgAAAP//UgYAAAD//1IBAAAA//9SBQAAAP//UgMAAAD//1IHAAAA/"
+        + "//SAAAAAP//0gQAAAD//9ICAAAA///SBgAAAP//0gEAAAD//9IFAAAA///SAwAAAP//0gcAAAD//zIAAAAA//8yB"
+        + "AAAAP//MgIAAAD//zIGAAAA//8yAQAAAP//MgUAAAD//zIDAAAA//8yBwAAAP//sgAAAAD//7IEAAAA//+yAgAAA"
+        + "P//sgYAAAD//w==";
+    peer.sendFrame(Base64.decode(frame.getBytes(UTF_8)));
+    peer.sendFrame().data(true, 1, "robot".getBytes("UTF-8"));
+    peer.acceptFrame(); // DATA
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    assertEquals("a", stream.getResponseHeaders().get(0).name.utf8());
+    assertEquals(60, stream.getResponseHeaders().get(0).value.size());
+    assertStreamData("robot", stream.getInputStream());
+  }
+
+  // TODO: change this to only cancel when local settings disable push
+  @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
+
+    // write the mocking script
+    peer.sendFrame().pushPromise(1, 2, Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    ));
+    peer.sendFrame().synReply(true, 2, Arrays.asList(
+        new Header(Header.RESPONSE_STATUS, "200")
+    ));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    connection(peer, HTTP_20_DRAFT_09);
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
+    assertEquals(TYPE_RST_STREAM, rstStream.type);
+    assertEquals(2, rstStream.streamId);
+    assertEquals(CANCEL, rstStream.errorCode);
+  }
+
+  private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
+      throws IOException, InterruptedException {
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, client);
+    peer.sendFrame().settings(settings);
+    peer.acceptFrame(); // ACK
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
+
+    // verify the peer received the ACK
+    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+    return connection;
+  }
+
+  private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
+    return connectionBuilder(peer, variant).handler(REJECT_INCOMING_STREAMS).build();
+  }
+
+  private SpdyConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
+      throws IOException {
+    return new SpdyConnection.Builder(true, peer.openSocket()).protocol(variant.getProtocol());
+  }
+
   private void writeAndClose(SpdyStream stream, String data) throws IOException {
     OutputStream out = stream.getOutputStream();
     out.write(data.getBytes("UTF-8"));
@@ -1027,6 +1435,15 @@ private void assertStreamData(String expected, InputStream inputStream) throws I
     assertEquals(expected, actual);
   }
 
+  private void assertFlushBlocks(OutputStream out) throws IOException {
+    interruptAfterDelay(500);
+    try {
+      out.flush();
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+  }
+
   /** Interrupts the current thread after {@code delayMillis}. */
   private void interruptAfterDelay(final long delayMillis) {
     final Thread toInterrupt = Thread.currentThread();
@@ -1041,4 +1458,8 @@ private void interruptAfterDelay(final long delayMillis) {
       }
     }.start();
   }
+
+  static int roundUp(int num, int divisor) {
+    return (num + divisor - 1) / divisor;
+  }
 }
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 9bad03d309..17f4cdac20 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Address.java b/okhttp/src/main/java/com/squareup/okhttp/Address.java
index b34bd9128c..ebda2a64a5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Address.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Address.java
@@ -41,22 +41,22 @@
   final SSLSocketFactory sslSocketFactory;
   final HostnameVerifier hostnameVerifier;
   final OkAuthenticator authenticator;
-  final List<String> transports;
+  final List<Protocol> protocols;
 
   public Address(String uriHost, int uriPort, SSLSocketFactory sslSocketFactory,
       HostnameVerifier hostnameVerifier, OkAuthenticator authenticator, Proxy proxy,
-      List<String> transports) throws UnknownHostException {
+      List<Protocol> protocols) throws UnknownHostException {
     if (uriHost == null) throw new NullPointerException("uriHost == null");
     if (uriPort <= 0) throw new IllegalArgumentException("uriPort <= 0: " + uriPort);
     if (authenticator == null) throw new IllegalArgumentException("authenticator == null");
-    if (transports == null) throw new IllegalArgumentException("transports == null");
+    if (protocols == null) throw new IllegalArgumentException("protocols == null");
     this.proxy = proxy;
     this.uriHost = uriHost;
     this.uriPort = uriPort;
     this.sslSocketFactory = sslSocketFactory;
     this.hostnameVerifier = hostnameVerifier;
     this.authenticator = authenticator;
-    this.transports = Util.immutableList(transports);
+    this.protocols = Util.immutableList(protocols);
   }
 
   /** Returns the hostname of the origin server. */
@@ -97,11 +97,12 @@ public OkAuthenticator getAuthenticator() {
   }
 
   /**
-   * Returns the client's transports. This method always returns a non-null list
-   * that contains "http/1.1", possibly among other transports.
+   * Returns the protocols the client supports. This method always returns a
+   * non-null list that contains minimally
+   * {@link Protocol#HTTP_11}.
    */
-  public List<String> getTransports() {
-    return transports;
+  public List<Protocol> getProtocols() {
+    return protocols;
   }
 
   /**
@@ -121,7 +122,7 @@ public Proxy getProxy() {
           && equal(this.sslSocketFactory, that.sslSocketFactory)
           && equal(this.hostnameVerifier, that.hostnameVerifier)
           && equal(this.authenticator, that.authenticator)
-          && equal(this.transports, that.transports);
+          && equal(this.protocols, that.protocols);
     }
     return false;
   }
@@ -134,7 +135,7 @@ public Proxy getProxy() {
     result = 31 * result + (hostnameVerifier != null ? hostnameVerifier.hashCode() : 0);
     result = 31 * result + (authenticator != null ? authenticator.hashCode() : 0);
     result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
-    result = 31 * result + transports.hashCode();
+    result = 31 * result + protocols.hashCode();
     return result;
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java b/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
new file mode 100644
index 0000000000..dc944e4f60
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/CacheControl.java
@@ -0,0 +1,176 @@
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.http.HeaderParser;
+
+/**
+ * A Cache-Control header with cache directives from a server or client. These
+ * directives set policy on what responses can be stored, and which requests can
+ * be satisfied by those stored responses.
+ *
+ * <p>See <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">RFC
+ * 2616, 14.9</a>.
+ */
+public final class CacheControl {
+  private final boolean noCache;
+  private final boolean noStore;
+  private final int maxAgeSeconds;
+  private final int sMaxAgeSeconds;
+  private final boolean isPublic;
+  private final boolean mustRevalidate;
+  private final int maxStaleSeconds;
+  private final int minFreshSeconds;
+  private final boolean onlyIfCached;
+
+  private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
+      boolean isPublic, boolean mustRevalidate, int maxStaleSeconds, int minFreshSeconds,
+      boolean onlyIfCached) {
+    this.noCache = noCache;
+    this.noStore = noStore;
+    this.maxAgeSeconds = maxAgeSeconds;
+    this.sMaxAgeSeconds = sMaxAgeSeconds;
+    this.isPublic = isPublic;
+    this.mustRevalidate = mustRevalidate;
+    this.maxStaleSeconds = maxStaleSeconds;
+    this.minFreshSeconds = minFreshSeconds;
+    this.onlyIfCached = onlyIfCached;
+  }
+
+  /**
+   * In a response, this field's name "no-cache" is misleading. It doesn't
+   * prevent us from caching the response; it only means we have to validate the
+   * response with the origin server before returning it. We can do this with a
+   * conditional GET.
+   *
+   * <p>In a request, it means do not use a cache to satisfy the request.
+   */
+  public boolean noCache() {
+    return noCache;
+  }
+
+  /** If true, this response should not be cached. */
+  public boolean noStore() {
+    return noStore;
+  }
+
+  /**
+   * The duration past the response's served date that it can be served without
+   * validation.
+   */
+  public int maxAgeSeconds() {
+    return maxAgeSeconds;
+  }
+
+  /**
+   * The "s-maxage" directive is the max age for shared caches. Not to be
+   * confused with "max-age" for non-shared caches, As in Firefox and Chrome,
+   * this directive is not honored by this cache.
+   */
+  public int sMaxAgeSeconds() {
+    return sMaxAgeSeconds;
+  }
+
+  public boolean isPublic() {
+    return isPublic;
+  }
+
+  public boolean mustRevalidate() {
+    return mustRevalidate;
+  }
+
+  public int maxStaleSeconds() {
+    return maxStaleSeconds;
+  }
+
+  public int minFreshSeconds() {
+    return minFreshSeconds;
+  }
+
+  /**
+   * This field's name "only-if-cached" is misleading. It actually means "do
+   * not use the network". It is set by a client who only wants to make a
+   * request if it can be fully satisfied by the cache. Cached responses that
+   * would require validation (ie. conditional gets) are not permitted if this
+   * header is set.
+   */
+  public boolean onlyIfCached() {
+    return onlyIfCached;
+  }
+
+  /**
+   * Returns the cache directives of {@code headers}. This honors both
+   * Cache-Control and Pragma headers if they are present.
+   */
+  public static CacheControl parse(Headers headers) {
+    boolean noCache = false;
+    boolean noStore = false;
+    int maxAgeSeconds = -1;
+    int sMaxAgeSeconds = -1;
+    boolean isPublic = false;
+    boolean mustRevalidate = false;
+    int maxStaleSeconds = -1;
+    int minFreshSeconds = -1;
+    boolean onlyIfCached = false;
+
+    for (int i = 0; i < headers.size(); i++) {
+      if (!headers.name(i).equalsIgnoreCase("Cache-Control")
+          && !headers.name(i).equalsIgnoreCase("Pragma")) {
+        continue;
+      }
+
+      String string = headers.value(i);
+      int pos = 0;
+      while (pos < string.length()) {
+        int tokenStart = pos;
+        pos = HeaderParser.skipUntil(string, pos, "=,;");
+        String directive = string.substring(tokenStart, pos).trim();
+        String parameter;
+
+        if (pos == string.length() || string.charAt(pos) == ',' || string.charAt(pos) == ';') {
+          pos++; // consume ',' or ';' (if necessary)
+          parameter = null;
+        } else {
+          pos++; // consume '='
+          pos = HeaderParser.skipWhitespace(string, pos);
+
+          // quoted string
+          if (pos < string.length() && string.charAt(pos) == '\"') {
+            pos++; // consume '"' open quote
+            int parameterStart = pos;
+            pos = HeaderParser.skipUntil(string, pos, "\"");
+            parameter = string.substring(parameterStart, pos);
+            pos++; // consume '"' close quote (if necessary)
+
+            // unquoted string
+          } else {
+            int parameterStart = pos;
+            pos = HeaderParser.skipUntil(string, pos, ",;");
+            parameter = string.substring(parameterStart, pos).trim();
+          }
+        }
+
+        if ("no-cache".equalsIgnoreCase(directive)) {
+          noCache = true;
+        } else if ("no-store".equalsIgnoreCase(directive)) {
+          noStore = true;
+        } else if ("max-age".equalsIgnoreCase(directive)) {
+          maxAgeSeconds = HeaderParser.parseSeconds(parameter);
+        } else if ("s-maxage".equalsIgnoreCase(directive)) {
+          sMaxAgeSeconds = HeaderParser.parseSeconds(parameter);
+        } else if ("public".equalsIgnoreCase(directive)) {
+          isPublic = true;
+        } else if ("must-revalidate".equalsIgnoreCase(directive)) {
+          mustRevalidate = true;
+        } else if ("max-stale".equalsIgnoreCase(directive)) {
+          maxStaleSeconds = HeaderParser.parseSeconds(parameter);
+        } else if ("min-fresh".equalsIgnoreCase(directive)) {
+          minFreshSeconds = HeaderParser.parseSeconds(parameter);
+        } else if ("only-if-cached".equalsIgnoreCase(directive)) {
+          onlyIfCached = true;
+        }
+      }
+    }
+
+    return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPublic,
+        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index dd0a639e0a..88813c4593 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -16,11 +16,11 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpTransport;
-import com.squareup.okhttp.internal.http.RawHeaders;
 import com.squareup.okhttp.internal.http.SpdyTransport;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import java.io.BufferedInputStream;
@@ -32,8 +32,6 @@
 import java.net.Proxy;
 import java.net.Socket;
 import java.net.SocketTimeoutException;
-import java.net.URL;
-import java.util.Arrays;
 import javax.net.ssl.SSLSocket;
 
 import static java.net.HttpURLConnection.HTTP_OK;
@@ -66,16 +64,6 @@
  * should the attempt fail.
  */
 public final class Connection implements Closeable {
-  private static final byte[] NPN_PROTOCOLS = new byte[] {
-      6, 's', 'p', 'd', 'y', '/', '3',
-      8, 'h', 't', 't', 'p', '/', '1', '.', '1'
-  };
-  private static final byte[] SPDY3 = new byte[] {
-      's', 'p', 'd', 'y', '/', '3'
-  };
-  private static final byte[] HTTP_11 = new byte[] {
-      'h', 't', 't', 'p', '/', '1', '.', '1'
-  };
 
   private final Route route;
 
@@ -86,6 +74,7 @@
   private SpdyConnection spdyConnection;
   private int httpMinorVersion = 1; // Assume HTTP/1.1
   private long idleStartTimeNs;
+  private Handshake handshake;
   private long keepAliveDurationNs;
 
   public Connection(Route route) {
@@ -100,10 +89,8 @@ public Connection(Route route, long keepAliveDuration) {
 
   public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest)
       throws IOException {
-    if (connected) {
-      throw new IllegalStateException("already connected");
-    }
-    connected = true;
+    if (connected) throw new IllegalStateException("already connected");
+
     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();
     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);
     socket.setSoTimeout(readTimeout);
@@ -112,14 +99,10 @@ public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelReq
 
     if (route.address.sslSocketFactory != null) {
       upgradeToTls(tunnelRequest);
+    } else {
+      streamWrapper();
     }
-
-    // Use MTU-sized buffers to send fewer packets.
-    int mtu = Platform.get().getMtu(socket);
-    if (mtu < 1024) mtu = 1024;
-    if (mtu > 8192) mtu = 8192;
-    in = new BufferedInputStream(in, mtu);
-    out = new BufferedOutputStream(out, mtu);
+    connected = true;
   }
 
   /**
@@ -144,9 +127,20 @@ private void upgradeToTls(TunnelRequest tunnelRequest) throws IOException {
       platform.supportTlsIntolerantServer(sslSocket);
     }
 
-    boolean useNpn = route.modernTls && route.address.transports.contains("spdy/3");
+    boolean useNpn = route.modernTls && (// Contains a spdy variant.
+        route.address.protocols.contains(Protocol.HTTP_2)
+     || route.address.protocols.contains(Protocol.SPDY_3)
+    );
+
     if (useNpn) {
-      platform.setNpnProtocols(sslSocket, NPN_PROTOCOLS);
+      if (route.address.protocols.contains(Protocol.HTTP_2) // Contains both spdy variants.
+          && route.address.protocols.contains(Protocol.SPDY_3)) {
+        platform.setNpnProtocols(sslSocket, Protocol.HTTP2_SPDY3_AND_HTTP);
+      } else if (route.address.protocols.contains(Protocol.HTTP_2)) {
+        platform.setNpnProtocols(sslSocket, Protocol.HTTP2_AND_HTTP_11);
+      } else {
+        platform.setNpnProtocols(sslSocket, Protocol.SPDY3_AND_HTTP11);
+      }
     }
 
     // Force handshake. This can throw!
@@ -159,17 +153,17 @@ private void upgradeToTls(TunnelRequest tunnelRequest) throws IOException {
 
     out = sslSocket.getOutputStream();
     in = sslSocket.getInputStream();
+    handshake = Handshake.get(sslSocket.getSession());
+    streamWrapper();
 
-    byte[] selectedProtocol;
-    if (useNpn && (selectedProtocol = platform.getNpnSelectedProtocol(sslSocket)) != null) {
-      if (Arrays.equals(selectedProtocol, SPDY3)) {
+    ByteString maybeProtocol;
+    if (useNpn && (maybeProtocol = platform.getNpnSelectedProtocol(sslSocket)) != null) {
+      Protocol selectedProtocol = Protocol.find(maybeProtocol); // Throws IOE on unknown.
+      if (selectedProtocol.spdyVariant) {
         sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
         spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, in, out)
-            .build();
+            .protocol(selectedProtocol).build();
         spdyConnection.sendConnectionHeader();
-      } else if (!Arrays.equals(selectedProtocol, HTTP_11)) {
-        throw new IOException(
-            "Unexpected NPN transport " + new String(selectedProtocol, "ISO-8859-1"));
       }
     }
   }
@@ -235,9 +229,7 @@ public boolean isReadable() {
   }
 
   public void resetIdleStartTime() {
-    if (spdyConnection != null) {
-      throw new IllegalStateException("spdyConnection != null");
-    }
+    if (spdyConnection != null) throw new IllegalStateException("spdyConnection != null");
     this.idleStartTimeNs = System.nanoTime();
   }
 
@@ -266,6 +258,10 @@ public long getIdleStartTimeNs() {
     return spdyConnection == null ? idleStartTimeNs : spdyConnection.getIdleStartTimeNs();
   }
 
+  public Handshake getHandshake() {
+    return handshake;
+  }
+
   /** Returns the transport appropriate for this connection. */
   public Object newTransport(HttpEngine httpEngine) throws IOException {
     return (spdyConnection != null)
@@ -281,10 +277,6 @@ public boolean isSpdy() {
     return spdyConnection != null;
   }
 
-  public SpdyConnection getSpdyConnection() {
-    return spdyConnection;
-  }
-
   /**
    * Returns the minor HTTP version that should be used for future requests on
    * this connection. Either 0 for HTTP/1.0, or 1 for HTTP/1.1. The default
@@ -318,29 +310,29 @@ public void updateReadTimeout(int newTimeout) throws IOException {
    * retried if the proxy requires authorization.
    */
   private void makeTunnel(TunnelRequest tunnelRequest) throws IOException {
-    RawHeaders requestHeaders = tunnelRequest.getRequestHeaders();
+    Request request = tunnelRequest.getRequest();
+    String requestLine = tunnelRequest.requestLine();
     while (true) {
-      out.write(requestHeaders.toBytes());
-      RawHeaders responseHeaders = RawHeaders.fromBytes(in);
+      HttpTransport.writeRequest(out, request.headers(), requestLine);
+      Response response = HttpTransport.readResponse(in).request(request).build();
 
-      switch (responseHeaders.getResponseCode()) {
+      switch (response.code()) {
         case HTTP_OK:
           return;
         case HTTP_PROXY_AUTH:
-          requestHeaders = new RawHeaders(requestHeaders);
-          URL url = new URL("https", tunnelRequest.host, tunnelRequest.port, "/");
-          boolean credentialsFound = HttpAuthenticator.processAuthHeader(
-              route.address.authenticator, HTTP_PROXY_AUTH, responseHeaders, requestHeaders,
-              route.proxy, url);
-          if (credentialsFound) {
-            continue;
-          } else {
-            throw new IOException("Failed to authenticate with proxy");
-          }
+          request = HttpAuthenticator.processAuthHeader(
+              route.address.authenticator, response, route.proxy);
+          if (request != null) continue;
+          throw new IOException("Failed to authenticate with proxy");
         default:
           throw new IOException(
-              "Unexpected response code for CONNECT: " + responseHeaders.getResponseCode());
+              "Unexpected response code for CONNECT: " + response.code());
       }
     }
   }
+
+  private void streamWrapper() throws IOException {
+    in = new BufferedInputStream(in, 4096);
+    out = new BufferedOutputStream(out, 256);
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index 05a1eea3ac..c8cadd6086 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -23,7 +23,6 @@
 import java.util.LinkedList;
 import java.util.List;
 import java.util.ListIterator;
-import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
@@ -82,9 +81,9 @@
   /** We use a single background thread to cleanup expired connections. */
   private final ExecutorService executorService = new ThreadPoolExecutor(0, 1,
       60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),
-      Util.daemonThreadFactory("OkHttp ConnectionPool"));
-  private final Callable<Void> connectionsCleanupCallable = new Callable<Void>() {
-    @Override public Void call() throws Exception {
+      Util.threadFactory("OkHttp ConnectionPool", true));
+  private final Runnable connectionsCleanupRunnable = new Runnable() {
+    @Override public void run() {
       List<Connection> expiredConnections = new ArrayList<Connection>(MAX_CONNECTIONS_TO_CLEANUP);
       int idleConnectionCount = 0;
       synchronized (ConnectionPool.this) {
@@ -113,7 +112,6 @@
       for (Connection expiredConnection : expiredConnections) {
         Util.closeQuietly(expiredConnection);
       }
-      return null;
     }
   };
 
@@ -209,7 +207,7 @@ public synchronized Connection get(Address address) {
       connections.addFirst(foundConnection); // Add it back after iteration.
     }
 
-    executorService.submit(connectionsCleanupCallable);
+    executorService.execute(connectionsCleanupRunnable);
     return foundConnection;
   }
 
@@ -243,7 +241,7 @@ public void recycle(Connection connection) {
       connection.resetIdleStartTime();
     }
 
-    executorService.submit(connectionsCleanupCallable);
+    executorService.execute(connectionsCleanupRunnable);
   }
 
   /**
@@ -251,7 +249,7 @@ public void recycle(Connection connection) {
    * continue to use {@code connection}.
    */
   public void maybeShare(Connection connection) {
-    executorService.submit(connectionsCleanupCallable);
+    executorService.execute(connectionsCleanupRunnable);
     if (!connection.isSpdy()) {
       // Only SPDY connections are sharable.
       return;
@@ -271,8 +269,8 @@ public void evictAll() {
       this.connections.clear();
     }
 
-    for (Connection connection : connections) {
-      Util.closeQuietly(connection);
+    for (int i = 0, size = connections.size(); i < size; i++) {
+      Util.closeQuietly(connections.get(i));
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index 6a6c273ad6..198fd4ea80 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -15,67 +15,147 @@
  */
 package com.squareup.okhttp;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
+import com.squareup.okhttp.internal.Util;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.concurrent.Executor;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
-final class Dispatcher {
-  // TODO: thread pool size should be configurable; possibly configurable per host.
-  private final ThreadPoolExecutor executorService = new ThreadPoolExecutor(
-      8, 8, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
-  private final Map<Object, List<Job>> enqueuedJobs = new LinkedHashMap<Object, List<Job>>();
-
-  public synchronized void enqueue(
-      HttpURLConnection connection, Request request, Response.Receiver responseReceiver) {
-    Job job = new Job(this, connection, request, responseReceiver);
-    List<Job> jobsForTag = enqueuedJobs.get(request.tag());
-    if (jobsForTag == null) {
-      jobsForTag = new ArrayList<Job>(2);
-      enqueuedJobs.put(request.tag(), jobsForTag);
+/**
+ * Policy on when async requests are executed.
+ *
+ * <p>Each dispatcher uses an {@link Executor} to run jobs internally. If you
+ * supply your own executor, it should be able to run {@link #getMaxRequests the
+ * configured maximum} number of jobs concurrently.
+ */
+public final class Dispatcher {
+  private int maxRequests = 64;
+  private int maxRequestsPerHost = 5;
+
+  /** Executes jobs. Created lazily. */
+  private Executor executor;
+
+  /** Ready jobs in the order they'll be run. */
+  private final Deque<Job> readyJobs = new ArrayDeque<Job>();
+
+  /** Running jobs. Includes canceled jobs that haven't finished yet. */
+  private final Deque<Job> runningJobs = new ArrayDeque<Job>();
+
+  public Dispatcher(Executor executor) {
+    this.executor = executor;
+  }
+
+  public Dispatcher() {
+  }
+
+  public synchronized Executor getExecutor() {
+    if (executor == null) {
+      executor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
+          new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
     }
-    jobsForTag.add(job);
-    executorService.execute(job);
+    return executor;
   }
 
-  public synchronized void cancel(Object tag) {
-    List<Job> jobs = enqueuedJobs.remove(tag);
-    if (jobs == null) return;
-    for (Job job : jobs) {
-      executorService.remove(job);
+  /**
+   * Set the maximum number of requests to execute concurrently. Above this
+   * requests queue in memory, waiting for the running jobs to complete.
+   *
+   * <p>If more than {@code maxRequests} requests are in flight when this is
+   * invoked, those requests will remain in flight.
+   */
+  public synchronized void setMaxRequests(int maxRequests) {
+    if (maxRequests < 1) {
+      throw new IllegalArgumentException("max < 1: " + maxRequests);
     }
+    this.maxRequests = maxRequests;
+    promoteJobs();
   }
 
-  synchronized void finished(Job job) {
-    List<Job> jobs = enqueuedJobs.get(job.request.tag());
-    if (jobs != null) jobs.remove(job);
+  public synchronized int getMaxRequests() {
+    return maxRequests;
   }
 
-  static class RealResponseBody extends Response.Body {
-    private final HttpURLConnection connection;
-    private final InputStream in;
+  /**
+   * Set the maximum number of requests for each host to execute concurrently.
+   * This limits requests by the URL's host name. Note that concurrent requests
+   * to a single IP address may still exceed this limit: multiple hostnames may
+   * share an IP address or be routed through the same HTTP proxy.
+   *
+   * <p>If more than {@code maxRequestsPerHost} requests are in flight when this
+   * is invoked, those requests will remain in flight.
+   */
+  public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
+    if (maxRequestsPerHost < 1) {
+      throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
+    }
+    this.maxRequestsPerHost = maxRequestsPerHost;
+    promoteJobs();
+  }
 
-    RealResponseBody(HttpURLConnection connection, InputStream in) {
-      this.connection = connection;
-      this.in = in;
+  public synchronized int getMaxRequestsPerHost() {
+    return maxRequestsPerHost;
+  }
+
+  synchronized void enqueue(OkHttpClient client, Request request, Response.Receiver receiver) {
+    // Copy the client. Otherwise changes (socket factory, redirect policy,
+    // etc.) may incorrectly be reflected in the request when it is executed.
+    client = client.copyWithDefaults();
+    Job job = new Job(this, client, request, receiver);
+
+    if (runningJobs.size() < maxRequests && runningJobsForHost(job) < maxRequestsPerHost) {
+      runningJobs.add(job);
+      getExecutor().execute(job);
+    } else {
+      readyJobs.add(job);
     }
+  }
 
-    @Override public String contentType() {
-      return connection.getHeaderField("Content-Type");
+  /**
+   * Cancel all jobs with the tag {@code tag}. If a canceled job is running it
+   * may continue running until it reaches a safe point to finish.
+   */
+  public synchronized void cancel(Object tag) {
+    for (Iterator<Job> i = readyJobs.iterator(); i.hasNext(); ) {
+      if (Util.equal(tag, i.next().tag())) i.remove();
     }
 
-    @Override public long contentLength() {
-      return connection.getContentLength(); // TODO: getContentLengthLong
+    for (Job job : runningJobs) {
+      if (Util.equal(tag, job.tag())) job.canceled = true;
+    }
+  }
+
+  /** Used by {@code Job#run} to signal completion. */
+  synchronized void finished(Job job) {
+    if (!runningJobs.remove(job)) throw new AssertionError("Job wasn't running!");
+    promoteJobs();
+  }
+
+  private void promoteJobs() {
+    if (runningJobs.size() >= maxRequests) return; // Already running max capacity.
+    if (readyJobs.isEmpty()) return; // No ready jobs to promote.
+
+    for (Iterator<Job> i = readyJobs.iterator(); i.hasNext(); ) {
+      Job job = i.next();
+
+      if (runningJobsForHost(job) < maxRequestsPerHost) {
+        i.remove();
+        runningJobs.add(job);
+        getExecutor().execute(job);
+      }
+
+      if (runningJobs.size() >= maxRequests) return; // Reached max capacity.
     }
+  }
 
-    @Override public InputStream byteStream() throws IOException {
-      return in;
+  /** Returns the number of running jobs that share a host with {@code job}. */
+  private int runningJobsForHost(Job job) {
+    int result = 0;
+    for (Job j : runningJobs) {
+      if (j.host().equals(job.host())) result++;
     }
+    return result;
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Failure.java b/okhttp/src/main/java/com/squareup/okhttp/Failure.java
index a3547003a5..51ee2eae34 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Failure.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Failure.java
@@ -17,11 +17,8 @@
 
 /**
  * A failure attempting to retrieve an HTTP response.
- *
- * <h3>Warning: Experimental OkHttp 2.0 API</h3>
- * This class is in beta. APIs are subject to change!
  */
-/* OkHttp 2.0: public */ class Failure {
+public final class Failure {
   private final Request request;
   private final Throwable exception;
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Handshake.java b/okhttp/src/main/java/com/squareup/okhttp/Handshake.java
new file mode 100644
index 0000000000..d9f5366757
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Handshake.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.Collections;
+import java.util.List;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+
+/**
+ * A record of a TLS handshake. For HTTPS clients, the client is <i>local</i>
+ * and the remote server is its <i>peer</i>.
+ *
+ * <p>This value object describes a completed handshake. Use {@link
+ * javax.net.ssl.SSLSocketFactory} to set policy for new handshakes.
+ */
+public final class Handshake {
+  private final String cipherSuite;
+  private final List<Certificate> peerCertificates;
+  private final List<Certificate> localCertificates;
+
+  private Handshake(
+      String cipherSuite, List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+    this.cipherSuite = cipherSuite;
+    this.peerCertificates = peerCertificates;
+    this.localCertificates = localCertificates;
+  }
+
+  public static Handshake get(SSLSession session) {
+    String cipherSuite = session.getCipherSuite();
+    if (cipherSuite == null) throw new IllegalStateException("cipherSuite == null");
+
+    Certificate[] peerCertificates;
+    try {
+      peerCertificates = session.getPeerCertificates();
+    } catch (SSLPeerUnverifiedException ignored) {
+      peerCertificates = null;
+    }
+    List<Certificate> peerCertificatesList = peerCertificates != null
+        ? Util.immutableList(peerCertificates)
+        : Collections.<Certificate>emptyList();
+
+    Certificate[] localCertificates = session.getLocalCertificates();
+    List<Certificate> localCertificatesList = localCertificates != null
+        ? Util.immutableList(localCertificates)
+        : Collections.<Certificate>emptyList();
+
+    return new Handshake(cipherSuite, peerCertificatesList, localCertificatesList);
+  }
+
+  public static Handshake get(
+      String cipherSuite, List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+    if (cipherSuite == null) throw new IllegalArgumentException("cipherSuite == null");
+    return new Handshake(cipherSuite, Util.immutableList(peerCertificates),
+        Util.immutableList(localCertificates));
+  }
+
+  /** Returns a cipher suite name like "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA". */
+  public String cipherSuite() {
+    return cipherSuite;
+  }
+
+  /** Returns a possibly-empty list of certificates that identify the remote peer. */
+  public List<Certificate> peerCertificates() {
+    return peerCertificates;
+  }
+
+  /** Returns the remote peer's principle, or null if that peer is anonymous. */
+  public Principal peerPrincipal() {
+    return !peerCertificates.isEmpty()
+        ? ((X509Certificate) peerCertificates.get(0)).getSubjectX500Principal()
+        : null;
+  }
+
+  /** Returns a possibly-empty list of certificates that identify this peer. */
+  public List<Certificate> localCertificates() {
+    return localCertificates;
+  }
+
+  /** Returns the local principle, or null if this peer is anonymous. */
+  public Principal localPrincipal() {
+    return !localCertificates.isEmpty()
+        ? ((X509Certificate) localCertificates.get(0)).getSubjectX500Principal()
+        : null;
+  }
+
+  @Override public boolean equals(Object other) {
+    if (!(other instanceof Handshake)) return false;
+    Handshake that = (Handshake) other;
+    return cipherSuite.equals(that.cipherSuite)
+        && peerCertificates.equals(that.peerCertificates)
+        && localCertificates.equals(that.localCertificates);
+  }
+
+  @Override public int hashCode() {
+    int result = 17;
+    result = 31 * result + cipherSuite.hashCode();
+    result = 31 * result + peerCertificates.hashCode();
+    result = 31 * result + localCertificates.hashCode();
+    return result;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Headers.java b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
new file mode 100644
index 0000000000..1221aa4e09
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
@@ -0,0 +1,210 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.squareup.okhttp;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeSet;
+
+/**
+ * The header fields of a single HTTP message. Values are uninterpreted strings;
+ * use {@code Request} and {@code Response} for interpreted headers. This class
+ * maintains the order of the header fields within the HTTP message.
+ *
+ * <p>This class tracks header values line-by-line. A field with multiple comma-
+ * separated values on the same line will be treated as a field with a single
+ * value by this class. It is the caller's responsibility to detect and split
+ * on commas if their field permits multiple values. This simplifies use of
+ * single-valued fields whose values routinely contain commas, such as cookies
+ * or dates.
+ *
+ * <p>This class trims whitespace from values. It never returns values with
+ * leading or trailing whitespace.
+ *
+ * <p>Instances of this class are immutable. Use {@link Builder} to create
+ * instances.
+ */
+public final class Headers {
+  private final String[] namesAndValues;
+
+  private Headers(Builder builder) {
+    this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
+  }
+
+  /** Returns the last value corresponding to the specified field, or null. */
+  public String get(String fieldName) {
+    return get(namesAndValues, fieldName);
+  }
+
+  /** Returns the number of field values. */
+  public int size() {
+    return namesAndValues.length / 2;
+  }
+
+  /** Returns the field at {@code position} or null if that is out of range. */
+  public String name(int index) {
+    int fieldNameIndex = index * 2;
+    if (fieldNameIndex < 0 || fieldNameIndex >= namesAndValues.length) {
+      return null;
+    }
+    return namesAndValues[fieldNameIndex];
+  }
+
+  /** Returns the value at {@code index} or null if that is out of range. */
+  public String value(int index) {
+    int valueIndex = index * 2 + 1;
+    if (valueIndex < 0 || valueIndex >= namesAndValues.length) {
+      return null;
+    }
+    return namesAndValues[valueIndex];
+  }
+
+  /** Returns an immutable case-insensitive set of header names. */
+  public Set<String> names() {
+    TreeSet<String> result = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
+    for (int i = 0; i < size(); i++) {
+      result.add(name(i));
+    }
+    return Collections.unmodifiableSet(result);
+  }
+
+  /** Returns an immutable list of the header values for {@code name}. */
+  public List<String> values(String name) {
+    List<String> result = null;
+    for (int i = 0; i < size(); i++) {
+      if (name.equalsIgnoreCase(name(i))) {
+        if (result == null) result = new ArrayList<String>(2);
+        result.add(value(i));
+      }
+    }
+    return result != null
+        ? Collections.unmodifiableList(result)
+        : Collections.<String>emptyList();
+  }
+
+  /** @param fieldNames a case-insensitive set of HTTP header field names. */
+  // TODO: it is very weird to request a case-insensitive set as a parameter.
+  public Headers getAll(Set<String> fieldNames) {
+    Builder result = new Builder();
+    for (int i = 0; i < namesAndValues.length; i += 2) {
+      String fieldName = namesAndValues[i];
+      if (fieldNames.contains(fieldName)) {
+        result.add(fieldName, namesAndValues[i + 1]);
+      }
+    }
+    return result.build();
+  }
+
+  public Builder newBuilder() {
+    Builder result = new Builder();
+    result.namesAndValues.addAll(Arrays.asList(namesAndValues));
+    return result;
+  }
+
+  @Override public String toString() {
+    StringBuilder result = new StringBuilder();
+    for (int i = 0; i < size(); i++) {
+      result.append(name(i)).append(": ").append(value(i)).append("\n");
+    }
+    return result.toString();
+  }
+
+  private static String get(String[] namesAndValues, String fieldName) {
+    for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
+      if (fieldName.equalsIgnoreCase(namesAndValues[i])) {
+        return namesAndValues[i + 1];
+      }
+    }
+    return null;
+  }
+
+  public static class Builder {
+    private final List<String> namesAndValues = new ArrayList<String>(20);
+
+    /** Add an header line containing a field name, a literal colon, and a value. */
+    public Builder addLine(String line) {
+      int index = line.indexOf(":", 1);
+      if (index != -1) {
+        return addLenient(line.substring(0, index), line.substring(index + 1));
+      } else if (line.startsWith(":")) {
+        // Work around empty header names and header names that start with a
+        // colon (created by old broken SPDY versions of the response cache).
+        return addLenient("", line.substring(1)); // Empty header name.
+      } else {
+        return addLenient("", line); // No header name.
+      }
+    }
+
+    /** Add a field with the specified value. */
+    public Builder add(String fieldName, String value) {
+      if (fieldName == null) throw new IllegalArgumentException("fieldname == null");
+      if (value == null) throw new IllegalArgumentException("value == null");
+      if (fieldName.length() == 0 || fieldName.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+        throw new IllegalArgumentException("Unexpected header: " + fieldName + ": " + value);
+      }
+      return addLenient(fieldName, value);
+    }
+
+    /**
+     * Add a field with the specified value without any validation. Only
+     * appropriate for headers from the remote peer.
+     */
+    private Builder addLenient(String fieldName, String value) {
+      namesAndValues.add(fieldName);
+      namesAndValues.add(value.trim());
+      return this;
+    }
+
+    public Builder removeAll(String fieldName) {
+      for (int i = 0; i < namesAndValues.size(); i += 2) {
+        if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
+          namesAndValues.remove(i); // field name
+          namesAndValues.remove(i); // value
+        }
+      }
+      return this;
+    }
+
+    /**
+     * Set a field with the specified value. If the field is not found, it is
+     * added. If the field is found, the existing values are replaced.
+     */
+    public Builder set(String fieldName, String value) {
+      removeAll(fieldName);
+      add(fieldName, value);
+      return this;
+    }
+
+    /** Equivalent to {@code build().get(fieldName)}, but potentially faster. */
+    public String get(String fieldName) {
+      for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
+        if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
+          return namesAndValues.get(i + 1);
+        }
+      }
+      return null;
+    }
+
+    public Headers build() {
+      return new Headers(this);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java b/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
index 8210318276..db8809ebe0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
@@ -20,12 +20,6 @@
 import com.squareup.okhttp.internal.DiskLruCache;
 import com.squareup.okhttp.internal.StrictLineReader;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.HttpEngine;
-import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
-import com.squareup.okhttp.internal.http.HttpsEngine;
-import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
-import com.squareup.okhttp.internal.http.RawHeaders;
-import com.squareup.okhttp.internal.http.ResponseHeaders;
 import java.io.BufferedWriter;
 import java.io.ByteArrayInputStream;
 import java.io.File;
@@ -38,22 +32,17 @@
 import java.io.Writer;
 import java.net.CacheRequest;
 import java.net.CacheResponse;
-import java.net.HttpURLConnection;
 import java.net.ResponseCache;
-import java.net.SecureCacheResponse;
 import java.net.URI;
 import java.net.URLConnection;
-import java.security.Principal;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateEncodingException;
 import java.security.cert.CertificateException;
 import java.security.cert.CertificateFactory;
-import java.security.cert.X509Certificate;
-import java.util.Arrays;
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocket;
 
 import static com.squareup.okhttp.internal.Util.US_ASCII;
 import static com.squareup.okhttp.internal.Util.UTF_8;
@@ -115,7 +104,7 @@
  *         connection.addRequestProperty("Cache-Control", "max-stale=" + maxStale);
  * }</pre>
  */
-public final class HttpResponseCache extends ResponseCache {
+public final class HttpResponseCache extends ResponseCache implements OkResponseCache {
   // TODO: add APIs to iterate the cache?
   private static final int VERSION = 201105;
   private static final int ENTRY_METADATA = 0;
@@ -131,51 +120,25 @@
   private int hitCount;
   private int requestCount;
 
-  /**
-   * Although this class only exposes the limited ResponseCache API, it
-   * implements the full OkResponseCache interface. This field is used as a
-   * package private handle to the complete implementation. It delegates to
-   * public and private members of this type.
-   */
-  final OkResponseCache okResponseCache = new OkResponseCache() {
-    @Override public CacheResponse get(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) throws IOException {
-      return HttpResponseCache.this.get(uri, requestMethod, requestHeaders);
-    }
-
-    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-      return HttpResponseCache.this.put(uri, connection);
-    }
-
-    @Override public void maybeRemove(String requestMethod, URI uri) throws IOException {
-      HttpResponseCache.this.maybeRemove(requestMethod, uri);
-    }
-
-    @Override public void update(
-        CacheResponse conditionalCacheHit, HttpURLConnection connection) throws IOException {
-      HttpResponseCache.this.update(conditionalCacheHit, connection);
-    }
-
-    @Override public void trackConditionalCacheHit() {
-      HttpResponseCache.this.trackConditionalCacheHit();
-    }
-
-    @Override public void trackResponse(ResponseSource source) {
-      HttpResponseCache.this.trackResponse(source);
-    }
-  };
-
   public HttpResponseCache(File directory, long maxSize) throws IOException {
     cache = DiskLruCache.open(directory, VERSION, ENTRY_COUNT, maxSize);
   }
 
-  private String uriToKey(URI uri) {
-    return Util.hash(uri.toString());
+  @Override public CacheResponse get(URI uri, String s, Map<String, List<String>> stringListMap)
+      throws IOException {
+    throw new UnsupportedOperationException("This is not a general purpose response cache.");
   }
 
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) {
-    String key = uriToKey(uri);
+  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+    throw new UnsupportedOperationException("This is not a general purpose response cache.");
+  }
+
+  private static String urlToKey(Request requst) {
+    return Util.hash(requst.urlString());
+  }
+
+  @Override public Response get(Request request) {
+    String key = urlToKey(request);
     DiskLruCache.Snapshot snapshot;
     Entry entry;
     try {
@@ -189,24 +152,20 @@ private String uriToKey(URI uri) {
       return null;
     }
 
-    if (!entry.matches(uri, requestMethod, requestHeaders)) {
-      snapshot.close();
+    Response response = entry.response(request, snapshot);
+
+    if (!entry.matches(request, response)) {
+      Util.closeQuietly(response.body());
       return null;
     }
 
-    return entry.isHttps() ? new EntrySecureCacheResponse(entry, snapshot)
-        : new EntryCacheResponse(entry, snapshot);
+    return response;
   }
 
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    if (!(urlConnection instanceof HttpURLConnection)) {
-      return null;
-    }
+  @Override public CacheRequest put(Response response) throws IOException {
+    String requestMethod = response.request().method();
 
-    HttpURLConnection httpConnection = (HttpURLConnection) urlConnection;
-    String requestMethod = httpConnection.getRequestMethod();
-
-    if (maybeRemove(requestMethod, uri)) {
+    if (maybeRemove(response.request())) {
       return null;
     }
     if (!requestMethod.equals("GET")) {
@@ -216,23 +175,14 @@ private String uriToKey(URI uri) {
       return null;
     }
 
-    HttpEngine httpEngine = getHttpEngine(httpConnection);
-    if (httpEngine == null) {
-      // Don't cache unless the HTTP implementation is ours.
-      return null;
-    }
-
-    ResponseHeaders response = httpEngine.getResponseHeaders();
     if (response.hasVaryAll()) {
       return null;
     }
 
-    RawHeaders varyHeaders =
-        httpEngine.getRequestHeaders().getHeaders().getAll(response.getVaryFields());
-    Entry entry = new Entry(uri, varyHeaders, httpConnection);
+    Entry entry = new Entry(response);
     DiskLruCache.Editor editor = null;
     try {
-      editor = cache.edit(uriToKey(uri));
+      editor = cache.edit(urlToKey(response.request()));
       if (editor == null) {
         return null;
       }
@@ -244,15 +194,11 @@ private String uriToKey(URI uri) {
     }
   }
 
-  /**
-   * Returns true if the supplied {@code requestMethod} potentially invalidates an entry in the
-   * cache.
-   */
-  private boolean maybeRemove(String requestMethod, URI uri) {
-    if (requestMethod.equals("POST") || requestMethod.equals("PUT") || requestMethod.equals(
-        "DELETE")) {
+  @Override public boolean maybeRemove(Request request) {
+    String method = request.method();
+    if (method.equals("POST") || method.equals("PUT") || method.equals("DELETE")) {
       try {
-        cache.remove(uriToKey(uri));
+        cache.remove(urlToKey(request));
       } catch (IOException ignored) {
         // The cache cannot be written.
       }
@@ -261,20 +207,12 @@ private boolean maybeRemove(String requestMethod, URI uri) {
     return false;
   }
 
-  private void update(CacheResponse conditionalCacheHit, HttpURLConnection httpConnection)
-      throws IOException {
-    HttpEngine httpEngine = getHttpEngine(httpConnection);
-    URI uri = httpEngine.getUri();
-    ResponseHeaders response = httpEngine.getResponseHeaders();
-    RawHeaders varyHeaders =
-        httpEngine.getRequestHeaders().getHeaders().getAll(response.getVaryFields());
-    Entry entry = new Entry(uri, varyHeaders, httpConnection);
-    DiskLruCache.Snapshot snapshot = (conditionalCacheHit instanceof EntryCacheResponse)
-        ? ((EntryCacheResponse) conditionalCacheHit).snapshot
-        : ((EntrySecureCacheResponse) conditionalCacheHit).snapshot;
+  @Override public void update(Response cached, Response network) {
+    Entry entry = new Entry(network);
+    DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
     DiskLruCache.Editor editor = null;
     try {
-      editor = snapshot.edit(); // returns null if snapshot is not current
+      editor = snapshot.edit(); // Returns null if snapshot is not current.
       if (editor != null) {
         entry.writeTo(editor);
         editor.commit();
@@ -294,16 +232,6 @@ private void abortQuietly(DiskLruCache.Editor editor) {
     }
   }
 
-  private HttpEngine getHttpEngine(URLConnection httpConnection) {
-    if (httpConnection instanceof HttpURLConnectionImpl) {
-      return ((HttpURLConnectionImpl) httpConnection).getHttpEngine();
-    } else if (httpConnection instanceof HttpsURLConnectionImpl) {
-      return ((HttpsURLConnectionImpl) httpConnection).getHttpEngine();
-    } else {
-      return null;
-    }
-  }
-
   /**
    * Closes the cache and deletes all of its stored values. This will delete
    * all files in the cache directory including files that weren't created by
@@ -345,7 +273,7 @@ public boolean isClosed() {
     return cache.isClosed();
   }
 
-  private synchronized void trackResponse(ResponseSource source) {
+  @Override public synchronized void trackResponse(ResponseSource source) {
     requestCount++;
 
     switch (source) {
@@ -359,7 +287,7 @@ private synchronized void trackResponse(ResponseSource source) {
     }
   }
 
-  private synchronized void trackConditionalCacheHit() {
+  @Override public synchronized void trackConditionalCacheHit() {
     hitCount++;
   }
 
@@ -426,13 +354,12 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
   }
 
   private static final class Entry {
-    private final String uri;
-    private final RawHeaders varyHeaders;
+    private final String url;
+    private final Headers varyHeaders;
     private final String requestMethod;
-    private final RawHeaders responseHeaders;
-    private final String cipherSuite;
-    private final Certificate[] peerCertificates;
-    private final Certificate[] localCertificates;
+    private final String statusLine;
+    private final Headers responseHeaders;
+    private final Handshake handshake;
 
     /**
      * Reads an entry from an input stream. A typical entry looks like this:
@@ -486,121 +413,90 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
     public Entry(InputStream in) throws IOException {
       try {
         StrictLineReader reader = new StrictLineReader(in, US_ASCII);
-        uri = reader.readLine();
+        url = reader.readLine();
         requestMethod = reader.readLine();
-        varyHeaders = new RawHeaders();
+        Headers.Builder varyHeadersBuilder = new Headers.Builder();
         int varyRequestHeaderLineCount = reader.readInt();
         for (int i = 0; i < varyRequestHeaderLineCount; i++) {
-          varyHeaders.addLine(reader.readLine());
+          varyHeadersBuilder.addLine(reader.readLine());
         }
+        varyHeaders = varyHeadersBuilder.build();
 
-        responseHeaders = new RawHeaders();
-        responseHeaders.setStatusLine(reader.readLine());
+        statusLine = reader.readLine();
+        Headers.Builder responseHeadersBuilder = new Headers.Builder();
         int responseHeaderLineCount = reader.readInt();
         for (int i = 0; i < responseHeaderLineCount; i++) {
-          responseHeaders.addLine(reader.readLine());
+          responseHeadersBuilder.addLine(reader.readLine());
         }
+        responseHeaders = responseHeadersBuilder.build();
 
         if (isHttps()) {
           String blank = reader.readLine();
           if (blank.length() > 0) {
             throw new IOException("expected \"\" but was \"" + blank + "\"");
           }
-          cipherSuite = reader.readLine();
-          peerCertificates = readCertArray(reader);
-          localCertificates = readCertArray(reader);
+          String cipherSuite = reader.readLine();
+          List<Certificate> peerCertificates = readCertificateList(reader);
+          List<Certificate> localCertificates = readCertificateList(reader);
+          handshake = Handshake.get(cipherSuite, peerCertificates, localCertificates);
         } else {
-          cipherSuite = null;
-          peerCertificates = null;
-          localCertificates = null;
+          handshake = null;
         }
       } finally {
         in.close();
       }
     }
 
-    public Entry(URI uri, RawHeaders varyHeaders, HttpURLConnection httpConnection)
-        throws IOException {
-      this.uri = uri.toString();
-      this.varyHeaders = varyHeaders;
-      this.requestMethod = httpConnection.getRequestMethod();
-      this.responseHeaders = RawHeaders.fromMultimap(httpConnection.getHeaderFields(), true);
-
-      SSLSocket sslSocket = getSslSocket(httpConnection);
-      if (sslSocket != null) {
-        cipherSuite = sslSocket.getSession().getCipherSuite();
-        Certificate[] peerCertificatesNonFinal = null;
-        try {
-          peerCertificatesNonFinal = sslSocket.getSession().getPeerCertificates();
-        } catch (SSLPeerUnverifiedException ignored) {
-        }
-        peerCertificates = peerCertificatesNonFinal;
-        localCertificates = sslSocket.getSession().getLocalCertificates();
-      } else {
-        cipherSuite = null;
-        peerCertificates = null;
-        localCertificates = null;
-      }
-    }
-
-    /**
-     * Returns the SSL socket used by {@code httpConnection} for HTTPS, nor null
-     * if the connection isn't using HTTPS. Since we permit redirects across
-     * protocols (HTTP to HTTPS or vice versa), the implementation type of the
-     * connection doesn't necessarily match the implementation type of its HTTP
-     * engine.
-     */
-    private SSLSocket getSslSocket(HttpURLConnection httpConnection) {
-      HttpEngine engine = httpConnection instanceof HttpsURLConnectionImpl
-          ? ((HttpsURLConnectionImpl) httpConnection).getHttpEngine()
-          : ((HttpURLConnectionImpl) httpConnection).getHttpEngine();
-      return engine instanceof HttpsEngine
-          ? ((HttpsEngine) engine).getSslSocket()
-          : null;
+    public Entry(Response response) {
+      this.url = response.request().urlString();
+      this.varyHeaders = response.request().headers().getAll(response.getVaryFields());
+      this.requestMethod = response.request().method();
+      this.statusLine = response.statusLine();
+      this.responseHeaders = response.headers();
+      this.handshake = response.handshake();
     }
 
     public void writeTo(DiskLruCache.Editor editor) throws IOException {
       OutputStream out = editor.newOutputStream(ENTRY_METADATA);
       Writer writer = new BufferedWriter(new OutputStreamWriter(out, UTF_8));
 
-      writer.write(uri + '\n');
+      writer.write(url + '\n');
       writer.write(requestMethod + '\n');
-      writer.write(Integer.toString(varyHeaders.length()) + '\n');
-      for (int i = 0; i < varyHeaders.length(); i++) {
-        writer.write(varyHeaders.getFieldName(i) + ": " + varyHeaders.getValue(i) + '\n');
+      writer.write(Integer.toString(varyHeaders.size()) + '\n');
+      for (int i = 0; i < varyHeaders.size(); i++) {
+        writer.write(varyHeaders.name(i) + ": " + varyHeaders.value(i) + '\n');
       }
 
-      writer.write(responseHeaders.getStatusLine() + '\n');
-      writer.write(Integer.toString(responseHeaders.length()) + '\n');
-      for (int i = 0; i < responseHeaders.length(); i++) {
-        writer.write(responseHeaders.getFieldName(i) + ": " + responseHeaders.getValue(i) + '\n');
+      writer.write(statusLine + '\n');
+      writer.write(Integer.toString(responseHeaders.size()) + '\n');
+      for (int i = 0; i < responseHeaders.size(); i++) {
+        writer.write(responseHeaders.name(i) + ": " + responseHeaders.value(i) + '\n');
       }
 
       if (isHttps()) {
         writer.write('\n');
-        writer.write(cipherSuite + '\n');
-        writeCertArray(writer, peerCertificates);
-        writeCertArray(writer, localCertificates);
+        writer.write(handshake.cipherSuite() + '\n');
+        writeCertArray(writer, handshake.peerCertificates());
+        writeCertArray(writer, handshake.localCertificates());
       }
       writer.close();
     }
 
     private boolean isHttps() {
-      return uri.startsWith("https://");
+      return url.startsWith("https://");
     }
 
-    private Certificate[] readCertArray(StrictLineReader reader) throws IOException {
+    private List<Certificate> readCertificateList(StrictLineReader reader) throws IOException {
       int length = reader.readInt();
-      if (length == -1) {
-        return null;
-      }
+      if (length == -1) return Collections.emptyList(); // OkHttp v1.2 used -1 to indicate null.
+
       try {
         CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-        Certificate[] result = new Certificate[length];
-        for (int i = 0; i < result.length; i++) {
+        List<Certificate> result = new ArrayList<Certificate>(length);
+        for (int i = 0; i < length; i++) {
           String line = reader.readLine();
           byte[] bytes = Base64.decode(line.getBytes("US-ASCII"));
-          result[i] = certificateFactory.generateCertificate(new ByteArrayInputStream(bytes));
+          result.add(certificateFactory.generateCertificate(new ByteArrayInputStream(bytes)));
         }
         return result;
       } catch (CertificateException e) {
@@ -608,15 +504,11 @@ private boolean isHttps() {
       }
     }
 
-    private void writeCertArray(Writer writer, Certificate[] certificates) throws IOException {
-      if (certificates == null) {
-        writer.write("-1\n");
-        return;
-      }
+    private void writeCertArray(Writer writer, List<Certificate> certificates) throws IOException {
       try {
-        writer.write(Integer.toString(certificates.length) + '\n');
-        for (Certificate certificate : certificates) {
-          byte[] bytes = certificate.getEncoded();
+        writer.write(Integer.toString(certificates.size()) + '\n');
+        for (int i = 0, size = certificates.size(); i < size; i++) {
+          byte[] bytes = certificates.get(i).getEncoded();
           String line = Base64.encode(bytes);
           writer.write(line + '\n');
         }
@@ -625,98 +517,64 @@ private void writeCertArray(Writer writer, Certificate[] certificates) throws IO
       }
     }
 
-    public boolean matches(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) {
-      return this.uri.equals(uri.toString())
-          && this.requestMethod.equals(requestMethod)
-          && new ResponseHeaders(uri, responseHeaders).varyMatches(varyHeaders.toMultimap(false),
-          requestHeaders);
-    }
-  }
-
-  /**
-   * Returns an input stream that reads the body of a snapshot, closing the
-   * snapshot when the stream is closed.
-   */
-  private static InputStream newBodyInputStream(final DiskLruCache.Snapshot snapshot) {
-    return new FilterInputStream(snapshot.getInputStream(ENTRY_BODY)) {
-      @Override public void close() throws IOException {
-        snapshot.close();
-        super.close();
-      }
-    };
-  }
-
-  static class EntryCacheResponse extends CacheResponse {
-    private final Entry entry;
-    private final DiskLruCache.Snapshot snapshot;
-    private final InputStream in;
-
-    public EntryCacheResponse(Entry entry, DiskLruCache.Snapshot snapshot) {
-      this.entry = entry;
-      this.snapshot = snapshot;
-      this.in = newBodyInputStream(snapshot);
+    public boolean matches(Request request, Response response) {
+      return url.equals(request.urlString())
+          && requestMethod.equals(request.method())
+          && response.varyMatches(varyHeaders, request);
     }
 
-    @Override public Map<String, List<String>> getHeaders() {
-      return entry.responseHeaders.toMultimap(true);
-    }
-
-    @Override public InputStream getBody() {
-      return in;
+    public Response response(Request request, DiskLruCache.Snapshot snapshot) {
+      String contentType = responseHeaders.get("Content-Type");
+      String contentLength = responseHeaders.get("Content-Length");
+      return new Response.Builder()
+          .request(request)
+          .statusLine(statusLine)
+          .headers(responseHeaders)
+          .body(new CacheResponseBody(snapshot, contentType, contentLength))
+          .handshake(handshake)
+          .build();
     }
   }
 
-  static class EntrySecureCacheResponse extends SecureCacheResponse {
-    private final Entry entry;
+  private static class CacheResponseBody extends Response.Body {
     private final DiskLruCache.Snapshot snapshot;
-    private final InputStream in;
+    private final InputStream bodyIn;
+    private final String contentType;
+    private final String contentLength;
 
-    public EntrySecureCacheResponse(Entry entry, DiskLruCache.Snapshot snapshot) {
-      this.entry = entry;
+    public CacheResponseBody(final DiskLruCache.Snapshot snapshot,
+        String contentType, String contentLength) {
       this.snapshot = snapshot;
-      this.in = newBodyInputStream(snapshot);
-    }
-
-    @Override public Map<String, List<String>> getHeaders() {
-      return entry.responseHeaders.toMultimap(true);
-    }
+      this.contentType = contentType;
+      this.contentLength = contentLength;
 
-    @Override public InputStream getBody() {
-      return in;
-    }
-
-    @Override public String getCipherSuite() {
-      return entry.cipherSuite;
+      // This input stream closes the snapshot when the stream is closed.
+      this.bodyIn = new FilterInputStream(snapshot.getInputStream(ENTRY_BODY)) {
+        @Override public void close() throws IOException {
+          snapshot.close();
+          super.close();
+        }
+      };
     }
 
-    @Override public List<Certificate> getServerCertificateChain()
-        throws SSLPeerUnverifiedException {
-      if (entry.peerCertificates == null || entry.peerCertificates.length == 0) {
-        throw new SSLPeerUnverifiedException(null);
-      }
-      return Arrays.asList(entry.peerCertificates.clone());
+    @Override public boolean ready() throws IOException {
+      return true;
     }
 
-    @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-      if (entry.peerCertificates == null || entry.peerCertificates.length == 0) {
-        throw new SSLPeerUnverifiedException(null);
-      }
-      return ((X509Certificate) entry.peerCertificates[0]).getSubjectX500Principal();
+    @Override public MediaType contentType() {
+      return contentType != null ? MediaType.parse(contentType) : null;
     }
 
-    @Override public List<Certificate> getLocalCertificateChain() {
-      if (entry.localCertificates == null || entry.localCertificates.length == 0) {
-        return null;
+    @Override public long contentLength() {
+      try {
+        return contentLength != null ? Long.parseLong(contentLength) : -1;
+      } catch (NumberFormatException e) {
+        return -1;
       }
-      return Arrays.asList(entry.localCertificates.clone());
     }
 
-    @Override public Principal getLocalPrincipal() {
-      if (entry.localCertificates == null || entry.localCertificates.length == 0) {
-        return null;
-      }
-      return ((X509Certificate) entry.localCertificates[0]).getSubjectX500Principal();
+    @Override public InputStream byteStream() {
+      return bodyIn;
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Job.java b/okhttp/src/main/java/com/squareup/okhttp/Job.java
index 3a453847a2..1a860dfdda 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Job.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Job.java
@@ -15,71 +15,242 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.NamedRunnable;
+import com.squareup.okhttp.internal.http.HttpAuthenticator;
+import com.squareup.okhttp.internal.http.HttpEngine;
+import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
+import com.squareup.okhttp.internal.http.OkHeaders;
 import java.io.IOException;
-import java.net.HttpURLConnection;
+import java.io.InputStream;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.URL;
 
-final class Job implements Runnable {
-  final HttpURLConnection connection;
-  final Request request;
-  final Response.Receiver responseReceiver;
-  final Dispatcher dispatcher;
+import static com.squareup.okhttp.internal.Util.getEffectivePort;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_MOVED_PERM;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_MOVED_TEMP;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_MULT_CHOICE;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_PROXY_AUTH;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_SEE_OTHER;
+import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_UNAUTHORIZED;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
-  public Job(Dispatcher dispatcher, HttpURLConnection connection, Request request,
+final class Job extends NamedRunnable {
+  private final Dispatcher dispatcher;
+  private final OkHttpClient client;
+  private final Response.Receiver responseReceiver;
+  private int redirectionCount;
+
+  volatile boolean canceled;
+
+  /** The request; possibly a consequence of redirects or auth headers. */
+  private Request request;
+  private HttpEngine engine;
+
+  public Job(Dispatcher dispatcher, OkHttpClient client, Request request,
       Response.Receiver responseReceiver) {
+    super("OkHttp %s", request.urlString());
     this.dispatcher = dispatcher;
-    this.connection = connection;
+    this.client = client;
     this.request = request;
     this.responseReceiver = responseReceiver;
   }
 
-  @Override public void run() {
+  String host() {
+    return request.url().getHost();
+  }
+
+  Request request() {
+    return request;
+  }
+
+  Object tag() {
+    return request.tag();
+  }
+
+  @Override protected void execute() {
     try {
-      sendRequest();
-      Response response = readResponse();
-      responseReceiver.onResponse(response);
+      Response response = getResponse();
+      if (response != null && !canceled) {
+        responseReceiver.onResponse(response);
+      }
     } catch (IOException e) {
       responseReceiver.onFailure(new Failure.Builder()
           .request(request)
           .exception(e)
           .build());
     } finally {
-      connection.disconnect();
+      engine.release(true); // Release the connection if it isn't already released.
       dispatcher.finished(this);
     }
   }
 
-  private HttpURLConnection sendRequest() throws IOException {
-    for (int i = 0; i < request.headerCount(); i++) {
-      connection.addRequestProperty(request.headerName(i), request.headerValue(i));
-    }
+  /**
+   * Performs the request and returns the response. May return null if this job
+   * was canceled.
+   */
+  private Response getResponse() throws IOException {
+    Response redirectedBy = null;
+
+    // Copy body metadata to the appropriate request headers.
     Request.Body body = request.body();
     if (body != null) {
-      connection.setDoOutput(true);
+      MediaType contentType = body.contentType();
+      if (contentType == null) throw new IllegalStateException("contentType == null");
+
+      Request.Builder requestBuilder = request.newBuilder();
+      requestBuilder.header("Content-Type", contentType.toString());
+
       long contentLength = body.contentLength();
-      if (contentLength == -1 || contentLength > Integer.MAX_VALUE) {
-        connection.setChunkedStreamingMode(0);
+      if (contentLength != -1) {
+        requestBuilder.header("Content-Length", Long.toString(contentLength));
+        requestBuilder.removeHeader("Transfer-Encoding");
       } else {
-        // Don't call setFixedLengthStreamingMode(long); that's only available on Java 1.7+.
-        connection.setFixedLengthStreamingMode((int) contentLength);
+        requestBuilder.header("Transfer-Encoding", "chunked");
+        requestBuilder.removeHeader("Content-Length");
       }
-      body.writeTo(connection.getOutputStream());
+
+      request = requestBuilder.build();
+    }
+
+    // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
+    engine = new HttpEngine(client, request, false, null, null, null);
+
+    while (true) {
+      if (canceled) return null;
+
+      try {
+        engine.sendRequest();
+
+        if (body != null) {
+          body.writeTo(engine.getRequestBody());
+        }
+
+        engine.readResponse();
+      } catch (IOException e) {
+        HttpEngine retryEngine = engine.recover(e);
+        if (retryEngine != null) {
+          engine = retryEngine;
+          continue;
+        }
+
+        // Give up; recovery is not possible.
+        throw e;
+      }
+
+      Response response = engine.getResponse();
+      Request redirect = processResponse(engine, response);
+
+      if (redirect == null) {
+        engine.automaticallyReleaseConnectionToPool();
+        return response.newBuilder()
+            .body(new RealResponseBody(response, engine.getResponseBody()))
+            .redirectedBy(redirectedBy)
+            .build();
+      }
+
+      if (!sameConnection(request, redirect)) {
+        engine.automaticallyReleaseConnectionToPool();
+      }
+
+      engine.release(false);
+      Connection connection = engine.getConnection();
+      redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.
+      request = redirect;
+      engine = new HttpEngine(client, request, false, connection, null, null);
+    }
+  }
+
+  /**
+   * Figures out the HTTP request to make in response to receiving {@code
+   * response}. This will either add authentication headers or follow
+   * redirects. If a follow-up is either unnecessary or not applicable, this
+   * returns null.
+   */
+  private Request processResponse(HttpEngine engine, Response response) throws IOException {
+    Request request = response.request();
+    Proxy selectedProxy = engine.getRoute() != null
+        ? engine.getRoute().getProxy()
+        : client.getProxy();
+    int responseCode = response.code();
+
+    switch (responseCode) {
+      case HTTP_PROXY_AUTH:
+        if (selectedProxy.type() != Proxy.Type.HTTP) {
+          throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
+        }
+        // fall-through
+      case HTTP_UNAUTHORIZED:
+        return HttpAuthenticator.processAuthHeader(
+            client.getAuthenticator(), response, selectedProxy);
+
+      case HTTP_MULT_CHOICE:
+      case HTTP_MOVED_PERM:
+      case HTTP_MOVED_TEMP:
+      case HTTP_SEE_OTHER:
+      case HTTP_TEMP_REDIRECT:
+        if (!client.getFollowProtocolRedirects()) {
+          return null; // This client has is configured to not follow redirects.
+        }
+
+        if (++redirectionCount > HttpURLConnectionImpl.MAX_REDIRECTS) {
+          throw new ProtocolException("Too many redirects: " + redirectionCount);
+        }
+
+        String method = request.method();
+        if (responseCode == HTTP_TEMP_REDIRECT && !method.equals("GET") && !method.equals("HEAD")) {
+          // "If the 307 status code is received in response to a request other than GET or HEAD,
+          // the user agent MUST NOT automatically redirect the request"
+          return null;
+        }
+
+        String location = response.header("Location");
+        if (location == null) {
+          return null;
+        }
+
+        URL url = new URL(request.url(), location);
+        if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) {
+          return null; // Don't follow redirects to unsupported protocols.
+        }
+
+        return this.request.newBuilder().url(url).build();
+
+      default:
+        return null;
     }
-    return connection;
   }
 
-  private Response readResponse() throws IOException {
-    int responseCode = connection.getResponseCode();
-    Response.Builder responseBuilder = new Response.Builder(request, responseCode);
+  static boolean sameConnection(Request a, Request b) {
+    return a.url().getHost().equals(b.url().getHost())
+        && getEffectivePort(a.url()) == getEffectivePort(b.url())
+        && a.url().getProtocol().equals(b.url().getProtocol());
+  }
+
+  static class RealResponseBody extends Response.Body {
+    private final Response response;
+    private final InputStream in;
+
+    RealResponseBody(Response response, InputStream in) {
+      this.response = response;
+      this.in = in;
+    }
+
+    @Override public boolean ready() throws IOException {
+      return true;
+    }
 
-    for (int i = 0; true; i++) {
-      String name = connection.getHeaderFieldKey(i);
-      if (name == null) break;
-      String value = connection.getHeaderField(i);
-      responseBuilder.addHeader(name, value);
+    @Override public MediaType contentType() {
+      String contentType = response.header("Content-Type");
+      return contentType != null ? MediaType.parse(contentType) : null;
     }
 
-    responseBuilder.body(new Dispatcher.RealResponseBody(connection, connection.getInputStream()));
-    // TODO: set redirectedBy
-    return responseBuilder.build();
+    @Override public long contentLength() {
+      return OkHeaders.contentLength(response);
+    }
+
+    @Override public InputStream byteStream() {
+      return in;
+    }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index 2fe9996dbb..68e1cfadb9 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -15,12 +15,13 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
 import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
-import com.squareup.okhttp.internal.http.OkResponseCacheAdapter;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
+import java.io.IOException;
 import java.net.CookieHandler;
 import java.net.HttpURLConnection;
 import java.net.Proxy;
@@ -30,7 +31,7 @@
 import java.net.URLConnection;
 import java.net.URLStreamHandler;
 import java.net.URLStreamHandlerFactory;
-import java.util.Arrays;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HostnameVerifier;
@@ -38,17 +39,15 @@
 import javax.net.ssl.SSLSocketFactory;
 
 /** Configures and creates HTTP connections. */
-public final class OkHttpClient implements URLStreamHandlerFactory {
-  private static final List<String> DEFAULT_TRANSPORTS
-      = Util.immutableList(Arrays.asList("spdy/3", "http/1.1"));
+public final class OkHttpClient implements URLStreamHandlerFactory, Cloneable {
 
   private final RouteDatabase routeDatabase;
-  private final Dispatcher dispatcher;
+  private Dispatcher dispatcher;
   private Proxy proxy;
-  private List<String> transports;
+  private List<Protocol> protocols;
   private ProxySelector proxySelector;
   private CookieHandler cookieHandler;
-  private ResponseCache responseCache;
+  private OkResponseCache responseCache;
   private SSLSocketFactory sslSocketFactory;
   private HostnameVerifier hostnameVerifier;
   private OkAuthenticator authenticator;
@@ -62,11 +61,6 @@ public OkHttpClient() {
     dispatcher = new Dispatcher();
   }
 
-  private OkHttpClient(OkHttpClient copyFrom) {
-    routeDatabase = copyFrom.routeDatabase;
-    dispatcher = copyFrom.dispatcher;
-  }
-
   /**
    * Sets the default connect timeout for new connections. A value of 0 means no timeout.
    *
@@ -169,24 +163,40 @@ public CookieHandler getCookieHandler() {
    *
    * <p>If unset, the {@link ResponseCache#getDefault() system-wide default}
    * response cache will be used.
+   *
+   * @deprecated OkHttp 2 dropped support for java.net.ResponseCache. That API
+   *     is broken for many reasons: URI instead of URL, no conditional updates,
+   *     no invalidation, and no mechanism for tracking hit rates. Use
+   *     {@link #setOkResponseCache} instead.
    */
+  @Deprecated
   public OkHttpClient setResponseCache(ResponseCache responseCache) {
-    this.responseCache = responseCache;
-    return this;
+    if (responseCache instanceof OkResponseCache) {
+      return setOkResponseCache((OkResponseCache) responseCache);
+    }
+    throw new UnsupportedOperationException("OkHttp 2 dropped support for java.net.ResponseCache. "
+        + "Use setOkResponseCache() instead.");
   }
 
+  /**
+   * @deprecated OkHttp 2 dropped support for java.net.ResponseCache. That API
+   *     is broken for many reasons: URI instead of URL, no conditional updates,
+   *     no invalidation, and no mechanism for tracking hit rates. Use
+   *     {@link #setOkResponseCache} instead.
+   */
+  @Deprecated
   public ResponseCache getResponseCache() {
-    return responseCache;
+    throw new UnsupportedOperationException("OkHttp 2 dropped support for java.net.ResponseCache. "
+        + "Use setOkResponseCache() instead.");
+  }
+
+  public OkHttpClient setOkResponseCache(OkResponseCache responseCache) {
+    this.responseCache = responseCache;
+    return this;
   }
 
   public OkResponseCache getOkResponseCache() {
-    if (responseCache instanceof HttpResponseCache) {
-      return ((HttpResponseCache) responseCache).okResponseCache;
-    } else if (responseCache != null) {
-      return new OkResponseCacheAdapter(responseCache);
-    } else {
-      return null;
-    }
+    return responseCache;
   }
 
   /**
@@ -272,20 +282,53 @@ public RouteDatabase getRoutesDatabase() {
   }
 
   /**
-   * Configure the transports used by this client to communicate with remote
+   * Sets the dispatcher used to set policy and execute asynchronous requests.
+   * Must not be null.
+   */
+  public OkHttpClient setDispatcher(Dispatcher dispatcher) {
+    if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
+    this.dispatcher = dispatcher;
+    return this;
+  }
+
+  public Dispatcher getDispatcher() {
+    return dispatcher;
+  }
+
+  /**
+   * @deprecated OkHttp 2 enforces an enumeration of {@link Protocol protocols}
+   * that can be selected. Please switch to {@link #setProtocols(java.util.List)}.
+   */
+  @Deprecated
+  public OkHttpClient setTransports(List<String> transports) {
+    List<Protocol> protocols = new ArrayList<Protocol>(transports.size());
+    for (int i = 0, size = transports.size(); i < size; i++) {
+      try {
+        Protocol protocol = Protocol.find(ByteString.encodeUtf8(transports.get(i)));
+        protocols.add(protocol);
+      } catch (IOException e) {
+        throw new IllegalArgumentException(e);
+      }
+    }
+    return setProtocols(protocols);
+  }
+
+  /**
+   * Configure the protocols used by this client to communicate with remote
    * servers. By default this client will prefer the most efficient transport
-   * available, falling back to more ubiquitous transports. Applications should
+   * available, falling back to more ubiquitous protocols. Applications should
    * only call this method to avoid specific compatibility problems, such as web
    * servers that behave incorrectly when SPDY is enabled.
    *
-   * <p>The following transports are currently supported:
+   * <p>The following protocols are currently supported:
    * <ul>
    *   <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-   *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3">spdy/3</a>
+   *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
+   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-09">HTTP-draft-09/2.0</a>
    * </ul>
    *
    * <p><strong>This is an evolving set.</strong> Future releases may drop
-   * support for transitional transports (like spdy/3), in favor of their
+   * support for transitional protocols (like spdy/3.1), in favor of their
    * successors (spdy/4 or http/2.0). The http/1.1 transport will never be
    * dropped.
    *
@@ -295,41 +338,55 @@ public RouteDatabase getRoutesDatabase() {
    * (such as <a href="http://tools.ietf.org/html/draft-friedl-tls-applayerprotoneg-02">ALPN</a>)
    * to negotiate a transport.
    *
-   * @param transports the transports to use, in order of preference. The list
+   * @param protocols the protocols to use, in order of preference. The list
    *     must contain "http/1.1". It must not contain null.
    */
-  public OkHttpClient setTransports(List<String> transports) {
-    transports = Util.immutableList(transports);
-    if (!transports.contains("http/1.1")) {
-      throw new IllegalArgumentException("transports doesn't contain http/1.1: " + transports);
-    }
-    if (transports.contains(null)) {
-      throw new IllegalArgumentException("transports must not contain null");
+  public OkHttpClient setProtocols(List<Protocol> protocols) {
+    protocols = Util.immutableList(protocols);
+    if (!protocols.contains(Protocol.HTTP_11)) {
+      throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
     }
-    if (transports.contains("")) {
-      throw new IllegalArgumentException("transports contains an empty string");
+    if (protocols.contains(null)) {
+      throw new IllegalArgumentException("protocols must not contain null");
     }
-    this.transports = transports;
+    this.protocols = Util.immutableList(protocols);
     return this;
   }
 
+  /**
+   * @deprecated OkHttp 2 enforces an enumeration of {@link Protocol protocols}
+   * that can be selected. Please switch to {@link #getProtocols()}.
+   */
+  @Deprecated
   public List<String> getTransports() {
+    List<String> transports = new ArrayList<String>(protocols.size());
+    for (int i = 0, size = protocols.size(); i < size; i++) {
+      transports.add(protocols.get(i).name.utf8());
+    }
     return transports;
   }
 
+  public List<Protocol> getProtocols() {
+    return protocols;
+  }
+
   /**
-   * Schedules {@code request} to be executed.
+   * Schedules {@code request} to be executed at some point in the future. The
+   * {@link #getDispatcher dispatcher} defines when the request will run:
+   * usually immediately unless there are several other requests currently being
+   * executed.
+   *
+   * <p>This client will later call back {@code responseReceiver} with either an
+   * HTTP response or a failure exception. If you {@link #cancel} a request
+   * before it completes the receiver will not be called back.
    */
-  /* OkHttp 2.0: public */ void enqueue(Request request, Response.Receiver responseReceiver) {
-    // Create the HttpURLConnection immediately so the enqueued job gets the current settings of
-    // this client. Otherwise changes to this client (socket factory, redirect policy, etc.) may
-    // incorrectly be reflected in the request when it is dispatched later.
-    dispatcher.enqueue(open(request.url()), request, responseReceiver);
+  public void enqueue(Request request, Response.Receiver responseReceiver) {
+    dispatcher.enqueue(this, request, responseReceiver);
   }
 
   /**
    * Cancels all scheduled tasks tagged with {@code tag}. Requests that are already
-   * in flight might not be canceled.
+   * complete cannot be canceled.
    */
   public void cancel(Object tag) {
     dispatcher.cancel(tag);
@@ -350,32 +407,51 @@ HttpURLConnection open(URL url, Proxy proxy) {
   }
 
   /**
-   * Returns a shallow copy of this OkHttpClient that uses the system-wide default for
-   * each field that hasn't been explicitly configured.
+   * Returns a shallow copy of this OkHttpClient that uses the system-wide
+   * default for each field that hasn't been explicitly configured.
    */
-  private OkHttpClient copyWithDefaults() {
-    OkHttpClient result = new OkHttpClient(this);
-    result.proxy = proxy;
-    result.proxySelector = proxySelector != null ? proxySelector : ProxySelector.getDefault();
-    result.cookieHandler = cookieHandler != null ? cookieHandler : CookieHandler.getDefault();
-    result.responseCache = responseCache != null ? responseCache : ResponseCache.getDefault();
-    result.sslSocketFactory = sslSocketFactory != null
-        ? sslSocketFactory
-        : HttpsURLConnection.getDefaultSSLSocketFactory();
-    result.hostnameVerifier = hostnameVerifier != null
-        ? hostnameVerifier
-        : OkHostnameVerifier.INSTANCE;
-    result.authenticator = authenticator != null
-        ? authenticator
-        : HttpAuthenticator.SYSTEM_DEFAULT;
-    result.connectionPool = connectionPool != null ? connectionPool : ConnectionPool.getDefault();
-    result.followProtocolRedirects = followProtocolRedirects;
-    result.transports = transports != null ? transports : DEFAULT_TRANSPORTS;
-    result.connectTimeout = connectTimeout;
-    result.readTimeout = readTimeout;
+  OkHttpClient copyWithDefaults() {
+    OkHttpClient result = clone();
+    if (result.proxySelector == null) {
+      result.proxySelector = ProxySelector.getDefault();
+    }
+    if (result.cookieHandler == null) {
+      result.cookieHandler = CookieHandler.getDefault();
+    }
+    if (result.responseCache == null) {
+      result.responseCache = toOkResponseCacheOrNull(ResponseCache.getDefault());
+    }
+    if (result.sslSocketFactory == null) {
+      result.sslSocketFactory = HttpsURLConnection.getDefaultSSLSocketFactory();
+    }
+    if (result.hostnameVerifier == null) {
+      result.hostnameVerifier = OkHostnameVerifier.INSTANCE;
+    }
+    if (result.authenticator == null) {
+      result.authenticator = HttpAuthenticator.SYSTEM_DEFAULT;
+    }
+    if (result.connectionPool == null) {
+      result.connectionPool = ConnectionPool.getDefault();
+    }
+    if (result.protocols == null) {
+      result.protocols = Protocol.HTTP2_SPDY3_AND_HTTP;
+    }
     return result;
   }
 
+  /** Returns a shallow copy of this OkHttpClient. */
+  @Override public OkHttpClient clone() {
+    try {
+      return (OkHttpClient) super.clone();
+    } catch (CloneNotSupportedException e) {
+      throw new AssertionError();
+    }
+  }
+
+  private OkResponseCache toOkResponseCacheOrNull(ResponseCache cache) {
+    return cache instanceof OkResponseCache ? ((OkResponseCache) cache) : null;
+  }
+
   /**
    * Creates a URLStreamHandler as a {@link URL#setURLStreamHandlerFactory}.
    *
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java b/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java
index ffe6f54b10..05460f5ada 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkResponseCache.java
@@ -17,36 +17,31 @@
 
 import java.io.IOException;
 import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
 
 /**
  * An extended response cache API. Unlike {@link java.net.ResponseCache}, this
  * interface supports conditional caching and statistics.
- *
- * <h3>Warning: Experimental OkHttp 2.0 API</h3>
- * This class is in beta. APIs are subject to change!
  */
 public interface OkResponseCache {
-  CacheResponse get(URI uri, String requestMethod, Map<String, List<String>> requestHeaders)
-      throws IOException;
+  Response get(Request request) throws IOException;
 
-  CacheRequest put(URI uri, URLConnection urlConnection) throws IOException;
+  CacheRequest put(Response response) throws IOException;
 
-  /** Remove any cache entries for the supplied {@code uri} if the request method invalidates. */
-  void maybeRemove(String requestMethod, URI uri) throws IOException;
+  /**
+   * Remove any cache entries for the supplied {@code uri}. Returns true if the
+   * supplied {@code requestMethod} potentially invalidates an entry in the
+   * cache.
+   */
+  // TODO: this shouldn't return a boolean.
+  boolean maybeRemove(Request request) throws IOException;
 
   /**
    * Handles a conditional request hit by updating the stored cache response
-   * with the headers from {@code httpConnection}. The cached response body is
-   * not updated. If the stored response has changed since {@code
-   * conditionalCacheHit} was returned, this does nothing.
+   * with the headers from {@code network}. The cached response body is not
+   * updated. If the stored response has changed since {@code cached} was
+   * returned, this does nothing.
    */
-  void update(CacheResponse conditionalCacheHit, HttpURLConnection connection) throws IOException;
+  void update(Response cached, Response network) throws IOException;
 
   /** Track an conditional GET that was satisfied by this cache. */
   void trackConditionalCacheHit();
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index a4e83f4889..317e0b4c86 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -15,8 +15,8 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.RawHeaders;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -24,28 +24,30 @@
 import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
 import java.net.URL;
 import java.util.List;
-import java.util.Set;
 
 /**
  * An HTTP request. Instances of this class are immutable if their {@link #body}
  * is null or itself immutable.
- *
- * <h3>Warning: Experimental OkHttp 2.0 API</h3>
- * This class is in beta. APIs are subject to change!
  */
-/* OkHttp 2.0: public */ final class Request {
+public final class Request {
   private final URL url;
   private final String method;
-  private final RawHeaders headers;
+  private final Headers headers;
   private final Body body;
   private final Object tag;
 
+  private volatile ParsedHeaders parsedHeaders; // Lazily initialized.
+  private volatile URI uri; // Lazily initialized.
+  private volatile CacheControl cacheControl; // Lazily initialized.
+
   private Request(Builder builder) {
     this.url = builder.url;
     this.method = builder.method;
-    this.headers = new RawHeaders(builder.headers);
+    this.headers = builder.headers.build();
     this.body = builder.body;
     this.tag = builder.tag != null ? builder.tag : this;
   }
@@ -54,6 +56,15 @@ public URL url() {
     return url;
   }
 
+  public URI uri() throws IOException {
+    try {
+      URI result = uri;
+      return result != null ? result : (uri = Platform.get().toUriLenient(url));
+    } catch (URISyntaxException e) {
+      throw new IOException(e.getMessage());
+    }
+  }
+
   public String urlString() {
     return url.toString();
   }
@@ -62,6 +73,10 @@ public String method() {
     return method;
   }
 
+  public Headers headers() {
+    return headers;
+  }
+
   public String header(String name) {
     return headers.get(name);
   }
@@ -70,40 +85,74 @@ public String header(String name) {
     return headers.values(name);
   }
 
-  public Set<String> headerNames() {
-    return headers.names();
+  public Body body() {
+    return body;
+  }
+
+  public Object tag() {
+    return tag;
   }
 
-  public int headerCount() {
-    return headers.length();
+  public Builder newBuilder() {
+    return new Builder(this);
   }
 
-  public String headerName(int index) {
-    return headers.getFieldName(index);
+  public Headers getHeaders() {
+    return headers;
   }
 
-  public String headerValue(int index) {
-    return headers.getValue(index);
+  public String getUserAgent() {
+    return parsedHeaders().userAgent;
   }
 
-  public Body body() {
-    return body;
+  public String getProxyAuthorization() {
+    return parsedHeaders().proxyAuthorization;
   }
 
-  public Object tag() {
-    return tag;
+  private ParsedHeaders parsedHeaders() {
+    ParsedHeaders result = parsedHeaders;
+    return result != null ? result : (parsedHeaders = new ParsedHeaders(headers));
+  }
+
+  /**
+   * Returns the cache control directives for this response. This is never null,
+   * even if this response contains no {@code Cache-Control} header.
+   */
+  public CacheControl cacheControl() {
+    CacheControl result = cacheControl;
+    return result != null ? result : (cacheControl = CacheControl.parse(headers));
+  }
+
+  public boolean isHttps() {
+    return url().getProtocol().equals("https");
+  }
+
+  /** Parsed request headers, computed on-demand and cached. */
+  private static class ParsedHeaders {
+    private String userAgent;
+    private String proxyAuthorization;
+
+    public ParsedHeaders(Headers headers) {
+      for (int i = 0; i < headers.size(); i++) {
+        String fieldName = headers.name(i);
+        String value = headers.value(i);
+        if ("User-Agent".equalsIgnoreCase(fieldName)) {
+          userAgent = value;
+        } else if ("Proxy-Authorization".equalsIgnoreCase(fieldName)) {
+          proxyAuthorization = value;
+        }
+      }
+    }
   }
 
   public abstract static class Body {
+    /** Returns the Content-Type header for this body. */
+    public abstract MediaType contentType();
+
     /**
-     * Returns the Content-Type header for this body, or null if the content
-     * type is unknown.
+     * Returns the number of bytes that will be written to {@code out} in a call
+     * to {@link #writeTo}, or -1 if that count is unknown.
      */
-    public MediaType contentType() {
-      return null;
-    }
-
-    /** Returns the number of bytes in this body, or -1 if that count is unknown. */
     public long contentLength() {
       return -1;
     }
@@ -182,30 +231,34 @@ public static Body create(final MediaType contentType, final File file) {
 
   public static class Builder {
     private URL url;
-    private String method = "GET";
-    private final RawHeaders headers = new RawHeaders();
+    private String method;
+    private Headers.Builder headers;
     private Body body;
     private Object tag;
 
-    public Builder(String url) {
-      url(url);
+    public Builder() {
+      this.method = "GET";
+      this.headers = new Headers.Builder();
     }
 
-    public Builder(URL url) {
-      url(url);
+    private Builder(Request request) {
+      this.url = request.url;
+      this.method = request.method;
+      this.body = request.body;
+      this.tag = request.tag;
+      this.headers = request.headers.newBuilder();
     }
 
     public Builder url(String url) {
       try {
-        this.url = new URL(url);
-        return this;
+        return url(new URL(url));
       } catch (MalformedURLException e) {
         throw new IllegalArgumentException("Malformed URL: " + url);
       }
     }
 
     public Builder url(URL url) {
-      if (url == null) throw new IllegalStateException("url == null");
+      if (url == null) throw new IllegalArgumentException("url == null");
       this.url = url;
       return this;
     }
@@ -228,6 +281,21 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
+    public Builder removeHeader(String name) {
+      headers.removeAll(name);
+      return this;
+    }
+
+    /** Removes all headers on this builder and adds {@code headers}. */
+    public Builder headers(Headers headers) {
+      this.headers = headers.newBuilder();
+      return this;
+    }
+
+    public Builder setUserAgent(String userAgent) {
+      return header("User-Agent", userAgent);
+    }
+
     public Builder get() {
       return method("GET", null);
     }
@@ -264,6 +332,7 @@ public Builder tag(Object tag) {
     }
 
     public Request build() {
+      if (url == null) throw new IllegalStateException("url == null");
       return new Request(this);
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index 4cef2cd5c8..cb9e3539cf 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -16,34 +16,47 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.RawHeaders;
+import com.squareup.okhttp.internal.http.HttpDate;
+import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.StatusLine;
 import java.io.ByteArrayOutputStream;
+import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
+import java.net.HttpURLConnection;
+import java.nio.charset.Charset;
+import java.util.Collections;
+import java.util.Date;
 import java.util.List;
 import java.util.Set;
+import java.util.TreeSet;
+
+import static com.squareup.okhttp.internal.Util.UTF_8;
+import static com.squareup.okhttp.internal.Util.equal;
 
 /**
  * An HTTP response. Instances of this class are not immutable: the response
  * body is a one-shot value that may be consumed only once. All other properties
  * are immutable.
- *
- * <h3>Warning: Experimental OkHttp 2.0 API</h3>
- * This class is in beta. APIs are subject to change!
  */
-/* OkHttp 2.0: public */ final class Response {
+public final class Response {
   private final Request request;
-  private final int code;
-  private final RawHeaders headers;
+  private final StatusLine statusLine;
+  private final Handshake handshake;
+  private final Headers headers;
   private final Body body;
   private final Response redirectedBy;
 
+  private volatile ParsedHeaders parsedHeaders; // Lazily initialized.
+  private volatile CacheControl cacheControl; // Lazily initialized.
+
   private Response(Builder builder) {
     this.request = builder.request;
-    this.code = builder.code;
-    this.headers = new RawHeaders(builder.headers);
+    this.statusLine = builder.statusLine;
+    this.handshake = builder.handshake;
+    this.headers = builder.headers.build();
     this.body = builder.body;
     this.redirectedBy = builder.redirectedBy;
   }
@@ -64,43 +77,55 @@ public Request request() {
     return request;
   }
 
+  public String statusLine() {
+    return statusLine.getStatusLine();
+  }
+
   public int code() {
-    return code;
+    return statusLine.code();
   }
 
-  public String header(String name) {
-    return header(name, null);
+  public String statusMessage() {
+    return statusLine.message();
   }
 
-  public String header(String name, String defaultValue) {
-    String result = headers.get(name);
-    return result != null ? result : defaultValue;
+  public int httpMinorVersion() {
+    return statusLine.httpMinorVersion();
   }
 
-  public List<String> headers(String name) {
-    return headers.values(name);
+  /**
+   * Returns the TLS handshake of the connection that carried this response, or
+   * null if the response was received without TLS.
+   */
+  public Handshake handshake() {
+    return handshake;
   }
 
-  public Set<String> headerNames() {
-    return headers.names();
+  public List<String> headers(String name) {
+    return headers.values(name);
   }
 
-  public int headerCount() {
-    return headers.length();
+  public String header(String name) {
+    return header(name, null);
   }
 
-  public String headerName(int index) {
-    return headers.getFieldName(index);
+  public String header(String name, String defaultValue) {
+    String result = headers.get(name);
+    return result != null ? result : defaultValue;
   }
 
-  public String headerValue(int index) {
-    return headers.getValue(index);
+  public Headers headers() {
+    return headers;
   }
 
   public Body body() {
     return body;
   }
 
+  public Builder newBuilder() {
+    return new Builder(this);
+  }
+
   /**
    * Returns the response for the HTTP redirect that triggered this response, or
    * null if this response wasn't triggered by an automatic redirect. The body
@@ -111,18 +136,84 @@ public Response redirectedBy() {
     return redirectedBy;
   }
 
-  public abstract static class Body {
-    public String contentType() {
-      return null;
+  // TODO: move out of public API
+  public Set<String> getVaryFields() {
+    return parsedHeaders().varyFields;
+  }
+
+  /**
+   * Returns true if a Vary header contains an asterisk. Such responses cannot
+   * be cached.
+   */
+  // TODO: move out of public API
+  public boolean hasVaryAll() {
+    return parsedHeaders().varyFields.contains("*");
+  }
+
+  /**
+   * Returns true if none of the Vary headers on this response have changed
+   * between {@code cachedRequest} and {@code newRequest}.
+   */
+  // TODO: move out of public API
+  public boolean varyMatches(Headers varyHeaders, Request newRequest) {
+    for (String field : parsedHeaders().varyFields) {
+      if (!equal(varyHeaders.values(field), newRequest.headers(field))) return false;
+    }
+    return true;
+  }
+
+  /**
+   * Returns true if this cached response should be used; false if the
+   * network response should be used.
+   */
+  // TODO: move out of public API
+  public boolean validate(Response network) {
+    if (network.code() == HttpURLConnection.HTTP_NOT_MODIFIED) {
+      return true;
     }
 
-    public long contentLength() {
-      return -1;
+    // The HTTP spec says that if the network's response is older than our
+    // cached response, we may return the cache's response. Like Chrome (but
+    // unlike Firefox), this client prefers to return the newer response.
+    ParsedHeaders networkHeaders = network.parsedHeaders();
+    if (parsedHeaders().lastModified != null
+        && networkHeaders.lastModified != null
+        && networkHeaders.lastModified.getTime() < parsedHeaders().lastModified.getTime()) {
+      return true;
     }
 
-    public abstract InputStream byteStream() throws IOException;
+    return false;
+  }
+
+  public abstract static class Body implements Closeable {
+    /** Multiple calls to {@link #charStream()} must return the same instance. */
+    private Reader reader;
+
+    /**
+     * Returns true if further data from this response body should be read at
+     * this time. For asynchronous protocols like SPDY and HTTP/2, this will
+     * return false once all locally-available body bytes have been read.
+     *
+     * <p>Clients with many concurrent downloads can use this method to reduce
+     * the number of idle threads blocking on reads. See {@link
+     * Receiver#onResponse} for details.
+     */
+    // <h3>Body.ready() vs. InputStream.available()</h3>
+    // TODO: Can we fix response bodies to implement InputStream.available well?
+    // The deflater implementation is broken by default but we could do better.
+    public abstract boolean ready() throws IOException;
+
+    public abstract MediaType contentType();
+
+    /**
+     * Returns the number of bytes in that will returned by {@link #bytes}, or
+     * {@link #byteStream}, or -1 if unknown.
+     */
+    public abstract long contentLength();
+
+    public abstract InputStream byteStream();
 
-    public byte[] bytes() throws IOException {
+    public final byte[] bytes() throws IOException {
       long contentLength = contentLength();
       if (contentLength > Integer.MAX_VALUE) {
         throw new IOException("Cannot buffer entire body for content length: " + contentLength);
@@ -143,41 +234,161 @@ public long contentLength() {
     }
 
     /**
-     * Returns the response bytes as a UTF-8 character stream. Do not call this
-     * method if the response content is not a UTF-8 character stream.
+     * Returns the response as a character stream decoded with the charset
+     * of the Content-Type header. If that header is either absent or lacks a
+     * charset, this will attempt to decode the response body as UTF-8.
      */
-    public Reader charStream() throws IOException {
-      // TODO: parse content-type.
-      return new InputStreamReader(byteStream(), "UTF-8");
+    public final Reader charStream() {
+      if (reader == null) {
+        reader = new InputStreamReader(byteStream(), charset());
+      }
+      return reader;
     }
 
     /**
-     * Returns the response bytes as a UTF-8 string. Do not call this method if
-     * the response content is not a UTF-8 character stream.
+     * Returns the response as a string decoded with the charset of the
+     * Content-Type header. If that header is either absent or lacks a charset,
+     * this will attempt to decode the response body as UTF-8.
      */
-    public String string() throws IOException {
-      // TODO: parse content-type.
-      return new String(bytes(), "UTF-8");
+    public final String string() throws IOException {
+      return new String(bytes(), charset().name());
+    }
+
+    private Charset charset() {
+      MediaType contentType = contentType();
+      return contentType != null ? contentType.charset(UTF_8) : UTF_8;
+    }
+
+    @Override public void close() throws IOException {
+      byteStream().close();
+    }
+  }
+
+  private ParsedHeaders parsedHeaders() {
+    ParsedHeaders result = parsedHeaders;
+    return result != null ? result : (parsedHeaders = new ParsedHeaders(headers));
+  }
+
+  /**
+   * Returns the cache control directives for this response. This is never null,
+   * even if this response contains no {@code Cache-Control} header.
+   */
+  public CacheControl cacheControl() {
+    CacheControl result = cacheControl;
+    return result != null ? result : (cacheControl = CacheControl.parse(headers));
+  }
+
+  /** Parsed response headers, computed on-demand and cached. */
+  private static class ParsedHeaders {
+    /** The last modified date of the response, if known. */
+    Date lastModified;
+
+    /** Case-insensitive set of field names. */
+    private Set<String> varyFields = Collections.emptySet();
+
+    private ParsedHeaders(Headers headers) {
+      for (int i = 0; i < headers.size(); i++) {
+        String fieldName = headers.name(i);
+        String value = headers.value(i);
+        if ("Last-Modified".equalsIgnoreCase(fieldName)) {
+          lastModified = HttpDate.parse(value);
+        } else if ("Vary".equalsIgnoreCase(fieldName)) {
+          // Replace the immutable empty set with something we can mutate.
+          if (varyFields.isEmpty()) {
+            varyFields = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
+          }
+          for (String varyField : value.split(",")) {
+            varyFields.add(varyField.trim());
+          }
+        }
+      }
     }
   }
 
   public interface Receiver {
+    /**
+     * Called when the request could not be executed due to a connectivity
+     * problem or timeout. Because networks can fail during an exchange, it is
+     * possible that the remote server accepted the request before the failure.
+     */
     void onFailure(Failure failure);
-    void onResponse(Response response) throws IOException;
+
+    /**
+     * Called when the HTTP response was successfully returned by the remote
+     * server. The receiver may proceed to read the response body with the
+     * response's {@link #body} method.
+     *
+     * <p>Note that transport-layer success (receiving a HTTP response code,
+     * headers and body) does not necessarily indicate application-layer
+     * success: {@code response} may still indicate an unhappy HTTP response
+     * code like 404 or 500.
+     *
+     * <h3>Non-blocking responses</h3>
+     *
+     * <p>Receivers do not need to block while waiting for the response body to
+     * download. Instead, they can get called back as data arrives. Use {@link
+     * Body#ready} to check if bytes should be read immediately. While there is
+     * data ready, read it. If there isn't, return false: receivers will be
+     * called back with {@code onResponse()} as additional data is downloaded.
+     *
+     * <p>Return true to indicate that the receiver has finished handling the
+     * response body. If the response body has unread data, it will be
+     * discarded.
+     *
+     * <p>When the response body has been fully consumed the returned value is
+     * undefined.
+     *
+     * <p>The current implementation of {@link Body#ready} always returns true
+     * when the underlying transport is HTTP/1. This results in blocking on that
+     * transport. For effective non-blocking your server must support SPDY or
+     * HTTP/2.
+     */
+    boolean onResponse(Response response) throws IOException;
   }
 
   public static class Builder {
-    private final Request request;
-    private final int code;
-    private final RawHeaders headers = new RawHeaders();
+    private Request request;
+    private StatusLine statusLine;
+    private Handshake handshake;
+    private Headers.Builder headers;
     private Body body;
     private Response redirectedBy;
 
-    public Builder(Request request, int code) {
-      if (request == null) throw new IllegalArgumentException("request == null");
-      if (code <= 0) throw new IllegalArgumentException("code <= 0");
+    public Builder() {
+      headers = new Headers.Builder();
+    }
+
+    private Builder(Response response) {
+      this.request = response.request;
+      this.statusLine = response.statusLine;
+      this.handshake = response.handshake;
+      this.headers = response.headers.newBuilder();
+      this.body = response.body;
+      this.redirectedBy = response.redirectedBy;
+    }
+
+    public Builder request(Request request) {
       this.request = request;
-      this.code = code;
+      return this;
+    }
+
+    public Builder statusLine(StatusLine statusLine) {
+      if (statusLine == null) throw new IllegalArgumentException("statusLine == null");
+      this.statusLine = statusLine;
+      return this;
+    }
+
+    public Builder statusLine(String statusLine) {
+      try {
+        return statusLine(new StatusLine(statusLine));
+      } catch (IOException e) {
+        throw new IllegalArgumentException(e);
+      }
+    }
+
+    public Builder handshake(Handshake handshake) {
+      this.handshake = handshake;
+      return this;
     }
 
     /**
@@ -198,19 +409,35 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
+    public Builder removeHeader(String name) {
+      headers.removeAll(name);
+      return this;
+    }
+
+    /** Removes all headers on this builder and adds {@code headers}. */
+    public Builder headers(Headers headers) {
+      this.headers = headers.newBuilder();
+      return this;
+    }
+
     public Builder body(Body body) {
       this.body = body;
       return this;
     }
 
+    // TODO: move out of public API
+    public Builder setResponseSource(ResponseSource responseSource) {
+      return header(OkHeaders.RESPONSE_SOURCE, responseSource + " " + statusLine.code());
+    }
+
     public Builder redirectedBy(Response redirectedBy) {
       this.redirectedBy = redirectedBy;
       return this;
     }
 
     public Response build() {
-      if (request == null) throw new IllegalStateException("Response has no request.");
-      if (code == -1) throw new IllegalStateException("Response has no code.");
+      if (request == null) throw new IllegalStateException("request == null");
+      if (statusLine == null) throw new IllegalStateException("statusLine == null");
       return new Response(this);
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java b/okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java
index 4eca172d35..915fa58e68 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java
@@ -29,9 +29,20 @@
   CONDITIONAL_CACHE,
 
   /** The response was returned from the network. */
-  NETWORK;
+  NETWORK,
+
+  /**
+   * The request demanded a cached response that the cache couldn't satisfy.
+   * This yields a 504 (Gateway Timeout) response as specified by
+   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.4.
+   */
+  NONE;
 
   public boolean requiresConnection() {
     return this == CONDITIONAL_CACHE || this == NETWORK;
   }
+
+  public boolean usesCache() {
+    return this == CACHE || this == CONDITIONAL_CACHE;
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Route.java b/okhttp/src/main/java/com/squareup/okhttp/Route.java
index 4b8786d229..a08a4699c5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Route.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Route.java
@@ -18,7 +18,21 @@
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 
-/** Represents the route used by a connection to reach an endpoint. */
+/**
+ * The concrete route used by a connection to reach an abstract origin server.
+ * When creating a connection the client has many options:
+ * <ul>
+ *   <li><strong>HTTP proxy:</strong> a proxy server may be explicitly
+ *       configured for the client. Otherwise the {@link java.net.ProxySelector
+ *       proxy selector} is used. It may return multiple proxies to attempt.
+ *   <li><strong>IP address:</strong> whether connecting directly to an origin
+ *       server or a proxy, opening a socket requires an IP address. The DNS
+ *       server may return multiple IP addresses to attempt.
+ *   <li><strong>Modern TLS:</strong> whether to include advanced TLS options
+ *       when attempting a HTTPS connection.
+ * </ul>
+ * Each route is a specific selection of these options.
+ */
 public class Route {
   final Address address;
   final Proxy proxy;
@@ -44,11 +58,8 @@ public Address getAddress() {
   /**
    * Returns the {@link Proxy} of this route.
    *
-   * <strong>Warning:</strong> This may be different than the proxy returned
-   * by {@link #getAddress}! That is the proxy that the user asked to be
-   * connected to; this returns the proxy that they were actually connected
-   * to. The two may disagree when a proxy selector selects a different proxy
-   * for a connection.
+   * <strong>Warning:</strong> This may disagree with {@link Address#getProxy}
+   * is null. When the address's proxy is null, the proxy selector will be used.
    */
   public Proxy getProxy() {
     return proxy;
@@ -64,11 +75,6 @@ public boolean isModernTls() {
     return modernTls;
   }
 
-  /** Returns a copy of this route with flipped TLS mode. */
-  Route flipTlsMode() {
-    return new Route(address, proxy, inetSocketAddress, !modernTls);
-  }
-
   @Override public boolean equals(Object obj) {
     if (obj instanceof Route) {
       Route other = (Route) obj;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/RouteDatabase.java b/okhttp/src/main/java/com/squareup/okhttp/RouteDatabase.java
index 9cbeaa73f1..4177c0fb1b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/RouteDatabase.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/RouteDatabase.java
@@ -15,10 +15,8 @@
  */
 package com.squareup.okhttp;
 
-import java.io.IOException;
 import java.util.LinkedHashSet;
 import java.util.Set;
-import javax.net.ssl.SSLHandshakeException;
 
 /**
  * A blacklist of failed routes to avoid when creating a new connection to a
@@ -31,14 +29,8 @@
   private final Set<Route> failedRoutes = new LinkedHashSet<Route>();
 
   /** Records a failure connecting to {@code failedRoute}. */
-  public synchronized void failed(Route failedRoute, IOException failure) {
+  public synchronized void failed(Route failedRoute) {
     failedRoutes.add(failedRoute);
-
-    if (!(failure instanceof SSLHandshakeException)) {
-      // If the problem was not related to SSL then it will also fail with
-      // a different TLS mode therefore we can be proactive about it.
-      failedRoutes.add(failedRoute.flipTlsMode());
-    }
   }
 
   /** Records success connecting to {@code failedRoute}. */
diff --git a/okhttp/src/main/java/com/squareup/okhttp/TunnelRequest.java b/okhttp/src/main/java/com/squareup/okhttp/TunnelRequest.java
index 5260b87c49..3bcff5a8a5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/TunnelRequest.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/TunnelRequest.java
@@ -15,7 +15,8 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.http.RawHeaders;
+import java.io.IOException;
+import java.net.URL;
 
 import static com.squareup.okhttp.internal.Util.getDefaultPort;
 
@@ -49,27 +50,31 @@ public TunnelRequest(String host, int port, String userAgent, String proxyAuthor
     this.proxyAuthorization = proxyAuthorization;
   }
 
+  String requestLine() {
+    return "CONNECT " + host + ":" + port + " HTTP/1.1";
+  }
+
   /**
    * If we're creating a TLS tunnel, send only the minimum set of headers.
    * This avoids sending potentially sensitive data like HTTP cookies to
    * the proxy unencrypted.
    */
-  RawHeaders getRequestHeaders() {
-    RawHeaders result = new RawHeaders();
-    result.setRequestLine("CONNECT " + host + ":" + port + " HTTP/1.1");
+  Request getRequest() throws IOException {
+    Request.Builder result = new Request.Builder()
+        .url(new URL("https", host, port, "/"));
 
     // Always set Host and User-Agent.
-    result.set("Host", port == getDefaultPort("https") ? host : (host + ":" + port));
-    result.set("User-Agent", userAgent);
+    result.header("Host", port == getDefaultPort("https") ? host : (host + ":" + port));
+    result.header("User-Agent", userAgent);
 
     // Copy over the Proxy-Authorization header if it exists.
     if (proxyAuthorization != null) {
-      result.set("Proxy-Authorization", proxyAuthorization);
+      result.header("Proxy-Authorization", proxyAuthorization);
     }
 
     // Always set the Proxy-Connection to Keep-Alive for the benefit of
     // HTTP/1.0 proxies like Squid.
-    result.set("Proxy-Connection", "Keep-Alive");
-    return result;
+    result.header("Proxy-Connection", "Keep-Alive");
+    return result.build();
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index f7fcb1ed2a..1dbaa88c0e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -30,11 +30,9 @@
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
-import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
-import java.util.concurrent.Callable;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -159,21 +157,24 @@
   private long nextSequenceNumber = 0;
 
   /** This cache uses a single background thread to evict entries. */
-  final ThreadPoolExecutor executorService =
-      new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
-  private final Callable<Void> cleanupCallable = new Callable<Void>() {
-    public Void call() throws Exception {
+  final ThreadPoolExecutor executorService = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
+      new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp DiskLruCache", true));
+  private final Runnable cleanupRunnable = new Runnable() {
+    public void run() {
       synchronized (DiskLruCache.this) {
         if (journalWriter == null) {
-          return null; // Closed.
+          return; // Closed.
         }
-        trimToSize();
-        if (journalRebuildRequired()) {
-          rebuildJournal();
-          redundantOpCount = 0;
+        try {
+          trimToSize();
+          if (journalRebuildRequired()) {
+            rebuildJournal();
+            redundantOpCount = 0;
+          }
+        } catch (IOException e) {
+          throw new RuntimeException(e);
         }
       }
-      return null;
     }
   };
 
@@ -432,7 +433,7 @@ public synchronized Snapshot get(String key) throws IOException {
     redundantOpCount++;
     journalWriter.append(READ + ' ' + key + '\n');
     if (journalRebuildRequired()) {
-      executorService.submit(cleanupCallable);
+      executorService.execute(cleanupRunnable);
     }
 
     return new Snapshot(key, entry.sequenceNumber, ins, entry.lengths);
@@ -489,7 +490,7 @@ public long getMaxSize() {
    */
   public synchronized void setMaxSize(long maxSize) {
     this.maxSize = maxSize;
-    executorService.submit(cleanupCallable);
+    executorService.execute(cleanupRunnable);
   }
 
   /**
@@ -552,7 +553,7 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
     journalWriter.flush();
 
     if (size > maxSize || journalRebuildRequired()) {
-      executorService.submit(cleanupCallable);
+      executorService.execute(cleanupRunnable);
     }
   }
 
@@ -562,7 +563,7 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
    */
   private boolean journalRebuildRequired() {
     final int redundantOpCompactThreshold = 2000;
-    return redundantOpCount >= redundantOpCompactThreshold //
+    return redundantOpCount >= redundantOpCompactThreshold
         && redundantOpCount >= lruEntries.size();
   }
 
@@ -594,7 +595,7 @@ public synchronized boolean remove(String key) throws IOException {
     lruEntries.remove(key);
 
     if (journalRebuildRequired()) {
-      executorService.submit(cleanupCallable);
+      executorService.execute(cleanupRunnable);
     }
 
     return true;
@@ -623,7 +624,9 @@ public synchronized void close() throws IOException {
     if (journalWriter == null) {
       return; // Already closed.
     }
-    for (Entry entry : new ArrayList<Entry>(lruEntries.values())) {
+    // Copying for safe iteration.
+    for (Object next : lruEntries.values().toArray()) {
+      Entry entry = (Entry) next;
       if (entry.currentEditor != null) {
         entry.currentEditor.abort();
       }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java
index a5d39b30a4..a7a818e2e6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java
@@ -36,7 +36,7 @@
   protected final InputStream in;
   protected final HttpEngine httpEngine;
   private final CacheRequest cacheRequest;
-  private final OutputStream cacheBody;
+  protected final OutputStream cacheBody;
   protected boolean closed;
 
   AbstractHttpInputStream(InputStream in, HttpEngine httpEngine, CacheRequest cacheRequest)
@@ -46,7 +46,7 @@
 
     OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
 
-    // some apps return a null body; for compatibility we treat that like a null cache request
+    // Some apps return a null body; for compatibility we treat that like a null cache request.
     if (cacheBody == null) {
       cacheRequest = null;
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
new file mode 100644
index 0000000000..ae0acdfb7e
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
@@ -0,0 +1,314 @@
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.CacheControl;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseSource;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.util.Date;
+
+import static com.squareup.okhttp.internal.Util.EMPTY_INPUT_STREAM;
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Given a request and cached response, this figures out whether to use the
+ * network, the cache, or both.
+ *
+ * <p>Selecting a cache strategy may add conditions to the request (like the
+ * "If-Modified-Since" header for conditional GETs) or warnings to the cached
+ * response (if the cached data is potentially stale).
+ */
+public final class CacheStrategy {
+  private static final Response.Body EMPTY_BODY = new Response.Body() {
+    @Override public boolean ready() throws IOException {
+      return true;
+    }
+    @Override public MediaType contentType() {
+      return null;
+    }
+    @Override public long contentLength() {
+      return 0;
+    }
+    @Override public InputStream byteStream() {
+      return EMPTY_INPUT_STREAM;
+    }
+  };
+
+  private static final StatusLine GATEWAY_TIMEOUT_STATUS_LINE;
+  static {
+    try {
+      GATEWAY_TIMEOUT_STATUS_LINE = new StatusLine("HTTP/1.1 504 Gateway Timeout");
+    } catch (IOException e) {
+      throw new AssertionError();
+    }
+  }
+
+  public final Request request;
+  public final Response response;
+  public final ResponseSource source;
+
+  private CacheStrategy(
+      Request request, Response response, ResponseSource source) {
+    this.request = request;
+    this.response = response;
+    this.source = source;
+  }
+
+  /**
+   * Returns true if this response can be stored to later serve another
+   * request.
+   */
+  public static boolean isCacheable(Response response, Request request) {
+    // Always go to network for uncacheable response codes (RFC 2616, 13.4),
+    // This implementation doesn't support caching partial content.
+    int responseCode = response.code();
+    if (responseCode != HttpURLConnection.HTTP_OK
+        && responseCode != HttpURLConnection.HTTP_NOT_AUTHORITATIVE
+        && responseCode != HttpURLConnection.HTTP_MULT_CHOICE
+        && responseCode != HttpURLConnection.HTTP_MOVED_PERM
+        && responseCode != HttpURLConnection.HTTP_GONE) {
+      return false;
+    }
+
+    // Responses to authorized requests aren't cacheable unless they include
+    // a 'public', 'must-revalidate' or 's-maxage' directive.
+    CacheControl responseCaching = response.cacheControl();
+    if (request.header("Authorization") != null
+        && !responseCaching.isPublic()
+        && !responseCaching.mustRevalidate()
+        && responseCaching.sMaxAgeSeconds() == -1) {
+      return false;
+    }
+
+    if (responseCaching.noStore()) {
+      return false;
+    }
+
+    return true;
+  }
+
+  public static class Factory {
+    final long nowMillis;
+    final Request request;
+    final Response cacheResponse;
+
+    /** The server's time when the cached response was served, if known. */
+    private Date servedDate;
+
+    /** The last modified date of the cached response, if known. */
+    private Date lastModified;
+
+    /**
+     * The expiration date of the cached response, if known. If both this field
+     * and the max age are set, the max age is preferred.
+     */
+    private Date expires;
+
+    /**
+     * Extension header set by OkHttp specifying the timestamp when the cached
+     * HTTP request was first initiated.
+     */
+    private long sentRequestMillis;
+
+    /**
+     * Extension header set by OkHttp specifying the timestamp when the cached
+     * HTTP response was first received.
+     */
+    private long receivedResponseMillis;
+
+    /** Etag of the cached response. */
+    private String etag;
+
+    /** Age of the cached response. */
+    private int ageSeconds = -1;
+
+    public Factory(long nowMillis, Request request, Response cacheResponse) {
+      this.nowMillis = nowMillis;
+      this.request = request;
+      this.cacheResponse = cacheResponse;
+
+      if (cacheResponse != null) {
+        for (int i = 0; i < cacheResponse.headers().size(); i++) {
+          String fieldName = cacheResponse.headers().name(i);
+          String value = cacheResponse.headers().value(i);
+          if ("Date".equalsIgnoreCase(fieldName)) {
+            servedDate = HttpDate.parse(value);
+          } else if ("Expires".equalsIgnoreCase(fieldName)) {
+            expires = HttpDate.parse(value);
+          } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
+            lastModified = HttpDate.parse(value);
+          } else if ("ETag".equalsIgnoreCase(fieldName)) {
+            etag = value;
+          } else if ("Age".equalsIgnoreCase(fieldName)) {
+            ageSeconds = HeaderParser.parseSeconds(value);
+          } else if (OkHeaders.SENT_MILLIS.equalsIgnoreCase(fieldName)) {
+            sentRequestMillis = Long.parseLong(value);
+          } else if (OkHeaders.RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
+            receivedResponseMillis = Long.parseLong(value);
+          }
+        }
+      }
+    }
+
+    /**
+     * Returns a strategy to satisfy {@code request} using the a cached response
+     * {@code response}.
+     */
+    public CacheStrategy get() {
+      CacheStrategy candidate = getCandidate();
+
+      if (candidate.source != ResponseSource.CACHE && request.cacheControl().onlyIfCached()) {
+        // We're forbidden from using the network, but the cache is insufficient.
+        Response noneResponse = new Response.Builder()
+            .request(candidate.request)
+            .statusLine(GATEWAY_TIMEOUT_STATUS_LINE)
+            .setResponseSource(ResponseSource.NONE)
+            .body(EMPTY_BODY)
+            .build();
+        return new CacheStrategy(candidate.request, noneResponse, ResponseSource.NONE);
+      }
+
+      return candidate;
+    }
+
+    /** Returns a strategy to use assuming the request can use the network. */
+    private CacheStrategy getCandidate() {
+      // No cached response.
+      if (cacheResponse == null) {
+        return new CacheStrategy(request, cacheResponse, ResponseSource.NETWORK);
+      }
+
+      // Drop the cached response if it's missing a required handshake.
+      if (request.isHttps() && cacheResponse.handshake() == null) {
+        return new CacheStrategy(request, cacheResponse, ResponseSource.NETWORK);
+      }
+
+      // If this response shouldn't have been stored, it should never be used
+      // as a response source. This check should be redundant as long as the
+      // persistence store is well-behaved and the rules are constant.
+      if (!isCacheable(cacheResponse, request)) {
+        return new CacheStrategy(request, cacheResponse, ResponseSource.NETWORK);
+      }
+
+      CacheControl requestCaching = request.cacheControl();
+      if (requestCaching.noCache() || hasConditions(request)) {
+        return new CacheStrategy(request, cacheResponse, ResponseSource.NETWORK);
+      }
+
+      long ageMillis = cacheResponseAge();
+      long freshMillis = computeFreshnessLifetime();
+
+      if (requestCaching.maxAgeSeconds() != -1) {
+        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
+      }
+
+      long minFreshMillis = 0;
+      if (requestCaching.minFreshSeconds() != -1) {
+        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
+      }
+
+      long maxStaleMillis = 0;
+      CacheControl responseCaching = cacheResponse.cacheControl();
+      if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
+        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
+      }
+
+      if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
+        Response.Builder builder = cacheResponse.newBuilder()
+            .setResponseSource(ResponseSource.CACHE); // Overwrite any stored response source.
+        if (ageMillis + minFreshMillis >= freshMillis) {
+          builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
+        }
+        long oneDayMillis = 24 * 60 * 60 * 1000L;
+        if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
+          builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
+        }
+        return new CacheStrategy(request, builder.build(), ResponseSource.CACHE);
+      }
+
+      Request.Builder conditionalRequestBuilder = request.newBuilder();
+
+      if (lastModified != null) {
+        conditionalRequestBuilder.header("If-Modified-Since", HttpDate.format(lastModified));
+      } else if (servedDate != null) {
+        conditionalRequestBuilder.header("If-Modified-Since", HttpDate.format(servedDate));
+      }
+
+      if (etag != null) {
+        conditionalRequestBuilder.header("If-None-Match", etag);
+      }
+
+      Request conditionalRequest = conditionalRequestBuilder.build();
+      ResponseSource responseSource = hasConditions(conditionalRequest)
+          ? ResponseSource.CONDITIONAL_CACHE
+          : ResponseSource.NETWORK;
+      return new CacheStrategy(conditionalRequest, cacheResponse, responseSource);
+    }
+
+    /**
+     * Returns the number of milliseconds that the response was fresh for,
+     * starting from the served date.
+     */
+    private long computeFreshnessLifetime() {
+      CacheControl responseCaching = cacheResponse.cacheControl();
+      if (responseCaching.maxAgeSeconds() != -1) {
+        return SECONDS.toMillis(responseCaching.maxAgeSeconds());
+      } else if (expires != null) {
+        long servedMillis = servedDate != null
+            ? servedDate.getTime()
+            : receivedResponseMillis;
+        long delta = expires.getTime() - servedMillis;
+        return delta > 0 ? delta : 0;
+      } else if (lastModified != null
+          && cacheResponse.request().url().getQuery() == null) {
+        // As recommended by the HTTP RFC and implemented in Firefox, the
+        // max age of a document should be defaulted to 10% of the
+        // document's age at the time it was served. Default expiration
+        // dates aren't used for URIs containing a query.
+        long servedMillis = servedDate != null
+            ? servedDate.getTime()
+            : sentRequestMillis;
+        long delta = servedMillis - lastModified.getTime();
+        return delta > 0 ? (delta / 10) : 0;
+      }
+      return 0;
+    }
+
+    /**
+     * Returns the current age of the response, in milliseconds. The calculation
+     * is specified by RFC 2616, 13.2.3 Age Calculations.
+     */
+    private long cacheResponseAge() {
+      long apparentReceivedAge = servedDate != null
+          ? Math.max(0, receivedResponseMillis - servedDate.getTime())
+          : 0;
+      long receivedAge = ageSeconds != -1
+          ? Math.max(apparentReceivedAge, SECONDS.toMillis(ageSeconds))
+          : apparentReceivedAge;
+      long responseDuration = receivedResponseMillis - sentRequestMillis;
+      long residentDuration = nowMillis - receivedResponseMillis;
+      return receivedAge + responseDuration + residentDuration;
+    }
+
+    /**
+     * Returns true if computeFreshnessLifetime used a heuristic. If we used a
+     * heuristic to serve a cached response older than 24 hours, we are required
+     * to attach a warning.
+     */
+    private boolean isFreshnessLifetimeHeuristic() {
+      return cacheResponse.cacheControl().maxAgeSeconds() == -1 && expires == null;
+    }
+
+    /**
+     * Returns true if the request contains conditions that save the server from
+     * sending a response that the client has locally. When a request is enqueued
+     * with its own conditions, the built-in response cache won't be used.
+     */
+    private static boolean hasConditions(Request request) {
+      return request.header("If-Modified-Since") != null || request.header("If-None-Match") != null;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
index 12e6409737..e9af13026c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HeaderParser.java
@@ -16,50 +16,7 @@
 
 package com.squareup.okhttp.internal.http;
 
-final class HeaderParser {
-
-  public interface CacheControlHandler {
-    void handle(String directive, String parameter);
-  }
-
-  /** Parse a comma-separated list of cache control header values. */
-  public static void parseCacheControl(String value, CacheControlHandler handler) {
-    int pos = 0;
-    while (pos < value.length()) {
-      int tokenStart = pos;
-      pos = skipUntil(value, pos, "=,");
-      String directive = value.substring(tokenStart, pos).trim();
-
-      if (pos == value.length() || value.charAt(pos) == ',') {
-        pos++; // consume ',' (if necessary)
-        handler.handle(directive, null);
-        continue;
-      }
-
-      pos++; // consume '='
-      pos = skipWhitespace(value, pos);
-
-      String parameter;
-
-      // quoted string
-      if (pos < value.length() && value.charAt(pos) == '\"') {
-        pos++; // consume '"' open quote
-        int parameterStart = pos;
-        pos = skipUntil(value, pos, "\"");
-        parameter = value.substring(parameterStart, pos);
-        pos++; // consume '"' close quote (if necessary)
-
-        // unquoted string
-      } else {
-        int parameterStart = pos;
-        pos = skipUntil(value, pos, ",");
-        parameter = value.substring(parameterStart, pos).trim();
-      }
-
-      handler.handle(directive, parameter);
-    }
-  }
-
+public final class HeaderParser {
   /**
    * Returns the next index in {@code input} at or after {@code pos} that
    * contains a character from {@code characters}. Returns the input length if
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java
index 63f39e47f0..ce40a92c27 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpAuthenticator.java
@@ -16,8 +16,11 @@
  */
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkAuthenticator;
 import com.squareup.okhttp.OkAuthenticator.Challenge;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.net.Authenticator;
 import java.net.InetAddress;
@@ -38,8 +41,9 @@
   public static final OkAuthenticator SYSTEM_DEFAULT = new OkAuthenticator() {
     @Override public Credential authenticate(
         Proxy proxy, URL url, List<Challenge> challenges) throws IOException {
-      for (Challenge challenge : challenges) {
-        if (!"Basic".equals(challenge.getScheme())) {
+      for (int i = 0, size = challenges.size(); i < size; i++) {
+        Challenge challenge = challenges.get(i);
+        if (!"Basic".equalsIgnoreCase(challenge.getScheme())) {
           continue;
         }
 
@@ -55,8 +59,9 @@
 
     @Override public Credential authenticateProxy(
         Proxy proxy, URL url, List<Challenge> challenges) throws IOException {
-      for (Challenge challenge : challenges) {
-        if (!"Basic".equals(challenge.getScheme())) {
+      for (int i = 0, size = challenges.size(); i < size; i++) {
+        Challenge challenge = challenges.get(i);
+        if (!"Basic".equalsIgnoreCase(challenge.getScheme())) {
           continue;
         }
 
@@ -84,44 +89,40 @@ private HttpAuthenticator() {
 
   /**
    * React to a failed authorization response by looking up new credentials.
-   *
-   * @return true if credentials have been added to successorRequestHeaders
-   *         and another request should be attempted.
+   * Returns a request for a subsequent attempt, or null if no further attempts
+   * should be made.
    */
-  public static boolean processAuthHeader(OkAuthenticator authenticator, int responseCode,
-      RawHeaders responseHeaders, RawHeaders successorRequestHeaders, Proxy proxy, URL url)
-      throws IOException {
+  public static Request processAuthHeader(
+      OkAuthenticator authenticator, Response response, Proxy proxy) throws IOException {
     String responseField;
     String requestField;
-    if (responseCode == HTTP_UNAUTHORIZED) {
+    if (response.code() == HTTP_UNAUTHORIZED) {
       responseField = "WWW-Authenticate";
       requestField = "Authorization";
-    } else if (responseCode == HTTP_PROXY_AUTH) {
+    } else if (response.code() == HTTP_PROXY_AUTH) {
       responseField = "Proxy-Authenticate";
       requestField = "Proxy-Authorization";
     } else {
       throw new IllegalArgumentException(); // TODO: ProtocolException?
     }
-    List<Challenge> challenges = parseChallenges(responseHeaders, responseField);
-    if (challenges.isEmpty()) {
-      return false; // Could not find a challenge so end the request cycle.
-    }
-    Credential credential = responseHeaders.getResponseCode() == HTTP_PROXY_AUTH
-        ? authenticator.authenticateProxy(proxy, url, challenges)
-        : authenticator.authenticate(proxy, url, challenges);
-    if (credential == null) {
-      return false; // Could not satisfy the challenge so end the request cycle.
-    }
+    List<Challenge> challenges = parseChallenges(response.headers(), responseField);
+    if (challenges.isEmpty()) return null; // Could not find a challenge so end the request cycle.
+
+    Request request = response.request();
+    Credential credential = response.code() == HTTP_PROXY_AUTH
+        ? authenticator.authenticateProxy(proxy, request.url(), challenges)
+        : authenticator.authenticate(proxy, request.url(), challenges);
+    if (credential == null) return null; // Couldn't satisfy the challenge so end the request cycle.
+
     // Add authorization credentials, bypassing the already-connected check.
-    successorRequestHeaders.set(requestField, credential.getHeaderValue());
-    return true;
+    return request.newBuilder().header(requestField, credential.getHeaderValue()).build();
   }
 
   /**
    * Parse RFC 2617 challenges. This API is only interested in the scheme
    * name and realm.
    */
-  private static List<Challenge> parseChallenges(RawHeaders responseHeaders,
+  private static List<Challenge> parseChallenges(Headers responseHeaders,
       String challengeHeader) {
     // auth-scheme = token
     // auth-param  = token "=" ( token | quoted-string )
@@ -129,11 +130,11 @@ public static boolean processAuthHeader(OkAuthenticator authenticator, int respo
     // realm       = "realm" "=" realm-value
     // realm-value = quoted-string
     List<Challenge> result = new ArrayList<Challenge>();
-    for (int h = 0; h < responseHeaders.length(); h++) {
-      if (!challengeHeader.equalsIgnoreCase(responseHeaders.getFieldName(h))) {
+    for (int h = 0; h < responseHeaders.size(); h++) {
+      if (!challengeHeader.equalsIgnoreCase(responseHeaders.name(h))) {
         continue;
       }
-      String value = responseHeaders.getValue(h);
+      String value = responseHeaders.value(h);
       int pos = 0;
       while (pos < value.length()) {
         int tokenStart = pos;
@@ -146,7 +147,7 @@ public static boolean processAuthHeader(OkAuthenticator authenticator, int respo
         //       It needs to be fixed to handle any scheme and any parameters
         //       http://code.google.com/p/android/issues/detail?id=11140
 
-        if (!value.regionMatches(pos, "realm=\"", 0, "realm=\"".length())) {
+        if (!value.regionMatches(true, pos, "realm=\"", 0, "realm=\"".length())) {
           break; // Unexpected challenge parameter; give up!
         }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
index 8275958293..bc8407e572 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
@@ -26,7 +26,7 @@
 /**
  * Best-effort parser for HTTP dates.
  */
-final class HttpDate {
+public final class HttpDate {
 
   /**
    * Most websites serve cookies in the blessed format. Eagerly create the parser to ensure such
@@ -36,7 +36,7 @@
       new ThreadLocal<DateFormat>() {
         @Override protected DateFormat initialValue() {
           DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-          rfc1123.setTimeZone(TimeZone.getTimeZone("UTC"));
+          rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
           return rfc1123;
         }
       };
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index 8efe56f405..b1f35c6ce2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -19,38 +19,37 @@
 
 import com.squareup.okhttp.Address;
 import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.OkResponseCache;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseSource;
+import com.squareup.okhttp.Route;
 import com.squareup.okhttp.TunnelRequest;
 import com.squareup.okhttp.internal.Dns;
-import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.CacheRequest;
-import java.net.CacheResponse;
 import java.net.CookieHandler;
-import java.net.HttpURLConnection;
-import java.net.Proxy;
-import java.net.URI;
-import java.net.URISyntaxException;
+import java.net.ProtocolException;
 import java.net.URL;
 import java.net.UnknownHostException;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
+import java.security.cert.CertificateException;
 import java.util.List;
 import java.util.Map;
 import java.util.zip.GZIPInputStream;
 import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocketFactory;
 
-import static com.squareup.okhttp.internal.Util.EMPTY_BYTE_ARRAY;
+import static com.squareup.okhttp.internal.Util.closeQuietly;
 import static com.squareup.okhttp.internal.Util.getDefaultPort;
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
+import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
 
 /**
  * Handles a single HTTP request/response pair. Each HTTP engine follows this
@@ -76,63 +75,51 @@
  * required, use {@link #automaticallyReleaseConnectionToPool()}.
  */
 public class HttpEngine {
-  private static final CacheResponse GATEWAY_TIMEOUT_RESPONSE = new CacheResponse() {
-    @Override public Map<String, List<String>> getHeaders() throws IOException {
-      Map<String, List<String>> result = new HashMap<String, List<String>>();
-      result.put(null, Collections.singletonList("HTTP/1.1 504 Gateway Timeout"));
-      return result;
-    }
-    @Override public InputStream getBody() throws IOException {
-      return new ByteArrayInputStream(EMPTY_BYTE_ARRAY);
-    }
-  };
-  public static final int HTTP_CONTINUE = 100;
-  public static final long SEC2NS = 1000 * 1000 * 1000;
-
-  protected final Policy policy;
-  protected final OkHttpClient client;
-
-  protected final String method;
-
-  private ResponseSource responseSource;
+  final OkHttpClient client;
 
-  protected Connection connection;
-  protected RouteSelector routeSelector;
-  private OutputStream requestBodyOut;
+  private Connection connection;
+  private RouteSelector routeSelector;
+  private Route route;
 
   private Transport transport;
 
-  private InputStream responseTransferIn;
-  private InputStream responseBodyIn;
-
-  private CacheResponse cacheResponse;
-  private CacheRequest cacheRequest;
-
   /** The time when the request headers were written, or -1 if they haven't been written yet. */
   long sentRequestMillis = -1;
 
-  /** Whether the connection has been established. */
-  boolean connected;
-
   /**
    * True if this client added an "Accept-Encoding: gzip" header field and is
    * therefore responsible for also decompressing the transfer stream.
    */
   private boolean transparentGzip;
 
-  final URI uri;
+  /**
+   * True if the request body must be completely buffered before transmission;
+   * false if it can be streamed. Buffering has two advantages: we don't need
+   * the content-length in advance and we can retransmit if necessary. The
+   * upside of streaming is that we can save memory.
+   */
+  public final boolean bufferRequestBody;
 
-  final RequestHeaders requestHeaders;
+  private Request request;
+  private OutputStream requestBodyOut;
+
+  private ResponseSource responseSource;
 
   /** Null until a response is received from the network or the cache. */
-  ResponseHeaders responseHeaders;
+  private Response response;
+  private InputStream responseTransferIn;
+  private InputStream responseBodyIn;
 
-  // The cache response currently being validated on a conditional get. Null
-  // if the cached response doesn't exist or doesn't need validation. If the
-  // conditional get succeeds, these will be used for the response headers and
-  // body. If it fails, these be closed and set to null.
-  private ResponseHeaders cachedResponseHeaders;
-  private InputStream cachedResponseBody;
+  /**
+   * The cache response currently being validated on a conditional get. Null
+   * if the cached response doesn't exist or doesn't need validation. If the
+   * conditional get succeeds, these will be used for the response. If it fails,
+   * it will be set to null.
+   */
+  private Response validatingResponse;
+
+  /** The cache request currently being populated from a network response. */
+  private CacheRequest cacheRequest;
 
   /**
    * True if the socket connection should be released to the connection pool
@@ -151,25 +138,15 @@
    *     redirect. This engine assumes ownership of the connection and must
    *     release it when it is unneeded.
    */
-  public HttpEngine(OkHttpClient client, Policy policy, String method, RawHeaders requestHeaders,
-      Connection connection, RetryableOutputStream requestBodyOut) throws IOException {
+  public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
+      Connection connection, RouteSelector routeSelector, RetryableOutputStream requestBodyOut) {
     this.client = client;
-    this.policy = policy;
-    this.method = method;
+    this.request = request;
+    this.bufferRequestBody = bufferRequestBody;
     this.connection = connection;
+    this.routeSelector = routeSelector;
+    this.route = connection != null ? connection.getRoute() : null;
     this.requestBodyOut = requestBodyOut;
-
-    try {
-      uri = Platform.get().toUriLenient(policy.getURL());
-    } catch (URISyntaxException e) {
-      throw new IOException(e.getMessage());
-    }
-
-    this.requestHeaders = new RequestHeaders(uri, new RawHeaders(requestHeaders));
-  }
-
-  public URI getUri() {
-    return uri;
   }
 
   /**
@@ -178,140 +155,107 @@ public URI getUri() {
    * writing the request body if it exists.
    */
   public final void sendRequest() throws IOException {
-    if (responseSource != null) {
-      return;
-    }
+    if (responseSource != null) return; // Already sent.
+    if (transport != null) throw new IllegalStateException();
 
     prepareRawRequestHeaders();
-    initResponseSource();
     OkResponseCache responseCache = client.getOkResponseCache();
+
+    Response cacheResponse = responseCache != null
+        ? responseCache.get(request)
+        : null;
+    long now = System.currentTimeMillis();
+    CacheStrategy cacheStrategy = new CacheStrategy.Factory(now, request, cacheResponse).get();
+    responseSource = cacheStrategy.source;
+    request = cacheStrategy.request;
+
     if (responseCache != null) {
       responseCache.trackResponse(responseSource);
     }
 
-    // The raw response source may require the network, but the request
-    // headers may forbid network use. In that case, dispose of the network
-    // response and use a GATEWAY_TIMEOUT response instead, as specified
-    // by http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.4.
-    if (requestHeaders.isOnlyIfCached() && responseSource.requiresConnection()) {
-      if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-        Util.closeQuietly(cachedResponseBody);
-      }
-      this.responseSource = ResponseSource.CACHE;
-      this.cacheResponse = GATEWAY_TIMEOUT_RESPONSE;
-      RawHeaders rawResponseHeaders = RawHeaders.fromMultimap(cacheResponse.getHeaders(), true);
-      setResponse(new ResponseHeaders(uri, rawResponseHeaders), cacheResponse.getBody());
+    if (responseSource != ResponseSource.NETWORK) {
+      validatingResponse = cacheStrategy.response;
     }
 
-    if (responseSource.requiresConnection()) {
-      sendSocketRequest();
-    } else if (connection != null) {
-      client.getConnectionPool().recycle(connection);
-      connection = null;
+    if (cacheResponse != null && !responseSource.usesCache()) {
+      closeQuietly(cacheResponse.body()); // We don't need this cached response. Close it.
     }
-  }
 
-  /**
-   * Initialize the source for this response. It may be corrected later if the
-   * request headers forbids network use.
-   */
-  private void initResponseSource() throws IOException {
-    responseSource = ResponseSource.NETWORK;
-    if (!policy.getUseCaches()) return;
-
-    OkResponseCache responseCache = client.getOkResponseCache();
-    if (responseCache == null) return;
+    if (responseSource.requiresConnection()) {
+      // Open a connection unless we inherited one from a redirect.
+      if (connection == null) {
+        connect();
+      }
 
-    CacheResponse candidate = responseCache.get(
-        uri, method, requestHeaders.getHeaders().toMultimap(false));
-    if (candidate == null) return;
+      transport = (Transport) connection.newTransport(this);
 
-    Map<String, List<String>> responseHeadersMap = candidate.getHeaders();
-    cachedResponseBody = candidate.getBody();
-    if (!acceptCacheResponseType(candidate)
-        || responseHeadersMap == null
-        || cachedResponseBody == null) {
-      Util.closeQuietly(cachedResponseBody);
-      return;
-    }
+      // Create a request body if we don't have one already. We'll already have
+      // one if we're retrying a failed POST.
+      if (hasRequestBody() && requestBodyOut == null) {
+        requestBodyOut = transport.createRequestBody(request);
+      }
 
-    RawHeaders rawResponseHeaders = RawHeaders.fromMultimap(responseHeadersMap, true);
-    cachedResponseHeaders = new ResponseHeaders(uri, rawResponseHeaders);
-    long now = System.currentTimeMillis();
-    this.responseSource = cachedResponseHeaders.chooseResponseSource(now, requestHeaders);
-    if (responseSource == ResponseSource.CACHE) {
-      this.cacheResponse = candidate;
-      setResponse(cachedResponseHeaders, cachedResponseBody);
-    } else if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-      this.cacheResponse = candidate;
-    } else if (responseSource == ResponseSource.NETWORK) {
-      Util.closeQuietly(cachedResponseBody);
     } else {
-      throw new AssertionError();
-    }
-  }
-
-  private void sendSocketRequest() throws IOException {
-    if (connection == null) {
-      connect();
-    }
+      // We're using a cached response. Close the connection we may have inherited from a redirect.
+      if (connection != null) {
+        disconnect();
+      }
 
-    if (transport != null) {
-      throw new IllegalStateException();
+      // No need for the network! Promote the cached response immediately.
+      this.response = validatingResponse;
+      if (validatingResponse.body() != null) {
+        initContentStream(validatingResponse.body().byteStream());
+      }
     }
+  }
 
-    transport = (Transport) connection.newTransport(this);
-
-    if (hasRequestBody() && requestBodyOut == null) {
-      // Create a request body if we don't have one already. We'll already
-      // have one if we're retrying a failed POST.
-      requestBodyOut = transport.createRequestBody();
-    }
+  private Response cacheableResponse() {
+    // Use an unreadable response body when offering the response to the cache.
+    // The cache isn't allowed to consume the response body bytes!
+    return response.newBuilder().body(null).build();
   }
 
   /** Connect to the origin server either directly or via a proxy. */
-  protected final void connect() throws IOException {
-    if (connection != null) {
-      return;
-    }
+  private void connect() throws IOException {
+    if (connection != null) throw new IllegalStateException();
+
     if (routeSelector == null) {
-      String uriHost = uri.getHost();
-      if (uriHost == null) {
-        throw new UnknownHostException(uri.toString());
+      String uriHost = request.url().getHost();
+      if (uriHost == null || uriHost.length() == 0) {
+        throw new UnknownHostException(request.url().toString());
       }
       SSLSocketFactory sslSocketFactory = null;
       HostnameVerifier hostnameVerifier = null;
-      if (uri.getScheme().equalsIgnoreCase("https")) {
+      if (request.isHttps()) {
         sslSocketFactory = client.getSslSocketFactory();
         hostnameVerifier = client.getHostnameVerifier();
       }
-      Address address = new Address(uriHost, getEffectivePort(uri), sslSocketFactory,
-          hostnameVerifier, client.getAuthenticator(), client.getProxy(), client.getTransports());
-      routeSelector = new RouteSelector(address, uri, client.getProxySelector(),
+      Address address = new Address(uriHost, getEffectivePort(request.url()), sslSocketFactory,
+          hostnameVerifier, client.getAuthenticator(), client.getProxy(), client.getProtocols());
+      routeSelector = new RouteSelector(address, request.uri(), client.getProxySelector(),
           client.getConnectionPool(), Dns.DEFAULT, client.getRoutesDatabase());
     }
-    connection = routeSelector.next(method);
+
+    connection = routeSelector.next(request.method());
+
     if (!connection.isConnected()) {
       connection.connect(client.getConnectTimeout(), client.getReadTimeout(), getTunnelConfig());
       client.getConnectionPool().maybeShare(connection);
       client.getRoutesDatabase().connected(connection.getRoute());
-    } else {
+    } else if (!connection.isSpdy()) {
       connection.updateReadTimeout(client.getReadTimeout());
     }
-    connected(connection);
-    if (connection.getRoute().getProxy() != client.getProxy()) {
-      // Update the request line if the proxy changed; it may need a host name.
-      requestHeaders.getHeaders().setRequestLine(getRequestLine());
-    }
+
+    route = connection.getRoute();
   }
 
   /**
    * Called after a socket connection has been created or retrieved from the
    * pool. Subclasses use this hook to get a reference to the TLS data.
    */
-  protected void connected(Connection connection) {
-    policy.setSelectedProxy(connection.getRoute().getProxy());
-    connected = true;
+  private void disconnect() {
+    client.getConnectionPool().recycle(connection);
+    connection = null;
   }
 
   /**
@@ -319,124 +263,101 @@ protected void connected(Connection connection) {
    * This is used to observe the sent time should the request be cached.
    */
   public void writingRequestHeaders() {
-    if (sentRequestMillis != -1) {
-      throw new IllegalStateException();
-    }
+    if (sentRequestMillis != -1) throw new IllegalStateException();
     sentRequestMillis = System.currentTimeMillis();
   }
 
-  /**
-   * @param body the response body, or null if it doesn't exist or isn't
-   * available.
-   */
-  private void setResponse(ResponseHeaders headers, InputStream body) throws IOException {
-    if (this.responseBodyIn != null) {
-      throw new IllegalStateException();
-    }
-    this.responseHeaders = headers;
-    // if connection is not SPDY, search headers for Keep-Alive, parse and set timeout
-    if (connection != null && !connection.isSpdy()) {
-      String keepAliveHeader = headers.getHeaders().get("Keep-Alive");
-      if (keepAliveHeader != null) {    // parse header
-        // we only care about the timeout, the server will issue
-        // "Connection: Close" on the last allowable request, so we do
-        // not need to handle max
-        int i = keepAliveHeader.indexOf("timeout");
-        if (i > -1) {
-          int j = keepAliveHeader.indexOf(' ', i + 8);
-          String timeoutStr;
-          if (j > -1) {
-            timeoutStr = keepAliveHeader.substring(i + 8, j);
-          } else {
-            timeoutStr = keepAliveHeader.substring(i + 8);
-          }
-          try {
-            connection.setKeepAliveDurationNs(Integer.decode(timeoutStr) * SEC2NS);
-          } catch (NumberFormatException e) {
-            //Log.w("OkHTTP","failed to parse string ("+timeoutStr+") as integer", e);
-          }
-        }
-      }
-    }
-    if (body != null) {
-      initContentStream(body);
-    }
-  }
-
   boolean hasRequestBody() {
-    return method.equals("POST") || method.equals("PUT");
+    String method = request.method();
+    return method.equals("POST") || method.equals("PUT") || method.equals("PATCH");
   }
 
   /** Returns the request body or null if this request doesn't have a body. */
   public final OutputStream getRequestBody() {
-    if (responseSource == null) {
-      throw new IllegalStateException();
-    }
+    if (responseSource == null) throw new IllegalStateException();
     return requestBodyOut;
   }
 
   public final boolean hasResponse() {
-    return responseHeaders != null;
+    return response != null;
   }
 
-  public final RequestHeaders getRequestHeaders() {
-    return requestHeaders;
+  public final Request getRequest() {
+    return request;
   }
 
-  public final ResponseHeaders getResponseHeaders() {
-    if (responseHeaders == null) {
-      throw new IllegalStateException();
-    }
-    return responseHeaders;
-  }
-
-  public final int getResponseCode() {
-    if (responseHeaders == null) {
-      throw new IllegalStateException();
-    }
-    return responseHeaders.getHeaders().getResponseCode();
+  /** Returns the engine's response. */
+  // TODO: the returned body will always be null.
+  public final Response getResponse() {
+    if (response == null) throw new IllegalStateException();
+    return response;
   }
 
   public final InputStream getResponseBody() {
-    if (responseHeaders == null) {
-      throw new IllegalStateException();
-    }
+    if (response == null) throw new IllegalStateException();
     return responseBodyIn;
   }
 
-  public final CacheResponse getCacheResponse() {
-    return cacheResponse;
-  }
-
   public final Connection getConnection() {
     return connection;
   }
 
+  /**
+   * Report and attempt to recover from {@code e}. Returns a new HTTP engine
+   * that should be used for the retry if {@code e} is recoverable, or null if
+   * the failure is permanent.
+   */
+  public HttpEngine recover(IOException e) {
+    if (routeSelector != null && connection != null) {
+      routeSelector.connectFailed(connection, e);
+    }
+
+    boolean canRetryRequestBody = requestBodyOut == null
+        || requestBodyOut instanceof RetryableOutputStream;
+    if (routeSelector == null && connection == null // No connection.
+        || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
+        || !isRecoverable(e)
+        || !canRetryRequestBody) {
+      return null;
+    }
+
+    release(true);
+
+    // For failure recovery, use the same route selector with a new connection.
+    return new HttpEngine(client, request, bufferRequestBody, null, routeSelector,
+        (RetryableOutputStream) requestBodyOut);
+  }
+
+  private boolean isRecoverable(IOException e) {
+    // If the problem was a CertificateException from the X509TrustManager,
+    // do not retry, we didn't have an abrupt server-initiated exception.
+    boolean sslFailure =
+        e instanceof SSLHandshakeException && e.getCause() instanceof CertificateException;
+    boolean protocolFailure = e instanceof ProtocolException;
+    return !sslFailure && !protocolFailure;
+  }
+
   /**
    * Returns true if {@code cacheResponse} is of the right type. This
    * condition is necessary but not sufficient for the cached response to
    * be used.
    */
-  protected boolean acceptCacheResponseType(CacheResponse cacheResponse) {
-    return true;
+  public Route getRoute() {
+    return route;
   }
 
   private void maybeCache() throws IOException {
-    // Are we caching at all?
-    if (!policy.getUseCaches()) return;
     OkResponseCache responseCache = client.getOkResponseCache();
     if (responseCache == null) return;
 
-    HttpURLConnection connectionToCache = policy.getHttpConnectionToCache();
-
     // Should we cache this response for this request?
-    if (!responseHeaders.isCacheable(requestHeaders)) {
-      responseCache.maybeRemove(connectionToCache.getRequestMethod(), uri);
+    if (!CacheStrategy.isCacheable(response, request)) {
+      responseCache.maybeRemove(request);
       return;
     }
 
     // Offer this request to the cache.
-    cacheRequest = responseCache.put(uri, connectionToCache);
+    cacheRequest = responseCache.put(cacheableResponse());
   }
 
   /**
@@ -448,8 +369,7 @@ private void maybeCache() throws IOException {
   public final void automaticallyReleaseConnectionToPool() {
     automaticallyReleaseConnectionToPool = true;
     if (connection != null && connectionReleased) {
-      client.getConnectionPool().recycle(connection);
-      connection = null;
+      disconnect();
     }
   }
 
@@ -460,36 +380,48 @@ public final void automaticallyReleaseConnectionToPool() {
    */
   public final void release(boolean streamCanceled) {
     // If the response body comes from the cache, close it.
-    if (responseBodyIn == cachedResponseBody) {
-      Util.closeQuietly(responseBodyIn);
+    if (validatingResponse != null
+        && validatingResponse.body() != null
+        && responseBodyIn == validatingResponse.body().byteStream()) {
+      closeQuietly(responseBodyIn);
     }
 
-    if (!connectionReleased && connection != null) {
+    if (connection != null && !connectionReleased) {
       connectionReleased = true;
 
       if (transport == null
           || !transport.makeReusable(streamCanceled, requestBodyOut, responseTransferIn)) {
-        Util.closeQuietly(connection);
+        closeQuietly(connection);
         connection = null;
       } else if (automaticallyReleaseConnectionToPool) {
-        client.getConnectionPool().recycle(connection);
-        connection = null;
+        disconnect();
       }
     }
   }
 
+  /**
+   * Initialize the response content stream from the response transfer stream.
+   * These two streams are the same unless we're doing transparent gzip, in
+   * which case the content stream is decompressed.
+   *
+   * <p>Whenever we do transparent gzip we also strip the corresponding headers.
+   * We strip the Content-Encoding header to prevent the application from
+   * attempting to double decompress. We strip the Content-Length header because
+   * it is the length of the compressed content, but the application is only
+   * interested in the length of the uncompressed content.
+   *
+   * <p>This method should only be used for non-empty response bodies. Response
+   * codes like "304 Not Modified" can include "Content-Encoding: gzip" without
+   * a response body and we will crash if we attempt to decompress the zero-byte
+   * stream.
+   */
   private void initContentStream(InputStream transferStream) throws IOException {
     responseTransferIn = transferStream;
-    if (transparentGzip && responseHeaders.isContentEncodingGzip()) {
-      // If the response was transparently gzipped, remove the gzip header field
-      // so clients don't double decompress. http://b/3009828
-      //
-      // Also remove the Content-Length in this case because it contains the
-      // length 528 of the gzipped response. This isn't terribly useful and is
-      // dangerous because 529 clients can query the content length, but not
-      // the content encoding.
-      responseHeaders.stripContentEncoding();
-      responseHeaders.stripContentLength();
+    if (transparentGzip && "gzip".equalsIgnoreCase(response.header("Content-Encoding"))) {
+      response = response.newBuilder()
+          .removeHeader("Content-Encoding")
+          .removeHeader("Content-Length")
+          .build();
       responseBodyIn = new GZIPInputStream(transferStream);
     } else {
       responseBodyIn = transferStream;
@@ -501,23 +433,23 @@ private void initContentStream(InputStream transferStream) throws IOException {
    * See RFC 2616 section 4.3.
    */
   public final boolean hasResponseBody() {
-    int responseCode = responseHeaders.getHeaders().getResponseCode();
-
     // HEAD requests never yield a body regardless of the response headers.
-    if (method.equals("HEAD")) {
+    if (request.method().equals("HEAD")) {
       return false;
     }
 
+    int responseCode = response.code();
     if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
-        && responseCode != HttpURLConnectionImpl.HTTP_NO_CONTENT
-        && responseCode != HttpURLConnectionImpl.HTTP_NOT_MODIFIED) {
+        && responseCode != HTTP_NO_CONTENT
+        && responseCode != HTTP_NOT_MODIFIED) {
       return true;
     }
 
     // If the Content-Length or Transfer-Encoding headers disagree with the
     // response code, the response is malformed. For best compatibility, we
     // honor the headers.
-    if (responseHeaders.getContentLength() != -1 || responseHeaders.isChunked()) {
+    if (OkHeaders.contentLength(response) != -1
+        || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
       return true;
     }
 
@@ -531,90 +463,38 @@ public final boolean hasResponseBody() {
    * doesn't know what content types the application is interested in.
    */
   private void prepareRawRequestHeaders() throws IOException {
-    requestHeaders.getHeaders().setRequestLine(getRequestLine());
+    Request.Builder result = request.newBuilder();
 
-    if (requestHeaders.getUserAgent() == null) {
-      requestHeaders.setUserAgent(getDefaultUserAgent());
+    if (request.getUserAgent() == null) {
+      result.setUserAgent(getDefaultUserAgent());
     }
 
-    if (requestHeaders.getHost() == null) {
-      requestHeaders.setHost(getOriginAddress(policy.getURL()));
+    if (request.header("Host") == null) {
+      result.header("Host", hostHeader(request.url()));
     }
 
     if ((connection == null || connection.getHttpMinorVersion() != 0)
-        && requestHeaders.getConnection() == null) {
-      requestHeaders.setConnection("Keep-Alive");
+        && request.header("Connection") == null) {
+      result.header("Connection", "Keep-Alive");
     }
 
-    if (requestHeaders.getAcceptEncoding() == null) {
+    if (request.header("Accept-Encoding") == null) {
       transparentGzip = true;
-      requestHeaders.setAcceptEncoding("gzip");
-    }
-
-    if (hasRequestBody() && requestHeaders.getContentType() == null) {
-      requestHeaders.setContentType("application/x-www-form-urlencoded");
+      result.header("Accept-Encoding", "gzip");
     }
 
-    long ifModifiedSince = policy.getIfModifiedSince();
-    if (ifModifiedSince != 0) {
-      requestHeaders.setIfModifiedSince(new Date(ifModifiedSince));
+    if (hasRequestBody() && request.header("Content-Type") == null) {
+      result.header("Content-Type", "application/x-www-form-urlencoded");
     }
 
     CookieHandler cookieHandler = client.getCookieHandler();
     if (cookieHandler != null) {
-      requestHeaders.addCookies(
-          cookieHandler.get(uri, requestHeaders.getHeaders().toMultimap(false)));
-    }
-  }
-
-  /**
-   * Returns the request status line, like "GET / HTTP/1.1". This is exposed
-   * to the application by {@link HttpURLConnectionImpl#getHeaderFields}, so
-   * it needs to be set even if the transport is SPDY.
-   */
-  String getRequestLine() {
-    String protocol =
-        (connection == null || connection.getHttpMinorVersion() != 0) ? "HTTP/1.1" : "HTTP/1.0";
-    return method + " " + requestString() + " " + protocol;
-  }
-
-  private String requestString() {
-    URL url = policy.getURL();
-    if (includeAuthorityInRequestLine()) {
-      return url.toString();
-    } else {
-      return requestPath(url);
-    }
-  }
-
-  /**
-   * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never
-   * empty, even if the request URL is. Includes the query component if it
-   * exists.
-   */
-  public static String requestPath(URL url) {
-    String fileOnly = url.getFile();
-    if (fileOnly == null) {
-      return "/";
-    } else if (!fileOnly.startsWith("/")) {
-      return "/" + fileOnly;
-    } else {
-      return fileOnly;
+      Map<String, List<String>> cookies = cookieHandler.get(
+          request.uri(), OkHeaders.toMultimap(request.getHeaders(), null));
+      OkHeaders.addCookies(result, cookies);
     }
-  }
 
-  /**
-   * Returns true if the request line should contain the full URL with host
-   * and port (like "GET http://android.com/foo HTTP/1.1") or only the path
-   * (like "GET /foo HTTP/1.1").
-   *
-   * <p>This is non-final because for HTTPS it's never necessary to supply the
-   * full URL, even if a proxy is in use.
-   */
-  protected boolean includeAuthorityInRequestLine() {
-    return connection == null
-        ? policy.usingProxy() // A proxy was requested.
-        : connection.getRoute().getProxy().type() == Proxy.Type.HTTP; // A proxy was selected.
+    request = result.build();
   }
 
   public static String getDefaultUserAgent() {
@@ -622,13 +502,10 @@ public static String getDefaultUserAgent() {
     return agent != null ? agent : ("Java" + System.getProperty("java.version"));
   }
 
-  public static String getOriginAddress(URL url) {
-    int port = url.getPort();
-    String result = url.getHost();
-    if (port > 0 && port != getDefaultPort(url.getProtocol())) {
-      result = result + ":" + port;
-    }
-    return result;
+  public static String hostHeader(URL url) {
+    return getEffectivePort(url) != getDefaultPort(url.getProtocol())
+        ? url.getHost() + ":" + url.getPort()
+        : url.getHost();
   }
 
   /**
@@ -636,25 +513,20 @@ public static String getOriginAddress(URL url) {
    * headers and starts reading the HTTP response body if it exists.
    */
   public final void readResponse() throws IOException {
-    if (hasResponse()) {
-      responseHeaders.setResponseSource(responseSource);
-      return;
-    }
-
-    if (responseSource == null) {
-      throw new IllegalStateException("readResponse() without sendRequest()");
-    }
-
-    if (!responseSource.requiresConnection()) {
-      return;
-    }
+    if (response != null) return;
+    if (responseSource == null) throw new IllegalStateException("call sendRequest() first!");
+    if (!responseSource.requiresConnection()) return;
 
     if (sentRequestMillis == -1) {
-      if (requestBodyOut instanceof RetryableOutputStream) {
-        int contentLength = ((RetryableOutputStream) requestBodyOut).contentLength();
-        requestHeaders.setContentLength(contentLength);
+      if (OkHeaders.contentLength(request) == -1
+          && requestBodyOut instanceof RetryableOutputStream) {
+        // We might not learn the Content-Length until the request body has been buffered.
+        long contentLength = ((RetryableOutputStream) requestBodyOut).contentLength();
+        request = request.newBuilder()
+            .header("Content-Length", Long.toString(contentLength))
+            .build();
       }
-      transport.writeRequestHeaders();
+      transport.writeRequestHeaders(request);
     }
 
     if (requestBodyOut != null) {
@@ -666,46 +538,107 @@ public final void readResponse() throws IOException {
 
     transport.flushRequest();
 
-    responseHeaders = transport.readResponseHeaders();
-    responseHeaders.setLocalTimestamps(sentRequestMillis, System.currentTimeMillis());
-    responseHeaders.setResponseSource(responseSource);
+    response = transport.readResponseHeaders()
+        .request(request)
+        .handshake(connection.getHandshake())
+        .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
+        .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
+        .setResponseSource(responseSource)
+        .build();
+    connection.setHttpMinorVersion(response.httpMinorVersion());
+    receiveHeaders(response.headers());
 
     if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-      if (cachedResponseHeaders.validate(responseHeaders)) {
+      if (validatingResponse.validate(response)) {
         release(false);
-        ResponseHeaders combinedHeaders = cachedResponseHeaders.combine(responseHeaders);
-        this.responseHeaders = combinedHeaders;
+        response = combine(validatingResponse, response);
 
-        // Update the cache after applying the combined headers but before initializing the content
-        // stream, otherwise the Content-Encoding header (if present) will be stripped from the
-        // combined headers and not end up in the cache file if transparent gzip compression is
-        // turned on.
+        // Update the cache after combining headers but before stripping the
+        // Content-Encoding header (as performed by initContentStream()).
         OkResponseCache responseCache = client.getOkResponseCache();
         responseCache.trackConditionalCacheHit();
-        responseCache.update(cacheResponse, policy.getHttpConnectionToCache());
+        responseCache.update(validatingResponse, cacheableResponse());
 
-        initContentStream(cachedResponseBody);
+        if (validatingResponse.body() != null) {
+          initContentStream(validatingResponse.body().byteStream());
+        }
         return;
       } else {
-        Util.closeQuietly(cachedResponseBody);
+        closeQuietly(validatingResponse.body());
       }
     }
 
-    if (hasResponseBody()) {
-      maybeCache(); // reentrant. this calls into user code which may call back into this!
+    if (!hasResponseBody()) {
+      // Don't call initContentStream() when the response doesn't have any content.
+      responseTransferIn = transport.getTransferStream(cacheRequest);
+      responseBodyIn = responseTransferIn;
+      return;
     }
 
+    maybeCache();
     initContentStream(transport.getTransferStream(cacheRequest));
   }
 
-  protected TunnelRequest getTunnelConfig() {
-    return null;
+  /**
+   * Combines cached headers with a network headers as defined by RFC 2616,
+   * 13.5.3.
+   */
+  private static Response combine(Response cached, Response network) throws IOException {
+    Headers.Builder result = new Headers.Builder();
+
+    Headers cachedHeaders = cached.headers();
+    for (int i = 0; i < cachedHeaders.size(); i++) {
+      String fieldName = cachedHeaders.name(i);
+      String value = cachedHeaders.value(i);
+      if ("Warning".equals(fieldName) && value.startsWith("1")) {
+        continue; // drop 100-level freshness warnings
+      }
+      if (!isEndToEnd(fieldName) || network.header(fieldName) == null) {
+        result.add(fieldName, value);
+      }
+    }
+
+    Headers networkHeaders = network.headers();
+    for (int i = 0; i < networkHeaders.size(); i++) {
+      String fieldName = networkHeaders.name(i);
+      if (isEndToEnd(fieldName)) {
+        result.add(fieldName, networkHeaders.value(i));
+      }
+    }
+
+    return cached.newBuilder().headers(result.build()).build();
+  }
+
+  /**
+   * Returns true if {@code fieldName} is an end-to-end HTTP header, as
+   * defined by RFC 2616, 13.5.1.
+   */
+  private static boolean isEndToEnd(String fieldName) {
+    return !"Connection".equalsIgnoreCase(fieldName)
+        && !"Keep-Alive".equalsIgnoreCase(fieldName)
+        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
+        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
+        && !"TE".equalsIgnoreCase(fieldName)
+        && !"Trailers".equalsIgnoreCase(fieldName)
+        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
+        && !"Upgrade".equalsIgnoreCase(fieldName);
+  }
+
+  private TunnelRequest getTunnelConfig() {
+    if (!request.isHttps()) return null;
+
+    String userAgent = request.getUserAgent();
+    if (userAgent == null) userAgent = getDefaultUserAgent();
+
+    URL url = request.url();
+    return new TunnelRequest(url.getHost(), getEffectivePort(url), userAgent,
+        request.getProxyAuthorization());
   }
 
-  public void receiveHeaders(RawHeaders headers) throws IOException {
+  public void receiveHeaders(Headers headers) throws IOException {
     CookieHandler cookieHandler = client.getCookieHandler();
     if (cookieHandler != null) {
-      cookieHandler.put(uri, headers.toMultimap(true));
+      cookieHandler.put(request.uri(), OkHeaders.toMultimap(headers, null));
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
index f8f9f17266..caf512858a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
@@ -17,6 +17,10 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.AbstractOutputStream;
 import com.squareup.okhttp.internal.Util;
 import java.io.ByteArrayOutputStream;
@@ -28,15 +32,9 @@
 import java.net.Socket;
 
 import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
 
 public final class HttpTransport implements Transport {
-  /**
-   * The timeout to use while discarding a stream of input data. Since this is
-   * used for connection reuse, this timeout should be significantly less than
-   * the time it takes to establish a new connection.
-   */
-  private static final int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
-
   public static final int DEFAULT_CHUNK_LENGTH = 1024;
 
   private final HttpEngine httpEngine;
@@ -58,49 +56,41 @@ public HttpTransport(HttpEngine httpEngine, OutputStream outputStream, InputStre
     this.socketIn = inputStream;
   }
 
-  @Override public OutputStream createRequestBody() throws IOException {
-    boolean chunked = httpEngine.requestHeaders.isChunked();
-    if (!chunked
-        && httpEngine.policy.getChunkLength() > 0
-        && httpEngine.connection.getHttpMinorVersion() != 0) {
-      httpEngine.requestHeaders.setChunked();
-      chunked = true;
-    }
+  @Override public OutputStream createRequestBody(Request request) throws IOException {
+    long contentLength = OkHeaders.contentLength(request);
 
-    // Stream a request body of unknown length.
-    if (chunked) {
-      int chunkLength = httpEngine.policy.getChunkLength();
-      if (chunkLength == -1) {
-        chunkLength = DEFAULT_CHUNK_LENGTH;
+    if (httpEngine.bufferRequestBody) {
+      if (contentLength > Integer.MAX_VALUE) {
+        throw new IllegalStateException("Use setFixedLengthStreamingMode() or "
+            + "setChunkedStreamingMode() for requests larger than 2 GiB.");
       }
-      writeRequestHeaders();
-      return new ChunkedOutputStream(requestOut, chunkLength);
-    }
 
-    // Stream a request body of a known length.
-    long fixedContentLength = httpEngine.policy.getFixedContentLength();
-    if (fixedContentLength != -1) {
-      httpEngine.requestHeaders.setContentLength(fixedContentLength);
-      writeRequestHeaders();
-      return new FixedLengthOutputStream(requestOut, fixedContentLength);
+      if (contentLength != -1) {
+        // Buffer a request body of a known length.
+        writeRequestHeaders(request);
+        return new RetryableOutputStream((int) contentLength);
+      } else {
+        // Buffer a request body of an unknown length. Don't write request
+        // headers until the entire body is ready; otherwise we can't set the
+        // Content-Length header correctly.
+        return new RetryableOutputStream();
+      }
     }
 
-    long contentLength = httpEngine.requestHeaders.getContentLength();
-    if (contentLength > Integer.MAX_VALUE) {
-      throw new IllegalArgumentException("Use setFixedLengthStreamingMode() or "
-          + "setChunkedStreamingMode() for requests larger than 2 GiB.");
+    if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
+      // Stream a request body of unknown length.
+      writeRequestHeaders(request);
+      return new ChunkedOutputStream(requestOut, DEFAULT_CHUNK_LENGTH);
     }
 
-    // Buffer a request body of a known length.
     if (contentLength != -1) {
-      writeRequestHeaders();
-      return new RetryableOutputStream((int) contentLength);
+      // Stream a request body of a known length.
+      writeRequestHeaders(request);
+      return new FixedLengthOutputStream(requestOut, contentLength);
     }
 
-    // Buffer a request body of an unknown length. Don't write request
-    // headers until the entire body is ready; otherwise we can't set the
-    // Content-Length header correctly.
-    return new RetryableOutputStream();
+    throw new IllegalStateException(
+        "Cannot stream a request body without chunked encoding or a known content length!");
   }
 
   @Override public void flushRequest() throws IOException {
@@ -124,21 +114,50 @@ public HttpTransport(HttpEngine httpEngine, OutputStream outputStream, InputStre
    * This ensures that the {@code Content-Length} header field receives the
    * proper value.
    */
-  public void writeRequestHeaders() throws IOException {
+  public void writeRequestHeaders(Request request) throws IOException {
     httpEngine.writingRequestHeaders();
-    RawHeaders headersToSend = httpEngine.requestHeaders.getHeaders();
-    byte[] bytes = headersToSend.toBytes();
-    requestOut.write(bytes);
+    String requestLine = RequestLine.get(request,
+        httpEngine.getConnection().getRoute().getProxy().type(),
+        httpEngine.getConnection().getHttpMinorVersion());
+    writeRequest(requestOut, request.getHeaders(), requestLine);
   }
 
-  @Override public ResponseHeaders readResponseHeaders() throws IOException {
-    RawHeaders rawHeaders = RawHeaders.fromBytes(socketIn);
-    httpEngine.connection.setHttpMinorVersion(rawHeaders.getHttpMinorVersion());
-    httpEngine.receiveHeaders(rawHeaders);
+  @Override public Response.Builder readResponseHeaders() throws IOException {
+    return readResponse(socketIn);
+  }
 
-    ResponseHeaders headers = new ResponseHeaders(httpEngine.uri, rawHeaders);
-    headers.setTransport("http/1.1");
-    return headers;
+  /** Returns bytes of a request header for sending on an HTTP transport. */
+  public static void writeRequest(OutputStream out, Headers headers, String requestLine)
+      throws IOException {
+    StringBuilder result = new StringBuilder(256);
+    result.append(requestLine).append("\r\n");
+    for (int i = 0; i < headers.size(); i ++) {
+      result.append(headers.name(i))
+          .append(": ")
+          .append(headers.value(i))
+          .append("\r\n");
+    }
+    result.append("\r\n");
+    out.write(result.toString().getBytes("ISO-8859-1"));
+  }
+
+  /** Parses bytes of a response header from an HTTP transport. */
+  public static Response.Builder readResponse(InputStream in) throws IOException {
+    while (true) {
+      String statusLineString = Util.readAsciiLine(in);
+      StatusLine statusLine = new StatusLine(statusLineString);
+
+      Response.Builder responseBuilder = new Response.Builder()
+          .statusLine(statusLine)
+          .header(OkHeaders.SELECTED_TRANSPORT, Protocol.HTTP_11.name.utf8())
+          .header(OkHeaders.SELECTED_PROTOCOL, Protocol.HTTP_11.name.utf8());
+
+      Headers.Builder headersBuilder = new Headers.Builder();
+      OkHeaders.readHeaders(headersBuilder, in);
+      responseBuilder.headers(headersBuilder.build());
+
+      if (statusLine.code() != HTTP_CONTINUE) return responseBuilder;
+    }
   }
 
   public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
@@ -153,12 +172,13 @@ public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
     }
 
     // If the request specified that the connection shouldn't be reused, don't reuse it.
-    if (httpEngine.requestHeaders.hasConnectionClose()) {
+    if ("close".equalsIgnoreCase(httpEngine.getRequest().header("Connection"))) {
       return false;
     }
 
     // If the response specified that the connection shouldn't be reused, don't reuse it.
-    if (httpEngine.responseHeaders != null && httpEngine.responseHeaders.hasConnectionClose()) {
+    if (httpEngine.getResponse() != null
+        && "close".equalsIgnoreCase(httpEngine.getResponse().header("Connection"))) {
       return false;
     }
 
@@ -183,7 +203,7 @@ public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
    * reuse.
    */
   private static boolean discardStream(HttpEngine httpEngine, InputStream responseBodyIn) {
-    Connection connection = httpEngine.connection;
+    Connection connection = httpEngine.getConnection();
     if (connection == null) return false;
     Socket socket = connection.getSocket();
     if (socket == null) return false;
@@ -191,7 +211,7 @@ private static boolean discardStream(HttpEngine httpEngine, InputStream response
       int socketTimeout = socket.getSoTimeout();
       socket.setSoTimeout(DISCARD_STREAM_TIMEOUT_MILLIS);
       try {
-        Util.skipAll(responseBodyIn);
+        Util.skipByReading(responseBodyIn, Long.MAX_VALUE, DISCARD_STREAM_TIMEOUT_MILLIS);
         return true;
       } finally {
         socket.setSoTimeout(socketTimeout);
@@ -206,13 +226,13 @@ private static boolean discardStream(HttpEngine httpEngine, InputStream response
       return new FixedLengthInputStream(socketIn, cacheRequest, httpEngine, 0);
     }
 
-    if (httpEngine.responseHeaders.isChunked()) {
+    if ("chunked".equalsIgnoreCase(httpEngine.getResponse().header("Transfer-Encoding"))) {
       return new ChunkedInputStream(socketIn, cacheRequest, this);
     }
 
-    if (httpEngine.responseHeaders.getContentLength() != -1) {
-      return new FixedLengthInputStream(socketIn, cacheRequest, httpEngine,
-          httpEngine.responseHeaders.getContentLength());
+    long contentLength = OkHeaders.contentLength(httpEngine.getResponse());
+    if (contentLength != -1) {
+      return new FixedLengthInputStream(socketIn, cacheRequest, httpEngine, contentLength);
     }
 
     // Wrap the input stream from the connection (rather than just returning
@@ -370,10 +390,10 @@ private void writeBufferedChunkToSocket() throws IOException {
 
   /** An HTTP body with a fixed length specified in advance. */
   private static class FixedLengthInputStream extends AbstractHttpInputStream {
-    private int bytesRemaining;
+    private long bytesRemaining;
 
     public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEngine httpEngine,
-        int length) throws IOException {
+        long length) throws IOException {
       super(is, httpEngine, cacheRequest);
       bytesRemaining = length;
       if (bytesRemaining == 0) {
@@ -387,7 +407,7 @@ public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEng
       if (bytesRemaining == 0) {
         return -1;
       }
-      int read = in.read(buffer, offset, Math.min(count, bytesRemaining));
+      int read = in.read(buffer, offset, (int) Math.min(count, bytesRemaining));
       if (read == -1) {
         unexpectedEndOfInput(); // the server didn't supply the promised content length
         throw new ProtocolException("unexpected end of stream");
@@ -402,7 +422,7 @@ public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEng
 
     @Override public int available() throws IOException {
       checkNotClosed();
-      return bytesRemaining == 0 ? 0 : Math.min(in.available(), bytesRemaining);
+      return bytesRemaining == 0 ? 0 : (int) Math.min(in.available(), bytesRemaining);
     }
 
     @Override public void close() throws IOException {
@@ -419,14 +439,12 @@ public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEng
   /** An HTTP body with alternating chunk sizes and chunk bodies. */
   private static class ChunkedInputStream extends AbstractHttpInputStream {
     private static final int NO_CHUNK_YET = -1;
-    private final HttpTransport transport;
     private int bytesRemainingInChunk = NO_CHUNK_YET;
     private boolean hasMoreChunks = true;
 
     ChunkedInputStream(InputStream is, CacheRequest cacheRequest, HttpTransport transport)
         throws IOException {
       super(is, transport.httpEngine, cacheRequest);
-      this.transport = transport;
     }
 
     @Override public int read(byte[] buffer, int offset, int count) throws IOException {
@@ -469,9 +487,9 @@ private void readChunkSize() throws IOException {
       }
       if (bytesRemainingInChunk == 0) {
         hasMoreChunks = false;
-        RawHeaders rawResponseHeaders = httpEngine.responseHeaders.getHeaders();
-        RawHeaders.readHeaders(transport.socketIn, rawResponseHeaders);
-        httpEngine.receiveHeaders(rawResponseHeaders);
+        Headers.Builder trailersBuilder = new Headers.Builder();
+        OkHeaders.readHeaders(trailersBuilder, in);
+        httpEngine.receiveHeaders(trailersBuilder.build());
         endOfInput();
       }
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
index 3beafb5543..1876772ab5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
@@ -18,7 +18,13 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.Route;
+import com.squareup.okhttp.internal.bytes.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
 import java.io.FileNotFoundException;
@@ -33,15 +39,15 @@
 import java.net.SocketPermission;
 import java.net.URL;
 import java.security.Permission;
-import java.security.cert.CertificateException;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Date;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLHandshakeException;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
 /**
  * This implementation uses HttpEngine to send requests and receive responses.
@@ -53,30 +59,31 @@
  * is <strong>not</strong> used to indicate not whether this URLConnection is
  * currently connected. Instead, it indicates whether a connection has ever been
  * attempted. Once a connection has been attempted, certain properties (request
- * header fields, request method, etc.) are immutable. Test the {@code
- * connection} field on this class for null/non-null to determine of an instance
- * is currently connected to a server.
+ * header fields, request method, etc.) are immutable.
  */
-public class HttpURLConnectionImpl extends HttpURLConnection implements Policy {
-
-  /** Numeric status code, 307: Temporary Redirect. */
-  static final int HTTP_TEMP_REDIRECT = 307;
+public class HttpURLConnectionImpl extends HttpURLConnection {
 
   /**
    * How many redirects should we follow? Chrome follows 21; Firefox, curl,
    * and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.
    */
-  private static final int MAX_REDIRECTS = 20;
+  public static final int MAX_REDIRECTS = 20;
 
   final OkHttpClient client;
 
-  private final RawHeaders rawRequestHeaders = new RawHeaders();
+  private Headers.Builder requestHeaders = new Headers.Builder();
+
   /** Like the superclass field of the same name, but a long and available on all platforms. */
   private long fixedContentLength = -1;
   private int redirectionCount;
   protected IOException httpEngineFailure;
   protected HttpEngine httpEngine;
-  private Proxy selectedProxy;
+
+  /**
+   * The most recently attempted route. This will be null if we haven't sent a
+   * request yet, or if the response comes from a cache.
+   */
+  private Route route;
 
   public HttpURLConnectionImpl(URL url, OkHttpClient client) {
     super(url);
@@ -113,7 +120,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
   @Override public final InputStream getErrorStream() {
     try {
       HttpEngine response = getResponse();
-      if (response.hasResponseBody() && response.getResponseCode() >= HTTP_BAD_REQUEST) {
+      if (response.hasResponseBody() && response.getResponse().code() >= HTTP_BAD_REQUEST) {
         return response.getResponseBody();
       }
       return null;
@@ -128,7 +135,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
    */
   @Override public final String getHeaderField(int position) {
     try {
-      return getResponse().getResponseHeaders().getHeaders().getValue(position);
+      return getResponse().getResponse().headers().value(position);
     } catch (IOException e) {
       return null;
     }
@@ -141,8 +148,8 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
    */
   @Override public final String getHeaderField(String fieldName) {
     try {
-      RawHeaders rawHeaders = getResponse().getResponseHeaders().getHeaders();
-      return fieldName == null ? rawHeaders.getStatusLine() : rawHeaders.get(fieldName);
+      Response response = getResponse().getResponse();
+      return fieldName == null ? response.statusLine() : response.headers().get(fieldName);
     } catch (IOException e) {
       return null;
     }
@@ -150,7 +157,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
 
   @Override public final String getHeaderFieldKey(int position) {
     try {
-      return getResponse().getResponseHeaders().getHeaders().getFieldName(position);
+      return getResponse().getResponse().headers().name(position);
     } catch (IOException e) {
       return null;
     }
@@ -158,7 +165,8 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
 
   @Override public final Map<String, List<String>> getHeaderFields() {
     try {
-      return getResponse().getResponseHeaders().getHeaders().toMultimap(true);
+      Response response = getResponse().getResponse();
+      return OkHeaders.toMultimap(response.headers(), response.statusLine());
     } catch (IOException e) {
       return Collections.emptyMap();
     }
@@ -169,7 +177,11 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
       throw new IllegalStateException(
           "Cannot access request header fields after connection is set");
     }
-    return rawRequestHeaders.toMultimap(false);
+
+    // For the request line property assigned to the null key, just use no proxy and HTTP 1.1.
+    Request request = new Request.Builder().url(getURL()).method(method, null).build();
+    String requestLine = RequestLine.get(request, null, 1);
+    return OkHeaders.toMultimap(requestHeaders.build(), requestLine);
   }
 
   @Override public final InputStream getInputStream() throws IOException {
@@ -219,10 +231,8 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
   }
 
   @Override public final String getRequestProperty(String field) {
-    if (field == null) {
-      return null;
-    }
-    return rawRequestHeaders.get(field);
+    if (field == null) return null;
+    return requestHeaders.get(field);
   }
 
   @Override public void setConnectTimeout(int timeoutMillis) {
@@ -254,31 +264,48 @@ private void initHttpEngine() throws IOException {
         if (method.equals("GET")) {
           // they are requesting a stream to write to. This implies a POST method
           method = "POST";
-        } else if (!method.equals("POST") && !method.equals("PUT")) {
-          // If the request method is neither POST nor PUT, then you're not writing
+        } else if (!method.equals("POST") && !method.equals("PUT") && !method.equals("PATCH")) {
+          // If the request method is neither POST nor PUT nor PATCH, then you're not writing
           throw new ProtocolException(method + " does not support writing");
         }
       }
-      httpEngine = newHttpEngine(method, rawRequestHeaders, null, null);
+      httpEngine = newHttpEngine(method, null, null);
     } catch (IOException e) {
       httpEngineFailure = e;
       throw e;
     }
   }
 
-  @Override public HttpURLConnection getHttpConnectionToCache() {
-    return this;
-  }
+  private HttpEngine newHttpEngine(String method, Connection connection,
+      RetryableOutputStream requestBody) {
+    Request.Builder builder = new Request.Builder()
+        .url(getURL())
+        .method(method, null /* No body; that's passed separately. */);
+    Headers headers = requestHeaders.build();
+    for (int i = 0; i < headers.size(); i++) {
+      builder.addHeader(headers.name(i), headers.value(i));
+    }
 
-  private HttpEngine newHttpEngine(String method, RawHeaders requestHeaders,
-      Connection connection, RetryableOutputStream requestBody) throws IOException {
-    if (url.getProtocol().equals("http")) {
-      return new HttpEngine(client, this, method, requestHeaders, connection, requestBody);
-    } else if (url.getProtocol().equals("https")) {
-      return new HttpsEngine(client, this, method, requestHeaders, connection, requestBody);
+    boolean bufferRequestBody;
+    if (fixedContentLength != -1) {
+      bufferRequestBody = false;
+      builder.header("Content-Length", Long.toString(fixedContentLength));
+    } else if (chunkLength > 0) {
+      bufferRequestBody = false;
+      builder.header("Transfer-Encoding", "chunked");
     } else {
-      throw new AssertionError();
+      bufferRequestBody = true;
     }
+
+    Request request = builder.build();
+
+    // If we're currently not using caches, make sure the engine's client doesn't have one.
+    OkHttpClient engineClient = client;
+    if (engineClient.getOkResponseCache() != null && !getUseCaches()) {
+      engineClient = client.clone().setOkResponseCache(null);
+    }
+
+    return new HttpEngine(engineClient, request, bufferRequestBody, connection, null, requestBody);
   }
 
   /**
@@ -311,18 +338,18 @@ private HttpEngine getResponse() throws IOException {
       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM
       // redirect should keep the same method, Chrome, Firefox and the
       // RI all issue GETs when following any redirect.
-      int responseCode = getResponseCode();
+      int responseCode = httpEngine.getResponse().code();
       if (responseCode == HTTP_MULT_CHOICE
           || responseCode == HTTP_MOVED_PERM
           || responseCode == HTTP_MOVED_TEMP
           || responseCode == HTTP_SEE_OTHER) {
         retryMethod = "GET";
+        requestHeaders.removeAll("Content-Length");
         requestBody = null;
       }
 
       if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {
-        throw new HttpRetryException("Cannot retry streamed HTTP body",
-            httpEngine.getResponseCode());
+        throw new HttpRetryException("Cannot retry streamed HTTP body", responseCode);
       }
 
       if (retry == Retry.DIFFERENT_CONNECTION) {
@@ -330,14 +357,8 @@ private HttpEngine getResponse() throws IOException {
       }
 
       httpEngine.release(false);
-
-      httpEngine = newHttpEngine(retryMethod, rawRequestHeaders, httpEngine.getConnection(),
+      httpEngine = newHttpEngine(retryMethod, httpEngine.getConnection(),
           (RetryableOutputStream) requestBody);
-
-      if (requestBody == null) {
-        // Drop the Content-Length header when redirected from POST to GET.
-        httpEngine.getRequestHeaders().removeContentLength();
-      }
     }
   }
 
@@ -349,60 +370,23 @@ private HttpEngine getResponse() throws IOException {
   private boolean execute(boolean readResponse) throws IOException {
     try {
       httpEngine.sendRequest();
+      route = httpEngine.getRoute();
       if (readResponse) {
         httpEngine.readResponse();
       }
 
       return true;
     } catch (IOException e) {
-      if (handleFailure(e)) {
+      HttpEngine retryEngine = httpEngine.recover(e);
+      if (retryEngine != null) {
+        httpEngine = retryEngine;
         return false;
-      } else {
-        throw e;
       }
-    }
-  }
 
-  /**
-   * Report and attempt to recover from {@code e}. Returns true if the HTTP
-   * engine was replaced and the request should be retried. Otherwise the
-   * failure is permanent.
-   */
-  private boolean handleFailure(IOException e) throws IOException {
-    RouteSelector routeSelector = httpEngine.routeSelector;
-    if (routeSelector != null && httpEngine.connection != null) {
-      routeSelector.connectFailed(httpEngine.connection, e);
-    }
-
-    OutputStream requestBody = httpEngine.getRequestBody();
-    boolean canRetryRequestBody = requestBody == null
-        || requestBody instanceof RetryableOutputStream;
-    if (routeSelector == null && httpEngine.connection == null // No connection.
-        || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
-        || !isRecoverable(e)
-        || !canRetryRequestBody) {
+      // Give up; recovery is not possible.
       httpEngineFailure = e;
-      return false;
+      throw e;
     }
-
-    httpEngine.release(true);
-    RetryableOutputStream retryableOutputStream = (RetryableOutputStream) requestBody;
-    httpEngine = newHttpEngine(method, rawRequestHeaders, null, retryableOutputStream);
-    httpEngine.routeSelector = routeSelector; // Keep the same routeSelector.
-    return true;
-  }
-
-  private boolean isRecoverable(IOException e) {
-    // If the problem was a CertificateException from the X509TrustManager,
-    // do not retry, we didn't have an abrupt server initiated exception.
-    boolean sslFailure =
-        e instanceof SSLHandshakeException && e.getCause() instanceof CertificateException;
-    boolean protocolFailure = e instanceof ProtocolException;
-    return !sslFailure && !protocolFailure;
-  }
-
-  public HttpEngine getHttpEngine() {
-    return httpEngine;
   }
 
   enum Retry {
@@ -413,12 +397,13 @@ public HttpEngine getHttpEngine() {
 
   /**
    * Returns the retry action to take for the current response headers. The
-   * headers, proxy and target URL or this connection may be adjusted to
+   * headers, proxy and target URL for this connection may be adjusted to
    * prepare for a follow up request.
    */
   private Retry processResponseHeaders() throws IOException {
-    Proxy selectedProxy = httpEngine.connection != null
-        ? httpEngine.connection.getRoute().getProxy()
+    Connection connection = httpEngine.getConnection();
+    Proxy selectedProxy = connection != null
+        ? connection.getRoute().getProxy()
         : client.getProxy();
     final int responseCode = getResponseCode();
     switch (responseCode) {
@@ -428,10 +413,11 @@ private Retry processResponseHeaders() throws IOException {
         }
         // fall-through
       case HTTP_UNAUTHORIZED:
-        boolean credentialsFound = HttpAuthenticator.processAuthHeader(client.getAuthenticator(),
-            getResponseCode(), httpEngine.getResponseHeaders().getHeaders(), rawRequestHeaders,
-            selectedProxy, url);
-        return credentialsFound ? Retry.SAME_CONNECTION : Retry.NONE;
+        Request successorRequest = HttpAuthenticator.processAuthHeader(client.getAuthenticator(),
+            httpEngine.getResponse(), selectedProxy);
+        if (successorRequest == null) return Retry.NONE;
+        requestHeaders = successorRequest.getHeaders().newBuilder();
+        return Retry.SAME_CONNECTION;
 
       case HTTP_MULT_CHOICE:
       case HTTP_MOVED_PERM:
@@ -475,38 +461,30 @@ private Retry processResponseHeaders() throws IOException {
     }
   }
 
-  /** @see java.net.HttpURLConnection#setFixedLengthStreamingMode(int) */
-  @Override public final long getFixedContentLength() {
-    return fixedContentLength;
-  }
-
-  @Override public final int getChunkLength() {
-    return chunkLength;
-  }
-
+  /**
+   * Returns true if either:
+   * <ul>
+   *   <li>A specific proxy was explicitly configured for this connection.
+   *   <li>The response has already been retrieved, and a proxy was {@link
+   *       java.net.ProxySelector selected} in order to get it.
+   * </ul>
+   *
+   * <p><strong>Warning:</strong> This method may return false before attempting
+   * to connect and true afterwards.
+   */
   @Override public final boolean usingProxy() {
-    if (selectedProxy != null) {
-      return isValidNonDirectProxy(selectedProxy);
-    }
-
-    // This behavior is a bit odd (but is probably justified by the
-    // oddness of the APIs involved). Before a connection is established,
-    // this method will return true only if this connection was explicitly
-    // opened with a Proxy. We don't attempt to query the ProxySelector
-    // at all.
-    return isValidNonDirectProxy(client.getProxy());
-  }
-
-  private static boolean isValidNonDirectProxy(Proxy proxy) {
+    Proxy proxy = route != null
+        ? route.getProxy()
+        : client.getProxy();
     return proxy != null && proxy.type() != Proxy.Type.DIRECT;
   }
 
   @Override public String getResponseMessage() throws IOException {
-    return getResponse().getResponseHeaders().getHeaders().getResponseMessage();
+    return getResponse().getResponse().statusMessage();
   }
 
   @Override public final int getResponseCode() throws IOException {
-    return getResponse().getResponseCode();
+    return getResponse().getResponse().code();
   }
 
   @Override public final void setRequestProperty(String field, String newValue) {
@@ -526,10 +504,20 @@ private static boolean isValidNonDirectProxy(Proxy proxy) {
       return;
     }
 
-    if ("X-Android-Transports".equals(field)) {
-      setTransports(newValue, false /* append */);
+    // TODO: Deprecate use of X-Android-Transports header?
+    if ("X-Android-Transports".equals(field) || "X-Android-Protocols".equals(field)) {
+      setProtocols(newValue, false /* append */);
     } else {
-      rawRequestHeaders.set(field, newValue);
+      requestHeaders.set(field, newValue);
+    }
+  }
+
+  @Override public void setIfModifiedSince(long newValue) {
+    super.setIfModifiedSince(newValue);
+    if (ifModifiedSince != 0) {
+      requestHeaders.set("If-Modified-Since", HttpDate.format(new Date(ifModifiedSince)));
+    } else {
+      requestHeaders.removeAll("If-Modified-Since");
     }
   }
 
@@ -550,26 +538,33 @@ private static boolean isValidNonDirectProxy(Proxy proxy) {
       return;
     }
 
-    if ("X-Android-Transports".equals(field)) {
-      setTransports(value, true /* append */);
+    // TODO: Deprecate use of X-Android-Transports header?
+    if ("X-Android-Transports".equals(field) || "X-Android-Protocols".equals(field)) {
+      setProtocols(value, true /* append */);
     } else {
-      rawRequestHeaders.add(field, value);
+      requestHeaders.add(field, value);
     }
   }
 
   /*
-   * Splits and validates a comma-separated string of transports.
+   * Splits and validates a comma-separated string of protocols.
    * When append == false, we require that the transport list contains "http/1.1".
+   * Throws {@link IllegalStateException} when one of the protocols isn't
+   * defined in {@link Protocol OkHttp's protocol enumeration}.
    */
-  private void setTransports(String transportsString, boolean append) {
-    List<String> transportsList = new ArrayList<String>();
+  private void setProtocols(String protocolsString, boolean append) {
+    List<Protocol> protocolsList = new ArrayList<Protocol>();
     if (append) {
-      transportsList.addAll(client.getTransports());
+      protocolsList.addAll(client.getProtocols());
     }
-    for (String transport : transportsString.split(",", -1)) {
-      transportsList.add(transport);
+    for (String protocol : protocolsString.split(",", -1)) {
+      try {
+        protocolsList.add(Protocol.find(ByteString.encodeUtf8(protocol)));
+      } catch (IOException e) {
+        throw new IllegalStateException(e);
+      }
     }
-    client.setTransports(transportsList);
+    client.setProtocols(protocolsList);
   }
 
   @Override public void setFixedLengthStreamingMode(int contentLength) {
@@ -584,8 +579,4 @@ public void setFixedLengthStreamingMode(long contentLength) {
     this.fixedContentLength = contentLength;
     super.fixedContentLength = (int) Math.min(contentLength, Integer.MAX_VALUE);
   }
-
-  @Override public final void setSelectedProxy(Proxy proxy) {
-    this.selectedProxy = proxy;
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsEngine.java
deleted file mode 100644
index 2bc1d68e42..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsEngine.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.TunnelRequest;
-import java.io.IOException;
-import java.net.CacheResponse;
-import java.net.SecureCacheResponse;
-import java.net.URL;
-import javax.net.ssl.SSLSocket;
-
-import static com.squareup.okhttp.internal.Util.getEffectivePort;
-
-public final class HttpsEngine extends HttpEngine {
-  /**
-   * Stash of HttpsEngine.connection.socket to implement requests like {@code
-   * HttpsURLConnection#getCipherSuite} even after the connection has been
-   * recycled.
-   */
-  private SSLSocket sslSocket;
-
-  public HttpsEngine(OkHttpClient client, Policy policy, String method, RawHeaders requestHeaders,
-      Connection connection, RetryableOutputStream requestBody) throws IOException {
-    super(client, policy, method, requestHeaders, connection, requestBody);
-    this.sslSocket = connection != null ? (SSLSocket) connection.getSocket() : null;
-  }
-
-  @Override protected void connected(Connection connection) {
-    this.sslSocket = (SSLSocket) connection.getSocket();
-    super.connected(connection);
-  }
-
-  @Override protected boolean acceptCacheResponseType(CacheResponse cacheResponse) {
-    return cacheResponse instanceof SecureCacheResponse;
-  }
-
-  @Override protected boolean includeAuthorityInRequestLine() {
-    // Even if there is a proxy, it isn't involved. Always request just the path.
-    return false;
-  }
-
-  public SSLSocket getSslSocket() {
-    return sslSocket;
-  }
-
-  @Override protected TunnelRequest getTunnelConfig() {
-    String userAgent = requestHeaders.getUserAgent();
-    if (userAgent == null) {
-      userAgent = getDefaultUserAgent();
-    }
-
-    URL url = policy.getURL();
-    return new TunnelRequest(url.getHost(), getEffectivePort(url), userAgent,
-        requestHeaders.getProxyAuthorization());
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
index e8c656a2a3..a4fbeb558f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
@@ -16,13 +16,12 @@
  */
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Handshake;
 import com.squareup.okhttp.OkHttpClient;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.net.HttpURLConnection;
 import java.net.ProtocolException;
-import java.net.SecureCacheResponse;
 import java.net.URL;
 import java.security.Permission;
 import java.security.Principal;
@@ -32,92 +31,52 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 
 public final class HttpsURLConnectionImpl extends HttpsURLConnection {
 
-  /** HttpUrlConnectionDelegate allows reuse of HttpURLConnectionImpl. */
-  private final HttpUrlConnectionDelegate delegate;
+  /** Reuse HttpURLConnectionImpl. */
+  private final HttpURLConnectionImpl delegate;
 
   public HttpsURLConnectionImpl(URL url, OkHttpClient client) {
     super(url);
-    delegate = new HttpUrlConnectionDelegate(url, client);
+    delegate = new HttpURLConnectionImpl(url, client);
   }
 
   @Override public String getCipherSuite() {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      return cacheResponse.getCipherSuite();
-    }
-    SSLSocket sslSocket = getSslSocket();
-    if (sslSocket != null) {
-      return sslSocket.getSession().getCipherSuite();
-    }
-    return null;
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.cipherSuite() : null;
   }
 
   @Override public Certificate[] getLocalCertificates() {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      List<Certificate> result = cacheResponse.getLocalCertificateChain();
-      return result != null ? result.toArray(new Certificate[result.size()]) : null;
-    }
-    SSLSocket sslSocket = getSslSocket();
-    if (sslSocket != null) {
-      return sslSocket.getSession().getLocalCertificates();
-    }
-    return null;
+    Handshake handshake = handshake();
+    if (handshake == null) return null;
+    List<Certificate> result = handshake.localCertificates();
+    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
   }
 
   @Override public Certificate[] getServerCertificates() throws SSLPeerUnverifiedException {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      List<Certificate> result = cacheResponse.getServerCertificateChain();
-      return result != null ? result.toArray(new Certificate[result.size()]) : null;
-    }
-    SSLSocket sslSocket = getSslSocket();
-    if (sslSocket != null) {
-      return sslSocket.getSession().getPeerCertificates();
-    }
-    return null;
+    Handshake handshake = handshake();
+    if (handshake == null) return null;
+    List<Certificate> result = handshake.peerCertificates();
+    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
   }
 
   @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      return cacheResponse.getPeerPrincipal();
-    }
-    SSLSocket sslSocket = getSslSocket();
-    if (sslSocket != null) {
-      return sslSocket.getSession().getPeerPrincipal();
-    }
-    return null;
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.peerPrincipal() : null;
   }
 
   @Override public Principal getLocalPrincipal() {
-    SecureCacheResponse cacheResponse = delegate.getSecureCacheResponse();
-    if (cacheResponse != null) {
-      return cacheResponse.getLocalPrincipal();
-    }
-    SSLSocket sslSocket = getSslSocket();
-    if (sslSocket != null) {
-      return sslSocket.getSession().getLocalPrincipal();
-    }
-    return null;
-  }
-
-  public HttpEngine getHttpEngine() {
-    return delegate.getHttpEngine();
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.localPrincipal() : null;
   }
 
-  private SSLSocket getSslSocket() {
-    if (delegate.httpEngine == null || !delegate.httpEngine.connected) {
+  private Handshake handshake() {
+    if (delegate.httpEngine == null) {
       throw new IllegalStateException("Connection has not yet been established");
     }
-    return delegate.httpEngine instanceof HttpsEngine
-        ? ((HttpsEngine) delegate.httpEngine).getSslSocket()
-        : null; // Not HTTPS! Probably an https:// to http:// redirect.
+    return delegate.httpEngine.getResponse().handshake();
   }
 
   @Override public void disconnect() {
@@ -342,19 +301,15 @@ private SSLSocket getSslSocket() {
     return delegate.client.getSslSocketFactory();
   }
 
-  private final class HttpUrlConnectionDelegate extends HttpURLConnectionImpl {
-    private HttpUrlConnectionDelegate(URL url, OkHttpClient client) {
-      super(url, client);
-    }
+  @Override public void setFixedLengthStreamingMode(long contentLength) {
+    delegate.setFixedLengthStreamingMode(contentLength);
+  }
 
-    @Override public HttpURLConnection getHttpConnectionToCache() {
-      return HttpsURLConnectionImpl.this;
-    }
+  @Override public long getContentLengthLong() {
+    return delegate.getContentLengthLong();
+  }
 
-    public SecureCacheResponse getSecureCacheResponse() {
-      return httpEngine instanceof HttpsEngine
-          ? (SecureCacheResponse) httpEngine.getCacheResponse()
-          : null;
-    }
+  @Override public long getHeaderFieldLong(String field, long defaultValue) {
+    return delegate.getHeaderFieldLong(field, defaultValue);
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
new file mode 100644
index 0000000000..dd18638ef6
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
@@ -0,0 +1,142 @@
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.Platform;
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+
+/** Headers and utilities for internal use by OkHttp. */
+public final class OkHeaders {
+  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
+    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
+    @Override public int compare(String a, String b) {
+      if (a == b) {
+        return 0;
+      } else if (a == null) {
+        return -1;
+      } else if (b == null) {
+        return 1;
+      } else {
+        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
+      }
+    }
+  };
+
+  static final String PREFIX = Platform.get().getPrefix();
+
+  /**
+   * Synthetic response header: the local time when the request was sent.
+   */
+  public static final String SENT_MILLIS = PREFIX + "-Sent-Millis";
+
+  /**
+   * Synthetic response header: the local time when the response was received.
+   */
+  public static final String RECEIVED_MILLIS = PREFIX + "-Received-Millis";
+
+  /**
+   * Synthetic response header: the response source and status code like
+   * "CONDITIONAL_CACHE 304".
+   */
+  public static final String RESPONSE_SOURCE = PREFIX + "-Response-Source";
+
+  /**
+   * @deprecated OkHttp 2 enforces an enumeration of {@link com.squareup.okhttp.Protocol protocols}
+   * that can be selected. Please use #SELECTED_PROTOCOL
+   */
+  @Deprecated
+  public static final String SELECTED_TRANSPORT = PREFIX + "-Selected-Transport";
+
+  /**
+   * Synthetic response header: the selected
+   * {@link com.squareup.okhttp.Protocol protocol} ("spdy/3.1", "http/1.1", etc).
+   */
+  public static final String SELECTED_PROTOCOL = PREFIX + "-Selected-Protocol";
+
+  private OkHeaders() {
+  }
+
+  public static long contentLength(Request request) {
+    return stringToLong(request.header("Content-Length"));
+  }
+
+  public static long contentLength(Response response) {
+    return stringToLong(response.header("Content-Length"));
+  }
+
+  private static long stringToLong(String s) {
+    if (s == null) return -1;
+    try {
+      return Long.parseLong(s);
+    } catch (NumberFormatException e) {
+      return -1;
+    }
+  }
+
+  /**
+   * Returns an immutable map containing each field to its list of values.
+   *
+   * @param valueForNullKey the request line for requests, or the status line
+   *     for responses. If non-null, this value is mapped to the null key.
+   */
+  public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
+    Map<String, List<String>> result = new TreeMap<String, List<String>>(FIELD_NAME_COMPARATOR);
+    for (int i = 0; i < headers.size(); i++) {
+      String fieldName = headers.name(i);
+      String value = headers.value(i);
+
+      List<String> allValues = new ArrayList<String>();
+      List<String> otherValues = result.get(fieldName);
+      if (otherValues != null) {
+        allValues.addAll(otherValues);
+      }
+      allValues.add(value);
+      result.put(fieldName, Collections.unmodifiableList(allValues));
+    }
+    if (valueForNullKey != null) {
+      result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));
+    }
+    return Collections.unmodifiableMap(result);
+  }
+
+  public static void addCookies(Request.Builder builder, Map<String, List<String>> cookieHeaders) {
+    for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
+      String key = entry.getKey();
+      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
+          && !entry.getValue().isEmpty()) {
+        builder.addHeader(key, buildCookieHeader(entry.getValue()));
+      }
+    }
+  }
+
+  /**
+   * Send all cookies in one big header, as recommended by
+   * <a href="http://tools.ietf.org/html/rfc6265#section-4.2.1">RFC 6265</a>.
+   */
+  private static String buildCookieHeader(List<String> cookies) {
+    if (cookies.size() == 1) return cookies.get(0);
+    StringBuilder sb = new StringBuilder();
+    for (int i = 0; i < cookies.size(); i++) {
+      if (i > 0) sb.append("; ");
+      sb.append(cookies.get(i));
+    }
+    return sb.toString();
+  }
+
+  /** Reads headers or trailers into {@code builder}. */
+  public static void readHeaders(Headers.Builder builder, InputStream in) throws IOException {
+    // parse the result headers until the first blank line
+    for (String line; (line = Util.readAsciiLine(in)).length() != 0; ) {
+      builder.addLine(line);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkResponseCacheAdapter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkResponseCacheAdapter.java
deleted file mode 100644
index 5335c2bce8..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkResponseCacheAdapter.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.OkResponseCache;
-import com.squareup.okhttp.ResponseSource;
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-
-public final class OkResponseCacheAdapter implements OkResponseCache {
-  private final ResponseCache responseCache;
-  public OkResponseCacheAdapter(ResponseCache responseCache) {
-    this.responseCache = responseCache;
-  }
-
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) throws IOException {
-    return responseCache.get(uri, requestMethod, requestHeaders);
-  }
-
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    return responseCache.put(uri, urlConnection);
-  }
-
-  @Override public void maybeRemove(String requestMethod, URI uri) throws IOException {
-  }
-
-  @Override public void update(CacheResponse conditionalCacheHit, HttpURLConnection connection)
-      throws IOException {
-  }
-
-  @Override public void trackConditionalCacheHit() {
-  }
-
-  @Override public void trackResponse(ResponseSource source) {
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Policy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Policy.java
deleted file mode 100644
index 0a29d4b1ab..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Policy.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import java.net.HttpURLConnection;
-import java.net.Proxy;
-import java.net.URL;
-
-public interface Policy {
-  /** Returns true if HTTP response caches should be used. */
-  boolean getUseCaches();
-
-  /** Returns the HttpURLConnection instance to store in the cache. */
-  HttpURLConnection getHttpConnectionToCache();
-
-  /** Returns the current destination URL, possibly a redirect. */
-  URL getURL();
-
-  /** Returns the If-Modified-Since timestamp, or 0 if none is set. */
-  long getIfModifiedSince();
-
-  /** Returns true if a non-direct proxy is specified. */
-  boolean usingProxy();
-
-  /** @see java.net.HttpURLConnection#setChunkedStreamingMode(int) */
-  int getChunkLength();
-
-  /** @see java.net.HttpURLConnection#setFixedLengthStreamingMode(int) */
-  long getFixedContentLength();
-
-  /**
-   * Sets the current proxy that this connection is using.
-   * @see java.net.HttpURLConnection#usingProxy
-   */
-  void setSelectedProxy(Proxy proxy);
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RawHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RawHeaders.java
deleted file mode 100644
index 8b45320704..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RawHeaders.java
+++ /dev/null
@@ -1,447 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
-import java.net.ProtocolException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.TreeMap;
-import java.util.TreeSet;
-
-/**
- * The HTTP status and unparsed header fields of a single HTTP message. Values
- * are represented as uninterpreted strings; use {@link RequestHeaders} and
- * {@link ResponseHeaders} for interpreted headers. This class maintains the
- * order of the header fields within the HTTP message.
- *
- * <p>This class tracks fields line-by-line. A field with multiple comma-
- * separated values on the same line will be treated as a field with a single
- * value by this class. It is the caller's responsibility to detect and split
- * on commas if their field permits multiple values. This simplifies use of
- * single-valued fields whose values routinely contain commas, such as cookies
- * or dates.
- *
- * <p>This class trims whitespace from values. It never returns values with
- * leading or trailing whitespace.
- */
-public final class RawHeaders {
-  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
-    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
-    @Override public int compare(String a, String b) {
-      if (a == b) {
-        return 0;
-      } else if (a == null) {
-        return -1;
-      } else if (b == null) {
-        return 1;
-      } else {
-        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
-      }
-    }
-  };
-
-  private final List<String> namesAndValues = new ArrayList<String>(20);
-  private String requestLine;
-  private String statusLine;
-  private int httpMinorVersion = 1;
-  private int responseCode = -1;
-  private String responseMessage;
-
-  public RawHeaders() {
-  }
-
-  public RawHeaders(RawHeaders copyFrom) {
-    namesAndValues.addAll(copyFrom.namesAndValues);
-    requestLine = copyFrom.requestLine;
-    statusLine = copyFrom.statusLine;
-    httpMinorVersion = copyFrom.httpMinorVersion;
-    responseCode = copyFrom.responseCode;
-    responseMessage = copyFrom.responseMessage;
-  }
-
-  /** Sets the request line (like "GET / HTTP/1.1"). */
-  public void setRequestLine(String requestLine) {
-    requestLine = requestLine.trim();
-    this.requestLine = requestLine;
-  }
-
-  /** Sets the response status line (like "HTTP/1.0 200 OK"). */
-  public void setStatusLine(String statusLine) throws IOException {
-    // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
-    // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
-    if (this.responseMessage != null) {
-      throw new IllegalStateException("statusLine is already set");
-    }
-    // We allow empty message without leading white space since some servers
-    // do not send the white space when the message is empty.
-    boolean hasMessage = statusLine.length() > 13;
-    if (!statusLine.startsWith("HTTP/1.")
-        || statusLine.length() < 12
-        || statusLine.charAt(8) != ' '
-        || (hasMessage && statusLine.charAt(12) != ' ')) {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
-    int httpMinorVersion = statusLine.charAt(7) - '0';
-    if (httpMinorVersion < 0 || httpMinorVersion > 9) {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
-    int responseCode;
-    try {
-      responseCode = Integer.parseInt(statusLine.substring(9, 12));
-    } catch (NumberFormatException e) {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
-    this.responseMessage = hasMessage ? statusLine.substring(13) : "";
-    this.responseCode = responseCode;
-    this.statusLine = statusLine;
-    this.httpMinorVersion = httpMinorVersion;
-  }
-
-  /**
-   * @param method like "GET", "POST", "HEAD", etc.
-   * @param path like "/foo/bar.html"
-   * @param version like "HTTP/1.1"
-   * @param host like "www.android.com:1234"
-   * @param scheme like "https"
-   */
-  public void addSpdyRequestHeaders(String method, String path, String version, String host,
-      String scheme) {
-    // TODO: populate the statusLine for the client's benefit?
-    add(":method", method);
-    add(":scheme", scheme);
-    add(":path", path);
-    add(":version", version);
-    add(":host", host);
-  }
-
-  public String getStatusLine() {
-    return statusLine;
-  }
-
-  /**
-   * Returns the status line's HTTP minor version. This returns 0 for HTTP/1.0
-   * and 1 for HTTP/1.1. This returns 1 if the HTTP version is unknown.
-   */
-  public int getHttpMinorVersion() {
-    return httpMinorVersion != -1 ? httpMinorVersion : 1;
-  }
-
-  /** Returns the HTTP status code or -1 if it is unknown. */
-  public int getResponseCode() {
-    return responseCode;
-  }
-
-  /** Returns the HTTP status message or null if it is unknown. */
-  public String getResponseMessage() {
-    return responseMessage;
-  }
-
-  /**
-   * Add an HTTP header line containing a field name, a literal colon, and a
-   * value. This works around empty header names and header names that start
-   * with a colon (created by old broken SPDY versions of the response cache).
-   */
-  public void addLine(String line) {
-    int index = line.indexOf(":", 1);
-    if (index != -1) {
-      addLenient(line.substring(0, index), line.substring(index + 1));
-    } else if (line.startsWith(":")) {
-      addLenient("", line.substring(1)); // Empty header name.
-    } else {
-      addLenient("", line); // No header name.
-    }
-  }
-
-  /** Add a field with the specified value. */
-  public void add(String fieldName, String value) {
-    if (fieldName == null) throw new IllegalArgumentException("fieldname == null");
-    if (value == null) throw new IllegalArgumentException("value == null");
-    if (fieldName.length() == 0 || fieldName.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-      throw new IllegalArgumentException("Unexpected header: " + fieldName + ": " + value);
-    }
-    addLenient(fieldName, value);
-  }
-
-  /**
-   * Add a field with the specified value without any validation. Only
-   * appropriate for headers from the remote peer.
-   */
-  private void addLenient(String fieldName, String value) {
-    namesAndValues.add(fieldName);
-    namesAndValues.add(value.trim());
-  }
-
-  public void removeAll(String fieldName) {
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
-        namesAndValues.remove(i); // field name
-        namesAndValues.remove(i); // value
-      }
-    }
-  }
-
-  public void addAll(String fieldName, List<String> headerFields) {
-    for (String value : headerFields) {
-      add(fieldName, value);
-    }
-  }
-
-  /**
-   * Set a field with the specified value. If the field is not found, it is
-   * added. If the field is found, the existing values are replaced.
-   */
-  public void set(String fieldName, String value) {
-    removeAll(fieldName);
-    add(fieldName, value);
-  }
-
-  /** Returns the number of field values. */
-  public int length() {
-    return namesAndValues.size() / 2;
-  }
-
-  /** Returns the field at {@code position} or null if that is out of range. */
-  public String getFieldName(int index) {
-    int fieldNameIndex = index * 2;
-    if (fieldNameIndex < 0 || fieldNameIndex >= namesAndValues.size()) {
-      return null;
-    }
-    return namesAndValues.get(fieldNameIndex);
-  }
-
-  /** Returns an immutable case-insensitive set of header names. */
-  public Set<String> names() {
-    TreeSet<String> result = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
-    for (int i = 0; i < length(); i++) {
-      result.add(getFieldName(i));
-    }
-    return Collections.unmodifiableSet(result);
-  }
-
-  /** Returns the value at {@code index} or null if that is out of range. */
-  public String getValue(int index) {
-    int valueIndex = index * 2 + 1;
-    if (valueIndex < 0 || valueIndex >= namesAndValues.size()) {
-      return null;
-    }
-    return namesAndValues.get(valueIndex);
-  }
-
-  /** Returns the last value corresponding to the specified field, or null. */
-  public String get(String fieldName) {
-    for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
-      if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
-        return namesAndValues.get(i + 1);
-      }
-    }
-    return null;
-  }
-
-  /** Returns an immutable list of the header values for {@code name}. */
-  public List<String> values(String name) {
-    List<String> result = null;
-    for (int i = 0; i < length(); i++) {
-      if (name.equalsIgnoreCase(getFieldName(i))) {
-        if (result == null) result = new ArrayList<String>(2);
-        result.add(getValue(i));
-      }
-    }
-    return result != null
-        ? Collections.unmodifiableList(result)
-        : Collections.<String>emptyList();
-  }
-
-  /** @param fieldNames a case-insensitive set of HTTP header field names. */
-  public RawHeaders getAll(Set<String> fieldNames) {
-    RawHeaders result = new RawHeaders();
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      String fieldName = namesAndValues.get(i);
-      if (fieldNames.contains(fieldName)) {
-        result.add(fieldName, namesAndValues.get(i + 1));
-      }
-    }
-    return result;
-  }
-
-  /** Returns bytes of a request header for sending on an HTTP transport. */
-  public byte[] toBytes() throws UnsupportedEncodingException {
-    StringBuilder result = new StringBuilder(256);
-    result.append(requestLine).append("\r\n");
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      result.append(namesAndValues.get(i))
-          .append(": ")
-          .append(namesAndValues.get(i + 1))
-          .append("\r\n");
-    }
-    result.append("\r\n");
-    return result.toString().getBytes("ISO-8859-1");
-  }
-
-  /** Parses bytes of a response header from an HTTP transport. */
-  public static RawHeaders fromBytes(InputStream in) throws IOException {
-    RawHeaders headers;
-    do {
-      headers = new RawHeaders();
-      headers.setStatusLine(Util.readAsciiLine(in));
-      readHeaders(in, headers);
-    } while (headers.getResponseCode() == HttpEngine.HTTP_CONTINUE);
-    return headers;
-  }
-
-  /** Reads headers or trailers into {@code out}. */
-  public static void readHeaders(InputStream in, RawHeaders out) throws IOException {
-    // parse the result headers until the first blank line
-    String line;
-    while ((line = Util.readAsciiLine(in)).length() != 0) {
-      out.addLine(line);
-    }
-  }
-
-  /**
-   * Returns an immutable map containing each field to its list of values. The
-   * status line is mapped to null.
-   */
-  public Map<String, List<String>> toMultimap(boolean response) {
-    Map<String, List<String>> result = new TreeMap<String, List<String>>(FIELD_NAME_COMPARATOR);
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      String fieldName = namesAndValues.get(i);
-      String value = namesAndValues.get(i + 1);
-
-      List<String> allValues = new ArrayList<String>();
-      List<String> otherValues = result.get(fieldName);
-      if (otherValues != null) {
-        allValues.addAll(otherValues);
-      }
-      allValues.add(value);
-      result.put(fieldName, Collections.unmodifiableList(allValues));
-    }
-    if (response && statusLine != null) {
-      result.put(null, Collections.unmodifiableList(Collections.singletonList(statusLine)));
-    } else if (requestLine != null) {
-      result.put(null, Collections.unmodifiableList(Collections.singletonList(requestLine)));
-    }
-    return Collections.unmodifiableMap(result);
-  }
-
-  /**
-   * Creates a new instance from the given map of fields to values. If
-   * present, the null field's last element will be used to set the status
-   * line.
-   */
-  public static RawHeaders fromMultimap(Map<String, List<String>> map, boolean response)
-      throws IOException {
-    if (!response) throw new UnsupportedOperationException();
-    RawHeaders result = new RawHeaders();
-    for (Entry<String, List<String>> entry : map.entrySet()) {
-      String fieldName = entry.getKey();
-      List<String> values = entry.getValue();
-      if (fieldName != null) {
-        for (String value : values) {
-          result.addLenient(fieldName, value);
-        }
-      } else if (!values.isEmpty()) {
-        result.setStatusLine(values.get(values.size() - 1));
-      }
-    }
-    return result;
-  }
-
-  /**
-   * Returns a list of alternating names and values. Names are all lower case.
-   * No names are repeated. If any name has multiple values, they are
-   * concatenated using "\0" as a delimiter.
-   */
-  public List<String> toNameValueBlock() {
-    Set<String> names = new HashSet<String>();
-    List<String> result = new ArrayList<String>();
-    for (int i = 0; i < namesAndValues.size(); i += 2) {
-      String name = namesAndValues.get(i).toLowerCase(Locale.US);
-      String value = namesAndValues.get(i + 1);
-
-      // Drop headers that are forbidden when layering HTTP over SPDY.
-      if (name.equals("connection")
-          || name.equals("host")
-          || name.equals("keep-alive")
-          || name.equals("proxy-connection")
-          || name.equals("transfer-encoding")) {
-        continue;
-      }
-
-      // If we haven't seen this name before, add the pair to the end of the list...
-      if (names.add(name)) {
-        result.add(name);
-        result.add(value);
-        continue;
-      }
-
-      // ...otherwise concatenate the existing values and this value.
-      for (int j = 0; j < result.size(); j += 2) {
-        if (name.equals(result.get(j))) {
-          result.set(j + 1, result.get(j + 1) + "\0" + value);
-          break;
-        }
-      }
-    }
-    return result;
-  }
-
-  /** Returns headers for a name value block containing a SPDY response. */
-  public static RawHeaders fromNameValueBlock(List<String> nameValueBlock) throws IOException {
-    if (nameValueBlock.size() % 2 != 0) {
-      throw new IllegalArgumentException("Unexpected name value block: " + nameValueBlock);
-    }
-    String status = null;
-    String version = null;
-    RawHeaders result = new RawHeaders();
-    for (int i = 0; i < nameValueBlock.size(); i += 2) {
-      String name = nameValueBlock.get(i);
-      String values = nameValueBlock.get(i + 1);
-      for (int start = 0; start < values.length(); ) {
-        int end = values.indexOf('\0', start);
-        if (end == -1) {
-          end = values.length();
-        }
-        String value = values.substring(start, end);
-        if (":status".equals(name)) {
-          status = value;
-        } else if (":version".equals(name)) {
-          version = value;
-        } else {
-          result.namesAndValues.add(name);
-          result.namesAndValues.add(value);
-        }
-        start = end + 1;
-      }
-    }
-    if (status == null) throw new ProtocolException("Expected ':status' header not present");
-    if (version == null) throw new ProtocolException("Expected ':version' header not present");
-    result.setStatusLine(version + " " + status);
-    return result;
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestHeaders.java
deleted file mode 100644
index 71c3cd0f21..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestHeaders.java
+++ /dev/null
@@ -1,317 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import java.net.URI;
-import java.util.Date;
-import java.util.List;
-import java.util.Map;
-
-/** Parsed HTTP request headers. */
-public final class RequestHeaders {
-  private final URI uri;
-  private final RawHeaders headers;
-
-  /** Don't use a cache to satisfy this request. */
-  private boolean noCache;
-  private int maxAgeSeconds = -1;
-  private int maxStaleSeconds = -1;
-  private int minFreshSeconds = -1;
-
-  /**
-   * This field's name "only-if-cached" is misleading. It actually means "do
-   * not use the network". It is set by a client who only wants to make a
-   * request if it can be fully satisfied by the cache. Cached responses that
-   * would require validation (ie. conditional gets) are not permitted if this
-   * header is set.
-   */
-  private boolean onlyIfCached;
-
-  /**
-   * True if the request contains an authorization field. Although this isn't
-   * necessarily a shared cache, it follows the spec's strict requirements for
-   * shared caches.
-   */
-  private boolean hasAuthorization;
-
-  private long contentLength = -1;
-  private String transferEncoding;
-  private String userAgent;
-  private String host;
-  private String connection;
-  private String acceptEncoding;
-  private String contentType;
-  private String ifModifiedSince;
-  private String ifNoneMatch;
-  private String proxyAuthorization;
-
-  public RequestHeaders(URI uri, RawHeaders headers) {
-    this.uri = uri;
-    this.headers = headers;
-
-    HeaderParser.CacheControlHandler handler = new HeaderParser.CacheControlHandler() {
-      @Override public void handle(String directive, String parameter) {
-        if ("no-cache".equalsIgnoreCase(directive)) {
-          noCache = true;
-        } else if ("max-age".equalsIgnoreCase(directive)) {
-          maxAgeSeconds = HeaderParser.parseSeconds(parameter);
-        } else if ("max-stale".equalsIgnoreCase(directive)) {
-          maxStaleSeconds = HeaderParser.parseSeconds(parameter);
-        } else if ("min-fresh".equalsIgnoreCase(directive)) {
-          minFreshSeconds = HeaderParser.parseSeconds(parameter);
-        } else if ("only-if-cached".equalsIgnoreCase(directive)) {
-          onlyIfCached = true;
-        }
-      }
-    };
-
-    for (int i = 0; i < headers.length(); i++) {
-      String fieldName = headers.getFieldName(i);
-      String value = headers.getValue(i);
-      if ("Cache-Control".equalsIgnoreCase(fieldName)) {
-        HeaderParser.parseCacheControl(value, handler);
-      } else if ("Pragma".equalsIgnoreCase(fieldName)) {
-        if ("no-cache".equalsIgnoreCase(value)) {
-          noCache = true;
-        }
-      } else if ("If-None-Match".equalsIgnoreCase(fieldName)) {
-        ifNoneMatch = value;
-      } else if ("If-Modified-Since".equalsIgnoreCase(fieldName)) {
-        ifModifiedSince = value;
-      } else if ("Authorization".equalsIgnoreCase(fieldName)) {
-        hasAuthorization = true;
-      } else if ("Content-Length".equalsIgnoreCase(fieldName)) {
-        try {
-          contentLength = Integer.parseInt(value);
-        } catch (NumberFormatException ignored) {
-        }
-      } else if ("Transfer-Encoding".equalsIgnoreCase(fieldName)) {
-        transferEncoding = value;
-      } else if ("User-Agent".equalsIgnoreCase(fieldName)) {
-        userAgent = value;
-      } else if ("Host".equalsIgnoreCase(fieldName)) {
-        host = value;
-      } else if ("Connection".equalsIgnoreCase(fieldName)) {
-        connection = value;
-      } else if ("Accept-Encoding".equalsIgnoreCase(fieldName)) {
-        acceptEncoding = value;
-      } else if ("Content-Type".equalsIgnoreCase(fieldName)) {
-        contentType = value;
-      } else if ("Proxy-Authorization".equalsIgnoreCase(fieldName)) {
-        proxyAuthorization = value;
-      }
-    }
-  }
-
-  public boolean isChunked() {
-    return "chunked".equalsIgnoreCase(transferEncoding);
-  }
-
-  public boolean hasConnectionClose() {
-    return "close".equalsIgnoreCase(connection);
-  }
-
-  public URI getUri() {
-    return uri;
-  }
-
-  public RawHeaders getHeaders() {
-    return headers;
-  }
-
-  public boolean isNoCache() {
-    return noCache;
-  }
-
-  public int getMaxAgeSeconds() {
-    return maxAgeSeconds;
-  }
-
-  public int getMaxStaleSeconds() {
-    return maxStaleSeconds;
-  }
-
-  public int getMinFreshSeconds() {
-    return minFreshSeconds;
-  }
-
-  public boolean isOnlyIfCached() {
-    return onlyIfCached;
-  }
-
-  public boolean hasAuthorization() {
-    return hasAuthorization;
-  }
-
-  public long getContentLength() {
-    return contentLength;
-  }
-
-  public String getTransferEncoding() {
-    return transferEncoding;
-  }
-
-  public String getUserAgent() {
-    return userAgent;
-  }
-
-  public String getHost() {
-    return host;
-  }
-
-  public String getConnection() {
-    return connection;
-  }
-
-  public String getAcceptEncoding() {
-    return acceptEncoding;
-  }
-
-  public String getContentType() {
-    return contentType;
-  }
-
-  public String getIfModifiedSince() {
-    return ifModifiedSince;
-  }
-
-  public String getIfNoneMatch() {
-    return ifNoneMatch;
-  }
-
-  public String getProxyAuthorization() {
-    return proxyAuthorization;
-  }
-
-  public void setChunked() {
-    if (this.transferEncoding != null) {
-      headers.removeAll("Transfer-Encoding");
-    }
-    headers.add("Transfer-Encoding", "chunked");
-    this.transferEncoding = "chunked";
-  }
-
-  public void setContentLength(long contentLength) {
-    if (this.contentLength != -1) {
-      headers.removeAll("Content-Length");
-    }
-    headers.add("Content-Length", Long.toString(contentLength));
-    this.contentLength = contentLength;
-  }
-
-  /**
-   * Remove the Content-Length headers. Call this when dropping the body on a
-   * request or response, such as when a redirect changes the method from POST
-   * to GET.
-   */
-  public void removeContentLength() {
-    if (contentLength != -1) {
-      headers.removeAll("Content-Length");
-      contentLength = -1;
-    }
-  }
-
-  public void setUserAgent(String userAgent) {
-    if (this.userAgent != null) {
-      headers.removeAll("User-Agent");
-    }
-    headers.add("User-Agent", userAgent);
-    this.userAgent = userAgent;
-  }
-
-  public void setHost(String host) {
-    if (this.host != null) {
-      headers.removeAll("Host");
-    }
-    headers.add("Host", host);
-    this.host = host;
-  }
-
-  public void setConnection(String connection) {
-    if (this.connection != null) {
-      headers.removeAll("Connection");
-    }
-    headers.add("Connection", connection);
-    this.connection = connection;
-  }
-
-  public void setAcceptEncoding(String acceptEncoding) {
-    if (this.acceptEncoding != null) {
-      headers.removeAll("Accept-Encoding");
-    }
-    headers.add("Accept-Encoding", acceptEncoding);
-    this.acceptEncoding = acceptEncoding;
-  }
-
-  public void setContentType(String contentType) {
-    if (this.contentType != null) {
-      headers.removeAll("Content-Type");
-    }
-    headers.add("Content-Type", contentType);
-    this.contentType = contentType;
-  }
-
-  public void setIfModifiedSince(Date date) {
-    if (ifModifiedSince != null) {
-      headers.removeAll("If-Modified-Since");
-    }
-    String formattedDate = HttpDate.format(date);
-    headers.add("If-Modified-Since", formattedDate);
-    ifModifiedSince = formattedDate;
-  }
-
-  public void setIfNoneMatch(String ifNoneMatch) {
-    if (this.ifNoneMatch != null) {
-      headers.removeAll("If-None-Match");
-    }
-    headers.add("If-None-Match", ifNoneMatch);
-    this.ifNoneMatch = ifNoneMatch;
-  }
-
-  /**
-   * Returns true if the request contains conditions that save the server from
-   * sending a response that the client has locally. When the caller adds
-   * conditions, this cache won't participate in the request.
-   */
-  public boolean hasConditions() {
-    return ifModifiedSince != null || ifNoneMatch != null;
-  }
-
-  public void addCookies(Map<String, List<String>> allCookieHeaders) {
-    for (Map.Entry<String, List<String>> entry : allCookieHeaders.entrySet()) {
-      String key = entry.getKey();
-      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
-          && !entry.getValue().isEmpty()) {
-        headers.add(key, buildCookieHeader(entry.getValue()));
-      }
-    }
-  }
-
-  /**
-   * Send all cookies in one big header, as recommended by
-   * <a href="http://tools.ietf.org/html/rfc6265#section-4.2.1">RFC 6265</a>.
-   */
-  private String buildCookieHeader(List<String> cookies) {
-    if (cookies.size() == 1) return cookies.get(0);
-    StringBuilder sb = new StringBuilder();
-    for (int i = 0; i < cookies.size(); i++) {
-      if (i > 0) sb.append("; ");
-      sb.append(cookies.get(i));
-    }
-    return sb.toString();
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
new file mode 100644
index 0000000000..c918df3c22
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
@@ -0,0 +1,55 @@
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Request;
+import java.net.Proxy;
+import java.net.URL;
+
+public final class RequestLine {
+  private RequestLine() {
+  }
+
+  /**
+   * Returns the request status line, like "GET / HTTP/1.1". This is exposed
+   * to the application by {@link HttpURLConnectionImpl#getHeaderFields}, so
+   * it needs to be set even if the transport is SPDY.
+   */
+  static String get(Request request, Proxy.Type proxyType, int httpMinorVersion) {
+    StringBuilder result = new StringBuilder();
+    result.append(request.method());
+    result.append(" ");
+
+    if (includeAuthorityInRequestLine(request, proxyType)) {
+      result.append(request.url());
+    } else {
+      result.append(requestPath(request.url()));
+    }
+
+    result.append(" ");
+    result.append(version(httpMinorVersion));
+    return result.toString();
+  }
+
+  /**
+   * Returns true if the request line should contain the full URL with host
+   * and port (like "GET http://android.com/foo HTTP/1.1") or only the path
+   * (like "GET /foo HTTP/1.1").
+   */
+  private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type proxyType) {
+    return !request.isHttps() && proxyType == Proxy.Type.HTTP;
+  }
+
+  /**
+   * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty,
+   * even if the request URL is. Includes the query component if it exists.
+   */
+  public static String requestPath(URL url) {
+    String pathAndQuery = url.getFile();
+    if (pathAndQuery == null) return "/";
+    if (!pathAndQuery.startsWith("/")) return "/" + pathAndQuery;
+    return pathAndQuery;
+  }
+
+  public static String version(int httpMinorVersion) {
+    return httpMinorVersion == 1 ? "HTTP/1.1" : "HTTP/1.0";
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseHeaders.java
deleted file mode 100644
index 461de8efb9..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseHeaders.java
+++ /dev/null
@@ -1,505 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.ResponseSource;
-import com.squareup.okhttp.internal.Platform;
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URI;
-import java.util.Collections;
-import java.util.Date;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeSet;
-import java.util.concurrent.TimeUnit;
-
-import static com.squareup.okhttp.internal.Util.equal;
-
-/** Parsed HTTP response headers. */
-public final class ResponseHeaders {
-
-  /** HTTP header name for the local time when the request was sent. */
-  private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
-
-  /** HTTP header name for the local time when the response was received. */
-  private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
-
-  /** HTTP synthetic header with the response source. */
-  static final String RESPONSE_SOURCE = Platform.get().getPrefix() + "-Response-Source";
-
-  /** HTTP synthetic header with the selected transport (spdy/3, http/1.1, etc). */
-  static final String SELECTED_TRANSPORT = Platform.get().getPrefix() + "-Selected-Transport";
-
-  private final URI uri;
-  private final RawHeaders headers;
-
-  /** The server's time when this response was served, if known. */
-  private Date servedDate;
-
-  /** The last modified date of the response, if known. */
-  private Date lastModified;
-
-  /**
-   * The expiration date of the response, if known. If both this field and the
-   * max age are set, the max age is preferred.
-   */
-  private Date expires;
-
-  /**
-   * Extension header set by HttpURLConnectionImpl specifying the timestamp
-   * when the HTTP request was first initiated.
-   */
-  private long sentRequestMillis;
-
-  /**
-   * Extension header set by HttpURLConnectionImpl specifying the timestamp
-   * when the HTTP response was first received.
-   */
-  private long receivedResponseMillis;
-
-  /**
-   * In the response, this field's name "no-cache" is misleading. It doesn't
-   * prevent us from caching the response; it only means we have to validate
-   * the response with the origin server before returning it. We can do this
-   * with a conditional get.
-   */
-  private boolean noCache;
-
-  /** If true, this response should not be cached. */
-  private boolean noStore;
-
-  /**
-   * The duration past the response's served date that it can be served
-   * without validation.
-   */
-  private int maxAgeSeconds = -1;
-
-  /**
-   * The "s-maxage" directive is the max age for shared caches. Not to be
-   * confused with "max-age" for non-shared caches, As in Firefox and Chrome,
-   * this directive is not honored by this cache.
-   */
-  private int sMaxAgeSeconds = -1;
-
-  /**
-   * This request header field's name "only-if-cached" is misleading. It
-   * actually means "do not use the network". It is set by a client who only
-   * wants to make a request if it can be fully satisfied by the cache.
-   * Cached responses that would require validation (ie. conditional gets) are
-   * not permitted if this header is set.
-   */
-  private boolean isPublic;
-  private boolean mustRevalidate;
-  private String etag;
-  private int ageSeconds = -1;
-
-  /** Case-insensitive set of field names. */
-  private Set<String> varyFields = Collections.emptySet();
-
-  private String contentEncoding;
-  private String transferEncoding;
-  private int contentLength = -1;
-  private String connection;
-
-  public ResponseHeaders(URI uri, RawHeaders headers) {
-    this.uri = uri;
-    this.headers = headers;
-
-    HeaderParser.CacheControlHandler handler = new HeaderParser.CacheControlHandler() {
-      @Override public void handle(String directive, String parameter) {
-        if ("no-cache".equalsIgnoreCase(directive)) {
-          noCache = true;
-        } else if ("no-store".equalsIgnoreCase(directive)) {
-          noStore = true;
-        } else if ("max-age".equalsIgnoreCase(directive)) {
-          maxAgeSeconds = HeaderParser.parseSeconds(parameter);
-        } else if ("s-maxage".equalsIgnoreCase(directive)) {
-          sMaxAgeSeconds = HeaderParser.parseSeconds(parameter);
-        } else if ("public".equalsIgnoreCase(directive)) {
-          isPublic = true;
-        } else if ("must-revalidate".equalsIgnoreCase(directive)) {
-          mustRevalidate = true;
-        }
-      }
-    };
-
-    for (int i = 0; i < headers.length(); i++) {
-      String fieldName = headers.getFieldName(i);
-      String value = headers.getValue(i);
-      if ("Cache-Control".equalsIgnoreCase(fieldName)) {
-        HeaderParser.parseCacheControl(value, handler);
-      } else if ("Date".equalsIgnoreCase(fieldName)) {
-        servedDate = HttpDate.parse(value);
-      } else if ("Expires".equalsIgnoreCase(fieldName)) {
-        expires = HttpDate.parse(value);
-      } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
-        lastModified = HttpDate.parse(value);
-      } else if ("ETag".equalsIgnoreCase(fieldName)) {
-        etag = value;
-      } else if ("Pragma".equalsIgnoreCase(fieldName)) {
-        if ("no-cache".equalsIgnoreCase(value)) {
-          noCache = true;
-        }
-      } else if ("Age".equalsIgnoreCase(fieldName)) {
-        ageSeconds = HeaderParser.parseSeconds(value);
-      } else if ("Vary".equalsIgnoreCase(fieldName)) {
-        // Replace the immutable empty set with something we can mutate.
-        if (varyFields.isEmpty()) {
-          varyFields = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
-        }
-        for (String varyField : value.split(",")) {
-          varyFields.add(varyField.trim());
-        }
-      } else if ("Content-Encoding".equalsIgnoreCase(fieldName)) {
-        contentEncoding = value;
-      } else if ("Transfer-Encoding".equalsIgnoreCase(fieldName)) {
-        transferEncoding = value;
-      } else if ("Content-Length".equalsIgnoreCase(fieldName)) {
-        try {
-          contentLength = Integer.parseInt(value);
-        } catch (NumberFormatException ignored) {
-        }
-      } else if ("Connection".equalsIgnoreCase(fieldName)) {
-        connection = value;
-      } else if (SENT_MILLIS.equalsIgnoreCase(fieldName)) {
-        sentRequestMillis = Long.parseLong(value);
-      } else if (RECEIVED_MILLIS.equalsIgnoreCase(fieldName)) {
-        receivedResponseMillis = Long.parseLong(value);
-      }
-    }
-  }
-
-  public boolean isContentEncodingGzip() {
-    return "gzip".equalsIgnoreCase(contentEncoding);
-  }
-
-  public void stripContentEncoding() {
-    contentEncoding = null;
-    headers.removeAll("Content-Encoding");
-  }
-
-  public void stripContentLength() {
-    contentLength = -1;
-    headers.removeAll("Content-Length");
-  }
-
-  public boolean isChunked() {
-    return "chunked".equalsIgnoreCase(transferEncoding);
-  }
-
-  public boolean hasConnectionClose() {
-    return "close".equalsIgnoreCase(connection);
-  }
-
-  public URI getUri() {
-    return uri;
-  }
-
-  public RawHeaders getHeaders() {
-    return headers;
-  }
-
-  public Date getServedDate() {
-    return servedDate;
-  }
-
-  public Date getLastModified() {
-    return lastModified;
-  }
-
-  public Date getExpires() {
-    return expires;
-  }
-
-  public boolean isNoCache() {
-    return noCache;
-  }
-
-  public boolean isNoStore() {
-    return noStore;
-  }
-
-  public int getMaxAgeSeconds() {
-    return maxAgeSeconds;
-  }
-
-  public int getSMaxAgeSeconds() {
-    return sMaxAgeSeconds;
-  }
-
-  public boolean isPublic() {
-    return isPublic;
-  }
-
-  public boolean isMustRevalidate() {
-    return mustRevalidate;
-  }
-
-  public String getEtag() {
-    return etag;
-  }
-
-  public Set<String> getVaryFields() {
-    return varyFields;
-  }
-
-  public String getContentEncoding() {
-    return contentEncoding;
-  }
-
-  public int getContentLength() {
-    return contentLength;
-  }
-
-  public String getConnection() {
-    return connection;
-  }
-
-  public void setLocalTimestamps(long sentRequestMillis, long receivedResponseMillis) {
-    this.sentRequestMillis = sentRequestMillis;
-    headers.add(SENT_MILLIS, Long.toString(sentRequestMillis));
-    this.receivedResponseMillis = receivedResponseMillis;
-    headers.add(RECEIVED_MILLIS, Long.toString(receivedResponseMillis));
-  }
-
-  public void setResponseSource(ResponseSource responseSource) {
-    headers.set(RESPONSE_SOURCE, responseSource.toString() + " " + headers.getResponseCode());
-  }
-
-  public void setTransport(String transport) {
-    headers.set(SELECTED_TRANSPORT, transport);
-  }
-
-  /**
-   * Returns the current age of the response, in milliseconds. The calculation
-   * is specified by RFC 2616, 13.2.3 Age Calculations.
-   */
-  private long computeAge(long nowMillis) {
-    long apparentReceivedAge =
-        servedDate != null ? Math.max(0, receivedResponseMillis - servedDate.getTime()) : 0;
-    long receivedAge =
-        ageSeconds != -1 ? Math.max(apparentReceivedAge, TimeUnit.SECONDS.toMillis(ageSeconds))
-            : apparentReceivedAge;
-    long responseDuration = receivedResponseMillis - sentRequestMillis;
-    long residentDuration = nowMillis - receivedResponseMillis;
-    return receivedAge + responseDuration + residentDuration;
-  }
-
-  /**
-   * Returns the number of milliseconds that the response was fresh for,
-   * starting from the served date.
-   */
-  private long computeFreshnessLifetime() {
-    if (maxAgeSeconds != -1) {
-      return TimeUnit.SECONDS.toMillis(maxAgeSeconds);
-    } else if (expires != null) {
-      long servedMillis = servedDate != null ? servedDate.getTime() : receivedResponseMillis;
-      long delta = expires.getTime() - servedMillis;
-      return delta > 0 ? delta : 0;
-    } else if (lastModified != null && uri.getRawQuery() == null) {
-      // As recommended by the HTTP RFC and implemented in Firefox, the
-      // max age of a document should be defaulted to 10% of the
-      // document's age at the time it was served. Default expiration
-      // dates aren't used for URIs containing a query.
-      long servedMillis = servedDate != null ? servedDate.getTime() : sentRequestMillis;
-      long delta = servedMillis - lastModified.getTime();
-      return delta > 0 ? (delta / 10) : 0;
-    }
-    return 0;
-  }
-
-  /**
-   * Returns true if computeFreshnessLifetime used a heuristic. If we used a
-   * heuristic to serve a cached response older than 24 hours, we are required
-   * to attach a warning.
-   */
-  private boolean isFreshnessLifetimeHeuristic() {
-    return maxAgeSeconds == -1 && expires == null;
-  }
-
-  /**
-   * Returns true if this response can be stored to later serve another
-   * request.
-   */
-  public boolean isCacheable(RequestHeaders request) {
-    // Always go to network for uncacheable response codes (RFC 2616, 13.4),
-    // This implementation doesn't support caching partial content.
-    int responseCode = headers.getResponseCode();
-    if (responseCode != HttpURLConnection.HTTP_OK
-        && responseCode != HttpURLConnection.HTTP_NOT_AUTHORITATIVE
-        && responseCode != HttpURLConnection.HTTP_MULT_CHOICE
-        && responseCode != HttpURLConnection.HTTP_MOVED_PERM
-        && responseCode != HttpURLConnection.HTTP_GONE) {
-      return false;
-    }
-
-    // Responses to authorized requests aren't cacheable unless they include
-    // a 'public', 'must-revalidate' or 's-maxage' directive.
-    if (request.hasAuthorization() && !isPublic && !mustRevalidate && sMaxAgeSeconds == -1) {
-      return false;
-    }
-
-    if (noStore) {
-      return false;
-    }
-
-    return true;
-  }
-
-  /**
-   * Returns true if a Vary header contains an asterisk. Such responses cannot
-   * be cached.
-   */
-  public boolean hasVaryAll() {
-    return varyFields.contains("*");
-  }
-
-  /**
-   * Returns true if none of the Vary headers on this response have changed
-   * between {@code cachedRequest} and {@code newRequest}.
-   */
-  public boolean varyMatches(Map<String, List<String>> cachedRequest,
-      Map<String, List<String>> newRequest) {
-    for (String field : varyFields) {
-      if (!equal(cachedRequest.get(field), newRequest.get(field))) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  /** Returns the source to satisfy {@code request} given this cached response. */
-  public ResponseSource chooseResponseSource(long nowMillis, RequestHeaders request) {
-    // If this response shouldn't have been stored, it should never be used
-    // as a response source. This check should be redundant as long as the
-    // persistence store is well-behaved and the rules are constant.
-    if (!isCacheable(request)) {
-      return ResponseSource.NETWORK;
-    }
-
-    if (request.isNoCache() || request.hasConditions()) {
-      return ResponseSource.NETWORK;
-    }
-
-    long ageMillis = computeAge(nowMillis);
-    long freshMillis = computeFreshnessLifetime();
-
-    if (request.getMaxAgeSeconds() != -1) {
-      freshMillis = Math.min(freshMillis, TimeUnit.SECONDS.toMillis(request.getMaxAgeSeconds()));
-    }
-
-    long minFreshMillis = 0;
-    if (request.getMinFreshSeconds() != -1) {
-      minFreshMillis = TimeUnit.SECONDS.toMillis(request.getMinFreshSeconds());
-    }
-
-    long maxStaleMillis = 0;
-    if (!mustRevalidate && request.getMaxStaleSeconds() != -1) {
-      maxStaleMillis = TimeUnit.SECONDS.toMillis(request.getMaxStaleSeconds());
-    }
-
-    if (!noCache && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
-      if (ageMillis + minFreshMillis >= freshMillis) {
-        headers.add("Warning", "110 HttpURLConnection \"Response is stale\"");
-      }
-      long oneDayMillis = 24 * 60 * 60 * 1000L;
-      if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
-        headers.add("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
-      }
-      return ResponseSource.CACHE;
-    }
-
-    if (lastModified != null) {
-      request.setIfModifiedSince(lastModified);
-    } else if (servedDate != null) {
-      request.setIfModifiedSince(servedDate);
-    }
-
-    if (etag != null) {
-      request.setIfNoneMatch(etag);
-    }
-
-    return request.hasConditions() ? ResponseSource.CONDITIONAL_CACHE : ResponseSource.NETWORK;
-  }
-
-  /**
-   * Returns true if this cached response should be used; false if the
-   * network response should be used.
-   */
-  public boolean validate(ResponseHeaders networkResponse) {
-    if (networkResponse.headers.getResponseCode() == HttpURLConnection.HTTP_NOT_MODIFIED) {
-      return true;
-    }
-
-    // The HTTP spec says that if the network's response is older than our
-    // cached response, we may return the cache's response. Like Chrome (but
-    // unlike Firefox), this client prefers to return the newer response.
-    if (lastModified != null
-        && networkResponse.lastModified != null
-        && networkResponse.lastModified.getTime() < lastModified.getTime()) {
-      return true;
-    }
-
-    return false;
-  }
-
-  /**
-   * Combines this cached header with a network header as defined by RFC 2616,
-   * 13.5.3.
-   */
-  public ResponseHeaders combine(ResponseHeaders network) throws IOException {
-    RawHeaders result = new RawHeaders();
-    result.setStatusLine(headers.getStatusLine());
-
-    for (int i = 0; i < headers.length(); i++) {
-      String fieldName = headers.getFieldName(i);
-      String value = headers.getValue(i);
-      if ("Warning".equals(fieldName) && value.startsWith("1")) {
-        continue; // drop 100-level freshness warnings
-      }
-      if (!isEndToEnd(fieldName) || network.headers.get(fieldName) == null) {
-        result.add(fieldName, value);
-      }
-    }
-
-    for (int i = 0; i < network.headers.length(); i++) {
-      String fieldName = network.headers.getFieldName(i);
-      if (isEndToEnd(fieldName)) {
-        result.add(fieldName, network.headers.getValue(i));
-      }
-    }
-
-    return new ResponseHeaders(uri, result);
-  }
-
-  /**
-   * Returns true if {@code fieldName} is an end-to-end HTTP header, as
-   * defined by RFC 2616, 13.5.1.
-   */
-  private static boolean isEndToEnd(String fieldName) {
-    return !"Connection".equalsIgnoreCase(fieldName)
-        && !"Keep-Alive".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authenticate".equalsIgnoreCase(fieldName)
-        && !"Proxy-Authorization".equalsIgnoreCase(fieldName)
-        && !"TE".equalsIgnoreCase(fieldName)
-        && !"Trailers".equalsIgnoreCase(fieldName)
-        && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
-        && !"Upgrade".equalsIgnoreCase(fieldName);
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
index 3d7a71ec6a..7a1b3ce6ac 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
@@ -33,6 +33,7 @@
 import java.util.LinkedList;
 import java.util.List;
 import java.util.NoSuchElementException;
+import javax.net.ssl.SSLHandshakeException;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
 
@@ -148,7 +149,16 @@ public void connectFailed(Connection connection, IOException failure) {
       proxySelector.connectFailed(uri, failedRoute.getProxy().address(), failure);
     }
 
-    routeDatabase.failed(failedRoute, failure);
+    routeDatabase.failed(failedRoute);
+
+    // If the previously returned route's problem was not related to TLS, and
+    // the next route only changes the TLS mode, we shouldn't even attempt it.
+    // This suppresses it in both this selector and also in the route database.
+    if (hasNextTlsMode() && !(failure instanceof SSLHandshakeException)) {
+      boolean modernTls = nextTlsMode() == TLS_MODE_MODERN;
+      Route routeToSuppress = new Route(address, lastProxy, lastInetSocketAddress, modernTls);
+      routeDatabase.failed(routeToSuppress);
+    }
   }
 
   /** Resets {@link #nextProxy} to the first option. */
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index fce58f4742..3390588478 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -16,15 +16,35 @@
 
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.bytes.ByteString;
+import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.spdy.ErrorCode;
+import com.squareup.okhttp.internal.spdy.Header;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.CacheRequest;
-import java.net.URL;
+import java.net.ProtocolException;
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+
+import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
+import static com.squareup.okhttp.internal.spdy.Header.RESPONSE_STATUS;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_AUTHORITY;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_HOST;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_METHOD;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_PATH;
+import static com.squareup.okhttp.internal.spdy.Header.TARGET_SCHEME;
+import static com.squareup.okhttp.internal.spdy.Header.VERSION;
 
 public final class SpdyTransport implements Transport {
   private final HttpEngine httpEngine;
@@ -36,25 +56,21 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     this.spdyConnection = spdyConnection;
   }
 
-  @Override public OutputStream createRequestBody() throws IOException {
-    // TODO: if we aren't streaming up to the server, we should buffer the whole request
-    writeRequestHeaders();
+  @Override public OutputStream createRequestBody(Request request) throws IOException {
+    // TODO: if bufferRequestBody is set, we must buffer the whole request
+    writeRequestHeaders(request);
     return stream.getOutputStream();
   }
 
-  @Override public void writeRequestHeaders() throws IOException {
-    if (stream != null) {
-      return;
-    }
+  @Override public void writeRequestHeaders(Request request) throws IOException {
+    if (stream != null) return;
+
     httpEngine.writingRequestHeaders();
-    RawHeaders requestHeaders = httpEngine.requestHeaders.getHeaders();
-    String version = httpEngine.connection.getHttpMinorVersion() == 1 ? "HTTP/1.1" : "HTTP/1.0";
-    URL url = httpEngine.policy.getURL();
-    requestHeaders.addSpdyRequestHeaders(httpEngine.method, HttpEngine.requestPath(url), version,
-        HttpEngine.getOriginAddress(url), httpEngine.uri.getScheme());
     boolean hasRequestBody = httpEngine.hasRequestBody();
     boolean hasResponseBody = true;
-    stream = spdyConnection.newStream(requestHeaders.toNameValueBlock(), hasRequestBody,
+    String version = RequestLine.version(httpEngine.getConnection().getHttpMinorVersion());
+    stream = spdyConnection.newStream(
+        writeNameValueBlock(request, spdyConnection.getProtocol(), version), hasRequestBody,
         hasResponseBody);
     stream.setReadTimeout(httpEngine.client.getReadTimeout());
   }
@@ -67,33 +83,210 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     stream.getOutputStream().close();
   }
 
-  @Override public ResponseHeaders readResponseHeaders() throws IOException {
-    List<String> nameValueBlock = stream.getResponseHeaders();
-    RawHeaders rawHeaders = RawHeaders.fromNameValueBlock(nameValueBlock);
-    httpEngine.receiveHeaders(rawHeaders);
+  @Override public Response.Builder readResponseHeaders() throws IOException {
+    return readNameValueBlock(stream.getResponseHeaders(), spdyConnection.getProtocol());
+  }
+
+  /**
+   * Returns a list of alternating names and values containing a SPDY request.
+   * Names are all lowercase. No names are repeated. If any name has multiple
+   * values, they are concatenated using "\0" as a delimiter.
+   */
+  public static List<Header> writeNameValueBlock(Request request, Protocol protocol,
+      String version) {
+    Headers headers = request.headers();
+    // TODO: make the known header names constants.
+    List<Header> result = new ArrayList<Header>(headers.size() + 10);
+    result.add(new Header(TARGET_METHOD, request.method()));
+    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
+    String host = HttpEngine.hostHeader(request.url());
+    if (Protocol.SPDY_3 == protocol) {
+      result.add(new Header(VERSION, version));
+      result.add(new Header(TARGET_HOST, host));
+    } else if (Protocol.HTTP_2 == protocol) {
+      result.add(new Header(TARGET_AUTHORITY, host));
+    } else {
+      throw new AssertionError();
+    }
+    result.add(new Header(TARGET_SCHEME, request.url().getProtocol()));
+
+    Set<ByteString> names = new LinkedHashSet<ByteString>();
+    for (int i = 0; i < headers.size(); i++) {
+      // header names must be lowercase.
+      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
+      String value = headers.value(i);
+
+      // Drop headers that are forbidden when layering HTTP over SPDY.
+      if (isProhibitedHeader(protocol, name)) continue;
+
+      // They shouldn't be set, but if they are, drop them. We've already written them!
+      if (name.equals(TARGET_METHOD)
+          || name.equals(TARGET_PATH)
+          || name.equals(TARGET_SCHEME)
+          || name.equals(TARGET_AUTHORITY)
+          || name.equals(TARGET_HOST)
+          || name.equals(VERSION)) {
+        continue;
+      }
+
+      // If we haven't seen this name before, add the pair to the end of the list...
+      if (names.add(name)) {
+        result.add(new Header(name, value));
+        continue;
+      }
 
-    ResponseHeaders headers = new ResponseHeaders(httpEngine.uri, rawHeaders);
-    headers.setTransport("spdy/3");
-    return headers;
+      // ...otherwise concatenate the existing values and this value.
+      for (int j = 0; j < result.size(); j++) {
+        if (result.get(j).name.equals(name)) {
+          String concatenated = joinOnNull(result.get(j).value.utf8(), value);
+          result.set(j, new Header(name, concatenated));
+          break;
+        }
+      }
+    }
+    return result;
+  }
+
+  private static String joinOnNull(String first, String second) {
+    return new StringBuilder(first).append('\0').append(second).toString();
+  }
+
+  /** Returns headers for a name value block containing a SPDY response. */
+  public static Response.Builder readNameValueBlock(List<Header> headerBlock,
+      Protocol protocol) throws IOException {
+    String status = null;
+    String version = "HTTP/1.1"; // :version present only in spdy/3.
+
+    Headers.Builder headersBuilder = new Headers.Builder();
+    headersBuilder.set(OkHeaders.SELECTED_TRANSPORT, protocol.name.utf8());
+    headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.name.utf8());
+    for (int i = 0; i < headerBlock.size(); i++) {
+      ByteString name = headerBlock.get(i).name;
+      String values = headerBlock.get(i).value.utf8();
+      for (int start = 0; start < values.length(); ) {
+        int end = values.indexOf('\0', start);
+        if (end == -1) {
+          end = values.length();
+        }
+        String value = values.substring(start, end);
+        if (name.equals(RESPONSE_STATUS)) {
+          status = value;
+        } else if (name.equals(VERSION)) {
+          version = value;
+        } else if (!isProhibitedHeader(protocol, name)) { // Don't write forbidden headers!
+          headersBuilder.add(name.utf8(), value);
+        }
+        start = end + 1;
+      }
+    }
+    if (status == null) throw new ProtocolException("Expected ':status' header not present");
+    if (version == null) throw new ProtocolException("Expected ':version' header not present");
+
+    return new Response.Builder()
+        .statusLine(new StatusLine(version + " " + status))
+        .headers(headersBuilder.build());
   }
 
   @Override public InputStream getTransferStream(CacheRequest cacheRequest) throws IOException {
-    return new UnknownLengthHttpInputStream(stream.getInputStream(), cacheRequest, httpEngine);
+    return new SpdyInputStream(stream, cacheRequest, httpEngine);
   }
 
   @Override public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
       InputStream responseBodyIn) {
-    if (streamCanceled) {
-      if (stream != null) {
+    return true; // SPDY sockets are always reusable.
+  }
+
+  /** When true, this header should not be emitted or consumed. */
+  private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
+    boolean prohibited = false;
+    if (protocol == Protocol.SPDY_3) {
+      // http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1#TOC-3.2.1-Request
+      if (name.equalsAscii("connection")
+          || name.equalsAscii("host")
+          || name.equalsAscii("keep-alive")
+          || name.equalsAscii("proxy-connection")
+          || name.equalsAscii("transfer-encoding")) {
+        prohibited = true;
+      }
+    } else if (protocol == Protocol.HTTP_2) {
+      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
+      if (name.equalsAscii("connection")
+          || name.equalsAscii("host")
+          || name.equalsAscii("keep-alive")
+          || name.equalsAscii("proxy-connection")
+          || name.equalsAscii("te")
+          || name.equalsAscii("transfer-encoding")
+          || name.equalsAscii("encoding")
+          || name.equalsAscii("upgrade")) {
+        prohibited = true;
+      }
+    } else {
+      throw new AssertionError(protocol);
+    }
+    return prohibited;
+  }
+
+  /** An HTTP message body terminated by the end of the underlying stream. */
+  private static class SpdyInputStream extends AbstractHttpInputStream {
+    private final SpdyStream stream;
+    private boolean inputExhausted;
+
+    SpdyInputStream(SpdyStream stream, CacheRequest cacheRequest, HttpEngine httpEngine)
+        throws IOException {
+      super(stream.getInputStream(), httpEngine, cacheRequest);
+      this.stream = stream;
+    }
+
+    @Override public int read(byte[] buffer, int offset, int count) throws IOException {
+      checkOffsetAndCount(buffer.length, offset, count);
+      checkNotClosed();
+      if (in == null || inputExhausted) {
+        return -1;
+      }
+      int read = in.read(buffer, offset, count);
+      if (read == -1) {
+        inputExhausted = true;
+        endOfInput();
+        return -1;
+      }
+      cacheWrite(buffer, offset, read);
+      return read;
+    }
+
+    @Override public int available() throws IOException {
+      checkNotClosed();
+      return in == null ? 0 : in.available();
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+
+      if (!inputExhausted && cacheBody != null) {
+        discardStream(); // Could make inputExhausted true!
+      }
+
+      closed = true;
+
+      if (!inputExhausted) {
         stream.closeLater(ErrorCode.CANCEL);
-        return true;
-      } else {
-        // If stream is null, it either means that writeRequestHeaders wasn't called
-        // or that SpdyConnection#newStream threw an IOException. In both cases there's
-        // nothing to do here and this stream can't be reused.
+        unexpectedEndOfInput();
+      }
+    }
+
+    private boolean discardStream() {
+      try {
+        long socketTimeout = stream.getReadTimeoutMillis();
+        stream.setReadTimeout(socketTimeout);
+        stream.setReadTimeout(DISCARD_STREAM_TIMEOUT_MILLIS);
+        try {
+          Util.skipByReading(this, Long.MAX_VALUE, DISCARD_STREAM_TIMEOUT_MILLIS);
+          return true;
+        } finally {
+          stream.setReadTimeout(socketTimeout);
+        }
+      } catch (IOException e) {
         return false;
       }
     }
-    return true;
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
new file mode 100644
index 0000000000..d295891392
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
@@ -0,0 +1,89 @@
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+
+public final class StatusLine {
+  /** Numeric status code, 307: Temporary Redirect. */
+  public static final int HTTP_TEMP_REDIRECT = 307;
+  public static final int HTTP_CONTINUE = 100;
+
+  private final String statusLine;
+  private final int httpMinorVersion;
+  private final int responseCode;
+  private final String responseMessage;
+
+  /** Sets the response status line (like "HTTP/1.0 200 OK"). */
+  public StatusLine(String statusLine) throws IOException {
+    // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
+    // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
+
+    // Parse protocol like "HTTP/1.1" followed by a space.
+    int codeStart;
+    int httpMinorVersion;
+    if (statusLine.startsWith("HTTP/1.")) {
+      if (statusLine.length() < 9 || statusLine.charAt(8) != ' ') {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+      httpMinorVersion = statusLine.charAt(7) - '0';
+      codeStart = 9;
+      if (httpMinorVersion < 0 || httpMinorVersion > 9) {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+    } else if (statusLine.startsWith("ICY ")) {
+      // Shoutcast uses ICY instead of "HTTP/1.0".
+      httpMinorVersion = 0;
+      codeStart = 4;
+    } else {
+      throw new ProtocolException("Unexpected status line: " + statusLine);
+    }
+
+    // Parse response code like "200". Always 3 digits.
+    if (statusLine.length() < codeStart + 3) {
+      throw new ProtocolException("Unexpected status line: " + statusLine);
+    }
+    int responseCode;
+    try {
+      responseCode = Integer.parseInt(statusLine.substring(codeStart, codeStart + 3));
+    } catch (NumberFormatException e) {
+      throw new ProtocolException("Unexpected status line: " + statusLine);
+    }
+
+    // Parse an optional response message like "OK" or "Not Modified". If it
+    // exists, it is separated from the response code by a space.
+    String responseMessage = "";
+    if (statusLine.length() > codeStart + 3) {
+      if (statusLine.charAt(codeStart + 3) != ' ') {
+        throw new ProtocolException("Unexpected status line: " + statusLine);
+      }
+      responseMessage = statusLine.substring(codeStart + 4);
+    }
+
+    this.responseMessage = responseMessage;
+    this.responseCode = responseCode;
+    this.statusLine = statusLine;
+    this.httpMinorVersion = httpMinorVersion;
+  }
+
+  public String getStatusLine() {
+    return statusLine;
+  }
+
+  /**
+   * Returns the status line's HTTP minor version. This returns 0 for HTTP/1.0
+   * and 1 for HTTP/1.1. This returns 1 if the HTTP version is unknown.
+   */
+  public int httpMinorVersion() {
+    return httpMinorVersion != -1 ? httpMinorVersion : 1;
+  }
+
+  /** Returns the HTTP status code or -1 if it is unknown. */
+  public int code() {
+    return responseCode;
+  }
+
+  /** Returns the HTTP status message or null if it is unknown. */
+  public String message() {
+    return responseMessage;
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
index d408bfec03..b1c38fec5a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
@@ -16,12 +16,21 @@
 
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.CacheRequest;
 
 interface Transport {
+  /**
+   * The timeout to use while discarding a stream of input data. Since this is
+   * used for connection reuse, this timeout should be significantly less than
+   * the time it takes to establish a new connection.
+   */
+  int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
+
   /**
    * Returns an output stream where the request body can be written. The
    * returned stream will of one of two types:
@@ -38,10 +47,10 @@
    */
   // TODO: don't bother retransmitting the request body? It's quite a corner
   // case and there's uncertainty whether Firefox or Chrome do this
-  OutputStream createRequestBody() throws IOException;
+  OutputStream createRequestBody(Request request) throws IOException;
 
   /** This should update the HTTP engine's sentRequestMillis field. */
-  void writeRequestHeaders() throws IOException;
+  void writeRequestHeaders(Request request) throws IOException;
 
   /**
    * Sends the request body returned by {@link #createRequestBody} to the
@@ -53,7 +62,7 @@
   void flushRequest() throws IOException;
 
   /** Read response headers and update the cookie manager. */
-  ResponseHeaders readResponseHeaders() throws IOException;
+  Response.Builder readResponseHeaders() throws IOException;
 
   // TODO: make this the content stream?
   InputStream getTransferStream(CacheRequest cacheRequest) throws IOException;
diff --git a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java b/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
index 6636ca7cc6..a3dcf5c332 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
@@ -15,13 +15,27 @@
  */
 package com.squareup.okhttp;
 
+import com.squareup.okhttp.internal.RecordingHostnameVerifier;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.Dispatcher;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.SocketPolicy;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.SSLContext;
 import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
 public final class AsyncApiTest {
@@ -29,8 +43,18 @@
   private OkHttpClient client = new OkHttpClient();
   private RecordingReceiver receiver = new RecordingReceiver();
 
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+  private HttpResponseCache cache;
+
+  @Before public void setUp() throws Exception {
+    String tmp = System.getProperty("java.io.tmpdir");
+    File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
+    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
+  }
+
   @After public void tearDown() throws Exception {
     server.shutdown();
+    cache.delete();
   }
 
   @Test public void get() throws Exception {
@@ -39,12 +63,13 @@
         .addHeader("Content-Type: text/plain"));
     server.play();
 
-    Request request = new Request.Builder(server.getUrl("/"))
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
         .header("User-Agent", "AsyncApiTest")
         .build();
     client.enqueue(request, receiver);
 
-    receiver.await(request)
+    receiver.await(request.url())
         .assertCode(200)
         .assertContainsHeaders("Content-Type: text/plain")
         .assertBody("abc");
@@ -52,21 +77,295 @@
     assertTrue(server.takeRequest().getHeaders().contains("User-Agent: AsyncApiTest"));
   }
 
+  @Test public void connectionPooling() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+    server.play();
+
+    client.enqueue(new Request.Builder().url(server.getUrl("/a")).build(), receiver);
+    receiver.await(server.getUrl("/a")).assertBody("abc");
+
+    client.enqueue(new Request.Builder().url(server.getUrl("/b")).build(), receiver);
+    receiver.await(server.getUrl("/b")).assertBody("def");
+
+    client.enqueue(new Request.Builder().url(server.getUrl("/c")).build(), receiver);
+    receiver.await(server.getUrl("/c")).assertBody("ghi");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void tls() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.enqueue(request, receiver);
+
+    receiver.await(request.url()).assertHandshake();
+  }
+
+  @Test public void recoverFromTlsHandshakeFailure() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.enqueue(request, receiver);
+
+    receiver.await(request.url()).assertBody("abc");
+  }
+
   @Test public void post() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
     server.play();
 
-    Request request = new Request.Builder(server.getUrl("/"))
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
         .post(Request.Body.create(MediaType.parse("text/plain"), "def"))
         .build();
     client.enqueue(request, receiver);
 
-    receiver.await(request)
+    receiver.await(request.url())
         .assertCode(200)
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("def", recordedRequest.getUtf8Body());
     assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void cache() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    client.setOkResponseCache(cache);
+
+    Request request1 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.enqueue(request1, receiver);
+    receiver.await(request1.url()).assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    Request request2 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.enqueue(request2, receiver);
+    receiver.await(request2.url()).assertCode(200).assertBody("A");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void redirect() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .addHeader("Test", "Redirect from /a to /b")
+        .setBody("/a has moved!"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /c")
+        .addHeader("Test", "Redirect from /b to /c")
+        .setBody("/b has moved!"));
+    server.enqueue(new MockResponse().setBody("C"));
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    client.enqueue(request, receiver);
+
+    receiver.await(server.getUrl("/c"))
+        .assertCode(200)
+        .assertBody("C")
+        .redirectedBy()
+        .assertCode(302)
+        .assertContainsHeaders("Test: Redirect from /b to /c")
+        .redirectedBy()
+        .assertCode(301)
+        .assertContainsHeaders("Test: Redirect from /a to /b");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+  }
+
+  @Test public void redirectWithRedirectsDisabled() throws Exception {
+    client.setFollowProtocolRedirects(false);
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .addHeader("Test", "Redirect from /a to /b")
+        .setBody("/a has moved!"));
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    client.enqueue(request, receiver);
+
+    receiver.await(server.getUrl("/a"))
+        .assertCode(301)
+        .assertBody("/a has moved!")
+        .assertContainsHeaders("Location: /b");
+  }
+
+  @Test public void follow20Redirects() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/0")).build();
+    client.enqueue(request, receiver);
+    receiver.await(server.getUrl("/20"))
+        .assertCode(200)
+        .assertBody("Success!");
+  }
+
+  @Test public void doesNotFollow21Redirects() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/0")).build();
+    client.enqueue(request, receiver);
+    receiver.await(server.getUrl("/20")).assertFailure("Too many redirects: 21");
+  }
+
+  @Test public void canceledBeforeResponseReadIsNeverDelivered() throws Exception {
+    client.getDispatcher().setMaxRequests(1); // Force requests to be executed serially.
+    server.setDispatcher(new Dispatcher() {
+      char nextResponse = 'A';
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        client.cancel("request A");
+        return new MockResponse().setBody(Character.toString(nextResponse++));
+      }
+    });
+    server.play();
+
+    // Canceling a request after the server has received a request but before
+    // it has delivered the response. That request will never be received to the
+    // client.
+    Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    client.enqueue(requestA, receiver);
+    assertEquals("/a", server.takeRequest().getPath());
+
+    // We then make a second request (not canceled) to make sure the receiver
+    // has nothing left to wait for.
+    Request requestB = new Request.Builder().url(server.getUrl("/b")).tag("request B").build();
+    client.enqueue(requestB, receiver);
+    assertEquals("/b", server.takeRequest().getPath());
+    receiver.await(requestB.url()).assertBody("B");
+
+    // At this point we know the receiver is ready: if it hasn't received 'A'
+    // yet it never will.
+    receiver.assertNoResponse(requestA.url());
+  }
+
+  @Test public void canceledAfterResponseIsDeliveredDoesNothing() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<String> bodyRef = new AtomicReference<String>();
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    client.enqueue(request, new Response.Receiver() {
+      @Override public void onFailure(Failure failure) {
+        throw new AssertionError();
+      }
+
+      @Override public boolean onResponse(Response response) throws IOException {
+        client.cancel("request A");
+        bodyRef.set(response.body().string());
+        latch.countDown();
+        return true;
+      }
+    });
+
+    latch.await();
+    assertEquals("A", bodyRef.get());
+  }
+
+  @Test public void connectionReuseWhenResponseBodyConsumed() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.play();
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    client.enqueue(request, new Response.Receiver() {
+      @Override public void onFailure(Failure failure) {
+        throw new AssertionError();
+      }
+      @Override public boolean onResponse(Response response) throws IOException {
+        InputStream bytes = response.body().byteStream();
+        assertEquals('a', bytes.read());
+        assertEquals('b', bytes.read());
+        assertEquals('c', bytes.read());
+
+        // This request will share a connection with 'A' cause it's all done.
+        client.enqueue(new Request.Builder().url(server.getUrl("/b")).build(), receiver);
+        return true;
+      }
+    });
+
+    receiver.await(server.getUrl("/b")).assertCode(200).assertBody("def");
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reuse!
+  }
+
+  @Test public void postBodyRetransmittedOnRedirect() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b")
+        .setBody("Moved to /b !"));
+    server.enqueue(new MockResponse()
+        .setBody("This is b."));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .post(Request.Body.create(MediaType.parse("text/plain"), "body!"))
+        .build();
+    client.enqueue(request, receiver);
+
+    receiver.await(server.getUrl("/b"))
+        .assertCode(200)
+        .assertBody("This is b.");
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("body!", request1.getUtf8Body());
+    assertEquals("5", request1.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", request1.getHeader("Content-Type"));
+    assertEquals(0, request1.getSequenceNumber());
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("body!", request2.getUtf8Body());
+    assertEquals("5", request2.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", request2.getHeader("Content-Type"));
+    assertEquals(1, request2.getSequenceNumber());
   }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
index 12f7a3c0f3..59553a0153 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
@@ -24,8 +24,6 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
 import java.util.Arrays;
 import javax.net.ssl.SSLContext;
 import org.junit.After;
@@ -40,17 +38,7 @@
 
 public final class ConnectionPoolTest {
   private static final int KEEP_ALIVE_DURATION_MS = 5000;
-  private static final SSLContext sslContext;
-
-  static {
-    try {
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
 
   private final MockWebServer spdyServer = new MockWebServer();
   private InetSocketAddress spdySocketAddress;
@@ -73,33 +61,33 @@
 
     httpServer.play();
     httpAddress = new Address(httpServer.getHostName(), httpServer.getPort(), null, null,
-        HttpAuthenticator.SYSTEM_DEFAULT, null, Arrays.asList("spdy/3", "http/1.1"));
+        HttpAuthenticator.SYSTEM_DEFAULT, null, Protocol.SPDY3_AND_HTTP11);
     httpSocketAddress = new InetSocketAddress(InetAddress.getByName(httpServer.getHostName()),
         httpServer.getPort());
 
     spdyServer.play();
     spdyAddress = new Address(spdyServer.getHostName(), spdyServer.getPort(),
         sslContext.getSocketFactory(), new RecordingHostnameVerifier(),
-        HttpAuthenticator.SYSTEM_DEFAULT, null, Arrays.asList("spdy/3", "http/1.1"));
+        HttpAuthenticator.SYSTEM_DEFAULT, null,Protocol.SPDY3_AND_HTTP11);
     spdySocketAddress = new InetSocketAddress(InetAddress.getByName(spdyServer.getHostName()),
         spdyServer.getPort());
 
     Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true);
     Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress, true);
     httpA = new Connection(httpRoute);
-    httpA.connect(100, 100, null);
+    httpA.connect(200, 200, null);
     httpB = new Connection(httpRoute);
-    httpB.connect(100, 100, null);
+    httpB.connect(200, 200, null);
     httpC = new Connection(httpRoute);
-    httpC.connect(100, 100, null);
+    httpC.connect(200, 200, null);
     httpD = new Connection(httpRoute);
-    httpD.connect(100, 100, null);
+    httpD.connect(200, 200, null);
     httpE = new Connection(httpRoute);
-    httpE.connect(100, 100, null);
+    httpE.connect(200, 200, null);
     spdyA = new Connection(spdyRoute);
-    spdyA.connect(100, 100, null);
+    spdyA.connect(200, 200, null);
     spdyB = new Connection(spdyRoute);
-    spdyB.connect(100, 100, null);
+    spdyB.connect(200, 200, null);
   }
 
   @After public void tearDown() throws Exception {
@@ -121,7 +109,7 @@
     assertNull(connection);
 
     connection = new Connection(new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true));
-    connection.connect(100, 100, null);
+    connection.connect(200, 200, null);
     assertEquals(0, pool.getConnectionCount());
     pool.recycle(connection);
     assertEquals(1, pool.getConnectionCount());
diff --git a/okhttp/src/test/java/com/squareup/okhttp/DispatcherTest.java b/okhttp/src/test/java/com/squareup/okhttp/DispatcherTest.java
new file mode 100644
index 0000000000..034ed84b64
--- /dev/null
+++ b/okhttp/src/test/java/com/squareup/okhttp/DispatcherTest.java
@@ -0,0 +1,167 @@
+package com.squareup.okhttp;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.Executor;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class DispatcherTest {
+  RecordingExecutor executor = new RecordingExecutor();
+  RecordingReceiver receiver = new RecordingReceiver();
+  Dispatcher dispatcher = new Dispatcher(executor);
+  OkHttpClient client = new OkHttpClient().setDispatcher(dispatcher);
+
+  @Before public void setUp() throws Exception {
+    dispatcher.setMaxRequests(20);
+    dispatcher.setMaxRequestsPerHost(10);
+  }
+
+  @Test public void maxRequestsZero() throws Exception {
+    try {
+      dispatcher.setMaxRequests(0);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void maxPerHostZero() throws Exception {
+    try {
+      dispatcher.setMaxRequestsPerHost(0);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void enqueuedJobsRunImmediately() throws Exception {
+    client.enqueue(newRequest("http://a/1"), receiver);
+    executor.assertJobs("http://a/1");
+  }
+
+  @Test public void maxRequestsEnforced() throws Exception {
+    dispatcher.setMaxRequests(3);
+    client.enqueue(newRequest("http://a/1"), receiver);
+    client.enqueue(newRequest("http://a/2"), receiver);
+    client.enqueue(newRequest("http://b/1"), receiver);
+    client.enqueue(newRequest("http://b/2"), receiver);
+    executor.assertJobs("http://a/1", "http://a/2", "http://b/1");
+  }
+
+  @Test public void maxPerHostEnforced() throws Exception {
+    dispatcher.setMaxRequestsPerHost(2);
+    client.enqueue(newRequest("http://a/1"), receiver);
+    client.enqueue(newRequest("http://a/2"), receiver);
+    client.enqueue(newRequest("http://a/3"), receiver);
+    executor.assertJobs("http://a/1", "http://a/2");
+  }
+
+  @Test public void increasingMaxRequestsPromotesJobsImmediately() throws Exception {
+    dispatcher.setMaxRequests(2);
+    client.enqueue(newRequest("http://a/1"), receiver);
+    client.enqueue(newRequest("http://b/1"), receiver);
+    client.enqueue(newRequest("http://c/1"), receiver);
+    client.enqueue(newRequest("http://a/2"), receiver);
+    client.enqueue(newRequest("http://b/2"), receiver);
+    dispatcher.setMaxRequests(4);
+    executor.assertJobs("http://a/1", "http://b/1", "http://c/1", "http://a/2");
+  }
+
+  @Test public void increasingMaxPerHostPromotesJobsImmediately() throws Exception {
+    dispatcher.setMaxRequestsPerHost(2);
+    client.enqueue(newRequest("http://a/1"), receiver);
+    client.enqueue(newRequest("http://a/2"), receiver);
+    client.enqueue(newRequest("http://a/3"), receiver);
+    client.enqueue(newRequest("http://a/4"), receiver);
+    client.enqueue(newRequest("http://a/5"), receiver);
+    dispatcher.setMaxRequestsPerHost(4);
+    executor.assertJobs("http://a/1", "http://a/2", "http://a/3", "http://a/4");
+  }
+
+  @Test public void oldJobFinishesNewJobCanRunDifferentHost() throws Exception {
+    dispatcher.setMaxRequests(1);
+    client.enqueue(newRequest("http://a/1"), receiver);
+    client.enqueue(newRequest("http://b/1"), receiver);
+    executor.finishJob("http://a/1");
+    executor.assertJobs("http://b/1");
+  }
+
+  @Test public void oldJobFinishesNewJobWithSameHostStarts() throws Exception {
+    dispatcher.setMaxRequests(2);
+    dispatcher.setMaxRequestsPerHost(1);
+    client.enqueue(newRequest("http://a/1"), receiver);
+    client.enqueue(newRequest("http://b/1"), receiver);
+    client.enqueue(newRequest("http://b/2"), receiver);
+    client.enqueue(newRequest("http://a/2"), receiver);
+    executor.finishJob("http://a/1");
+    executor.assertJobs("http://b/1", "http://a/2");
+  }
+
+  @Test public void oldJobFinishesNewJobCantRunDueToHostLimit() throws Exception {
+    dispatcher.setMaxRequestsPerHost(1);
+    client.enqueue(newRequest("http://a/1"), receiver);
+    client.enqueue(newRequest("http://b/1"), receiver);
+    client.enqueue(newRequest("http://a/2"), receiver);
+    executor.finishJob("http://b/1");
+    executor.assertJobs("http://a/1");
+  }
+
+  @Test public void cancelingReadyJobPreventsItFromStarting() throws Exception {
+    dispatcher.setMaxRequestsPerHost(1);
+    client.enqueue(newRequest("http://a/1"), receiver);
+    client.enqueue(newRequest("http://a/2", "tag1"), receiver);
+    dispatcher.cancel("tag1");
+    executor.finishJob("http://a/1");
+    executor.assertJobs();
+  }
+
+  @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
+    dispatcher.setMaxRequests(1);
+    client.enqueue(newRequest("http://a/1", "tag1"), receiver);
+    client.enqueue(newRequest("http://a/2"), receiver);
+    dispatcher.cancel("tag1");
+    executor.assertJobs("http://a/1");
+    executor.finishJob("http://a/1");
+    executor.assertJobs("http://a/2");
+  }
+
+  class RecordingExecutor implements Executor {
+    private List<Job> jobs = new ArrayList<Job>();
+
+    @Override public void execute(Runnable command) {
+      jobs.add((Job) command);
+    }
+
+    public void assertJobs(String... expectedUrls) {
+      List<String> actualUrls = new ArrayList<String>();
+      for (Job job : jobs) {
+        actualUrls.add(job.request().urlString());
+      }
+      assertEquals(Arrays.asList(expectedUrls), actualUrls);
+    }
+
+    public void finishJob(String url) {
+      for (Iterator<Job> i = jobs.iterator(); i.hasNext(); ) {
+        Job job = i.next();
+        if (job.request().urlString().equals(url)) {
+          i.remove();
+          dispatcher.finished(job);
+          return;
+        }
+      }
+      throw new AssertionError("No such job: " + url);
+    }
+  }
+
+  private Request newRequest(String url) {
+    return new Request.Builder().url(url).build();
+  }
+
+  private Request newRequest(String url, String tag) {
+    return new Request.Builder().url(url).tag(tag).build();
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java b/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java
index f30ae98573..6628331a92 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java
@@ -20,6 +20,8 @@
 import java.util.List;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
 /**
@@ -45,8 +47,9 @@ public RecordedResponse assertCode(int expectedCode) {
 
   public RecordedResponse assertContainsHeaders(String... expectedHeaders) {
     List<String> actualHeaders = new ArrayList<String>();
-    for (int i = 0; i < response.headerCount(); i++) {
-      actualHeaders.add(response.headerName(i) + ": " + response.headerValue(i));
+    Headers headers = response.headers();
+    for (int i = 0; i < headers.size(); i++) {
+      actualHeaders.add(headers.name(i) + ": " + headers.value(i));
     }
     if (!actualHeaders.containsAll(Arrays.asList(expectedHeaders))) {
       fail("Expected: " + actualHeaders + "\nto contain: " + Arrays.toString(expectedHeaders));
@@ -58,4 +61,30 @@ public RecordedResponse assertBody(String expectedBody) {
     assertEquals(expectedBody, body);
     return this;
   }
+
+  public RecordedResponse assertHandshake() {
+    Handshake handshake = response.handshake();
+    assertNotNull(handshake.cipherSuite());
+    assertNotNull(handshake.peerPrincipal());
+    assertEquals(1, handshake.peerCertificates().size());
+    assertNull(handshake.localPrincipal());
+    assertEquals(0, handshake.localCertificates().size());
+    return this;
+  }
+
+  /**
+   * Asserts that the current response was redirected and returns a new recorded
+   * response for the original request.
+   */
+  public RecordedResponse redirectedBy() {
+    Response redirectedBy = response.redirectedBy();
+    assertNotNull(redirectedBy);
+    assertNull(redirectedBy.body());
+    return new RecordedResponse(redirectedBy.request(), redirectedBy, null, null);
+  }
+
+  public void assertFailure(String message) {
+    assertNotNull(failure);
+    assertEquals(message, failure.exception().getMessage());
+  }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java b/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java
index ee0db124a9..f5b54eede0 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java
@@ -15,9 +15,13 @@
  */
 package com.squareup.okhttp;
 
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.net.URL;
 import java.util.ArrayList;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -26,6 +30,8 @@
 public class RecordingReceiver implements Response.Receiver {
   public static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10);
 
+  private final Map<Response, ByteArrayOutputStream> inFlightResponses
+      = new LinkedHashMap<Response, ByteArrayOutputStream>();
   private final List<RecordedResponse> responses = new ArrayList<RecordedResponse>();
 
   @Override public synchronized void onFailure(Failure failure) {
@@ -33,21 +39,42 @@
     notifyAll();
   }
 
-  @Override public synchronized void onResponse(Response response) throws IOException {
-    responses.add(new RecordedResponse(
-        response.request(), response, response.body().string(), null));
-    notifyAll();
+  @Override public synchronized boolean onResponse(Response response) throws IOException {
+    ByteArrayOutputStream out = inFlightResponses.get(response);
+    if (out == null) {
+      out = new ByteArrayOutputStream();
+      inFlightResponses.put(response, out);
+    }
+
+    byte[] buffer = new byte[1024];
+    Response.Body body = response.body();
+
+    while (body.ready()) {
+      int c = body.byteStream().read(buffer);
+
+      if (c == -1) {
+        inFlightResponses.remove(response);
+        responses.add(new RecordedResponse(
+            response.request(), response, out.toString("UTF-8"), null));
+        notifyAll();
+        return true;
+      }
+
+      out.write(buffer, 0, c);
+    }
+
+    return false;
   }
 
   /**
    * Returns the recorded response triggered by {@code request}. Throws if the
    * response isn't enqueued before the timeout.
    */
-  public synchronized RecordedResponse await(Request request) throws Exception {
+  public synchronized RecordedResponse await(URL url) throws Exception {
     long timeoutMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime()) + TIMEOUT_MILLIS;
     while (true) {
       for (RecordedResponse recordedResponse : responses) {
-        if (recordedResponse.request == request) {
+        if (recordedResponse.request.url().equals(url)) {
           return recordedResponse;
         }
       }
@@ -57,6 +84,14 @@ public synchronized RecordedResponse await(Request request) throws Exception {
       wait(timeoutMillis - nowMillis);
     }
 
-    throw new AssertionError("Timed out waiting for response to " + request);
+    throw new AssertionError("Timed out waiting for response to " + url);
+  }
+
+  public synchronized void assertNoResponse(URL url) throws Exception {
+    for (RecordedResponse recordedResponse : responses) {
+      if (recordedResponse.request.url().equals(url)) {
+        throw new AssertionError("Expected no response for " + url);
+      }
+    }
   }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
new file mode 100644
index 0000000000..c8d9f22df0
--- /dev/null
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.net.URL;
+import java.util.List;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLSession;
+
+import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
+
+public final class ExternalHttp2Example {
+  public static void main(String[] args) throws Exception {
+    URL url = new URL("https://twitter.com/");
+    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient()
+        .setProtocols(Protocol.HTTP2_AND_HTTP_11).open(url);
+
+    connection.setHostnameVerifier(new HostnameVerifier() {
+      @Override public boolean verify(String s, SSLSession sslSession) {
+        System.out.println("VERIFYING " + s);
+        return true;
+      }
+    });
+
+    int responseCode = connection.getResponseCode();
+    System.out.println(responseCode);
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    // If null, probably you didn't add jetty's npn jar to your boot classpath!
+    if (protocolValues != null && !protocolValues.isEmpty()) {
+      System.out.println("PROTOCOL " + protocolValues.get(0));
+    }
+    BufferedReader reader =
+        new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
+    String line;
+    while ((line = reader.readLine()) != null) {
+      System.out.println(line);
+    }
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
index 11d7239050..dab90c138f 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
@@ -17,17 +17,22 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.net.URL;
+import java.util.List;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLSession;
 
+import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
+
 public final class ExternalSpdyExample {
   public static void main(String[] args) throws Exception {
     URL url = new URL("https://www.google.ca/");
-    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient().open(url);
+    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient()
+        .setProtocols(Protocol.SPDY3_AND_HTTP11).open(url);
 
     connection.setHostnameVerifier(new HostnameVerifier() {
       @Override public boolean verify(String s, SSLSession sslSession) {
@@ -38,6 +43,11 @@ public static void main(String[] args) throws Exception {
 
     int responseCode = connection.getResponseCode();
     System.out.println(responseCode);
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    // If null, probably you didn't add jetty's npn jar to your boot classpath!
+    if (protocolValues != null && !protocolValues.isEmpty()) {
+      System.out.println("PROTOCOL " + protocolValues.get(0));
+    }
 
     BufferedReader reader =
         new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
new file mode 100644
index 0000000000..36b63f07ed
--- /dev/null
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.spdy.Header;
+import java.io.IOException;
+import java.util.List;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.Util.headerEntries;
+import static junit.framework.Assert.assertNull;
+import static org.junit.Assert.assertEquals;
+
+public final class HeadersTest {
+  @Test public void parseNameValueBlock() throws IOException {
+    List<Header> headerBlock = headerEntries(
+        "cache-control", "no-cache, no-store",
+        "set-cookie", "Cookie1\u0000Cookie2",
+        ":status", "200 OK",
+        ":version", "HTTP/1.1");
+    Request request = new Request.Builder().url("http://square.com/").build();
+    Response response =
+        SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
+    Headers headers = response.headers();
+    assertEquals(5, headers.size());
+    assertEquals("HTTP/1.1 200 OK", response.statusLine());
+    assertEquals("no-cache, no-store", headers.get("cache-control"));
+    assertEquals("Cookie2", headers.get("set-cookie"));
+    assertEquals(Protocol.SPDY_3.name.utf8(), headers.get(OkHeaders.SELECTED_TRANSPORT));
+    assertEquals(OkHeaders.SELECTED_TRANSPORT, headers.name(0));
+    assertEquals(Protocol.SPDY_3.name.utf8(), headers.get(OkHeaders.SELECTED_PROTOCOL));
+    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(1));
+    assertEquals(Protocol.SPDY_3.name.utf8(), headers.value(1));
+    assertEquals("cache-control", headers.name(2));
+    assertEquals("no-cache, no-store", headers.value(2));
+    assertEquals("set-cookie", headers.name(3));
+    assertEquals("Cookie1", headers.value(3));
+    assertEquals("set-cookie", headers.name(4));
+    assertEquals("Cookie2", headers.value(4));
+    assertNull(headers.get(":status"));
+    assertNull(headers.get(":version"));
+  }
+
+  @Test public void readNameValueBlockDropsForbiddenHeadersSpdy3() throws IOException {
+    List<Header> headerBlock = headerEntries(
+        ":status", "200 OK",
+        ":version", "HTTP/1.1",
+        "connection", "close");
+    Request request = new Request.Builder().url("http://square.com/").build();
+    Response response =
+        SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
+    Headers headers = response.headers();
+    assertEquals(2, headers.size());
+    assertEquals(OkHeaders.SELECTED_TRANSPORT, headers.name(0));
+    assertEquals(Protocol.SPDY_3.name.utf8(), headers.value(0));
+    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(1));
+    assertEquals(Protocol.SPDY_3.name.utf8(), headers.value(1));;
+  }
+
+  @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
+    List<Header> headerBlock = headerEntries(
+        ":status", "200 OK",
+        ":version", "HTTP/1.1",
+        "connection", "close");
+    Request request = new Request.Builder().url("http://square.com/").build();
+    Response response = SpdyTransport.readNameValueBlock(headerBlock, Protocol.HTTP_2)
+        .request(request).build();
+    Headers headers = response.headers();
+    assertEquals(2, headers.size());
+    assertEquals(OkHeaders.SELECTED_TRANSPORT, headers.name(0));
+    assertEquals(Protocol.HTTP_2.name.utf8(), headers.value(0));
+    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(1));
+    assertEquals(Protocol.HTTP_2.name.utf8(), headers.value(1));
+  }
+
+  @Test public void toNameValueBlock() {
+    Request request = new Request.Builder()
+        .url("http://square.com/")
+        .header("cache-control", "no-cache, no-store")
+        .addHeader("set-cookie", "Cookie1")
+        .addHeader("set-cookie", "Cookie2")
+        .header(":status", "200 OK")
+        .build();
+    List<Header> headerBlock =
+        SpdyTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1");
+    List<Header> expected = headerEntries(
+        ":method", "GET",
+        ":path", "/",
+        ":version", "HTTP/1.1",
+        ":host", "square.com",
+        ":scheme", "http",
+        "cache-control", "no-cache, no-store",
+        "set-cookie", "Cookie1\u0000Cookie2",
+        ":status", "200 OK");
+    assertEquals(expected, headerBlock);
+  }
+
+  @Test public void toNameValueBlockDropsForbiddenHeadersSpdy3() {
+    Request request = new Request.Builder()
+        .url("http://square.com/")
+        .header("Connection", "close")
+        .header("Transfer-Encoding", "chunked")
+        .build();
+    List<Header> expected = headerEntries(
+        ":method", "GET",
+        ":path", "/",
+        ":version", "HTTP/1.1",
+        ":host", "square.com",
+        ":scheme", "http");
+    assertEquals(expected, SpdyTransport.writeNameValueBlock(request, Protocol.SPDY_3, "HTTP/1.1"));
+  }
+
+  @Test public void toNameValueBlockDropsForbiddenHeadersHttp2() {
+    Request request = new Request.Builder()
+        .url("http://square.com/")
+        .header("Connection", "upgrade")
+        .header("Upgrade", "websocket")
+        .build();
+    List<Header> expected = headerEntries(
+        ":method", "GET",
+        ":path", "/",
+        ":authority", "square.com",
+        ":scheme", "http");
+    assertEquals(expected,
+        SpdyTransport.writeNameValueBlock(request, Protocol.HTTP_2, "HTTP/1.1"));
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
new file mode 100644
index 0000000000..c1f4d3cf88
--- /dev/null
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Protocol;
+
+public class HttpOverHttp20Draft09Test extends HttpOverSpdyTest {
+
+  public HttpOverHttp20Draft09Test() {
+    super(Protocol.HTTP_2);
+    this.hostHeader = ":authority";
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
new file mode 100644
index 0000000000..4020bf4c25
--- /dev/null
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Protocol;
+
+public class HttpOverSpdy3Test extends HttpOverSpdyTest {
+
+  public HttpOverSpdy3Test() {
+    super(Protocol.SPDY_3);
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index 7720c5b615..83cabdecec 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -17,12 +17,14 @@
 
 import com.squareup.okhttp.HttpResponseCache;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.RecordingAuthenticator;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.SocketPolicy;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
@@ -31,58 +33,62 @@
 import java.net.Authenticator;
 import java.net.CookieManager;
 import java.net.HttpURLConnection;
-import java.net.InetAddress;
 import java.net.URL;
-import java.net.URLConnection;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSession;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /** Test how SPDY interacts with HTTP features. */
-public final class HttpOverSpdyTest {
+public abstract class HttpOverSpdyTest {
+
+  /** Protocol to test, for example {@link com.squareup.okhttp.Protocol#SPDY_3} */
+  private final Protocol protocol;
+  protected String hostHeader = ":host";
+
+  protected HttpOverSpdyTest(Protocol protocol){
+    this.protocol = protocol;
+  }
+
   private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
     public boolean verify(String hostname, SSLSession session) {
       return true;
     }
   };
 
-  private static final SSLContext sslContext;
-  static {
-    try {
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
   private final MockWebServer server = new MockWebServer();
   private final String hostName = server.getHostName();
   private final OkHttpClient client = new OkHttpClient();
+  private HttpURLConnection connection;
   private HttpResponseCache cache;
 
   @Before public void setUp() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
+    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_11));
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     String systemTmpDir = System.getProperty("java.io.tmpdir");
-    File cacheDir = new File(systemTmpDir, "HttpCache-" + UUID.randomUUID());
+    File cacheDir = new File(systemTmpDir, "HttpCache-" + protocol + "-" + UUID.randomUUID());
     cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
   }
 
@@ -96,7 +102,7 @@ public boolean verify(String hostname, SSLSession session) {
     server.enqueue(response);
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     assertContent("ABCDE", connection, Integer.MAX_VALUE);
     assertEquals(200, connection.getResponseCode());
     assertEquals("Sweet", connection.getResponseMessage());
@@ -104,30 +110,87 @@ public boolean verify(String hostname, SSLSession session) {
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
     assertContains(request.getHeaders(), ":scheme: https");
-    assertContains(request.getHeaders(), ":host: " + hostName + ":" + server.getPort());
+    assertContains(request.getHeaders(), hostHeader + ": " + hostName + ":" + server.getPort());
   }
 
   @Test public void emptyResponse() throws IOException {
     server.enqueue(new MockResponse());
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     assertEquals(-1, connection.getInputStream().read());
   }
 
-  @Test public void post() throws Exception {
+  byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+
+  /** An output stream can be written to more than once, so we can't guess content length. */
+   @Test public void noDefaultContentLengthOnPost() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDE");
+    server.enqueue(response);
+    server.play();
+
+    connection = client.open(server.getUrl("/foo"));
+    connection.setDoOutput(true);
+    connection.getOutputStream().write(postBytes);
+    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody());
+    assertNull(request.getHeader("Content-Length"));
+  }
+
+  @Test public void userSuppliedContentLengthHeader() throws Exception {
     MockResponse response = new MockResponse().setBody("ABCDE");
     server.enqueue(response);
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
+    connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
     connection.setDoOutput(true);
-    connection.getOutputStream().write("FGHIJ".getBytes(Util.UTF_8));
+    connection.getOutputStream().write(postBytes);
     assertContent("ABCDE", connection, Integer.MAX_VALUE);
 
     RecordedRequest request = server.takeRequest();
     assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("FGHIJ", request.getUtf8Body());
+    assertArrayEquals(postBytes, request.getBody());
+    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+  }
+
+  @Test public void closeAfterFlush() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDE");
+    server.enqueue(response);
+    server.play();
+
+    connection = client.open(server.getUrl("/foo"));
+    connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
+    connection.setDoOutput(true);
+    connection.getOutputStream().write(postBytes); // push bytes into SpdyDataOutputStream.buffer
+    connection.getOutputStream().flush(); // SpdyConnection.writeData subject to write window
+    connection.getOutputStream().close(); // SpdyConnection.writeData empty frame
+    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody());
+    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+  }
+
+  @Test public void setFixedLengthStreamingModeSetsContentLength() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDE");
+    server.enqueue(response);
+    server.play();
+
+    connection = client.open(server.getUrl("/foo"));
+    connection.setFixedLengthStreamingMode(postBytes.length);
+    connection.setDoOutput(true);
+    connection.getOutputStream().write(postBytes);
+    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody());
+    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
   }
 
   @Test public void spdyConnectionReuse() throws Exception {
@@ -145,6 +208,20 @@ public boolean verify(String hostname, SSLSession session) {
     assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
+  @Test @Ignore public void synchronousSpdyRequest() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+
+    ExecutorService executor = Executors.newCachedThreadPool();
+    CountDownLatch countDownLatch = new CountDownLatch(2);
+    executor.execute(new SpdyRequest("/r1", countDownLatch));
+    executor.execute(new SpdyRequest("/r2", countDownLatch));
+    countDownLatch.await();
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
   @Test public void gzippedResponseBody() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Encoding: gzip")
         .setBody(gzip("ABCABCABC".getBytes(Util.UTF_8))));
@@ -160,7 +237,7 @@ public boolean verify(String hostname, SSLSession session) {
     server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
     RecordedRequest denied = server.takeRequest();
@@ -178,7 +255,7 @@ public boolean verify(String hostname, SSLSession session) {
     server.enqueue(new MockResponse().setBody("This is the new location!"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertContent("This is the new location!", connection, Integer.MAX_VALUE);
 
     RecordedRequest request1 = server.takeRequest();
@@ -191,15 +268,40 @@ public boolean verify(String hostname, SSLSession session) {
     server.enqueue(new MockResponse().setBody("ABC"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals("ABC", readAscii(in, 3));
     assertEquals(-1, in.read());
     assertEquals(-1, in.read());
   }
 
+  @Test(timeout = 3000) public void readResponseHeaderTimeout() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+
+    connection = client.open(server.getUrl("/"));
+    connection.setReadTimeout(1000);
+    assertContent("A", connection, Integer.MAX_VALUE);
+  }
+
+  @Test public void spdyConnectionTimeout() throws Exception {
+    MockResponse response = new MockResponse().setBody("A");
+    response.setBodyDelayTimeMs(1000);
+    server.enqueue(response);
+    server.play();
+
+    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    connection1.setReadTimeout(2000);
+    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    connection2.setReadTimeout(200);
+    connection1.connect();
+    connection2.connect();
+    assertContent("A", connection1, Integer.MAX_VALUE);
+  }
+
   @Test public void responsesAreCached() throws IOException {
-    client.setResponseCache(cache);
+    client.setOkResponseCache(cache);
 
     server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("A"));
     server.play();
@@ -216,7 +318,7 @@ public boolean verify(String hostname, SSLSession session) {
   }
 
   @Test public void conditionalCache() throws IOException {
-    client.setResponseCache(cache);
+    client.setOkResponseCache(cache);
 
     server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
@@ -232,6 +334,24 @@ public boolean verify(String hostname, SSLSession session) {
     assertEquals(1, cache.getHitCount());
   }
 
+  @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
+    client.setOkResponseCache(cache);
+
+    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("ABCD"));
+    server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("EFGH"));
+    server.play();
+
+    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    InputStream in1 = connection1.getInputStream();
+    assertEquals("AB", readAscii(in1, 2));
+    in1.close();
+
+    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    InputStream in2 = connection2.getInputStream();
+    assertEquals("ABCD", readAscii(in2, Integer.MAX_VALUE));
+    in2.close();
+  }
+
   @Test public void acceptAndTransmitCookies() throws Exception {
     CookieManager cookieManager = new CookieManager();
     client.setCookieHandler(cookieManager);
@@ -258,11 +378,10 @@ public boolean verify(String hostname, SSLSession session) {
     assertTrue(collection.toString(), collection.contains(value));
   }
 
-  private void assertContent(String expected, URLConnection connection, int limit)
+  private void assertContent(String expected, HttpURLConnection connection, int limit)
       throws IOException {
     connection.connect();
     assertEquals(expected, readAscii(connection.getInputStream(), limit));
-    ((HttpURLConnection) connection).disconnect();
   }
 
   private void assertContainsNoneMatching(List<String> headers, String pattern) {
@@ -293,4 +412,23 @@ private String readAscii(InputStream in, int count) throws IOException {
     gzippedOut.close();
     return bytesOut.toByteArray();
   }
+
+  class SpdyRequest implements Runnable {
+    String path;
+    CountDownLatch countDownLatch;
+    public SpdyRequest(String path, CountDownLatch countDownLatch) {
+      this.path = path;
+      this.countDownLatch = countDownLatch;
+    }
+
+    @Override public void run() {
+      try {
+        HttpURLConnection conn = client.open(server.getUrl(path));
+        assertEquals("A", readAscii(conn.getInputStream(), 1));
+        countDownLatch.countDown();
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }
+  }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
index cbbeb987a2..40a35e7e31 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
@@ -18,6 +18,9 @@
 
 import com.squareup.okhttp.HttpResponseCache;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkResponseCache;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseSource;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
@@ -39,22 +42,18 @@
 import java.net.CookieManager;
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
-import java.net.InetAddress;
 import java.net.ResponseCache;
 import java.net.SecureCacheResponse;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.URLConnection;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
@@ -63,6 +62,7 @@
 import java.util.TimeZone;
 import java.util.UUID;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.zip.GZIPOutputStream;
@@ -89,23 +89,15 @@
       return true;
     }
   };
+
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+
   private final OkHttpClient client = new OkHttpClient();
   private MockWebServer server = new MockWebServer();
   private MockWebServer server2 = new MockWebServer();
   private HttpResponseCache cache;
   private final CookieManager cookieManager = new CookieManager();
 
-  private static final SSLContext sslContext;
-  static {
-    try {
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
   @Before public void setUp() throws Exception {
     String tmp = System.getProperty("java.io.tmpdir");
     File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
@@ -212,11 +204,10 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
     // exhaust the content stream
     readAscii(conn);
 
-    CacheResponse cached =
-        cache.get(url.toURI(), "GET", Collections.<String, List<String>>emptyMap());
+    Response cached = cache.get(new Request.Builder().url(url).build());
     if (shouldPut) {
       assertNotNull(Integer.toString(responseCode), cached);
-      cached.getBody().close();
+      cached.body().close();
     } else {
       assertNull(Integer.toString(responseCode), cached);
     }
@@ -231,40 +222,21 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
     final String body = "ABCDE";
     final AtomicInteger cacheCount = new AtomicInteger();
 
-    server.enqueue(
-        new MockResponse().setStatus("HTTP/1.1 200 Fantastic").addHeader("fgh: ijk").setBody(body));
-    server.play();
-
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        return null;
-      }
-
-      @Override public CacheRequest put(URI uri, URLConnection conn) throws IOException {
-        HttpURLConnection httpConnection = (HttpURLConnection) conn;
-        try {
-          httpConnection.getRequestProperties();
-          fail();
-        } catch (IllegalStateException expected) {
-        }
-        try {
-          httpConnection.addRequestProperty("K", "V");
-          fail();
-        } catch (IllegalStateException expected) {
-        }
-        assertEquals("HTTP/1.1 200 Fantastic", httpConnection.getHeaderField(null));
-        assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"),
-            httpConnection.getHeaderFields().get(null));
-        assertEquals(200, httpConnection.getResponseCode());
-        assertEquals("Fantastic", httpConnection.getResponseMessage());
-        assertEquals(body.length(), httpConnection.getContentLength());
-        assertEquals("ijk", httpConnection.getHeaderField("fgh"));
-        try {
-          httpConnection.getInputStream(); // the RI doesn't forbid this, but it should
-          fail();
-        } catch (IOException expected) {
-        }
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 200 Fantastic")
+        .addHeader("Content-Type: text/plain")
+        .addHeader("fgh: ijk")
+        .setBody(body));
+    server.play();
+
+    client.setOkResponseCache(new AbstractOkResponseCache() {
+      @Override public CacheRequest put(Response response) throws IOException {
+        assertEquals(server.getUrl("/"), response.request().url());
+        assertEquals(200, response.code());
+        assertNull(response.body());
+        assertEquals("5", response.header("Content-Length"));
+        assertEquals("text/plain", response.header("Content-Type"));
+        assertEquals("ijk", response.header("fgh"));
         cacheCount.incrementAndGet();
         return null;
       }
@@ -276,6 +248,32 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
     assertEquals(1, cacheCount.get());
   }
 
+  /** Don't explode if the cache returns a null body. http://b/3373699 */
+  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
+    final AtomicBoolean aborted = new AtomicBoolean();
+    client.setOkResponseCache(new AbstractOkResponseCache() {
+      @Override public CacheRequest put(Response response) throws IOException {
+        return new CacheRequest() {
+          @Override public void abort() {
+            aborted.set(true);
+          }
+
+          @Override public OutputStream getBody() throws IOException {
+            return null;
+          }
+        };
+      }
+    });
+
+    server.enqueue(new MockResponse().setBody("abcdef"));
+    server.play();
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals("abc", readAscii(connection, 3));
+    connection.getInputStream().close();
+    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
+  }
+
   @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
     testResponseCaching(TransferKind.FIXED_LENGTH);
   }
@@ -334,32 +332,32 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("ABC"));
     server.play();
 
-    HttpsURLConnection connection = (HttpsURLConnection) client.open(server.getUrl("/"));
-    connection.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(connection));
+    HttpsURLConnection c1 = (HttpsURLConnection) client.open(server.getUrl("/"));
+    c1.setSSLSocketFactory(sslContext.getSocketFactory());
+    c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("ABC", readAscii(c1));
 
     // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    String suite = connection.getCipherSuite();
-    List<Certificate> localCerts = toListOrNull(connection.getLocalCertificates());
-    List<Certificate> serverCerts = toListOrNull(connection.getServerCertificates());
-    Principal peerPrincipal = connection.getPeerPrincipal();
-    Principal localPrincipal = connection.getLocalPrincipal();
-
-    connection = (HttpsURLConnection) client.open(server.getUrl("/")); // cached!
-    connection.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(connection));
+    String suite = c1.getCipherSuite();
+    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
+    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
+    Principal peerPrincipal = c1.getPeerPrincipal();
+    Principal localPrincipal = c1.getLocalPrincipal();
+
+    HttpsURLConnection c2 = (HttpsURLConnection) client.open(server.getUrl("/")); // cached!
+    c2.setSSLSocketFactory(sslContext.getSocketFactory());
+    c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("ABC", readAscii(c2));
 
     assertEquals(2, cache.getRequestCount());
     assertEquals(1, cache.getNetworkCount());
     assertEquals(1, cache.getHitCount());
 
-    assertEquals(suite, connection.getCipherSuite());
-    assertEquals(localCerts, toListOrNull(connection.getLocalCertificates()));
-    assertEquals(serverCerts, toListOrNull(connection.getServerCertificates()));
-    assertEquals(peerPrincipal, connection.getPeerPrincipal());
-    assertEquals(localPrincipal, connection.getLocalPrincipal());
+    assertEquals(suite, c2.getCipherSuite());
+    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
+    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
+    assertEquals(peerPrincipal, c2.getPeerPrincipal());
+    assertEquals(localPrincipal, c2.getLocalPrincipal());
   }
 
   @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
@@ -445,13 +443,16 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
     HttpsURLConnection connection1 = (HttpsURLConnection) client.open(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection1));
+    assertNotNull(connection1.getCipherSuite());
 
     // Cached!
     HttpsURLConnection connection2 = (HttpsURLConnection) client.open(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection2));
+    assertNotNull(connection2.getCipherSuite());
 
     assertEquals(4, cache.getRequestCount()); // 2 direct + 2 redirect = 4
     assertEquals(2, cache.getHitCount());
+    assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
   }
 
   /**
@@ -494,15 +495,10 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setBody("ABC"));
     server.play();
 
-    final AtomicReference<Map<String, List<String>>> requestHeadersRef =
-        new AtomicReference<Map<String, List<String>>>();
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        requestHeadersRef.set(requestHeaders);
-        return null;
-      }
-      @Override public CacheRequest put(URI uri, URLConnection conn) throws IOException {
+    final AtomicReference<Request> requestRef = new AtomicReference<Request>();
+    client.setOkResponseCache(new AbstractOkResponseCache() {
+      @Override public Response get(Request request) throws IOException {
+        requestRef.set(request);
         return null;
       }
     });
@@ -511,7 +507,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     URLConnection urlConnection = openConnection(url);
     urlConnection.addRequestProperty("A", "android");
     readAscii(urlConnection);
-    assertEquals(Arrays.asList("android"), requestHeadersRef.get().get("A"));
+    assertEquals(Arrays.asList("android"), requestRef.get().headers("A"));
   }
 
   @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
@@ -568,7 +564,7 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
 
   private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
     // Setting a low transfer speed ensures that stream discarding will time out.
-    MockResponse response = new MockResponse().setBytesPerSecond(6);
+    MockResponse response = new MockResponse().throttleBody(6, 1, TimeUnit.SECONDS);
     transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
     server.enqueue(response);
     server.enqueue(new MockResponse().setBody("Request #2"));
@@ -774,7 +770,7 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
 
     URLConnection request2 = openConnection(url);
     if (expectCached) {
-      assertEquals("1", request1.getHeaderField("X-Response-ID"));
+      assertEquals("1", request2.getHeaderField("X-Response-ID"));
     } else {
       assertEquals("2", request2.getHeaderField("X-Response-ID"));
     }
@@ -1048,6 +1044,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
+    assertEquals(1, cache.getRequestCount());
+    assertEquals(0, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
   }
 
   @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
@@ -1060,6 +1059,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     URLConnection connection = openConnection(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(1, cache.getHitCount());
   }
 
   @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
@@ -1072,6 +1074,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
   }
 
   @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
@@ -1082,6 +1087,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertGatewayTimeout(connection);
+    assertEquals(2, cache.getRequestCount());
+    assertEquals(1, cache.getNetworkCount());
+    assertEquals(0, cache.getHitCount());
   }
 
   @Test public void requestCacheControlNoCache() throws Exception {
@@ -1684,8 +1692,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
 
-    String source = connection.getHeaderField(ResponseHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CACHE.toString() + " 200", source);
+    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
+    assertEquals(ResponseSource.CACHE + " 200", source);
   }
 
   @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
@@ -1701,8 +1709,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("B", readAscii(connection));
 
-    String source = connection.getHeaderField(ResponseHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CONDITIONAL_CACHE.toString() + " 200", source);
+    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
+    assertEquals(ResponseSource.CONDITIONAL_CACHE + " 200", source);
   }
 
   @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
@@ -1716,8 +1724,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
 
-    String source = connection.getHeaderField(ResponseHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CONDITIONAL_CACHE.toString() + " 304", source);
+    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
+    assertEquals(ResponseSource.CONDITIONAL_CACHE + " 304", source);
   }
 
   @Test public void responseSourceHeaderFetched() throws IOException {
@@ -1727,8 +1735,8 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     URLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
 
-    String source = connection.getHeaderField(ResponseHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.NETWORK.toString() + " 200", source);
+    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
+    assertEquals(ResponseSource.NETWORK + " 200", source);
   }
 
   @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
@@ -1819,7 +1827,7 @@ private String formatDate(long delta, TimeUnit timeUnit) {
 
   private String formatDate(Date date) {
     DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone("UTC"));
+    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
     return rfc1123.format(date);
   }
 
@@ -1911,7 +1919,8 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
   private String readAscii(URLConnection connection, int count) throws IOException {
     HttpURLConnection httpConnection = (HttpURLConnection) connection;
     InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
-        ? connection.getInputStream() : httpConnection.getErrorStream();
+        ? connection.getInputStream()
+        : httpConnection.getErrorStream();
     StringBuilder result = new StringBuilder();
     for (int i = 0; i < count; i++) {
       int value = in.read();
@@ -1942,6 +1951,8 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
     }
     assertEquals(504, connection.getResponseCode());
     assertEquals(-1, connection.getErrorStream().read());
+    assertEquals(ResponseSource.NONE + " 504",
+        connection.getHeaderField(OkHeaders.RESPONSE_SOURCE));
   }
 
   enum TransferKind {
@@ -2010,4 +2021,27 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
       return response;
     }
   }
+
+  static abstract class AbstractOkResponseCache implements OkResponseCache {
+    @Override public Response get(Request request) throws IOException {
+      return null;
+    }
+
+    @Override public CacheRequest put(Response response) throws IOException {
+      return null;
+    }
+
+    @Override public boolean maybeRemove(Request request) throws IOException {
+      return false;
+    }
+
+    @Override public void update(Response cached, Response network) throws IOException {
+    }
+
+    @Override public void trackConditionalCacheHit() {
+    }
+
+    @Override public void trackResponse(ResponseSource source) {
+    }
+  }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RawHeadersTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/RawHeadersTest.java
deleted file mode 100644
index 4ce80a5ebb..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RawHeadersTest.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import org.junit.Test;
-
-import static junit.framework.Assert.assertNull;
-import static org.junit.Assert.assertEquals;
-
-public final class RawHeadersTest {
-  @Test public void parseNameValueBlock() throws IOException {
-    List<String> nameValueBlock = Arrays.asList(
-        "cache-control", "no-cache, no-store",
-        "set-cookie", "Cookie1\u0000Cookie2",
-        ":status", "200 OK",
-        ":version", "HTTP/1.1");
-    RawHeaders rawHeaders = RawHeaders.fromNameValueBlock(nameValueBlock);
-    assertEquals(3, rawHeaders.length());
-    assertEquals("HTTP/1.1 200 OK", rawHeaders.getStatusLine());
-    assertEquals("no-cache, no-store", rawHeaders.get("cache-control"));
-    assertEquals("Cookie2", rawHeaders.get("set-cookie"));
-    assertEquals("cache-control", rawHeaders.getFieldName(0));
-    assertEquals("no-cache, no-store", rawHeaders.getValue(0));
-    assertEquals("set-cookie", rawHeaders.getFieldName(1));
-    assertEquals("Cookie1", rawHeaders.getValue(1));
-    assertEquals("set-cookie", rawHeaders.getFieldName(2));
-    assertEquals("Cookie2", rawHeaders.getValue(2));
-    assertNull(rawHeaders.get(":status"));
-    assertNull(rawHeaders.get(":version"));
-  }
-
-  @Test public void toNameValueBlock() {
-    RawHeaders rawHeaders = new RawHeaders();
-    rawHeaders.add("cache-control", "no-cache, no-store");
-    rawHeaders.add("set-cookie", "Cookie1");
-    rawHeaders.add("set-cookie", "Cookie2");
-    rawHeaders.add(":status", "200 OK");
-    // TODO: fromNameValueBlock should take the status line headers
-    List<String> nameValueBlock = rawHeaders.toNameValueBlock();
-    List<String> expected =
-        Arrays.asList("cache-control", "no-cache, no-store", "set-cookie", "Cookie1\u0000Cookie2",
-            ":status", "200 OK");
-    assertEquals(expected, nameValueBlock);
-  }
-
-  @Test public void toNameValueBlockDropsForbiddenHeaders() {
-    RawHeaders rawHeaders = new RawHeaders();
-    rawHeaders.add("Connection", "close");
-    rawHeaders.add("Transfer-Encoding", "chunked");
-    assertEquals(Arrays.<String>asList(), rawHeaders.toNameValueBlock());
-  }
-
-  @Test public void statusMessage() throws IOException {
-    RawHeaders rawHeaders = new RawHeaders();
-    final String message = "Temporary Redirect";
-    final int version = 1;
-    final int code = 200;
-    rawHeaders.setStatusLine("HTTP/1." + version + " " + code + " " + message);
-    assertEquals(message, rawHeaders.getResponseMessage());
-    assertEquals(version, rawHeaders.getHttpMinorVersion());
-    assertEquals(code, rawHeaders.getResponseCode());
-  }
-
-  @Test public void statusMessageWithEmptyMessage() throws IOException {
-    RawHeaders rawHeaders = new RawHeaders();
-    final int version = 1;
-    final int code = 503;
-    rawHeaders.setStatusLine("HTTP/1." + version + " " + code + " ");
-    assertEquals("", rawHeaders.getResponseMessage());
-    assertEquals(version, rawHeaders.getHttpMinorVersion());
-    assertEquals(code, rawHeaders.getResponseCode());
-  }
-
-  /**
-   * This is not defined in the protocol but some servers won't add the leading
-   * empty space when the message is empty.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
-   */
-  @Test public void statusMessageWithEmptyMessageAndNoLeadingSpace() throws IOException {
-    RawHeaders rawHeaders = new RawHeaders();
-    final int version = 1;
-    final int code = 503;
-    rawHeaders.setStatusLine("HTTP/1." + version + " " + code);
-    assertEquals("", rawHeaders.getResponseMessage());
-    assertEquals(version, rawHeaders.getHttpMinorVersion());
-    assertEquals(code, rawHeaders.getResponseCode());
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
index a92db9ee14..ea3dc57976 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
@@ -19,6 +19,7 @@
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.OkAuthenticator;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.RouteDatabase;
 import com.squareup.okhttp.internal.Dns;
 import com.squareup.okhttp.internal.SslContextBuilder;
@@ -59,16 +60,14 @@
   private static final String uriHost = "hostA";
   private static final int uriPort = 80;
 
-  private static final SSLContext sslContext;
-  private static final SSLSocketFactory socketFactory;
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+  private static final SSLSocketFactory socketFactory = sslContext.getSocketFactory();
   private static final HostnameVerifier hostnameVerifier;
   private static final ConnectionPool pool;
 
   static {
     try {
       uri = new URI("http://" + uriHost + ":" + uriPort + "/path");
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-      socketFactory = sslContext.getSocketFactory();
       pool = ConnectionPool.getDefault();
       hostnameVerifier = HttpsURLConnectionImpl.getDefaultHostnameVerifier();
     } catch (Exception e) {
@@ -77,12 +76,12 @@
   }
 
   private final OkAuthenticator authenticator = HttpAuthenticator.SYSTEM_DEFAULT;
-  private final List<String> transports = Arrays.asList("http/1.1");
+  private final List<Protocol> protocols = Arrays.asList(Protocol.HTTP_11);
   private final FakeDns dns = new FakeDns();
   private final FakeProxySelector proxySelector = new FakeProxySelector();
 
   @Test public void singleRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
+    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
         new RouteDatabase());
 
@@ -101,7 +100,7 @@
   }
 
   @Test public void singleRouteReturnsFailedRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
+    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
         new RouteDatabase());
 
@@ -109,7 +108,7 @@
     dns.inetAddresses = makeFakeAddresses(255, 1);
     Connection connection = routeSelector.next("GET");
     RouteDatabase routeDatabase = new RouteDatabase();
-    routeDatabase.failed(connection.getRoute(), new IOException());
+    routeDatabase.failed(connection.getRoute());
     routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns, routeDatabase);
     assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
         false);
@@ -122,7 +121,7 @@
   }
 
   @Test public void explicitProxyTriesThatProxiesAddressesOnly() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, proxyA, transports);
+    Address address = new Address(uriHost, uriPort, null, null, authenticator, proxyA, protocols);
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
         new RouteDatabase());
 
@@ -140,7 +139,7 @@
 
   @Test public void explicitDirectProxy() throws Exception {
     Address address = new Address(uriHost, uriPort, null, null, authenticator, NO_PROXY,
-        transports);
+        protocols);
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
         new RouteDatabase());
 
@@ -157,7 +156,7 @@
   }
 
   @Test public void proxySelectorReturnsNull() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
+    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
 
     proxySelector.proxies = null;
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
@@ -174,7 +173,7 @@
   }
 
   @Test public void proxySelectorReturnsNoProxies() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
+    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
         new RouteDatabase());
 
@@ -191,7 +190,7 @@
   }
 
   @Test public void proxySelectorReturnsMultipleProxies() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
+    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
 
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
@@ -226,7 +225,7 @@
   }
 
   @Test public void proxySelectorDirectConnectionsAreSkipped() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
+    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
 
     proxySelector.proxies.add(NO_PROXY);
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
@@ -244,7 +243,7 @@
   }
 
   @Test public void proxyDnsFailureContinuesToNextProxy() throws Exception {
-    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, transports);
+    Address address = new Address(uriHost, uriPort, null, null, authenticator, null, protocols);
 
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
@@ -283,9 +282,10 @@
     assertFalse(routeSelector.hasNext());
   }
 
+  // https://github.com/square/okhttp/issues/442
   @Test public void nonSslErrorAddsAllTlsModesToFailedRoute() throws Exception {
     Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        Proxy.NO_PROXY, transports);
+        Proxy.NO_PROXY, protocols);
     RouteDatabase routeDatabase = new RouteDatabase();
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
         routeDatabase);
@@ -294,11 +294,12 @@
     Connection connection = routeSelector.next("GET");
     routeSelector.connectFailed(connection, new IOException("Non SSL exception"));
     assertTrue(routeDatabase.failedRoutesCount() == 2);
+    assertFalse(routeSelector.hasNext());
   }
 
   @Test public void sslErrorAddsOnlyFailedTlsModeToFailedRoute() throws Exception {
     Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        Proxy.NO_PROXY, transports);
+        Proxy.NO_PROXY, protocols);
     RouteDatabase routeDatabase = new RouteDatabase();
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
         routeDatabase);
@@ -307,11 +308,12 @@
     Connection connection = routeSelector.next("GET");
     routeSelector.connectFailed(connection, new SSLHandshakeException("SSL exception"));
     assertTrue(routeDatabase.failedRoutesCount() == 1);
+    assertTrue(routeSelector.hasNext());
   }
 
   @Test public void multipleProxiesMultipleInetAddressesMultipleTlsModes() throws Exception {
     Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        null, transports);
+        null, protocols);
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
@@ -358,7 +360,7 @@
 
   @Test public void failedRoutesAreLast() throws Exception {
     Address address = new Address(uriHost, uriPort, socketFactory, hostnameVerifier, authenticator,
-        Proxy.NO_PROXY, transports);
+        Proxy.NO_PROXY, protocols);
 
     RouteDatabase routeDatabase = new RouteDatabase();
     RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
@@ -374,7 +376,7 @@
     // Check that we do indeed have more than one route.
     assertTrue(regularRoutes.size() > 1);
     // Add first regular route as failed.
-    routeDatabase.failed(regularRoutes.get(0).getRoute(), new SSLHandshakeException("none"));
+    routeDatabase.failed(regularRoutes.get(0).getRoute());
     // Reset selector
     routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns, routeDatabase);
 
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
new file mode 100644
index 0000000000..c3ea3a982d
--- /dev/null
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import org.junit.Test;
+
+import static junit.framework.Assert.fail;
+import static org.junit.Assert.assertEquals;
+
+public final class StatusLineTest {
+  @Test public void parse() throws IOException {
+    String message = "Temporary Redirect";
+    int version = 1;
+    int code = 200;
+    StatusLine statusLine = new StatusLine("HTTP/1." + version + " " + code + " " + message);
+    assertEquals(message, statusLine.message());
+    assertEquals(version, statusLine.httpMinorVersion());
+    assertEquals(code, statusLine.code());
+  }
+
+  @Test public void emptyMessage() throws IOException {
+    int version = 1;
+    int code = 503;
+    StatusLine statusLine = new StatusLine("HTTP/1." + version + " " + code + " ");
+    assertEquals("", statusLine.message());
+    assertEquals(version, statusLine.httpMinorVersion());
+    assertEquals(code, statusLine.code());
+  }
+
+  /**
+   * This is not defined in the protocol but some servers won't add the leading
+   * empty space when the message is empty.
+   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
+   */
+  @Test public void emptyMessageAndNoLeadingSpace() throws IOException {
+    int version = 1;
+    int code = 503;
+    StatusLine statusLine = new StatusLine("HTTP/1." + version + " " + code);
+    assertEquals("", statusLine.message());
+    assertEquals(version, statusLine.httpMinorVersion());
+    assertEquals(code, statusLine.code());
+  }
+
+  // https://github.com/square/okhttp/issues/386
+  @Test public void shoutcast() throws IOException {
+    StatusLine statusLine = new StatusLine("ICY 200 OK");
+    assertEquals("OK", statusLine.message());
+    assertEquals(0, statusLine.httpMinorVersion());
+    assertEquals(200, statusLine.code());
+  }
+
+  @Test public void missingProtocol() throws IOException {
+    assertInvalid("");
+    assertInvalid(" ");
+    assertInvalid("200 OK");
+    assertInvalid(" 200 OK");
+  }
+
+  @Test public void protocolVersions() throws IOException {
+    assertInvalid("HTTP/2.0 200 OK");
+    assertInvalid("HTTP/2.1 200 OK");
+    assertInvalid("HTTP/-.1 200 OK");
+    assertInvalid("HTTP/1.- 200 OK");
+    assertInvalid("HTTP/0.1 200 OK");
+    assertInvalid("HTTP/101 200 OK");
+    assertInvalid("HTTP/1.1_200 OK");
+  }
+
+  @Test public void nonThreeDigitCode() throws IOException {
+    assertInvalid("HTTP/1.1  OK");
+    assertInvalid("HTTP/1.1 2 OK");
+    assertInvalid("HTTP/1.1 20 OK");
+    assertInvalid("HTTP/1.1 2000 OK");
+    assertInvalid("HTTP/1.1 two OK");
+    assertInvalid("HTTP/1.1 2");
+    assertInvalid("HTTP/1.1 2000");
+    assertInvalid("HTTP/1.1 two");
+  }
+
+  @Test public void truncated() throws IOException {
+    assertInvalid("");
+    assertInvalid("H");
+    assertInvalid("HTTP/1");
+    assertInvalid("HTTP/1.");
+    assertInvalid("HTTP/1.1");
+    assertInvalid("HTTP/1.1 ");
+    assertInvalid("HTTP/1.1 2");
+    assertInvalid("HTTP/1.1 20");
+  }
+
+  @Test public void wrongMessageDelimiter() throws IOException {
+    assertInvalid("HTTP/1.1 200_");
+  }
+
+  private void assertInvalid(String statusLine) throws IOException {
+    try {
+      new StatusLine(statusLine);
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 5af2812ccd..6ed031d543 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -16,16 +16,18 @@
 
 package com.squareup.okhttp.internal.http;
 
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.SocketPolicy;
 import com.squareup.okhttp.HttpResponseCache;
+import com.squareup.okhttp.OkAuthenticator.Credential;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.RecordingAuthenticator;
 import com.squareup.okhttp.internal.RecordingHostnameVerifier;
 import com.squareup.okhttp.internal.RecordingOkAuthenticator;
 import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.SocketPolicy;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
@@ -48,7 +50,6 @@
 import java.net.URL;
 import java.net.URLConnection;
 import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
@@ -61,7 +62,6 @@
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.zip.GZIPInputStream;
 import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.HttpsURLConnection;
@@ -76,11 +76,14 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
+import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
-import static com.squareup.okhttp.OkAuthenticator.Credential;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
@@ -89,24 +92,16 @@
 
 /** Android's URLConnectionTest. */
 public final class URLConnectionTest {
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+
   private MockWebServer server = new MockWebServer();
   private MockWebServer server2 = new MockWebServer();
 
   private final OkHttpClient client = new OkHttpClient();
+  private HttpURLConnection connection;
   private HttpResponseCache cache;
   private String hostName;
 
-  private static final SSLContext sslContext;
-  static {
-    try {
-      sslContext = new SslContextBuilder(InetAddress.getLocalHost().getHostName()).build();
-    } catch (GeneralSecurityException e) {
-      throw new RuntimeException(e);
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
   @Before public void setUp() throws Exception {
     hostName = server.getHostName();
     server.setNpnEnabled(false);
@@ -131,12 +126,12 @@
     server.enqueue(new MockResponse());
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.addRequestProperty("D", "e");
-    urlConnection.addRequestProperty("D", "f");
-    assertEquals("f", urlConnection.getRequestProperty("D"));
-    assertEquals("f", urlConnection.getRequestProperty("d"));
-    Map<String, List<String>> requestHeaders = urlConnection.getRequestProperties();
+    connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("D", "e");
+    connection.addRequestProperty("D", "f");
+    assertEquals("f", connection.getRequestProperty("D"));
+    assertEquals("f", connection.getRequestProperty("d"));
+    Map<String, List<String>> requestHeaders = connection.getRequestProperties();
     assertEquals(newSet("e", "f"), new HashSet<String>(requestHeaders.get("D")));
     assertEquals(newSet("e", "f"), new HashSet<String>(requestHeaders.get("d")));
     try {
@@ -150,21 +145,21 @@
     } catch (UnsupportedOperationException expected) {
     }
     try {
-      urlConnection.setRequestProperty(null, "j");
+      connection.setRequestProperty(null, "j");
       fail();
     } catch (NullPointerException expected) {
     }
     try {
-      urlConnection.addRequestProperty(null, "k");
+      connection.addRequestProperty(null, "k");
       fail();
     } catch (NullPointerException expected) {
     }
-    urlConnection.setRequestProperty("NullValue", null);
-    assertNull(urlConnection.getRequestProperty("NullValue"));
-    urlConnection.addRequestProperty("AnotherNullValue", null);
-    assertNull(urlConnection.getRequestProperty("AnotherNullValue"));
+    connection.setRequestProperty("NullValue", null);
+    assertNull(connection.getRequestProperty("NullValue"));
+    connection.addRequestProperty("AnotherNullValue", null);
+    assertNull(connection.getRequestProperty("AnotherNullValue"));
 
-    urlConnection.getResponseCode();
+    connection.getResponseCode();
     RecordedRequest request = server.takeRequest();
     assertContains(request.getHeaders(), "D: e");
     assertContains(request.getHeaders(), "D: f");
@@ -174,17 +169,17 @@
     assertContainsNoneMatching(request.getHeaders(), "null:.*");
 
     try {
-      urlConnection.addRequestProperty("N", "o");
+      connection.addRequestProperty("N", "o");
       fail("Set header after connect");
     } catch (IllegalStateException expected) {
     }
     try {
-      urlConnection.setRequestProperty("P", "q");
+      connection.setRequestProperty("P", "q");
       fail("Set header after connect");
     } catch (IllegalStateException expected) {
     }
     try {
-      urlConnection.getRequestProperties();
+      connection.getRequestProperties();
       fail();
     } catch (IllegalStateException expected) {
     }
@@ -192,10 +187,10 @@
 
   @Test public void getRequestPropertyReturnsLastValue() throws Exception {
     server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.addRequestProperty("A", "value1");
-    urlConnection.addRequestProperty("A", "value2");
-    assertEquals("value2", urlConnection.getRequestProperty("A"));
+    connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("A", "value1");
+    connection.addRequestProperty("A", "value2");
+    assertEquals("value2", connection.getRequestProperty("A"));
   }
 
   @Test public void responseHeaders() throws IOException, InterruptedException {
@@ -206,11 +201,11 @@
         .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-    assertEquals("HTTP/1.0 200 Fantastic", urlConnection.getHeaderField(null));
-    Map<String, List<String>> responseHeaders = urlConnection.getHeaderFields();
+    connection = client.open(server.getUrl("/"));
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Fantastic", connection.getResponseMessage());
+    assertEquals("HTTP/1.0 200 Fantastic", connection.getHeaderField(null));
+    Map<String, List<String>> responseHeaders = connection.getHeaderFields();
     assertEquals(Arrays.asList("HTTP/1.0 200 Fantastic"), responseHeaders.get(null));
     assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("A")));
     assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("a")));
@@ -224,21 +219,21 @@
       fail("Modified an unmodifiable view.");
     } catch (UnsupportedOperationException expected) {
     }
-    assertEquals("A", urlConnection.getHeaderFieldKey(0));
-    assertEquals("c", urlConnection.getHeaderField(0));
-    assertEquals("B", urlConnection.getHeaderFieldKey(1));
-    assertEquals("d", urlConnection.getHeaderField(1));
-    assertEquals("A", urlConnection.getHeaderFieldKey(2));
-    assertEquals("e", urlConnection.getHeaderField(2));
+    assertEquals("A", connection.getHeaderFieldKey(0));
+    assertEquals("c", connection.getHeaderField(0));
+    assertEquals("B", connection.getHeaderFieldKey(1));
+    assertEquals("d", connection.getHeaderField(1));
+    assertEquals("A", connection.getHeaderFieldKey(2));
+    assertEquals("e", connection.getHeaderField(2));
   }
 
   @Test public void serverSendsInvalidResponseHeaders() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.getResponseCode();
+      connection.getResponseCode();
       fail();
     } catch (IOException expected) {
     }
@@ -248,9 +243,9 @@
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.getResponseCode();
+      connection.getResponseCode();
       fail();
     } catch (IOException expected) {
     }
@@ -260,9 +255,9 @@
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.getResponseCode();
+      connection.getResponseCode();
       fail();
     } catch (IOException expected) {
     }
@@ -272,9 +267,9 @@
     server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.getResponseCode();
+      connection.getResponseCode();
       fail();
     } catch (IOException expected) {
     }
@@ -285,7 +280,7 @@
     URL url = server.getUrl("/foo");
     server.shutdown();
 
-    HttpURLConnection connection = client.open(url);
+    connection = client.open(url);
     try {
       connection.connect();
       fail();
@@ -316,7 +311,7 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     client.setProxySelector(proxySelector);
     server2.shutdown();
 
-    HttpURLConnection connection = client.open(server.getUrl("/def"));
+    connection = client.open(server.getUrl("/def"));
     connection.setDoOutput(true);
     transferKind.setForRequest(connection, 4);
     connection.getOutputStream().write("body".getBytes("UTF-8"));
@@ -328,14 +323,14 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
   @Test public void getErrorStreamOnSuccessfulRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertNull(connection.getErrorStream());
   }
 
   @Test public void getErrorStreamOnUnsuccessfulRequest() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(404).setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection.getErrorStream(), Integer.MAX_VALUE));
   }
 
@@ -515,7 +510,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
 
     assertContent("this response comes via HTTPS", connection);
 
@@ -535,7 +530,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
 
     client.setSslSocketFactory(clientSocketFactory);
     client.setHostnameVerifier(hostnameVerifier);
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertContent("this response comes via HTTPS", connection);
 
     connection = client.open(server.getUrl("/"));
@@ -575,7 +570,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
 
     assertContent("this response comes via SSL", connection);
 
@@ -593,7 +588,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.enqueue(new MockResponse()); // unused
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     try {
       connection.getInputStream();
       fail();
@@ -621,8 +616,9 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
     server.play();
 
     URL url = new URL("http://android.com/foo");
-    HttpURLConnection connection = proxyConfig.connect(server, client, url);
+    connection = proxyConfig.connect(server, client, url);
     assertContent("this response comes via a proxy", connection);
+    assertTrue(connection.usingProxy());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET http://android.com/foo HTTP/1.1", request.getRequestLine());
@@ -671,7 +667,7 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
     URL url = server.getUrl("/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = proxyConfig.connect(server, client, url);
+    connection = proxyConfig.connect(server, client, url);
 
     assertContent("this response comes via HTTPS", connection);
 
@@ -711,7 +707,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     URL url = new URL("https://android.com/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(hostnameVerifier);
-    HttpURLConnection connection = proxyConfig.connect(server, client, url);
+    connection = proxyConfig.connect(server, client, url);
 
     assertContent("this response comes via a secure proxy", connection);
 
@@ -747,7 +743,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
 
     URL url = new URL("https://android.com/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
-    HttpURLConnection connection = client.open(url);
+    connection = client.open(url);
 
     try {
       connection.getResponseCode();
@@ -786,7 +782,7 @@ private void initResponseCache() throws IOException {
     URL url = new URL("https://android.com/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(hostnameVerifier);
-    HttpURLConnection connection = client.open(url);
+    connection = client.open(url);
     connection.addRequestProperty("Private", "Secret");
     connection.addRequestProperty("Proxy-Authorization", "bar");
     connection.addRequestProperty("User-Agent", "baz");
@@ -818,7 +814,7 @@ private void initResponseCache() throws IOException {
     URL url = new URL("https://android.com/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(url);
+    connection = client.open(url);
     assertContent("A", connection);
 
     RecordedRequest connect1 = server.takeRequest();
@@ -848,7 +844,7 @@ private void initResponseCache() throws IOException {
     URL url = new URL("https://android.com/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(url);
+    connection = client.open(url);
     connection.setRequestProperty("Connection", "close");
 
     assertContent("this response comes via a proxy", connection);
@@ -877,7 +873,7 @@ private void initResponseCache() throws IOException {
     server.enqueue(new MockResponse().setBody("ABCDEFGHIJKLMNOPQR"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals('A', (char) in.read());
     connection.disconnect();
@@ -892,9 +888,8 @@ private void initResponseCache() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.disconnect();
-
     assertContent("A", connection);
     assertEquals(200, connection.getResponseCode());
   }
@@ -1125,40 +1120,62 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
 
     server.play();
 
-    URLConnection connection1 = client.open(server.getUrl("/"));
+    HttpURLConnection connection1 = client.open(server.getUrl("/"));
     InputStream in1 = connection1.getInputStream();
     assertEquals("ABCDE", readAscii(in1, 5));
-    in1.close();
+    connection1.disconnect();
 
     HttpURLConnection connection2 = client.open(server.getUrl("/"));
     InputStream in2 = connection2.getInputStream();
     assertEquals("LMNOP", readAscii(in2, 5));
-    in2.close();
+    connection2.disconnect();
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection is pooled!
   }
 
-  /**
-   * Obnoxiously test that the chunk sizes transmitted exactly equal the
-   * requested data+chunk header size. Although setChunkedStreamingMode()
-   * isn't specific about whether the size applies to the data or the
-   * complete chunk, the RI interprets it as a complete chunk.
-   */
+  @Test public void streamDiscardingIsTimely() throws Exception {
+    // This response takes at least a full second to serve: 10,000 bytes served 100 bytes at a time.
+    server.enqueue(new MockResponse()
+        .setBody(new byte[10000])
+        .throttleBody(100, 10, MILLISECONDS));
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+
+    long startNanos = System.nanoTime();
+    URLConnection connection1 = client.open(server.getUrl("/"));
+    InputStream in = connection1.getInputStream();
+    in.close();
+    long elapsedNanos = System.nanoTime() - startNanos;
+    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
+
+    // If we're working correctly, this should be greater than 100ms, but less than double that.
+    // Previously we had a bug where we would download the entire response body as long as no
+    // individual read took longer than 100ms.
+    assertTrue(String.format("Time to close: %sms", elapsedMillis), elapsedMillis < 500);
+
+    // Do another request to confirm that the discarded connection was not pooled.
+    assertContent("A", client.open(server.getUrl("/")));
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
+  }
+
   @Test public void setChunkedStreamingMode() throws IOException, InterruptedException {
     server.enqueue(new MockResponse());
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.setChunkedStreamingMode(8);
-    urlConnection.setDoOutput(true);
-    OutputStream outputStream = urlConnection.getOutputStream();
-    outputStream.write("ABCDEFGHIJKLMNOPQ".getBytes("US-ASCII"));
-    assertEquals(200, urlConnection.getResponseCode());
+    String body = "ABCDEFGHIJKLMNOPQ";
+    connection = client.open(server.getUrl("/"));
+    connection.setChunkedStreamingMode(0); // OkHttp does not honor specific chunk sizes.
+    connection.setDoOutput(true);
+    OutputStream outputStream = connection.getOutputStream();
+    outputStream.write(body.getBytes("US-ASCII"));
+    assertEquals(200, connection.getResponseCode());
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("ABCDEFGHIJKLMNOPQ", new String(request.getBody(), "US-ASCII"));
-    assertEquals(Arrays.asList(3, 3, 3, 3, 3, 2), request.getChunkSizes());
+    assertEquals(body, new String(request.getBody(), "US-ASCII"));
+    assertEquals(Arrays.asList(body.length()), request.getChunkSizes());
   }
 
   @Test public void authenticateWithFixedLengthStreaming() throws Exception {
@@ -1177,7 +1194,7 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     if (streamingMode == StreamingMode.FIXED_LENGTH) {
@@ -1261,7 +1278,6 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     server.enqueue(pleaseAuthenticate);
     server.play();
 
-    HttpURLConnection connection;
     if (proxy) {
       client.setProxy(server.toProxyAddress());
       connection = client.open(new URL("http://android.com"));
@@ -1284,7 +1300,7 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
   }
 
   private void assertValidRequestMethod(String requestMethod) throws Exception {
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setRequestMethod(requestMethod);
     assertEquals(requestMethod, connection.getRequestMethod());
   }
@@ -1300,7 +1316,7 @@ private void assertValidRequestMethod(String requestMethod) throws Exception {
   }
 
   private void assertInvalidRequestMethod(String requestMethod) throws Exception {
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.setRequestMethod(requestMethod);
       fail();
@@ -1308,9 +1324,35 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
     }
   }
 
+  @Test public void shoutcast() throws Exception {
+    server.enqueue(new MockResponse().setStatus("ICY 200 OK")
+        // .addHeader("HTTP/1.0 200 OK")
+        .addHeader("Accept-Ranges: none")
+        .addHeader("Content-Type: audio/mpeg")
+        .addHeader("icy-br:128")
+        .addHeader("ice-audio-info: bitrate=128;samplerate=44100;channels=2")
+        .addHeader("icy-br:128")
+        .addHeader("icy-description:Rock")
+        .addHeader("icy-genre:riders")
+        .addHeader("icy-name:A2RRock")
+        .addHeader("icy-pub:1")
+        .addHeader("icy-url:http://www.A2Rradio.com")
+        .addHeader("Server: Icecast 2.3.3-kh8")
+        .addHeader("Cache-Control: no-cache")
+        .addHeader("Pragma: no-cache")
+        .addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT")
+        .addHeader("icy-metaint:16000")
+        .setBody("mp3 data"));
+    server.play();
+    connection = client.open(server.getUrl("/"));
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("OK", connection.getResponseMessage());
+    assertContent("mp3 data", connection);
+  }
+
   @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.setFixedLengthStreamingMode(-2);
       fail();
@@ -1320,14 +1362,14 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
 
   @Test public void canSetNegativeChunkedStreamingMode() throws Exception {
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setChunkedStreamingMode(-2);
   }
 
   @Test public void cannotSetFixedLengthStreamingModeAfterConnect() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     try {
       connection.setFixedLengthStreamingMode(1);
@@ -1339,7 +1381,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
   @Test public void cannotSetChunkedStreamingModeAfterConnect() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     try {
       connection.setChunkedStreamingMode(1);
@@ -1350,7 +1392,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
 
   @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() throws Exception {
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setChunkedStreamingMode(1);
     try {
       connection.setFixedLengthStreamingMode(1);
@@ -1361,7 +1403,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
 
   @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() throws Exception {
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setFixedLengthStreamingMode(1);
     try {
       connection.setChunkedStreamingMode(1);
@@ -1389,7 +1431,7 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     if (streamingMode == StreamingMode.FIXED_LENGTH) {
@@ -1429,7 +1471,7 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     OutputStream outputStream = connection.getOutputStream();
@@ -1464,7 +1506,7 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
     // no authorization header for the first request...
@@ -1480,6 +1522,19 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     }
   }
 
+  /** https://github.com/square/okhttp/issues/342 */
+  @Test public void authenticateRealmUppercase() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(401)
+        .addHeader("wWw-aUtHeNtIcAtE: bAsIc rEaLm=\"pRoTeCtEd aReA\"")
+        .setBody("Please authenticate."));
+    server.enqueue(new MockResponse().setBody("Successful auth!"));
+    server.play();
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    connection = client.open(server.getUrl("/"));
+    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+  }
+
   @Test public void redirectedWithChunkedEncoding() throws Exception {
     testRedirected(TransferKind.CHUNKED, true);
   }
@@ -1523,7 +1578,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("This is the new location!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1544,7 +1599,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     client.setFollowProtocolRedirects(false);
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1555,7 +1610,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     server.play();
 
     client.setFollowProtocolRedirects(false);
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1596,7 +1651,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
     client.setFollowProtocolRedirects(true);
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertContent("This is secure HTTPS!", connection);
     assertFalse(connection instanceof HttpsURLConnection);
   }
@@ -1629,7 +1684,7 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
     server.enqueue(new MockResponse().setBody("This is the first server again!"));
     server.play();
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertContent("This is the 2nd server!", connection);
     assertEquals(server2.getUrl("/"), connection.getURL());
 
@@ -1699,7 +1754,7 @@ private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
     server.enqueue(new MockResponse().setBody("Page 2"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/page1"));
+    connection = client.open(server.getUrl("/page1"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     OutputStream outputStream = connection.getOutputStream();
@@ -1723,7 +1778,7 @@ private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
     server.enqueue(new MockResponse().setBody("Page 2"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/page1"));
+    connection = client.open(server.getUrl("/page1"));
     connection.setDoOutput(true);
     connection.addRequestProperty("Content-Length", "4");
     connection.addRequestProperty("Content-Type", "text/plain; charset=utf-8");
@@ -1749,7 +1804,7 @@ private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("Proxy Response"));
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     // Fails on the RI, which gets "Proxy Response"
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1776,7 +1831,7 @@ private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
 
   private void test307Redirect(String method) throws Exception {
     MockResponse response1 = new MockResponse()
-        .setResponseCode(HttpURLConnectionImpl.HTTP_TEMP_REDIRECT)
+        .setResponseCode(HTTP_TEMP_REDIRECT)
         .addHeader("Location: /page2");
     if (!method.equals("HEAD")) {
       response1.setBody("This page has moved!");
@@ -1785,7 +1840,7 @@ private void test307Redirect(String method) throws Exception {
     server.enqueue(new MockResponse().setBody("Page 2"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/page1"));
+    connection = client.open(server.getUrl("/page1"));
     connection.setRequestMethod(method);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     if (method.equals("POST")) {
@@ -1831,7 +1886,7 @@ private void test307Redirect(String method) throws Exception {
     server.enqueue(new MockResponse().setBody("Success!"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/0"));
+    connection = client.open(server.getUrl("/0"));
     assertContent("Success!", connection);
     assertEquals(server.getUrl("/20"), connection.getURL());
   }
@@ -1844,7 +1899,7 @@ private void test307Redirect(String method) throws Exception {
     }
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/0"));
+    connection = client.open(server.getUrl("/0"));
     try {
       connection.getInputStream();
       fail();
@@ -1889,9 +1944,9 @@ private void test307Redirect(String method) throws Exception {
     server.enqueue(new MockResponse().setBody("unused")); // to keep the server alive
     server.play();
 
-    URLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.setReadTimeout(1000);
-    InputStream in = urlConnection.getInputStream();
+    URLConnection connection = client.open(server.getUrl("/"));
+    connection.setReadTimeout(1000);
+    InputStream in = connection.getInputStream();
     assertEquals('A', in.read());
     assertEquals('B', in.read());
     assertEquals('C', in.read());
@@ -1906,11 +1961,11 @@ private void test307Redirect(String method) throws Exception {
     server.enqueue(new MockResponse());
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.setRequestProperty("Transfer-encoding", "chunked");
-    urlConnection.setDoOutput(true);
-    urlConnection.getOutputStream().write("ABC".getBytes("UTF-8"));
-    assertEquals(200, urlConnection.getResponseCode());
+    connection = client.open(server.getUrl("/"));
+    connection.setRequestProperty("Transfer-encoding", "chunked");
+    connection.setDoOutput(true);
+    connection.getOutputStream().write("ABC".getBytes("UTF-8"));
+    assertEquals(200, connection.getResponseCode());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("ABC", new String(request.getBody(), "UTF-8"));
@@ -1997,7 +2052,7 @@ private void test307Redirect(String method) throws Exception {
     server.enqueue(new MockResponse().setBody(new byte[] { -2, -1 }));
     server.play();
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals(254, in.read());
     assertEquals(255, in.read());
@@ -2025,7 +2080,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     server.enqueue(new MockResponse().setBody("abc"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] upload = "def".getBytes("UTF-8");
 
@@ -2056,7 +2111,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     }
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.getInputStream();
       fail();
@@ -2071,7 +2126,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void dnsFailureThrowsIOException() throws IOException {
-    HttpURLConnection connection = client.open(new URL("http://host.unlikelytld"));
+    connection = client.open(new URL("http://host.unlikelytld"));
     try {
       connection.connect();
       fail();
@@ -2080,7 +2135,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
-    HttpURLConnection connection = client.open(new URL("http:///foo.html"));
+    connection = client.open(new URL("http:///foo.html"));
     try {
       connection.connect();
       fail();
@@ -2094,11 +2149,10 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     server.play();
 
     // The request should work once and then fail
-    URLConnection connection1 = client.open(server.getUrl(""));
+    HttpURLConnection connection1 = client.open(server.getUrl(""));
     connection1.setReadTimeout(100);
     InputStream input = connection1.getInputStream();
     assertEquals("ABC", readAscii(input, Integer.MAX_VALUE));
-    input.close();
     server.shutdown();
     try {
       HttpURLConnection connection2 = client.open(server.getUrl(""));
@@ -2110,35 +2164,22 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   /** Don't explode if the cache returns a null body. http://b/3373699 */
-  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
-    final AtomicBoolean aborted = new AtomicBoolean();
-    client.setResponseCache(new ResponseCache() {
+  @Test public void installDeprecatedJavaNetResponseCache() throws Exception {
+    ResponseCache cache = new ResponseCache() {
       @Override public CacheResponse get(URI uri, String requestMethod,
           Map<String, List<String>> requestHeaders) throws IOException {
         return null;
       }
-
       @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        return new CacheRequest() {
-          @Override public void abort() {
-            aborted.set(true);
-          }
-
-          @Override public OutputStream getBody() throws IOException {
-            return null;
-          }
-        };
+        return null;
       }
-    });
-
-    server.enqueue(new MockResponse().setBody("abcdef"));
-    server.play();
+    };
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
-    InputStream in = connection.getInputStream();
-    assertEquals("abc", readAscii(in, 3));
-    in.close();
-    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
+    try {
+      client.setResponseCache(cache);
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
   }
 
   /** http://code.google.com/p/android/issues/detail?id=14562 */
@@ -2149,7 +2190,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
         .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals("ABC", readAscii(in, 3));
     assertEquals(-1, in.read());
@@ -2159,7 +2200,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   @Test public void getContent() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = (InputStream) connection.getContent();
     assertEquals("A", readAscii(in, Integer.MAX_VALUE));
   }
@@ -2167,7 +2208,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   @Test public void getContentOfType() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.getContent(null);
       fail();
@@ -2179,13 +2220,12 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     } catch (NullPointerException expected) {
     }
     assertNull(connection.getContent(new Class[] { getClass() }));
-    connection.disconnect();
   }
 
   @Test public void getOutputStreamOnGetFails() throws Exception {
     server.enqueue(new MockResponse());
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.getOutputStream();
       fail();
@@ -2196,7 +2236,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   @Test public void getOutputAfterGetInputStreamFails() throws Exception {
     server.enqueue(new MockResponse());
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     try {
       connection.getInputStream();
@@ -2209,7 +2249,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   @Test public void setDoOutputOrDoInputAfterConnectFails() throws Exception {
     server.enqueue(new MockResponse());
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.connect();
     try {
       connection.setDoOutput(true);
@@ -2221,13 +2261,12 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
       fail();
     } catch (IllegalStateException expected) {
     }
-    connection.disconnect();
   }
 
   @Test public void clientSendsContentLength() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     OutputStream out = connection.getOutputStream();
     out.write(new byte[] { 'A', 'B', 'C' });
@@ -2240,25 +2279,22 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   @Test public void getContentLengthConnects() throws Exception {
     server.enqueue(new MockResponse().setBody("ABC"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals(3, connection.getContentLength());
-    connection.disconnect();
   }
 
   @Test public void getContentTypeConnects() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("ABC"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("text/plain", connection.getContentType());
-    connection.disconnect();
   }
 
   @Test public void getContentEncodingConnects() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Encoding: identity").setBody("ABC"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("identity", connection.getContentEncoding());
-    connection.disconnect();
   }
 
   // http://b/4361656
@@ -2290,7 +2326,7 @@ private void testInputStreamAvailable(TransferKind transferKind) throws IOExcept
     transferKind.setBody(response, body, 4);
     server.enqueue(response);
     server.play();
-    URLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     for (int i = 0; i < body.length(); i++) {
       assertTrue(in.available() >= 0);
@@ -2337,7 +2373,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     byte[] requestBody = new byte[requestSize];
     new Random(0).nextBytes(requestBody);
 
-    HttpURLConnection connection = client.open(server.getUrl("/b"));
+    connection = client.open(server.getUrl("/b"));
     connection.setRequestMethod("POST");
     transferKind.setForRequest(connection, requestBody.length);
     for (int i = 0; i < requestBody.length; i += 1024) {
@@ -2357,7 +2393,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/b"));
+    connection = client.open(server.getUrl("/b"));
     connection.setRequestProperty("Content-Length", "4");
     connection.setRequestMethod("POST");
     OutputStream out = connection.getOutputStream();
@@ -2375,7 +2411,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/b"));
+    connection = client.open(server.getUrl("/b"));
     connection.setRequestProperty("Content-Length", "3");
     connection.setRequestMethod("POST");
     OutputStream out = connection.getOutputStream();
@@ -2416,26 +2452,26 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
   @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
     server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.addRequestProperty("B", "");
-    assertContent("body", urlConnection);
-    assertEquals("", urlConnection.getRequestProperty("B"));
+    connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("B", "");
+    assertContent("body", connection);
+    assertEquals("", connection.getRequestProperty("B"));
   }
 
   @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().addHeader("A:").setBody("body"));
     server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    assertContent("body", urlConnection);
-    assertEquals("", urlConnection.getHeaderField("A"));
+    connection = client.open(server.getUrl("/"));
+    assertContent("body", connection);
+    assertEquals("", connection.getHeaderField("A"));
   }
 
   @Test public void emptyRequestHeaderNameIsStrict() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
     server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.setRequestProperty("", "A");
+      connection.setRequestProperty("", "A");
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -2444,9 +2480,9 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
   @Test public void emptyResponseHeaderNameIsLenient() throws Exception {
     server.enqueue(new MockResponse().addHeader(":A").setBody("body"));
     server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.getResponseCode();
-    assertEquals("A", urlConnection.getHeaderField(""));
+    connection = client.open(server.getUrl("/"));
+    connection.getResponseCode();
+    assertEquals("A", connection.getHeaderField(""));
   }
 
   @Test @Ignore public void deflateCompression() {
@@ -2485,24 +2521,89 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertTrue(call, call.contains("challenges=[Basic realm=\"protected area\"]"));
   }
 
-  @Test public void setTransports() throws Exception {
+  @Test public void npnSetsProtocolHeader_SPDY_3() throws Exception {
+    npnSetsProtocolHeader(Protocol.SPDY_3);
+  }
+
+  @Test public void npnSetsProtocolHeader_HTTP_2() throws Exception {
+    npnSetsProtocolHeader(Protocol.HTTP_2);
+  }
+
+  private void npnSetsProtocolHeader(Protocol protocol) throws IOException {
+    enableNpn(protocol);
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+    client.setProtocols(Arrays.asList(Protocol.HTTP_11, protocol));
+    connection = client.open(server.getUrl("/"));
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    assertEquals(Arrays.asList(protocol.name.utf8()), protocolValues);
+    assertContent("A", connection);
+  }
+
+  /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
+  @Test public void zeroLengthPost() throws IOException, InterruptedException {
+    zeroLengthPayload("POST");
+  }
+
+  @Test public void zeroLengthPost_SPDY_3() throws Exception {
+    enableNpn(Protocol.SPDY_3);
+    zeroLengthPost();
+  }
+
+  @Test public void zeroLengthPost_HTTP_2() throws Exception {
+    enableNpn(Protocol.HTTP_2);
+    zeroLengthPost();
+  }
+
+  /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
+  @Test public void zeroLengthPut() throws IOException, InterruptedException {
+    zeroLengthPayload("PUT");
+  }
+
+  @Test public void zeroLengthPut_SPDY_3() throws Exception {
+    enableNpn(Protocol.SPDY_3);
+    zeroLengthPut();
+  }
+
+  @Test public void zeroLengthPut_HTTP_2() throws Exception {
+    enableNpn(Protocol.HTTP_2);
+    zeroLengthPut();
+  }
+
+  private void zeroLengthPayload(String method)
+      throws IOException, InterruptedException {
+    server.enqueue(new MockResponse());
+    server.play();
+    connection = client.open(server.getUrl("/"));
+    connection.setRequestProperty("Content-Length", "0");
+    connection.setRequestMethod(method);
+    connection.setFixedLengthStreamingMode(0);
+    connection.setDoOutput(true);
+    assertContent("", connection);
+    RecordedRequest zeroLengthPayload = server.takeRequest();
+    assertEquals(method, zeroLengthPayload.getMethod());
+    assertEquals("0", zeroLengthPayload.getHeader("content-length"));
+    assertEquals(0L, zeroLengthPayload.getBodySize());
+  }
+
+  @Test public void setProtocols() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    client.setTransports(Arrays.asList("http/1.1"));
+    client.setProtocols(Arrays.asList(Protocol.HTTP_11));
     assertContent("A", client.open(server.getUrl("/")));
   }
 
-  @Test public void setTransportsWithoutHttp11() throws Exception {
+  @Test public void setProtocolsWithoutHttp11() throws Exception {
     try {
-      client.setTransports(Arrays.asList("spdy/3"));
+      client.setProtocols(Arrays.asList(Protocol.SPDY_3));
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
-  @Test public void setTransportsWithNull() throws Exception {
+  @Test public void setProtocolsWithNull() throws Exception {
     try {
-      client.setTransports(Arrays.asList("http/1.1", null));
+      client.setProtocols(Arrays.asList(Protocol.HTTP_11, null));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -2513,7 +2614,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse());
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     long contentLength = Integer.MAX_VALUE + 1L;
     connection.setFixedLengthStreamingMode(contentLength);
@@ -2530,6 +2631,36 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertEquals(Long.toString(contentLength), request.getHeader("Content-Length"));
   }
 
+  /**
+   * We had a bug where we attempted to gunzip responses that didn't have a
+   * body. This only came up with 304s since that response code can include
+   * headers (like "Content-Encoding") without any content to go along with it.
+   * https://github.com/square/okhttp/issues/358
+   */
+  @Test public void noTransparentGzipFor304NotModified() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    server.play();
+
+    HttpURLConnection connection1 = client.open(server.getUrl("/"));
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection1.getResponseCode());
+    assertContent("", connection1);
+
+    HttpURLConnection connection2 = client.open(server.getUrl("/"));
+    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+    assertContent("b", connection2);
+
+    RecordedRequest requestA = server.takeRequest();
+    assertEquals(0, requestA.getSequenceNumber());
+
+    RecordedRequest requestB = server.takeRequest();
+    assertEquals(1, requestB.getSequenceNumber());
+  }
+
   /** Returns a gzipped copy of {@code bytes}. */
   public byte[] gzip(byte[] bytes) throws IOException {
     ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
@@ -2543,14 +2674,13 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
    * Reads at most {@code limit} characters from {@code in} and asserts that
    * content equals {@code expected}.
    */
-  private void assertContent(String expected, URLConnection connection, int limit)
+  private void assertContent(String expected, HttpURLConnection connection, int limit)
       throws IOException {
     connection.connect();
     assertEquals(expected, readAscii(connection.getInputStream(), limit));
-    ((HttpURLConnection) connection).disconnect();
   }
 
-  private void assertContent(String expected, URLConnection connection) throws IOException {
+  private void assertContent(String expected, HttpURLConnection connection) throws IOException {
     assertContent(expected, connection, Integer.MAX_VALUE);
   }
 
@@ -2698,4 +2828,17 @@ private String certificatesToString(X509Certificate[] certificates) {
     @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
     }
   }
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/npn-boot-8.1.2.v20120308.jar}
+   */
+  private void enableNpn(Protocol protocol) {
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_11));
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.setNpnEnabled(true);
+    server.setNpnProtocols(client.getProtocols());
+  }
 }
diff --git a/pom.xml b/pom.xml
index a24a0efedc..aea71da07a 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp</groupId>
   <artifactId>parent</artifactId>
-  <version>1.2.2-SNAPSHOT</version>
+  <version>2.0.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
@@ -24,6 +24,7 @@
     <module>okhttp-protocols</module>
     <module>mockwebserver</module>
     <module>samples</module>
+    <module>benchmarks</module>
   </modules>
 
   <properties>
@@ -37,7 +38,7 @@
     <apache.http.version>4.2.2</apache.http.version>
 
     <!-- Test Dependencies -->
-    <junit.version>4.10</junit.version>
+    <junit.version>4.11</junit.version>
   </properties>
 
   <scm>
@@ -105,10 +106,17 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-surefire-plugin</artifactId>
-          <version>2.9</version>
+          <version>2.16</version>
           <configuration>
             <argLine>-Xbootclasspath/p:${settings.localRepository}/org/mortbay/jetty/npn/npn-boot/${npn.version}/npn-boot-${npn.version}.jar</argLine>
           </configuration>
+          <dependencies>
+            <dependency>
+              <groupId>org.apache.maven.surefire</groupId>
+              <artifactId>surefire-junit47</artifactId>
+              <version>2.16</version>
+            </dependency>
+          </dependencies>
         </plugin>
 
         <plugin>
@@ -162,8 +170,8 @@
         <configuration>
           <signature>
             <groupId>org.codehaus.mojo.signature</groupId>
-            <artifactId>java15</artifactId>
-            <version>1.0</version>
+            <artifactId>java16</artifactId>
+            <version>1.1</version>
           </signature>
         </configuration>
       </plugin>
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index dc0633c751..61e58756a1 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
diff --git a/samples/pom.xml b/samples/pom.xml
index 2462fd09d7..b212e99d99 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp.sample</groupId>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index 990152b227..93657e2f2f 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
index 8969f47236..c6424e2dec 100644
--- a/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
+++ b/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
@@ -18,7 +18,7 @@
       new TypeToken<List<Contributor>>() {
       };
 
-  class Contributor {
+  static class Contributor {
     String login;
     int contributions;
   }
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index f98e5b5b78..70188c725c 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>1.2.2-SNAPSHOT</version>
+    <version>2.0.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
diff --git a/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java b/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
index 274bf9dd48..cb0e24e37a 100644
--- a/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
+++ b/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
@@ -9,6 +9,7 @@
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.io.InputStream;
 import java.security.GeneralSecurityException;
 import java.security.KeyStore;
 import java.security.SecureRandom;
@@ -116,8 +117,12 @@ public static void main(String[] args) throws Exception {
   private static SSLContext sslContext(String keystoreFile, String password)
       throws GeneralSecurityException, IOException {
     KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
-    keystore.load(new FileInputStream(keystoreFile), password.toCharArray());
-
+    InputStream in = new FileInputStream(keystoreFile);
+    try {
+      keystore.load(in, password.toCharArray());
+    } finally {
+      Util.closeQuietly(in);
+    }
     KeyManagerFactory keyManagerFactory =
         KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
     keyManagerFactory.init(keystore, password.toCharArray());
