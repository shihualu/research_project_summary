diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
index d9a8e909da..7dfe3f41bf 100755
--- a/.buildscript/deploy_snapshot.sh
+++ b/.buildscript/deploy_snapshot.sh
@@ -21,6 +21,6 @@ elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
   echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
 else
   echo "Deploying snapshot..."
-  mvn clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -DskipTests
+  ./gradlew clean uploadArchives
   echo "Snapshot deployed!"
 fi
diff --git a/.buildscript/settings.xml b/.buildscript/settings.xml
deleted file mode 100644
index 91f444b228..0000000000
--- a/.buildscript/settings.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<settings>
-  <servers>
-    <server>
-      <id>sonatype-nexus-snapshots</id>
-      <username>${env.CI_DEPLOY_USERNAME}</username>
-      <password>${env.CI_DEPLOY_PASSWORD}</password>
-    </server>
-  </servers>
-</settings>
diff --git a/.circleci/config.yml b/.circleci/config.yml
new file mode 100644
index 0000000000..d994242b28
--- /dev/null
+++ b/.circleci/config.yml
@@ -0,0 +1,219 @@
+version: 2.1
+
+commands:
+  runtests:
+    description: "Run tests"
+    parameters:
+      platform:
+        type: string
+    steps:
+      - restore_cache:
+          keys:
+            # restore compilation and wrapper from previous branch/job build or master
+            - v4-{{ .Branch }}-{{ .Environment.CIRCLE_JOB }}
+            - v4-master-compile
+
+      - run:
+          name: Run tests
+          command: ./gradlew --build-cache --parallel --continue test
+          environment:
+            GRADLE_OPTS: -Dorg.gradle.daemon=false -Dokhttp.platform=<< parameters.platform >> -Dorg.gradle.workers.max=3 -Xmx1G
+
+      - save_cache:
+          paths:
+            - ~/.gradle/caches
+            - ~/.gradle/wrapper
+          key: v4-{{ .Branch }}-{{ .Environment.CIRCLE_JOB }}
+          when: always
+
+      - run:
+          name: Save test results
+          command: |
+            mkdir -p ~/test-results/junit/
+            find . -type f -regex ".*/build/test-results/.*xml" -exec cp {} ~/test-results/junit/ \;
+          when: always
+
+      - store_test_results:
+          name: Store test results
+          path: ~/test-results
+
+      - run:
+          name: Save gradle reports
+          command: |
+            mkdir -p ~/reports/
+            tar cf - */build/reports | (cd ~/reports/; tar xf -)
+          when: always
+
+      - store_artifacts:
+          name: Store gradle reports
+          path: ~/reports
+
+jobs:
+  compile:
+    docker:
+      - image: circleci/openjdk:8u171-jdk
+
+    environment:
+      JVM_OPTS: -Xmx1g
+      TERM: dumb
+
+    steps:
+      - checkout
+
+      - run:
+          name: Compile
+          command: ./gradlew --parallel --build-cache downloadDependencies testClasses
+          environment:
+            GRADLE_OPTS: -Dorg.gradle.daemon=false -Dorg.gradle.workers.max=3 -Xmx768m
+
+      - run:
+          name: Run tests
+          command: ./gradlew --parallel --build-cache test
+          environment:
+            GRADLE_OPTS: -Dorg.gradle.daemon=false -Dorg.gradle.workers.max=3 -Xmx1G
+
+      - save_cache:
+          paths:
+            - ~/.gradle/caches
+            - ~/.gradle/wrapper
+          # Under normal usage, saves compiled results from master at least once a day
+          key: v4-{{ .Branch }}-{{ .Environment.CIRCLE_JOB }}-{{ epoch }}
+
+  checkjdk8:
+    docker:
+      - image: circleci/openjdk:8u171-jdk
+
+    environment:
+      JVM_OPTS: -Xmx1g
+      TERM: dumb
+
+    steps:
+      - checkout
+
+      - restore_cache:
+          keys:
+            # restore compilation and wrapper from master build
+            - v4-master-compile
+
+      - run:
+          name: Run checks
+          command: ./gradlew --parallel --continue --build-cache check -x test
+          environment:
+            GRADLE_OPTS: -Dorg.gradle.daemon=false -Dorg.gradle.workers.max=3 -Xmx1G
+
+      - run:
+          name: Save gradle reports
+          command: |
+            mkdir -p ~/reports/
+            tar cf - */build/reports | (cd ~/reports/; tar xf -)
+          when: always
+
+      - store_artifacts:
+          name: Store gradle reports
+          path: ~/reports
+
+  testjdk8:
+    docker:
+      - image: circleci/openjdk:8u171-jdk
+
+    environment:
+      JVM_OPTS: -Xmx1g
+      TERM: dumb
+
+    steps:
+      - checkout
+
+      - runtests:
+          platform: jdk8
+
+  testjdk8alpn:
+    docker:
+      - image: circleci/openjdk:8u171-jdk
+
+    environment:
+      JVM_OPTS: -Xmx1g
+      TERM: dumb
+
+    steps:
+      - checkout
+
+      - runtests:
+          platform: jdk8alpn
+
+  testjdk11:
+    docker:
+      - image: circleci/openjdk:11.0.3-jdk-stretch
+
+    environment:
+      JVM_OPTS: -Xmx1g
+      TERM: dumb
+
+    steps:
+      - checkout
+
+      - runtests:
+          platform: jdk9
+
+  testconscrypt:
+    docker:
+      - image: circleci/openjdk:11.0.3-jdk-stretch
+
+    environment:
+      JVM_OPTS: -Xmx1g
+      TERM: dumb
+
+    steps:
+      - checkout
+
+      - runtests:
+          platform: conscrypt
+
+workflows:
+  version: 2
+  commit:
+    jobs:
+      - compile:
+          filters:
+            branches:
+              only: master
+      - checkjdk8:
+          filters:
+            branches:
+              ignore: master
+      - testjdk8:
+          filters:
+            branches:
+              only: master
+      - testjdk8alpn
+      - testjdk11:
+          filters:
+            branches:
+              only: master
+      - testconscrypt:
+          filters:
+            branches:
+              only: master
+  nightly:
+    triggers:
+      - schedule:
+          cron: "4 1 * * *"
+          filters:
+            branches:
+              only: master
+    jobs:
+      - compile
+      - checkjdk8:
+          requires:
+            - compile
+      - testjdk8:
+          requires:
+            - compile
+      - testjdk8alpn:
+          requires:
+            - compile
+      - testjdk11:
+          requires:
+            - compile
+      - testconscrypt:
+          requires:
+            - compile
diff --git a/.github/CONTRIBUTING.md b/.github/CONTRIBUTING.md
index 7543438302..01431c6e87 100644
--- a/.github/CONTRIBUTING.md
+++ b/.github/CONTRIBUTING.md
@@ -6,7 +6,7 @@ forking the repository and sending a pull request.
 
 When submitting code, please make every effort to follow existing conventions
 and style in order to keep the code as readable as possible. Please also make
-sure your code compiles by running `mvn clean verify`. Checkstyle failures
+sure your code compiles by running `./gradlew check`. Checkstyle failures
 during compilation indicate errors in your style and can be viewed in the
 `checkstyle-result.xml` file.
 
diff --git a/.gitignore b/.gitignore
index 226a3f3d65..d2b9133572 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,6 +1,7 @@
 .classpath
 .project
 .settings
+.gradle
 eclipsebin
 
 bin
@@ -8,10 +9,12 @@ gen
 build
 out
 lib
+generated
 
 target
 pom.xml.*
 release.properties
+local.properties
 
 .idea
 *.iml
diff --git a/.travis.yml b/.travis.yml
index 1ebb5eb306..d74b3927c2 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -2,22 +2,19 @@ language: java
 
 jdk:
   - oraclejdk8
-#  - openjdk11
+  - openjdk8
+  - openjdk11
 
-addons:
-  apt:
-    packages:
-      - oracle-java8-installer # Updates JDK 8 to the latest available.
-
-script: mvn test javadoc:jar source:jar -B
+script:
+ - ./gradlew check
 
 after_success:
   - .buildscript/deploy_snapshot.sh
 
 env:
   global:
-    - secure: "S0BTJVrF4fUCwhTdmoQY6LYr5r1wgXZ/p8lc5bIgUUsc1Ckalwt7s/GDwPuLJ4702sI5t56Eye2iEIMUjeFJKqebZRsX1C5oYsYFxGi3BGlepstYpmj0gLXuSWqCLniS9zmHXCxLhLkC6KxPVjhDlbq76XQx0o3K1J8oEIj/PCE="
-    - secure: "awV7yLXURjlPbTOladsNDZk74KYCNXoiZpAP0gQFfK4Sc0fc7+kg8z/yhdWXeTxjsIZ6m0dVDHTqnH8ytnydwXpBam8JdQJ+EAWA6R3Svq1BR1bzl/PcZUoz+Xn8lMXdU3yA1p4qtQlUhMxwsE3MOVe24HSDJPAu4XeWFj1j3qo="
+    - secure: "fELrorBJHDz+Xk9iSVMnamu0qC0+pYnFvjnEIcGnmKMMxLI/CIMACghIfSkqZhKAcU3hvxgWzyY8JBMnf5tykUjjOwmubAjZ9qIvwujtrUoUitUkpvVaPtqF0d1Yx0Xq4qt3NB9cOugPR/cPGnoEvSKfND3g+o5ta7KzdjwMBCY="
+    - secure: "WMkcWrsvzJNf48w7DJwipUNbhAoggCkC+NM31esq9/GDceGtVWj4hssQETynG4+ckxr0wGqUxsTRTz0uGhX6Fi58haG8yKp+g/HVClqI5EYjI44ptPcwlqlbYjuGbk65k1OGGZLctA6fQA3uT0zee05/yBjJx/jOqrN+PD1tW38="
 
 branches:
   except:
@@ -28,6 +25,11 @@ notifications:
 
 sudo: false
 
+before_cache:
+  - rm -f  $HOME/.gradle/caches/modules-2/modules-2.lock
+  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/
+
 cache:
   directories:
-    - $HOME/.m2
+    - $HOME/.gradle/caches/
+    - $HOME/.gradle/wrapper/
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 1a1dc66ae1..7c59ffefae 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,152 @@
 Change Log
 ==========
 
+## Version 3.14.1
+
+_2019-04-10_
+
+ *  Fix: Don't crash when an interceptor retries when there are no more routes. This was an
+    edge-case regression introduced with the events cleanup in 3.14.0.
+
+ *  Fix: Provide actionable advice when the exchange is non-null. Prior to 3.14, OkHttp would
+    silently leak connections when an interceptor retries without closing the response body. With
+    3.14 we detect this problem but the exception was not helpful.
+
+## Version 3.14.0
+
+_2019-03-14_
+
+ *  **This release deletes the long-deprecated `OkUrlFactory` and `OkApacheClient` APIs.** These
+    facades hide OkHttp's implementation behind another client's API. If you still need this please
+    copy and paste [ObsoleteUrlFactory.java][obsolete_url_factory] or
+    [ObsoleteApacheClient.java][obsolete_apache_client] into your project.
+
+ *  **OkHttp now supports duplex calls over HTTP/2.** With normal HTTP calls the request must finish
+    before the response starts. With duplex, request and response bodies are transmitted
+    simultaneously. This can be used to implement interactive conversations within a single HTTP
+    call.
+
+    Create duplex calls by overriding the new `RequestBody.isDuplex()` method to return true.
+    This simple option dramatically changes the behavior of the request body and of the entire
+    call.
+
+    The `RequestBody.writeTo()` method may now retain a reference to the provided sink and
+    hand it off to another thread to write to it after `writeTo` returns.
+
+    The `EventListener` may now see requests and responses interleaved in ways not previously
+    permitted. For example, a listener may receive `responseHeadersStart()` followed by
+    `requestBodyEnd()`, both on the same call. Such events may be triggered by different threads
+    even for a single call.
+
+    Interceptors that rewrite or replace the request body may now inadvertently interfere with
+    duplex request bodies. Such interceptors should check `RequestBody.isDuplex()` and avoid
+    accessing the request body when it is.
+
+    Duplex calls require HTTP/2. If HTTP/1 is established instead the duplex call will fail. The
+    most common use of duplex calls is [gRPC][grpc_http2].
+
+ *  New: Prevent OkHttp from retransmitting a request body by overriding `RequestBody.isOneShot()`.
+    This is most useful when writing the request body is destructive.
+
+ *  New: We've added `requestFailed()` and `responseFailed()` methods to `EventListener`. These
+    are called instead of `requestBodyEnd()` and `responseBodyEnd()` in some failure situations.
+    They may also be fired in cases where no event was published previously. In this release we did
+    an internal rewrite of our event code to fix problems where events were lost or unbalanced.
+
+ *  Fix: Don't leak a connection when a call is canceled immediately preceding the `onFailure()`
+    callback.
+
+ *  Fix: Apply call timeouts when connecting duplex calls, web sockets, and server-sent events.
+    Once the streams are established no further timeout is enforced.
+
+ *  Fix: Retain the `Route` when a connection is reused on a redirect or other follow-up. This was
+    causing some `Authenticator` calls to see a null route when non-null was expected.
+
+ *  Fix: Use the correct key size in the name of `TLS_AES_128_CCM_8_SHA256` which is a TLS 1.3
+    cipher suite. We accidentally specified a key size of 256, preventing that cipher suite from
+    being selected for any TLS handshakes. We didn't notice because this cipher suite isn't
+    supported on Android, Java, or Conscrypt.
+
+    We removed this cipher suite and `TLS_AES_128_CCM_SHA256` from the restricted, modern, and
+    compatible sets of cipher suites. These two cipher suites aren't enabled by default in either
+    Firefox or Chrome.
+
+    See our [TLS Configuration History][tls_configuration_history] tracker for a log of all changes
+    to OkHttp's default TLS options.
+
+ *  New: Upgrade to Conscrypt 2.0.0. OkHttp works with other versions of Conscrypt but this is the
+    version we're testing against.
+
+    ```kotlin
+    implementation("org.conscrypt:conscrypt-openjdk-uber:2.0.0")
+    ```
+
+ *  New: Update the embedded public suffixes list.
+
+
+## Version 3.12.2
+
+_2019-03-14_
+
+ *  Fix: Don't crash if the HTTPS server returns no certificates in the TLS handshake.
+ *  Fix: Don't leak a connection when a call is canceled immediately preceding the `onFailure()`
+    callback.
+
+
+## Version 3.13.1
+
+_2019-02-05_
+
+ *  Fix: Don't crash when using a custom `X509TrustManager` or `SSLSocket` on Android. When we
+    removed obsolete code for Android 4.4 we inadvertently also removed support for custom
+    subclasses. We've restored that support!
+
+
+## Version 3.13.0
+
+_2019-02-04_
+
+ *  **This release bumps our minimum requirements to Java 8+ or Android 5+.** Cutting off old
+    devices is a serious change and we don't do it lightly! [This post][require_android_5] explains
+    why we're doing this and how to upgrade.
+
+    The OkHttp 3.12.x branch will be our long-term branch for Android 2.3+ (API level 9+) and Java
+    7+. These platforms lack support for TLS 1.2 and should not be used. But because upgrading is
+    difficult we will backport critical fixes to the 3.12.x branch through December 31, 2020.
+
+ *  **TLSv1 and TLSv1.1 are no longer enabled by default.** Major web browsers are working towards
+    removing these versions altogether in early 2020. If your servers aren't ready yet you can
+    configure OkHttp 3.13 to allow TLSv1 and TLSv1.1 connections:
+
+    ```
+    OkHttpClient client = new OkHttpClient.Builder()
+        .connectionSpecs(Arrays.asList(ConnectionSpec.COMPATIBLE_TLS))
+        .build();
+    ```
+
+ *  New: You can now access HTTP trailers with `Response.trailers()`. This method may only be called
+    after the entire HTTP response body has been read.
+
+ *  New: Upgrade to Okio 1.17.3. If you're on Kotlin-friendly Okio 2.x this release requires 2.2.2
+    or newer.
+
+    ```kotlin
+    implementation("com.squareup.okio:okio:1.17.3")
+    ```
+
+ *  Fix: Don't miss cancels when sending HTTP/2 request headers.
+ *  Fix: Don't miss whole operation timeouts when calls redirect.
+ *  Fix: Don't leak connections if web sockets have malformed responses or if `onOpen()` throws.
+ *  Fix: Don't retry when request bodies fail due to `FileNotFoundException`.
+ *  Fix: Don't crash when URLs have IPv4-mapped IPv6 addresses.
+ *  Fix: Don't crash when building `HandshakeCertificates` on Android API 28.
+ *  Fix: Permit multipart file names to contain non-ASCII characters.
+ *  New: API to get MockWebServer's dispatcher.
+ *  New: API to access headers as `java.time.Instant`.
+ *  New: Fail fast if a `SSLSocketFactory` is used as a `SocketFactory`.
+ *  New: Log the TLS handshake in `LoggingEventListener`.
+
+
 ## Version 3.12.1
 
 _2018-12-23_
@@ -1606,4 +1752,9 @@ Initial release.
  [remove_cbc_ecdsa]: https://developers.google.com/web/updates/2016/12/chrome-56-deprecations#remove_cbc-mode_ecdsa_ciphers_in_tls
  [conscrypt]: https://github.com/google/conscrypt/
  [conscrypt_dependency]: https://github.com/google/conscrypt/#download
- [https_server_sample]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
\ No newline at end of file
+ [https_server_sample]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
+ [require_android_5]: https://medium.com/square-corner-blog/okhttp-3-13-requires-android-5-818bb78d07ce
+ [obsolete_apache_client]: https://gist.github.com/swankjesse/09721f72039e3a46cf50f94323deb82d
+ [obsolete_url_factory]: https://gist.github.com/swankjesse/dd91c0a8854e1559b00f5fc9c7bfae70
+ [tls_configuration_history]: https://github.com/square/okhttp/wiki/TLS-Configuration-History
+ [grpc_http2]: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md
diff --git a/README.md b/README.md
index 4f3a71b4bc..b2a7a59ed3 100644
--- a/README.md
+++ b/README.md
@@ -36,7 +36,7 @@ Download
 Download [the latest JAR][okhttp_latest_jar] or configure this dependency:
 
 ```kotlin
-implementation("com.squareup.okhttp3:okhttp:3.12.1")
+implementation("com.squareup.okhttp3:okhttp:3.14.1")
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -53,7 +53,7 @@ MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2 so
 
 Download [the latest JAR][mockwebserver_latest_jar] or configure this dependency:
 ```xml
-testImplementation("com.squareup.okhttp3:mockwebserver:3.12.1")
+testImplementation("com.squareup.okhttp3:mockwebserver:3.14.1")
 ```
 
 R8 / ProGuard
diff --git a/bom/pom.xml b/bom/pom.xml
deleted file mode 100644
index 635932b866..0000000000
--- a/bom/pom.xml
+++ /dev/null
@@ -1,77 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>okhttp-bom</artifactId>
-  <version>3.13.0-SNAPSHOT</version>
-  <packaging>pom</packaging>
-  <name>OkHttp (Bill of Materials)</name>
-
-  <dependencyManagement>
-    <dependencies>
-      <dependency>
-        <groupId>${project.groupId}</groupId>
-        <artifactId>okhttp</artifactId>
-        <version>${project.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>${project.groupId}</groupId>
-        <artifactId>okhttp-tests</artifactId>
-        <version>${project.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>${project.groupId}</groupId>
-        <artifactId>okhttp-android-support</artifactId>
-        <version>${project.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>${project.groupId}</groupId>
-        <artifactId>okhttp-apache</artifactId>
-        <version>${project.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>${project.groupId}</groupId>
-        <artifactId>okhttp-sse</artifactId>
-        <version>${project.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>${project.groupId}</groupId>
-        <artifactId>okhttp-testing-support</artifactId>
-        <version>${project.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>${project.groupId}</groupId>
-        <artifactId>okhttp-tls</artifactId>
-        <version>${project.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>${project.groupId}</groupId>
-        <artifactId>okhttp-urlconnection</artifactId>
-        <version>${project.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>${project.groupId}</groupId>
-        <artifactId>logging-interceptor</artifactId>
-        <version>${project.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>${project.groupId}</groupId>
-        <artifactId>okhttp-dnsoverhttps</artifactId>
-        <version>${project.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>${project.groupId}</groupId>
-        <artifactId>okcurl</artifactId>
-        <version>${project.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>${project.groupId}</groupId>
-        <artifactId>mockwebserver</artifactId>
-        <version>${project.version}</version>
-      </dependency>
-    </dependencies>
-  </dependencyManagement>
-
-</project>
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 0000000000..a4cd699712
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,242 @@
+import net.ltgt.gradle.errorprone.CheckSeverity
+
+buildscript {
+  ext.versions = [
+      'airline': '0.8',
+      'android': '4.1.1.4',
+      'animalSniffer': '1.17',
+      'assertj': '3.11.0',
+      'bouncycastle': '1.60',
+      'checkstyle': '8.15',
+      'conscrypt': '2.1.0',
+      'findbugs': '3.0.2',
+      'guava': '27.0.1-jre',
+      'java': '1.8',
+      'jnrUnixsocket': '0.22',
+      'jsoup': '1.11.3',
+      'junit': '4.12',
+      'kotlin': '1.3.30',
+      'moshi': '1.8.0',
+      'okio': '2.2.2',
+      'ktlint': '0.31.0'
+  ]
+
+  ext.deps = [
+      'airline': "io.airlift:airline:${versions.airline}",
+      'android': "com.google.android:android:${versions.android}",
+      'animalSniffer': "org.codehaus.mojo:animal-sniffer-annotations:${versions.animalSniffer}",
+      'assertj': "org.assertj:assertj-core:${versions.assertj}",
+      'bouncycastle': "org.bouncycastle:bcprov-jdk15on:${versions.bouncycastle}",
+      'conscrypt': "org.conscrypt:conscrypt-openjdk-uber:${versions.conscrypt}",
+      'guava': "com.google.guava:guava:${versions.guava}",
+      'jnrUnixsocket': "com.github.jnr:jnr-unixsocket:${versions.jnrUnixsocket}",
+      'jsoup': "org.jsoup:jsoup:${versions.jsoup}",
+      'jsr305': "com.google.code.findbugs:jsr305:${versions.findbugs}",
+      'junit': "junit:junit:${versions.junit}",
+      'kotlinStdlib': "org.jetbrains.kotlin:kotlin-stdlib:${versions.kotlin}",
+      'moshi': "com.squareup.moshi:moshi:${versions.moshi}",
+      'okio': "com.squareup.okio:okio:${versions.okio}"
+  ]
+
+  dependencies {
+    // TODO(jwilson): configure maven-publish-plugin to limit which artifacts are published.
+    classpath 'com.vanniktech:gradle-maven-publish-plugin:0.8.0'
+    classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.7.1'
+    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:${versions.kotlin}"
+    classpath "org.jetbrains.dokka:dokka-gradle-plugin:0.9.18"
+    classpath 'com.diffplug.spotless:spotless-plugin-gradle:3.21.1'
+  }
+
+  repositories {
+    mavenCentral()
+    gradlePluginPortal()
+  }
+}
+
+plugins {
+  id 'ru.vyarus.animalsniffer' version '1.5.0'
+  id 'com.github.johnrengelman.shadow' version '4.0.1'
+  id 'me.champeau.gradle.japicmp' version '0.2.6'
+}
+
+allprojects {
+  group = GROUP
+  version = VERSION_NAME
+
+  repositories {
+    mavenCentral()
+    maven {
+      url 'https://dl.bintray.com/kotlin/dokka'
+    }
+  }
+
+  task downloadDependencies() {
+    description 'Download all dependencies to the Gradle cache'
+    doLast {
+      configurations.findAll { it.canBeResolved }.files
+    }
+  }
+}
+
+subprojects { project ->
+  apply plugin: 'java'
+  apply plugin: 'java-library'
+  apply plugin: 'org.jetbrains.kotlin.platform.jvm'
+  apply plugin: 'checkstyle'
+  apply plugin: 'ru.vyarus.animalsniffer'
+  apply plugin: 'net.ltgt.errorprone'
+  apply plugin: 'org.jetbrains.dokka'
+  apply plugin: 'com.diffplug.gradle.spotless'
+  sourceCompatibility = JavaVersion.VERSION_1_8
+  targetCompatibility = JavaVersion.VERSION_1_8
+
+  checkstyleMain.exclude '**/CipherSuite.java'
+  afterEvaluate {
+    checkstyle {
+      configFile = rootProject.file('checkstyle.xml')
+      toolVersion "${versions.checkstyle}"
+      sourceSets = [project.sourceSets.main]
+    }
+  }
+
+  // Animal Sniffer confirms we don't use APIs not on both Java 8 and Android 5.
+  animalsniffer {
+    sourceSets = [sourceSets.main]
+  }
+  dependencies {
+    signature 'net.sf.androidscents.signature:android-api-level-21:5.0.1_r2@signature'
+    signature 'org.codehaus.mojo.signature:java18:1.0@signature'
+  }
+  
+  spotless {
+    kotlin {
+      target "**/*.kt"
+      ktlint(versions.ktlint).userData(['indent_size': '2', 'continuation_indent_size' : '2'])
+    }
+  }
+
+  def platform = System.getProperty("okhttp.platform", "jdk8")
+
+  test {
+    jvmArgs += "-Dlistener=okhttp3.testing.InstallUncaughtExceptionHandlerListener"
+    jvmArgs += "-Dokhttp.platform=$platform"
+
+    testLogging {
+      exceptionFormat = 'full'
+    }
+  }
+
+  if (platform == "jdk8alpn") {
+    // Add alpn-boot on Java 8 so we can use HTTP/2 without a stable API.
+    def alpnBootVersion = alpnBootVersion()
+    if (alpnBootVersion != null) {
+      dependencies {
+        testCompile "org.mortbay.jetty.alpn:alpn-boot:$alpnBootVersion"
+      }
+      def alpnBootJar = configurations.testCompile.find { it.name.startsWith("alpn-boot-") }
+      test {
+        jvmArgs += "-Xbootclasspath/p:${alpnBootJar}"
+      }
+    }
+  } else if (platform == "conscrypt") {
+    dependencies {
+      testRuntime "org.conscrypt:conscrypt-openjdk-uber:${versions.conscrypt}"
+    }
+  }
+
+  dependencies {
+    errorproneJavac 'com.google.errorprone:javac:9+181-r4173-1'
+    errorprone 'com.google.errorprone:error_prone_core:2.3.3'
+  }
+  tasks.withType(JavaCompile).configureEach {
+    options.errorprone {
+      check("MissingFail", CheckSeverity.ERROR)
+      check("MissingOverride", CheckSeverity.ERROR)
+    }
+  }
+
+  dokka {
+    reportUndocumented = false 
+    skipDeprecated = true
+    jdkVersion = 8
+    packageOptions {
+      prefix = "okhttp3.internal"
+      suppress = true
+    }
+    if (project.file('Module.md').exists()) {
+      includes = ['Module.md']
+    }
+    externalDocumentationLink {
+      url = new URL("https://square.github.io/okio/2.x/okio/jvm/index.html")
+      packageListUrl = new URL("https://square.github.io/okio/2.x/okio/jvm/package-list")
+    }
+  }
+}
+
+tasks.wrapper {
+  distributionType = Wrapper.DistributionType.ALL
+}
+
+/**
+ * Returns the alpn-boot version specific to this OpenJDK 8 JVM, or null if this is not a Java 8 VM.
+ * https://github.com/xjdr/xio/blob/master/alpn-boot.gradle
+ */
+def alpnBootVersion() {
+  def javaVersion = System.getProperty("java.version")
+  def patchVersionMatcher = (javaVersion =~ /1\.8\.0_(\d+)(-.*)?/)
+  if (!patchVersionMatcher.find()) return null
+  def patchVersion = Integer.parseInt(patchVersionMatcher.group(1))
+  return alpnBootVersionForPatchVersion(javaVersion, patchVersion)
+}
+
+def alpnBootVersionForPatchVersion(String javaVersion, int patchVersion) {
+  switch (patchVersion) {
+    case 0..24:
+      return '8.1.0.v20141016'
+    case 25..30:
+      return '8.1.2.v20141202'
+    case 31..50:
+      return '8.1.3.v20150130'
+    case 51..59:
+      return '8.1.4.v20150727'
+    case 60..64:
+      return '8.1.5.v20150921'
+    case 65..70:
+      return '8.1.6.v20151105'
+    case 71..77:
+      return '8.1.7.v20160121'
+    case 78..101:
+      return '8.1.8.v20160420'
+    case 102..111:
+      return '8.1.9.v20160720'
+    case 112..120:
+      return '8.1.10.v20161026'
+    case 121..160:
+      return '8.1.11.v20170118'
+    case 161..181:
+      return '8.1.12.v20180117'
+    case 191..202:
+      return '8.1.13.v20181017'
+    default:
+      throw new IllegalStateException("Unexpected Java version: ${javaVersion}")
+  }
+}
+
+/**
+ * Returns a .jar file for the golden version of this project.
+ * https://github.com/Visistema/Groovy1/blob/ba5eb9b2f19ca0cc8927359ce414c4e1974b7016/gradle/binarycompatibility.gradle#L48
+ */
+ext.baselineJar = { project, version ->
+  def group = project.property("GROUP")
+  def artifactId = project.property("POM_ARTIFACT_ID")
+  try {
+    String jarFile = "$artifactId-${version}.jar"
+    project.group = 'virtual_group_for_japicmp' // Prevent it from resolving the current version.
+    def dependency = project.dependencies.create("$group:$artifactId:$version@jar")
+    return project.configurations.detachedConfiguration(dependency).files
+        .find { (it.name == jarFile) }
+  } finally {
+    project.group = group
+  }
+}
+ext.baselineVersion = "3.14.1"
diff --git a/checkstyle.xml b/checkstyle.xml
index 1e4d8e6d1d..f66aad53f8 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -28,8 +28,6 @@
   </module>
 
   <module name="TreeWalker">
-    <property name="cacheFile" value="${checkstyle.cache.file}"/>
-
     <!-- Checks for Javadoc comments.                     -->
     <!-- See http://checkstyle.sf.net/config_javadoc.html -->
     <!--module name="JavadocMethod"/-->
diff --git a/okhttp-tests/fuzzingserver-config.json b/fuzzing/fuzzingserver-config.json
similarity index 100%
rename from okhttp-tests/fuzzingserver-config.json
rename to fuzzing/fuzzingserver-config.json
diff --git a/okhttp-tests/fuzzingserver-expected.txt b/fuzzing/fuzzingserver-expected.txt
similarity index 100%
rename from okhttp-tests/fuzzingserver-expected.txt
rename to fuzzing/fuzzingserver-expected.txt
diff --git a/okhttp-tests/fuzzingserver-test.sh b/fuzzing/fuzzingserver-test.sh
similarity index 100%
rename from okhttp-tests/fuzzingserver-test.sh
rename to fuzzing/fuzzingserver-test.sh
diff --git a/okhttp-tests/fuzzingserver-update-expected.sh b/fuzzing/fuzzingserver-update-expected.sh
similarity index 100%
rename from okhttp-tests/fuzzingserver-update-expected.sh
rename to fuzzing/fuzzingserver-update-expected.sh
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 0000000000..7c006bc8bb
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,16 @@
+org.gradle.jvmargs='-Dfile.encoding=UTF-8'
+
+GROUP=com.squareup.okhttp3
+VERSION_NAME=4.0.0-SNAPSHOT
+
+POM_URL=https://github.com/square/okhttp
+POM_SCM_URL=https://github.com/square/okhttp
+POM_SCM_CONNECTION=scm:git:https://github.com/square/okhttp.git
+POM_SCM_DEV_CONNECTION=scm:git:ssh://git@github.com/square/okhttp.git
+
+POM_LICENCE_NAME=The Apache Software License, Version 2.0
+POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
+POM_LICENCE_DIST=repo
+
+POM_DEVELOPER_ID=square
+POM_DEVELOPER_NAME=Square, Inc.
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..5c2d1cf016
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000000..b8a51fe209
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,5 @@
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.3-all.zip
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
diff --git a/gradlew b/gradlew
new file mode 100755
index 0000000000..b0d6d0ab5d
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,188 @@
+#!/usr/bin/env sh
+
+#
+# Copyright 2015 the original author or authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn () {
+    echo "$*"
+}
+
+die () {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
+}
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
+
+exec "$JAVACMD" "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
index 0000000000..15e1ee37a7
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,100 @@
+@rem
+@rem Copyright 2015 the original author or authors.
+@rem
+@rem Licensed under the Apache License, Version 2.0 (the "License");
+@rem you may not use this file except in compliance with the License.
+@rem You may obtain a copy of the License at
+@rem
+@rem      http://www.apache.org/licenses/LICENSE-2.0
+@rem
+@rem Unless required by applicable law or agreed to in writing, software
+@rem distributed under the License is distributed on an "AS IS" BASIS,
+@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@rem See the License for the specific language governing permissions and
+@rem limitations under the License.
+@rem
+
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/mockwebserver/Module.md b/mockwebserver/Module.md
new file mode 100644
index 0000000000..8493a4c347
--- /dev/null
+++ b/mockwebserver/Module.md
@@ -0,0 +1,3 @@
+# Module mockwebserver
+
+A scriptable web server for testing HTTP clients.
diff --git a/mockwebserver/build.gradle b/mockwebserver/build.gradle
new file mode 100644
index 0000000000..f010b0575d
--- /dev/null
+++ b/mockwebserver/build.gradle
@@ -0,0 +1,28 @@
+apply plugin: 'com.vanniktech.maven.publish'
+apply plugin: 'me.champeau.gradle.japicmp'
+
+jar {
+  manifest {
+    attributes('Automatic-Module-Name': 'okhttp3.mockwebserver')
+  }
+}
+
+dependencies {
+  api project(':okhttp')
+  api deps.junit
+
+  testImplementation project(':okhttp-testing-support')
+  testImplementation project(':okhttp-tls')
+  testImplementation deps.assertj
+}
+
+task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
+  oldClasspath = files(baselineJar(project, baselineVersion))
+  newClasspath = files(jar.archivePath)
+  onlyBinaryIncompatibleModified = true
+  failOnModification = true
+  txtOutputFile = file("$buildDir/reports/japi.txt")
+  ignoreMissingClasses = true
+  includeSynthetic = true
+}
+check.dependsOn(japicmp)
diff --git a/mockwebserver/gradle.properties b/mockwebserver/gradle.properties
new file mode 100644
index 0000000000..640fcdf3d5
--- /dev/null
+++ b/mockwebserver/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=mockwebserver
+POM_NAME=mockwebserver
+POM_PACKAGING=jar
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
deleted file mode 100644
index fe7a1c40d3..0000000000
--- a/mockwebserver/pom.xml
+++ /dev/null
@@ -1,84 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>mockwebserver</artifactId>
-  <name>MockWebServer</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-tls</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>3.0.1</version>
-        <configuration>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-            <link>http://square.github.io/okio/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <version>3.1.0</version>
-        <configuration>
-          <descriptorRefs>
-            <descriptorRef>jar-with-dependencies</descriptorRef>
-          </descriptorRefs>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>single</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.mockwebserver</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
index 2c9ad33b49..51aba7624c 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
@@ -20,7 +20,7 @@
 import java.util.concurrent.TimeUnit;
 import okhttp3.Headers;
 import okhttp3.WebSocketListener;
-import okhttp3.internal.Internal;
+import okhttp3.internal.InternalKtKt;
 import okhttp3.internal.http2.Settings;
 import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
 import okio.Buffer;
@@ -138,7 +138,7 @@ public MockResponse addHeader(String name, Object value) {
    * value.
    */
   public MockResponse addHeaderLenient(String name, Object value) {
-    Internal.instance.addLenient(headers, name, String.valueOf(value));
+    InternalKtKt.addHeaderLenient(headers, name, String.valueOf(value));
     return this;
   }
 
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 4b6983d00e..4ff215096b 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -79,6 +79,7 @@
 import okio.Timeout;
 import org.junit.rules.ExternalResource;
 
+import static okhttp3.internal.InternalKtKt.addHeaderLenient;
 import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.mockwebserver.SocketPolicy.CONTINUE_ALWAYS;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
@@ -140,7 +141,7 @@
       Collections.newSetFromMap(new ConcurrentHashMap<>());
   private final AtomicInteger requestCount = new AtomicInteger();
   private long bodyLimit = Long.MAX_VALUE;
-  private ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
+  private ServerSocketFactory serverSocketFactory;
   private ServerSocket serverSocket;
   private SSLSocketFactory sslSocketFactory;
   private ExecutorService executor;
@@ -366,7 +367,12 @@ private synchronized void start(InetSocketAddress inetSocketAddress) throws IOEx
 
     executor = Executors.newCachedThreadPool(Util.threadFactory("MockWebServer", false));
     this.inetSocketAddress = inetSocketAddress;
+
+    if (serverSocketFactory == null) {
+      serverSocketFactory = ServerSocketFactory.getDefault();
+    }
     serverSocket = serverSocketFactory.createServerSocket();
+
     // Reuse if the user specified a port
     serverSocket.setReuseAddress(inetSocketAddress.getPort() != 0);
     serverSocket.bind(inetSocketAddress, 50);
@@ -491,6 +497,7 @@ public void processConnection() throws Exception {
           if (protocolNegotiationEnabled) {
             String protocolString = Platform.get().getSelectedProtocol(sslSocket);
             protocol = protocolString != null ? Protocol.get(protocolString) : Protocol.HTTP_1_1;
+            Platform.get().afterHandshake(sslSocket);
           }
           openClientSockets.remove(raw);
         } else if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
@@ -650,7 +657,7 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
     boolean expectContinue = false;
     String header;
     while ((header = source.readUtf8LineStrict()).length() != 0) {
-      Internal.instance.addLenient(headers, header);
+      addHeaderLenient(headers, header);
       String lowercaseHeader = header.toLowerCase(Locale.US);
       if (contentLength == -1 && lowercaseHeader.startsWith("content-length:")) {
         contentLength = Long.parseLong(header.substring(15).trim());
@@ -926,7 +933,7 @@ private Http2SocketHandler(Socket socket, Protocol protocol) {
       if (peekedResponse.getSocketPolicy() == RESET_STREAM_AT_START) {
         try {
           dispatchBookkeepingRequest(sequenceNumber.getAndIncrement(), socket);
-          stream.close(ErrorCode.fromHttp2(peekedResponse.getHttp2ErrorCode()));
+          stream.close(ErrorCode.fromHttp2(peekedResponse.getHttp2ErrorCode()), null);
           return;
         } catch (InterruptedException e) {
           throw new AssertionError(e);
@@ -985,9 +992,7 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
       Headers headers = httpHeaders.build();
 
       MockResponse peek = dispatcher.peek();
-      if (peek.isDuplex()) {
-        readBody = false;
-      } else if (!readBody && peek.getSocketPolicy() == EXPECT_CONTINUE) {
+      if (!readBody && peek.getSocketPolicy() == EXPECT_CONTINUE) {
         List<Header> continueHeaders = Collections.singletonList(
             new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue")));
         stream.writeHeaders(continueHeaders, false, true);
@@ -996,7 +1001,7 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
       }
 
       Buffer body = new Buffer();
-      if (readBody) {
+      if (readBody && !peek.isDuplex()) {
         String contentLengthString = headers.get("content-length");
         long byteCount = contentLengthString != null
             ? Long.parseLong(contentLengthString)
@@ -1049,17 +1054,18 @@ private void writeResponse(final Http2Stream stream,
       }
       pushPromises(stream, request, response.getPushPromises());
       if (body != null) {
-        BufferedSink sink = Okio.buffer(stream.getSink());
-        sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
-        throttledTransfer(response, socket, body, sink, body.size(), false);
-        sink.close();
+        try (BufferedSink sink = Okio.buffer(stream.getSink())) {
+          sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
+          throttledTransfer(response, socket, body, sink, body.size(), false);
+        }
       } else if (response.isDuplex()) {
-        BufferedSink sink = Okio.buffer(stream.getSink());
-        BufferedSource source = Okio.buffer(stream.getSource());
-        DuplexResponseBody duplexResponseBody = response.getDuplexResponseBody();
-        duplexResponseBody.onRequest(request, source, sink);
+        try (BufferedSink sink = Okio.buffer(stream.getSink());
+             BufferedSource source = Okio.buffer(stream.getSource())) {
+          DuplexResponseBody duplexResponseBody = response.getDuplexResponseBody();
+          duplexResponseBody.onRequest(request, source, sink);
+        }
       } else if (!outFinished) {
-        stream.close(ErrorCode.NO_ERROR);
+        stream.close(ErrorCode.NO_ERROR, null);
       }
     }
 
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/MockDuplexResponseBody.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/MockDuplexResponseBody.java
new file mode 100644
index 0000000000..6f90d1710b
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/MockDuplexResponseBody.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.mockwebserver.internal.duplex;
+
+import java.io.IOException;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Utf8;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * A scriptable request/response conversation. Create the script by calling methods like {@link
+ * #receiveRequest} in the sequence they are run.
+ */
+public final class MockDuplexResponseBody implements DuplexResponseBody {
+  private final BlockingQueue<Action> actions = new LinkedBlockingQueue<>();
+  private final BlockingQueue<FutureTask<Void>> results = new LinkedBlockingQueue<>();
+
+  public MockDuplexResponseBody receiveRequest(String expected) {
+    actions.add((request, requestBody, responseBody) -> {
+      assertEquals(expected, requestBody.readUtf8(Utf8.size(expected)));
+    });
+    return this;
+  }
+
+  public MockDuplexResponseBody exhaustRequest() {
+    actions.add((request, requestBody, responseBody) -> {
+      assertTrue(requestBody.exhausted());
+    });
+    return this;
+  }
+
+  public MockDuplexResponseBody requestIOException() {
+    actions.add((request, requestBody, responseBody) -> {
+      try {
+        requestBody.exhausted();
+        fail();
+      } catch (IOException expected) {
+      }
+    });
+    return this;
+  }
+
+  public MockDuplexResponseBody sendResponse(String s) {
+    return sendResponse(s, new CountDownLatch(0));
+  }
+
+    public MockDuplexResponseBody sendResponse(String s, CountDownLatch responseSent) {
+    actions.add((request, requestBody, responseBody) -> {
+      responseBody.writeUtf8(s);
+      responseBody.flush();
+      responseSent.countDown();
+    });
+    return this;
+  }
+
+  public MockDuplexResponseBody exhaustResponse() {
+    actions.add((request, requestBody, responseBody) -> {
+      responseBody.close();
+    });
+    return this;
+  }
+
+  public MockDuplexResponseBody sleep(long duration, TimeUnit unit) {
+    actions.add((request, requestBody, responseBody) -> {
+      try {
+        Thread.sleep(unit.toMillis(duration));
+      } catch (InterruptedException e) {
+        throw new AssertionError(e);
+      }
+    });
+    return this;
+  }
+
+  @Override public void onRequest(RecordedRequest request, BufferedSource requestBody,
+      BufferedSink responseBody) {
+    FutureTask<Void> futureTask = new FutureTask<>(() -> {
+      for (Action action; (action = actions.poll()) != null; ) {
+        action.execute(request, requestBody, responseBody);
+      }
+      return null; // Success!
+    });
+    results.add(futureTask);
+    futureTask.run();
+  }
+
+  /** Returns once the duplex conversation completes successfully. */
+  public void awaitSuccess() throws Exception {
+    FutureTask<Void> futureTask = results.poll(5, TimeUnit.SECONDS);
+    if (futureTask == null) throw new AssertionError("no onRequest call received");
+    futureTask.get(5, TimeUnit.SECONDS);
+  }
+
+  private interface Action {
+    void execute(RecordedRequest request, BufferedSource requestBody, BufferedSink responseBody)
+        throws IOException;
+  }
+}
+
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
index 0a43dd9165..39b5df5d11 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
@@ -22,20 +22,18 @@
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
-import org.junit.After;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.Timeout;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class CustomDispatcherTest {
-  private MockWebServer mockWebServer = new MockWebServer();
+  @Rule public MockWebServer mockWebServer = new MockWebServer();
 
-  @After public void tearDown() throws Exception {
-    mockWebServer.shutdown();
-  }
+  @Rule public Timeout globalTimeout = Timeout.seconds(30);
 
   @Test public void simpleDispatch() throws Exception {
-    mockWebServer.start();
     final List<RecordedRequest> requestsMade = new ArrayList<>();
     final Dispatcher dispatcher = new Dispatcher() {
       @Override
@@ -44,19 +42,18 @@ public MockResponse dispatch(RecordedRequest request) {
         return new MockResponse();
       }
     };
-    assertEquals(0, requestsMade.size());
+    assertThat(requestsMade.size()).isEqualTo(0);
     mockWebServer.setDispatcher(dispatcher);
     final URL url = mockWebServer.url("/").url();
     final HttpURLConnection conn = (HttpURLConnection) url.openConnection();
     conn.getResponseCode(); // Force the connection to hit the "server".
     // Make sure our dispatcher got the request.
-    assertEquals(1, requestsMade.size());
+    assertThat(requestsMade.size()).isEqualTo(1);
   }
 
   @Test public void outOfOrderResponses() throws Exception {
     AtomicInteger firstResponseCode = new AtomicInteger();
     AtomicInteger secondResponseCode = new AtomicInteger();
-    mockWebServer.start();
     final String secondRequest = "/bar";
     final String firstRequest = "/foo";
     final CountDownLatch latch = new CountDownLatch(1);
@@ -75,12 +72,16 @@ public MockResponse dispatch(RecordedRequest request) throws InterruptedExceptio
     final Thread endsFirst = buildRequestThread(secondRequest, secondResponseCode);
     endsFirst.start();
     endsFirst.join();
-    assertEquals(0, firstResponseCode.get()); // First response is still waiting.
-    assertEquals(200, secondResponseCode.get()); // Second response is done.
+    // First response is still waiting.
+    assertThat(firstResponseCode.get()).isEqualTo(0);
+    // Second response is done.
+    assertThat(secondResponseCode.get()).isEqualTo(200);
     latch.countDown();
     startsFirst.join();
-    assertEquals(200, firstResponseCode.get()); // And now it's done!
-    assertEquals(200, secondResponseCode.get()); // (Still done).
+    // And now it's done!
+    assertThat(firstResponseCode.get()).isEqualTo(200);
+    // (Still done).
+    assertThat(secondResponseCode.get()).isEqualTo(200);
   }
 
   private Thread buildRequestThread(String path, AtomicInteger responseCode) {
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index 67f417e73f..ceea8b934a 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -28,7 +28,6 @@
 import java.net.URL;
 import java.net.URLConnection;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -38,33 +37,34 @@
 import okhttp3.HttpUrl;
 import okhttp3.Protocol;
 import okhttp3.RecordingHostnameVerifier;
-import okhttp3.internal.Util;
 import okhttp3.tls.HandshakeCertificates;
 import okhttp3.tls.HeldCertificate;
-import org.junit.After;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.Timeout;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Arrays.asList;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeFalse;
 
 public final class MockWebServerTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
+  @Rule public Timeout globalTimeout = Timeout.seconds(30);
+
   @Test public void defaultMockResponse() {
     MockResponse response = new MockResponse();
-    assertEquals(Arrays.asList("Content-Length: 0"), headersToList(response));
-    assertEquals("HTTP/1.1 200 OK", response.getStatus());
+    assertThat(headersToList(response)).containsExactly("Content-Length: 0");
+    assertThat(response.getStatus()).isEqualTo("HTTP/1.1 200 OK");
   }
 
   @Test public void setResponseMockReason() {
@@ -80,21 +80,21 @@
     for (int i = 0; i < 600; i++) {
       MockResponse response = new MockResponse().setResponseCode(i);
       String expectedReason = reasons[i / 100];
-      assertEquals("HTTP/1.1 " + i + " " + expectedReason, response.getStatus());
-      assertEquals(Arrays.asList("Content-Length: 0"), headersToList(response));
+      assertThat(response.getStatus()).isEqualTo(("HTTP/1.1 " + i + " " + expectedReason));
+      assertThat(headersToList(response)).containsExactly("Content-Length: 0");
     }
   }
 
   @Test public void setStatusControlsWholeStatusLine() {
     MockResponse response = new MockResponse().setStatus("HTTP/1.1 202 That'll do pig");
-    assertEquals(Arrays.asList("Content-Length: 0"), headersToList(response));
-    assertEquals("HTTP/1.1 202 That'll do pig", response.getStatus());
+    assertThat(headersToList(response)).containsExactly("Content-Length: 0");
+    assertThat(response.getStatus()).isEqualTo("HTTP/1.1 202 That'll do pig");
   }
 
   @Test public void setBodyAdjustsHeaders() throws IOException {
     MockResponse response = new MockResponse().setBody("ABC");
-    assertEquals(Arrays.asList("Content-Length: 3"), headersToList(response));
-    assertEquals("ABC", response.getBody().readUtf8());
+    assertThat(headersToList(response)).containsExactly("Content-Length: 3");
+    assertThat(response.getBody().readUtf8()).isEqualTo("ABC");
   }
 
   @Test public void mockResponseAddHeader() {
@@ -102,7 +102,7 @@
         .clearHeaders()
         .addHeader("Cookie: s=square")
         .addHeader("Cookie", "a=android");
-    assertEquals(Arrays.asList("Cookie: s=square", "Cookie: a=android"), headersToList(response));
+    assertThat(headersToList(response)).containsExactly("Cookie: s=square", "Cookie: a=android");
   }
 
   @Test public void mockResponseSetHeader() {
@@ -112,7 +112,7 @@
         .addHeader("Cookie: a=android")
         .addHeader("Cookies: delicious");
     response.setHeader("cookie", "r=robot");
-    assertEquals(Arrays.asList("Cookies: delicious", "cookie: r=robot"), headersToList(response));
+    assertThat(headersToList(response)).containsExactly("Cookies: delicious", "cookie: r=robot");
   }
 
   @Test public void mockResponseSetHeaders() {
@@ -123,7 +123,7 @@
 
     response.setHeaders(new Headers.Builder().add("Cookie", "a=android").build());
 
-    assertEquals(Arrays.asList("Cookie: a=android"), headersToList(response));
+    assertThat(headersToList(response)).containsExactly("Cookie: a=android");
   }
 
   @Test public void regularResponse() throws Exception {
@@ -134,12 +134,12 @@
     connection.setRequestProperty("Accept-Language", "en-US");
     InputStream in = connection.getInputStream();
     BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
-    assertEquals("hello world", reader.readLine());
+    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
+    assertThat(reader.readLine()).isEqualTo("hello world");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", request.getRequestLine());
-    assertEquals("en-US", request.getHeader("Accept-Language"));
+    assertThat(request.getRequestLine()).isEqualTo("GET / HTTP/1.1");
+    assertThat(request.getHeader("Accept-Language")).isEqualTo("en-US");
   }
 
   @Test public void redirect() throws Exception {
@@ -152,12 +152,12 @@
     URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
     BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertEquals("This is the new location!", reader.readLine());
+    assertThat(reader.readLine()).isEqualTo("This is the new location!");
 
     RecordedRequest first = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", first.getRequestLine());
+    assertThat(first.getRequestLine()).isEqualTo("GET / HTTP/1.1");
     RecordedRequest redirect = server.takeRequest();
-    assertEquals("GET /new-path HTTP/1.1", redirect.getRequestLine());
+    assertThat(redirect.getRequestLine()).isEqualTo("GET /new-path HTTP/1.1");
   }
 
   /**
@@ -176,7 +176,7 @@
     URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
     BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertEquals("enqueued in the background", reader.readLine());
+    assertThat(reader.readLine()).isEqualTo("enqueued in the background");
   }
 
   @Test public void nonHexadecimalChunkSize() throws Exception {
@@ -204,9 +204,9 @@
     URLConnection urlConnection = server.url("/").url().openConnection();
     urlConnection.setReadTimeout(1000);
     InputStream in = urlConnection.getInputStream();
-    assertEquals('A', in.read());
-    assertEquals('B', in.read());
-    assertEquals('C', in.read());
+    assertThat(in.read()).isEqualTo('A');
+    assertThat(in.read()).isEqualTo('B');
+    assertThat(in.read()).isEqualTo('C');
     try {
       in.read(); // if Content-Length was accurate, this would return -1 immediately
       fail();
@@ -215,21 +215,23 @@
 
     URLConnection urlConnection2 = server.url("/").url().openConnection();
     InputStream in2 = urlConnection2.getInputStream();
-    assertEquals('D', in2.read());
-    assertEquals('E', in2.read());
-    assertEquals('F', in2.read());
-    assertEquals(-1, in2.read());
+    assertThat(in2.read()).isEqualTo('D');
+    assertThat(in2.read()).isEqualTo('E');
+    assertThat(in2.read()).isEqualTo('F');
+    assertThat(in2.read()).isEqualTo(-1);
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
+  @Ignore("Not actually failing where expected")
   @Test public void disconnectAtStart() throws Exception {
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
     server.enqueue(new MockResponse()); // The jdk's HttpUrlConnection is a bastard.
     server.enqueue(new MockResponse());
     try {
       server.url("/a").url().openConnection().getInputStream();
+      fail();
     } catch (IOException expected) {
     }
     server.url("/b").url().openConnection().getInputStream(); // Should succeed.
@@ -248,12 +250,10 @@
     connection.setDoOutput(true);
     connection.getOutputStream().write("ABCDEF".getBytes(UTF_8));
     InputStream in = connection.getInputStream();
-    assertEquals(-1, in.read());
+    assertThat(in.read()).isEqualTo(-1);
     long elapsedNanos = System.nanoTime() - startNanos;
     long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-
-    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
-    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
+    assertThat(elapsedMillis).isBetween(500L, 1000L);
   }
 
   /**
@@ -268,18 +268,16 @@
     long startNanos = System.nanoTime();
     URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
-    assertEquals('A', in.read());
-    assertEquals('B', in.read());
-    assertEquals('C', in.read());
-    assertEquals('D', in.read());
-    assertEquals('E', in.read());
-    assertEquals('F', in.read());
-    assertEquals(-1, in.read());
+    assertThat(in.read()).isEqualTo('A');
+    assertThat(in.read()).isEqualTo('B');
+    assertThat(in.read()).isEqualTo('C');
+    assertThat(in.read()).isEqualTo('D');
+    assertThat(in.read()).isEqualTo('E');
+    assertThat(in.read()).isEqualTo('F');
+    assertThat(in.read()).isEqualTo(-1);
     long elapsedNanos = System.nanoTime() - startNanos;
     long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-
-    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
-    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
+    assertThat(elapsedMillis).isBetween(500L, 1000L);
   }
 
   /** Delay the response body by sleeping 1s. */
@@ -291,10 +289,10 @@
     long startNanos = System.nanoTime();
     URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
-    assertEquals('A', in.read());
+    assertThat(in.read()).isEqualTo('A');
     long elapsedNanos = System.nanoTime() - startNanos;
     long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 1000);
+    assertThat(elapsedMillis).isGreaterThanOrEqualTo(1000L);
 
     in.close();
   }
@@ -326,7 +324,8 @@
         break;
       }
     }
-    assertEquals(512f, i, 5f); // Halfway +/- 0.5%
+    // Halfway +/- 0.5%
+    assertThat((float) i).isCloseTo(512f, offset(5f));
   }
 
   @Test public void disconnectResponseHalfway() throws IOException {
@@ -335,13 +334,13 @@
         .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
 
     URLConnection connection = server.url("/").url().openConnection();
-    assertEquals(2, connection.getContentLength());
+    assertThat(connection.getContentLength()).isEqualTo(2);
     InputStream in = connection.getInputStream();
-    assertEquals('a', in.read());
+    assertThat(in.read()).isEqualTo('a');
     try {
       int byteRead = in.read();
       // OpenJDK behavior: end of stream.
-      assertEquals(-1, byteRead);
+      assertThat(byteRead).isEqualTo(-1);
     } catch (ProtocolException e) {
       // On Android, HttpURLConnection is implemented by OkHttp v2. OkHttp
       // treats an incomplete response body as a ProtocolException.
@@ -374,25 +373,21 @@
     server.shutdown();
   }
 
-  @After public void tearDown() throws IOException {
-    server.shutdown();
-  }
-
   @Test public void portImplicitlyStarts() throws IOException {
-    assertTrue(server.getPort() > 0);
+    assertThat(server.getPort()).isGreaterThan(0);
   }
 
   @Test public void hostnameImplicitlyStarts() throws IOException {
-    assertNotNull(server.getHostName());
+    assertThat(server.getHostName()).isNotNull();
   }
 
   @Test public void toProxyAddressImplicitlyStarts() throws IOException {
-    assertNotNull(server.toProxyAddress());
+    assertThat(server.toProxyAddress()).isNotNull();
   }
 
   @Test public void differentInstancesGetDifferentPorts() throws IOException {
     MockWebServer other = new MockWebServer();
-    assertNotEquals(server.getPort(), other.getPort());
+    assertThat(other.getPort()).isNotEqualTo(server.getPort());
     other.shutdown();
   }
 
@@ -407,7 +402,7 @@
 
     statement.evaluate();
 
-    assertTrue(called.get());
+    assertThat(called.get()).isTrue();
     try {
       server.url("/").url().openConnection().connect();
       fail();
@@ -436,18 +431,19 @@
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
     InputStream in = connection.getInputStream();
     BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
-    assertEquals("hello world", reader.readLine());
+    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
+    assertThat(reader.readLine()).isEqualTo("hello world");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("GET /a/deep/path?key=foo%20bar HTTP/1.1", request.getRequestLine());
+    assertThat(request.getRequestLine()).isEqualTo(
+        "GET /a/deep/path?key=foo%20bar HTTP/1.1");
 
     HttpUrl requestUrl = request.getRequestUrl();
-    assertEquals("http", requestUrl.scheme());
-    assertEquals(server.getHostName(), requestUrl.host());
-    assertEquals(server.getPort(), requestUrl.port());
-    assertEquals("/a/deep/path", requestUrl.encodedPath());
-    assertEquals("foo bar", requestUrl.queryParameter("key"));
+    assertThat(requestUrl.scheme()).isEqualTo("http");
+    assertThat(requestUrl.host()).isEqualTo(server.getHostName());
+    assertThat(requestUrl.port()).isEqualTo(server.getPort());
+    assertThat(requestUrl.encodedPath()).isEqualTo("/a/deep/path");
+    assertThat(requestUrl.queryParameter("key")).isEqualTo("foo bar");
   }
 
   @Test public void shutdownServerAfterRequest() throws Exception {
@@ -456,15 +452,15 @@
     URL url = server.url("/").url();
 
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
 
     HttpURLConnection refusedConnection = (HttpURLConnection) url.openConnection();
 
     try {
       refusedConnection.getResponseCode();
       fail("Second connection should be refused");
-    } catch (ConnectException e ) {
-      assertTrue(e.getMessage().contains("refused"));
+    } catch (ConnectException e) {
+      assertThat(e.getMessage()).contains("refused");
     }
   }
 
@@ -479,38 +475,40 @@
 
     InputStream in = connection.getInputStream();
     BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertEquals("response", reader.readLine());
+    assertThat(reader.readLine()).isEqualTo("response");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("request", request.getBody().readUtf8());
+    assertThat(request.getBody().readUtf8()).isEqualTo("request");
   }
 
   @Test public void testH2PriorKnowledgeServerFallback() {
     try {
-      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
+      server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
-              + "[h2_prior_knowledge, http/1.1]", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("protocols containing h2_prior_knowledge cannot use other protocols: "
+              + "[h2_prior_knowledge, http/1.1]"));
     }
   }
 
   @Test public void testH2PriorKnowledgeServerDuplicates() {
     try {
       // Treating this use case as user error
-      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
+      server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
-          + "[h2_prior_knowledge, h2_prior_knowledge]", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("protocols containing h2_prior_knowledge cannot use other protocols: "
+              + "[h2_prior_knowledge, h2_prior_knowledge]"));
     }
   }
 
   @Test public void testMockWebServerH2PriorKnowledgeProtocol() {
-    server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE));
+    server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE));
 
-    assertEquals(1, server.protocols().size());
-    assertEquals(Protocol.H2_PRIOR_KNOWLEDGE, server.protocols().get(0));
+    assertThat(server.protocols().size()).isEqualTo(1);
+    assertThat(server.protocols().get(0)).isEqualTo(Protocol.H2_PRIOR_KNOWLEDGE);
   }
 
   @Test public void https() throws Exception {
@@ -523,22 +521,24 @@
     connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     connection.setHostnameVerifier(new RecordingHostnameVerifier());
 
-    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
     BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
-    assertEquals("abc", reader.readLine());
+    assertThat(reader.readLine()).isEqualTo("abc");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("https", request.getRequestUrl().scheme());
+    assertThat(request.getRequestUrl().scheme()).isEqualTo("https");
     Handshake handshake = request.getHandshake();
-    assertNotNull(handshake.tlsVersion());
-    assertNotNull(handshake.cipherSuite());
-    assertNotNull(handshake.localPrincipal());
-    assertEquals(1, handshake.localCertificates().size());
-    assertNull(handshake.peerPrincipal());
-    assertEquals(0, handshake.peerCertificates().size());
+    assertThat(handshake.tlsVersion()).isNotNull();
+    assertThat(handshake.cipherSuite()).isNotNull();
+    assertThat(handshake.localPrincipal()).isNotNull();
+    assertThat(handshake.localCertificates().size()).isEqualTo(1);
+    assertThat(handshake.peerPrincipal()).isNull();
+    assertThat(handshake.peerCertificates().size()).isEqualTo(0);
   }
 
   @Test public void httpsWithClientAuth() throws Exception {
+    assumeFalse(getPlatform().equals("conscrypt"));
+
     HeldCertificate clientCa = new HeldCertificate.Builder()
         .certificateAuthority(0)
         .build();
@@ -571,18 +571,22 @@
     connection.setSSLSocketFactory(clientHandshakeCertificates.sslSocketFactory());
     connection.setHostnameVerifier(new RecordingHostnameVerifier());
 
-    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
     BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
-    assertEquals("abc", reader.readLine());
+    assertThat(reader.readLine()).isEqualTo("abc");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("https", request.getRequestUrl().scheme());
+    assertThat(request.getRequestUrl().scheme()).isEqualTo("https");
     Handshake handshake = request.getHandshake();
-    assertNotNull(handshake.tlsVersion());
-    assertNotNull(handshake.cipherSuite());
-    assertNotNull(handshake.localPrincipal());
-    assertEquals(1, handshake.localCertificates().size());
-    assertNotNull(handshake.peerPrincipal());
-    assertEquals(1, handshake.peerCertificates().size());
+    assertThat(handshake.tlsVersion()).isNotNull();
+    assertThat(handshake.cipherSuite()).isNotNull();
+    assertThat(handshake.localPrincipal()).isNotNull();
+    assertThat(handshake.localCertificates().size()).isEqualTo(1);
+    assertThat(handshake.peerPrincipal()).isNotNull();
+    assertThat(handshake.peerCertificates().size()).isEqualTo(1);
+  }
+
+  public static String getPlatform() {
+    return System.getProperty("okhttp.platform", "jdk8");
   }
 }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
index b55a6ddd3f..4d498406a8 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
@@ -22,13 +22,16 @@
 import java.net.UnknownHostException;
 import java.util.Collections;
 import okhttp3.Headers;
+import okhttp3.internal.Util;
 import okio.Buffer;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.Timeout;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class RecordedRequestTest {
-  Headers headers = new Headers.Builder().build();
+  Headers headers = Util.EMPTY_HEADERS;
 
   private class FakeSocket extends Socket {
     private final InetAddress localAddress;
@@ -68,6 +71,8 @@ private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAd
     }
   }
 
+  @Rule public Timeout globalTimeout = Timeout.seconds(30);
+
   @Test public void testIPv4() throws UnknownHostException {
     Socket socket =
         new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] { 127, 0, 0, 1 }), 80);
@@ -75,7 +80,7 @@ private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAd
     RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
         Collections.emptyList(), 0, new Buffer(), 0, socket);
 
-    assertEquals("http://127.0.0.1/", request.getRequestUrl().toString());
+    assertThat(request.getRequestUrl().toString()).isEqualTo("http://127.0.0.1/");
   }
 
   @Test public void testIpv6() throws UnknownHostException {
@@ -85,7 +90,7 @@ private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAd
     RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
         Collections.emptyList(), 0, new Buffer(), 0, socket);
 
-    assertEquals("http://[::1]/", request.getRequestUrl().toString());
+    assertThat(request.getRequestUrl().toString()).isEqualTo("http://[::1]/");
   }
 
   @Test public void testUsesLocal() throws UnknownHostException {
@@ -95,6 +100,6 @@ private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAd
     RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
         Collections.emptyList(), 0, new Buffer(), 0, socket);
 
-    assertEquals("http://127.0.0.1/", request.getRequestUrl().toString());
+    assertThat(request.getRequestUrl().toString()).isEqualTo("http://127.0.0.1/");
   }
 }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
index b7ca4b2488..eeed8d2b08 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
@@ -21,7 +21,6 @@
 import java.net.ProtocolException;
 import java.net.ServerSocket;
 import java.net.Socket;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.logging.Level;
@@ -39,6 +38,7 @@
 import okio.Okio;
 import okio.Source;
 
+import static java.util.Arrays.asList;
 import static okhttp3.internal.platform.Platform.INFO;
 import static okhttp3.tls.internal.TlsUtil.localhost;
 
@@ -125,7 +125,7 @@ private SSLSocket doSsl(Socket socket) throws IOException {
   }
 
   private void send404(Http2Stream stream, String path) throws IOException {
-    List<Header> responseHeaders = Arrays.asList(
+    List<Header> responseHeaders = asList(
         new Header(":status", "404"),
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", "text/plain")
@@ -137,7 +137,7 @@ private void send404(Http2Stream stream, String path) throws IOException {
   }
 
   private void serveDirectory(Http2Stream stream, File[] files) throws IOException {
-    List<Header> responseHeaders = Arrays.asList(
+    List<Header> responseHeaders = asList(
         new Header(":status", "200"),
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", "text/html; charset=UTF-8")
@@ -152,7 +152,7 @@ private void serveDirectory(Http2Stream stream, File[] files) throws IOException
   }
 
   private void serveFile(Http2Stream stream, File file) throws IOException {
-    List<Header> responseHeaders = Arrays.asList(
+    List<Header> responseHeaders = asList(
         new Header(":status", "200"),
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", contentType(file))
diff --git a/okcurl/build.gradle b/okcurl/build.gradle
new file mode 100644
index 0000000000..54ebfabf50
--- /dev/null
+++ b/okcurl/build.gradle
@@ -0,0 +1,38 @@
+apply plugin: 'com.vanniktech.maven.publish'
+apply plugin: 'com.github.johnrengelman.shadow'
+
+jar {
+  manifest {
+    attributes 'Automatic-Module-Name': 'okhttp3.curl'
+    attributes 'Main-Class': 'okhttp3.curl.Main'
+  }
+}
+
+// resources-templates.
+sourceSets {
+  main.resources.srcDirs += "$buildDir/generated/resources-templates"
+}
+compileJava {
+  dependsOn 'copyResourcesTemplates'
+}
+task copyResourcesTemplates(type: Copy) {
+  from 'src/main/resources-templates'
+  into "$buildDir/generated/resources-templates"
+  expand('projectVersion': "$VERSION_NAME")
+  filteringCharset = 'UTF-8'
+}
+
+dependencies {
+  api project(':okhttp')
+  api project(':okhttp-logging-interceptor')
+  implementation deps.airline
+  implementation deps.guava
+
+  testImplementation project(':okhttp-testing-support')
+  testImplementation deps.junit
+  testImplementation deps.assertj
+}
+
+shadowJar {
+  mergeServiceFiles()
+}
diff --git a/okcurl/gradle.properties b/okcurl/gradle.properties
new file mode 100644
index 0000000000..ae701b79bd
--- /dev/null
+++ b/okcurl/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=okcurl
+POM_NAME=okcurl
+POM_PACKAGING=jar
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
deleted file mode 100644
index c252ade5b2..0000000000
--- a/okcurl/pom.xml
+++ /dev/null
@@ -1,110 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okcurl</artifactId>
-  <name>OkCurl</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>logging-interceptor</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>io.airlift</groupId>
-      <artifactId>airline</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <resources>
-      <resource>
-        <directory>src/main/resources</directory>
-        <filtering>true</filtering>
-      </resource>
-    </resources>
-
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <version>3.1.0</version>
-        <configuration>
-          <descriptorRefs>
-            <descriptorRef>jar-with-dependencies</descriptorRef>
-          </descriptorRefs>
-          <archive>
-            <manifest>
-              <mainClass>okhttp3.curl.Main</mainClass>
-            </manifest>
-          </archive>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>single</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.skife.maven</groupId>
-        <artifactId>really-executable-jar-maven-plugin</artifactId>
-        <version>1.5.0</version>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>really-executable-jar</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <flags>-Xbootclasspath/p:$0</flags>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.curl</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okcurl/src/main/java/okhttp3/curl/Main.java b/okcurl/src/main/java/okhttp3/curl/Main.java
index 22c8b5c45c..a6c799b944 100644
--- a/okcurl/src/main/java/okhttp3/curl/Main.java
+++ b/okcurl/src/main/java/okhttp3/curl/Main.java
@@ -276,7 +276,7 @@ private static X509TrustManager createInsecureTrustManager() {
 
   private static SSLSocketFactory createInsecureSslSocketFactory(TrustManager trustManager) {
     try {
-      SSLContext context = Platform.get().getSSLContext();
+      SSLContext context = Platform.get().newSSLContext();
       context.init(null, new TrustManager[] {trustManager}, null);
       return context.getSocketFactory();
     } catch (Exception e) {
diff --git a/okcurl/src/main/resources-templates/okcurl-version.properties b/okcurl/src/main/resources-templates/okcurl-version.properties
new file mode 100644
index 0000000000..a15427847c
--- /dev/null
+++ b/okcurl/src/main/resources-templates/okcurl-version.properties
@@ -0,0 +1 @@
+version=${projectVersion}
diff --git a/okcurl/src/main/resources/okcurl-version.properties b/okcurl/src/main/resources/okcurl-version.properties
deleted file mode 100644
index defbd48204..0000000000
--- a/okcurl/src/main/resources/okcurl-version.properties
+++ /dev/null
@@ -1 +0,0 @@
-version=${project.version}
diff --git a/okcurl/src/test/java/okhttp3/curl/MainTest.java b/okcurl/src/test/java/okhttp3/curl/MainTest.java
index 12fe6d5ec4..6277c93f8a 100644
--- a/okcurl/src/test/java/okhttp3/curl/MainTest.java
+++ b/okcurl/src/test/java/okhttp3/curl/MainTest.java
@@ -22,72 +22,79 @@
 import org.junit.Test;
 
 import static okhttp3.curl.Main.fromArgs;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class MainTest {
   @Test public void simple() {
     Request request = fromArgs("http://example.com").createRequest();
-    assertEquals("GET", request.method());
-    assertEquals("http://example.com/", request.url().toString());
-    assertNull(request.body());
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void put() throws IOException {
     Request request = fromArgs("-X", "PUT", "-d", "foo", "http://example.com").createRequest();
-    assertEquals("PUT", request.method());
-    assertEquals("http://example.com/", request.url().toString());
-    assertEquals(3, request.body().contentLength());
+    assertThat(request.method()).isEqualTo("PUT");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/");
+    assertThat(request.body().contentLength()).isEqualTo(3);
   }
 
   @Test public void dataPost() {
     Request request = fromArgs("-d", "foo", "http://example.com").createRequest();
     RequestBody body = request.body();
-    assertEquals("POST", request.method());
-    assertEquals("http://example.com/", request.url().toString());
-    assertEquals("application/x-www-form-urlencoded; charset=utf-8", body.contentType().toString());
-    assertEquals("foo", bodyAsString(body));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/");
+    assertThat(body.contentType().toString()).isEqualTo(
+        "application/x-www-form-urlencoded; charset=utf-8");
+    assertThat(bodyAsString(body)).isEqualTo("foo");
   }
 
   @Test public void dataPut() {
     Request request = fromArgs("-d", "foo", "-X", "PUT", "http://example.com").createRequest();
     RequestBody body = request.body();
-    assertEquals("PUT", request.method());
-    assertEquals("http://example.com/", request.url().toString());
-    assertEquals("application/x-www-form-urlencoded; charset=utf-8", body.contentType().toString());
-    assertEquals("foo", bodyAsString(body));
+    assertThat(request.method()).isEqualTo("PUT");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/");
+    assertThat(body.contentType().toString()).isEqualTo(
+        "application/x-www-form-urlencoded; charset=utf-8");
+    assertThat(bodyAsString(body)).isEqualTo("foo");
   }
 
   @Test public void contentTypeHeader() {
     Request request = fromArgs("-d", "foo", "-H", "Content-Type: application/json",
         "http://example.com").createRequest();
     RequestBody body = request.body();
-    assertEquals("POST", request.method());
-    assertEquals("http://example.com/", request.url().toString());
-    assertEquals("application/json; charset=utf-8", body.contentType().toString());
-    assertEquals("foo", bodyAsString(body));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/");
+    assertThat(body.contentType().toString()).isEqualTo("application/json; charset=utf-8");
+    assertThat(bodyAsString(body)).isEqualTo("foo");
   }
 
   @Test public void referer() {
     Request request = fromArgs("-e", "foo", "http://example.com").createRequest();
-    assertEquals("GET", request.method());
-    assertEquals("http://example.com/", request.url().toString());
-    assertEquals("foo", request.header("Referer"));
-    assertNull(request.body());
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/");
+    assertThat(request.header("Referer")).isEqualTo("foo");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void userAgent() {
     Request request = fromArgs("-A", "foo", "http://example.com").createRequest();
-    assertEquals("GET", request.method());
-    assertEquals("http://example.com/", request.url().toString());
-    assertEquals("foo", request.header("User-Agent"));
-    assertNull(request.body());
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/");
+    assertThat(request.header("User-Agent")).isEqualTo("foo");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void defaultUserAgent() {
+    Request request = fromArgs("http://example.com").createRequest();
+    assertThat(request.header("User-Agent")).startsWith("okcurl/");
   }
 
   @Test public void headerSplitWithDate() {
     Request request = fromArgs("-H", "If-Modified-Since: Mon, 18 Aug 2014 15:16:06 GMT",
         "http://example.com").createRequest();
-    assertEquals("Mon, 18 Aug 2014 15:16:06 GMT", request.header("If-Modified-Since"));
+    assertThat(request.header("If-Modified-Since")).isEqualTo(
+        "Mon, 18 Aug 2014 15:16:06 GMT");
   }
 
   private static String bodyAsString(RequestBody body) {
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
deleted file mode 100644
index 1dbcfce02c..0000000000
--- a/okhttp-android-support/pom.xml
+++ /dev/null
@@ -1,82 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-android-support</artifactId>
-  <name>OkHttp Android Platform Support</name>
-  <description>Classes to support the Android platform's use of OkHttp (not required for most
-    developers).
-  </description>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-tls</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-urlconnection</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>3.0.1</version>
-        <configuration>
-          <excludePackageNames>okhttp3.internal.*</excludePackageNames>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.androidsupport</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java b/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
deleted file mode 100644
index de5788539a..0000000000
--- a/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.ResponseCache;
-import okhttp3.internal.huc.CacheAdapter;
-
-/**
- * Back doors to enable the use of OkHttp within the Android platform libraries. OkHttp is used to
- * provide the default {@link java.net.HttpURLConnection} / {@link javax.net.ssl.HttpsURLConnection}
- * implementation including support for a custom {@link ResponseCache}.
- */
-public class AndroidInternal {
-
-  private AndroidInternal() {
-  }
-
-  /** Sets the response cache to be used to read and write cached responses. */
-  public static void setResponseCache(OkUrlFactory okUrlFactory, ResponseCache responseCache) {
-    OkHttpClient.Builder builder = okUrlFactory.client().newBuilder();
-    if (responseCache instanceof OkCacheContainer) {
-      // Avoid adding layers of wrappers. Rather than wrap the ResponseCache in yet another layer to
-      // make the ResponseCache look like an InternalCache, we can unwrap the Cache instead.
-      // This means that Cache stats will be correctly updated.
-      OkCacheContainer okCacheContainer = (OkCacheContainer) responseCache;
-      builder.cache(okCacheContainer.getCache());
-    } else {
-      builder.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
-    }
-    okUrlFactory.setClient(builder.build());
-  }
-}
diff --git a/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
deleted file mode 100644
index a0590b2c4b..0000000000
--- a/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-import javax.annotation.Nullable;
-import okhttp3.internal.huc.JavaApiConverter;
-
-/**
- * A class provided for use by Android so that it can continue supporting a {@link ResponseCache}
- * with stats.
- */
-public class AndroidShimResponseCache extends ResponseCache {
-
-  private final Cache delegate;
-
-  private AndroidShimResponseCache(Cache delegate) {
-    this.delegate = delegate;
-  }
-
-  public static AndroidShimResponseCache create(File directory, long maxSize) throws IOException {
-    Cache cache = new Cache(directory, maxSize);
-    return new AndroidShimResponseCache(cache);
-  }
-
-  public boolean isEquivalent(File directory, long maxSize) {
-    Cache installedCache = getCache();
-    return (installedCache.directory().equals(directory)
-        && installedCache.maxSize() == maxSize
-        && !installedCache.isClosed());
-  }
-
-  public Cache getCache() {
-    return delegate;
-  }
-
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) throws IOException {
-    Request okRequest = JavaApiConverter.createOkRequest(uri, requestMethod, requestHeaders);
-    Response okResponse = delegate.internalCache.get(okRequest);
-    if (okResponse == null) {
-      return null;
-    }
-    return JavaApiConverter.createJavaCacheResponse(okResponse);
-  }
-
-  @Override public @Nullable CacheRequest put(
-      URI uri, URLConnection urlConnection) throws IOException {
-    Response okResponse = JavaApiConverter.createOkResponseForCachePut(uri, urlConnection);
-    if (okResponse == null) {
-      // The URLConnection is not cacheable or could not be converted. Stop.
-      return null;
-    }
-    okhttp3.internal.cache.CacheRequest okCacheRequest =
-        delegate.internalCache.put(okResponse);
-    if (okCacheRequest == null) {
-      return null;
-    }
-    return JavaApiConverter.createJavaCacheRequest(okCacheRequest);
-  }
-
-  /**
-   * Returns the number of bytes currently being used to store the values in this cache. This may be
-   * greater than the {@link #maxSize} if a background deletion is pending.
-   */
-  public long size() throws IOException {
-    return delegate.size();
-  }
-
-  /**
-   * Returns the maximum number of bytes that this cache should use to store its data.
-   */
-  public long maxSize() {
-    return delegate.maxSize();
-  }
-
-  /**
-   * Force buffered operations to the filesystem. This ensures that responses written to the cache
-   * will be available the next time the cache is opened, even if this process is killed.
-   */
-  public void flush() throws IOException {
-    delegate.flush();
-  }
-
-  /**
-   * Returns the number of HTTP requests that required the network to either supply a response or
-   * validate a locally cached response.
-   */
-  public int getNetworkCount() {
-    return delegate.networkCount();
-  }
-
-  /**
-   * Returns the number of HTTP requests whose response was provided by the cache. This may include
-   * conditional {@code GET} requests that were validated over the network.
-   */
-  public int getHitCount() {
-    return delegate.hitCount();
-  }
-
-  /**
-   * Returns the total number of HTTP requests that were made. This includes both client requests
-   * and requests that were made on the client's behalf to handle a redirects and retries.
-   */
-  public int getRequestCount() {
-    return delegate.requestCount();
-  }
-
-  /**
-   * Uninstalls the cache and releases any active resources. Stored contents will remain on the
-   * filesystem.
-   */
-  public void close() throws IOException {
-    delegate.close();
-  }
-
-  /**
-   * Uninstalls the cache and deletes all of its stored contents.
-   */
-  public void delete() throws IOException {
-    delegate.delete();
-  }
-}
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
deleted file mode 100644
index 5bca95b937..0000000000
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.util.List;
-import java.util.Map;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.cache.CacheRequest;
-import okhttp3.internal.cache.CacheStrategy;
-import okhttp3.internal.cache.InternalCache;
-import okio.Okio;
-import okio.Sink;
-
-/** Adapts {@link ResponseCache} to {@link InternalCache}. */
-public final class CacheAdapter implements InternalCache {
-  private final ResponseCache delegate;
-
-  public CacheAdapter(ResponseCache delegate) {
-    this.delegate = delegate;
-  }
-
-  public ResponseCache getDelegate() {
-    return delegate;
-  }
-
-  @Override public Response get(Request request) throws IOException {
-    CacheResponse javaResponse = getJavaCachedResponse(request);
-    if (javaResponse == null) {
-      return null;
-    }
-    return JavaApiConverter.createOkResponseForCacheGet(request, javaResponse);
-  }
-
-  @Override public CacheRequest put(Response response) throws IOException {
-    URI uri = response.request().url().uri();
-    HttpURLConnection connection = JavaApiConverter.createJavaUrlConnectionForCachePut(response);
-    final java.net.CacheRequest request = delegate.put(uri, connection);
-    if (request == null) {
-      return null;
-    }
-    return new CacheRequest() {
-      @Override public Sink body() throws IOException {
-        OutputStream body = request.getBody();
-        return body != null ? Okio.sink(body) : null;
-      }
-
-      @Override public void abort() {
-        request.abort();
-      }
-    };
-  }
-
-  @Override public void remove(Request request) throws IOException {
-    // This method is treated as optional and there is no obvious way of implementing it with
-    // ResponseCache. Removing items from the cache due to modifications made from this client is
-    // not essential given that modifications could be made from any other client. We have to assume
-    // that it's ok to keep using the cached data. Otherwise the server shouldn't declare it as
-    // cacheable or the client should be careful about caching it.
-  }
-
-  @Override public void update(Response cached, Response network) {
-    // This method is treated as optional and there is no obvious way of implementing it with
-    // ResponseCache. Updating headers is useful if the server changes the metadata for a resource
-    // (e.g. max age) to extend or truncate the life of that resource in the cache. If the metadata
-    // is not updated the caching behavior may not be optimal, but will obey the metadata sent
-    // with the original cached response.
-  }
-
-  @Override public void trackConditionalCacheHit() {
-    // This method is optional.
-  }
-
-  @Override public void trackResponse(CacheStrategy cacheStrategy) {
-    // This method is optional.
-  }
-
-  /**
-   * Returns the {@link CacheResponse} from the delegate by converting the OkHttp {@link Request}
-   * into the arguments required by the {@link ResponseCache}.
-   */
-  private CacheResponse getJavaCachedResponse(Request request) throws IOException {
-    Map<String, List<String>> headers = JavaApiConverter.extractJavaHeaders(request);
-    return delegate.get(request.url().uri(), request.method(), headers);
-  }
-}
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
deleted file mode 100644
index 51155785e6..0000000000
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
+++ /dev/null
@@ -1,892 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.SecureCacheResponse;
-import java.net.URI;
-import java.net.URLConnection;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.CipherSuite;
-import okhttp3.Handshake;
-import okhttp3.Headers;
-import okhttp3.MediaType;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.TlsVersion;
-import okhttp3.internal.Internal;
-import okhttp3.internal.JavaNetHeaders;
-import okhttp3.internal.Util;
-import okhttp3.internal.cache.CacheRequest;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.StatusLine;
-import okhttp3.internal.platform.Platform;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Sink;
-
-/**
- * Helper methods that convert between Java and OkHttp representations.
- */
-public final class JavaApiConverter {
-  /** Synthetic response header: the local time when the request was sent. */
-  private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
-
-  /** Synthetic response header: the local time when the response was received. */
-  private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
-
-  private JavaApiConverter() {
-  }
-
-  /**
-   * Creates an OkHttp {@link Response} using the supplied {@link URI} and {@link URLConnection} to
-   * supply the data. The URLConnection is assumed to already be connected. If this method returns
-   * {@code null} the response is uncacheable.
-   */
-  public static Response createOkResponseForCachePut(URI uri, URLConnection urlConnection)
-      throws IOException {
-
-    HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
-
-    Response.Builder okResponseBuilder = new Response.Builder();
-
-    // Request: Create one from the URL connection.
-    Headers responseHeaders = createHeaders(urlConnection.getHeaderFields());
-    // Some request headers are needed for Vary caching.
-    Headers varyHeaders = varyHeaders(urlConnection, responseHeaders);
-    if (varyHeaders == null) {
-      return null;
-    }
-
-    // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
-    String requestMethod = httpUrlConnection.getRequestMethod();
-    RequestBody placeholderBody = HttpMethod.requiresRequestBody(requestMethod)
-        ? Util.EMPTY_REQUEST
-        : null;
-
-    Request okRequest = new Request.Builder()
-        .url(uri.toString())
-        .method(requestMethod, placeholderBody)
-        .headers(varyHeaders)
-        .build();
-    okResponseBuilder.request(okRequest);
-
-    // Status line
-    StatusLine statusLine = StatusLine.parse(extractStatusLine(httpUrlConnection));
-    okResponseBuilder.protocol(statusLine.protocol);
-    okResponseBuilder.code(statusLine.code);
-    okResponseBuilder.message(statusLine.message);
-
-    // A network response is required for the Cache to find any Vary headers it needs.
-    Response networkResponse = okResponseBuilder.build();
-    okResponseBuilder.networkResponse(networkResponse);
-
-    // Response headers
-    Headers okHeaders = extractOkResponseHeaders(httpUrlConnection, okResponseBuilder);
-    okResponseBuilder.headers(okHeaders);
-
-    // Response body
-    ResponseBody okBody = createOkBody(urlConnection);
-    okResponseBuilder.body(okBody);
-
-    // Handle SSL handshake information as needed.
-    if (httpUrlConnection instanceof HttpsURLConnection) {
-      HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) httpUrlConnection;
-
-      Certificate[] peerCertificates;
-      try {
-        peerCertificates = httpsUrlConnection.getServerCertificates();
-      } catch (SSLPeerUnverifiedException e) {
-        peerCertificates = null;
-      }
-
-      Certificate[] localCertificates = httpsUrlConnection.getLocalCertificates();
-
-      String cipherSuiteString = httpsUrlConnection.getCipherSuite();
-      CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-      Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, cipherSuite,
-          nullSafeImmutableList(peerCertificates), nullSafeImmutableList(localCertificates));
-      okResponseBuilder.handshake(handshake);
-    }
-
-    return okResponseBuilder.build();
-  }
-
-  /**
-   * Returns headers for the header names and values in the {@link Map}.
-   */
-  private static Headers createHeaders(Map<String, List<String>> headers) {
-    Headers.Builder builder = new Headers.Builder();
-    for (Map.Entry<String, List<String>> header : headers.entrySet()) {
-      if (header.getKey() == null || header.getValue() == null) {
-        continue;
-      }
-      String name = header.getKey().trim();
-      for (String value : header.getValue()) {
-        String trimmedValue = value.trim();
-        Internal.instance.addLenient(builder, name, trimmedValue);
-      }
-    }
-    return builder.build();
-  }
-
-  private static Headers varyHeaders(URLConnection urlConnection, Headers responseHeaders) {
-    if (HttpHeaders.hasVaryAll(responseHeaders)) {
-      // "*" means that this will be treated as uncacheable anyway.
-      return null;
-    }
-    Set<String> varyFields = HttpHeaders.varyFields(responseHeaders);
-    if (varyFields.isEmpty()) {
-      return new Headers.Builder().build();
-    }
-
-    // This probably indicates another HTTP stack is trying to use the shared ResponseCache.
-    // We cannot guarantee this case will work properly because we cannot reliably extract *all*
-    // the request header values, and we can't get multiple Vary request header values.
-    // We also can't be sure about the Accept-Encoding behavior of other stacks.
-    if (!(urlConnection instanceof CacheHttpURLConnection
-        || urlConnection instanceof CacheHttpsURLConnection)) {
-      return null;
-    }
-
-    // This is the case we expect: The URLConnection is from a call to
-    // JavaApiConverter.createJavaUrlConnection() and we have access to the user's request headers.
-    Map<String, List<String>> requestProperties = urlConnection.getRequestProperties();
-    Headers.Builder result = new Headers.Builder();
-    for (String fieldName : varyFields) {
-      List<String> fieldValues = requestProperties.get(fieldName);
-      if (fieldValues == null) {
-        if (fieldName.equals("Accept-Encoding")) {
-          // Accept-Encoding is special. If OkHttp sees Accept-Encoding is unset it will add
-          // "gzip". We don't have access to the request that was actually made so we must do the
-          // same.
-          result.add("Accept-Encoding", "gzip");
-        }
-      } else {
-        for (String fieldValue : fieldValues) {
-          Internal.instance.addLenient(result, fieldName, fieldValue);
-        }
-      }
-    }
-    return result.build();
-  }
-
-  /**
-   * Creates an OkHttp {@link Response} using the supplied {@link Request} and {@link CacheResponse}
-   * to supply the data.
-   */
-  static Response createOkResponseForCacheGet(Request request, CacheResponse javaResponse)
-      throws IOException {
-
-    // Build a cache request for the response to use.
-    Headers responseHeaders = createHeaders(javaResponse.getHeaders());
-    Headers varyHeaders;
-    if (HttpHeaders.hasVaryAll(responseHeaders)) {
-      // "*" means that this will be treated as uncacheable anyway.
-      varyHeaders = new Headers.Builder().build();
-    } else {
-      varyHeaders = HttpHeaders.varyHeaders(request.headers(), responseHeaders);
-    }
-
-    Request cacheRequest = new Request.Builder()
-        .url(request.url())
-        .method(request.method(), null)
-        .headers(varyHeaders)
-        .build();
-
-    Response.Builder okResponseBuilder = new Response.Builder();
-
-    // Request: Use the cacheRequest we built.
-    okResponseBuilder.request(cacheRequest);
-
-    // Status line: Java has this as one of the headers.
-    StatusLine statusLine = StatusLine.parse(extractStatusLine(javaResponse));
-    okResponseBuilder.protocol(statusLine.protocol);
-    okResponseBuilder.code(statusLine.code);
-    okResponseBuilder.message(statusLine.message);
-
-    // Response headers
-    Headers okHeaders = extractOkHeaders(javaResponse, okResponseBuilder);
-    okResponseBuilder.headers(okHeaders);
-
-    // Response body
-    ResponseBody okBody = createOkBody(okHeaders, javaResponse);
-    okResponseBuilder.body(okBody);
-
-    // Handle SSL handshake information as needed.
-    if (javaResponse instanceof SecureCacheResponse) {
-      SecureCacheResponse javaSecureCacheResponse = (SecureCacheResponse) javaResponse;
-
-      // Handshake doesn't support null lists.
-      List<Certificate> peerCertificates;
-      try {
-        peerCertificates = javaSecureCacheResponse.getServerCertificateChain();
-      } catch (SSLPeerUnverifiedException e) {
-        peerCertificates = Collections.emptyList();
-      }
-      List<Certificate> localCertificates = javaSecureCacheResponse.getLocalCertificateChain();
-      if (localCertificates == null) {
-        localCertificates = Collections.emptyList();
-      }
-
-      String cipherSuiteString = javaSecureCacheResponse.getCipherSuite();
-      CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-      Handshake handshake = Handshake.get(
-          TlsVersion.SSL_3_0, cipherSuite, peerCertificates, localCertificates);
-      okResponseBuilder.handshake(handshake);
-    }
-
-    return okResponseBuilder.build();
-  }
-
-  /**
-   * Creates an OkHttp {@link Request} from the supplied information.
-   *
-   * <p>This method allows a {@code null} value for {@code requestHeaders} for situations where a
-   * connection is already connected and access to the headers has been lost. See {@link
-   * java.net.HttpURLConnection#getRequestProperties()} for details.
-   */
-  public static Request createOkRequest(
-      URI uri, String requestMethod, Map<String, List<String>> requestHeaders) {
-    // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
-    RequestBody placeholderBody = HttpMethod.requiresRequestBody(requestMethod)
-        ? Util.EMPTY_REQUEST
-        : null;
-
-    Request.Builder builder = new Request.Builder()
-        .url(uri.toString())
-        .method(requestMethod, placeholderBody);
-
-    if (requestHeaders != null) {
-      Headers headers = extractOkHeaders(requestHeaders, null);
-      builder.headers(headers);
-    }
-    return builder.build();
-  }
-
-  /**
-   * Creates a {@link java.net.CacheResponse} of the correct (sub)type using information gathered
-   * from the supplied {@link Response}.
-   */
-  public static CacheResponse createJavaCacheResponse(final Response response) {
-    final Headers headers = withSyntheticHeaders(response);
-    final ResponseBody body = response.body();
-    if (response.request().isHttps()) {
-      final Handshake handshake = response.handshake();
-      return new SecureCacheResponse() {
-        @Override
-        public String getCipherSuite() {
-          return handshake != null ? handshake.cipherSuite().javaName() : null;
-        }
-
-        @Override
-        public List<Certificate> getLocalCertificateChain() {
-          if (handshake == null) return null;
-          // Java requires null, not an empty list here.
-          List<Certificate> certificates = handshake.localCertificates();
-          return certificates.size() > 0 ? certificates : null;
-        }
-
-        @Override
-        public List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException {
-          if (handshake == null) return null;
-          // Java requires null, not an empty list here.
-          List<Certificate> certificates = handshake.peerCertificates();
-          return certificates.size() > 0 ? certificates : null;
-        }
-
-        @Override
-        public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-          if (handshake == null) return null;
-          return handshake.peerPrincipal();
-        }
-
-        @Override
-        public Principal getLocalPrincipal() {
-          if (handshake == null) return null;
-          return handshake.localPrincipal();
-        }
-
-        @Override
-        public Map<String, List<String>> getHeaders() throws IOException {
-          // Java requires that the entry with a null key be the status line.
-          return JavaNetHeaders.toMultimap(headers, StatusLine.get(response).toString());
-        }
-
-        @Override
-        public InputStream getBody() throws IOException {
-          if (body == null) return null;
-          return body.byteStream();
-        }
-      };
-    } else {
-      return new CacheResponse() {
-        @Override
-        public Map<String, List<String>> getHeaders() throws IOException {
-          // Java requires that the entry with a null key be the status line.
-          return JavaNetHeaders.toMultimap(headers, StatusLine.get(response).toString());
-        }
-
-        @Override
-        public InputStream getBody() throws IOException {
-          if (body == null) return null;
-          return body.byteStream();
-        }
-      };
-    }
-  }
-
-  public static java.net.CacheRequest createJavaCacheRequest(final CacheRequest okCacheRequest) {
-    return new java.net.CacheRequest() {
-      @Override
-      public void abort() {
-        okCacheRequest.abort();
-      }
-
-      @Override
-      public OutputStream getBody() throws IOException {
-        Sink body = okCacheRequest.body();
-        if (body == null) {
-          return null;
-        }
-        return Okio.buffer(body).outputStream();
-      }
-    };
-  }
-
-  /**
-   * Creates an {@link java.net.HttpURLConnection} of the correct subclass from the supplied OkHttp
-   * {@link Response}.
-   */
-  static HttpURLConnection createJavaUrlConnectionForCachePut(Response okResponse) {
-    okResponse = okResponse.newBuilder()
-        .body(null)
-        .headers(withSyntheticHeaders(okResponse))
-        .build();
-    Request request = okResponse.request();
-    // Create an object of the correct class in case the ResponseCache uses instanceof.
-    if (request.isHttps()) {
-      return new CacheHttpsURLConnection(new CacheHttpURLConnection(okResponse));
-    } else {
-      return new CacheHttpURLConnection(okResponse);
-    }
-  }
-
-  private static Headers withSyntheticHeaders(Response okResponse) {
-    return okResponse.headers().newBuilder()
-        .add(SENT_MILLIS, Long.toString(okResponse.sentRequestAtMillis()))
-        .add(RECEIVED_MILLIS, Long.toString(okResponse.receivedResponseAtMillis()))
-        .build();
-  }
-
-  /**
-   * Extracts an immutable request header map from the supplied {@link Headers}.
-   */
-  static Map<String, List<String>> extractJavaHeaders(Request request) {
-    return JavaNetHeaders.toMultimap(request.headers(), null);
-  }
-
-  /**
-   * Extracts OkHttp headers from the supplied {@link java.net.CacheResponse}. Only real headers are
-   * extracted. See {@link #extractStatusLine(java.net.CacheResponse)}.
-   */
-  private static Headers extractOkHeaders(
-      CacheResponse javaResponse, Response.Builder okResponseBuilder) throws IOException {
-    Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
-    return extractOkHeaders(javaResponseHeaders, okResponseBuilder);
-  }
-
-  /**
-   * Extracts OkHttp headers from the supplied {@link java.net.HttpURLConnection}. Only real headers
-   * are extracted. See {@link #extractStatusLine(java.net.HttpURLConnection)}.
-   */
-  private static Headers extractOkResponseHeaders(
-      HttpURLConnection httpUrlConnection, Response.Builder okResponseBuilder) {
-    Map<String, List<String>> javaResponseHeaders = httpUrlConnection.getHeaderFields();
-    return extractOkHeaders(javaResponseHeaders, okResponseBuilder);
-  }
-
-  /**
-   * Extracts OkHttp headers from the supplied {@link Map}. Only real headers are extracted. Any
-   * entry (one with a {@code null} key) is discarded. Special internal headers used to track cache
-   * metadata are omitted from the result and added to {@code okResponseBuilder} instead.
-   */
-  // @VisibleForTesting
-  static Headers extractOkHeaders(
-      Map<String, List<String>> javaHeaders, Response.Builder okResponseBuilder) {
-    Headers.Builder okHeadersBuilder = new Headers.Builder();
-    for (Map.Entry<String, List<String>> javaHeader : javaHeaders.entrySet()) {
-      String name = javaHeader.getKey();
-      if (name == null) {
-        // The Java API uses the null key to store the status line in responses.
-        // Earlier versions of OkHttp would use the null key to store the "request line" in
-        // requests. e.g. "GET / HTTP 1.1". Although this is no longer the case it must be
-        // explicitly ignored because Headers.Builder does not support null keys.
-        continue;
-      }
-      if (okResponseBuilder != null && javaHeader.getValue().size() == 1) {
-        if (name.equals(SENT_MILLIS)) {
-          okResponseBuilder.sentRequestAtMillis(Long.valueOf(javaHeader.getValue().get(0)));
-          continue;
-        }
-        if (name.equals(RECEIVED_MILLIS)) {
-          okResponseBuilder.receivedResponseAtMillis(Long.valueOf(javaHeader.getValue().get(0)));
-          continue;
-        }
-      }
-      for (String value : javaHeader.getValue()) {
-        Internal.instance.addLenient(okHeadersBuilder, name, value);
-      }
-    }
-    return okHeadersBuilder.build();
-  }
-
-  /**
-   * Extracts the status line from the supplied Java API {@link java.net.HttpURLConnection}. As per
-   * the spec, the status line is held as the header with the null key. Returns {@code null} if
-   * there is no status line.
-   */
-  private static String extractStatusLine(HttpURLConnection httpUrlConnection) {
-    // Java specifies that this will be be response header with a null key.
-    return httpUrlConnection.getHeaderField(null);
-  }
-
-  /**
-   * Extracts the status line from the supplied Java API {@link java.net.CacheResponse}. As per the
-   * spec, the status line is held as the header with the null key. Throws a {@link
-   * ProtocolException} if there is no status line.
-   */
-  private static String extractStatusLine(CacheResponse javaResponse) throws IOException {
-    Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
-    return extractStatusLine(javaResponseHeaders);
-  }
-
-  // VisibleForTesting
-  static String extractStatusLine(Map<String, List<String>> javaResponseHeaders)
-      throws ProtocolException {
-    List<String> values = javaResponseHeaders.get(null);
-    if (values == null || values.size() == 0) {
-      // The status line is missing. This suggests a badly behaving cache.
-      throw new ProtocolException(
-          "CacheResponse is missing a \'null\' header containing the status line. Headers="
-              + javaResponseHeaders);
-    }
-    return values.get(0);
-  }
-
-  /**
-   * Creates an OkHttp Response.Body containing the supplied information.
-   */
-  private static ResponseBody createOkBody(final Headers okHeaders,
-      final CacheResponse cacheResponse) throws IOException {
-    final BufferedSource body = Okio.buffer(Okio.source(cacheResponse.getBody()));
-    return new ResponseBody() {
-      @Override
-      public MediaType contentType() {
-        String contentTypeHeader = okHeaders.get("Content-Type");
-        return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);
-      }
-
-      @Override
-      public long contentLength() {
-        return HttpHeaders.contentLength(okHeaders);
-      }
-
-      @Override public BufferedSource source() {
-        return body;
-      }
-    };
-  }
-
-  /**
-   * Creates an OkHttp Response.Body containing the supplied information.
-   */
-  private static ResponseBody createOkBody(final URLConnection urlConnection) throws IOException {
-    if (!urlConnection.getDoInput()) {
-      return null;
-    }
-
-    final BufferedSource body = Okio.buffer(Okio.source(urlConnection.getInputStream()));
-    return new ResponseBody() {
-      @Override public MediaType contentType() {
-        String contentTypeHeader = urlConnection.getContentType();
-        return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);
-      }
-
-      @Override public long contentLength() {
-        String s = urlConnection.getHeaderField("Content-Length");
-        return stringToLong(s);
-      }
-
-      @Override public BufferedSource source() {
-        return body;
-      }
-    };
-  }
-
-  /**
-   * An {@link java.net.HttpURLConnection} that represents an HTTP request at the point where the
-   * request has been made, and the response headers have been received, but the body content, if
-   * present, has not been read yet. This intended to provide enough information for {@link
-   * java.net.ResponseCache} subclasses and no more.
-   *
-   * <p>Much of the method implementations are overrides to delegate to the OkHttp request and
-   * response, or to deny access to information as a real HttpURLConnection would after connection.
-   */
-  private static final class CacheHttpURLConnection extends HttpURLConnection {
-
-    private final Request request;
-    private final Response response;
-
-    CacheHttpURLConnection(Response response) {
-      super(response.request().url().url());
-      this.request = response.request();
-      this.response = response;
-
-      // Configure URLConnection inherited fields.
-      this.connected = true;
-      this.doOutput = request.body() != null;
-      this.doInput = true;
-      this.useCaches = true;
-
-      // Configure HttpUrlConnection inherited fields.
-      this.method = request.method();
-    }
-
-    // HTTP connection lifecycle methods
-
-    @Override
-    public void connect() throws IOException {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public void disconnect() {
-      throw throwRequestModificationException();
-    }
-
-    // HTTP Request methods
-
-    @Override
-    public void setRequestProperty(String key, String value) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public void addRequestProperty(String key, String value) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public String getRequestProperty(String key) {
-      return request.header(key);
-    }
-
-    @Override
-    public Map<String, List<String>> getRequestProperties() {
-      // The RI and OkHttp's HttpURLConnectionImpl fail this call after connect() as required by the
-      // spec. There seems no good reason why this should fail while getRequestProperty() is ok.
-      // We don't fail here, because we need all request header values for caching Vary responses
-      // correctly.
-      return JavaNetHeaders.toMultimap(request.headers(), null);
-    }
-
-    @Override
-    public void setFixedLengthStreamingMode(int contentLength) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public void setFixedLengthStreamingMode(long contentLength) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public void setChunkedStreamingMode(int chunklen) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public void setInstanceFollowRedirects(boolean followRedirects) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public boolean getInstanceFollowRedirects() {
-      // Return the platform default.
-      return super.getInstanceFollowRedirects();
-    }
-
-    @Override
-    public void setRequestMethod(String method) throws ProtocolException {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public String getRequestMethod() {
-      return request.method();
-    }
-
-    // HTTP Response methods
-
-    @Override
-    public String getHeaderFieldKey(int position) {
-      // Deal with index 0 meaning "status line"
-      if (position < 0) {
-        throw new IllegalArgumentException("Invalid header index: " + position);
-      }
-      if (position == 0 || position > response.headers().size()) {
-        return null;
-      }
-      return response.headers().name(position - 1);
-    }
-
-    @Override
-    public String getHeaderField(int position) {
-      // Deal with index 0 meaning "status line"
-      if (position < 0) {
-        throw new IllegalArgumentException("Invalid header index: " + position);
-      }
-      if (position == 0) {
-        return StatusLine.get(response).toString();
-      }
-      if (position > response.headers().size()) {
-        return null;
-      }
-      return response.headers().value(position - 1);
-    }
-
-    @Override
-    public String getHeaderField(String fieldName) {
-      return fieldName == null
-          ? StatusLine.get(response).toString()
-          : response.headers().get(fieldName);
-    }
-
-    @Override
-    public Map<String, List<String>> getHeaderFields() {
-      return JavaNetHeaders.toMultimap(response.headers(), StatusLine.get(response).toString());
-    }
-
-    @Override
-    public int getResponseCode() throws IOException {
-      return response.code();
-    }
-
-    @Override
-    public String getResponseMessage() throws IOException {
-      return response.message();
-    }
-
-    @Override
-    public InputStream getErrorStream() {
-      return null;
-    }
-
-    // HTTP miscellaneous methods
-
-    @Override
-    public boolean usingProxy() {
-      // It's safe to return false here, even if a proxy is in use. The problem is we don't
-      // necessarily know if we're going to use a proxy by the time we ask the cache for a response.
-      return false;
-    }
-
-    // URLConnection methods
-
-    @Override
-    public void setConnectTimeout(int timeout) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public int getConnectTimeout() {
-      // Impossible to say.
-      return 0;
-    }
-
-    @Override
-    public void setReadTimeout(int timeout) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public int getReadTimeout() {
-      // Impossible to say.
-      return 0;
-    }
-
-    @Override
-    public Object getContent() throws IOException {
-      throw throwResponseBodyAccessException();
-    }
-
-    @Override
-    public Object getContent(Class[] classes) throws IOException {
-      throw throwResponseBodyAccessException();
-    }
-
-    @Override
-    public InputStream getInputStream() throws IOException {
-      return new InputStream() {
-        @Override public int read() throws IOException {
-          throw throwResponseBodyAccessException();
-        }
-      };
-    }
-
-    @Override
-    public OutputStream getOutputStream() throws IOException {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public void setDoInput(boolean doInput) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public boolean getDoInput() {
-      return doInput;
-    }
-
-    @Override
-    public void setDoOutput(boolean doOutput) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public boolean getDoOutput() {
-      return doOutput;
-    }
-
-    @Override
-    public void setAllowUserInteraction(boolean allowUserInteraction) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public boolean getAllowUserInteraction() {
-      return false;
-    }
-
-    @Override
-    public void setUseCaches(boolean useCaches) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public boolean getUseCaches() {
-      return super.getUseCaches();
-    }
-
-    @Override
-    public void setIfModifiedSince(long ifModifiedSince) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public long getIfModifiedSince() {
-      return stringToLong(request.headers().get("If-Modified-Since"));
-    }
-
-    @Override
-    public boolean getDefaultUseCaches() {
-      return super.getDefaultUseCaches();
-    }
-
-    @Override
-    public void setDefaultUseCaches(boolean defaultUseCaches) {
-      super.setDefaultUseCaches(defaultUseCaches);
-    }
-  }
-
-  /** An HttpsURLConnection to offer to the cache. */
-  private static final class CacheHttpsURLConnection extends DelegatingHttpsURLConnection {
-    private final CacheHttpURLConnection delegate;
-
-    CacheHttpsURLConnection(CacheHttpURLConnection delegate) {
-      super(delegate);
-      this.delegate = delegate;
-    }
-
-    @Override protected Handshake handshake() {
-      return delegate.response.handshake();
-    }
-
-    @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
-      throw throwRequestModificationException();
-    }
-
-    @Override public HostnameVerifier getHostnameVerifier() {
-      throw throwRequestSslAccessException();
-    }
-
-    @Override public void setSSLSocketFactory(SSLSocketFactory socketFactory) {
-      throw throwRequestModificationException();
-    }
-
-    @Override public SSLSocketFactory getSSLSocketFactory() {
-      throw throwRequestSslAccessException();
-    }
-  }
-
-  private static RuntimeException throwRequestModificationException() {
-    throw new UnsupportedOperationException("ResponseCache cannot modify the request.");
-  }
-
-  private static RuntimeException throwRequestHeaderAccessException() {
-    throw new UnsupportedOperationException("ResponseCache cannot access request headers");
-  }
-
-  private static RuntimeException throwRequestSslAccessException() {
-    throw new UnsupportedOperationException("ResponseCache cannot access SSL internals");
-  }
-
-  private static RuntimeException throwResponseBodyAccessException() {
-    throw new UnsupportedOperationException("ResponseCache cannot access the response body.");
-  }
-
-  private static <T> List<T> nullSafeImmutableList(T[] elements) {
-    return elements == null ? Collections.emptyList() : Util.immutableList(elements);
-  }
-
-  private static long stringToLong(String s) {
-    if (s == null) return -1;
-    try {
-      return Long.parseLong(s);
-    } catch (NumberFormatException e) {
-      return -1;
-    }
-  }
-}
diff --git a/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java b/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java
deleted file mode 100644
index e5ce90dd34..0000000000
--- a/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-import javax.annotation.Nullable;
-
-public class AbstractResponseCache extends ResponseCache {
-  @Override public @Nullable CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) throws IOException {
-    return null;
-  }
-
-  @Override public @Nullable CacheRequest put(
-      URI uri, URLConnection connection) throws IOException {
-    return null;
-  }
-
-  public static URI toUri(URL serverUrl) {
-    try {
-      return serverUrl.toURI();
-    } catch (URISyntaxException e) {
-      throw new AssertionError(e);
-    }
-  }
-}
diff --git a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
deleted file mode 100644
index c569a3b365..0000000000
--- a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.android;
-
-import java.io.Closeable;
-import java.io.File;
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-import okhttp3.AndroidShimResponseCache;
-import okhttp3.Cache;
-import okhttp3.OkCacheContainer;
-
-/**
- * A copy of android.net.http.HttpResponseCache taken from AOSP. Android need to keep this code
- * working somehow. Dependencies on okhttp3 are com.android.okhttp on Android.
- *
- * <p>This class exists in okhttp-android-support to help keep the API as it always has been on
- * Android. The public API cannot be changed. This class delegates to {@link
- * AndroidShimResponseCache}, a class that exists in a package that enables it to interact with
- * non-public OkHttp classes.
- */
-public final class HttpResponseCache extends ResponseCache implements Closeable, OkCacheContainer {
-
-  private AndroidShimResponseCache shimResponseCache;
-
-  private HttpResponseCache(AndroidShimResponseCache shimResponseCache) {
-    this.shimResponseCache = shimResponseCache;
-  }
-
-  /**
-   * Returns the currently-installed {@code HttpResponseCache}, or null if there is no cache
-   * installed or it is not a {@code HttpResponseCache}.
-   */
-  public static HttpResponseCache getInstalled() {
-    ResponseCache installed = ResponseCache.getDefault();
-    if (installed instanceof HttpResponseCache) {
-      return (HttpResponseCache) installed;
-    }
-    return null;
-  }
-
-  /**
-   * Creates a new HTTP response cache and sets it as the system default cache.
-   *
-   * @param directory the directory to hold cache data.
-   * @param maxSize the maximum size of the cache in bytes.
-   * @return the newly-installed cache
-   * @throws java.io.IOException if {@code directory} cannot be used for this cache. Most
-   * applications should respond to this exception by logging a warning.
-   */
-  public static synchronized HttpResponseCache install(File directory, long maxSize) throws
-      IOException {
-    ResponseCache installed = ResponseCache.getDefault();
-
-    if (installed instanceof HttpResponseCache) {
-      HttpResponseCache installedResponseCache = (HttpResponseCache) installed;
-      // don't close and reopen if an equivalent cache is already installed
-      AndroidShimResponseCache trueResponseCache = installedResponseCache.shimResponseCache;
-      if (trueResponseCache.isEquivalent(directory, maxSize)) {
-        return installedResponseCache;
-      } else {
-        // The HttpResponseCache that owns this object is about to be replaced.
-        trueResponseCache.close();
-      }
-    }
-
-    AndroidShimResponseCache trueResponseCache =
-        AndroidShimResponseCache.create(directory, maxSize);
-    HttpResponseCache newResponseCache = new HttpResponseCache(trueResponseCache);
-    ResponseCache.setDefault(newResponseCache);
-    return newResponseCache;
-  }
-
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) throws IOException {
-    return shimResponseCache.get(uri, requestMethod, requestHeaders);
-  }
-
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    return shimResponseCache.put(uri, urlConnection);
-  }
-
-  /**
-   * Returns the number of bytes currently being used to store the values in this cache. This may be
-   * greater than the {@link #maxSize} if a background deletion is pending.
-   */
-  public long size() {
-    try {
-      return shimResponseCache.size();
-    } catch (IOException e) {
-      // This can occur if the cache failed to lazily initialize. Return -1 to mean "unknown".
-      return -1;
-    }
-  }
-
-  /**
-   * Returns the maximum number of bytes that this cache should use to store its data.
-   */
-  public long maxSize() {
-    return shimResponseCache.maxSize();
-  }
-
-  /**
-   * Force buffered operations to the filesystem. This ensures that responses written to the cache
-   * will be available the next time the cache is opened, even if this process is killed.
-   */
-  public void flush() {
-    try {
-      shimResponseCache.flush();
-    } catch (IOException ignored) {
-    }
-  }
-
-  /**
-   * Returns the number of HTTP requests that required the network to either supply a response or
-   * validate a locally cached response.
-   */
-  public int getNetworkCount() {
-    return shimResponseCache.getNetworkCount();
-  }
-
-  /**
-   * Returns the number of HTTP requests whose response was provided by the cache. This may include
-   * conditional {@code GET} requests that were validated over the network.
-   */
-  public int getHitCount() {
-    return shimResponseCache.getHitCount();
-  }
-
-  /**
-   * Returns the total number of HTTP requests that were made. This includes both client requests
-   * and requests that were made on the client's behalf to handle a redirects and retries.
-   */
-  public int getRequestCount() {
-    return shimResponseCache.getRequestCount();
-  }
-
-  /**
-   * Uninstalls the cache and releases any active resources. Stored contents will remain on the
-   * filesystem.
-   */
-  @Override public void close() throws IOException {
-    if (ResponseCache.getDefault() == this) {
-      ResponseCache.setDefault(null);
-    }
-    shimResponseCache.close();
-  }
-
-  /**
-   * Uninstalls the cache and deletes all of its stored contents.
-   */
-  public void delete() throws IOException {
-    if (ResponseCache.getDefault() == this) {
-      ResponseCache.setDefault(null);
-    }
-    shimResponseCache.delete();
-  }
-
-  @Override
-  public Cache getCache() {
-    return shimResponseCache.getCache();
-  }
-}
diff --git a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
deleted file mode 100644
index dcb1c01815..0000000000
--- a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.android;
-
-import java.io.File;
-import java.io.InputStream;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-import okhttp3.AndroidInternal;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.fail;
-
-/**
- * A port of Android's android.net.http.HttpResponseCacheTest to JUnit4.
- */
-public final class HttpResponseCacheTest {
-  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
-  @Rule public MockWebServer server = new MockWebServer();
-
-  private File cacheDir;
-  private OkUrlFactory urlFactory;
-
-  @Before public void setUp() throws Exception {
-    cacheDir = cacheRule.getRoot();
-    urlFactory = new OkUrlFactory(new OkHttpClient());
-  }
-
-  @After public void tearDown() throws Exception {
-    ResponseCache.setDefault(null);
-  }
-
-  @Test public void install() throws Exception {
-    HttpResponseCache installed = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    assertNotNull(installed);
-    assertSame(installed, ResponseCache.getDefault());
-    assertSame(installed, HttpResponseCache.getDefault());
-  }
-
-  @Test public void secondEquivalentInstallDoesNothing() throws Exception {
-    HttpResponseCache first = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    HttpResponseCache another = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    assertSame(first, another);
-  }
-
-  @Test public void installClosesPreviouslyInstalled() throws Exception {
-    HttpResponseCache first = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    initializeCache(first);
-
-    HttpResponseCache another = HttpResponseCache.install(cacheDir, 8 * 1024 * 1024);
-    initializeCache(another);
-
-    assertNotSame(first, another);
-    try {
-      first.flush();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void getInstalledWithWrongTypeInstalled() {
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override
-      public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) {
-        return null;
-      }
-
-      @Override
-      public CacheRequest put(URI uri, URLConnection connection) {
-        return null;
-      }
-    });
-    assertNull(HttpResponseCache.getInstalled());
-  }
-
-  @Test public void closeCloses() throws Exception {
-    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    initializeCache(cache);
-
-    cache.close();
-    try {
-      cache.flush();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void closeUninstalls() throws Exception {
-    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    cache.close();
-    assertNull(ResponseCache.getDefault());
-  }
-
-  @Test public void deleteUninstalls() throws Exception {
-    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    cache.delete();
-    assertNull(ResponseCache.getDefault());
-  }
-
-  /**
-   * Make sure that statistics tracking are wired all the way through the wrapper class.
-   * http://code.google.com/p/android/issues/detail?id=25418
-   */
-  @Test public void statisticsTracking() throws Exception {
-    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-
-    URLConnection c1 = openUrl(server.url("/"));
-
-    InputStream inputStream = c1.getInputStream();
-    assertEquals('A', inputStream.read());
-    inputStream.close();
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-
-    URLConnection c2 = openUrl(server.url("/"));
-    assertEquals('A', c2.getInputStream().read());
-
-    URLConnection c3 = openUrl(server.url("/"));
-    assertEquals('A', c3.getInputStream().read());
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
-  }
-
-  // This mimics the Android HttpHandler, which is found in the okhttp3 package.
-  private URLConnection openUrl(HttpUrl url) {
-    ResponseCache responseCache = ResponseCache.getDefault();
-    AndroidInternal.setResponseCache(urlFactory, responseCache);
-    return urlFactory.open(url.url());
-  }
-
-  private void initializeCache(HttpResponseCache cache) {
-    // Ensure the cache is initialized, otherwise various methods are no-ops.
-    cache.size();
-  }
-}
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
deleted file mode 100644
index c1b4a6f4d2..0000000000
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
+++ /dev/null
@@ -1,298 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URL;
-import java.net.URLConnection;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import okhttp3.AbstractResponseCache;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.internal.Internal;
-import okhttp3.internal.cache.InternalCache;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-/**
- * A white-box test for {@link CacheAdapter}. See also:
- * <ul>
- *     <li>{@link ResponseCacheTest} for black-box tests that check that {@link ResponseCache}
- *         classes are called correctly by OkHttp.
- *     <li>{@link JavaApiConverterTest} for tests that check Java API classes / OkHttp conversion
- *         logic.
- * </ul>
- */
-public class CacheAdapterTest {
-  private HandshakeCertificates handshakeCertificates = localhost();
-  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  private MockWebServer server;
-  private OkHttpClient client;
-  private HttpURLConnection connection;
-
-  @Before public void setUp() throws Exception {
-    server = new MockWebServer();
-    client = new OkHttpClient();
-  }
-
-  @After public void tearDown() throws Exception {
-    if (connection != null) {
-      connection.disconnect();
-    }
-    server.shutdown();
-  }
-
-  @Test public void get_httpGet() throws Exception {
-    final URL serverUrl = configureServer(new MockResponse());
-    assertEquals("http", serverUrl.getProtocol());
-
-    ResponseCache responseCache = new AbstractResponseCache() {
-      @Override public CacheResponse get(
-          URI uri, String method, Map<String, List<String>> headers) throws IOException {
-        try {
-          assertEquals(toUri(serverUrl), uri);
-          assertEquals("GET", method);
-          assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
-          assertEquals(Collections.singletonList("value1"), headers.get("key1"));
-          return null;
-        } catch (Throwable t) {
-          throw new IOException("unexpected cache failure", t);
-        }
-      }
-    };
-    setInternalCache(new CacheAdapter(responseCache));
-
-    connection = new OkUrlFactory(client).open(serverUrl);
-    connection.setRequestProperty("key1", "value1");
-
-    executeGet(connection);
-  }
-
-  @Test public void get_httpsGet() throws Exception {
-    final URL serverUrl = configureHttpsServer(new MockResponse());
-    assertEquals("https", serverUrl.getProtocol());
-
-    ResponseCache responseCache = new AbstractResponseCache() {
-      @Override public CacheResponse get(URI uri, String method, Map<String, List<String>> headers)
-          throws IOException {
-        try {
-          assertEquals("https", uri.getScheme());
-          assertEquals(toUri(serverUrl), uri);
-          assertEquals("GET", method);
-          assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
-          assertEquals(Collections.singletonList("value1"), headers.get("key1"));
-          return null;
-        } catch (Throwable t) {
-          throw new IOException("unexpected cache failure", t);
-        }
-      }
-    };
-    setInternalCache(new CacheAdapter(responseCache));
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-
-    connection = new OkUrlFactory(client).open(serverUrl);
-    connection.setRequestProperty("key1", "value1");
-
-    executeGet(connection);
-  }
-
-  @Test public void put_httpGet() throws Exception {
-    final String statusLine = "HTTP/1.1 200 Fantastic";
-    final byte[] response = "ResponseString".getBytes(UTF_8);
-    final URL serverUrl = configureServer(
-        new MockResponse()
-            .setStatus(statusLine)
-            .addHeader("A", "c")
-            .setBody(new Buffer().write(response)));
-
-    ResponseCache responseCache = new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        try {
-          assertTrue(connection instanceof HttpURLConnection);
-          assertFalse(connection instanceof HttpsURLConnection);
-
-          assertEquals(response.length, connection.getContentLength());
-
-          HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
-          assertEquals("GET", httpUrlConnection.getRequestMethod());
-          assertTrue(httpUrlConnection.getDoInput());
-          assertFalse(httpUrlConnection.getDoOutput());
-
-          assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
-          assertEquals(toUri(serverUrl), uri);
-          assertEquals(serverUrl, connection.getURL());
-          assertEquals("value", connection.getRequestProperty("key"));
-
-          // Check retrieval by string key.
-          assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
-          assertEquals("c", httpUrlConnection.getHeaderField("A"));
-          // The RI and OkHttp supports case-insensitive matching for this method.
-          assertEquals("c", httpUrlConnection.getHeaderField("a"));
-          return null;
-        } catch (Throwable t) {
-          throw new IOException("unexpected cache failure", t);
-        }
-      }
-    };
-    setInternalCache(new CacheAdapter(responseCache));
-
-    connection = new OkUrlFactory(client).open(serverUrl);
-    connection.setRequestProperty("key", "value");
-    executeGet(connection);
-  }
-
-  @Test public void put_httpPost() throws Exception {
-    final String statusLine = "HTTP/1.1 200 Fantastic";
-    final URL serverUrl = configureServer(
-        new MockResponse()
-            .setStatus(statusLine)
-            .addHeader("A", "c"));
-
-    ResponseCache responseCache = new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        try {
-          assertTrue(connection instanceof HttpURLConnection);
-          assertFalse(connection instanceof HttpsURLConnection);
-
-          assertEquals(0, connection.getContentLength());
-
-          HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
-          assertEquals("POST", httpUrlConnection.getRequestMethod());
-          assertTrue(httpUrlConnection.getDoInput());
-          assertTrue(httpUrlConnection.getDoOutput());
-
-          assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
-          assertEquals(toUri(serverUrl), uri);
-          assertEquals(serverUrl, connection.getURL());
-          assertEquals("value", connection.getRequestProperty("key"));
-
-          // Check retrieval by string key.
-          assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
-          assertEquals("c", httpUrlConnection.getHeaderField("A"));
-          // The RI and OkHttp supports case-insensitive matching for this method.
-          assertEquals("c", httpUrlConnection.getHeaderField("a"));
-          return null;
-        } catch (Throwable t) {
-          throw new IOException("unexpected cache failure", t);
-        }
-      }
-    };
-    setInternalCache(new CacheAdapter(responseCache));
-
-    connection = new OkUrlFactory(client).open(serverUrl);
-
-    executePost(connection);
-  }
-
-  @Test public void put_httpsGet() throws Exception {
-    final URL serverUrl = configureHttpsServer(new MockResponse());
-    assertEquals("https", serverUrl.getProtocol());
-
-    ResponseCache responseCache = new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        try {
-          assertTrue(connection instanceof HttpsURLConnection);
-          assertEquals(toUri(serverUrl), uri);
-          assertEquals(serverUrl, connection.getURL());
-
-          HttpsURLConnection cacheHttpsUrlConnection = (HttpsURLConnection) connection;
-          HttpsURLConnection realHttpsUrlConnection =
-              (HttpsURLConnection) CacheAdapterTest.this.connection;
-          assertEquals(realHttpsUrlConnection.getCipherSuite(),
-              cacheHttpsUrlConnection.getCipherSuite());
-          assertEquals(realHttpsUrlConnection.getPeerPrincipal(),
-              cacheHttpsUrlConnection.getPeerPrincipal());
-          assertArrayEquals(realHttpsUrlConnection.getLocalCertificates(),
-              cacheHttpsUrlConnection.getLocalCertificates());
-          assertArrayEquals(realHttpsUrlConnection.getServerCertificates(),
-              cacheHttpsUrlConnection.getServerCertificates());
-          assertEquals(realHttpsUrlConnection.getLocalPrincipal(),
-              cacheHttpsUrlConnection.getLocalPrincipal());
-          return null;
-        } catch (Throwable t) {
-          throw new IOException("unexpected cache failure", t);
-        }
-      }
-    };
-    setInternalCache(new CacheAdapter(responseCache));
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-
-    connection = new OkUrlFactory(client).open(serverUrl);
-    executeGet(connection);
-  }
-
-  private void executeGet(HttpURLConnection connection) throws IOException {
-    connection.connect();
-    connection.getHeaderFields();
-    connection.disconnect();
-  }
-
-  private void executePost(HttpURLConnection connection) throws IOException {
-    connection.setDoOutput(true);
-    connection.connect();
-    connection.getOutputStream().write("Hello World".getBytes());
-    connection.disconnect();
-  }
-
-  private URL configureServer(MockResponse mockResponse) throws Exception {
-    server.enqueue(mockResponse);
-    server.start();
-    return server.url("/").url();
-  }
-
-  private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false /* tunnelProxy */);
-    server.enqueue(mockResponse);
-    server.start();
-    return server.url("/").url();
-  }
-
-  private void setInternalCache(InternalCache internalCache) {
-    OkHttpClient.Builder builder = client.newBuilder();
-    Internal.instance.setCache(builder, internalCache);
-    client = builder.build();
-  }
-}
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
deleted file mode 100644
index 8acbe31519..0000000000
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
+++ /dev/null
@@ -1,692 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.SecureCacheResponse;
-import java.net.URI;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.security.cert.CertificateException;
-import java.security.cert.CertificateFactory;
-import java.security.cert.X509Certificate;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import okhttp3.CipherSuite;
-import okhttp3.Handshake;
-import okhttp3.Headers;
-import okhttp3.MediaType;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.TlsVersion;
-import okhttp3.internal.Internal;
-import okhttp3.mockwebserver.MockWebServer;
-import okio.Buffer;
-import okio.BufferedSource;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public class JavaApiConverterTest {
-
-  // $ openssl req -x509 -nodes -days 36500 -subj '/CN=localhost' -config ./cert.cnf \
-  //     -newkey rsa:512 -out cert.pem
-  private static final X509Certificate LOCAL_CERT = certificate(""
-      + "-----BEGIN CERTIFICATE-----\n"
-      + "MIIBWDCCAQKgAwIBAgIJANS1EtICX2AZMA0GCSqGSIb3DQEBBQUAMBQxEjAQBgNV\n"
-      + "BAMTCWxvY2FsaG9zdDAgFw0xMjAxMDIxOTA4NThaGA8yMTExMTIwOTE5MDg1OFow\n"
-      + "FDESMBAGA1UEAxMJbG9jYWxob3N0MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAPpt\n"
-      + "atK8r4/hf4hSIs0os/BSlQLbRBaK9AfBReM4QdAklcQqe6CHsStKfI8pp0zs7Ptg\n"
-      + "PmMdpbttL0O7mUboBC8CAwEAAaM1MDMwMQYDVR0RBCowKIIVbG9jYWxob3N0Lmxv\n"
-      + "Y2FsZG9tYWlugglsb2NhbGhvc3SHBH8AAAEwDQYJKoZIhvcNAQEFBQADQQD0ntfL\n"
-      + "DCzOCv9Ma6Lv5o5jcYWVxvBSTsnt22hsJpWD1K7iY9lbkLwl0ivn73pG2evsAn9G\n"
-      + "X8YKH52fnHsCrhSD\n"
-      + "-----END CERTIFICATE-----");
-
-  // openssl req -x509 -nodes -days 36500 -subj '/CN=*.0.0.1' -newkey rsa:512 -out cert.pem
-  private static final X509Certificate SERVER_CERT = certificate(""
-      + "-----BEGIN CERTIFICATE-----\n"
-      + "MIIBkjCCATygAwIBAgIJAMdemqOwd/BEMA0GCSqGSIb3DQEBBQUAMBIxEDAOBgNV\n"
-      + "BAMUByouMC4wLjEwIBcNMTAxMjIwMTY0NDI1WhgPMjExMDExMjYxNjQ0MjVaMBIx\n"
-      + "EDAOBgNVBAMUByouMC4wLjEwXDANBgkqhkiG9w0BAQEFAANLADBIAkEAqY8c9Qrt\n"
-      + "YPWCvb7lclI+aDHM6fgbJcHsS9Zg8nUOh5dWrS7AgeA25wyaokFl4plBbbHQe2j+\n"
-      + "cCjsRiJIcQo9HwIDAQABo3MwcTAdBgNVHQ4EFgQUJ436TZPJvwCBKklZZqIvt1Yt\n"
-      + "JjEwQgYDVR0jBDswOYAUJ436TZPJvwCBKklZZqIvt1YtJjGhFqQUMBIxEDAOBgNV\n"
-      + "BAMUByouMC4wLjGCCQDHXpqjsHfwRDAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEB\n"
-      + "BQUAA0EAk9i88xdjWoewqvE+iMC9tD2obMchgFDaHH0ogxxiRaIKeEly3g0uGxIt\n"
-      + "fl2WRY8hb4x+zRrwsFaLEpdEvqcjOQ==\n"
-      + "-----END CERTIFICATE-----");
-
-  @Rule public MockWebServer server = new MockWebServer();
-
-  @Before public void setUp() throws Exception {
-    Internal.initializeInstanceForTests();
-  }
-
-  @Test public void createOkResponseForCacheGet() throws Exception {
-    final String statusLine = "HTTP/1.1 200 Fantastic";
-    URI uri = new URI("http://foo/bar");
-    Request request = new Request.Builder().url(uri.toURL()).build();
-    CacheResponse cacheResponse = new CacheResponse() {
-      @Override public Map<String, List<String>> getHeaders() throws IOException {
-        Map<String, List<String>> headers = new LinkedHashMap<>();
-        headers.put(null, Collections.singletonList(statusLine));
-        headers.put("xyzzy", Arrays.asList("bar", "baz"));
-        return headers;
-      }
-
-      @Override public InputStream getBody() throws IOException {
-        return new ByteArrayInputStream("HelloWorld".getBytes(UTF_8));
-      }
-    };
-
-    Response response = JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
-    Request cacheRequest = response.request();
-    assertEquals(request.url(), cacheRequest.url());
-    assertEquals(request.method(), cacheRequest.method());
-    assertEquals(0, request.headers().size());
-
-    assertEquals(Protocol.HTTP_1_1, response.protocol());
-    assertEquals(200, response.code());
-    assertEquals("Fantastic", response.message());
-    Headers okResponseHeaders = response.headers();
-    assertEquals("baz", okResponseHeaders.get("xyzzy"));
-    assertEquals("HelloWorld", response.body().string());
-    assertNull(response.handshake());
-  }
-
-  /** Test for https://code.google.com/p/android/issues/detail?id=160522 */
-  @Test public void createOkResponseForCacheGet_withMissingStatusLine() throws Exception {
-    URI uri = new URI("http://foo/bar");
-    Request request = new Request.Builder().url(uri.toURL()).build();
-    CacheResponse cacheResponse = new CacheResponse() {
-      @Override public Map<String, List<String>> getHeaders() throws IOException {
-        Map<String, List<String>> headers = new LinkedHashMap<>();
-        // Headers is deliberately missing an entry with a null key.
-        headers.put("xyzzy", Arrays.asList("bar", "baz"));
-        return headers;
-      }
-
-      @Override public InputStream getBody() throws IOException {
-        return null; // Should never be called
-      }
-    };
-
-    try {
-      JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void createOkResponseForCacheGet_secure() throws Exception {
-    final String statusLine = "HTTP/1.1 200 Fantastic";
-    final Principal localPrincipal = LOCAL_CERT.getSubjectX500Principal();
-    final List<Certificate> localCertificates = Arrays.asList(LOCAL_CERT);
-    final Principal serverPrincipal = SERVER_CERT.getSubjectX500Principal();
-    final List<Certificate> serverCertificates = Arrays.asList(SERVER_CERT);
-    URI uri = new URI("https://foo/bar");
-    Request request = new Request.Builder().url(uri.toURL()).build();
-    SecureCacheResponse cacheResponse = new SecureCacheResponse() {
-      @Override public Map<String, List<String>> getHeaders() throws IOException {
-        Map<String, List<String>> headers = new LinkedHashMap<>();
-        headers.put(null, Collections.singletonList(statusLine));
-        headers.put("xyzzy", Arrays.asList("bar", "baz"));
-        return headers;
-      }
-
-      @Override public InputStream getBody() throws IOException {
-        return new ByteArrayInputStream("HelloWorld".getBytes(UTF_8));
-      }
-
-      @Override public String getCipherSuite() {
-        return "SSL_RSA_WITH_NULL_MD5";
-      }
-
-      @Override public List<Certificate> getLocalCertificateChain() {
-        return localCertificates;
-      }
-
-      @Override public List<Certificate> getServerCertificateChain()
-          throws SSLPeerUnverifiedException {
-        return serverCertificates;
-      }
-
-      @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-        return serverPrincipal;
-      }
-
-      @Override public Principal getLocalPrincipal() {
-        return localPrincipal;
-      }
-    };
-
-    Response response = JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
-    Request cacheRequest = response.request();
-    assertEquals(request.url(), cacheRequest.url());
-    assertEquals(request.method(), cacheRequest.method());
-    assertEquals(0, request.headers().size());
-
-    assertEquals(Protocol.HTTP_1_1, response.protocol());
-    assertEquals(200, response.code());
-    assertEquals("Fantastic", response.message());
-    Headers okResponseHeaders = response.headers();
-    assertEquals("baz", okResponseHeaders.get("xyzzy"));
-    assertEquals("HelloWorld", response.body().string());
-
-    Handshake handshake = response.handshake();
-    assertNotNull(handshake);
-    assertNotNullAndEquals(CipherSuite.TLS_RSA_WITH_NULL_MD5, handshake.cipherSuite());
-    assertEquals(localPrincipal, handshake.localPrincipal());
-    assertEquals(serverPrincipal, handshake.peerPrincipal());
-    assertEquals(serverCertificates, handshake.peerCertificates());
-    assertEquals(localCertificates, handshake.localCertificates());
-  }
-
-  @Test public void createOkRequest_nullRequestHeaders() throws Exception {
-    URI uri = new URI("http://foo/bar");
-
-    Map<String, List<String>> javaRequestHeaders = null;
-    Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
-    assertFalse(request.isHttps());
-    assertEquals(uri, request.url().uri());
-    Headers okRequestHeaders = request.headers();
-    assertEquals(0, okRequestHeaders.size());
-    assertEquals("POST", request.method());
-  }
-
-  @Test public void createOkRequest_nonNullRequestHeaders() throws Exception {
-    URI uri = new URI("https://foo/bar");
-
-    Map<String, List<String>> javaRequestHeaders = new LinkedHashMap<>();
-    javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
-    Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
-    assertTrue(request.isHttps());
-    assertEquals(uri, request.url().uri());
-    Headers okRequestHeaders = request.headers();
-    assertEquals(1, okRequestHeaders.size());
-    assertEquals("Bar", okRequestHeaders.get("Foo"));
-    assertEquals("POST", request.method());
-  }
-
-  // Older versions of OkHttp would store the "request line" as a header with a
-  // null key. To support the Android usecase where an old version of OkHttp uses
-  // a newer, Android-bundled, version of HttpResponseCache the null key must be
-  // explicitly ignored.
-  @Test public void createOkRequest_nullRequestHeaderKey() throws Exception {
-    URI uri = new URI("https://foo/bar");
-
-    Map<String, List<String>> javaRequestHeaders = new LinkedHashMap<>();
-    javaRequestHeaders.put(null, Arrays.asList("GET / HTTP 1.1"));
-    javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
-    Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
-    assertTrue(request.isHttps());
-    assertEquals(uri, request.url().uri());
-    Headers okRequestHeaders = request.headers();
-    assertEquals(1, okRequestHeaders.size());
-    assertEquals("Bar", okRequestHeaders.get("Foo"));
-    assertEquals("POST", request.method());
-  }
-
-  @Test public void createJavaUrlConnection_requestChangesForbidden() throws Exception {
-    Response okResponse = createArbitraryOkResponse();
-    HttpURLConnection httpUrlConnection =
-        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
-    // Check an arbitrary (not complete) set of methods that can be used to modify the
-    // request.
-    try {
-      httpUrlConnection.setRequestProperty("key", "value");
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.setFixedLengthStreamingMode(1234);
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.setRequestMethod("PUT");
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.getHeaderFields().put("key", Collections.singletonList("value"));
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.getOutputStream();
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-
-  @Test public void createJavaUrlConnection_connectionChangesForbidden() throws Exception {
-    Response okResponse = createArbitraryOkResponse();
-    HttpURLConnection httpUrlConnection =
-        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
-    try {
-      httpUrlConnection.connect();
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.disconnect();
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-
-  @Test public void createJavaUrlConnection_responseChangesForbidden() throws Exception {
-    Response okResponse = createArbitraryOkResponse();
-    HttpURLConnection httpUrlConnection =
-        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
-    // Check an arbitrary (not complete) set of methods that can be used to access the response
-    // body.
-    InputStream is = httpUrlConnection.getInputStream();
-    try {
-      is.read();
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.getContent();
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.setFixedLengthStreamingMode(1234);
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.setRequestMethod("PUT");
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.getHeaderFields().put("key", Collections.singletonList("value"));
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-
-  @Test public void createJavaUrlConnection_responseHeadersOk() throws Exception {
-    ResponseBody responseBody = createResponseBody("BodyText");
-    Response okResponse = new Response.Builder()
-        .request(createArbitraryOkRequest())
-        .protocol(Protocol.HTTP_1_1)
-        .code(200)
-        .message("Fantastic")
-        .addHeader("A", "c")
-        .addHeader("B", "d")
-        .addHeader("A", "e")
-        .addHeader("Content-Length", Long.toString(responseBody.contentLength()))
-        .body(responseBody)
-        .build();
-
-    HttpURLConnection httpUrlConnection =
-        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
-    assertEquals(200, httpUrlConnection.getResponseCode());
-    assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
-    assertEquals(responseBody.contentLength(), httpUrlConnection.getContentLength());
-
-    // Check retrieval by string key.
-    assertEquals("HTTP/1.1 200 Fantastic", httpUrlConnection.getHeaderField(null));
-    assertEquals("e", httpUrlConnection.getHeaderField("A"));
-    // The RI and OkHttp supports case-insensitive matching for this method.
-    assertEquals("e", httpUrlConnection.getHeaderField("a"));
-
-    // Check retrieval using a Map.
-    Map<String, List<String>> responseHeaders = httpUrlConnection.getHeaderFields();
-    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), responseHeaders.get(null));
-    assertEquals(newSet("c", "e"), newSet(responseHeaders.get("A")));
-    // OkHttp supports case-insensitive matching here. The RI does not.
-    assertEquals(newSet("c", "e"), newSet(responseHeaders.get("a")));
-
-    // Check the Map iterator contains the expected mappings.
-    assertHeadersContainsMapping(responseHeaders, null, "HTTP/1.1 200 Fantastic");
-    assertHeadersContainsMapping(responseHeaders, "A", "c", "e");
-    assertHeadersContainsMapping(responseHeaders, "B", "d");
-
-    // Check immutability of the headers Map.
-    try {
-      responseHeaders.put("N", Arrays.asList("o"));
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      responseHeaders.get("A").add("f");
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-
-    // Check retrieval of headers by index.
-    assertNull(httpUrlConnection.getHeaderFieldKey(0));
-    assertEquals("HTTP/1.1 200 Fantastic", httpUrlConnection.getHeaderField(0));
-    // After header zero there may be additional entries provided at the beginning or end by the
-    // implementation. It's probably important that the relative ordering of the headers is
-    // preserved, particularly if there are multiple value for the same key.
-    int i = 1;
-    while (!httpUrlConnection.getHeaderFieldKey(i).equals("A")) {
-      i++;
-    }
-    // Check the ordering of the headers set by app code.
-    assertResponseHeaderAtIndex(httpUrlConnection, i++, "A", "c");
-    assertResponseHeaderAtIndex(httpUrlConnection, i++, "B", "d");
-    assertResponseHeaderAtIndex(httpUrlConnection, i++, "A", "e");
-    // There may be some additional headers provided by the implementation.
-    while (httpUrlConnection.getHeaderField(i) != null) {
-      assertNotNull(httpUrlConnection.getHeaderFieldKey(i));
-      i++;
-    }
-    // Confirm the correct behavior when the index is out-of-range.
-    assertNull(httpUrlConnection.getHeaderFieldKey(i));
-  }
-
-  private static void assertResponseHeaderAtIndex(HttpURLConnection httpUrlConnection,
-      int headerIndex, String expectedKey, String expectedValue) {
-    assertEquals(expectedKey, httpUrlConnection.getHeaderFieldKey(headerIndex));
-    assertEquals(expectedValue, httpUrlConnection.getHeaderField(headerIndex));
-  }
-
-  private void assertHeadersContainsMapping(Map<String, List<String>> headers, String expectedKey,
-      String... expectedValues) {
-    assertTrue(headers.containsKey(expectedKey));
-    assertEquals(newSet(expectedValues), newSet(headers.get(expectedKey)));
-  }
-
-  @Test public void createJavaUrlConnection_accessibleRequestInfo_GET() throws Exception {
-    Request okRequest = createArbitraryOkRequest().newBuilder()
-        .get()
-        .build();
-    Response okResponse = createArbitraryOkResponse(okRequest);
-    HttpURLConnection httpUrlConnection =
-        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
-
-    assertEquals("GET", httpUrlConnection.getRequestMethod());
-    assertTrue(httpUrlConnection.getDoInput());
-    assertFalse(httpUrlConnection.getDoOutput());
-  }
-
-  @Test public void createJavaUrlConnection_accessibleRequestInfo_POST() throws Exception {
-    Request okRequest = createArbitraryOkRequest().newBuilder()
-        .post(createRequestBody("PostBody"))
-        .build();
-    Response okResponse = createArbitraryOkResponse(okRequest);
-    HttpURLConnection httpUrlConnection =
-        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
-
-    assertEquals("POST", httpUrlConnection.getRequestMethod());
-    assertTrue(httpUrlConnection.getDoInput());
-    assertTrue(httpUrlConnection.getDoOutput());
-  }
-
-  @Test public void createJavaUrlConnection_https_extraHttpsMethods() throws Exception {
-    Request okRequest = createArbitraryOkRequest().newBuilder()
-        .get()
-        .url("https://secure/request")
-        .build();
-    Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, CipherSuite.TLS_RSA_WITH_NULL_MD5,
-        Arrays.asList(SERVER_CERT), Arrays.asList(LOCAL_CERT));
-    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
-        .handshake(handshake)
-        .build();
-    HttpsURLConnection httpsUrlConnection =
-        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
-
-    assertEquals("SSL_RSA_WITH_NULL_MD5", httpsUrlConnection.getCipherSuite());
-    assertEquals(SERVER_CERT.getSubjectX500Principal(), httpsUrlConnection.getPeerPrincipal());
-    assertArrayEquals(new Certificate[] {LOCAL_CERT}, httpsUrlConnection.getLocalCertificates());
-    assertArrayEquals(new Certificate[] {SERVER_CERT},
-        httpsUrlConnection.getServerCertificates());
-    assertEquals(LOCAL_CERT.getSubjectX500Principal(), httpsUrlConnection.getLocalPrincipal());
-  }
-
-  @Test public void createJavaUrlConnection_https_forbiddenFields() throws Exception {
-    Request okRequest = createArbitraryOkRequest().newBuilder()
-        .url("https://secure/request")
-        .build();
-    Response okResponse = createArbitraryOkResponse(okRequest);
-    HttpsURLConnection httpsUrlConnection =
-        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
-
-    try {
-      httpsUrlConnection.getHostnameVerifier();
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpsUrlConnection.getSSLSocketFactory();
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-
-  @Test public void createJavaCacheResponse_httpGet() throws Exception {
-    Request okRequest =
-        createArbitraryOkRequest().newBuilder()
-            .url("http://insecure/request")
-            .get()
-            .build();
-    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
-        .protocol(Protocol.HTTP_1_1)
-        .code(200)
-        .message("Fantastic")
-        .addHeader("key1", "value1_1")
-        .addHeader("key2", "value2")
-        .addHeader("key1", "value1_2")
-        .body(null)
-        .build();
-    CacheResponse javaCacheResponse = JavaApiConverter.createJavaCacheResponse(okResponse);
-    assertFalse(javaCacheResponse instanceof SecureCacheResponse);
-    Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
-    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
-    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
-    assertNull(javaCacheResponse.getBody());
-  }
-
-  @Test public void createJavaCacheResponse_httpPost() throws Exception {
-    Request okRequest =
-        createArbitraryOkRequest().newBuilder()
-            .url("http://insecure/request")
-            .post(createRequestBody("RequestBody"))
-            .build();
-    ResponseBody responseBody = createResponseBody("ResponseBody");
-    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
-        .protocol(Protocol.HTTP_1_1)
-        .code(200)
-        .message("Fantastic")
-        .addHeader("key1", "value1_1")
-        .addHeader("key2", "value2")
-        .addHeader("key1", "value1_2")
-        .body(responseBody)
-        .build();
-    CacheResponse javaCacheResponse = JavaApiConverter.createJavaCacheResponse(okResponse);
-    assertFalse(javaCacheResponse instanceof SecureCacheResponse);
-    Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
-    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
-    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
-    assertEquals("ResponseBody", readAll(javaCacheResponse.getBody()));
-  }
-
-  @Test public void createJavaCacheResponse_httpsPost() throws Exception {
-    Request okRequest =
-        createArbitraryOkRequest().newBuilder()
-            .url("https://secure/request")
-            .post(createRequestBody("RequestBody"))
-            .build();
-    ResponseBody responseBody = createResponseBody("ResponseBody");
-    Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, CipherSuite.TLS_RSA_WITH_NULL_MD5,
-        Arrays.asList(SERVER_CERT), Arrays.asList(LOCAL_CERT));
-    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
-        .protocol(Protocol.HTTP_1_1)
-        .code(200)
-        .message("Fantastic")
-        .addHeader("key1", "value1_1")
-        .addHeader("key2", "value2")
-        .addHeader("key1", "value1_2")
-        .body(responseBody)
-        .handshake(handshake)
-        .build();
-    SecureCacheResponse javaCacheResponse =
-        (SecureCacheResponse) JavaApiConverter.createJavaCacheResponse(okResponse);
-    Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
-    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
-    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
-    assertEquals("ResponseBody", readAll(javaCacheResponse.getBody()));
-    assertEquals(handshake.cipherSuite().javaName(), javaCacheResponse.getCipherSuite());
-    assertEquals(handshake.localCertificates(), javaCacheResponse.getLocalCertificateChain());
-    assertEquals(handshake.peerCertificates(), javaCacheResponse.getServerCertificateChain());
-    assertEquals(handshake.localPrincipal(), javaCacheResponse.getLocalPrincipal());
-    assertEquals(handshake.peerPrincipal(), javaCacheResponse.getPeerPrincipal());
-  }
-
-  @Test public void extractJavaHeaders() throws Exception {
-    Request okRequest = createArbitraryOkRequest().newBuilder()
-        .addHeader("key1", "value1_1")
-        .addHeader("key2", "value2")
-        .addHeader("key1", "value1_2")
-        .build();
-    Map<String, List<String>> javaHeaders = JavaApiConverter.extractJavaHeaders(okRequest);
-
-    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
-    assertEquals(Arrays.asList("value2"), javaHeaders.get("key2"));
-  }
-
-  @Test public void extractOkHeaders() {
-    Map<String, List<String>> javaResponseHeaders = new LinkedHashMap<>();
-    javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
-    javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
-    javaResponseHeaders.put("key2", Arrays.asList("value2"));
-
-    Headers okHeaders = JavaApiConverter.extractOkHeaders(javaResponseHeaders, null);
-    assertEquals(3, okHeaders.size()); // null entry should be stripped out
-    assertEquals(Arrays.asList("value1_1", "value1_2"), okHeaders.values("key1"));
-    assertEquals(Arrays.asList("value2"), okHeaders.values("key2"));
-  }
-
-  @Test public void extractStatusLine() throws Exception {
-    Map<String, List<String>> javaResponseHeaders = new LinkedHashMap<>();
-    javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
-    javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
-    javaResponseHeaders.put("key2", Arrays.asList("value2"));
-    assertEquals("StatusLine", JavaApiConverter.extractStatusLine(javaResponseHeaders));
-
-    try {
-      JavaApiConverter.extractStatusLine(Collections.emptyMap());
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  private static <T> void assertNotNullAndEquals(T expected, T actual) {
-    assertNotNull(actual);
-    assertEquals(expected, actual);
-  }
-
-  private static X509Certificate certificate(String certificate) {
-    try {
-      return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(
-          new ByteArrayInputStream(certificate.getBytes(UTF_8)));
-    } catch (CertificateException e) {
-      fail();
-      return null;
-    }
-  }
-
-  @SafeVarargs
-  private static <T> Set<T> newSet(T... elements) {
-    return newSet(Arrays.asList(elements));
-  }
-
-  private static <T> Set<T> newSet(List<T> elements) {
-    return new LinkedHashSet<>(elements);
-  }
-
-  private static Request createArbitraryOkRequest() {
-    return new Request.Builder().url("http://arbitrary/url").build();
-  }
-
-  private static Response createArbitraryOkResponse(Request request) {
-    return new Response.Builder()
-        .request(request)
-        .protocol(Protocol.HTTP_1_1)
-        .code(200)
-        .message("Arbitrary")
-        .build();
-  }
-
-  private static Response createArbitraryOkResponse() {
-    return createArbitraryOkResponse(createArbitraryOkRequest());
-  }
-
-  private static RequestBody createRequestBody(String bodyText) {
-    return RequestBody.create(MediaType.get("text/plain"), bodyText);
-  }
-
-  private static ResponseBody createResponseBody(String bodyText) {
-    final Buffer source = new Buffer().writeUtf8(bodyText);
-    final long contentLength = source.size();
-    return new ResponseBody() {
-      @Override public MediaType contentType() {
-        return MediaType.get("text/plain; charset=utf-8");
-      }
-
-      @Override public long contentLength() {
-        return contentLength;
-      }
-
-      @Override public BufferedSource source() {
-        return source;
-      }
-    };
-  }
-
-  private String readAll(InputStream in) throws IOException {
-    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
-    int value;
-    while ((value = in.read()) != -1) {
-      buffer.write(value);
-    }
-    in.close();
-    return buffer.toString("UTF-8");
-  }
-}
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
deleted file mode 100644
index 94c875d814..0000000000
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
+++ /dev/null
@@ -1,2190 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.internal.huc;
-
-import java.io.ByteArrayInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.CookieManager;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.ResponseCache;
-import java.net.SecureCacheResponse;
-import java.net.URI;
-import java.net.URL;
-import java.net.URLConnection;
-import java.nio.charset.StandardCharsets;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.TimeZone;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import okhttp3.AbstractResponseCache;
-import okhttp3.AndroidInternal;
-import okhttp3.AndroidShimResponseCache;
-import okhttp3.Headers;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.internal.Internal;
-import okhttp3.internal.cache.InternalCache;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeFalse;
-
-/**
- * Tests the interaction between OkHttp and {@link ResponseCache}. Based on okhttp3.CacheTest with
- * changes for ResponseCache and HttpURLConnection.
- */
-public final class ResponseCacheTest {
-  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
-  @Rule public MockWebServer server = new MockWebServer();
-  @Rule public MockWebServer server2 = new MockWebServer();
-
-  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  private HandshakeCertificates handshakeCertificates = localhost();
-  private ResponseCache cache;
-  private CookieManager cookieManager;
-  private OkUrlFactory urlFactory;
-
-  @Before public void setUp() throws Exception {
-    server.setProtocolNegotiationEnabled(false);
-
-    cache = AndroidShimResponseCache.create(cacheRule.getRoot(), 10 * 1024 * 1024);
-    urlFactory = new OkUrlFactory(new OkHttpClient());
-    AndroidInternal.setResponseCache(urlFactory, cache);
-
-    cookieManager = new CookieManager();
-  }
-
-  @After public void tearDown() {
-    ResponseCache.setDefault(null);
-  }
-
-  private HttpURLConnection openConnection(URL url) {
-    return urlFactory.open(url);
-  }
-
-  /**
-   * Test that response caching is consistent with the RI and the spec.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
-   */
-  @Test public void responseCachingByResponseCode() throws Exception {
-    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
-    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
-
-    // We can't test 100 because it's not really a response.
-    // assertCached(false, 100);
-    assertCached(false, 101);
-    assertCached(false, 102);
-    assertCached(true, 200);
-    assertCached(false, 201);
-    assertCached(false, 202);
-    assertCached(true, 203);
-    assertCached(true, 204);
-    assertCached(false, 205);
-    assertCached(false, 206); //Electing to not cache partial responses
-    assertCached(false, 207);
-    assertCached(true, 300);
-    assertCached(true, 301);
-    assertCached(true, 302);
-    assertCached(false, 303);
-    assertCached(false, 304);
-    assertCached(false, 305);
-    assertCached(false, 306);
-    assertCached(true, 307);
-    assertCached(true, 308);
-    assertCached(false, 400);
-    assertCached(false, 401);
-    assertCached(false, 402);
-    assertCached(false, 403);
-    assertCached(true, 404);
-    assertCached(true, 405);
-    assertCached(false, 406);
-    assertCached(false, 408);
-    assertCached(false, 409);
-    // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true, 410);
-    assertCached(false, 411);
-    assertCached(false, 412);
-    assertCached(false, 413);
-    assertCached(true, 414);
-    assertCached(false, 415);
-    assertCached(false, 416);
-    assertCached(false, 417);
-    assertCached(false, 418);
-
-    assertCached(false, 500);
-    assertCached(true, 501);
-    assertCached(false, 502);
-    assertCached(false, 503);
-    assertCached(false, 504);
-    assertCached(false, 505);
-    assertCached(false, 506);
-  }
-
-  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
-    int expectedResponseCode = responseCode;
-
-    server = new MockWebServer();
-    MockResponse mockResponse = new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(responseCode)
-        .setBody("ABCDE")
-        .addHeader("WWW-Authenticate: challenge");
-    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
-      mockResponse.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
-      mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
-        || responseCode == HttpURLConnection.HTTP_RESET) {
-      mockResponse.setBody(""); // We forbid bodies for 204 and 205.
-    }
-    server.enqueue(mockResponse);
-
-    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
-      // 408's are a bit of an outlier because we may repeat the request if we encounter this
-      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
-      // because of the retry. We just want to ensure the initial 408 isn't cached.
-      expectedResponseCode = 200;
-      server.enqueue(new MockResponse()
-          .setHeader("Cache-Control", "no-store")
-          .setBody("FGHIJ"));
-    }
-
-    server.start();
-
-    URL url = server.url("/").url();
-    HttpURLConnection connection = openConnection(url);
-    assertEquals(expectedResponseCode, connection.getResponseCode());
-
-    // Exhaust the content stream.
-    readAscii(connection);
-
-    CacheResponse cached = cache.get(url.toURI(), "GET", null);
-    if (shouldPut) {
-      assertNotNull(Integer.toString(responseCode), cached);
-    } else {
-      assertNull(Integer.toString(responseCode), cached);
-    }
-    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
-    testResponseCaching(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
-    testResponseCaching(TransferKind.CHUNKED);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
-    testResponseCaching(TransferKind.END_OF_STREAM);
-  }
-
-  /**
-   * HttpURLConnection.getInputStream().skip(long) causes ResponseCache corruption
-   * http://code.google.com/p/android/issues/detail?id=8175
-   */
-  private void testResponseCaching(TransferKind transferKind) throws IOException {
-    MockResponse mockResponse = new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setStatus("HTTP/1.1 200 Fantastic");
-    transferKind.setBody(mockResponse, "I love puppies but hate spiders", 1);
-    server.enqueue(mockResponse);
-
-    // Make sure that calling skip() doesn't omit bytes from the cache.
-    HttpURLConnection urlConnection = openConnection(server.url("/").url());
-    InputStream in = urlConnection.getInputStream();
-    assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
-    reliableSkip(in, "puppies but hate ".length());
-    assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
-    assertEquals(-1, in.read());
-    in.close();
-
-    urlConnection = openConnection(server.url("/").url()); // cached!
-    in = urlConnection.getInputStream();
-    assertEquals("I love puppies but hate spiders",
-        readAscii(urlConnection, "I love puppies but hate spiders".length()));
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-
-    assertEquals(-1, in.read());
-    in.close();
-  }
-
-  @Test public void secureResponseCaching() throws IOException {
-    assumeFalse(getPlatform().equals("jdk9"));
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-
-    HttpsURLConnection c1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    c1.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
-    c1.setHostnameVerifier(hostnameVerifier);
-    assertEquals("ABC", readAscii(c1));
-
-    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    String suite = c1.getCipherSuite();
-    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
-    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
-    Principal peerPrincipal = c1.getPeerPrincipal();
-    Principal localPrincipal = c1.getLocalPrincipal();
-
-    HttpsURLConnection c2 = (HttpsURLConnection) openConnection(server.url("/").url()); // cached!
-    c2.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
-    c2.setHostnameVerifier(hostnameVerifier);
-    assertEquals("ABC", readAscii(c2));
-
-    assertEquals(suite, c2.getCipherSuite());
-    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
-    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
-    assertEquals(peerPrincipal, c2.getPeerPrincipal());
-    assertEquals(localPrincipal, c2.getLocalPrincipal());
-  }
-
-  @Test public void responseCachingAndRedirects() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    assertEquals("ABC", readAscii(connection));
-
-    connection = openConnection(server.url("/").url()); // cached!
-    assertEquals("ABC", readAscii(connection));
-  }
-
-  @Test public void redirectToCachedResult() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    assertEquals("ABC", readAscii(openConnection(server.url("/foo").url())));
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
-    assertEquals(0, request1.getSequenceNumber());
-
-    assertEquals("ABC", readAscii(openConnection(server.url("/bar").url())));
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
-    assertEquals(1, request2.getSequenceNumber());
-
-    // an unrelated request should reuse the pooled connection
-    assertEquals("DEF", readAscii(openConnection(server.url("/baz").url())));
-    RecordedRequest request3 = server.takeRequest();
-    assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
-    assertEquals(2, request3.getSequenceNumber());
-  }
-
-  @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-
-    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    assertEquals("ABC", readAscii(connection1));
-    assertNotNull(connection1.getCipherSuite());
-
-    // Cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.url("/").url());
-    assertEquals("ABC", readAscii(connection2));
-    assertNotNull(connection2.getCipherSuite());
-
-    assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
-  }
-
-  /**
-   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
-   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
-   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
-   *
-   * https://github.com/square/okhttp/issues/214
-   */
-  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server2.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server2.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: " + server2.url("/").url()));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-
-    HttpURLConnection connection1 = openConnection(server.url("/").url());
-    assertEquals("ABC", readAscii(connection1));
-
-    // Cached!
-    HttpURLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("ABC", readAscii(connection2));
-  }
-
-  @Test public void foundCachedWithExpiresHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(302, "Expires", formatDate(1, TimeUnit.HOURS));
-  }
-
-  @Test public void foundCachedWithCacheControlHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(302, "Cache-Control", "max-age=60");
-  }
-
-  @Test public void temporaryRedirectCachedWithExpiresHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(307, "Expires", formatDate(1, TimeUnit.HOURS));
-  }
-
-  @Test public void temporaryRedirectCachedWithCacheControlHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(307, "Cache-Control", "max-age=60");
-  }
-
-  @Test public void foundNotCachedWithoutCacheHeader() throws Exception {
-    temporaryRedirectNotCachedWithoutCachingHeader(302);
-  }
-
-  @Test public void temporaryRedirectNotCachedWithoutCacheHeader() throws Exception {
-    temporaryRedirectNotCachedWithoutCachingHeader(307);
-  }
-
-  private void temporaryRedirectCachedWithCachingHeader(
-      int responseCode, String headerName, String headerValue) throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader(headerName, headerValue)
-        .addHeader("Location", "/a"));
-    server.enqueue(new MockResponse()
-        .addHeader(headerName, headerValue)
-        .setBody("a"));
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-    server.enqueue(new MockResponse()
-        .setBody("c"));
-
-    URL url = server.url("/").url();
-    assertEquals("a", readAscii(openConnection(url)));
-    assertEquals("a", readAscii(openConnection(url)));
-  }
-
-  private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader("Location", "/a"));
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-
-    URL url = server.url("/").url();
-    assertEquals("a", readAscii(openConnection(url)));
-    assertEquals("b", readAscii(openConnection(url)));
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
-    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
-    testServerPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() {
-    // Intentionally empty. This case doesn't make sense because there's no
-    // such thing as a premature disconnect when the disconnect itself
-    // indicates the end of the data stream.
-  }
-
-  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
-    server.enqueue(truncateViolently(response, 16));
-    server.enqueue(new MockResponse()
-        .setBody("Request #2"));
-
-    BufferedSource bodySource = Okio.buffer(Okio.source(
-        openConnection(server.url("/").url()).getInputStream()));
-    assertEquals("ABCDE\n", bodySource.readUtf8(6));
-    try {
-      bodySource.readUtf8(21);
-      fail("This implementation silently ignored a truncated HTTP body.");
-    } catch (IOException expected) {
-    } finally {
-      bodySource.close();
-    }
-
-    URLConnection connection = openConnection(server.url("/").url());
-    assertEquals("Request #2", readAscii(connection));
-  }
-
-  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
-    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
-    testClientPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
-    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
-  }
-
-  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
-    // Setting a low transfer speed ensures that stream discarding will time out.
-    MockResponse response = new MockResponse()
-        .throttleBody(6, 1, TimeUnit.SECONDS);
-    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(response);
-    server.enqueue(new MockResponse()
-        .setBody("Request #2"));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals("ABCDE", readAscii(connection, 5));
-    in.close();
-    try {
-      in.read();
-      fail("Expected an IOException because the stream is closed.");
-    } catch (IOException expected) {
-    }
-
-    connection = openConnection(server.url("/").url());
-    assertEquals("Request #2", readAscii(connection));
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
-    //      last modified: 105 seconds ago
-    //             served:   5 seconds ago
-    //   default lifetime: (105 - 5) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds from now
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-        .setBody("A"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
-    assertEquals("A", readAscii(connection));
-    assertNull(connection.getHeaderField("Warning"));
-  }
-
-  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
-    //      last modified: 115 seconds ago
-    //             served:  15 seconds ago
-    //   default lifetime: (115 - 15) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds ago
-    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
-    //      last modified: 105 days ago
-    //             served:   5 days ago
-    //   default lifetime: (105 - 5) / 10 = 10 days
-    //            expires:  10 days from served date = 5 days from now
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
-        .setBody("A"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    URLConnection connection = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection));
-    assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
-        connection.getHeaderField("Warning"));
-  }
-
-  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/?foo=bar").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
-  }
-
-  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void expirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Cache-Control: max-age=60"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
-    // Chrome interprets max-age relative to the local clock. Both our cache
-    // and Firefox both use the earlier of the local and server's clock.
-    assertNotCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=60")
-        .addHeader("Cache-Control: max-age=180"));
-  }
-
-  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=180")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void requestMethodOptionsIsNotCached() throws Exception {
-    testRequestMethod("OPTIONS", false);
-  }
-
-  @Test public void requestMethodGetIsCached() throws Exception {
-    testRequestMethod("GET", true);
-  }
-
-  @Test public void requestMethodHeadIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("HEAD", false);
-  }
-
-  @Test public void requestMethodPostIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("POST", false);
-  }
-
-  @Test public void requestMethodPutIsNotCached() throws Exception {
-    testRequestMethod("PUT", false);
-  }
-
-  @Test public void requestMethodDeleteIsNotCached() throws Exception {
-    testRequestMethod("DELETE", false);
-  }
-
-  @Test public void requestMethodTraceIsNotCached() throws Exception {
-    testRequestMethod("TRACE", false);
-  }
-
-  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
-    // 1. seed the cache (potentially)
-    // 2. expect a cache hit or miss
-    server.enqueue(new MockResponse()
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("X-Response-ID: 1"));
-    server.enqueue(new MockResponse()
-        .addHeader("X-Response-ID: 2"));
-
-    URL url = server.url("/").url();
-
-    HttpURLConnection request1 = openConnection(url);
-    request1.setRequestMethod(requestMethod);
-    addRequestBodyIfNecessary(requestMethod, request1);
-    request1.getInputStream().close();
-    assertEquals("1", request1.getHeaderField("X-Response-ID"));
-
-    URLConnection request2 = openConnection(url);
-    request2.getInputStream().close();
-    if (expectCached) {
-      assertEquals("1", request2.getHeaderField("X-Response-ID"));
-    } else {
-      assertEquals("2", request2.getHeaderField("X-Response-ID"));
-    }
-  }
-
-  private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection connection)
-      throws IOException {
-    if (requestMethod.equals("POST") || requestMethod.equals("PUT")) {
-      connection.setDoOutput(true);
-      OutputStream requestBody = connection.getOutputStream();
-      requestBody.write('x');
-      requestBody.close();
-    }
-  }
-
-  @Test public void postInvalidatesCache() throws Exception {
-    testMethodInvalidates("POST");
-  }
-
-  @Test public void putInvalidatesCache() throws Exception {
-    testMethodInvalidates("PUT");
-  }
-
-  @Test public void deleteMethodInvalidatesCache() throws Exception {
-    testMethodInvalidates("DELETE");
-  }
-
-  private void testMethodInvalidates(String requestMethod) throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it
-    // 3. expect a cache miss
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    URL url = server.url("/").url();
-
-    assertEquals("A", readAscii(openConnection(url)));
-
-    HttpURLConnection invalidateConnection = openConnection(url);
-    invalidateConnection.setRequestMethod(requestMethod);
-    assertEquals("B", readAscii(invalidateConnection));
-
-    assertEquals("C", readAscii(openConnection(url)));
-  }
-
-  /**
-   * Equivalent to {@code CacheTest.postInvalidatesCacheWithUncacheableResponse()} but demonstrating
-   * that {@link ResponseCache} provides no mechanism for cache invalidation as the result of
-   * locally-made requests. In reality invalidation could take place from other clients at any
-   * time.
-   */
-  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it with uncacheable response
-    // 3. the cache to return the original value
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .setResponseCode(500));
-
-    URL url = server.url("/").url();
-
-    assertEquals("A", readAscii(openConnection(url)));
-
-    HttpURLConnection invalidate = openConnection(url);
-    invalidate.setRequestMethod("POST");
-    addRequestBodyIfNecessary("POST", invalidate);
-    assertEquals("B", readAscii(invalidate));
-
-    assertEquals("A", readAscii(openConnection(url)));
-  }
-
-  @Test public void etag() throws Exception {
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("ETag: v1"));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-  }
-
-  /** If both If-Modified-Since and If-None-Match conditions apply, send only If-None-Match. */
-  @Test public void etagAndExpirationDateInThePast() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void cacheControlNoCache() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Cache-Control: no-cache"));
-  }
-
-  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void pragmaNoCache() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Pragma: no-cache"));
-  }
-
-  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Pragma: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void cacheControlNoStore() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
-    // 1. request a range
-    // 2. request a full document, expecting a cache miss
-    server.enqueue(new MockResponse()
-        .setBody("AA")
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 1000-1001/2000"));
-    server.enqueue(new MockResponse()
-        .setBody("BB"));
-
-    URL url = server.url("/").url();
-
-    HttpURLConnection range = openConnection(url);
-    range.addRequestProperty("Range", "bytes=1000-1001");
-    assertEquals("AA", readAscii(range));
-
-    assertEquals("BB", readAscii(openConnection(url)));
-  }
-
-  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
-
-    URL url = server.url("/").url();
-
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
-  }
-
-  @Test public void clientSideNoStore() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("B"));
-
-    HttpURLConnection connection1 = openConnection(server.url("/").url());
-    connection1.setRequestProperty("Cache-Control", "no-store");
-    assertEquals("A", readAscii(connection1));
-
-    HttpURLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("B", readAscii(connection2));
-  }
-
-  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
-    assertNonIdentityEncodingCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
-    assertNonIdentityEncodingCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
-    server.enqueue(response
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // At least three request/response pairs are required because after the first request is cached
-    // a different execution path might be taken. Thus modifications to the cache applied during
-    // the second request might not be visible until another request is performed.
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void notModifiedSpecifiesEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setBody("DEFDEFDEF"));
-
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-    assertEquals("DEFDEFDEF", readAscii(openConnection(server.url("/").url())));
-  }
-
-  /** https://github.com/square/okhttp/issues/947 */
-  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Vary: Accept-Encoding")
-        .addHeader("Cache-Control: max-age=60"));
-    server.enqueue(new MockResponse()
-        .setBody("FAIL"));
-
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void expiresDateBeforeModifiedDate() throws Exception {
-    assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
-  }
-
-  @Test public void requestMaxAge() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "max-age=30");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestMinFresh() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "min-fresh=120");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestMaxStale() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "max-stale=180");
-    assertEquals("A", readAscii(connection));
-    assertEquals("110 HttpURLConnection \"Response is stale\"",
-        connection.getHeaderField("Warning"));
-  }
-
-  @Test public void requestMaxStaleDirectiveWithNoValue() throws IOException {
-    // Add a stale response to the cache.
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    // With max-stale, we'll return that stale response.
-    URLConnection maxStaleConnection = openConnection(server.url("/").url());
-    maxStaleConnection.setRequestProperty("Cache-Control", "max-stale");
-    assertEquals("A", readAscii(maxStaleConnection));
-    assertEquals("110 HttpURLConnection \"Response is stale\"",
-        maxStaleConnection.getHeaderField("Warning"));
-  }
-
-  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120, must-revalidate")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "max-stale=180");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
-    // (no responses enqueued)
-
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-  }
-
-  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-  }
-
-  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-  }
-
-  @Test public void requestCacheControlNoCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
-    connection.setRequestProperty("Cache-Control", "no-cache");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestPragmaNoCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
-    connection.setRequestProperty("Pragma", "no-cache");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
-    MockResponse response = new MockResponse()
-        .addHeader("ETag: v3")
-        .addHeader("Cache-Control: max-age=0");
-    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
-    RecordedRequest request =
-        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
-    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
-    assertNull(request.getHeader("If-None-Match"));
-  }
-
-  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
-    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
-    MockResponse response = new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: max-age=0");
-    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
-    assertEquals("v1", request.getHeader("If-None-Match"));
-    assertNull(request.getHeader("If-Modified-Since"));
-  }
-
-  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
-      String conditionValue) throws Exception {
-    server.enqueue(seed.setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-
-    HttpURLConnection connection = openConnection(url);
-    connection.addRequestProperty(conditionName, conditionValue);
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
-    assertEquals("", readAscii(connection));
-
-    server.takeRequest(); // seed
-    return server.takeRequest();
-  }
-
-  /**
-   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
-   * served.
-   */
-  @Test public void retainServedDateFormat() throws Exception {
-    // Serve a response with a non-standard date format that OkHttp supports.
-    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
-    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
-    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
-    String lastModifiedString = dateFormat.format(lastModifiedDate);
-    String servedString = dateFormat.format(servedDate);
-
-    // This response should be conditionally cached.
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedString)
-        .addHeader("Expires: " + servedString)
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    // The first request has no conditions.
-    RecordedRequest request1 = server.takeRequest();
-    assertNull(request1.getHeader("If-Modified-Since"));
-
-    // The 2nd request uses the server's date format.
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
-    connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
-    assertEquals("", readAscii(connection));
-  }
-
-  @Test public void authorizationRequestFullyCached() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection connection = openConnection(url);
-    connection.addRequestProperty("Authorization", "password");
-    assertEquals("A", readAscii(connection));
-    assertEquals("A", readAscii(openConnection(url)));
-  }
-
-  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Content-Location: /bar")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/foo").url())));
-    assertEquals("B", readAscii(openConnection(server.url("/bar").url())));
-  }
-
-  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/a").url())));
-    assertEquals("A", readAscii(openConnection(server.url("/a").url())));
-    assertEquals("B", readAscii(openConnection(server.url("/b").url())));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frenchConnection = openConnection(url);
-    frenchConnection.setRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(frenchConnection));
-
-    HttpURLConnection englishConnection = openConnection(url);
-    englishConnection.setRequestProperty("Accept-Language", "en-US");
-    assertEquals("B", readAscii(englishConnection));
-  }
-
-  @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frenchConnection1 = openConnection(url);
-    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(frenchConnection1));
-
-    HttpURLConnection frenchConnection2 = openConnection(url);
-    frenchConnection2.setRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(frenchConnection2));
-  }
-
-  @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    HttpURLConnection connection2 = openConnection(server.url("/").url());
-    connection2.setRequestProperty("Foo", "bar");
-    assertEquals("B", readAscii(connection2));
-  }
-
-  @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpURLConnection connection1 = openConnection(server.url("/").url());
-    connection1.setRequestProperty("Foo", "bar");
-    assertEquals("A", readAscii(connection1));
-    assertEquals("B", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void varyFieldsAreCaseInsensitive() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: ACCEPT-LANGUAGE")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frenchConnection1 = openConnection(url);
-    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(frenchConnection1));
-    HttpURLConnection frenchConnection2 = openConnection(url);
-    frenchConnection2.setRequestProperty("accept-language", "fr-CA");
-    assertEquals("A", readAscii(frenchConnection2));
-  }
-
-  @Test public void varyMultipleFieldsWithMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frenchConnection1 = openConnection(url);
-    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
-    frenchConnection1.setRequestProperty("Accept-Charset", "UTF-8");
-    frenchConnection1.setRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(frenchConnection1));
-    HttpURLConnection frenchConnection2 = openConnection(url);
-    frenchConnection2.setRequestProperty("Accept-Language", "fr-CA");
-    frenchConnection2.setRequestProperty("Accept-Charset", "UTF-8");
-    frenchConnection2.setRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(frenchConnection2));
-  }
-
-  @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frenchConnection = openConnection(url);
-    frenchConnection.setRequestProperty("Accept-Language", "fr-CA");
-    frenchConnection.setRequestProperty("Accept-Charset", "UTF-8");
-    frenchConnection.setRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(frenchConnection));
-    HttpURLConnection englishConnection = openConnection(url);
-    englishConnection.setRequestProperty("Accept-Language", "en-CA");
-    englishConnection.setRequestProperty("Accept-Charset", "UTF-8");
-    englishConnection.setRequestProperty("Accept-Encoding", "identity");
-    assertEquals("B", readAscii(englishConnection));
-  }
-
-  @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection multiConnection1 = openConnection(url);
-    multiConnection1.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    multiConnection1.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(multiConnection1));
-
-    HttpURLConnection multiConnection2 = openConnection(url);
-    multiConnection2.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    multiConnection2.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(multiConnection2));
-  }
-
-  @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection multiConnection = openConnection(url);
-    multiConnection.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    multiConnection.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(multiConnection));
-
-    HttpURLConnection notFrenchConnection = openConnection(url);
-    notFrenchConnection.setRequestProperty("Accept-Language", "fr-CA");
-    notFrenchConnection.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("B", readAscii(notFrenchConnection));
-  }
-
-  @Test public void varyAsterisk() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: *")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    assertEquals("B", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void varyAndHttps() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-
-    URL url = server.url("/").url();
-    HttpURLConnection connection1 = openConnection(url);
-    connection1.setRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection1));
-
-    HttpURLConnection connection2 = openConnection(url);
-    connection2.setRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Allow: GET, HEAD")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Allow: GET, HEAD, PUT")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
-
-    URLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
-  }
-
-  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Transfer-Encoding: identity")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Transfer-Encoding: none")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
-
-    URLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
-  }
-
-  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Warning: 199 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("199 test danger", connection1.getHeaderField("Warning"));
-
-    URLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertNull(connection2.getHeaderField("Warning"));
-  }
-
-  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Warning: 299 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("299 test danger", connection1.getHeaderField("Warning"));
-
-    URLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("299 test danger", connection2.getHeaderField("Warning"));
-  }
-
-  @Test public void doNotCachePartialResponse() throws Exception {
-    assertNotCached(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 100-100/200")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  /**
-   * Equivalent to {@code CacheTest.conditionalHitUpdatesCache()}, except a Java standard cache has
-   * no means to update the headers for an existing entry so the behavior is different.
-   */
-  @Test public void conditionalHitDoesNotUpdateCache() throws Exception {
-    // A response that is cacheable, but with a short life.
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    // A response that refers to the previous response, but is cacheable with a long life.
-    // Contains a header we can recognize as having come from the server.
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Allow: GET, HEAD")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    // A response that is cacheable with a long life.
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .addHeader("Cache-Control: max-age=30"));
-    // A response that should never be requested.
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    // cache miss; seed the cache with an entry that will require a network hit to be sure it is
-    // still valid
-    HttpURLConnection connection1 = openConnection(server.url("/a").url());
-    assertEquals("A", readAscii(connection1));
-    assertNull(connection1.getHeaderField("Allow"));
-
-    // conditional cache hit; The cached data should be returned, but the cache is not updated.
-    HttpURLConnection connection2 = openConnection(server.url("/a").url());
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
-
-    // conditional cache hit; The server responds with new data. The cache is updated.
-    HttpURLConnection connection3 = openConnection(server.url("/a").url());
-    assertEquals("B", readAscii(connection3));
-
-    // full cache hit; The data from connection3 has now replaced that from connection 1.
-    HttpURLConnection connection4 = openConnection(server.url("/a").url());
-    assertEquals("B", readAscii(connection4));
-
-    assertEquals(3, server.getRequestCount());
-  }
-
-  @Test public void responseSourceHeaderCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=0")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(304));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void emptyResponseHeaderNameFromCacheIsLenient() {
-    Headers.Builder headers = new Headers.Builder()
-        .add("Cache-Control: max-age=120");
-    Internal.instance.addLenient(headers, ": A");
-    server.enqueue(new MockResponse()
-        .setHeaders(headers.build())
-        .setBody("body"));
-
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    assertEquals("A", connection.getHeaderField(""));
-  }
-
-  /**
-   * @param delta the offset from the current date to use. Negative values yield dates in the past;
-   * positive values yield dates in the future.
-   */
-  private String formatDate(long delta, TimeUnit timeUnit) {
-    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private String formatDate(Date date) {
-    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
-    return rfc1123.format(date);
-  }
-
-  private void assertNotCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
-  }
-
-  /** @return the request with the conditional get headers. */
-  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
-    // scenario 1: condition succeeds
-    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // scenario 2: condition fails
-    server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
-
-    URL valid = server.url("/valid").url();
-    HttpURLConnection connection1 = openConnection(valid);
-    assertEquals("A", readAscii(connection1));
-    assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
-    assertEquals("A-OK", connection1.getResponseMessage());
-    HttpURLConnection connection2 = openConnection(valid);
-    assertEquals("A", readAscii(connection2));
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertEquals("A-OK", connection2.getResponseMessage());
-
-    URL invalid = server.url("/invalid").url();
-    HttpURLConnection connection3 = openConnection(invalid);
-    assertEquals("B", readAscii(connection3));
-    assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
-    assertEquals("B-OK", connection3.getResponseMessage());
-    HttpURLConnection connection4 = openConnection(invalid);
-    assertEquals("C", readAscii(connection4));
-    assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
-    assertEquals("C-OK", connection4.getResponseMessage());
-
-    server.takeRequest(); // regular get
-    return server.takeRequest(); // conditional get
-  }
-
-  private void assertFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(response.setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("A", readAscii(openConnection(url)));
-  }
-
-  /**
-   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
-   * how clients respond to the premature conclusion of the HTTP body.
-   */
-  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
-    response.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
-    Headers headers = response.getHeaders();
-    Buffer truncatedBody = new Buffer();
-    truncatedBody.write(response.getBody(), numBytesToKeep);
-    response.setBody(truncatedBody);
-    response.setHeaders(headers);
-    return response;
-  }
-
-  enum TransferKind {
-    CHUNKED {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setChunkedBody(content, chunkSize);
-      }
-    },
-    FIXED_LENGTH {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-      }
-    },
-    END_OF_STREAM {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
-        response.removeHeader("Content-Length");
-      }
-    };
-
-    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, new Buffer().writeUtf8(content), chunkSize);
-    }
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  private Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(result));
-    sink.writeUtf8(data);
-    sink.close();
-    return result;
-  }
-
-  /**
-   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
-   * characters can be read, the remaining characters are returned and the stream is closed.
-   */
-  private String readAscii(URLConnection connection, int count) throws IOException {
-    HttpURLConnection httpConnection = (HttpURLConnection) connection;
-    InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
-        ? connection.getInputStream() : httpConnection.getErrorStream();
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  private String readAscii(URLConnection connection) throws IOException {
-    return readAscii(connection, Integer.MAX_VALUE);
-  }
-
-  private void reliableSkip(InputStream in, int length) throws IOException {
-    while (length > 0) {
-      length -= in.skip(length);
-    }
-  }
-
-  private void assertGatewayTimeout(HttpURLConnection connection) throws IOException {
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (FileNotFoundException expected) {
-    }
-    assertEquals(504, connection.getResponseCode());
-    assertEquals(-1, connection.getErrorStream().read());
-  }
-
-  private static <T> List<T> toListOrNull(T[] arrayOrNull) {
-    return arrayOrNull != null ? Arrays.asList(arrayOrNull) : null;
-  }
-
-  // Android-added tests.
-
-  /**
-   * Test that we can interrogate the response when the cache is being populated.
-   * http://code.google.com/p/android/issues/detail?id=7787
-   */
-  @Test public void responseCacheCallbackApis() throws Exception {
-    final String body = "ABCDE";
-    final AtomicInteger cacheCount = new AtomicInteger();
-
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 200 Fantastic")
-        .addHeader("Content-Type: text/plain")
-        .addHeader("fgh: ijk")
-        .setBody(body));
-
-    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        HttpURLConnection httpURLConnection = (HttpURLConnection) connection;
-        assertEquals(server.url("/").url(), uri.toURL());
-        assertEquals(200, httpURLConnection.getResponseCode());
-        InputStream is = httpURLConnection.getInputStream();
-        try {
-          is.read();
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        assertEquals("5", connection.getHeaderField("Content-Length"));
-        assertEquals("text/plain", connection.getHeaderField("Content-Type"));
-        assertEquals("ijk", connection.getHeaderField("fgh"));
-        cacheCount.incrementAndGet();
-        return null;
-      }
-    }));
-
-    URL url = server.url("/").url();
-    HttpURLConnection connection = openConnection(url);
-    assertEquals(body, readAscii(connection));
-    assertEquals(1, cacheCount.get());
-  }
-
-  /** Don't explode if the cache returns a null body. http://b/3373699 */
-  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
-    final AtomicBoolean aborted = new AtomicBoolean();
-    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) {
-        return new CacheRequest() {
-          @Override public void abort() {
-            aborted.set(true);
-          }
-
-          @Override public OutputStream getBody() {
-            return null;
-          }
-        };
-      }
-    }));
-
-    server.enqueue(new MockResponse().setBody("abcdef"));
-
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    assertEquals("abc", readAscii(connection, 3));
-    connection.getInputStream().close();
-    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
-  }
-
-  /**
-   * Fail if a badly-behaved cache returns a null status line header.
-   * https://code.google.com/p/android/issues/detail?id=160522
-   */
-  @Test public void responseCacheReturnsNullStatusLine() throws Exception {
-    String cachedContentString = "Hello";
-    final byte[] cachedContent = cachedContentString.getBytes(StandardCharsets.US_ASCII);
-
-    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
-      @Override
-      public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) {
-        return new CacheResponse() {
-          @Override public Map<String, List<String>> getHeaders() {
-            String contentType = "text/plain";
-            Map<String, List<String>> headers = new LinkedHashMap<>();
-            headers.put("Content-Length", Arrays.asList(Integer.toString(cachedContent.length)));
-            headers.put("Content-Type", Arrays.asList(contentType));
-            headers.put("Expires", Arrays.asList(formatDate(-1, TimeUnit.HOURS)));
-            headers.put("Cache-Control", Arrays.asList("max-age=60"));
-            // Crucially, the header with a null key is missing, which renders the cache response
-            // unusable because OkHttp only caches responses with cacheable response codes.
-            return headers;
-          }
-
-          @Override public InputStream getBody() {
-            return new ByteArrayInputStream(cachedContent);
-          }
-        };
-      }
-    }));
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    // If there was no status line from the cache an exception will be thrown. No network request
-    // should be made.
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  private static class InsecureResponseCache extends ResponseCache {
-
-    private final ResponseCache delegate;
-
-    private InsecureResponseCache(ResponseCache delegate) {
-      this.delegate = delegate;
-    }
-
-    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-      return delegate.put(uri, connection);
-    }
-
-    @Override public CacheResponse get(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) throws IOException {
-      final CacheResponse response = delegate.get(uri, requestMethod, requestHeaders);
-      if (response instanceof SecureCacheResponse) {
-        return new CacheResponse() {
-          @Override public InputStream getBody() throws IOException {
-            return response.getBody();
-          }
-
-          @Override public Map<String, List<String>> getHeaders() throws IOException {
-            return response.getHeaders();
-          }
-        };
-      }
-      return response;
-    }
-  }
-
-  @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
-    assumeFalse(getPlatform().equals("jdk9"));
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-
-    AndroidInternal.setResponseCache(urlFactory, new InsecureResponseCache(cache));
-
-    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    connection1.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
-    connection1.setHostnameVerifier(hostnameVerifier);
-    assertEquals("ABC", readAscii(connection1));
-
-    // Not cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.url("/").url());
-    connection2.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
-    connection2.setHostnameVerifier(hostnameVerifier);
-    assertEquals("DEF", readAscii(connection2));
-  }
-
-  @Test public void responseCacheRequestHeaders() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    final AtomicReference<Map<String, List<String>>> requestHeadersRef = new AtomicReference<>();
-    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) {
-        requestHeadersRef.set(requestHeaders);
-        return null;
-      }
-    }));
-
-    URL url = server.url("/").url();
-    URLConnection urlConnection = openConnection(url);
-    urlConnection.addRequestProperty("A", "android");
-    readAscii(urlConnection);
-    assertEquals(Arrays.asList("android"), requestHeadersRef.get().get("A"));
-  }
-
-  @Test public void responseCachingWithoutBody() throws IOException {
-    MockResponse response =
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .setStatus("HTTP/1.1 200 Fantastic");
-    server.enqueue(response);
-
-    HttpURLConnection urlConnection = openConnection(server.url("/").url());
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-    assertTrue(urlConnection.getDoInput());
-    InputStream is = urlConnection.getInputStream();
-    assertEquals(-1, is.read());
-    is.close();
-
-    urlConnection = openConnection(server.url("/").url()); // cached!
-    assertTrue(urlConnection.getDoInput());
-    InputStream cachedIs = urlConnection.getInputStream();
-    assertEquals(-1, cachedIs.read());
-    cachedIs.close();
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-  }
-
-  @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.setUseCaches(false);
-    assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.setUseCaches(false);
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
-    URL url = new URL("http://localhost/");
-    URLConnection c1 = openConnection(url);
-    URLConnection c2 = openConnection(url);
-    assertTrue(c1.getDefaultUseCaches());
-    c1.setDefaultUseCaches(false);
-    try {
-      assertTrue(c1.getUseCaches());
-      assertTrue(c2.getUseCaches());
-      URLConnection c3 = openConnection(url);
-      assertFalse(c3.getUseCaches());
-    } finally {
-      c1.setDefaultUseCaches(true);
-    }
-  }
-
-  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
-  // default ResponseCache. We try to keep this case working as much as possible because apps break
-  // if we don't.
-  @Test public void otherStacks_cacheHitWithoutVary() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("FAIL"));
-
-    // Set the cache as the shared cache.
-    ResponseCache.setDefault(cache);
-
-    // Use the platform's HTTP stack.
-    URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof OkHttpURLConnection);
-    assertEquals("A", readAscii(connection));
-
-    URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof OkHttpURLConnection);
-    assertEquals("A", readAscii(connection2));
-  }
-
-  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
-  // default ResponseCache. We can't keep the Vary case working because we can't get to the Vary
-  // request headers after connect(). Accept-Encoding has special behavior so we test it explicitly.
-  @Test public void otherStacks_cacheMissWithVaryAcceptEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    // Set the cache as the shared cache.
-    ResponseCache.setDefault(cache);
-
-    // Use the platform's HTTP stack.
-    URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof OkHttpURLConnection);
-    assertEquals("A", readAscii(connection));
-
-    URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof OkHttpURLConnection);
-    assertEquals("B", readAscii(connection2));
-  }
-
-  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
-  // default ResponseCache. We can't keep the Vary case working because we can't get to the Vary
-  // request headers after connect().
-  @Test public void otherStacks_cacheMissWithVary() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    // Set the cache as the shared cache.
-    ResponseCache.setDefault(cache);
-
-    // Use the platform's HTTP stack.
-    URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof OkHttpURLConnection);
-    connection.setRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection));
-
-    URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof OkHttpURLConnection);
-    assertEquals("B", readAscii(connection2));
-  }
-
-  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
-  // default ResponseCache. We can't keep the Vary case working, because we can't get to the Vary
-  // request headers after connect().
-  @Test public void otherStacks_cacheMissWithVaryAsterisk() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: *")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    // Set the cache as the shared cache.
-    ResponseCache.setDefault(cache);
-
-    // Use the platform's HTTP stack.
-    URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof OkHttpURLConnection);
-    assertEquals("A", readAscii(connection));
-
-    URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof OkHttpURLConnection);
-    assertEquals("B", readAscii(connection2));
-  }
-
-  private void setInternalCache(InternalCache internalCache) {
-    OkHttpClient.Builder builder = urlFactory.client().newBuilder();
-    Internal.instance.setCache(builder, internalCache);
-    urlFactory.setClient(builder.build());
-  }
-
-  private String getPlatform() {
-    return System.getProperty("okhttp.platform", "platform");
-  }
-}
diff --git a/okhttp-apache/README.md b/okhttp-apache/README.md
deleted file mode 100644
index ac71ec215a..0000000000
--- a/okhttp-apache/README.md
+++ /dev/null
@@ -1,7 +0,0 @@
-OkHttp Apache HttpClient Implementation
-=======================================
-
-This module is an implementation of the Apache `HttpClient` interface that is backed by OkHttp.
-
-**Warning**: Many core features of Apache HTTP client are not implemented by this API. This includes
-the keep-alive strategy, cookie store, credentials provider, route planner and others.
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
deleted file mode 100644
index 89b50f68e9..0000000000
--- a/okhttp-apache/pom.xml
+++ /dev/null
@@ -1,74 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-apache</artifactId>
-  <name>OkHttp Apache HttpClient</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.httpcomponents</groupId>
-      <artifactId>httpclient</artifactId>
-      <scope>provided</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>3.0.1</version>
-        <configuration>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-            <link>http://hc.apache.org/httpcomponents-client-4.3.x/httpclient/apidocs/</link>
-            <link>https://hc.apache.org/httpcomponents-core-4.3.x/httpcore/apidocs/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.apache</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java b/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
deleted file mode 100644
index c55543f569..0000000000
--- a/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package okhttp3.apache;
-
-import java.io.IOException;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okio.BufferedSink;
-import org.apache.http.HttpEntity;
-
-/** Adapts an {@link HttpEntity} to OkHttp's {@link RequestBody}. */
-final class HttpEntityBody extends RequestBody {
-  private static final MediaType DEFAULT_MEDIA_TYPE = MediaType.get("application/octet-stream");
-
-  private final HttpEntity entity;
-  private final MediaType mediaType;
-
-  HttpEntityBody(HttpEntity entity, String contentTypeHeader) {
-    this.entity = entity;
-
-    if (contentTypeHeader != null) {
-      mediaType = MediaType.parse(contentTypeHeader);
-    } else if (entity.getContentType() != null) {
-      mediaType = MediaType.parse(entity.getContentType().getValue());
-    } else {
-      // Apache is forgiving and lets you skip specifying a content type with an entity. OkHttp is
-      // not forgiving so we fall back to a generic type if it's missing.
-      mediaType = DEFAULT_MEDIA_TYPE;
-    }
-  }
-
-  @Override public long contentLength() {
-    return entity.getContentLength();
-  }
-
-  @Override public MediaType contentType() {
-    return mediaType;
-  }
-
-  @Override public void writeTo(BufferedSink sink) throws IOException {
-    entity.writeTo(sink.outputStream());
-  }
-}
diff --git a/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
deleted file mode 100644
index d1241d3d01..0000000000
--- a/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
+++ /dev/null
@@ -1,208 +0,0 @@
-// Copyright 2013 Square, Inc.
-package okhttp3.apache;
-
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import okhttp3.Headers;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Util;
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpEntityEnclosingRequest;
-import org.apache.http.HttpHost;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpResponse;
-import org.apache.http.RequestLine;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.ResponseHandler;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.conn.ClientConnectionManager;
-import org.apache.http.conn.params.ConnRouteParams;
-import org.apache.http.entity.InputStreamEntity;
-import org.apache.http.message.BasicHttpResponse;
-import org.apache.http.params.AbstractHttpParams;
-import org.apache.http.params.HttpParams;
-import org.apache.http.protocol.HttpContext;
-
-import static java.net.Proxy.Type.HTTP;
-import static org.apache.http.HttpVersion.HTTP_1_1;
-
-/**
- * @deprecated OkHttp will be dropping its ability to be used with {@link HttpClient} in an upcoming
- * release. Applications that need this should either downgrade to the Apache implementation or
- * upgrade to OkHttp's Request/Response API.
- */
-public final class OkApacheClient implements HttpClient {
-  private static Request transformRequest(HttpRequest request) {
-    Request.Builder builder = new Request.Builder();
-
-    RequestLine requestLine = request.getRequestLine();
-    String method = requestLine.getMethod();
-    builder.url(requestLine.getUri());
-
-    String contentType = null;
-    for (Header header : request.getAllHeaders()) {
-      String name = header.getName();
-      if ("Content-Type".equalsIgnoreCase(name)) {
-        contentType = header.getValue();
-      } else {
-        builder.header(name, header.getValue());
-      }
-    }
-
-    RequestBody body = null;
-    if (request instanceof HttpEntityEnclosingRequest) {
-      HttpEntity entity = ((HttpEntityEnclosingRequest) request).getEntity();
-      if (entity != null) {
-        // Wrap the entity in a custom Body which takes care of the content, length, and type.
-        body = new HttpEntityBody(entity, contentType);
-
-        Header encoding = entity.getContentEncoding();
-        if (encoding != null) {
-          builder.header(encoding.getName(), encoding.getValue());
-        }
-      } else {
-        body = Util.EMPTY_REQUEST;
-      }
-    }
-    builder.method(method, body);
-
-    return builder.build();
-  }
-
-  private static HttpResponse transformResponse(Response response) {
-    int code = response.code();
-    String message = response.message();
-    BasicHttpResponse httpResponse = new BasicHttpResponse(HTTP_1_1, code, message);
-
-    ResponseBody body = response.body();
-    InputStreamEntity entity = new InputStreamEntity(body.byteStream(), body.contentLength());
-    httpResponse.setEntity(entity);
-
-    Headers headers = response.headers();
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      String name = headers.name(i);
-      String value = headers.value(i);
-      httpResponse.addHeader(name, value);
-      if ("Content-Type".equalsIgnoreCase(name)) {
-        entity.setContentType(value);
-      } else if ("Content-Encoding".equalsIgnoreCase(name)) {
-        entity.setContentEncoding(value);
-      }
-    }
-
-    return httpResponse;
-  }
-
-  private final HttpParams params = new AbstractHttpParams() {
-    @Override public Object getParameter(String name) {
-      if (name.equals(ConnRouteParams.DEFAULT_PROXY)) {
-        Proxy proxy = client.proxy();
-        if (proxy == null) {
-          return null;
-        }
-        InetSocketAddress address = (InetSocketAddress) proxy.address();
-        return new HttpHost(address.getHostName(), address.getPort());
-      }
-      throw new IllegalArgumentException(name);
-    }
-
-    @Override public HttpParams setParameter(String name, Object value) {
-      if (name.equals(ConnRouteParams.DEFAULT_PROXY)) {
-        HttpHost host = (HttpHost) value;
-        Proxy proxy = null;
-        if (host != null) {
-          proxy = new Proxy(HTTP, new InetSocketAddress(host.getHostName(), host.getPort()));
-        }
-        client = client.newBuilder()
-            .proxy(proxy)
-            .build();
-        return this;
-      }
-      throw new IllegalArgumentException(name);
-    }
-
-    @Override public HttpParams copy() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public boolean removeParameter(String name) {
-      throw new UnsupportedOperationException();
-    }
-  };
-
-  private OkHttpClient client;
-
-  public OkApacheClient() {
-    this(new OkHttpClient());
-  }
-
-  public OkApacheClient(OkHttpClient client) {
-    this.client = client;
-  }
-
-  @Override public HttpParams getParams() {
-    return params;
-  }
-
-  @Override public ClientConnectionManager getConnectionManager() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override public HttpResponse execute(HttpUriRequest request) throws IOException {
-    return execute(null, request, (HttpContext) null);
-  }
-
-  @Override public HttpResponse execute(HttpUriRequest request, HttpContext context)
-      throws IOException {
-    return execute(null, request, context);
-  }
-
-  @Override public HttpResponse execute(HttpHost host, HttpRequest request) throws IOException {
-    return execute(host, request, (HttpContext) null);
-  }
-
-  @Override public HttpResponse execute(HttpHost host, HttpRequest request, HttpContext context)
-      throws IOException {
-    Request okRequest = transformRequest(request);
-    Response okResponse = client.newCall(okRequest).execute();
-    return transformResponse(okResponse);
-  }
-
-  @Override public <T> T execute(HttpUriRequest request, ResponseHandler<? extends T> handler)
-      throws IOException {
-    return execute(null, request, handler, null);
-  }
-
-  @Override public <T> T execute(HttpUriRequest request, ResponseHandler<? extends T> handler,
-      HttpContext context) throws IOException {
-    return execute(null, request, handler, context);
-  }
-
-  @Override public <T> T execute(HttpHost host, HttpRequest request,
-      ResponseHandler<? extends T> handler) throws IOException {
-    return execute(host, request, handler, null);
-  }
-
-  @Override public <T> T execute(HttpHost host, HttpRequest request,
-      ResponseHandler<? extends T> handler, HttpContext context) throws IOException {
-    HttpResponse response = execute(host, request, context);
-    try {
-      return handler.handleResponse(response);
-    } finally {
-      consumeContentQuietly(response);
-    }
-  }
-
-  private static void consumeContentQuietly(HttpResponse response) {
-    try {
-      response.getEntity().consumeContent();
-    } catch (Throwable ignored) {
-    }
-  }
-}
diff --git a/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java b/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
deleted file mode 100644
index f8482564ab..0000000000
--- a/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
+++ /dev/null
@@ -1,281 +0,0 @@
-package okhttp3.apache;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URISyntaxException;
-import java.util.zip.GZIPInputStream;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okio.Buffer;
-import okio.GzipSink;
-import okio.Okio;
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.client.methods.HttpPost;
-import org.apache.http.client.methods.HttpPut;
-import org.apache.http.entity.ByteArrayEntity;
-import org.apache.http.entity.InputStreamEntity;
-import org.apache.http.entity.StringEntity;
-import org.apache.http.util.EntityUtils;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-
-public class OkApacheClientTest {
-  private MockWebServer server;
-  private OkApacheClient client;
-
-  @Before public void setUp() throws IOException {
-    client = new OkApacheClient();
-    server = new MockWebServer();
-    server.start();
-  }
-
-  @After public void tearDown() throws IOException {
-    server.shutdown();
-  }
-
-  @Test public void success() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hello, World!"));
-
-    HttpGet request = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response = client.execute(request);
-    String actual = EntityUtils.toString(response.getEntity());
-    assertEquals("Hello, World!", actual);
-  }
-
-  @Test public void redirect() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(302).addHeader("Location", "/foo"));
-    server.enqueue(new MockResponse().setBody("Hello, Redirect!"));
-
-    HttpGet request = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response = client.execute(request);
-    String actual = EntityUtils.toString(response.getEntity(), UTF_8);
-    assertEquals("Hello, Redirect!", actual);
-  }
-
-  @Test public void sessionExpired() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(422));
-
-    HttpGet request = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response = client.execute(request);
-    assertEquals(422, response.getStatusLine().getStatusCode());
-  }
-
-  @Test public void headers() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Foo", "Bar"));
-    server.enqueue(new MockResponse().addHeader("Foo", "Bar").addHeader("Foo", "Baz"));
-
-    HttpGet request1 = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response1 = client.execute(request1);
-    Header[] headers1 = response1.getHeaders("Foo");
-    assertEquals(1, headers1.length);
-    assertEquals("Bar", headers1[0].getValue());
-
-    HttpGet request2 = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response2 = client.execute(request2);
-    Header[] headers2 = response2.getHeaders("Foo");
-    assertEquals(2, headers2.length);
-    assertEquals("Bar", headers2[0].getValue());
-    assertEquals("Baz", headers2[1].getValue());
-  }
-
-  @Test public void postByteEntity() throws Exception {
-    server.enqueue(new MockResponse());
-
-    final HttpPost post = new HttpPost(server.url("/").url().toURI());
-    byte[] body = "Hello, world!".getBytes(UTF_8);
-    post.setEntity(new ByteArrayEntity(body));
-    client.execute(post);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("Hello, world!", request.getBody().readUtf8());
-    assertEquals(request.getHeader("Content-Length"), "13");
-  }
-
-  @Test public void postInputStreamEntity() throws Exception {
-    server.enqueue(new MockResponse());
-
-    final HttpPost post = new HttpPost(server.url("/").url().toURI());
-    byte[] body = "Hello, world!".getBytes(UTF_8);
-    post.setEntity(new InputStreamEntity(new ByteArrayInputStream(body), body.length));
-    client.execute(post);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("Hello, world!", request.getBody().readUtf8());
-    assertEquals(request.getHeader("Content-Length"), "13");
-  }
-
-  @Test public void postEmptyEntity() throws Exception {
-    server.enqueue(new MockResponse());
-    final HttpPost post = new HttpPost(server.url("/").url().toURI());
-    client.execute(post);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(0, request.getBodySize());
-    assertNotNull(request.getBody());
-  }
-
-  @Test public void putEmptyEntity() throws Exception {
-    server.enqueue(new MockResponse());
-    final HttpPut put = new HttpPut(server.url("/").url().toURI());
-    client.execute(put);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(0, request.getBodySize());
-    assertNotNull(request.getBody());
-  }
-
-  @Test public void postOverrideContentType() throws Exception {
-    server.enqueue(new MockResponse());
-
-    HttpPost httpPost = new HttpPost();
-    httpPost.setURI(server.url("/").url().toURI());
-    httpPost.addHeader("Content-Type", "application/xml");
-    httpPost.setEntity(new StringEntity("<yo/>"));
-    client.execute(httpPost);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(request.getHeader("Content-Type"), "application/xml");
-  }
-
-  @Test public void contentType() throws Exception {
-    server.enqueue(new MockResponse().setBody("<html><body><h1>Hello, World!</h1></body></html>")
-        .setHeader("Content-Type", "text/html"));
-    server.enqueue(new MockResponse().setBody("{\"Message\": { \"text\": \"Hello, World!\" } }")
-        .setHeader("Content-Type", "application/json"));
-    server.enqueue(new MockResponse().setBody("Hello, World!"));
-
-    HttpGet request1 = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response1 = client.execute(request1);
-    Header[] headers1 = response1.getHeaders("Content-Type");
-    assertEquals(1, headers1.length);
-    assertEquals("text/html", headers1[0].getValue());
-    assertNotNull(response1.getEntity().getContentType());
-    assertEquals("text/html", response1.getEntity().getContentType().getValue());
-
-    HttpGet request2 = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response2 = client.execute(request2);
-    Header[] headers2 = response2.getHeaders("Content-Type");
-    assertEquals(1, headers2.length);
-    assertEquals("application/json", headers2[0].getValue());
-    assertNotNull(response2.getEntity().getContentType());
-    assertEquals("application/json", response2.getEntity().getContentType().getValue());
-
-    HttpGet request3 = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response3 = client.execute(request3);
-    Header[] headers3 = response3.getHeaders("Content-Type");
-    assertEquals(0, headers3.length);
-    assertNull(response3.getEntity().getContentType());
-  }
-
-  @Test public void contentTypeIsCaseInsensitive() throws URISyntaxException, IOException {
-    server.enqueue(new MockResponse().setBody("{\"Message\": { \"text\": \"Hello, World!\" } }")
-        .setHeader("cONTENT-tYPE", "application/json"));
-
-    HttpGet request = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response = client.execute(request);
-    assertEquals("application/json", response.getEntity().getContentType().getValue());
-  }
-
-  @Test public void contentEncoding() throws Exception {
-    String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
-    server.enqueue(new MockResponse().setBody(gzip(text))
-        .setHeader("Content-Encoding", "gzip"));
-
-    HttpGet request = new HttpGet(server.url("/").url().toURI());
-    request.setHeader("Accept-encoding", "gzip"); // Not transparent gzip.
-    HttpResponse response = client.execute(request);
-    HttpEntity entity = response.getEntity();
-
-    Header[] encodingHeaders = response.getHeaders("Content-Encoding");
-    assertEquals(1, encodingHeaders.length);
-    assertEquals("gzip", encodingHeaders[0].getValue());
-    assertNotNull(entity.getContentEncoding());
-    assertEquals("gzip", entity.getContentEncoding().getValue());
-
-    assertEquals(text, gunzip(entity));
-  }
-
-  @Test public void jsonGzipResponse() throws Exception {
-    String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
-    server.enqueue(new MockResponse().setBody(gzip(text))
-        .setHeader("Content-Encoding", "gzip")
-        .setHeader("Content-Type", "application/json"));
-
-    HttpGet request1 = new HttpGet(server.url("/").url().toURI());
-    request1.setHeader("Accept-encoding", "gzip"); // Not transparent gzip.
-
-    HttpResponse response = client.execute(request1);
-    HttpEntity entity = response.getEntity();
-
-    Header[] encodingHeaders = response.getHeaders("Content-Encoding");
-    assertEquals(1, encodingHeaders.length);
-    assertEquals("gzip", encodingHeaders[0].getValue());
-    assertNotNull(entity.getContentEncoding());
-    assertEquals("gzip", entity.getContentEncoding().getValue());
-
-    Header[] typeHeaders = response.getHeaders("Content-Type");
-    assertEquals(1, typeHeaders.length);
-    assertEquals("application/json", typeHeaders[0].getValue());
-    assertNotNull(entity.getContentType());
-    assertEquals("application/json", entity.getContentType().getValue());
-
-    assertEquals(text, gunzip(entity));
-  }
-
-  @Test public void jsonTransparentGzipResponse() throws Exception {
-    String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
-    server.enqueue(new MockResponse().setBody(gzip(text))
-        .setHeader("Content-Encoding", "gzip")
-        .setHeader("Content-Type", "application/json"));
-
-    HttpGet request = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response = client.execute(request);
-    HttpEntity entity = response.getEntity();
-
-    // Expecting transparent gzip response by not adding header "Accept-encoding: gzip"
-    Header[] encodingHeaders = response.getHeaders("Content-Encoding");
-    assertEquals(0, encodingHeaders.length);
-    assertNull(entity.getContentEncoding());
-
-    // Content length should be absent.
-    Header[] lengthHeaders = response.getHeaders("Content-Length");
-    assertEquals(0, lengthHeaders.length);
-    assertEquals(-1, entity.getContentLength());
-
-    Header[] typeHeaders = response.getHeaders("Content-Type");
-    assertEquals(1, typeHeaders.length);
-    assertEquals("application/json", typeHeaders[0].getValue());
-    assertNotNull(entity.getContentType());
-    assertEquals("application/json", entity.getContentType().getValue());
-
-    assertEquals(text, EntityUtils.toString(entity, UTF_8));
-  }
-
-  private static Buffer gzip(String body) throws IOException {
-    Buffer buffer = new Buffer();
-    Okio.buffer(new GzipSink(buffer)).writeUtf8(body).close();
-    return buffer;
-  }
-
-  private static String gunzip(HttpEntity body) throws IOException {
-    InputStream in = new GZIPInputStream(body.getContent());
-    Buffer buffer = new Buffer();
-    byte[] temp = new byte[1024];
-    int read;
-    while ((read = in.read(temp)) != -1) {
-      buffer.write(temp, 0, read);
-    }
-    return buffer.readUtf8();
-  }
-}
diff --git a/okhttp-dnsoverhttps/build.gradle b/okhttp-dnsoverhttps/build.gradle
new file mode 100644
index 0000000000..1a9f104092
--- /dev/null
+++ b/okhttp-dnsoverhttps/build.gradle
@@ -0,0 +1,18 @@
+apply plugin: 'com.vanniktech.maven.publish'
+
+jar {
+  manifest {
+    attributes('Automatic-Module-Name': 'okhttp3.dnsoverhttps')
+  }
+}
+
+dependencies {
+  api project(':okhttp')
+  compileOnly deps.jsr305
+
+  testImplementation project(':okhttp-testing-support')
+  testImplementation project(':mockwebserver')
+  testImplementation deps.conscrypt
+  testImplementation deps.junit
+  testImplementation deps.assertj
+}
diff --git a/okhttp-dnsoverhttps/gradle.properties b/okhttp-dnsoverhttps/gradle.properties
new file mode 100644
index 0000000000..bd908aaa26
--- /dev/null
+++ b/okhttp-dnsoverhttps/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=okhttp-dnsoverhttps
+POM_NAME=okhttp-dnsoverhttps
+POM_PACKAGING=jar
diff --git a/okhttp-dnsoverhttps/pom.xml b/okhttp-dnsoverhttps/pom.xml
deleted file mode 100644
index b5ad646bf9..0000000000
--- a/okhttp-dnsoverhttps/pom.xml
+++ /dev/null
@@ -1,67 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-dnsoverhttps</artifactId>
-  <name>OkHttp DNS over HTTPS</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.conscrypt</groupId>
-      <artifactId>conscrypt-openjdk-uber</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.dnsoverhttps</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.kt
similarity index 53%
rename from okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.java
rename to okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.kt
index 2cd474d30b..5523487838 100644
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.java
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.kt
@@ -13,33 +13,29 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.dnsoverhttps;
+package okhttp3.dnsoverhttps
 
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.List;
-import okhttp3.Dns;
+import okhttp3.Dns
+import java.net.InetAddress
+import java.net.UnknownHostException
 
 /**
  * Internal Bootstrap DNS implementation for handling initial connection to DNS over HTTPS server.
  *
  * Returns hardcoded results for the known host.
  */
-final class BootstrapDns implements Dns {
-  private final String dnsHostname;
-  private final List<InetAddress> dnsServers;
-
-  BootstrapDns(String dnsHostname, List<InetAddress> dnsServers) {
-    this.dnsHostname = dnsHostname;
-    this.dnsServers = dnsServers;
-  }
-
-  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-    if (!this.dnsHostname.equals(hostname)) {
-      throw new UnknownHostException(
-          "BootstrapDns called for " + hostname + " instead of " + dnsHostname);
+internal class BootstrapDns(
+  private val dnsHostname: String,
+  private val dnsServers: List<InetAddress>
+) : Dns {
+  @Throws(UnknownHostException::class)
+  override fun lookup(hostname: String): List<InetAddress> {
+    if (this.dnsHostname != hostname) {
+      throw UnknownHostException(
+          "BootstrapDns called for $hostname instead of $dnsHostname"
+      )
     }
 
-    return dnsServers;
+    return dnsServers
   }
 }
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java
deleted file mode 100644
index 67442f3313..0000000000
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java
+++ /dev/null
@@ -1,359 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.dnsoverhttps;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import javax.annotation.Nullable;
-import okhttp3.CacheControl;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.Dns;
-import okhttp3.HttpUrl;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Util;
-import okhttp3.internal.platform.Platform;
-import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
-import okio.ByteString;
-
-/**
- * DNS over HTTPS implementation.
- *
- * Implementation of https://tools.ietf.org/html/draft-ietf-doh-dns-over-https-13
- *
- * <blockquote>A DNS API client encodes a single DNS query into an HTTP request
- * using either the HTTP GET or POST method and the other requirements
- * of this section.  The DNS API server defines the URI used by the
- * request through the use of a URI Template.</blockquote>
- *
- * <h3>Warning: This is a non-final API.</h3>
- *
- * <p><strong>As of OkHttp 3.11, this feature is an unstable preview: the API is subject to change,
- * and the implementation is incomplete. We expect that OkHttp 3.12 or 3.13 will finalize this API.
- * Until then, expect API and behavior changes when you update your OkHttp dependency.</strong>
- */
-public class DnsOverHttps implements Dns {
-  public static final MediaType DNS_MESSAGE = MediaType.get("application/dns-message");
-  public static final int MAX_RESPONSE_SIZE = 64 * 1024;
-  private final OkHttpClient client;
-  private final HttpUrl url;
-  private final boolean includeIPv6;
-  private final boolean post;
-  private final boolean resolvePrivateAddresses;
-  private final boolean resolvePublicAddresses;
-
-  DnsOverHttps(Builder builder) {
-    if (builder.client == null) {
-      throw new NullPointerException("client not set");
-    }
-    if (builder.url == null) {
-      throw new NullPointerException("url not set");
-    }
-
-    this.url = builder.url;
-    this.includeIPv6 = builder.includeIPv6;
-    this.post = builder.post;
-    this.resolvePrivateAddresses = builder.resolvePrivateAddresses;
-    this.resolvePublicAddresses = builder.resolvePublicAddresses;
-    this.client = builder.client.newBuilder().dns(buildBootstrapClient(builder)).build();
-  }
-
-  private static Dns buildBootstrapClient(Builder builder) {
-    List<InetAddress> hosts = builder.bootstrapDnsHosts;
-
-    if (hosts != null) {
-      return new BootstrapDns(builder.url.host(), hosts);
-    } else {
-      return builder.systemDns;
-    }
-  }
-
-  public HttpUrl url() {
-    return url;
-  }
-
-  public boolean post() {
-    return post;
-  }
-
-  public boolean includeIPv6() {
-    return includeIPv6;
-  }
-
-  public OkHttpClient client() {
-    return client;
-  }
-
-  public boolean resolvePrivateAddresses() {
-    return resolvePrivateAddresses;
-  }
-
-  public boolean resolvePublicAddresses() {
-    return resolvePublicAddresses;
-  }
-
-  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-    if (!resolvePrivateAddresses || !resolvePublicAddresses) {
-      boolean privateHost = isPrivateHost(hostname);
-
-      if (privateHost && !resolvePrivateAddresses) {
-        throw new UnknownHostException("private hosts not resolved");
-      }
-
-      if (!privateHost && !resolvePublicAddresses) {
-        throw new UnknownHostException("public hosts not resolved");
-      }
-    }
-
-    return lookupHttps(hostname);
-  }
-
-  private List<InetAddress> lookupHttps(String hostname) throws UnknownHostException {
-    List<Call> networkRequests = new ArrayList<>(2);
-    List<Exception> failures = new ArrayList<>(2);
-    List<InetAddress> results = new ArrayList<>(5);
-
-    buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_A);
-
-    if (includeIPv6) {
-      buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_AAAA);
-    }
-
-    executeRequests(hostname, networkRequests, results, failures);
-
-    if (!results.isEmpty()) {
-      return results;
-    }
-
-    return throwBestFailure(hostname, failures);
-  }
-
-  private void buildRequest(String hostname, List<Call> networkRequests, List<InetAddress> results,
-      List<Exception> failures, int type) {
-    Request request = buildRequest(hostname, type);
-    Response response = getCacheOnlyResponse(request);
-
-    if (response != null) {
-      processResponse(response, hostname, results, failures);
-    } else {
-      networkRequests.add(client.newCall(request));
-    }
-  }
-
-  private void executeRequests(final String hostname, List<Call> networkRequests,
-      final List<InetAddress> responses, final List<Exception> failures) {
-    final CountDownLatch latch = new CountDownLatch(networkRequests.size());
-
-    for (Call call : networkRequests) {
-      call.enqueue(new Callback() {
-        @Override public void onFailure(Call call, IOException e) {
-          synchronized (failures) {
-            failures.add(e);
-          }
-          latch.countDown();
-        }
-
-        @Override public void onResponse(Call call, Response response) {
-          processResponse(response, hostname, responses, failures);
-          latch.countDown();
-        }
-      });
-    }
-
-    try {
-      latch.await();
-    } catch (InterruptedException e) {
-      failures.add(e);
-    }
-  }
-
-  private void processResponse(Response response, String hostname, List<InetAddress> results,
-      List<Exception> failures) {
-    try {
-      List<InetAddress> addresses = readResponse(hostname, response);
-      synchronized (results) {
-        results.addAll(addresses);
-      }
-    } catch (Exception e) {
-      synchronized (failures) {
-        failures.add(e);
-      }
-    }
-  }
-
-  private List<InetAddress> throwBestFailure(String hostname, List<Exception> failures)
-      throws UnknownHostException {
-    if (failures.size() == 0) {
-      throw new UnknownHostException(hostname);
-    }
-
-    Exception failure = failures.get(0);
-
-    if (failure instanceof UnknownHostException) {
-      throw (UnknownHostException) failure;
-    }
-
-    UnknownHostException unknownHostException = new UnknownHostException(hostname);
-    unknownHostException.initCause(failure);
-
-    for (int i = 1; i < failures.size(); i++) {
-      Util.addSuppressedIfPossible(unknownHostException, failures.get(i));
-    }
-
-    throw unknownHostException;
-  }
-
-  private @Nullable Response getCacheOnlyResponse(Request request) {
-    if (!post && client.cache() != null) {
-      try {
-        Request cacheRequest = request.newBuilder().cacheControl(CacheControl.FORCE_CACHE).build();
-
-        Response cacheResponse = client.newCall(cacheRequest).execute();
-
-        if (cacheResponse.code() != 504) {
-          return cacheResponse;
-        }
-      } catch (IOException ioe) {
-        // Failures are ignored as we can fallback to the network
-        // and hopefully repopulate the cache.
-      }
-    }
-
-    return null;
-  }
-
-  private List<InetAddress> readResponse(String hostname, Response response) throws Exception {
-    if (response.cacheResponse() == null && response.protocol() != Protocol.HTTP_2) {
-      Platform.get().log(Platform.WARN, "Incorrect protocol: " + response.protocol(), null);
-    }
-
-    try {
-      if (!response.isSuccessful()) {
-        throw new IOException("response: " + response.code() + " " + response.message());
-      }
-
-      ResponseBody body = response.body();
-
-      if (body.contentLength() > MAX_RESPONSE_SIZE) {
-        throw new IOException("response size exceeds limit ("
-            + MAX_RESPONSE_SIZE
-            + " bytes): "
-            + body.contentLength()
-            + " bytes");
-      }
-
-      ByteString responseBytes = body.source().readByteString();
-
-      return DnsRecordCodec.decodeAnswers(hostname, responseBytes);
-    } finally {
-      response.close();
-    }
-  }
-
-  private Request buildRequest(String hostname, int type) {
-    Request.Builder requestBuilder = new Request.Builder().header("Accept", DNS_MESSAGE.toString());
-
-    ByteString query = DnsRecordCodec.encodeQuery(hostname, type);
-
-    if (post) {
-      requestBuilder = requestBuilder.url(url).post(RequestBody.create(DNS_MESSAGE, query));
-    } else {
-      String encoded = query.base64Url().replace("=", "");
-      HttpUrl requestUrl = url.newBuilder().addQueryParameter("dns", encoded).build();
-
-      requestBuilder = requestBuilder.url(requestUrl);
-    }
-
-    return requestBuilder.build();
-  }
-
-  static boolean isPrivateHost(String host) {
-    return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host) == null;
-  }
-
-  public static final class Builder {
-    @Nullable OkHttpClient client = null;
-    @Nullable HttpUrl url = null;
-    boolean includeIPv6 = true;
-    boolean post = false;
-    Dns systemDns = Dns.SYSTEM;
-    @Nullable List<InetAddress> bootstrapDnsHosts = null;
-    boolean resolvePrivateAddresses = false;
-    boolean resolvePublicAddresses = true;
-
-    public Builder() {
-    }
-
-    public DnsOverHttps build() {
-      return new DnsOverHttps(this);
-    }
-
-    public Builder client(OkHttpClient client) {
-      this.client = client;
-      return this;
-    }
-
-    public Builder url(HttpUrl url) {
-      this.url = url;
-      return this;
-    }
-
-    public Builder includeIPv6(boolean includeIPv6) {
-      this.includeIPv6 = includeIPv6;
-      return this;
-    }
-
-    public Builder post(boolean post) {
-      this.post = post;
-      return this;
-    }
-
-    public Builder resolvePrivateAddresses(boolean resolvePrivateAddresses) {
-      this.resolvePrivateAddresses = resolvePrivateAddresses;
-      return this;
-    }
-
-    public Builder resolvePublicAddresses(boolean resolvePublicAddresses) {
-      this.resolvePublicAddresses = resolvePublicAddresses;
-      return this;
-    }
-
-    public Builder bootstrapDnsHosts(@Nullable List<InetAddress> bootstrapDnsHosts) {
-      this.bootstrapDnsHosts = bootstrapDnsHosts;
-      return this;
-    }
-
-    public Builder bootstrapDnsHosts(InetAddress... bootstrapDnsHosts) {
-      return bootstrapDnsHosts(Arrays.asList(bootstrapDnsHosts));
-    }
-
-    public Builder systemDns(Dns systemDns) {
-      this.systemDns = systemDns;
-      return this;
-    }
-  }
-}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt
new file mode 100644
index 0000000000..5f088fa71b
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt
@@ -0,0 +1,331 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps
+
+import okhttp3.CacheControl
+import okhttp3.Call
+import okhttp3.Callback
+import okhttp3.Dns
+import okhttp3.HttpUrl
+import okhttp3.MediaType
+import okhttp3.OkHttpClient
+import okhttp3.Protocol
+import okhttp3.Request
+import okhttp3.RequestBody
+import okhttp3.Response
+import okhttp3.internal.platform.Platform
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase
+import java.io.IOException
+import java.net.InetAddress
+import java.net.UnknownHostException
+import java.util.ArrayList
+import java.util.concurrent.CountDownLatch
+
+/**
+ * [DNS over HTTPS implementation][[doh_spec]].
+ *
+ * <blockquote>A DNS API client encodes a single DNS query into an HTTP request
+ * using either the HTTP GET or POST method and the other requirements
+ * of this section.  The DNS API server defines the URI used by the
+ * request through the use of a URI Template.</blockquote>
+ *
+ * <h3>Warning: This is a non-final API.</h3>
+ *
+ * As of OkHttp 3.14, this feature is an unstable preview: the API is subject to change,
+ * and the implementation is incomplete. We expect that OkHttp 4.0 or 4.1 will finalize this API.
+ * Until then, expect API and behavior changes when you update your OkHttp dependency.**
+ *
+ * [doh_spec]: https://tools.ietf.org/html/draft-ietf-doh-dns-over-https-13
+ */
+class DnsOverHttps internal constructor(builder: Builder) : Dns {
+  private val client: OkHttpClient =
+      builder.client?.newBuilder()?.dns(buildBootstrapClient(builder))?.build()
+          ?: throw NullPointerException("client not set")
+  private val url: HttpUrl = builder.url ?: throw NullPointerException("url not set")
+  private val includeIPv6: Boolean = builder.includeIPv6
+  private val post: Boolean = builder.post
+  private val resolvePrivateAddresses: Boolean = builder.resolvePrivateAddresses
+  private val resolvePublicAddresses: Boolean = builder.resolvePublicAddresses
+
+  fun url(): HttpUrl = url
+
+  fun post(): Boolean = post
+
+  fun includeIPv6(): Boolean = includeIPv6
+
+  fun client(): OkHttpClient = client
+
+  fun resolvePrivateAddresses(): Boolean = resolvePrivateAddresses
+
+  fun resolvePublicAddresses(): Boolean = resolvePublicAddresses
+
+  @Throws(UnknownHostException::class)
+  override fun lookup(hostname: String): List<InetAddress> {
+    if (!resolvePrivateAddresses || !resolvePublicAddresses) {
+      val privateHost = isPrivateHost(hostname)
+
+      if (privateHost && !resolvePrivateAddresses) {
+        throw UnknownHostException("private hosts not resolved")
+      }
+
+      if (!privateHost && !resolvePublicAddresses) {
+        throw UnknownHostException("public hosts not resolved")
+      }
+    }
+
+    return lookupHttps(hostname)
+  }
+
+  @Throws(UnknownHostException::class)
+  private fun lookupHttps(hostname: String): List<InetAddress> {
+    val networkRequests = ArrayList<Call>(2)
+    val failures = ArrayList<Exception>(2)
+    val results = ArrayList<InetAddress>(5)
+
+    buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_A)
+
+    if (includeIPv6) {
+      buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_AAAA)
+    }
+
+    executeRequests(hostname, networkRequests, results, failures)
+
+    return if (!results.isEmpty()) {
+      results
+    } else {
+      throwBestFailure(hostname, failures)
+    }
+  }
+
+  private fun buildRequest(
+    hostname: String,
+    networkRequests: MutableList<Call>,
+    results: MutableList<InetAddress>,
+    failures: MutableList<Exception>,
+    type: Int
+  ) {
+    val request = buildRequest(hostname, type)
+    val response = getCacheOnlyResponse(request)
+
+    response?.let { processResponse(it, hostname, results, failures) } ?: networkRequests.add(
+        client.newCall(request))
+  }
+
+  private fun executeRequests(
+    hostname: String,
+    networkRequests: List<Call>,
+    responses: MutableList<InetAddress>,
+    failures: MutableList<Exception>
+  ) {
+    val latch = CountDownLatch(networkRequests.size)
+
+    for (call in networkRequests) {
+      call.enqueue(object : Callback {
+        override fun onFailure(call: Call, e: IOException) {
+          synchronized(failures) {
+            failures.add(e)
+          }
+          latch.countDown()
+        }
+
+        override fun onResponse(call: Call, response: Response) {
+          processResponse(response, hostname, responses, failures)
+          latch.countDown()
+        }
+      })
+    }
+
+    try {
+      latch.await()
+    } catch (e: InterruptedException) {
+      failures.add(e)
+    }
+  }
+
+  private fun processResponse(
+    response: Response,
+    hostname: String,
+    results: MutableList<InetAddress>,
+    failures: MutableList<Exception>
+  ) {
+    try {
+      val addresses = readResponse(hostname, response)
+      synchronized(results) {
+        results.addAll(addresses)
+      }
+    } catch (e: Exception) {
+      synchronized(failures) {
+        failures.add(e)
+      }
+    }
+  }
+
+  @Throws(UnknownHostException::class)
+  private fun throwBestFailure(hostname: String, failures: List<Exception>): List<InetAddress> {
+    if (failures.isEmpty()) {
+      throw UnknownHostException(hostname)
+    }
+
+    val failure = failures[0]
+
+    if (failure is UnknownHostException) {
+      throw failure
+    }
+
+    val unknownHostException = UnknownHostException(hostname)
+    unknownHostException.initCause(failure)
+
+    for (i in 1 until failures.size) {
+      unknownHostException.addSuppressed(failures[i])
+    }
+
+    throw unknownHostException
+  }
+
+  private fun getCacheOnlyResponse(request: Request): Response? {
+    if (!post && client.cache() != null) {
+      try {
+        val cacheRequest = request.newBuilder().cacheControl(CacheControl.FORCE_CACHE).build()
+
+        val cacheResponse = client.newCall(cacheRequest).execute()
+
+        if (cacheResponse.code() != 504) {
+          return cacheResponse
+        }
+      } catch (ioe: IOException) {
+        // Failures are ignored as we can fallback to the network
+        // and hopefully repopulate the cache.
+      }
+    }
+
+    return null
+  }
+
+  @Throws(Exception::class)
+  private fun readResponse(hostname: String, response: Response): List<InetAddress> {
+    if (response.cacheResponse() == null && response.protocol() !== Protocol.HTTP_2) {
+      Platform.get().log(Platform.WARN, "Incorrect protocol: ${response.protocol()}", null)
+    }
+
+    response.use {
+      if (!response.isSuccessful) {
+        throw IOException("response: " + response.code() + " " + response.message())
+      }
+
+      val body = response.body()
+
+      if (body!!.contentLength() > MAX_RESPONSE_SIZE) {
+        throw IOException(
+            "response size exceeds limit ($MAX_RESPONSE_SIZE bytes): ${body.contentLength()} bytes"
+        )
+      }
+
+      val responseBytes = body.source().readByteString()
+
+      return DnsRecordCodec.decodeAnswers(hostname, responseBytes)
+    }
+  }
+
+  private fun buildRequest(hostname: String, type: Int): Request =
+      Request.Builder().header("Accept", DNS_MESSAGE.toString()).apply {
+        val query = DnsRecordCodec.encodeQuery(hostname, type)
+
+        if (post) {
+          url(url).post(RequestBody.create(DNS_MESSAGE, query))
+        } else {
+          val encoded = query.base64Url().replace("=", "")
+          val requestUrl = url.newBuilder().addQueryParameter("dns", encoded).build()
+
+          url(requestUrl)
+        }
+      }.build()
+
+  class Builder {
+    internal var client: OkHttpClient? = null
+    internal var url: HttpUrl? = null
+    internal var includeIPv6 = true
+    internal var post = false
+    internal var systemDns = Dns.SYSTEM
+    internal var bootstrapDnsHosts: List<InetAddress>? = null
+    internal var resolvePrivateAddresses = false
+    internal var resolvePublicAddresses = true
+
+    fun build(): DnsOverHttps = DnsOverHttps(this)
+
+    fun client(client: OkHttpClient): Builder {
+      this.client = client
+      return this
+    }
+
+    fun url(url: HttpUrl): Builder {
+      this.url = url
+      return this
+    }
+
+    fun includeIPv6(includeIPv6: Boolean): Builder {
+      this.includeIPv6 = includeIPv6
+      return this
+    }
+
+    fun post(post: Boolean): Builder {
+      this.post = post
+      return this
+    }
+
+    fun resolvePrivateAddresses(resolvePrivateAddresses: Boolean): Builder {
+      this.resolvePrivateAddresses = resolvePrivateAddresses
+      return this
+    }
+
+    fun resolvePublicAddresses(resolvePublicAddresses: Boolean): Builder {
+      this.resolvePublicAddresses = resolvePublicAddresses
+      return this
+    }
+
+    fun bootstrapDnsHosts(bootstrapDnsHosts: List<InetAddress>?): Builder {
+      this.bootstrapDnsHosts = bootstrapDnsHosts
+      return this
+    }
+
+    fun bootstrapDnsHosts(vararg bootstrapDnsHosts: InetAddress): Builder {
+      return bootstrapDnsHosts(bootstrapDnsHosts.toList())
+    }
+
+    fun systemDns(systemDns: Dns): Builder {
+      this.systemDns = systemDns
+      return this
+    }
+  }
+
+  companion object {
+    val DNS_MESSAGE: MediaType = MediaType.get("application/dns-message")
+    const val MAX_RESPONSE_SIZE = 64 * 1024
+
+    private fun buildBootstrapClient(builder: Builder): Dns {
+      val hosts = builder.bootstrapDnsHosts
+
+      return if (hosts != null) {
+        BootstrapDns(builder.url!!.host(), hosts)
+      } else {
+        builder.systemDns
+      }
+    }
+
+    internal fun isPrivateHost(host: String): Boolean {
+      return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host) == null
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java
deleted file mode 100644
index 4c1cfc481e..0000000000
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright 2016 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at:
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package okhttp3.dnsoverhttps;
-
-import java.io.EOFException;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.List;
-import okio.Buffer;
-import okio.ByteString;
-import okio.Utf8;
-
-/**
- * Trivial Dns Encoder/Decoder, basically ripped from Netty full implementation.
- */
-class DnsRecordCodec {
-  private static final byte SERVFAIL = 2;
-  private static final byte NXDOMAIN = 3;
-  public static final int TYPE_A = 0x0001;
-  public static final int TYPE_AAAA = 0x001c;
-  private static final int TYPE_PTR = 0x000c;
-  private static final Charset ASCII = Charset.forName("ASCII");
-
-  private DnsRecordCodec() {
-  }
-
-  public static ByteString encodeQuery(String host, int type) {
-    Buffer buf = new Buffer();
-
-    buf.writeShort(0); // query id
-    buf.writeShort(256); // flags with recursion
-    buf.writeShort(1); // question count
-    buf.writeShort(0); // answerCount
-    buf.writeShort(0); // authorityResourceCount
-    buf.writeShort(0); // additional
-
-    Buffer nameBuf = new Buffer();
-    final String[] labels = host.split("\\.");
-    for (String label : labels) {
-      long utf8ByteCount = Utf8.size(label);
-      if (utf8ByteCount != label.length()) {
-        throw new IllegalArgumentException("non-ascii hostname: " + host);
-      }
-      nameBuf.writeByte((byte) utf8ByteCount);
-      nameBuf.writeUtf8(label);
-    }
-    nameBuf.writeByte(0); // end
-
-    nameBuf.copyTo(buf, 0, nameBuf.size());
-    buf.writeShort(type);
-    buf.writeShort(1); // CLASS_IN
-
-    return buf.readByteString();
-  }
-
-  public static List<InetAddress> decodeAnswers(String hostname, ByteString byteString)
-      throws Exception {
-    List<InetAddress> result = new ArrayList<>();
-
-    Buffer buf = new Buffer();
-    buf.write(byteString);
-    buf.readShort(); // query id
-
-    final int flags = buf.readShort() & 0xffff;
-    if (flags >> 15 == 0) {
-      throw new IllegalArgumentException("not a response");
-    }
-
-    byte responseCode = (byte) (flags & 0xf);
-
-    if (responseCode == NXDOMAIN) {
-      throw new UnknownHostException(hostname + ": NXDOMAIN");
-    } else if (responseCode == SERVFAIL) {
-      throw new UnknownHostException(hostname + ": SERVFAIL");
-    }
-
-    final int questionCount = buf.readShort() & 0xffff;
-    final int answerCount = buf.readShort() & 0xffff;
-    buf.readShort(); // authority record count
-    buf.readShort(); // additional record count
-
-    for (int i = 0; i < questionCount; i++) {
-      skipName(buf); // name
-      buf.readShort(); // type
-      buf.readShort(); // class
-    }
-
-    for (int i = 0; i < answerCount; i++) {
-      skipName(buf); // name
-
-      int type = buf.readShort() & 0xffff;
-      buf.readShort(); // class
-      final long ttl = buf.readInt() & 0xffffffffL; // ttl
-      final int length = buf.readShort() & 0xffff;
-
-      if (type == TYPE_A || type == TYPE_AAAA) {
-        byte[] bytes = new byte[length];
-        buf.read(bytes);
-        result.add(InetAddress.getByAddress(bytes));
-      } else {
-        buf.skip(length);
-      }
-    }
-
-    return result;
-  }
-
-  private static void skipName(Buffer in) throws EOFException {
-    // 0 - 63 bytes
-    int length = in.readByte();
-
-    if (length < 0) {
-      // compressed name pointer, first two bits are 1
-      // drop second byte of compression offset
-      in.skip(1);
-    } else {
-      while (length > 0) {
-        // skip each part of the domain name
-        in.skip(length);
-        length = in.readByte();
-      }
-    }
-  }
-}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt
new file mode 100644
index 0000000000..0551d39f6f
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package okhttp3.dnsoverhttps
+
+import okio.Buffer
+import okio.ByteString
+import okio.utf8Size
+import java.io.EOFException
+import java.net.InetAddress
+import java.net.UnknownHostException
+import java.nio.charset.StandardCharsets
+import java.util.ArrayList
+
+/**
+ * Trivial Dns Encoder/Decoder, basically ripped from Netty full implementation.
+ */
+object DnsRecordCodec {
+  private const val SERVFAIL = 2
+  private const val NXDOMAIN = 3
+  const val TYPE_A = 0x0001
+  const val TYPE_AAAA = 0x001c
+  private const val TYPE_PTR = 0x000c
+  private val ASCII = StandardCharsets.US_ASCII
+
+  @JvmStatic
+  fun encodeQuery(host: String, type: Int): ByteString = Buffer().apply {
+    writeShort(0) // query id
+    writeShort(256) // flags with recursion
+    writeShort(1) // question count
+    writeShort(0) // answerCount
+    writeShort(0) // authorityResourceCount
+    writeShort(0) // additional
+
+    val nameBuf = Buffer()
+    val labels = host.split('.').dropLastWhile { it.isEmpty() }.toTypedArray()
+    for (label in labels) {
+      val utf8ByteCount = label.utf8Size()
+      if (utf8ByteCount != label.length.toLong()) {
+        throw IllegalArgumentException("non-ascii hostname: $host")
+      }
+      nameBuf.writeByte(utf8ByteCount.toInt())
+      nameBuf.writeUtf8(label)
+    }
+    nameBuf.writeByte(0) // end
+
+    nameBuf.copyTo(this, 0, nameBuf.size)
+    writeShort(type)
+    writeShort(1) // CLASS_IN
+  }.readByteString()
+
+  @Throws(Exception::class)
+  @JvmStatic
+  fun decodeAnswers(hostname: String, byteString: ByteString): List<InetAddress> {
+    val result = ArrayList<InetAddress>()
+
+    val buf = Buffer()
+    buf.write(byteString)
+    buf.readShort() // query id
+
+    val flags = buf.readShort().toInt() and 0xffff
+    if (flags shr 15 == 0) {
+      throw IllegalArgumentException("not a response")
+    }
+
+    val responseCode = flags and 0xf
+
+    if (responseCode == NXDOMAIN) {
+      throw UnknownHostException("$hostname: NXDOMAIN")
+    } else if (responseCode == SERVFAIL) {
+      throw UnknownHostException("$hostname: SERVFAIL")
+    }
+
+    val questionCount = buf.readShort().toInt() and 0xffff
+    val answerCount = buf.readShort().toInt() and 0xffff
+    buf.readShort() // authority record count
+    buf.readShort() // additional record count
+
+    for (i in 0 until questionCount) {
+      skipName(buf) // name
+      buf.readShort() // type
+      buf.readShort() // class
+    }
+
+    for (i in 0 until answerCount) {
+      skipName(buf) // name
+
+      val type = buf.readShort().toInt() and 0xffff
+      buf.readShort() // class
+      val ttl = buf.readInt().toLong() and 0xffffffffL // ttl
+      val length = buf.readShort().toInt() and 0xffff
+
+      if (type == TYPE_A || type == TYPE_AAAA) {
+        val bytes = ByteArray(length)
+        buf.read(bytes)
+        result.add(InetAddress.getByAddress(bytes))
+      } else {
+        buf.skip(length.toLong())
+      }
+    }
+
+    return result
+  }
+
+  @Throws(EOFException::class)
+  private fun skipName(source: Buffer) {
+    // 0 - 63 bytes
+    var length = source.readByte().toInt()
+
+    if (length < 0) {
+      // compressed name pointer, first two bits are 1
+      // drop second byte of compression offset
+      source.skip(1)
+    } else {
+      while (length > 0) {
+        // skip each part of the domain name
+        source.skip(length.toLong())
+        length = source.readByte().toInt()
+      }
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java
deleted file mode 100644
index 54da565bc2..0000000000
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java
+++ /dev/null
@@ -1,3 +0,0 @@
-/** A DNS over HTTPS implementation for OkHttp. */
-@okhttp3.internal.annotations.EverythingIsNonNull
-package okhttp3.dnsoverhttps;
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.kt
new file mode 100644
index 0000000000..f0f89d115b
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.kt
@@ -0,0 +1,2 @@
+/** A DNS over HTTPS implementation for OkHttp.  */
+package okhttp3.dnsoverhttps
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
index c6c16278dd..8b750f018c 100644
--- a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
@@ -15,13 +15,12 @@
  */
 package okhttp3.dnsoverhttps;
 
+import java.io.EOFException;
 import java.io.File;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.Arrays;
-import java.util.HashSet;
-import java.util.LinkedHashSet;
 import java.util.List;
 import okhttp3.Cache;
 import okhttp3.Dns;
@@ -39,8 +38,7 @@
 
 import static java.util.Arrays.asList;
 import static java.util.Collections.singletonList;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public class DnsOverHttpsTest {
@@ -62,12 +60,12 @@
 
     List<InetAddress> result = dns.lookup("google.com");
 
-    assertEquals(singletonList(address("157.240.1.18")), result);
+    assertThat(result).isEqualTo(singletonList(address("157.240.1.18")));
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("GET", recordedRequest.getMethod());
-    assertEquals("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
-        recordedRequest.getPath());
+    assertThat(recordedRequest.getMethod()).isEqualTo("GET");
+    assertThat(recordedRequest.getPath()).isEqualTo(
+        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ");
   }
 
   @Test public void getIpv6() throws Exception {
@@ -84,20 +82,19 @@
 
     List<InetAddress> result = dns.lookup("google.com");
 
-    assertEquals(2, result.size());
-    assertTrue(result.contains(address("157.240.1.18")));
-    assertTrue(result.contains(address("2a03:2880:f029:11:face:b00c:0:2")));
+    assertThat(result.size()).isEqualTo(2);
+    assertThat(result).contains(address("157.240.1.18"));
+    assertThat(result).contains(address("2a03:2880:f029:11:face:b00c:0:2"));
 
     RecordedRequest request1 = server.takeRequest();
-    assertEquals("GET", request1.getMethod());
+    assertThat(request1.getMethod()).isEqualTo("GET");
 
     RecordedRequest request2 = server.takeRequest();
-    assertEquals("GET", request2.getMethod());
+    assertThat(request2.getMethod()).isEqualTo("GET");
 
-    assertEquals(new HashSet<>(
-            Arrays.asList("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
-                "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AABwAAQ")),
-        new LinkedHashSet<>(Arrays.asList(request1.getPath(), request2.getPath())));
+    assertThat(asList(request1.getPath(), request2.getPath())).containsExactlyInAnyOrder(
+        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
+        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AABwAAQ");
   }
 
   @Test public void failure() throws Exception {
@@ -111,13 +108,13 @@
       fail();
     } catch (UnknownHostException uhe) {
       uhe.printStackTrace();
-      assertEquals("google.com: NXDOMAIN", uhe.getMessage());
+      assertThat(uhe.getMessage()).isEqualTo("google.com: NXDOMAIN");
     }
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("GET", recordedRequest.getMethod());
-    assertEquals("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
-        recordedRequest.getPath());
+    assertThat(recordedRequest.getMethod()).isEqualTo("GET");
+    assertThat(recordedRequest.getPath()).isEqualTo(
+        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ");
   }
 
   @Test public void failOnExcessiveResponse() {
@@ -129,10 +126,10 @@
       dns.lookup("google.com");
       fail();
     } catch (IOException ioe) {
-      assertEquals("google.com", ioe.getMessage());
+      assertThat(ioe.getMessage()).isEqualTo("google.com");
       Throwable cause = ioe.getCause();
-      assertTrue(cause instanceof IOException);
-      assertEquals("response size exceeds limit (65536 bytes): 65537 bytes", cause.getMessage());
+      assertThat(cause).isInstanceOf(IOException.class);
+      assertThat(cause).hasMessage("response size exceeds limit (65536 bytes): 65537 bytes");
     }
   }
 
@@ -143,9 +140,8 @@
       dns.lookup("google.com");
       fail();
     } catch (IOException ioe) {
-      assertEquals("google.com", ioe.getMessage());
-      Throwable cause = ioe.getCause();
-      assertTrue(cause instanceof RuntimeException);
+      assertThat(ioe).hasMessage("google.com");
+      assertThat(ioe.getCause()).isInstanceOf(EOFException.class);
     }
   }
 
@@ -170,15 +166,15 @@
 
     List<InetAddress> result = cachedDns.lookup("google.com");
 
-    assertEquals(singletonList(address("157.240.1.18")), result);
+    assertThat(result).containsExactly(address("157.240.1.18"));
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("GET", recordedRequest.getMethod());
-    assertEquals("/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
-        recordedRequest.getPath());
+    assertThat(recordedRequest.getMethod()).isEqualTo("GET");
+    assertThat(recordedRequest.getPath()).isEqualTo(
+        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ");
 
     result = cachedDns.lookup("google.com");
-    assertEquals(singletonList(address("157.240.1.18")), result);
+    assertThat(result).isEqualTo(singletonList(address("157.240.1.18")));
   }
 
   private MockResponse dnsResponse(String s) {
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
index 3a12b4d254..8eea96c7bd 100644
--- a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
@@ -17,21 +17,20 @@
 
 import java.net.InetAddress;
 import java.net.UnknownHostException;
-import java.util.Collections;
 import java.util.List;
 import okio.ByteString;
 import org.junit.Test;
 
 import static okhttp3.dnsoverhttps.DnsRecordCodec.TYPE_A;
 import static okhttp3.dnsoverhttps.DnsRecordCodec.TYPE_AAAA;
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public class DnsRecordCodecTest {
   @Test public void testGoogleDotComEncoding() {
     String encoded = encodeQuery("google.com", TYPE_A);
 
-    assertEquals("AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ", encoded);
+    assertThat(encoded).isEqualTo("AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ");
   }
 
   private String encodeQuery(String host, int type) {
@@ -41,30 +40,28 @@ private String encodeQuery(String host, int type) {
   @Test public void testGoogleDotComEncodingWithIPv6() {
     String encoded = encodeQuery("google.com", TYPE_AAAA);
 
-    assertEquals("AAABAAABAAAAAAAABmdvb2dsZQNjb20AABwAAQ", encoded);
+    assertThat(encoded).isEqualTo("AAABAAABAAAAAAAABmdvb2dsZQNjb20AABwAAQ");
   }
 
   @Test public void testGoogleDotComDecodingFromCloudflare() throws Exception {
     List<InetAddress> encoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
         "00008180000100010000000006676f6f676c6503636f6d0000010001c00c00010001000000430004d83ad54e"));
 
-    assertEquals(Collections.singletonList(InetAddress.getByName("216.58.213.78")), encoded);
+    assertThat(encoded).containsExactly(InetAddress.getByName("216.58.213.78"));
   }
 
   @Test public void testGoogleDotComDecodingFromGoogle() throws Exception {
     List<InetAddress> decoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
         "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c0005000100000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c042000100010000003b00049df00112"));
 
-    assertEquals(Collections.singletonList(InetAddress.getByName("157.240.1.18")), decoded);
+    assertThat(decoded).containsExactly(InetAddress.getByName("157.240.1.18"));
   }
 
   @Test public void testGoogleDotComDecodingFromGoogleIPv6() throws Exception {
     List<InetAddress> decoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
         "0000818000010003000000000567726170680866616365626f6f6b03636f6d00001c0001c00c0005000100000a1b000603617069c012c0300005000100000b1f000c04737461720463313072c012c042001c00010000003b00102a032880f0290011faceb00c00000002"));
 
-    assertEquals(
-        Collections.singletonList(InetAddress.getByName("2a03:2880:f029:11:face:b00c:0:2")),
-        decoded);
+    assertThat(decoded).containsExactly(InetAddress.getByName("2a03:2880:f029:11:face:b00c:0:2"));
   }
 
   @Test public void testGoogleDotComDecodingNxdomainFailure() throws Exception {
@@ -73,7 +70,7 @@ private String encodeQuery(String host, int type) {
           "0000818300010000000100000e7364666c6b686673646c6b6a64660265650000010001c01b00060001000007070038026e7303746c64c01b0a686f73746d61737465720d6565737469696e7465726e6574c01b5adb12c100000e10000003840012750000000e10"));
       fail();
     } catch (UnknownHostException uhe) {
-      assertEquals("sdflkhfsdlkjdf.ee: NXDOMAIN", uhe.getMessage());
+      assertThat(uhe.getMessage()).isEqualTo("sdflkhfsdlkjdf.ee: NXDOMAIN");
     }
   }
 }
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
index 65975ae5cc..6a25e7ebf3 100644
--- a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
@@ -20,20 +20,21 @@
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.security.Security;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import okhttp3.Cache;
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 
+import static java.util.Arrays.asList;
+
 public class TestDohMain {
   public static void main(String[] args) throws IOException {
     Security.insertProviderAt(new org.conscrypt.OpenSSLProvider(), 1);
 
     OkHttpClient bootstrapClient = new OkHttpClient.Builder().build();
 
-    List<String> names = Arrays.asList("google.com", "graph.facebook.com", "sdflkhfsdlkjdf.ee");
+    List<String> names = asList("google.com", "graph.facebook.com", "sdflkhfsdlkjdf.ee");
 
     try {
       System.out.println("uncached\n********\n");
@@ -53,7 +54,7 @@ public static void main(String[] args) throws IOException {
       runBatch(badProviders, names);
 
       System.out.println("cached first run\n****************\n");
-      names = Arrays.asList("google.com", "graph.facebook.com");
+      names = asList("google.com", "graph.facebook.com");
       bootstrapClient = bootstrapClient.newBuilder().cache(dnsCache).build();
       dnsProviders = DohProviders.providers(bootstrapClient, true, true, true);
       runBatch(dnsProviders, names);
diff --git a/okhttp-hpacktests/build.gradle b/okhttp-hpacktests/build.gradle
new file mode 100644
index 0000000000..cc38a49483
--- /dev/null
+++ b/okhttp-hpacktests/build.gradle
@@ -0,0 +1,9 @@
+dependencies {
+  testImplementation deps.okio
+  testImplementation deps.moshi
+  testImplementation project(':okhttp')
+  testImplementation project(':okhttp-testing-support')
+  testImplementation project(':mockwebserver')
+  testImplementation deps.junit
+  testImplementation deps.assertj
+}
diff --git a/okhttp-hpacktests/pom.xml b/okhttp-hpacktests/pom.xml
deleted file mode 100644
index a2a22ae365..0000000000
--- a/okhttp-hpacktests/pom.xml
+++ /dev/null
@@ -1,62 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-hpacktests</artifactId>
-  <name>OkHttp HPACK Tests</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okio</groupId>
-      <artifactId>okio</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <!-- Do not deploy this as an artifact to Maven central. -->
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-deploy-plugin</artifactId>
-        <configuration>
-          <skip>true</skip>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java
index dbcc99f55f..06bcbdf8ca 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java
@@ -17,6 +17,7 @@
 
 import java.util.Collection;
 import okhttp3.internal.http2.hpackjson.Story;
+import org.junit.Assume;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -37,6 +38,8 @@ public HpackDecodeInteropTest(Story story) {
 
   @Test
   public void testGoodDecoderInterop() throws Exception {
+    Assume.assumeFalse("Test stories missing, checkout git submodule", getStory() == Story.MISSING);
+
     testDecoder();
   }
 }
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java
index a3f69da38c..8cbb7a0e68 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java
@@ -17,6 +17,7 @@
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
 import okhttp3.internal.http2.hpackjson.Case;
@@ -24,8 +25,8 @@
 import okhttp3.internal.http2.hpackjson.Story;
 import okio.Buffer;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
+import static okhttp3.internal.http2.hpackjson.Story.MISSING;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /**
  * Tests Hpack implementation using https://github.com/http2jp/hpack-test-case/
@@ -37,12 +38,13 @@
    */
   protected static Collection<Story[]> createStories(String[] interopTests)
       throws Exception {
+    if (interopTests.length == 0) {
+      return Collections.singletonList(new Story[] {MISSING});
+    }
+
     List<Story[]> result = new ArrayList<>();
     for (String interopTestName : interopTests) {
       List<Story> stories = HpackJsonUtil.readStories(interopTestName);
-      if (stories.isEmpty()) {
-        fail("No stories for: " + interopTestName);
-      }
       for (Story story : stories) {
         result.add(new Story[] {story});
       }
@@ -67,10 +69,10 @@ protected void testDecoder() throws Exception {
   }
 
   protected void testDecoder(Story story) throws Exception {
-    for (Case caze : story.getCases()) {
-      bytesIn.write(caze.getWire());
+    for (Case testCase : story.getCases()) {
+      bytesIn.write(testCase.getWire());
       hpackReader.readHeaders();
-      assertSetEquals(String.format("seqno=%d", caze.getSeqno()), caze.getHeaders(),
+      assertSetEquals(String.format("seqno=%d", testCase.getSeqno()), testCase.getHeaders(),
           hpackReader.getAndResetHeaderList());
     }
   }
@@ -83,7 +85,8 @@ protected void testDecoder(Story story) throws Exception {
    */
   private static void assertSetEquals(
       String message, List<Header> expected, List<Header> observed) {
-    assertEquals(message, new LinkedHashSet<>(expected), new LinkedHashSet<>(observed));
+    assertThat(new LinkedHashSet<>(observed)).overridingErrorMessage(message).isEqualTo(
+        new LinkedHashSet<>(expected));
   }
 
   protected Story getStory() {
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java
index 55325ce53d..00371f05ad 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java
@@ -19,6 +19,7 @@
 import okhttp3.internal.http2.hpackjson.Case;
 import okhttp3.internal.http2.hpackjson.Story;
 import okio.Buffer;
+import org.junit.Assume;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -49,6 +50,8 @@ public HpackRoundTripTest(Story story) {
 
   @Test
   public void testRoundTrip() throws Exception {
+    Assume.assumeFalse("Test stories missing, checkout git submodule", getStory() == Story.MISSING);
+
     Story story = getStory().clone();
     // Mutate cases in base class.
     for (Case caze : story.getCases()) {
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java
index 39b1489d4b..68c0aa99bc 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java
@@ -21,11 +21,15 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URISyntaxException;
+import java.net.URL;
 import java.util.ArrayList;
-import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import okio.Okio;
 
+import static java.util.Arrays.asList;
+import static okhttp3.internal.http2.hpackjson.Story.MISSING;
+
 /**
  * Utilities for reading HPACK tests.
  */
@@ -48,10 +52,14 @@ private static Story readStory(File file) throws IOException {
 
   /** Iterate through the hpack-test-case resources, only picking stories for the current draft. */
   public static String[] storiesForCurrentDraft() throws URISyntaxException {
-    File testCaseDirectory = new File(HpackJsonUtil.class.getResource("/hpack-test-case").toURI());
+    URL resource = HpackJsonUtil.class.getResource("/hpack-test-case");
+    if (resource == null) {
+      return new String[0];
+    }
+    File testCaseDirectory = new File(resource.toURI());
     List<String> storyNames = new ArrayList<>();
     for (File path : testCaseDirectory.listFiles()) {
-      if (path.isDirectory() && Arrays.asList(path.list()).contains("story_00.json")) {
+      if (path.isDirectory() && asList(path.list()).contains("story_00.json")) {
         try {
           Story firstStory = readStory(new File(path, "story_00.json"));
           if (firstStory.getDraft() >= BASE_DRAFT) {
@@ -86,6 +94,12 @@ private static Story readStory(File file) throws IOException {
         storyInputStream.close();
       }
     }
+
+    if (result.isEmpty()) {
+      // missing files
+      return Collections.singletonList(MISSING);
+    }
+
     return result;
   }
 
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java
index 288a87b81f..25a63a073b 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java
@@ -23,6 +23,11 @@
  * reflectively with Moshi to parse stories from files.
  */
 public class Story implements Cloneable {
+  public final static Story MISSING = new Story();
+
+  static {
+    MISSING.setFileName("missing");
+  }
 
   private transient String fileName;
   private List<Case> cases;
diff --git a/okhttp-logging-interceptor/Module.md b/okhttp-logging-interceptor/Module.md
new file mode 100644
index 0000000000..d018b76711
--- /dev/null
+++ b/okhttp-logging-interceptor/Module.md
@@ -0,0 +1,3 @@
+# Module okhttp-logging-interceptor
+
+An OkHttp interceptor which logs HTTP request and response data.
diff --git a/okhttp-logging-interceptor/build.gradle b/okhttp-logging-interceptor/build.gradle
new file mode 100644
index 0000000000..5381903882
--- /dev/null
+++ b/okhttp-logging-interceptor/build.gradle
@@ -0,0 +1,37 @@
+apply plugin: 'com.vanniktech.maven.publish'
+apply plugin: 'me.champeau.gradle.japicmp'
+
+jar {
+  manifest {
+    attributes('Automatic-Module-Name': 'okhttp3.logging')
+  }
+}
+
+dependencies {
+  api project(':okhttp')
+  compileOnly deps.jsr305
+
+  testCompileOnly deps.jsr305
+  testImplementation deps.junit
+  testImplementation project(':mockwebserver')
+  testImplementation project(':okhttp-testing-support')
+  testImplementation project(':okhttp-tls')
+  testImplementation deps.assertj
+}
+
+task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
+  oldClasspath = files(baselineJar(project, baselineVersion))
+  newClasspath = files(jar.archivePath)
+  onlyBinaryIncompatibleModified = true
+  failOnModification = true
+  txtOutputFile = file("$buildDir/reports/japi.txt")
+  ignoreMissingClasses = true
+  includeSynthetic = true
+  methodExcludes = [
+    // Became 'final' in 4.0.0:
+    'okhttp3.logging.HttpLoggingInterceptor#redactHeader(java.lang.String)',
+    'okhttp3.logging.HttpLoggingInterceptor#getLevel()',
+    'okhttp3.logging.HttpLoggingInterceptor#setLevel(okhttp3.logging.HttpLoggingInterceptor$Level)'
+  ]
+}
+check.dependsOn(japicmp)
diff --git a/okhttp-logging-interceptor/gradle.properties b/okhttp-logging-interceptor/gradle.properties
new file mode 100644
index 0000000000..e0fec2973b
--- /dev/null
+++ b/okhttp-logging-interceptor/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=logging-interceptor
+POM_NAME=logging-interceptor
+POM_PACKAGING=jar
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
deleted file mode 100644
index 1841991051..0000000000
--- a/okhttp-logging-interceptor/pom.xml
+++ /dev/null
@@ -1,68 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>logging-interceptor</artifactId>
-  <name>OkHttp Logging Interceptor</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-tls</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.logging</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
deleted file mode 100644
index 1c960b74bd..0000000000
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+++ /dev/null
@@ -1,325 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.logging;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.util.Collections;
-import java.util.Set;
-import java.util.TreeSet;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Connection;
-import okhttp3.Headers;
-import okhttp3.Interceptor;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.platform.Platform;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.GzipSource;
-
-import static okhttp3.internal.platform.Platform.INFO;
-
-/**
- * An OkHttp interceptor which logs request and response information. Can be applied as an
- * {@linkplain OkHttpClient#interceptors() application interceptor} or as a {@linkplain
- * OkHttpClient#networkInterceptors() network interceptor}. <p> The format of the logs created by
- * this class should not be considered stable and may change slightly between releases. If you need
- * a stable logging format, use your own interceptor.
- */
-public final class HttpLoggingInterceptor implements Interceptor {
-  private static final Charset UTF8 = Charset.forName("UTF-8");
-
-  public enum Level {
-    /** No logs. */
-    NONE,
-    /**
-     * Logs request and response lines.
-     *
-     * <p>Example:
-     * <pre>{@code
-     * --> POST /greeting http/1.1 (3-byte body)
-     *
-     * <-- 200 OK (22ms, 6-byte body)
-     * }</pre>
-     */
-    BASIC,
-    /**
-     * Logs request and response lines and their respective headers.
-     *
-     * <p>Example:
-     * <pre>{@code
-     * --> POST /greeting http/1.1
-     * Host: example.com
-     * Content-Type: plain/text
-     * Content-Length: 3
-     * --> END POST
-     *
-     * <-- 200 OK (22ms)
-     * Content-Type: plain/text
-     * Content-Length: 6
-     * <-- END HTTP
-     * }</pre>
-     */
-    HEADERS,
-    /**
-     * Logs request and response lines and their respective headers and bodies (if present).
-     *
-     * <p>Example:
-     * <pre>{@code
-     * --> POST /greeting http/1.1
-     * Host: example.com
-     * Content-Type: plain/text
-     * Content-Length: 3
-     *
-     * Hi?
-     * --> END POST
-     *
-     * <-- 200 OK (22ms)
-     * Content-Type: plain/text
-     * Content-Length: 6
-     *
-     * Hello!
-     * <-- END HTTP
-     * }</pre>
-     */
-    BODY
-  }
-
-  public interface Logger {
-    void log(String message);
-
-    /** A {@link Logger} defaults output appropriate for the current platform. */
-    Logger DEFAULT = message -> Platform.get().log(INFO, message, null);
-  }
-
-  public HttpLoggingInterceptor() {
-    this(Logger.DEFAULT);
-  }
-
-  public HttpLoggingInterceptor(Logger logger) {
-    this.logger = logger;
-  }
-
-  private final Logger logger;
-
-  private volatile Set<String> headersToRedact = Collections.emptySet();
-
-  public void redactHeader(String name) {
-    Set<String> newHeadersToRedact = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
-    newHeadersToRedact.addAll(headersToRedact);
-    newHeadersToRedact.add(name);
-    headersToRedact = newHeadersToRedact;
-  }
-
-  private volatile Level level = Level.NONE;
-
-  /** Change the level at which this interceptor logs. */
-  public HttpLoggingInterceptor setLevel(Level level) {
-    if (level == null) throw new NullPointerException("level == null. Use Level.NONE instead.");
-    this.level = level;
-    return this;
-  }
-
-  public Level getLevel() {
-    return level;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Level level = this.level;
-
-    Request request = chain.request();
-    if (level == Level.NONE) {
-      return chain.proceed(request);
-    }
-
-    boolean logBody = level == Level.BODY;
-    boolean logHeaders = logBody || level == Level.HEADERS;
-
-    RequestBody requestBody = request.body();
-    boolean hasRequestBody = requestBody != null;
-
-    Connection connection = chain.connection();
-    String requestStartMessage = "--> "
-        + request.method()
-        + ' ' + request.url()
-        + (connection != null ? " " + connection.protocol() : "");
-    if (!logHeaders && hasRequestBody) {
-      requestStartMessage += " (" + requestBody.contentLength() + "-byte body)";
-    }
-    logger.log(requestStartMessage);
-
-    if (logHeaders) {
-      if (hasRequestBody) {
-        // Request body headers are only present when installed as a network interceptor. Force
-        // them to be included (when available) so there values are known.
-        if (requestBody.contentType() != null) {
-          logger.log("Content-Type: " + requestBody.contentType());
-        }
-        if (requestBody.contentLength() != -1) {
-          logger.log("Content-Length: " + requestBody.contentLength());
-        }
-      }
-
-      Headers headers = request.headers();
-      for (int i = 0, count = headers.size(); i < count; i++) {
-        String name = headers.name(i);
-        // Skip headers from the request body as they are explicitly logged above.
-        if (!"Content-Type".equalsIgnoreCase(name) && !"Content-Length".equalsIgnoreCase(name)) {
-          logHeader(headers, i);
-        }
-      }
-
-      if (!logBody || !hasRequestBody) {
-        logger.log("--> END " + request.method());
-      } else if (bodyHasUnknownEncoding(request.headers())) {
-        logger.log("--> END " + request.method() + " (encoded body omitted)");
-      } else {
-        Buffer buffer = new Buffer();
-        requestBody.writeTo(buffer);
-
-        Charset charset = UTF8;
-        MediaType contentType = requestBody.contentType();
-        if (contentType != null) {
-          charset = contentType.charset(UTF8);
-        }
-
-        logger.log("");
-        if (isPlaintext(buffer)) {
-          logger.log(buffer.readString(charset));
-          logger.log("--> END " + request.method()
-              + " (" + requestBody.contentLength() + "-byte body)");
-        } else {
-          logger.log("--> END " + request.method() + " (binary "
-              + requestBody.contentLength() + "-byte body omitted)");
-        }
-      }
-    }
-
-    long startNs = System.nanoTime();
-    Response response;
-    try {
-      response = chain.proceed(request);
-    } catch (Exception e) {
-      logger.log("<-- HTTP FAILED: " + e);
-      throw e;
-    }
-    long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);
-
-    ResponseBody responseBody = response.body();
-    long contentLength = responseBody.contentLength();
-    String bodySize = contentLength != -1 ? contentLength + "-byte" : "unknown-length";
-    logger.log("<-- "
-        + response.code()
-        + (response.message().isEmpty() ? "" : ' ' + response.message())
-        + ' ' + response.request().url()
-        + " (" + tookMs + "ms" + (!logHeaders ? ", " + bodySize + " body" : "") + ')');
-
-    if (logHeaders) {
-      Headers headers = response.headers();
-      for (int i = 0, count = headers.size(); i < count; i++) {
-        logHeader(headers, i);
-      }
-
-      if (!logBody || !HttpHeaders.hasBody(response)) {
-        logger.log("<-- END HTTP");
-      } else if (bodyHasUnknownEncoding(response.headers())) {
-        logger.log("<-- END HTTP (encoded body omitted)");
-      } else {
-        BufferedSource source = responseBody.source();
-        source.request(Long.MAX_VALUE); // Buffer the entire body.
-        Buffer buffer = source.getBuffer();
-
-        Long gzippedLength = null;
-        if ("gzip".equalsIgnoreCase(headers.get("Content-Encoding"))) {
-          gzippedLength = buffer.size();
-          try (GzipSource gzippedResponseBody = new GzipSource(buffer.clone())) {
-            buffer = new Buffer();
-            buffer.writeAll(gzippedResponseBody);
-          }
-        }
-
-        Charset charset = UTF8;
-        MediaType contentType = responseBody.contentType();
-        if (contentType != null) {
-          charset = contentType.charset(UTF8);
-        }
-
-        if (!isPlaintext(buffer)) {
-          logger.log("");
-          logger.log("<-- END HTTP (binary " + buffer.size() + "-byte body omitted)");
-          return response;
-        }
-
-        if (contentLength != 0) {
-          logger.log("");
-          logger.log(buffer.clone().readString(charset));
-        }
-
-        if (gzippedLength != null) {
-            logger.log("<-- END HTTP (" + buffer.size() + "-byte, "
-                + gzippedLength + "-gzipped-byte body)");
-        } else {
-            logger.log("<-- END HTTP (" + buffer.size() + "-byte body)");
-        }
-      }
-    }
-
-    return response;
-  }
-
-  private void logHeader(Headers headers, int i) {
-    String value = headersToRedact.contains(headers.name(i)) ? "" : headers.value(i);
-    logger.log(headers.name(i) + ": " + value);
-  }
-
-  /**
-   * Returns true if the body in question probably contains human readable text. Uses a small sample
-   * of code points to detect unicode control characters commonly used in binary file signatures.
-   */
-  static boolean isPlaintext(Buffer buffer) {
-    try {
-      Buffer prefix = new Buffer();
-      long byteCount = buffer.size() < 64 ? buffer.size() : 64;
-      buffer.copyTo(prefix, 0, byteCount);
-      for (int i = 0; i < 16; i++) {
-        if (prefix.exhausted()) {
-          break;
-        }
-        int codePoint = prefix.readUtf8CodePoint();
-        if (Character.isISOControl(codePoint) && !Character.isWhitespace(codePoint)) {
-          return false;
-        }
-      }
-      return true;
-    } catch (EOFException e) {
-      return false; // Truncated UTF-8 sequence.
-    }
-  }
-
-  private static boolean bodyHasUnknownEncoding(Headers headers) {
-    String contentEncoding = headers.get("Content-Encoding");
-    return contentEncoding != null
-        && !contentEncoding.equalsIgnoreCase("identity")
-        && !contentEncoding.equalsIgnoreCase("gzip");
-  }
-}
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
new file mode 100644
index 0000000000..f31b005a82
--- /dev/null
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
@@ -0,0 +1,321 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging
+
+import okhttp3.Headers
+import okhttp3.Interceptor
+import okhttp3.OkHttpClient
+import okhttp3.Response
+import okhttp3.internal.http.HttpHeaders
+import okhttp3.internal.platform.Platform
+import okhttp3.internal.platform.Platform.Companion.INFO
+import okio.Buffer
+import okio.GzipSource
+import java.io.EOFException
+import java.io.IOException
+import java.nio.charset.Charset
+import java.nio.charset.StandardCharsets
+import java.util.TreeSet
+import java.util.concurrent.TimeUnit
+
+/**
+ * An OkHttp interceptor which logs request and response information. Can be applied as an
+ * [application interceptor][OkHttpClient.interceptors] or as a [OkHttpClient.networkInterceptors].
+ *
+ * The format of the logs created by this class should not be considered stable and may
+ * change slightly between releases. If you need a stable logging format, use your own interceptor.
+ */
+class HttpLoggingInterceptor @JvmOverloads constructor(
+  private val logger: Logger = Logger.DEFAULT
+) : Interceptor {
+
+  @Volatile private var headersToRedact = emptySet<String>()
+
+  @Volatile @set:JvmName("-deprecated_setLevel") var level = Level.NONE
+
+  enum class Level {
+    /** No logs. */
+    NONE,
+
+    /**
+     * Logs request and response lines.
+     *
+     * Example:
+     * ```
+     * --> POST /greeting http/1.1 (3-byte body)
+     *
+     * <-- 200 OK (22ms, 6-byte body)
+     * ```
+     */
+    BASIC,
+
+    /**
+     * Logs request and response lines and their respective headers.
+     *
+     * Example:
+     * ```
+     * --> POST /greeting http/1.1
+     * Host: example.com
+     * Content-Type: plain/text
+     * Content-Length: 3
+     * --> END POST
+     *
+     * <-- 200 OK (22ms)
+     * Content-Type: plain/text
+     * Content-Length: 6
+     * <-- END HTTP
+     * ```
+     */
+    HEADERS,
+
+    /**
+     * Logs request and response lines and their respective headers and bodies (if present).
+     *
+     * Example:
+     * ```
+     * --> POST /greeting http/1.1
+     * Host: example.com
+     * Content-Type: plain/text
+     * Content-Length: 3
+     *
+     * Hi?
+     * --> END POST
+     *
+     * <-- 200 OK (22ms)
+     * Content-Type: plain/text
+     * Content-Length: 6
+     *
+     * Hello!
+     * <-- END HTTP
+     * ```
+     */
+    BODY
+  }
+
+  interface Logger {
+    fun log(message: String)
+
+    companion object {
+      // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+      @JvmName("-deprecated_Logger")
+      inline operator fun invoke(
+        crossinline block: (message: String) -> Unit
+      ): Logger = object : Logger {
+        override fun log(message: String) = block(message)
+      }
+
+      /** A [Logger] defaults output appropriate for the current platform.  */
+      @JvmField
+      val DEFAULT: Logger = object : Logger {
+        override fun log(message: String) {
+          Platform.get().log(INFO, message, null)
+        }
+      }
+    }
+  }
+
+  fun redactHeader(name: String) {
+    val newHeadersToRedact = TreeSet(String.CASE_INSENSITIVE_ORDER)
+    newHeadersToRedact.addAll(headersToRedact)
+    newHeadersToRedact.add(name)
+    headersToRedact = newHeadersToRedact
+  }
+
+  fun setLevel(level: Level) = apply {
+    this.level = level
+  }
+
+  @JvmName("-deprecated_getLevel")
+  fun getLevel(): Level = level
+
+  @Throws(IOException::class)
+  override fun intercept(chain: Interceptor.Chain): Response {
+    val level = this.level
+
+    val request = chain.request()
+    if (level == Level.NONE) {
+      return chain.proceed(request)
+    }
+
+    val logBody = level == Level.BODY
+    val logHeaders = logBody || level == Level.HEADERS
+
+    val requestBody = request.body()
+
+    val connection = chain.connection()
+    var requestStartMessage =
+        ("--> ${request.method()} ${request.url()}${if (connection != null) " " + connection.protocol() else ""}")
+    if (!logHeaders && requestBody != null) {
+      requestStartMessage += " (${requestBody.contentLength()}-byte body)"
+    }
+    logger.log(requestStartMessage)
+
+    if (logHeaders) {
+      if (requestBody != null) {
+        // Request body headers are only present when installed as a network interceptor. Force
+        // them to be included (when available) so there values are known.
+        requestBody.contentType()?.let {
+          logger.log("Content-Type: $it")
+        }
+        if (requestBody.contentLength() != -1L) {
+          logger.log("Content-Length: ${requestBody.contentLength()}")
+        }
+      }
+
+      val headers = request.headers()
+      var i = 0
+      val count = headers.size()
+      while (i < count) {
+        val name = headers.name(i)
+        // Skip headers from the request body as they are explicitly logged above.
+        if (!"Content-Type".equals(name, ignoreCase = true) && !"Content-Length".equals(name,
+                ignoreCase = true)) {
+          logHeader(headers, i)
+        }
+        i++
+      }
+
+      if (!logBody || requestBody == null) {
+        logger.log("--> END ${request.method()}")
+      } else if (bodyHasUnknownEncoding(request.headers())) {
+        logger.log("--> END ${request.method()} (encoded body omitted)")
+      } else if (requestBody.isDuplex()) {
+        logger.log("--> END ${request.method()} (duplex request body omitted)")
+      } else {
+        val buffer = Buffer()
+        requestBody.writeTo(buffer)
+
+        val contentType = requestBody.contentType()
+        val charset: Charset = contentType?.charset(UTF8) ?: UTF8
+
+        logger.log("")
+        if (buffer.isUtf8()) {
+          logger.log(buffer.readString(charset))
+          logger.log("--> END ${request.method()} (${requestBody.contentLength()}-byte body)")
+        } else {
+          logger.log(
+              "--> END ${request.method()} (binary ${requestBody.contentLength()}-byte body omitted)")
+        }
+      }
+    }
+
+    val startNs = System.nanoTime()
+    val response: Response
+    try {
+      response = chain.proceed(request)
+    } catch (e: Exception) {
+      logger.log("<-- HTTP FAILED: $e")
+      throw e
+    }
+
+    val tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs)
+
+    val responseBody = response.body()!!
+    val contentLength = responseBody.contentLength()
+    val bodySize = if (contentLength != -1L) "$contentLength-byte" else "unknown-length"
+    logger.log(
+        "<-- ${response.code()}${if (response.message().isEmpty()) "" else ' ' + response.message()} ${response.request().url()} (${tookMs}ms${if (!logHeaders) ", $bodySize body" else ""})")
+
+    if (logHeaders) {
+      val headers = response.headers()
+      for (i in 0 until headers.size()) {
+        logHeader(headers, i)
+      }
+
+      if (!logBody || !HttpHeaders.hasBody(response)) {
+        logger.log("<-- END HTTP")
+      } else if (bodyHasUnknownEncoding(response.headers())) {
+        logger.log("<-- END HTTP (encoded body omitted)")
+      } else {
+        val source = responseBody.source()
+        source.request(java.lang.Long.MAX_VALUE) // Buffer the entire body.
+        var buffer = source.buffer
+
+        var gzippedLength: Long? = null
+        if ("gzip".equals(headers["Content-Encoding"], ignoreCase = true)) {
+          gzippedLength = buffer.size
+          GzipSource(buffer.clone()).use { gzippedResponseBody ->
+            buffer = Buffer()
+            buffer.writeAll(gzippedResponseBody)
+          }
+        }
+
+        val contentType = responseBody.contentType()
+        val charset: Charset = contentType?.charset(UTF8) ?: UTF8
+
+        if (!buffer.isUtf8()) {
+          logger.log("")
+          logger.log("<-- END HTTP (binary ${buffer.size}-byte body omitted)")
+          return response
+        }
+
+        if (contentLength != 0L) {
+          logger.log("")
+          logger.log(buffer.clone().readString(charset))
+        }
+
+        if (gzippedLength != null) {
+          logger.log("<-- END HTTP (${buffer.size}-byte, $gzippedLength-gzipped-byte body)")
+        } else {
+          logger.log("<-- END HTTP (${buffer.size}-byte body)")
+        }
+      }
+    }
+
+    return response
+  }
+
+  private fun logHeader(headers: Headers, i: Int) {
+    val value = if (headersToRedact.contains(headers.name(i))) "" else headers.value(i)
+    logger.log(headers.name(i) + ": " + value)
+  }
+
+  companion object {
+    private val UTF8 = StandardCharsets.UTF_8
+
+    /**
+     * Returns true if the body in question probably contains human readable text. Uses a small
+     * sample of code points to detect unicode control characters commonly used in binary file
+     * signatures.
+     */
+    internal fun Buffer.isUtf8(): Boolean {
+      try {
+        val prefix = Buffer()
+        val byteCount = if (size < 64) size else 64
+        copyTo(prefix, 0, byteCount)
+        for (i in 0 until 16) {
+          if (prefix.exhausted()) {
+            break
+          }
+          val codePoint = prefix.readUtf8CodePoint()
+          if (Character.isISOControl(codePoint) && !Character.isWhitespace(codePoint)) {
+            return false
+          }
+        }
+        return true
+      } catch (e: EOFException) {
+        return false // Truncated UTF-8 sequence.
+      }
+    }
+
+    private fun bodyHasUnknownEncoding(headers: Headers): Boolean {
+      val contentEncoding = headers["Content-Encoding"]
+      return (contentEncoding != null &&
+          !contentEncoding.equals("identity", ignoreCase = true) &&
+          !contentEncoding.equals("gzip", ignoreCase = true))
+    }
+  }
+}
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.java
deleted file mode 100644
index da38261bfb..0000000000
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.java
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.logging;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.Call;
-import okhttp3.Connection;
-import okhttp3.EventListener;
-import okhttp3.Handshake;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-
-/**
- * An OkHttp EventListener, which logs call events. Can be applied as an
- * {@linkplain OkHttpClient#eventListenerFactory() event listener factory}.
- *
- * <p>The format of the logs created by this class should not be considered stable and may change
- * slightly between releases. If you need a stable logging format, use your own event listener.
- */
-public final class LoggingEventListener extends EventListener {
-  private final HttpLoggingInterceptor.Logger logger;
-  private long startNs;
-
-  private LoggingEventListener(HttpLoggingInterceptor.Logger logger) {
-    this.logger = logger;
-  }
-
-  @Override
-  public void callStart(Call call) {
-    startNs = System.nanoTime();
-
-    logWithTime("callStart: " + call.request());
-  }
-
-  @Override
-  public void dnsStart(Call call, String domainName) {
-    logWithTime("dnsStart: " + domainName);
-  }
-
-  @Override
-  public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
-    logWithTime("dnsEnd: " + inetAddressList);
-  }
-
-  @Override
-  public void connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
-    logWithTime("connectStart: " + inetSocketAddress + " " + proxy);
-  }
-
-  @Override
-  public void secureConnectStart(Call call) {
-    logWithTime("secureConnectStart");
-  }
-
-  @Override
-  public void secureConnectEnd(Call call, @Nullable Handshake handshake) {
-    logWithTime("secureConnectEnd: " + handshake);
-  }
-
-  @Override
-  public void connectEnd(
-      Call call, InetSocketAddress inetSocketAddress, Proxy proxy, @Nullable Protocol protocol) {
-    logWithTime("connectEnd: " + protocol);
-  }
-
-  @Override
-  public void connectFailed(
-      Call call,
-      InetSocketAddress inetSocketAddress,
-      Proxy proxy,
-      @Nullable Protocol protocol,
-      IOException ioe) {
-    logWithTime("connectFailed: " + protocol + " " + ioe);
-  }
-
-  @Override
-  public void connectionAcquired(Call call, Connection connection) {
-    logWithTime("connectionAcquired: " + connection);
-  }
-
-  @Override
-  public void connectionReleased(Call call, Connection connection) {
-    logWithTime("connectionReleased");
-  }
-
-  @Override
-  public void requestHeadersStart(Call call) {
-    logWithTime("requestHeadersStart");
-  }
-
-  @Override
-  public void requestHeadersEnd(Call call, Request request) {
-    logWithTime("requestHeadersEnd");
-  }
-
-  @Override
-  public void requestBodyStart(Call call) {
-    logWithTime("requestBodyStart");
-  }
-
-  @Override
-  public void requestBodyEnd(Call call, long byteCount) {
-    logWithTime("requestBodyEnd: byteCount=" + byteCount);
-  }
-
-  @Override
-  public void responseHeadersStart(Call call) {
-    logWithTime("responseHeadersStart");
-  }
-
-  @Override
-  public void responseHeadersEnd(Call call, Response response) {
-    logWithTime("responseHeadersEnd: " + response);
-  }
-
-  @Override
-  public void responseBodyStart(Call call) {
-    logWithTime("responseBodyStart");
-  }
-
-  @Override
-  public void responseBodyEnd(Call call, long byteCount) {
-    logWithTime("responseBodyEnd: byteCount=" + byteCount);
-  }
-
-  @Override
-  public void callEnd(Call call) {
-    logWithTime("callEnd");
-  }
-
-  @Override
-  public void callFailed(Call call, IOException ioe) {
-    logWithTime("callFailed: " + ioe);
-  }
-
-  private void logWithTime(String message) {
-    long timeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);
-    logger.log("[" + timeMs + " ms] " + message);
-  }
-
-  public static class Factory implements EventListener.Factory {
-    private final HttpLoggingInterceptor.Logger logger;
-
-    public Factory() {
-      this(HttpLoggingInterceptor.Logger.DEFAULT);
-    }
-
-    public Factory(HttpLoggingInterceptor.Logger logger) {
-      this.logger = logger;
-    }
-
-    @Override
-    public EventListener create(Call call) {
-      return new LoggingEventListener(logger);
-    }
-  }
-}
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt
new file mode 100644
index 0000000000..33253db6ee
--- /dev/null
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging
+
+import okhttp3.Call
+import okhttp3.Connection
+import okhttp3.EventListener
+import okhttp3.Handshake
+import okhttp3.OkHttpClient
+import okhttp3.Protocol
+import okhttp3.Request
+import okhttp3.Response
+import java.io.IOException
+import java.net.InetAddress
+import java.net.InetSocketAddress
+import java.net.Proxy
+import java.util.concurrent.TimeUnit
+
+/**
+ * An OkHttp EventListener, which logs call events. Can be applied as an
+ * [event listener factory][OkHttpClient.eventListenerFactory].
+ *
+ * The format of the logs created by this class should not be considered stable and may change
+ * slightly between releases. If you need a stable logging format, use your own event listener.
+ */
+class LoggingEventListener private constructor(
+  private val logger: HttpLoggingInterceptor.Logger
+) : EventListener() {
+  private var startNs: Long = 0
+
+  override fun callStart(call: Call) {
+    startNs = System.nanoTime()
+
+    logWithTime("callStart: ${call.request()}")
+  }
+
+  override fun dnsStart(call: Call, domainName: String) {
+    logWithTime("dnsStart: $domainName")
+  }
+
+  override fun dnsEnd(call: Call, domainName: String, inetAddressList: List<InetAddress>) {
+    logWithTime("dnsEnd: $inetAddressList")
+  }
+
+  override fun connectStart(call: Call, inetSocketAddress: InetSocketAddress, proxy: Proxy) {
+    logWithTime("connectStart: $inetSocketAddress $proxy")
+  }
+
+  override fun secureConnectStart(call: Call) {
+    logWithTime("secureConnectStart")
+  }
+
+  override fun secureConnectEnd(call: Call, handshake: Handshake?) {
+    logWithTime("secureConnectEnd: $handshake")
+  }
+
+  override fun connectEnd(
+    call: Call,
+    inetSocketAddress: InetSocketAddress,
+    proxy: Proxy,
+    protocol: Protocol?
+  ) {
+    logWithTime("connectEnd: $protocol")
+  }
+
+  override fun connectFailed(
+    call: Call,
+    inetSocketAddress: InetSocketAddress,
+    proxy: Proxy,
+    protocol: Protocol?,
+    ioe: IOException
+  ) {
+    logWithTime("connectFailed: $protocol $ioe")
+  }
+
+  override fun connectionAcquired(call: Call, connection: Connection) {
+    logWithTime("connectionAcquired: $connection")
+  }
+
+  override fun connectionReleased(call: Call, connection: Connection) {
+    logWithTime("connectionReleased")
+  }
+
+  override fun requestHeadersStart(call: Call) {
+    logWithTime("requestHeadersStart")
+  }
+
+  override fun requestHeadersEnd(call: Call, request: Request) {
+    logWithTime("requestHeadersEnd")
+  }
+
+  override fun requestBodyStart(call: Call) {
+    logWithTime("requestBodyStart")
+  }
+
+  override fun requestBodyEnd(call: Call, byteCount: Long) {
+    logWithTime("requestBodyEnd: byteCount=$byteCount")
+  }
+
+  override fun requestFailed(call: Call, ioe: IOException) {
+    logWithTime("requestFailed: $ioe")
+  }
+
+  override fun responseHeadersStart(call: Call) {
+    logWithTime("responseHeadersStart")
+  }
+
+  override fun responseHeadersEnd(call: Call, response: Response) {
+    logWithTime("responseHeadersEnd: $response")
+  }
+
+  override fun responseBodyStart(call: Call) {
+    logWithTime("responseBodyStart")
+  }
+
+  override fun responseBodyEnd(call: Call, byteCount: Long) {
+    logWithTime("responseBodyEnd: byteCount=$byteCount")
+  }
+
+  override fun responseFailed(call: Call, ioe: IOException) {
+    logWithTime("responseFailed: $ioe")
+  }
+
+  override fun callEnd(call: Call) {
+    logWithTime("callEnd")
+  }
+
+  override fun callFailed(call: Call, ioe: IOException) {
+    logWithTime("callFailed: $ioe")
+  }
+
+  private fun logWithTime(message: String) {
+    val timeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs)
+    logger.log("[$timeMs ms] $message")
+  }
+
+  open class Factory @JvmOverloads constructor(
+    private val logger: HttpLoggingInterceptor.Logger = HttpLoggingInterceptor.Logger.DEFAULT
+  ) : EventListener.Factory {
+    constructor(block: (string: String) -> Unit) : this(HttpLoggingInterceptor.Logger(block))
+
+    override fun create(call: Call): EventListener = LoggingEventListener(logger)
+  }
+}
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
deleted file mode 100644
index 62d0ff5761..0000000000
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
+++ /dev/null
@@ -1,3 +0,0 @@
-/** An OkHttp interceptor which logs HTTP request and response data. */
-@okhttp3.internal.annotations.EverythingIsNonNull
-package okhttp3.logging;
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorKotlinTest.kt b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorKotlinTest.kt
new file mode 100644
index 0000000000..05d63c9684
--- /dev/null
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorKotlinTest.kt
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging
+
+import okhttp3.logging.HttpLoggingInterceptor.Companion.isUtf8
+import okio.Buffer
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+
+class HttpLoggingInterceptorKotlinTest {
+  @Test fun isPlaintext() {
+    assertThat(Buffer().isUtf8()).isTrue()
+    assertThat(Buffer().writeUtf8("abc").isUtf8()).isTrue()
+    assertThat(Buffer().writeUtf8("new\r\nlines").isUtf8()).isTrue()
+    assertThat(Buffer().writeUtf8("white\t space").isUtf8()).isTrue()
+    assertThat(Buffer().writeByte(0x80).isUtf8()).isTrue()
+    assertThat(Buffer().writeByte(0x00).isUtf8()).isFalse()
+    assertThat(Buffer().writeByte(0xc0).isUtf8()).isFalse()
+  }
+}
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index bd4b8f79bc..0c3b850867 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -20,10 +20,12 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.regex.Pattern;
+import javax.annotation.Nullable;
 import javax.net.ssl.HostnameVerifier;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
+import okhttp3.PlatformRule;
 import okhttp3.Protocol;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
@@ -37,23 +39,20 @@
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
-import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
 import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.junit.Assume.assumeThat;
 
 public final class HttpLoggingInterceptorTest {
   private static final MediaType PLAIN = MediaType.get("text/plain; charset=utf-8");
 
+  @Rule public final PlatformRule platform = new PlatformRule();
   @Rule public final MockWebServer server = new MockWebServer();
 
   private final HandshakeCertificates handshakeCertificates = localhost();
@@ -90,11 +89,11 @@ private void setLevel(Level level) {
 
   @Test public void levelGetter() {
     // The default is NONE.
-    Assert.assertEquals(Level.NONE, applicationInterceptor.getLevel());
+    assertThat(applicationInterceptor.getLevel()).isEqualTo(Level.NONE);
 
     for (Level level : Level.values()) {
       applicationInterceptor.setLevel(level);
-      assertEquals(level, applicationInterceptor.getLevel());
+      assertThat(applicationInterceptor.getLevel()).isEqualTo(level);
     }
   }
 
@@ -102,14 +101,13 @@ private void setLevel(Level level) {
     try {
       applicationInterceptor.setLevel(null);
       fail();
-    } catch (NullPointerException expected) {
-      assertEquals("level == null. Use Level.NONE instead.", expected.getMessage());
+    } catch (IllegalArgumentException expected) {
     }
   }
 
   @Test public void setLevelShouldReturnSameInstanceOfInterceptor() {
     for (Level level : Level.values()) {
-      assertSame(applicationInterceptor, applicationInterceptor.setLevel(level));
+      assertThat(applicationInterceptor.setLevel(level)).isSameAs(applicationInterceptor);
     }
   }
 
@@ -544,7 +542,8 @@ private void bodyGetNoBody(int code) throws IOException {
     Response response = client.newCall(request().build()).execute();
 
     ResponseBody responseBody = response.body();
-    assertEquals("Expected response body to be valid","Hello, Hello, Hello", responseBody.string());
+    assertThat(responseBody.string()).overridingErrorMessage(
+        "Expected response body to be valid").isEqualTo("Hello, Hello, Hello");
     responseBody.close();
 
     networkLogs
@@ -647,16 +646,6 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
   }
 
-  @Test public void isPlaintext() {
-    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer()));
-    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("abc")));
-    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("new\r\nlines")));
-    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("white\t space")));
-    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x80)));
-    assertFalse(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x00)));
-    assertFalse(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0xc0)));
-  }
-
   @Test public void responseBodyIsBinary() throws IOException {
     setLevel(Level.BODY);
     Buffer buffer = new Buffer();
@@ -796,6 +785,51 @@ public void headersAreRedacted() throws Exception {
         .assertNoMoreLogs();
   }
 
+  @Test public void duplexRequestsAreNotLogged() throws Exception {
+    platform.assumeHttp2Support();
+
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false); // HTTP/2
+    url = server.url("/");
+
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+        .setBody("Hello response!"));
+
+    RequestBody asyncRequestBody = new RequestBody() {
+      @Override public @Nullable MediaType contentType() {
+        return null;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Hello request!");
+        sink.close();
+      }
+
+      @Override public boolean isDuplex() {
+        return true;
+      }
+    };
+
+    Request request = request()
+        .post(asyncRequestBody)
+        .build();
+    Response response = client.newCall(request).execute();
+    assumeThat(response.protocol(), equalTo(Protocol.HTTP_2));
+
+    assertThat(response.body().string()).isEqualTo("Hello response!");
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url)
+        .assertLogEqual("--> END POST (duplex request body omitted)")
+        .assertLogMatch("<-- 200 " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("content-length: 15")
+        .assertLogEqual("")
+        .assertLogEqual("Hello response!")
+        .assertLogEqual("<-- END HTTP (15-byte body)")
+        .assertNoMoreLogs();
+  }
+
   private Request.Builder request() {
     return new Request.Builder().url(url);
   }
@@ -805,22 +839,22 @@ public void headersAreRedacted() throws Exception {
     private int index;
 
     LogRecorder assertLogEqual(String expected) {
-      assertTrue("No more messages found", index < logs.size());
+      assertThat(index).overridingErrorMessage("No more messages found").isLessThan(logs.size());
       String actual = logs.get(index++);
-      assertEquals(expected, actual);
+      assertThat(actual).isEqualTo(expected);
       return this;
     }
 
     LogRecorder assertLogMatch(String pattern) {
-      assertTrue("No more messages found", index < logs.size());
+      assertThat(index).overridingErrorMessage("No more messages found").isLessThan(logs.size());
       String actual = logs.get(index++);
-      assertTrue("<" + actual + "> did not match pattern <" + pattern + ">",
-          Pattern.matches(pattern, actual));
+      assertThat(actual).matches(Pattern.compile(pattern, Pattern.DOTALL));
       return this;
     }
 
     void assertNoMoreLogs() {
-      assertEquals("More messages remain: " + logs.subList(index, logs.size()), index, logs.size());
+      assertThat(logs.size()).overridingErrorMessage(
+          "More messages remain: " + logs.subList(index, logs.size())).isEqualTo(index);
     }
 
     @Override public void log(String message) {
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
index 84aecb571c..f1e5c239b2 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
@@ -20,6 +20,7 @@
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
+import okhttp3.PlatformRule;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
@@ -31,13 +32,17 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static java.util.Arrays.asList;
+import static okhttp3.Protocol.HTTP_1_1;
+import static okhttp3.Protocol.HTTP_2;
 import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.junit.Assert.assertNotNull;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class LoggingEventListenerTest {
   private static final MediaType PLAIN = MediaType.get("text/plain");
 
+  @Rule public final PlatformRule platform = new PlatformRule();
   @Rule public final MockWebServer server = new MockWebServer();
 
   private final HandshakeCertificates handshakeCertificates = localhost();
@@ -64,7 +69,7 @@ public void setUp() {
   public void get() throws Exception {
     server.enqueue(new MockResponse().setBody("Hello!").setHeader("Content-Type", PLAIN));
     Response response = client.newCall(request().build()).execute();
-    assertNotNull(response.body());
+    assertThat(response.body()).isNotNull();
     response.body().bytes();
 
     logRecorder
@@ -133,9 +138,11 @@ public void secureGet() throws Exception {
 
     server.enqueue(new MockResponse());
     Response response = client.newCall(request().build()).execute();
-    assertNotNull(response.body());
+    assertThat(response.body()).isNotNull();
     response.body().bytes();
 
+    platform.assumeHttp2Support();
+
     logRecorder
         .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
         .assertLogMatch("dnsStart: " + url.host())
@@ -143,8 +150,8 @@ public void secureGet() throws Exception {
         .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
         .assertLogMatch("secureConnectStart")
         .assertLogMatch("secureConnectEnd: Handshake\\{"
-            + "tlsVersion=TLS_1_2 "
-            + "cipherSuite=TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 "
+            + "tlsVersion=TLS_1_[23] "
+            + "cipherSuite=TLS_.* "
             + "peerCertificates=\\[CN=localhost\\] "
             + "localCertificates=\\[\\]}")
         .assertLogMatch("connectEnd: h2")
@@ -189,6 +196,7 @@ public void dnsFail() throws IOException {
   @Test
   public void connectFail() {
     server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.setProtocols(asList(HTTP_2, HTTP_1_1));
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     url = server.url("/");
 
@@ -205,9 +213,9 @@ public void connectFail() {
         .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
         .assertLogMatch("secureConnectStart")
         .assertLogMatch(
-            "connectFailed: null javax\\.net\\.ssl\\.SSLProtocolException: Handshake message sequence violation, 1")
+            "connectFailed: null javax\\.net\\.ssl\\.(?:SSLProtocolException|SSLHandshakeException): (?:Unexpected handshake message: client_hello|Handshake message sequence violation, 1|Read error).*")
         .assertLogMatch(
-            "callFailed: javax.net.ssl.SSLProtocolException: Handshake message sequence violation, 1")
+            "callFailed: javax\\.net\\.ssl\\.(?:SSLProtocolException|SSLHandshakeException): (?:Unexpected handshake message: client_hello|Handshake message sequence violation, 1|Read error).*")
         .assertNoMoreLogs();
   }
 
@@ -216,7 +224,7 @@ public void connectFail() {
   }
 
   private static class LogRecorder extends HttpLoggingInterceptorTest.LogRecorder {
-    LogRecorder assertLogMatch(String pattern) {
+    @Override LogRecorder assertLogMatch(String pattern) {
       return (LogRecorder) super.assertLogMatch("\\[\\d+ ms] " + pattern);
     }
   }
diff --git a/okhttp-sse/Module.md b/okhttp-sse/Module.md
new file mode 100644
index 0000000000..1802142d80
--- /dev/null
+++ b/okhttp-sse/Module.md
@@ -0,0 +1,3 @@
+# Module okhttp-sse
+
+Support for server-sent events.
diff --git a/okhttp-sse/build.gradle b/okhttp-sse/build.gradle
new file mode 100644
index 0000000000..a6a478907b
--- /dev/null
+++ b/okhttp-sse/build.gradle
@@ -0,0 +1,33 @@
+apply plugin: 'com.vanniktech.maven.publish'
+apply plugin: 'me.champeau.gradle.japicmp'
+
+jar {
+  manifest {
+    attributes('Automatic-Module-Name': 'okhttp3.sse')
+  }
+}
+
+dependencies {
+  api project(':okhttp')
+  compileOnly deps.jsr305
+
+  testImplementation project(':okhttp-testing-support')
+  testImplementation project(':mockwebserver')
+  testImplementation deps.junit
+  testImplementation deps.assertj
+  testCompileOnly deps.jsr305
+}
+
+task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
+  oldClasspath = files(baselineJar(project, baselineVersion))
+  newClasspath = files(jar.archivePath)
+  onlyBinaryIncompatibleModified = true
+  failOnModification = true
+  txtOutputFile = file("$buildDir/reports/japi.txt")
+  ignoreMissingClasses = true
+  includeSynthetic = true
+  packageExcludes = [
+      'okhttp3.internal.sse',
+  ]
+}
+check.dependsOn(japicmp)
diff --git a/okhttp-sse/gradle.properties b/okhttp-sse/gradle.properties
new file mode 100644
index 0000000000..497287dfc0
--- /dev/null
+++ b/okhttp-sse/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=okhttp-sse
+POM_NAME=okhttp-sse
+POM_PACKAGING=jar
diff --git a/okhttp-sse/pom.xml b/okhttp-sse/pom.xml
deleted file mode 100644
index bfeb54327f..0000000000
--- a/okhttp-sse/pom.xml
+++ /dev/null
@@ -1,73 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-sse</artifactId>
-  <name>OkHttp Server-Sent Events</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>3.0.1</version>
-        <configuration>
-          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.sse</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java
deleted file mode 100644
index c49e49f4aa..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.sse;
-
-import java.io.IOException;
-import javax.annotation.Nullable;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.EventListener;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Util;
-import okhttp3.sse.EventSource;
-import okhttp3.sse.EventSourceListener;
-
-public final class RealEventSource
-    implements EventSource, ServerSentEventReader.Callback, Callback {
-
-  private final Request request;
-  private final EventSourceListener listener;
-
-  private @Nullable Call call;
-
-  public RealEventSource(Request request, EventSourceListener listener) {
-    this.request = request;
-    this.listener = listener;
-  }
-
-  public void connect(OkHttpClient client) {
-    client = client.newBuilder()
-        .eventListener(EventListener.NONE)
-        .build();
-    call = client.newCall(request);
-    call.timeout().clearTimeout();
-    call.enqueue(this);
-  }
-
-  @Override public void onResponse(Call call, Response response) {
-    processResponse(response);
-  }
-
-  public void processResponse(Response response) {
-    try {
-      if (!response.isSuccessful()) {
-        listener.onFailure(this, null, response);
-        return;
-      }
-
-      ResponseBody body = response.body();
-
-      //noinspection ConstantConditions main body is never null
-      MediaType contentType = body.contentType();
-      if (!isEventStream(contentType)) {
-        listener.onFailure(this,
-            new IllegalStateException("Invalid content-type: " + contentType), response);
-        return;
-      }
-
-      // Replace the body with an empty one so the callbacks can't see real data.
-      response = response.newBuilder().body(Util.EMPTY_RESPONSE).build();
-
-      ServerSentEventReader reader = new ServerSentEventReader(body.source(), this);
-      try {
-        listener.onOpen(this, response);
-        while (reader.processNextEvent()) {
-        }
-      } catch (Exception e) {
-        listener.onFailure(this, e, response);
-        return;
-      }
-
-      listener.onClosed(this);
-    } finally {
-      response.close();
-    }
-  }
-
-  private static boolean isEventStream(@Nullable MediaType contentType) {
-    return contentType != null && contentType.type().equals("text") && contentType.subtype()
-        .equals("event-stream");
-  }
-
-  @Override public void onFailure(Call call, IOException e) {
-    listener.onFailure(this, e, null);
-  }
-
-  @Override public Request request() {
-    return request;
-  }
-
-  @Override public void cancel() {
-    call.cancel();
-  }
-
-  @Override public void onEvent(@Nullable String id, @Nullable String type, String data) {
-    listener.onEvent(this, id, type, data);
-  }
-
-  @Override public void onRetryChange(long timeMs) {
-    // Ignored. We do not auto-retry.
-  }
-}
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.kt b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.kt
new file mode 100644
index 0000000000..116764187d
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.kt
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse
+
+import okhttp3.Call
+import okhttp3.Callback
+import okhttp3.EventListener
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.ResponseBody
+import okhttp3.internal.Internal
+import okhttp3.internal.Util
+import okhttp3.sse.EventSource
+import okhttp3.sse.EventSourceListener
+import java.io.IOException
+
+class RealEventSource(
+  private val request: Request,
+  private val listener: EventSourceListener
+) : EventSource, ServerSentEventReader.Callback, Callback {
+  private lateinit var call: Call
+
+  fun connect(client: OkHttpClient) {
+    val client = client.newBuilder()
+        .eventListener(EventListener.NONE)
+        .build()
+    call = client.newCall(request)
+    call.enqueue(this)
+  }
+
+  override fun onResponse(call: Call, response: Response) {
+    processResponse(response)
+  }
+
+  fun processResponse(response: Response) {
+    response.use {
+      if (!response.isSuccessful) {
+        listener.onFailure(this, null, response)
+        return
+      }
+
+      val body = response.body()!!
+
+      if (!body.isEventStream()) {
+        listener.onFailure(this,
+            IllegalStateException("Invalid content-type: ${body.contentType()}"), response)
+        return
+      }
+
+      // This is a long-lived response. Cancel full-call timeouts.
+      Internal.instance.exchange(response)?.timeoutEarlyExit()
+
+      // Replace the body with an empty one so the callbacks can't see real data.
+      val response = response.newBuilder()
+          .body(Util.EMPTY_RESPONSE)
+          .build()
+
+      val reader = ServerSentEventReader(body.source(), this)
+      try {
+        listener.onOpen(this, response)
+        while (reader.processNextEvent()) {
+        }
+      } catch (e: Exception) {
+        listener.onFailure(this, e, response)
+        return
+      }
+      listener.onClosed(this)
+    }
+  }
+
+  private fun ResponseBody.isEventStream(): Boolean {
+    val contentType = contentType() ?: return false
+    return contentType.type() == "text" && contentType.subtype() == "event-stream"
+  }
+
+  override fun onFailure(call: Call, e: IOException) {
+    listener.onFailure(this, e, null)
+  }
+
+  override fun request(): Request = request
+
+  override fun cancel() {
+    call.cancel()
+  }
+
+  override fun onEvent(id: String?, type: String?, data: String) {
+    listener.onEvent(this, id, type, data)
+  }
+
+  override fun onRetryChange(timeMs: Long) {
+    // Ignored. We do not auto-retry.
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
deleted file mode 100644
index ae19d3745e..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.sse;
-
-import java.io.IOException;
-import javax.annotation.Nullable;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-
-public final class ServerSentEventReader {
-  private static final ByteString CRLF = ByteString.encodeUtf8("\r\n");
-  private static final ByteString DATA = ByteString.encodeUtf8("data");
-  private static final ByteString ID = ByteString.encodeUtf8("id");
-  private static final ByteString EVENT = ByteString.encodeUtf8("event");
-  private static final ByteString RETRY = ByteString.encodeUtf8("retry");
-
-  public interface Callback {
-    void onEvent(@Nullable String id, @Nullable String type, String data);
-    void onRetryChange(long timeMs);
-  }
-
-  private final BufferedSource source;
-  private final Callback callback;
-
-  private String lastId = null;
-
-  public ServerSentEventReader(BufferedSource source, Callback callback) {
-    if (source == null) throw new NullPointerException("source == null");
-    if (callback == null) throw new NullPointerException("callback == null");
-    this.source = source;
-    this.callback = callback;
-  }
-
-  /**
-   * Process the next event. This will result in a single call to {@link Callback#onEvent}
-   * <em>unless</em> the data section was empty. Any number of calls to
-   * {@link Callback#onRetryChange} may occur while processing an event.
-   *
-   * @return false when EOF is reached
-   */
-  boolean processNextEvent() throws IOException {
-    String id = lastId;
-    String type = null;
-    Buffer data = new Buffer();
-
-    while (true) {
-      long lineEnd = source.indexOfElement(CRLF);
-      if (lineEnd == -1L) {
-        return false;
-      }
-
-      switch (source.getBuffer().getByte(0)) {
-        case '\r':
-        case '\n':
-          completeEvent(id, type, data);
-          return true;
-
-        case 'd':
-          if (isKey(DATA)) {
-            parseData(data, lineEnd);
-            continue;
-          }
-          break;
-
-        case 'e':
-          if (isKey(EVENT)) {
-            type = parseEvent(lineEnd);
-            continue;
-          }
-          break;
-
-        case 'i':
-          if (isKey(ID)) {
-            id = parseId(lineEnd);
-            continue;
-          }
-          break;
-
-        case 'r':
-          if (isKey(RETRY)) {
-            parseRetry(lineEnd);
-            continue;
-          }
-          break;
-      }
-
-      source.skip(lineEnd);
-      skipCrAndOrLf();
-    }
-  }
-
-  private void completeEvent(String id, String type, Buffer data) throws IOException {
-    skipCrAndOrLf();
-
-    if (data.size() != 0L) {
-      lastId = id;
-      data.skip(1L); // Leading newline.
-      callback.onEvent(id, type, data.readUtf8());
-    }
-  }
-
-  private void parseData(Buffer data, long end) throws IOException {
-    data.writeByte('\n');
-    end -= skipNameAndDivider(4L);
-    source.readFully(data, end);
-    skipCrAndOrLf();
-  }
-
-  private String parseEvent(long end) throws IOException {
-    String type = null;
-    end -= skipNameAndDivider(5L);
-    if (end != 0L) {
-      type = source.readUtf8(end);
-    }
-    skipCrAndOrLf();
-    return type;
-  }
-
-  private String parseId(long end) throws IOException {
-    String id;
-    end -= skipNameAndDivider(2L);
-    if (end != 0L) {
-      id = source.readUtf8(end);
-    } else {
-      id = null;
-    }
-    skipCrAndOrLf();
-    return id;
-  }
-
-  private void parseRetry(long end) throws IOException {
-    end -= skipNameAndDivider(5L);
-    String retryString = source.readUtf8(end);
-    long retryMs = -1L;
-    try {
-      retryMs = Long.parseLong(retryString);
-    } catch (NumberFormatException ignored) {
-    }
-    if (retryMs != -1L) {
-      callback.onRetryChange(retryMs);
-    }
-    skipCrAndOrLf();
-  }
-
-  /**
-   * Returns true if the first bytes of {@link #source} are {@code key} followed by a colon or
-   * a newline.
-   */
-  private boolean isKey(ByteString key) throws IOException {
-    if (source.rangeEquals(0, key)) {
-      byte nextByte = source.getBuffer().getByte(key.size());
-      return nextByte == ':'
-          || nextByte == '\r'
-          || nextByte == '\n';
-    }
-    return false;
-  }
-
-  /** Consumes {@code \r}, {@code \r\n}, or {@code \n} from {@link #source}. */
-  private void skipCrAndOrLf() throws IOException {
-    if ((source.readByte() & 0xff) == '\r'
-        && source.request(1)
-        && source.getBuffer().getByte(0) == '\n') {
-      source.skip(1);
-    }
-  }
-
-  /**
-   * Consumes the field name of the specified length and the optional colon and its optional
-   * trailing space. Returns the number of bytes skipped.
-   */
-  private long skipNameAndDivider(long length) throws IOException {
-    source.skip(length);
-
-    if (source.getBuffer().getByte(0) == ':') {
-      source.skip(1L);
-      length++;
-
-      if (source.getBuffer().getByte(0) == ' ') {
-        source.skip(1);
-        length++;
-      }
-    }
-
-    return length;
-  }
-}
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.kt b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.kt
new file mode 100644
index 0000000000..98e4d0f970
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.kt
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse
+
+import okio.Buffer
+import okio.BufferedSource
+import okio.ByteString.Companion.encodeUtf8
+import okio.Options
+import java.io.IOException
+
+class ServerSentEventReader(
+  private val source: BufferedSource,
+  private val callback: Callback
+) {
+  private var lastId: String? = null
+
+  interface Callback {
+    fun onEvent(id: String?, type: String?, data: String)
+    fun onRetryChange(timeMs: Long)
+  }
+
+  /**
+   * Process the next event. This will result in a single call to [Callback.onEvent] *unless* the
+   * data section was empty. Any number of calls to [Callback.onRetryChange] may occur while
+   * processing an event.
+   *
+   * @return false when EOF is reached
+   */
+  @Throws(IOException::class)
+  fun processNextEvent(): Boolean {
+    var id = lastId
+    var type: String? = null
+    val data = Buffer()
+
+    while (true) {
+      when (source.select(options)) {
+        in 0..2 -> {
+          completeEvent(id, type, data)
+          return true
+        }
+
+        in 3..4 -> {
+          source.readData(data)
+        }
+
+        in 5..7 -> {
+          data.writeByte('\n'.toInt()) // 'data' on a line of its own.
+        }
+
+        in 8..9 -> {
+          id = source.readUtf8LineStrict().takeIf { it.isNotEmpty() }
+        }
+
+        in 10..12 -> {
+          id = null // 'id' on a line of its own.
+        }
+
+        in 13..14 -> {
+          type = source.readUtf8LineStrict().takeIf { it.isNotEmpty() }
+        }
+
+        in 15..17 -> {
+          type = null // 'event' on a line of its own
+        }
+
+        in 18..19 -> {
+          val retryMs = source.readRetryMs()
+          if (retryMs != -1L) {
+            callback.onRetryChange(retryMs)
+          }
+        }
+
+        -1 -> {
+          val lineEnd = source.indexOfElement(CRLF)
+          if (lineEnd != -1L) {
+            // Skip the line and newline
+            source.skip(lineEnd)
+            source.select(options)
+          } else {
+            return false // No more newlines.
+          }
+        }
+
+        else -> throw AssertionError()
+      }
+    }
+  }
+
+  @Throws(IOException::class)
+  private fun completeEvent(id: String?, type: String?, data: Buffer) {
+    if (data.size != 0L) {
+      lastId = id
+      data.skip(1L) // Leading newline.
+      callback.onEvent(id, type, data.readUtf8())
+    }
+  }
+
+  companion object {
+    val options = Options.of(
+        /*  0 */ "\r\n".encodeUtf8(),
+        /*  1 */ "\r".encodeUtf8(),
+        /*  2 */ "\n".encodeUtf8(),
+
+        /*  3 */ "data: ".encodeUtf8(),
+        /*  4 */ "data:".encodeUtf8(),
+
+        /*  5 */ "data\r\n".encodeUtf8(),
+        /*  6 */ "data\r".encodeUtf8(),
+        /*  7 */ "data\n".encodeUtf8(),
+
+        /*  8 */ "id: ".encodeUtf8(),
+        /*  9 */ "id:".encodeUtf8(),
+
+        /* 10 */ "id\r\n".encodeUtf8(),
+        /* 11 */ "id\r".encodeUtf8(),
+        /* 12 */ "id\n".encodeUtf8(),
+
+        /* 13 */ "event: ".encodeUtf8(),
+        /* 14 */ "event:".encodeUtf8(),
+
+        /* 15 */ "event\r\n".encodeUtf8(),
+        /* 16 */ "event\r".encodeUtf8(),
+        /* 17 */ "event\n".encodeUtf8(),
+
+        /* 18 */ "retry: ".encodeUtf8(),
+        /* 19 */ "retry:".encodeUtf8()
+    )
+
+    private val CRLF = "\r\n".encodeUtf8()
+
+    @Throws(IOException::class)
+    private fun BufferedSource.readData(data: Buffer) {
+      data.writeByte('\n'.toInt())
+      readFully(data, indexOfElement(CRLF))
+      select(options) // Skip the newline bytes.
+    }
+
+    @Throws(IOException::class)
+    private fun BufferedSource.readRetryMs(): Long {
+      val retryString = readUtf8LineStrict()
+      return try {
+        retryString.toLong()
+      } catch (_: NumberFormatException) {
+        -1L
+      }
+    }
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSource.kt
similarity index 75%
rename from okhttp-sse/src/main/java/okhttp3/sse/EventSource.java
rename to okhttp-sse/src/main/java/okhttp3/sse/EventSource.kt
index fe703dc8c0..93ac828aa0 100644
--- a/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSource.kt
@@ -13,27 +13,26 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.sse;
+package okhttp3.sse
 
-import okhttp3.Request;
+import okhttp3.Request
 
-public interface EventSource {
-  /** Returns the original request that initiated this event source. */
-  Request request();
+interface EventSource {
+  /** Returns the original request that initiated this event source.  */
+  fun request(): Request
 
   /**
    * Immediately and violently release resources held by this event source. This does nothing if
    * the event source has already been closed or canceled.
    */
-  void cancel();
+  fun cancel()
 
   interface Factory {
     /**
      * Creates a new event source and immediately returns it. Creating an event source initiates an
-     * asynchronous process to connect the socket. Once that succeeds or fails, {@code listener}
-     * will be notified. The caller must cancel the returned event source when it is no longer
-     * in use.
+     * asynchronous process to connect the socket. Once that succeeds or fails, `listener` will be
+     * notified. The caller must cancel the returned event source when it is no longer in use.
      */
-    EventSource newEventSource(Request request, EventSourceListener listener);
+    fun newEventSource(request: Request, listener: EventSourceListener): EventSource
   }
 }
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.kt
similarity index 69%
rename from okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java
rename to okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.kt
index 4246625eca..cf24ab51c4 100644
--- a/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.kt
@@ -13,38 +13,36 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.sse;
+package okhttp3.sse
 
-import javax.annotation.Nullable;
-import okhttp3.Response;
+import okhttp3.Response
 
-public abstract class EventSourceListener {
+abstract class EventSourceListener {
   /**
    * Invoked when an event source has been accepted by the remote peer and may begin transmitting
    * events.
    */
-  public void onOpen(EventSource eventSource, Response response) {
+  open fun onOpen(eventSource: EventSource, response: Response) {
   }
 
   /**
    * TODO description.
    */
-  public void onEvent(EventSource eventSource, @Nullable String id, @Nullable String type,
-      String data) {
+  open fun onEvent(eventSource: EventSource, id: String?, type: String?, data: String) {
   }
 
   /**
    * TODO description.
+   *
    * No further calls to this listener will be made.
    */
-  public void onClosed(EventSource eventSource) {
+  open fun onClosed(eventSource: EventSource) {
   }
 
   /**
    * Invoked when an event source has been closed due to an error reading from or writing to the
    * network. Incoming events may have been lost. No further calls to this listener will be made.
    */
-  public void onFailure(EventSource eventSource, @Nullable Throwable t,
-      @Nullable Response response) {
+  open fun onFailure(eventSource: EventSource, t: Throwable?, response: Response?) {
   }
 }
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java
deleted file mode 100644
index db0c818d54..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.sse;
-
-import okhttp3.OkHttpClient;
-import okhttp3.Response;
-import okhttp3.internal.sse.RealEventSource;
-
-public final class EventSources {
-  public static EventSource.Factory createFactory(final OkHttpClient client) {
-    return (request, listener) -> {
-      RealEventSource eventSource = new RealEventSource(request, listener);
-      eventSource.connect(client);
-      return eventSource;
-    };
-  }
-
-  public static void processResponse(Response response, EventSourceListener listener) {
-    RealEventSource eventSource = new RealEventSource(response.request(), listener);
-    eventSource.processResponse(response);
-  }
-
-  private EventSources() {
-    throw new AssertionError();
-  }
-}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSources.kt b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.kt
new file mode 100644
index 0000000000..2702cd365f
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.kt
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.sse
+
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.internal.sse.RealEventSource
+
+object EventSources {
+  @JvmStatic
+  fun createFactory(client: OkHttpClient): EventSource.Factory {
+    return object : EventSource.Factory {
+      override fun newEventSource(request: Request, listener: EventSourceListener): EventSource {
+        return RealEventSource(request, listener).apply {
+          connect(client)
+        }
+      }
+    }
+  }
+
+  @JvmStatic
+  fun processResponse(response: Response, listener: EventSourceListener) {
+    val eventSource = RealEventSource(response.request(), listener)
+    eventSource.processResponse(response)
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/package-info.java b/okhttp-sse/src/main/java/okhttp3/sse/package-info.java
deleted file mode 100644
index 2a5f883883..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/sse/package-info.java
+++ /dev/null
@@ -1,3 +0,0 @@
-/** Support for server-sent events. */
-@okhttp3.internal.annotations.EverythingIsNonNull
-package okhttp3.sse;
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
index 7f576eece9..0dbec41be1 100644
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
@@ -17,6 +17,7 @@
 
 import java.util.concurrent.TimeUnit;
 import okhttp3.OkHttpClient;
+import okhttp3.OkHttpClientTestRule;
 import okhttp3.Request;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -26,14 +27,14 @@
 import org.junit.Rule;
 import org.junit.Test;
 
-import static okhttp3.TestUtil.defaultClient;
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class EventSourceHttpTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   private final EventSourceRecorder listener = new EventSourceRecorder();
-  private OkHttpClient client = defaultClient();
+  private OkHttpClient client = clientTestRule.client;
 
   @After public void after() {
     listener.assertExhausted();
@@ -46,7 +47,7 @@
 
     EventSource source = newEventSource();
 
-    assertEquals("/", source.request().url().encodedPath());
+    assertThat(source.request().url().encodedPath()).isEqualTo("/");
 
     listener.assertOpen();
     listener.assertEvent(null, null, "hey");
@@ -71,9 +72,9 @@
     listener.assertFailure(null);
   }
 
-  @Test public void callTimeoutIsNotApplied() throws Exception {
+  @Test public void fullCallTimeoutDoesNotApplyOnceConnected() throws Exception {
     client = client.newBuilder()
-        .callTimeout(100, TimeUnit.MILLISECONDS)
+        .callTimeout(250, TimeUnit.MILLISECONDS)
         .build();
 
     server.enqueue(new MockResponse()
@@ -83,13 +84,27 @@
 
     EventSource source = newEventSource();
 
-    assertEquals("/", source.request().url().encodedPath());
+    assertThat(source.request().url().encodedPath()).isEqualTo("/");
 
     listener.assertOpen();
     listener.assertEvent(null, null, "hey");
     listener.assertClose();
   }
 
+  @Test public void fullCallTimeoutAppliesToSetup() throws Exception {
+    client = client.newBuilder()
+        .callTimeout(250, TimeUnit.MILLISECONDS)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS)
+        .setHeader("content-type", "text/event-stream")
+        .setBody("data: hey\n\n"));
+
+    newEventSource();
+    listener.assertFailure("timeout");
+  }
+
   private EventSource newEventSource() {
     Request request = new Request.Builder()
         .url(server.url("/"))
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
index cf4afd4ec9..bc87c5a644 100644
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
@@ -19,15 +19,13 @@
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingDeque;
 import javax.annotation.Nullable;
-import okhttp3.sse.EventSource;
-import okhttp3.sse.EventSourceListener;
 import okhttp3.Response;
 import okhttp3.internal.platform.Platform;
+import okhttp3.sse.EventSource;
+import okhttp3.sse.EventSourceListener;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class EventSourceRecorder extends EventSourceListener {
   private final BlockingQueue<Object> events = new LinkedBlockingDeque<>();
@@ -67,12 +65,12 @@ private Object nextEvent() {
   }
 
   public void assertExhausted() {
-    assertTrue("Remaining events: " + events, events.isEmpty());
+    assertThat(events).isEmpty();
   }
 
   public void assertEvent(@Nullable String id, @Nullable String type, String data) {
     Object actual = nextEvent();
-    assertEquals(new Event(id, type, data), actual);
+    assertThat(actual).isEqualTo(new Event(id, type, data));
   }
 
   public EventSource assertOpen() {
@@ -96,9 +94,9 @@ public void assertFailure(@Nullable String message) {
       throw new AssertionError("Expected Failure but was " + event);
     }
     if (message != null) {
-      assertEquals(message, ((Failure) event).t.getMessage());
+      assertThat(((Failure) event).t.getMessage()).isEqualTo(message);
     } else {
-      assertNull(((Failure) event).t);
+      assertThat(((Failure) event).t).isNull();
     }
   }
 
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
index 697a2d2019..e837e0e42c 100644
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
@@ -23,24 +23,23 @@
 import org.junit.After;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class ServerSentEventIteratorTest {
   /** Either {@link Event} or {@link Long} items for events and retry changes, respectively. */
   private final Deque<Object> callbacks = new ArrayDeque<>();
 
   @After public void after() {
-    assertTrue("Unconsumed events: " + callbacks, callbacks.isEmpty());
+    assertThat(callbacks).isEmpty();
   }
-  
+
   @Test public void multiline() throws IOException {
     consumeEvents(""
         + "data: YHOO\n"
         + "data: +2\n"
         + "data: 10\n"
         + "\n");
-    assertEquals(new Event(null, null, "YHOO\n+2\n10"), callbacks.remove());
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "YHOO\n+2\n10"));
   }
 
   @Test public void multilineCr() throws IOException {
@@ -49,7 +48,7 @@
         + "data: +2\r"
         + "data: 10\r"
         + "\r");
-    assertEquals(new Event(null, null, "YHOO\n+2\n10"), callbacks.remove());
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "YHOO\n+2\n10"));
   }
 
   @Test public void multilineCrLf() throws IOException {
@@ -58,7 +57,7 @@
         + "data: +2\r\n"
         + "data: 10\r\n"
         + "\r\n");
-    assertEquals(new Event(null, null, "YHOO\n+2\n10"), callbacks.remove());
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "YHOO\n+2\n10"));
   }
 
   @Test public void eventType() throws IOException {
@@ -72,9 +71,9 @@
         + "event: add\n"
         + "data: 113411\n"
         + "\n");
-    assertEquals(new Event(null, "add", "73857293"), callbacks.remove());
-    assertEquals(new Event(null, "remove", "2153"), callbacks.remove());
-    assertEquals(new Event(null, "add", "113411"), callbacks.remove());
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, "add", "73857293"));
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, "remove", "2153"));
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, "add", "113411"));
   }
 
   @Test public void commentsIgnored() throws IOException {
@@ -84,7 +83,7 @@
         + "data: first event\n"
         + "id: 1\n"
         + "\n");
-    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
   }
 
   @Test public void idCleared() throws IOException {
@@ -97,9 +96,9 @@
         + "\n"
         + "data: third event\n"
         + "\n");
-    assertEquals(new Event("1", null, "first event"), callbacks.remove());
-    assertEquals(new Event(null, null, "second event"), callbacks.remove());
-    assertEquals(new Event(null, null, "third event"), callbacks.remove());
+    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "second event"));
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "third event"));
   }
 
   @Test public void nakedFieldNames() throws IOException {
@@ -110,8 +109,8 @@
         + "data\n"
         + "\n"
         + "data:\n");
-    assertEquals(new Event(null, null, ""), callbacks.remove());
-    assertEquals(new Event(null, null, "\n"), callbacks.remove());
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, ""));
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "\n"));
   }
 
   @Test public void colonSpaceOptional() throws IOException {
@@ -120,15 +119,15 @@
         + "\n"
         + "data: test\n"
         + "\n");
-    assertEquals(new Event(null, null, "test"), callbacks.remove());
-    assertEquals(new Event(null, null, "test"), callbacks.remove());
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "test"));
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "test"));
   }
 
   @Test public void leadingWhitespace() throws IOException {
     consumeEvents(""
         + "data:  test\n"
         + "\n");
-    assertEquals(new Event(null, null, " test"), callbacks.remove());
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, " test"));
   }
 
   @Test public void idReusedAcrossEvents() throws IOException {
@@ -141,9 +140,9 @@
         + "id: 2\n"
         + "data: third event\n"
         + "\n");
-    assertEquals(new Event("1", null, "first event"), callbacks.remove());
-    assertEquals(new Event("1", null, "second event"), callbacks.remove());
-    assertEquals(new Event("2", null, "third event"), callbacks.remove());
+    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
+    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "second event"));
+    assertThat(callbacks.remove()).isEqualTo(new Event("2", null, "third event"));
   }
 
   @Test public void idIgnoredFromEmptyEvent() throws IOException {
@@ -155,8 +154,8 @@
         + "\n"
         + "data: second event\n"
         + "\n");
-    assertEquals(new Event("1", null, "first event"), callbacks.remove());
-    assertEquals(new Event("1", null, "second event"), callbacks.remove());
+    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
+    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "second event"));
   }
 
   @Test public void retry() throws IOException {
@@ -166,8 +165,8 @@
         + "data: first event\n"
         + "id: 1\n"
         + "\n");
-    assertEquals(22L, callbacks.remove());
-    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+    assertThat(callbacks.remove()).isEqualTo(22L);
+    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
   }
 
   @Test public void retryInvalidFormatIgnored() throws IOException {
@@ -176,9 +175,39 @@
         + "\n"
         + "retry: hey"
         + "\n");
-    assertEquals(22L, callbacks.remove());
+    assertThat(callbacks.remove()).isEqualTo(22L);
+  }
+
+  @Test public void namePrefixIgnored() throws IOException {
+    consumeEvents(""
+        + "data: a\n"
+        + "eventually\n"
+        + "database\n"
+        + "identity\n"
+        + "retrying\n"
+        + "\n");
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "a"));
+  }
+
+  @Test public void nakedNameClearsIdAndTypeAppendsData() throws IOException {
+    consumeEvents(""
+        + "id: a\n"
+        + "event: b\n"
+        + "data: c\n"
+        + "id\n"
+        + "event\n"
+        + "data\n"
+        + "\n");
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "c\n"));
+  }
+
+  @Test public void nakedRetryIgnored() throws IOException {
+    consumeEvents(""
+        + "retry\n"
+        + "\n");
+    assertThat(callbacks).isEmpty();
   }
-  
+
   private void consumeEvents(String source) throws IOException {
     ServerSentEventReader.Callback callback = new ServerSentEventReader.Callback() {
       @Override public void onEvent(@Nullable String id, @Nullable String type, String data) {
@@ -191,6 +220,7 @@ private void consumeEvents(String source) throws IOException {
     Buffer buffer = new Buffer().writeUtf8(source);
     ServerSentEventReader reader = new ServerSentEventReader(buffer, callback);
     while (reader.processNextEvent());
-    assertEquals("Unconsumed buffer: " + buffer.readUtf8(), 0, buffer.size());
+    assertThat(buffer.size()).overridingErrorMessage("Unconsumed buffer: " + buffer.readUtf8())
+        .isEqualTo(0);
   }
 }
diff --git a/okhttp-testing-support/build.gradle b/okhttp-testing-support/build.gradle
new file mode 100644
index 0000000000..b2611277a1
--- /dev/null
+++ b/okhttp-testing-support/build.gradle
@@ -0,0 +1,8 @@
+dependencies {
+  api project(':okhttp')
+  api deps.junit
+  api deps.assertj
+  api deps.conscrypt
+  
+  compileOnly deps.jsr305
+}
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
deleted file mode 100644
index 8457273d97..0000000000
--- a/okhttp-testing-support/pom.xml
+++ /dev/null
@@ -1,49 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-testing-support</artifactId>
-  <name>OkHttp test support classes</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <optional>true</optional>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.testing</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
index e12ea9c622..82cacacbac 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
@@ -18,12 +18,11 @@
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class FakeDns implements Dns {
   private final Map<String, List<InetAddress>> hostAddresses = new LinkedHashMap<>();
@@ -56,7 +55,7 @@ public InetAddress lookup(String hostname, int index) throws UnknownHostExceptio
   }
 
   public void assertRequests(String... expectedHosts) {
-    assertEquals(Arrays.asList(expectedHosts), requestedHosts);
+    assertThat(requestedHosts).containsExactly(expectedHosts);
     requestedHosts.clear();
   }
 
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java b/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
index ab67a9f06e..3851ca3351 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
@@ -30,38 +30,47 @@ public FakeSSLSession(Certificate... certificates) throws Exception {
     this.certificates = certificates;
   }
 
+  @Override
   public int getApplicationBufferSize() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public String getCipherSuite() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public long getCreationTime() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public byte[] getId() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public long getLastAccessedTime() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public Certificate[] getLocalCertificates() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public Principal getLocalPrincipal() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public int getPacketBufferSize() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException {
     if (certificates.length == 0) {
       throw new SSLPeerUnverifiedException("peer not authenticated");
@@ -70,50 +79,62 @@ public int getPacketBufferSize() {
     }
   }
 
+  @Override
   public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public String getPeerHost() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public int getPeerPort() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public String getProtocol() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public SSLSessionContext getSessionContext() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public void putValue(String s, Object obj) {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public void removeValue(String s) {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public Object getValue(String s) {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public String[] getValueNames() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public void invalidate() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public boolean isValid() {
     throw new UnsupportedOperationException();
   }
diff --git a/okhttp-testing-support/src/main/java/okhttp3/ForwardingRequestBody.java b/okhttp-testing-support/src/main/java/okhttp3/ForwardingRequestBody.java
new file mode 100644
index 0000000000..4aa144c6be
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/ForwardingRequestBody.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+import okio.BufferedSink;
+
+public class ForwardingRequestBody extends RequestBody {
+  private final RequestBody delegate;
+
+  public ForwardingRequestBody(RequestBody delegate) {
+    if (delegate == null) throw new IllegalArgumentException("delegate == null");
+    this.delegate = delegate;
+  }
+
+  public final RequestBody delegate() {
+    return delegate;
+  }
+
+  @Override public @Nullable MediaType contentType() {
+    return delegate.contentType();
+  }
+
+  @Override public long contentLength() throws IOException {
+    return delegate.contentLength();
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    delegate.writeTo(sink);
+  }
+
+  @Override public boolean isDuplex() {
+    return delegate.isDuplex();
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName() + "(" + delegate.toString() + ")";
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/ForwardingResponseBody.java b/okhttp-testing-support/src/main/java/okhttp3/ForwardingResponseBody.java
new file mode 100644
index 0000000000..2cc067ac0c
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/ForwardingResponseBody.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import javax.annotation.Nullable;
+import okio.BufferedSource;
+
+public class ForwardingResponseBody extends ResponseBody {
+  private final ResponseBody delegate;
+
+  public ForwardingResponseBody(ResponseBody delegate) {
+    if (delegate == null) throw new IllegalArgumentException("delegate == null");
+    this.delegate = delegate;
+  }
+
+  public final ResponseBody delegate() {
+    return delegate;
+  }
+
+  @Override public @Nullable MediaType contentType() {
+    return delegate.contentType();
+  }
+
+  @Override public long contentLength() {
+    return delegate.contentLength();
+  }
+
+  @Override public BufferedSource source() {
+    return delegate.source();
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName() + "(" + delegate.toString() + ")";
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.java b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.java
new file mode 100644
index 0000000000..41dacf9b13
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import static okhttp3.TestUtil.defaultClient;
+
+public class OkHttpClientTestRule implements TestRule {
+  public OkHttpClient client = defaultClient();
+
+  @Override
+  public Statement apply(Statement base, Description description) {
+    return statement(base);
+  }
+
+  private Statement statement(final Statement base) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        try {
+          base.evaluate();
+        } finally {
+          TestUtil.ensureAllConnectionsReleased(client);
+        }
+      }
+    };
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/PlatformRule.kt b/okhttp-testing-support/src/main/java/okhttp3/PlatformRule.kt
new file mode 100644
index 0000000000..359de2c688
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/PlatformRule.kt
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.platform.ConscryptPlatform
+import okhttp3.internal.platform.Jdk8WithJettyBootPlatform
+import okhttp3.internal.platform.Jdk9Platform
+import okhttp3.internal.platform.Platform
+import org.conscrypt.Conscrypt
+import org.hamcrest.CoreMatchers.equalTo
+import org.hamcrest.CoreMatchers.not
+import org.junit.Assume.assumeThat
+import org.junit.Assume.assumeTrue
+import org.junit.rules.ExternalResource
+import java.security.Security
+
+/**
+ * Marks a test as Platform aware, before the test runs a consistent Platform will be
+ * established e.g. SecurityProvider for Conscrypt installed.
+ *
+ * Also allows a test file to state general platform assumptions, or for individual test.
+ */
+@Suppress("unused", "MemberVisibilityCanBePrivate")
+open class PlatformRule @JvmOverloads constructor(
+  val requiredPlatformName: String? = null,
+  val platform: Platform? = null
+) : ExternalResource() {
+  override fun before() {
+    if (requiredPlatformName != null) {
+      assumeThat(getPlatformSystemProperty(), equalTo(requiredPlatformName))
+    }
+
+    if (platform != null) {
+      Platform.resetForTests(platform)
+    } else {
+      Platform.resetForTests()
+    }
+  }
+
+  override fun after() {
+    if (platform != null) {
+      Platform.resetForTests()
+    }
+  }
+
+  fun isConscrypt() = getPlatformSystemProperty() == CONSCRYPT_PROPERTY
+
+  fun isJdk9() = getPlatformSystemProperty() == JDK9_PROPERTY
+
+  fun isJdk8() = getPlatformSystemProperty() == JDK8_PROPERTY
+
+  fun isJdk8Alpn() = getPlatformSystemProperty() == JDK8_ALPN_PROPERTY
+
+  fun hasHttp2Support() = !isJdk8()
+
+  fun assumeConscrypt() {
+    assumeThat(getPlatformSystemProperty(), equalTo(
+        CONSCRYPT_PROPERTY))
+  }
+
+  fun assumeJdk9() {
+    assumeThat(getPlatformSystemProperty(), equalTo(
+        JDK9_PROPERTY))
+  }
+
+  fun assumeJdk8() {
+    assumeThat(getPlatformSystemProperty(), equalTo(
+        JDK8_PROPERTY))
+  }
+
+  fun assumeJdk8Alpn() {
+    assumeThat(getPlatformSystemProperty(), equalTo(
+        JDK8_ALPN_PROPERTY))
+  }
+
+  fun assumeHttp2Support() {
+    assumeThat(getPlatformSystemProperty(), not(
+        JDK8_PROPERTY))
+  }
+
+  fun assumeNotConscrypt() {
+    assumeThat(getPlatformSystemProperty(), not(
+        CONSCRYPT_PROPERTY))
+  }
+
+  fun assumeNotJdk9() {
+    assumeThat(getPlatformSystemProperty(), not(
+        JDK9_PROPERTY))
+  }
+
+  fun assumeNotJdk8() {
+    assumeThat(getPlatformSystemProperty(), not(
+        JDK8_PROPERTY))
+  }
+
+  fun assumeNotJdk8Alpn() {
+    assumeThat(getPlatformSystemProperty(), not(
+        JDK8_ALPN_PROPERTY))
+  }
+
+  fun assumeNotHttp2Support() {
+    assumeThat(getPlatformSystemProperty(), equalTo(
+        JDK8_PROPERTY))
+  }
+
+  fun assumeJettyBootEnabled() {
+    assumeTrue("ALPN Boot not enabled", isAlpnBootEnabled())
+  }
+
+  companion object {
+    const val PROPERTY_NAME = "okhttp.platform"
+    const val CONSCRYPT_PROPERTY = "conscrypt"
+    const val JDK9_PROPERTY = "jdk9"
+    const val JDK8_ALPN_PROPERTY = "jdk8alpn"
+    const val JDK8_PROPERTY = "jdk8"
+
+    init {
+      if (getPlatformSystemProperty() == CONSCRYPT_PROPERTY && Security.getProviders()[0].name != "Conscrypt") {
+        if (!Conscrypt.isAvailable()) {
+          System.err.println("Warning: Conscrypt not available")
+        }
+
+        val provider = Conscrypt.newProviderBuilder().provideTrustManager(true).build()
+        Security.insertProviderAt(provider, 1)
+      } else if (getPlatformSystemProperty() == JDK8_ALPN_PROPERTY) {
+        if (!isAlpnBootEnabled()) {
+          System.err.println("Warning: ALPN Boot not enabled")
+        }
+      } else if (getPlatformSystemProperty() == JDK8_PROPERTY) {
+        if (isAlpnBootEnabled()) {
+          System.err.println("Warning: ALPN Boot enabled unintentionally")
+        }
+      }
+    }
+
+    @JvmStatic
+    fun getPlatformSystemProperty(): String {
+      var property: String? = System.getProperty(PROPERTY_NAME)
+
+      if (property == null) {
+        property = when (Platform.get()) {
+          is ConscryptPlatform -> CONSCRYPT_PROPERTY
+          is Jdk8WithJettyBootPlatform -> CONSCRYPT_PROPERTY
+          is Jdk9Platform -> JDK9_PROPERTY
+          else -> JDK8_PROPERTY
+        }
+      }
+
+      return property
+    }
+
+    @JvmStatic
+    fun conscrypt() = PlatformRule(CONSCRYPT_PROPERTY)
+
+    @JvmStatic
+    fun jdk9() = PlatformRule(JDK9_PROPERTY)
+
+    @JvmStatic
+    fun jdk8() = PlatformRule(JDK8_PROPERTY)
+
+    @JvmStatic
+    fun jdk8alpn() = PlatformRule(JDK8_ALPN_PROPERTY)
+
+    @JvmStatic
+    fun isAlpnBootEnabled(): Boolean = try {
+      Class.forName("org.eclipse.jetty.alpn.ALPN", true, null)
+      true
+    } catch (cnfe: ClassNotFoundException) {
+      false
+    }
+  }
+}
\ No newline at end of file
diff --git a/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
index bd4f9be142..eb9e46d9e4 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
@@ -17,19 +17,19 @@
 
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Deque;
 import java.util.List;
 
-import static org.junit.Assert.assertEquals;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class RecordingCookieJar implements CookieJar {
   private final Deque<List<Cookie>> requestCookies = new ArrayDeque<>();
   private final Deque<List<Cookie>> responseCookies = new ArrayDeque<>();
 
   public void enqueueRequestCookies(Cookie... cookies) {
-    requestCookies.add(Arrays.asList(cookies));
+    requestCookies.add(asList(cookies));
   }
 
   public List<Cookie> takeResponseCookies() {
@@ -42,7 +42,7 @@ public void assertResponseCookies(String... cookies) {
     for (Cookie cookie : actualCookies) {
       actualCookieStrings.add(cookie.toString());
     }
-    assertEquals(Arrays.asList(cookies), actualCookieStrings);
+    assertThat(actualCookieStrings).containsExactly(cookies);
   }
 
   @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
diff --git a/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
index 568b7c518c..0b883ee027 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
@@ -23,6 +23,7 @@
 public final class RecordingHostnameVerifier implements HostnameVerifier {
   public final List<String> calls = new ArrayList<>();
 
+  @Override
   public boolean verify(String hostname, SSLSession session) {
     calls.add("verify " + hostname);
     return true;
diff --git a/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java b/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
index 81b47ddf55..f3038c090a 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
@@ -23,6 +23,8 @@
 import java.util.List;
 import okhttp3.internal.http2.Header;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 public final class TestUtil {
   public static final InetSocketAddress UNREACHABLE_ADDRESS
       = new InetSocketAddress("198.51.100.1", 8080);
@@ -83,4 +85,9 @@ public static void awaitGarbageCollection() throws Exception {
     Thread.sleep(100);
     System.runFinalization();
   }
+
+  public static void ensureAllConnectionsReleased(OkHttpClient client) {
+    client.connectionPool().evictAll();
+    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(0);
+  }
 }
diff --git a/okhttp-testing-support/src/main/java/okhttp3/UppercaseRequestInterceptor.java b/okhttp-testing-support/src/main/java/okhttp3/UppercaseRequestInterceptor.java
new file mode 100644
index 0000000000..490c266116
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/UppercaseRequestInterceptor.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+import okio.ForwardingSink;
+import okio.Okio;
+import okio.Sink;
+
+/** Rewrites the request body sent to the server to be all uppercase. */
+public final class UppercaseRequestInterceptor implements Interceptor {
+  @Override public Response intercept(Chain chain) throws IOException {
+    return chain.proceed(uppercaseRequest(chain.request()));
+  }
+
+  /** Returns a request that transforms {@code request} to be all uppercase. */
+  private Request uppercaseRequest(Request request) {
+    RequestBody uppercaseBody = new ForwardingRequestBody(request.body()) {
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        delegate().writeTo(Okio.buffer(uppercaseSink(sink)));
+      }
+    };
+    return request.newBuilder()
+        .method(request.method(), uppercaseBody)
+        .build();
+  }
+
+  private Sink uppercaseSink(Sink sink) {
+    return new ForwardingSink(sink) {
+      @Override public void write(Buffer source, long byteCount) throws IOException {
+        ByteString bytes = source.readByteString(byteCount);
+        delegate().write(new Buffer().write(bytes.toAsciiUppercase()), byteCount);
+      }
+    };
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/UppercaseResponseInterceptor.java b/okhttp-testing-support/src/main/java/okhttp3/UppercaseResponseInterceptor.java
new file mode 100644
index 0000000000..7fbf8ef479
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/UppercaseResponseInterceptor.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
+
+/** Rewrites the response body returned from the server to be all uppercase. */
+public final class UppercaseResponseInterceptor implements Interceptor {
+  @Override public Response intercept(Chain chain) throws IOException {
+    return uppercaseResponse(chain.proceed(chain.request()));
+  }
+
+  private Response uppercaseResponse(Response response) {
+    ResponseBody uppercaseBody = new ForwardingResponseBody(response.body()) {
+      @Override public BufferedSource source() {
+        return Okio.buffer(uppercaseSource(delegate().source()));
+      }
+    };
+    return response.newBuilder()
+        .body(uppercaseBody)
+        .build();
+  }
+
+  private ForwardingSource uppercaseSource(BufferedSource source) {
+    return new ForwardingSource(source) {
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        Buffer buffer = new Buffer();
+        long read = delegate().read(buffer, byteCount);
+        if (read != -1L) sink.write(buffer.readByteString().toAsciiUppercase());
+        return read;
+      }
+    };
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/internal/duplex/AsyncRequestBody.java b/okhttp-testing-support/src/main/java/okhttp3/internal/duplex/AsyncRequestBody.java
new file mode 100644
index 0000000000..a6b554adcb
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/internal/duplex/AsyncRequestBody.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.duplex;
+
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okio.BufferedSink;
+
+import static junit.framework.TestCase.assertTrue;
+
+/** A duplex request body that keeps the provided sinks so they can be written to later. */
+public final class AsyncRequestBody extends RequestBody {
+  private final BlockingQueue<BufferedSink> requestBodySinks = new LinkedBlockingQueue<>();
+
+  @Override public @Nullable MediaType contentType() {
+    return null;
+  }
+
+  @Override public void writeTo(BufferedSink sink) {
+    requestBodySinks.add(sink);
+  }
+
+  @Override public boolean isDuplex() {
+    return true;
+  }
+
+  public BufferedSink takeSink() throws InterruptedException {
+    BufferedSink result = requestBodySinks.poll(5, TimeUnit.SECONDS);
+    if (result == null) throw new AssertionError("no sink to take");
+    return result;
+  }
+
+  public void assertNoMoreSinks() {
+    assertTrue(requestBodySinks.isEmpty());
+  }
+}
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
deleted file mode 100644
index bd1dbd73da..0000000000
--- a/okhttp-tests/pom.xml
+++ /dev/null
@@ -1,107 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-tests</artifactId>
-  <name>OkHttp Tests</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okio</groupId>
-      <artifactId>okio</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-tls</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-urlconnection</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>org.conscrypt</groupId>
-      <artifactId>conscrypt-openjdk-uber</artifactId>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>logging-interceptor</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <version>3.1.0</version>
-        <configuration>
-          <descriptorRefs>
-            <descriptorRef>jar-with-dependencies</descriptorRef>
-          </descriptorRefs>
-          <archive>
-            <manifest>
-              <mainClass>okhttp3.AutobahnTester</mainClass>
-            </manifest>
-          </archive>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>single</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <!-- Do not deploy this as an artifact to Maven central. -->
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-deploy-plugin</artifactId>
-        <version>2.8.2</version>
-        <configuration>
-          <skip>true</skip>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java b/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
deleted file mode 100644
index 356f96ab46..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.concurrent.TimeUnit;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class CacheControlTest {
-  @Test public void emptyBuilderIsEmpty() throws Exception {
-    CacheControl cacheControl = new CacheControl.Builder().build();
-    assertEquals("", cacheControl.toString());
-    assertFalse(cacheControl.noCache());
-    assertFalse(cacheControl.noStore());
-    assertEquals(-1, cacheControl.maxAgeSeconds());
-    assertEquals(-1, cacheControl.sMaxAgeSeconds());
-    assertFalse(cacheControl.isPrivate());
-    assertFalse(cacheControl.isPublic());
-    assertFalse(cacheControl.mustRevalidate());
-    assertEquals(-1, cacheControl.maxStaleSeconds());
-    assertEquals(-1, cacheControl.minFreshSeconds());
-    assertFalse(cacheControl.onlyIfCached());
-    assertFalse(cacheControl.mustRevalidate());
-  }
-
-  @Test public void completeBuilder() throws Exception {
-    CacheControl cacheControl = new CacheControl.Builder()
-        .noCache()
-        .noStore()
-        .maxAge(1, TimeUnit.SECONDS)
-        .maxStale(2, TimeUnit.SECONDS)
-        .minFresh(3, TimeUnit.SECONDS)
-        .onlyIfCached()
-        .noTransform()
-        .immutable()
-        .build();
-    assertEquals("no-cache, no-store, max-age=1, max-stale=2, min-fresh=3, only-if-cached, "
-        + "no-transform, immutable", cacheControl.toString());
-    assertTrue(cacheControl.noCache());
-    assertTrue(cacheControl.noStore());
-    assertEquals(1, cacheControl.maxAgeSeconds());
-    assertEquals(2, cacheControl.maxStaleSeconds());
-    assertEquals(3, cacheControl.minFreshSeconds());
-    assertTrue(cacheControl.onlyIfCached());
-    assertTrue(cacheControl.noTransform());
-    assertTrue(cacheControl.immutable());
-
-    // These members are accessible to response headers only.
-    assertEquals(-1, cacheControl.sMaxAgeSeconds());
-    assertFalse(cacheControl.isPrivate());
-    assertFalse(cacheControl.isPublic());
-    assertFalse(cacheControl.mustRevalidate());
-  }
-
-  @Test public void parseEmpty() throws Exception {
-    CacheControl cacheControl = CacheControl.parse(
-        new Headers.Builder().set("Cache-Control", "").build());
-    assertEquals("", cacheControl.toString());
-    assertFalse(cacheControl.noCache());
-    assertFalse(cacheControl.noStore());
-    assertEquals(-1, cacheControl.maxAgeSeconds());
-    assertEquals(-1, cacheControl.sMaxAgeSeconds());
-    assertFalse(cacheControl.isPublic());
-    assertFalse(cacheControl.mustRevalidate());
-    assertEquals(-1, cacheControl.maxStaleSeconds());
-    assertEquals(-1, cacheControl.minFreshSeconds());
-    assertFalse(cacheControl.onlyIfCached());
-    assertFalse(cacheControl.mustRevalidate());
-  }
-
-  @Test public void parse() throws Exception {
-    String header = "no-cache, no-store, max-age=1, s-maxage=2, private, public, must-revalidate, "
-        + "max-stale=3, min-fresh=4, only-if-cached, no-transform";
-    CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
-        .set("Cache-Control", header)
-        .build());
-    assertTrue(cacheControl.noCache());
-    assertTrue(cacheControl.noStore());
-    assertEquals(1, cacheControl.maxAgeSeconds());
-    assertEquals(2, cacheControl.sMaxAgeSeconds());
-    assertTrue(cacheControl.isPrivate());
-    assertTrue(cacheControl.isPublic());
-    assertTrue(cacheControl.mustRevalidate());
-    assertEquals(3, cacheControl.maxStaleSeconds());
-    assertEquals(4, cacheControl.minFreshSeconds());
-    assertTrue(cacheControl.onlyIfCached());
-    assertTrue(cacheControl.noTransform());
-    assertEquals(header, cacheControl.toString());
-  }
-
-  @Test public void parseIgnoreCacheControlExtensions() throws Exception {
-    // Example from http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.6
-    String header = "private, community=\"UCI\"";
-    CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
-        .set("Cache-Control", header)
-        .build());
-    assertFalse(cacheControl.noCache());
-    assertFalse(cacheControl.noStore());
-    assertEquals(-1, cacheControl.maxAgeSeconds());
-    assertEquals(-1, cacheControl.sMaxAgeSeconds());
-    assertTrue(cacheControl.isPrivate());
-    assertFalse(cacheControl.isPublic());
-    assertFalse(cacheControl.mustRevalidate());
-    assertEquals(-1, cacheControl.maxStaleSeconds());
-    assertEquals(-1, cacheControl.minFreshSeconds());
-    assertFalse(cacheControl.onlyIfCached());
-    assertFalse(cacheControl.noTransform());
-    assertFalse(cacheControl.immutable());
-    assertEquals(header, cacheControl.toString());
-  }
-
-  @Test public void parseCacheControlAndPragmaAreCombined() {
-    Headers headers =
-        Headers.of("Cache-Control", "max-age=12", "Pragma", "must-revalidate", "Pragma", "public");
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertEquals("max-age=12, public, must-revalidate", cacheControl.toString());
-  }
-
-  @SuppressWarnings("RedundantStringConstructorCall") // Testing instance equality.
-  @Test public void parseCacheControlHeaderValueIsRetained() {
-    String value = new String("max-age=12");
-    Headers headers = Headers.of("Cache-Control", value);
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertSame(value, cacheControl.toString());
-  }
-
-  @Test public void parseCacheControlHeaderValueInvalidatedByPragma() {
-    Headers headers = Headers.of("Cache-Control", "max-age=12", "Pragma", "must-revalidate");
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertNull(cacheControl.headerValue);
-  }
-
-  @Test public void parseCacheControlHeaderValueInvalidatedByTwoValues() {
-    Headers headers = Headers.of("Cache-Control", "max-age=12", "Cache-Control", "must-revalidate");
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertNull(cacheControl.headerValue);
-  }
-
-  @Test public void parsePragmaHeaderValueIsNotRetained() {
-    Headers headers = Headers.of("Pragma", "must-revalidate");
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertNull(cacheControl.headerValue);
-  }
-
-  @Test public void computedHeaderValueIsCached() {
-    CacheControl cacheControl = new CacheControl.Builder()
-        .maxAge(2, TimeUnit.DAYS)
-        .build();
-    assertNull(cacheControl.headerValue);
-    assertEquals("max-age=172800", cacheControl.toString());
-    assertEquals("max-age=172800", cacheControl.headerValue);
-    cacheControl.headerValue = "Hi";
-    assertEquals("Hi", cacheControl.toString());
-  }
-
-  @Test public void timeDurationTruncatedToMaxValue() throws Exception {
-    CacheControl cacheControl = new CacheControl.Builder()
-        .maxAge(365 * 100, TimeUnit.DAYS) // Longer than Integer.MAX_VALUE seconds.
-        .build();
-    assertEquals(Integer.MAX_VALUE, cacheControl.maxAgeSeconds());
-  }
-
-  @Test public void secondsMustBeNonNegative() throws Exception {
-    CacheControl.Builder builder = new CacheControl.Builder();
-    try {
-      builder.maxAge(-1, TimeUnit.SECONDS);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void timePrecisionIsTruncatedToSeconds() throws Exception {
-    CacheControl cacheControl = new CacheControl.Builder()
-        .maxAge(4999, TimeUnit.MILLISECONDS)
-        .build();
-    assertEquals(4, cacheControl.maxAgeSeconds());
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
deleted file mode 100644
index b95f8521a5..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.Socket;
-import java.util.Collections;
-import java.util.concurrent.TimeUnit;
-import javax.net.SocketFactory;
-import okhttp3.internal.Internal;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.connection.StreamAllocation;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.awaitGarbageCollection;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-public final class ConnectionPoolTest {
-  private final Address addressA = newAddress("a");
-  private final Route routeA1 = newRoute(addressA);
-  private final Address addressB = newAddress("b");
-  private final Route routeB1 = newRoute(addressB);
-  private final Address addressC = newAddress("c");
-  private final Route routeC1 = newRoute(addressC);
-
-  static {
-    Internal.initializeInstanceForTests();
-  }
-
-  @Test public void connectionsEvictedWhenIdleLongEnough() throws Exception {
-    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
-
-    RealConnection c1 = newConnection(pool, routeA1, 50L);
-
-    // Running at time 50, the pool returns that nothing can be evicted until time 150.
-    assertEquals(100L, pool.cleanup(50L));
-    assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket().isClosed());
-
-    // Running at time 60, the pool returns that nothing can be evicted until time 150.
-    assertEquals(90L, pool.cleanup(60L));
-    assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket().isClosed());
-
-    // Running at time 149, the pool returns that nothing can be evicted until time 150.
-    assertEquals(1L, pool.cleanup(149L));
-    assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket().isClosed());
-
-    // Running at time 150, the pool evicts.
-    assertEquals(0, pool.cleanup(150L));
-    assertEquals(0, pool.connectionCount());
-    assertTrue(c1.socket().isClosed());
-
-    // Running again, the pool reports that no further runs are necessary.
-    assertEquals(-1, pool.cleanup(150L));
-    assertEquals(0, pool.connectionCount());
-    assertTrue(c1.socket().isClosed());
-  }
-
-  @Test public void inUseConnectionsNotEvicted() throws Exception {
-    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
-
-    RealConnection c1 = newConnection(pool, routeA1, 50L);
-    synchronized (pool) {
-      StreamAllocation streamAllocation = new StreamAllocation(pool, addressA, null,
-          EventListener.NONE, null);
-      streamAllocation.acquire(c1, true);
-    }
-
-    // Running at time 50, the pool returns that nothing can be evicted until time 150.
-    assertEquals(100L, pool.cleanup(50L));
-    assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket().isClosed());
-
-    // Running at time 60, the pool returns that nothing can be evicted until time 160.
-    assertEquals(100L, pool.cleanup(60L));
-    assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket().isClosed());
-
-    // Running at time 160, the pool returns that nothing can be evicted until time 260.
-    assertEquals(100L, pool.cleanup(160L));
-    assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket().isClosed());
-  }
-
-  @Test public void cleanupPrioritizesEarliestEviction() throws Exception {
-    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
-
-    RealConnection c1 = newConnection(pool, routeA1, 75L);
-    RealConnection c2 = newConnection(pool, routeB1, 50L);
-
-    // Running at time 75, the pool returns that nothing can be evicted until time 150.
-    assertEquals(75L, pool.cleanup(75L));
-    assertEquals(2, pool.connectionCount());
-
-    // Running at time 149, the pool returns that nothing can be evicted until time 150.
-    assertEquals(1L, pool.cleanup(149L));
-    assertEquals(2, pool.connectionCount());
-
-    // Running at time 150, the pool evicts c2.
-    assertEquals(0L, pool.cleanup(150L));
-    assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket().isClosed());
-    assertTrue(c2.socket().isClosed());
-
-    // Running at time 150, the pool returns that nothing can be evicted until time 175.
-    assertEquals(25L, pool.cleanup(150L));
-    assertEquals(1, pool.connectionCount());
-
-    // Running at time 175, the pool evicts c1.
-    assertEquals(0L, pool.cleanup(175L));
-    assertEquals(0, pool.connectionCount());
-    assertTrue(c1.socket().isClosed());
-    assertTrue(c2.socket().isClosed());
-  }
-
-  @Test public void oldestConnectionsEvictedIfIdleLimitExceeded() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
-    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
-
-    RealConnection c1 = newConnection(pool, routeA1, 50L);
-    RealConnection c2 = newConnection(pool, routeB1, 75L);
-
-    // With 2 connections, there's no need to evict until the connections time out.
-    assertEquals(50L, pool.cleanup(100L));
-    assertEquals(2, pool.connectionCount());
-    assertFalse(c1.socket().isClosed());
-    assertFalse(c2.socket().isClosed());
-
-    // Add a third connection
-    RealConnection c3 = newConnection(pool, routeC1, 75L);
-
-    // The third connection bounces the first.
-    assertEquals(0L, pool.cleanup(100L));
-    assertEquals(2, pool.connectionCount());
-    assertTrue(c1.socket().isClosed());
-    assertFalse(c2.socket().isClosed());
-    assertFalse(c3.socket().isClosed());
-  }
-
-  @Test public void leakedAllocation() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
-    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
-
-    RealConnection c1 = newConnection(pool, routeA1, 0L);
-    allocateAndLeakAllocation(pool, c1);
-
-    awaitGarbageCollection();
-    assertEquals(0L, pool.cleanup(100L));
-    assertEquals(Collections.emptyList(), c1.allocations);
-
-    assertTrue(c1.noNewStreams); // Can't allocate once a leak has been detected.
-  }
-
-  /** Use a helper method so there's no hidden reference remaining on the stack. */
-  private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
-    synchronized (pool) {
-      StreamAllocation leak = new StreamAllocation(pool, connection.route().address(), null,
-          EventListener.NONE, null);
-      leak.acquire(connection, true);
-    }
-  }
-
-  private RealConnection newConnection(ConnectionPool pool, Route route, long idleAtNanos) {
-    RealConnection result = RealConnection.testConnection(pool, route, new Socket(), idleAtNanos);
-    synchronized (pool) {
-      pool.put(result);
-    }
-    return result;
-  }
-
-  private Address newAddress(String name) {
-    return new Address(name, 1, Dns.SYSTEM, SocketFactory.getDefault(), null, null, null,
-        new RecordingOkAuthenticator("password", null), null, Collections.emptyList(),
-        Collections.emptyList(), ProxySelector.getDefault());
-  }
-
-  private Route newRoute(Address address) {
-    return new Route(address, Proxy.NO_PROXY,
-        InetSocketAddress.createUnresolved(address.url().host(), address.url().port()));
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java b/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java
deleted file mode 100644
index 2add4201e3..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.security.Security;
-import java.util.Arrays;
-import okhttp3.internal.platform.ConscryptPlatform;
-import okhttp3.internal.platform.Platform;
-import org.conscrypt.OpenSSLProvider;
-import org.junit.Assume;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-
-public class ConscryptTest {
-  public static final CipherSuite[] MANDATORY_CIPHER_SUITES = new CipherSuite[] {
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
-  };
-
-  private OkHttpClient client = buildClient();
-
-  private OkHttpClient buildClient() {
-    ConnectionSpec spec = new ConnectionSpec.Builder(true)
-        .cipherSuites(MANDATORY_CIPHER_SUITES) // Check we are using strong ciphers
-        .tlsVersions(TlsVersion.TLS_1_2) // and modern TLS
-        .supportsTlsExtensions(true)
-        .build();
-
-    return new OkHttpClient.Builder().connectionSpecs(Arrays.asList(spec)).build();
-  }
-
-  private static void assumeConscrypt() {
-    Assume.assumeTrue("conscrypt".equals(System.getProperty("okhttp.platform")));
-  }
-
-  private static void assumeNetwork() {
-    try {
-      InetAddress.getByName("www.google.com");
-    } catch (UnknownHostException uhe) {
-      Assume.assumeNoException(uhe);
-    }
-  }
-
-  @Test
-  public void testMozilla() throws IOException {
-    assumeNetwork();
-    assumeConscrypt();
-
-    Request request = new Request.Builder().url("https://mozilla.org/robots.txt").build();
-
-    Response response = client.newCall(request).execute();
-
-    assertEquals(Protocol.HTTP_2, response.protocol());
-  }
-
-  @Test
-  public void testGoogle() throws IOException {
-    assumeNetwork();
-    assumeConscrypt();
-
-    Request request = new Request.Builder().url("https://google.com/robots.txt").build();
-
-    Response response = client.newCall(request).execute();
-
-    assertEquals(Protocol.HTTP_2, response.protocol());
-  }
-
-  @Test
-  public void testBuild() {
-    assertNotNull(ConscryptPlatform.buildIfSupported());
-  }
-
-  @Test
-  public void testPreferred() {
-    Assume.assumeFalse(Platform.isConscryptPreferred());
-
-    try {
-      Security.insertProviderAt(new OpenSSLProvider(), 1);
-      assertTrue(Platform.isConscryptPreferred());
-    } finally {
-      Security.removeProvider("Conscrypt");
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/CookieTest.java b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
deleted file mode 100644
index 3304fa588a..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/CookieTest.java
+++ /dev/null
@@ -1,580 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-import java.util.Objects;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpDate;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class CookieTest {
-  HttpUrl url = HttpUrl.get("https://example.com/");
-
-  @Test public void simpleCookie() throws Exception {
-    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42");
-    assertEquals("SID=31d4d96e407aad42; path=/", cookie.toString());
-  }
-
-  @Test public void noEqualsSign() throws Exception {
-    assertNull(Cookie.parse(url, "foo"));
-    assertNull(Cookie.parse(url, "foo; Path=/"));
-  }
-
-  @Test public void emptyName() throws Exception {
-    assertNull(Cookie.parse(url, "=b"));
-    assertNull(Cookie.parse(url, " =b"));
-    assertNull(Cookie.parse(url, "\r\t \n=b"));
-  }
-
-  @Test public void spaceInName() throws Exception {
-    assertEquals("a b", Cookie.parse(url, "a b=cd").name());
-  }
-
-  @Test public void spaceInValue() throws Exception {
-    assertEquals("c d", Cookie.parse(url, "ab=c d").value());
-  }
-
-  @Test public void trimLeadingAndTrailingWhitespaceFromName() throws Exception {
-    assertEquals("a", Cookie.parse(url, " a=b").name());
-    assertEquals("a", Cookie.parse(url, "a =b").name());
-    assertEquals("a", Cookie.parse(url, "\r\t \na\n\t \n=b").name());
-  }
-
-  @Test public void emptyValue() throws Exception {
-    assertEquals("", Cookie.parse(url, "a=").value());
-    assertEquals("", Cookie.parse(url, "a= ").value());
-    assertEquals("", Cookie.parse(url, "a=\r\t \n").value());
-  }
-
-  @Test public void trimLeadingAndTrailingWhitespaceFromValue() throws Exception {
-    assertEquals("", Cookie.parse(url, "a= ").value());
-    assertEquals("b", Cookie.parse(url, "a= b").value());
-    assertEquals("b", Cookie.parse(url, "a=b ").value());
-    assertEquals("b", Cookie.parse(url, "a=\r\t \nb\n\t \n").value());
-  }
-
-  @Test public void invalidCharacters() throws Exception {
-    assertNull(Cookie.parse(url, "a\u0000b=cd"));
-    assertNull(Cookie.parse(url, "ab=c\u0000d"));
-    assertNull(Cookie.parse(url, "a\u0001b=cd"));
-    assertNull(Cookie.parse(url, "ab=c\u0001d"));
-    assertNull(Cookie.parse(url, "a\u0009b=cd"));
-    assertNull(Cookie.parse(url, "ab=c\u0009d"));
-    assertNull(Cookie.parse(url, "a\u001fb=cd"));
-    assertNull(Cookie.parse(url, "ab=c\u001fd"));
-    assertNull(Cookie.parse(url, "a\u007fb=cd"));
-    assertNull(Cookie.parse(url, "ab=c\u007fd"));
-    assertNull(Cookie.parse(url, "a\u0080b=cd"));
-    assertNull(Cookie.parse(url, "ab=c\u0080d"));
-    assertNull(Cookie.parse(url, "a\u00ffb=cd"));
-    assertNull(Cookie.parse(url, "ab=c\u00ffd"));
-  }
-
-  @Test public void maxAge() throws Exception {
-    assertEquals(51000L,
-        Cookie.parse(50000L, url, "a=b; Max-Age=1").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854724").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854725").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854726").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=1").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=2").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=3").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=10000000000000000000").expiresAt());
-  }
-
-  @Test public void maxAgeNonPositive() throws Exception {
-    assertEquals(Long.MIN_VALUE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=-1").expiresAt());
-    assertEquals(Long.MIN_VALUE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=0").expiresAt());
-    assertEquals(Long.MIN_VALUE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=-9223372036854775808").expiresAt());
-    assertEquals(Long.MIN_VALUE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=-9223372036854775809").expiresAt());
-    assertEquals(Long.MIN_VALUE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=-10000000000000000000").expiresAt());
-  }
-
-  @Test public void domainAndPath() throws Exception {
-    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Domain=example.com");
-    assertEquals("example.com", cookie.domain());
-    assertEquals("/", cookie.path());
-    assertFalse(cookie.hostOnly());
-    assertEquals("SID=31d4d96e407aad42; domain=example.com; path=/", cookie.toString());
-  }
-
-  @Test public void secureAndHttpOnly() throws Exception {
-    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Secure; HttpOnly");
-    assertTrue(cookie.secure());
-    assertTrue(cookie.httpOnly());
-    assertEquals("SID=31d4d96e407aad42; path=/; secure; httponly", cookie.toString());
-  }
-
-  @Test public void expiresDate() throws Exception {
-    assertEquals(date("1970-01-01T00:00:00.000+0000"), new Date(
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT").expiresAt()));
-    assertEquals(date("2021-06-09T10:18:14.000+0000"), new Date(
-        Cookie.parse(url, "a=b; Expires=Wed, 09 Jun 2021 10:18:14 GMT").expiresAt()));
-    assertEquals(date("1994-11-06T08:49:37.000+0000"), new Date(
-        Cookie.parse(url, "a=b; Expires=Sun, 06 Nov 1994 08:49:37 GMT").expiresAt()));
-  }
-
-  @Test public void awkwardDates() throws Exception {
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 70 00:00:00 GMT").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 January 1970 00:00:00 GMT").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Janucember 1970 00:00:00 GMT").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=Thu, 1 Jan 1970 00:00:00 GMT").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 0:00:00 GMT").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:0:00 GMT").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:0 GMT").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=00:00:00 Thu, 01 Jan 1970 GMT").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 01").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 1").expiresAt());
-  }
-
-  @Test public void invalidYear() throws Exception {
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1600 00:00:00 GMT").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 19999 00:00:00 GMT").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 00:00:00 GMT").expiresAt());
-  }
-
-  @Test public void invalidMonth() throws Exception {
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Foo 1970 00:00:00 GMT").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Foocember 1970 00:00:00 GMT").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 1970 00:00:00 GMT").expiresAt());
-  }
-
-  @Test public void invalidDayOfMonth() throws Exception {
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 32 Jan 1970 00:00:00 GMT").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, Jan 1970 00:00:00 GMT").expiresAt());
-  }
-
-  @Test public void invalidHour() throws Exception {
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 24:00:00 GMT").expiresAt());
-  }
-
-  @Test public void invalidMinute() throws Exception {
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:60:00 GMT").expiresAt());
-  }
-
-  @Test public void invalidSecond() throws Exception {
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:60 GMT").expiresAt());
-  }
-
-  @Test public void domainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com");
-    assertTrue(cookie.matches(HttpUrl.get("http://example.com")));
-    assertTrue(cookie.matches(HttpUrl.get("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.get("http://square.com")));
-  }
-
-  /** If no domain is present, match only the origin domain. */
-  @Test public void domainMatchesNoDomain() throws Exception {
-    Cookie cookie = Cookie.parse(url, "a=b");
-    assertTrue(cookie.matches(HttpUrl.get("http://example.com")));
-    assertFalse(cookie.matches(HttpUrl.get("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.get("http://square.com")));
-  }
-
-  /** Ignore an optional leading `.` in the domain. */
-  @Test public void domainMatchesIgnoresLeadingDot() throws Exception {
-    Cookie cookie = Cookie.parse(url, "a=b; domain=.example.com");
-    assertTrue(cookie.matches(HttpUrl.get("http://example.com")));
-    assertTrue(cookie.matches(HttpUrl.get("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.get("http://square.com")));
-  }
-
-  /** Ignore the entire attribute if the domain ends with `.`. */
-  @Test public void domainIgnoredWithTrailingDot() throws Exception {
-    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com.");
-    assertTrue(cookie.matches(HttpUrl.get("http://example.com")));
-    assertFalse(cookie.matches(HttpUrl.get("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.get("http://square.com")));
-  }
-
-  @Test public void idnDomainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://.net/"), "a=b; domain=.net");
-    assertTrue(cookie.matches(HttpUrl.get("http://.net/")));
-    assertTrue(cookie.matches(HttpUrl.get("http://xn--n3h.net/")));
-    assertTrue(cookie.matches(HttpUrl.get("http://www..net/")));
-    assertTrue(cookie.matches(HttpUrl.get("http://www.xn--n3h.net/")));
-  }
-
-  @Test public void punycodeDomainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://xn--n3h.net/"), "a=b; domain=xn--n3h.net");
-    assertTrue(cookie.matches(HttpUrl.get("http://.net/")));
-    assertTrue(cookie.matches(HttpUrl.get("http://xn--n3h.net/")));
-    assertTrue(cookie.matches(HttpUrl.get("http://www..net/")));
-    assertTrue(cookie.matches(HttpUrl.get("http://www.xn--n3h.net/")));
-  }
-
-  @Test public void domainMatchesIpAddress() throws Exception {
-    HttpUrl urlWithIp = HttpUrl.get("http://123.45.234.56/");
-    assertNull(Cookie.parse(urlWithIp, "a=b; domain=234.56"));
-    assertEquals("123.45.234.56", Cookie.parse(urlWithIp, "a=b; domain=123.45.234.56").domain());
-  }
-
-  @Test public void domainMatchesIpv6Address() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::1");
-    assertEquals("::1", cookie.domain());
-    assertTrue(cookie.matches(HttpUrl.get("http://[::1]/")));
-  }
-
-  @Test public void domainMatchesIpv6AddressWithCompression() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://[0001:0000::]/"), "a=b; domain=0001:0000::");
-    assertEquals("1::", cookie.domain());
-    assertTrue(cookie.matches(HttpUrl.get("http://[1::]/")));
-  }
-
-  @Test public void domainMatchesIpv6AddressWithIpv4Suffix() throws Exception {
-    Cookie cookie = Cookie.parse(
-        HttpUrl.get("http://[::1:ffff:ffff]/"), "a=b; domain=::1:255.255.255.255");
-    assertEquals("::1:ffff:ffff", cookie.domain());
-    assertTrue(cookie.matches(HttpUrl.get("http://[::1:ffff:ffff]/")));
-  }
-
-  @Test public void ipv6AddressDoesntMatch() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::2");
-    assertNull(cookie);
-  }
-
-  @Test public void ipv6AddressMalformed() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::2::2");
-    assertEquals("::1", cookie.domain());
-  }
-
-  /**
-   * These public suffixes were selected by inspecting the publicsuffix.org list. It's possible they
-   * may change in the future. If this test begins to fail, please double check they are still
-   * present in the public suffix list.
-   */
-  @Test public void domainIsPublicSuffix() {
-    HttpUrl ascii = HttpUrl.get("https://foo1.foo.bar.elb.amazonaws.com");
-    assertNotNull(Cookie.parse(ascii, "a=b; domain=foo.bar.elb.amazonaws.com"));
-    assertNull(Cookie.parse(ascii, "a=b; domain=bar.elb.amazonaws.com"));
-    assertNull(Cookie.parse(ascii, "a=b; domain=com"));
-
-    HttpUrl unicode = HttpUrl.get("https://...jp");
-    assertNotNull(Cookie.parse(unicode, "a=b; domain=..jp"));
-    assertNull(Cookie.parse(unicode, "a=b; domain=.jp"));
-
-    HttpUrl punycode = HttpUrl.get("https://xn--ue5a.xn--ue5a.xn--8ltr62k.jp");
-    assertNotNull(Cookie.parse(punycode, "a=b; domain=xn--ue5a.xn--8ltr62k.jp"));
-    assertNull(Cookie.parse(punycode, "a=b; domain=xn--8ltr62k.jp"));
-  }
-
-  @Test public void hostOnly() throws Exception {
-    assertTrue(Cookie.parse(url, "a=b").hostOnly());
-    assertFalse(Cookie.parse(url, "a=b; domain=example.com").hostOnly());
-  }
-
-  @Test public void defaultPath() throws Exception {
-    assertEquals("/foo", Cookie.parse(HttpUrl.get("http://example.com/foo/bar"), "a=b").path());
-    assertEquals("/foo", Cookie.parse(HttpUrl.get("http://example.com/foo/"), "a=b").path());
-    assertEquals("/", Cookie.parse(HttpUrl.get("http://example.com/foo"), "a=b").path());
-    assertEquals("/", Cookie.parse(HttpUrl.get("http://example.com/"), "a=b").path());
-  }
-
-  @Test public void defaultPathIsUsedIfPathDoesntHaveLeadingSlash() throws Exception {
-    assertEquals("/foo", Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
-        "a=b; path=quux").path());
-    assertEquals("/foo", Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
-        "a=b; path=").path());
-  }
-
-  @Test public void pathAttributeDoesntNeedToMatch() throws Exception {
-    assertEquals("/quux", Cookie.parse(HttpUrl.get("http://example.com/"),
-        "a=b; path=/quux").path());
-    assertEquals("/quux", Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
-        "a=b; path=/quux").path());
-  }
-
-  @Test public void httpOnly() throws Exception {
-    assertFalse(Cookie.parse(url, "a=b").httpOnly());
-    assertTrue(Cookie.parse(url, "a=b; HttpOnly").httpOnly());
-  }
-
-  @Test public void secure() throws Exception {
-    assertFalse(Cookie.parse(url, "a=b").secure());
-    assertTrue(Cookie.parse(url, "a=b; Secure").secure());
-  }
-
-  @Test public void maxAgeTakesPrecedenceOverExpires() throws Exception {
-    // Max-Age = 1, Expires = 2. In either order.
-    assertEquals(1000L, Cookie.parse(
-        0L, url, "a=b; Max-Age=1; Expires=Thu, 01 Jan 1970 00:00:02 GMT").expiresAt());
-    assertEquals(1000L, Cookie.parse(
-        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:02 GMT; Max-Age=1").expiresAt());
-    // Max-Age = 2, Expires = 1. In either order.
-    assertEquals(2000L, Cookie.parse(
-        0L, url, "a=b; Max-Age=2; Expires=Thu, 01 Jan 1970 00:00:01 GMT").expiresAt());
-    assertEquals(2000L, Cookie.parse(
-        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Max-Age=2").expiresAt());
-  }
-
-  /** If a cookie incorrectly defines multiple 'Max-Age' attributes, the last one defined wins. */
-  @Test public void lastMaxAgeWins() throws Exception {
-    assertEquals(3000L, Cookie.parse(
-        0L, url, "a=b; Max-Age=2; Max-Age=4; Max-Age=1; Max-Age=3").expiresAt());
-  }
-
-  /** If a cookie incorrectly defines multiple 'Expires' attributes, the last one defined wins. */
-  @Test public void lastExpiresAtWins() throws Exception {
-    assertEquals(3000L, Cookie.parse(0L, url, "a=b; "
-        + "Expires=Thu, 01 Jan 1970 00:00:02 GMT; "
-        + "Expires=Thu, 01 Jan 1970 00:00:04 GMT; "
-        + "Expires=Thu, 01 Jan 1970 00:00:01 GMT; "
-        + "Expires=Thu, 01 Jan 1970 00:00:03 GMT").expiresAt());
-  }
-
-  @Test public void maxAgeOrExpiresMakesCookiePersistent() throws Exception {
-    assertFalse(Cookie.parse(0L, url, "a=b").persistent());
-    assertTrue(Cookie.parse(0L, url, "a=b; Max-Age=1").persistent());
-    assertTrue(Cookie.parse(0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT").persistent());
-  }
-
-  @Test public void parseAll() throws Exception {
-    Headers headers = new Headers.Builder()
-        .add("Set-Cookie: a=b")
-        .add("Set-Cookie: c=d")
-        .build();
-    List<Cookie> cookies = Cookie.parseAll(url, headers);
-    assertEquals(2, cookies.size());
-    assertEquals("a=b; path=/", cookies.get(0).toString());
-    assertEquals("c=d; path=/", cookies.get(1).toString());
-  }
-
-  @Test public void builder() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .domain("example.com")
-        .build();
-    assertEquals("a", cookie.name());
-    assertEquals("b", cookie.value());
-    assertEquals(HttpDate.MAX_DATE, cookie.expiresAt());
-    assertEquals("example.com", cookie.domain());
-    assertEquals("/", cookie.path());
-    assertFalse(cookie.secure());
-    assertFalse(cookie.httpOnly());
-    assertFalse(cookie.persistent());
-    assertFalse(cookie.hostOnly());
-  }
-
-  @Test public void builderNameValidation() throws Exception {
-    try {
-      new Cookie.Builder().name(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      new Cookie.Builder().name(" a ");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void builderValueValidation() throws Exception {
-    try {
-      new Cookie.Builder().value(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      new Cookie.Builder().value(" b ");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void builderClampsMaxDate() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .expiresAt(Long.MAX_VALUE)
-        .build();
-    assertEquals("a=b; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/", cookie.toString());
-  }
-
-  @Test public void builderExpiresAt() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .expiresAt(date("1970-01-01T00:00:01.000+0000").getTime())
-        .build();
-    assertEquals("a=b; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/", cookie.toString());
-  }
-
-  @Test public void builderClampsMinDate() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .expiresAt(date("1970-01-01T00:00:00.000+0000").getTime())
-        .build();
-    assertEquals("a=b; max-age=0; path=/", cookie.toString());
-  }
-
-  @Test public void builderDomainValidation() throws Exception {
-    try {
-      new Cookie.Builder().hostOnlyDomain(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      new Cookie.Builder().hostOnlyDomain("a/b");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void builderDomain() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("squareup.com")
-        .build();
-    assertEquals("squareup.com", cookie.domain());
-    assertTrue(cookie.hostOnly());
-  }
-
-  @Test public void builderPath() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .path("/foo")
-        .build();
-    assertEquals("/foo", cookie.path());
-  }
-
-  @Test public void builderPathValidation() throws Exception {
-    try {
-      new Cookie.Builder().path(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      new Cookie.Builder().path("foo");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void builderSecure() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .secure()
-        .build();
-    assertTrue(cookie.secure());
-  }
-
-  @Test public void builderHttpOnly() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .httpOnly()
-        .build();
-    assertTrue(cookie.httpOnly());
-  }
-
-  @Test public void builderIpv6() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .domain("0:0:0:0:0:0:0:1")
-        .build();
-    assertEquals("::1", cookie.domain());
-  }
-
-  @Test public void equalsAndHashCode() throws Exception {
-    List<String> cookieStrings = Arrays.asList(
-        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
-        "a= ; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
-        "a=b;          Domain=example.com; Max-Age=5; Secure; HttpOnly",
-        "a=b; Path=/c;                     Max-Age=5; Secure; HttpOnly",
-        "a=b; Path=/c; Domain=example.com;            Secure; HttpOnly",
-        "a=b; Path=/c; Domain=example.com; Max-Age=5;         HttpOnly",
-        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure;         "
-    );
-    for (String stringA : cookieStrings) {
-      Cookie cookieA = Cookie.parse(0, url, stringA);
-      for (String stringB : cookieStrings) {
-        Cookie cookieB = Cookie.parse(0, url, stringB);
-        if (Objects.equals(stringA, stringB)) {
-          assertEquals(cookieA.hashCode(), cookieB.hashCode());
-          assertEquals(cookieA, cookieB);
-        } else {
-          assertNotEquals(cookieA.hashCode(), cookieB.hashCode());
-          assertNotEquals(cookieA, cookieB);
-        }
-      }
-      assertNotEquals(null, cookieA);
-    }
-  }
-
-  private Date date(String s) throws ParseException {
-    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
-    format.setTimeZone(Util.UTC);
-    return format.parse(s);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/DuplexTest.java b/okhttp-tests/src/test/java/okhttp3/DuplexTest.java
deleted file mode 100644
index c911c700e2..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/DuplexTest.java
+++ /dev/null
@@ -1,283 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.internal.duplex.DuplexRequestBody;
-import okhttp3.internal.duplex.MwsDuplexAccess;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
-import okhttp3.tls.HandshakeCertificates;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TestRule;
-import org.junit.rules.Timeout;
-
-import static junit.framework.TestCase.assertTrue;
-import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-
-public final class DuplexTest {
-  @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client = defaultClient();
-
-  @Test public void trueDuplexClientWritesFirst() throws IOException {
-    MockResponse mockResponse = new MockResponse();
-    mockResponse.clearHeaders();
-    MwsDuplexAccess.instance.setBody(mockResponse, new DuplexResponseBody() {
-      @Override public void onRequest(RecordedRequest request,
-          BufferedSource requestBody, BufferedSink responseBody) throws IOException {
-
-        assertEquals("request A", requestBody.readUtf8Line());
-        responseBody.writeUtf8("response B\n");
-        responseBody.flush();
-
-        assertEquals("request C", requestBody.readUtf8Line());
-        responseBody.writeUtf8("response D\n");
-        responseBody.flush();
-
-        assertEquals("request E", requestBody.readUtf8Line());
-        responseBody.writeUtf8("response F\n");
-        responseBody.flush();
-
-        assertNull(requestBody.readUtf8Line());
-        requestBody.close();
-        responseBody.close();
-      }
-    });
-    server.enqueue(mockResponse);
-    enableProtocol(Protocol.HTTP_2);
-
-    DuplexRequestBody duplexRequestBody = new DuplexRequestBody(null, 128);
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(duplexRequestBody)
-        .build());
-
-    BufferedSink requestBody = duplexRequestBody.createSink();
-    requestBody.writeUtf8("request A\n");
-    requestBody.flush();
-
-    try (Response response = call.execute()) {
-      BufferedSource responseBody = response.body().source();
-      assertEquals("response B", responseBody.readUtf8Line());
-
-      requestBody.writeUtf8("request C\n");
-      requestBody.flush();
-      assertEquals("response D", responseBody.readUtf8Line());
-
-      requestBody.writeUtf8("request E\n");
-      requestBody.flush();
-      assertEquals("response F", responseBody.readUtf8Line());
-
-      requestBody.close();
-      assertNull(responseBody.readUtf8Line());
-    }
-  }
-
-  @Test public void trueDuplexServerWritesFirst() throws IOException {
-    MockResponse mockResponse = new MockResponse();
-    mockResponse.clearHeaders();
-    MwsDuplexAccess.instance.setBody(mockResponse, new DuplexResponseBody() {
-      @Override public void onRequest(RecordedRequest request,
-          BufferedSource requestBody, BufferedSink responseBody) throws IOException {
-        responseBody.writeUtf8("response A\n");
-        responseBody.flush();
-        assertEquals("request B", requestBody.readUtf8Line());
-
-        responseBody.writeUtf8("response C\n");
-        responseBody.flush();
-        assertEquals("request D", requestBody.readUtf8Line());
-
-        responseBody.writeUtf8("response E\n");
-        responseBody.flush();
-        assertEquals("request F", requestBody.readUtf8Line());
-
-        responseBody.close();
-      }
-    });
-    server.enqueue(mockResponse);
-    enableProtocol(Protocol.HTTP_2);
-
-    DuplexRequestBody duplexRequestBody = new DuplexRequestBody(null, 128);
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(duplexRequestBody)
-        .build());
-
-    BufferedSink requestBody = duplexRequestBody.createSink();
-
-    try (Response response = call.execute()) {
-      BufferedSource responseBody = response.body().source();
-
-      assertEquals("response A", responseBody.readUtf8Line());
-      requestBody.writeUtf8("request B\n");
-      requestBody.flush();
-
-      assertEquals("response C", responseBody.readUtf8Line());
-      requestBody.writeUtf8("request D\n");
-      requestBody.flush();
-
-      assertEquals("response E", responseBody.readUtf8Line());
-      requestBody.writeUtf8("request F\n");
-      requestBody.flush();
-
-      assertNull(responseBody.readUtf8Line());
-      requestBody.close();
-    }
-  }
-
-  @Test public void clientReadsHeadersDataTrailers() throws IOException {
-    final LatchParty latchParty = new LatchParty();
-    MockResponse mockResponse = new MockResponse()
-        .clearHeaders()
-        .addHeader("h1", "v1")
-        .addHeader("h2", "v2")
-        .setTrailers(Headers.of("trailers", "boom"));
-    MwsDuplexAccess.instance.setBody(mockResponse, new DuplexResponseBody() {
-      @Override public void onRequest(RecordedRequest request,
-          BufferedSource requestBody, BufferedSink responseBody) throws IOException {
-
-        latchParty.step(1);
-        responseBody.writeUtf8("ok");
-        responseBody.flush();
-
-        latchParty.step(3);
-        responseBody.writeUtf8("taco");
-        responseBody.flush();
-
-        latchParty.step(5);
-        responseBody.close();
-      }
-    });
-    server.enqueue(mockResponse);
-    enableProtocol(Protocol.HTTP_2);
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    try (Response response = call.execute()) {
-      assertEquals(Headers.of("h1", "v1", "h2", "v2"), response.headers());
-
-      latchParty.step(2);
-      BufferedSource responseBody = response.body().source();
-      assertEquals("ok", responseBody.readUtf8(2));
-
-      latchParty.step(4);
-      assertEquals("taco", responseBody.readUtf8(4));
-
-      latchParty.step(6);
-      assertTrue(responseBody.exhausted());
-      assertEquals(Headers.of("trailers", "boom"), response.trailers());
-    }
-  }
-
-  @Test public void serverReadsHeadersData() throws IOException {
-    final AtomicReference<BufferedSource> requestBodySourceRef = new AtomicReference<>();
-
-    MockResponse mockResponse = new MockResponse()
-        .clearHeaders()
-        .addHeader("h1", "v1")
-        .addHeader("h2", "v2");
-    MwsDuplexAccess.instance.setBody(mockResponse, new DuplexResponseBody() {
-      @Override public void onRequest(RecordedRequest request,
-          BufferedSource requestBody, BufferedSink responseBody) throws IOException {
-        responseBody.close();
-
-        requestBodySourceRef.set(requestBody);
-      }
-    });
-    server.enqueue(mockResponse);
-    enableProtocol(Protocol.HTTP_2);
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", new DuplexRequestBody(null, 1024L))
-        .build();
-    Call call = client.newCall(request);
-
-    BufferedSink sink = ((DuplexRequestBody) request.body).createSink();
-    sink.writeUtf8("hey\n");
-
-    try (Response response = call.execute()) {
-      sink.writeUtf8("whats going on\n");
-      sink.close();
-
-      // check what the server received
-      BufferedSource requestBody = requestBodySourceRef.get();
-      assertEquals("hey", requestBody.readUtf8Line());
-      assertEquals("whats going on", requestBody.readUtf8Line());
-      assertTrue(requestBody.exhausted());
-    }
-  }
-
-  // TODO(oldergod) write tests for headers discarded with 100 Continue
-
-  /**
-   * Tests that use this will fail unless boot classpath is set. Ex. {@code
-   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
-   */
-  private void enableProtocol(Protocol protocol) {
-    enableTls();
-    client = client.newBuilder()
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
-        .build();
-    server.setProtocols(client.protocols());
-  }
-
-  private void enableTls() {
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-  }
-
-  static final class LatchParty {
-    private int currentRound = 1;
-
-    synchronized void step(int round) {
-      try {
-        // Wait until I can be released.
-        while (currentRound != round) {
-          wait();
-        }
-
-        // Release the other thread.
-        currentRound++;
-        notifyAll();
-      } catch (InterruptedException e) {
-        throw new AssertionError();
-      }
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
deleted file mode 100644
index b0cb8a6d0f..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import okio.Buffer;
-import org.junit.Test;
-import java.nio.charset.Charset;
-
-import static org.junit.Assert.assertEquals;
-
-public final class FormBodyTest {
-  @Test public void urlEncoding() throws Exception {
-    FormBody body = new FormBody.Builder()
-        .add("a+=& b", "c+=& d")
-        .add("space, the", "final frontier")
-        .add("%25", "%25")
-        .build();
-
-    assertEquals(3, body.size());
-
-    assertEquals("a%2B%3D%26%20b", body.encodedName(0));
-    assertEquals("space%2C%20the", body.encodedName(1));
-    assertEquals("%2525", body.encodedName(2));
-
-    assertEquals("a+=& b", body.name(0));
-    assertEquals("space, the", body.name(1));
-    assertEquals("%25", body.name(2));
-
-    assertEquals("c%2B%3D%26%20d", body.encodedValue(0));
-    assertEquals("final%20frontier", body.encodedValue(1));
-    assertEquals("%2525", body.encodedValue(2));
-
-    assertEquals("c+=& d", body.value(0));
-    assertEquals("final frontier", body.value(1));
-    assertEquals("%25", body.value(2));
-
-    assertEquals("application/x-www-form-urlencoded", body.contentType().toString());
-
-    String expected = "a%2B%3D%26%20b=c%2B%3D%26%20d&space%2C%20the=final%20frontier&%2525=%2525";
-    assertEquals(expected.length(), body.contentLength());
-
-    Buffer out = new Buffer();
-    body.writeTo(out);
-    assertEquals(expected, out.readUtf8());
-  }
-
-  @Test public void addEncoded() throws Exception {
-    FormBody body = new FormBody.Builder()
-        .addEncoded("a+=& b", "c+=& d")
-        .addEncoded("e+=& f", "g+=& h")
-        .addEncoded("%25", "%25")
-        .build();
-
-    String expected = "a+%3D%26%20b=c+%3D%26%20d&e+%3D%26%20f=g+%3D%26%20h&%25=%25";
-    Buffer out = new Buffer();
-    body.writeTo(out);
-    assertEquals(expected, out.readUtf8());
-  }
-
-  @Test public void encodedPair() throws Exception {
-    FormBody body = new FormBody.Builder()
-        .add("sim", "ple")
-        .build();
-
-    String expected = "sim=ple";
-    assertEquals(expected.length(), body.contentLength());
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertEquals(expected, buffer.readUtf8());
-  }
-
-  @Test public void encodeMultiplePairs() throws Exception {
-    FormBody body = new FormBody.Builder()
-        .add("sim", "ple")
-        .add("hey", "there")
-        .add("help", "me")
-        .build();
-
-    String expected = "sim=ple&hey=there&help=me";
-    assertEquals(expected.length(), body.contentLength());
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertEquals(expected, buffer.readUtf8());
-  }
-
-  @Test public void buildEmptyForm() throws Exception {
-    FormBody body = new FormBody.Builder().build();
-
-    String expected = "";
-    assertEquals(expected.length(), body.contentLength());
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertEquals(expected, buffer.readUtf8());
-  }
-
-  @Test public void characterEncoding() throws Exception {
-    assertEquals("%00", formEncode(0)); // Browsers convert '\u0000' to '%EF%BF%BD'.
-    assertEquals("%01", formEncode(1));
-    assertEquals("%02", formEncode(2));
-    assertEquals("%03", formEncode(3));
-    assertEquals("%04", formEncode(4));
-    assertEquals("%05", formEncode(5));
-    assertEquals("%06", formEncode(6));
-    assertEquals("%07", formEncode(7));
-    assertEquals("%08", formEncode(8));
-    assertEquals("%09", formEncode(9));
-    assertEquals("%0A", formEncode(10)); // Browsers convert '\n' to '\r\n'
-    assertEquals("%0B", formEncode(11));
-    assertEquals("%0C", formEncode(12));
-    assertEquals("%0D", formEncode(13)); // Browsers convert '\r' to '\r\n'
-    assertEquals("%0E", formEncode(14));
-    assertEquals("%0F", formEncode(15));
-    assertEquals("%10", formEncode(16));
-    assertEquals("%11", formEncode(17));
-    assertEquals("%12", formEncode(18));
-    assertEquals("%13", formEncode(19));
-    assertEquals("%14", formEncode(20));
-    assertEquals("%15", formEncode(21));
-    assertEquals("%16", formEncode(22));
-    assertEquals("%17", formEncode(23));
-    assertEquals("%18", formEncode(24));
-    assertEquals("%19", formEncode(25));
-    assertEquals("%1A", formEncode(26));
-    assertEquals("%1B", formEncode(27));
-    assertEquals("%1C", formEncode(28));
-    assertEquals("%1D", formEncode(29));
-    assertEquals("%1E", formEncode(30));
-    assertEquals("%1F", formEncode(31));
-    assertEquals("%20", formEncode(32)); // Browsers use '+' for space.
-    assertEquals("%21", formEncode(33));
-    assertEquals("%22", formEncode(34));
-    assertEquals("%23", formEncode(35));
-    assertEquals("%24", formEncode(36));
-    assertEquals("%25", formEncode(37));
-    assertEquals("%26", formEncode(38));
-    assertEquals("%27", formEncode(39));
-    assertEquals("%28", formEncode(40));
-    assertEquals("%29", formEncode(41));
-    assertEquals("*", formEncode(42));
-    assertEquals("%2B", formEncode(43));
-    assertEquals("%2C", formEncode(44));
-    assertEquals("-", formEncode(45));
-    assertEquals(".", formEncode(46));
-    assertEquals("%2F", formEncode(47));
-    assertEquals("0", formEncode(48));
-    assertEquals("9", formEncode(57));
-    assertEquals("%3A", formEncode(58));
-    assertEquals("%3B", formEncode(59));
-    assertEquals("%3C", formEncode(60));
-    assertEquals("%3D", formEncode(61));
-    assertEquals("%3E", formEncode(62));
-    assertEquals("%3F", formEncode(63));
-    assertEquals("%40", formEncode(64));
-    assertEquals("A", formEncode(65));
-    assertEquals("Z", formEncode(90));
-    assertEquals("%5B", formEncode(91));
-    assertEquals("%5C", formEncode(92));
-    assertEquals("%5D", formEncode(93));
-    assertEquals("%5E", formEncode(94));
-    assertEquals("_", formEncode(95));
-    assertEquals("%60", formEncode(96));
-    assertEquals("a", formEncode(97));
-    assertEquals("z", formEncode(122));
-    assertEquals("%7B", formEncode(123));
-    assertEquals("%7C", formEncode(124));
-    assertEquals("%7D", formEncode(125));
-    assertEquals("%7E", formEncode(126));
-    assertEquals("%7F", formEncode(127));
-    assertEquals("%C2%80", formEncode(128));
-    assertEquals("%C3%BF", formEncode(255));
-  }
-
-  private String formEncode(int codePoint) throws IOException {
-    // Wrap the codepoint with regular printable characters to prevent trimming.
-    FormBody body = new FormBody.Builder()
-        .add("a", new String(new int[] {'b', codePoint, 'c'}, 0, 3))
-        .build();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    buffer.skip(3); // Skip "a=b" prefix.
-    return buffer.readUtf8(buffer.size() - 1); // Skip the "c" suffix.
-  }
-
-  @Test public void manualCharset() throws Exception {
-    FormBody body = new FormBody.Builder(Charset.forName("ISO-8859-1"))
-        .add("name", "Nicols")
-        .build();
-
-    String expected = "name=Nicol%E1s";
-    assertEquals(expected.length(), body.contentLength());
-
-    Buffer out = new Buffer();
-    body.writeTo(out);
-    assertEquals(expected, out.readUtf8());
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
deleted file mode 100644
index 23a32d7e92..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ /dev/null
@@ -1,1629 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.URI;
-import java.net.URL;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import okhttp3.UrlComponentEncodingTester.Component;
-import okhttp3.UrlComponentEncodingTester.Encoding;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import static java.util.Collections.singletonList;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-
-@RunWith(Parameterized.class)
-public final class HttpUrlTest {
-  @Parameterized.Parameters(name = "Use get = {0}")
-  public static Collection<Object[]> parameters() {
-    return Arrays.asList(
-        new Object[] { true },
-        new Object[] { false }
-    );
-  }
-
-  @Parameterized.Parameter
-  public boolean useGet;
-
-  HttpUrl parse(String url) {
-    return useGet
-        ? HttpUrl.get(url)
-        : HttpUrl.parse(url);
-  }
-
-  @Test public void parseTrimsAsciiWhitespace() throws Exception {
-    HttpUrl expected = parse("http://host/");
-    assertEquals(expected, parse("http://host/\f\n\t \r")); // Leading.
-    assertEquals(expected, parse("\r\n\f \thttp://host/")); // Trailing.
-    assertEquals(expected, parse(" http://host/ ")); // Both.
-    assertEquals(expected, parse("    http://host/    ")); // Both.
-    assertEquals(expected, parse("http://host/").resolve("   "));
-    assertEquals(expected, parse("http://host/").resolve("  .  "));
-  }
-
-  @Test public void parseHostAsciiNonPrintable() throws Exception {
-    String host = "host\u0001";
-    assertInvalid("http://" + host + "/", "Invalid URL host: \"host\u0001\"");
-    // TODO make exception message escape non-printable characters
-  }
-
-  @Test public void parseDoesNotTrimOtherWhitespaceCharacters() throws Exception {
-    // Whitespace characters list from Google's Guava team: http://goo.gl/IcR9RD
-    assertEquals("/%0B", parse("http://h/\u000b").encodedPath()); // line tabulation
-    assertEquals("/%1C", parse("http://h/\u001c").encodedPath()); // information separator 4
-    assertEquals("/%1D", parse("http://h/\u001d").encodedPath()); // information separator 3
-    assertEquals("/%1E", parse("http://h/\u001e").encodedPath()); // information separator 2
-    assertEquals("/%1F", parse("http://h/\u001f").encodedPath()); // information separator 1
-    assertEquals("/%C2%85", parse("http://h/\u0085").encodedPath()); // next line
-    assertEquals("/%C2%A0", parse("http://h/\u00a0").encodedPath()); // non-breaking space
-    assertEquals("/%E1%9A%80", parse("http://h/\u1680").encodedPath()); // ogham space mark
-    assertEquals("/%E1%A0%8E", parse("http://h/\u180e").encodedPath()); // mongolian vowel separator
-    assertEquals("/%E2%80%80", parse("http://h/\u2000").encodedPath()); // en quad
-    assertEquals("/%E2%80%81", parse("http://h/\u2001").encodedPath()); // em quad
-    assertEquals("/%E2%80%82", parse("http://h/\u2002").encodedPath()); // en space
-    assertEquals("/%E2%80%83", parse("http://h/\u2003").encodedPath()); // em space
-    assertEquals("/%E2%80%84", parse("http://h/\u2004").encodedPath()); // three-per-em space
-    assertEquals("/%E2%80%85", parse("http://h/\u2005").encodedPath()); // four-per-em space
-    assertEquals("/%E2%80%86", parse("http://h/\u2006").encodedPath()); // six-per-em space
-    assertEquals("/%E2%80%87", parse("http://h/\u2007").encodedPath()); // figure space
-    assertEquals("/%E2%80%88", parse("http://h/\u2008").encodedPath()); // punctuation space
-    assertEquals("/%E2%80%89", parse("http://h/\u2009").encodedPath()); // thin space
-    assertEquals("/%E2%80%8A", parse("http://h/\u200a").encodedPath()); // hair space
-    assertEquals("/%E2%80%8B", parse("http://h/\u200b").encodedPath()); // zero-width space
-    assertEquals("/%E2%80%8C", parse("http://h/\u200c").encodedPath()); // zero-width non-joiner
-    assertEquals("/%E2%80%8D", parse("http://h/\u200d").encodedPath()); // zero-width joiner
-    assertEquals("/%E2%80%8E", parse("http://h/\u200e").encodedPath()); // left-to-right mark
-    assertEquals("/%E2%80%8F", parse("http://h/\u200f").encodedPath()); // right-to-left mark
-    assertEquals("/%E2%80%A8", parse("http://h/\u2028").encodedPath()); // line separator
-    assertEquals("/%E2%80%A9", parse("http://h/\u2029").encodedPath()); // paragraph separator
-    assertEquals("/%E2%80%AF", parse("http://h/\u202f").encodedPath()); // narrow non-breaking space
-    assertEquals("/%E2%81%9F", parse("http://h/\u205f").encodedPath()); // medium mathematical space
-    assertEquals("/%E3%80%80", parse("http://h/\u3000").encodedPath()); // ideographic space
-  }
-
-  @Test public void scheme() throws Exception {
-    assertEquals(parse("http://host/"), parse("http://host/"));
-    assertEquals(parse("http://host/"), parse("Http://host/"));
-    assertEquals(parse("http://host/"), parse("http://host/"));
-    assertEquals(parse("http://host/"), parse("HTTP://host/"));
-    assertEquals(parse("https://host/"), parse("https://host/"));
-    assertEquals(parse("https://host/"), parse("HTTPS://host/"));
-
-    assertInvalid("image640://480.png", "Expected URL scheme 'http' or 'https' but was 'image640'");
-    assertInvalid("httpp://host/", "Expected URL scheme 'http' or 'https' but was 'httpp'");
-    assertInvalid("0ttp://host/", "Expected URL scheme 'http' or 'https' but no colon was found");
-    assertInvalid("ht+tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht+tp'");
-    assertInvalid("ht.tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht.tp'");
-    assertInvalid("ht-tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht-tp'");
-    assertInvalid("ht1tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht1tp'");
-    assertInvalid("httpss://host/", "Expected URL scheme 'http' or 'https' but was 'httpss'");
-  }
-
-  @Test public void parseNoScheme() throws Exception {
-    assertInvalid("//host", "Expected URL scheme 'http' or 'https' but no colon was found");
-    assertInvalid("/path", "Expected URL scheme 'http' or 'https' but no colon was found");
-    assertInvalid("path", "Expected URL scheme 'http' or 'https' but no colon was found");
-    assertInvalid("?query", "Expected URL scheme 'http' or 'https' but no colon was found");
-    assertInvalid("#fragment", "Expected URL scheme 'http' or 'https' but no colon was found");
-  }
-
-  @Test public void newBuilderResolve() throws Exception {
-    // Non-exhaustive tests because implementation is the same as resolve.
-    HttpUrl base = parse("http://host/a/b");
-    assertEquals(parse("https://host2/"), base.newBuilder("https://host2").build());
-    assertEquals(parse("http://host2/"), base.newBuilder("//host2").build());
-    assertEquals(parse("http://host/path"), base.newBuilder("/path").build());
-    assertEquals(parse("http://host/a/path"), base.newBuilder("path").build());
-    assertEquals(parse("http://host/a/b?query"), base.newBuilder("?query").build());
-    assertEquals(parse("http://host/a/b#fragment"), base.newBuilder("#fragment").build());
-    assertEquals(parse("http://host/a/b"), base.newBuilder("").build());
-    assertNull(base.newBuilder("ftp://b"));
-    assertNull(base.newBuilder("ht+tp://b"));
-    assertNull(base.newBuilder("ht-tp://b"));
-    assertNull(base.newBuilder("ht.tp://b"));
-  }
-
-  @Test public void redactedUrl() {
-    HttpUrl baseWithPasswordAndUsername = parse("http://username:password@host/a/b#fragment");
-    HttpUrl baseWithUsernameOnly = parse("http://username@host/a/b#fragment");
-    HttpUrl baseWithPasswordOnly = parse("http://password@host/a/b#fragment");
-    assertEquals("http://host/...", baseWithPasswordAndUsername.redact());
-    assertEquals("http://host/...", baseWithUsernameOnly.redact());
-    assertEquals("http://host/...", baseWithPasswordOnly.redact());
-  }
-
-  @Test public void resolveNoScheme() throws Exception {
-    HttpUrl base = parse("http://host/a/b");
-    assertEquals(parse("http://host2/"), base.resolve("//host2"));
-    assertEquals(parse("http://host/path"), base.resolve("/path"));
-    assertEquals(parse("http://host/a/path"), base.resolve("path"));
-    assertEquals(parse("http://host/a/b?query"), base.resolve("?query"));
-    assertEquals(parse("http://host/a/b#fragment"), base.resolve("#fragment"));
-    assertEquals(parse("http://host/a/b"), base.resolve(""));
-    assertEquals(parse("http://host/path"), base.resolve("\\path"));
-  }
-
-  @Test public void resolveUnsupportedScheme() throws Exception {
-    HttpUrl base = parse("http://a/");
-    assertNull(base.resolve("ftp://b"));
-    assertNull(base.resolve("ht+tp://b"));
-    assertNull(base.resolve("ht-tp://b"));
-    assertNull(base.resolve("ht.tp://b"));
-  }
-
-  @Test public void resolveSchemeLikePath() throws Exception {
-    HttpUrl base = parse("http://a/");
-    assertEquals(parse("http://a/http//b/"), base.resolve("http//b/"));
-    assertEquals(parse("http://a/ht+tp//b/"), base.resolve("ht+tp//b/"));
-    assertEquals(parse("http://a/ht-tp//b/"), base.resolve("ht-tp//b/"));
-    assertEquals(parse("http://a/ht.tp//b/"), base.resolve("ht.tp//b/"));
-  }
-
-  /** https://tools.ietf.org/html/rfc3986#section-5.4.1 */
-  @Test public void rfc3886NormalExamples() {
-    HttpUrl url = parse("http://a/b/c/d;p?q");
-    assertNull(url.resolve("g:h")); // No 'g:' scheme in HttpUrl.
-    assertEquals(parse("http://a/b/c/g"), url.resolve("g"));
-    assertEquals(parse("http://a/b/c/g"), url.resolve("./g"));
-    assertEquals(parse("http://a/b/c/g/"), url.resolve("g/"));
-    assertEquals(parse("http://a/g"), url.resolve("/g"));
-    assertEquals(parse("http://g"), url.resolve("//g"));
-    assertEquals(parse("http://a/b/c/d;p?y"), url.resolve("?y"));
-    assertEquals(parse("http://a/b/c/g?y"), url.resolve("g?y"));
-    assertEquals(parse("http://a/b/c/d;p?q#s"), url.resolve("#s"));
-    assertEquals(parse("http://a/b/c/g#s"), url.resolve("g#s"));
-    assertEquals(parse("http://a/b/c/g?y#s"), url.resolve("g?y#s"));
-    assertEquals(parse("http://a/b/c/;x"), url.resolve(";x"));
-    assertEquals(parse("http://a/b/c/g;x"), url.resolve("g;x"));
-    assertEquals(parse("http://a/b/c/g;x?y#s"), url.resolve("g;x?y#s"));
-    assertEquals(parse("http://a/b/c/d;p?q"), url.resolve(""));
-    assertEquals(parse("http://a/b/c/"), url.resolve("."));
-    assertEquals(parse("http://a/b/c/"), url.resolve("./"));
-    assertEquals(parse("http://a/b/"), url.resolve(".."));
-    assertEquals(parse("http://a/b/"), url.resolve("../"));
-    assertEquals(parse("http://a/b/g"), url.resolve("../g"));
-    assertEquals(parse("http://a/"), url.resolve("../.."));
-    assertEquals(parse("http://a/"), url.resolve("../../"));
-    assertEquals(parse("http://a/g"), url.resolve("../../g"));
-  }
-
-  /** https://tools.ietf.org/html/rfc3986#section-5.4.2 */
-  @Test public void rfc3886AbnormalExamples() {
-    HttpUrl url = parse("http://a/b/c/d;p?q");
-    assertEquals(parse("http://a/g"), url.resolve("../../../g"));
-    assertEquals(parse("http://a/g"), url.resolve("../../../../g"));
-    assertEquals(parse("http://a/g"), url.resolve("/./g"));
-    assertEquals(parse("http://a/g"), url.resolve("/../g"));
-    assertEquals(parse("http://a/b/c/g."), url.resolve("g."));
-    assertEquals(parse("http://a/b/c/.g"), url.resolve(".g"));
-    assertEquals(parse("http://a/b/c/g.."), url.resolve("g.."));
-    assertEquals(parse("http://a/b/c/..g"), url.resolve("..g"));
-    assertEquals(parse("http://a/b/g"), url.resolve("./../g"));
-    assertEquals(parse("http://a/b/c/g/"), url.resolve("./g/."));
-    assertEquals(parse("http://a/b/c/g/h"), url.resolve("g/./h"));
-    assertEquals(parse("http://a/b/c/h"), url.resolve("g/../h"));
-    assertEquals(parse("http://a/b/c/g;x=1/y"), url.resolve("g;x=1/./y"));
-    assertEquals(parse("http://a/b/c/y"), url.resolve("g;x=1/../y"));
-    assertEquals(parse("http://a/b/c/g?y/./x"), url.resolve("g?y/./x"));
-    assertEquals(parse("http://a/b/c/g?y/../x"), url.resolve("g?y/../x"));
-    assertEquals(parse("http://a/b/c/g#s/./x"), url.resolve("g#s/./x"));
-    assertEquals(parse("http://a/b/c/g#s/../x"), url.resolve("g#s/../x"));
-    assertEquals(parse("http://a/b/c/g"), url.resolve("http:g")); // "http:g" also okay.
-  }
-
-  @Test public void parseAuthoritySlashCountDoesntMatter() throws Exception {
-    assertEquals(parse("http://host/path"), parse("http:host/path"));
-    assertEquals(parse("http://host/path"), parse("http:/host/path"));
-    assertEquals(parse("http://host/path"), parse("http:\\host/path"));
-    assertEquals(parse("http://host/path"), parse("http://host/path"));
-    assertEquals(parse("http://host/path"), parse("http:\\/host/path"));
-    assertEquals(parse("http://host/path"), parse("http:/\\host/path"));
-    assertEquals(parse("http://host/path"), parse("http:\\\\host/path"));
-    assertEquals(parse("http://host/path"), parse("http:///host/path"));
-    assertEquals(parse("http://host/path"), parse("http:\\//host/path"));
-    assertEquals(parse("http://host/path"), parse("http:/\\/host/path"));
-    assertEquals(parse("http://host/path"), parse("http://\\host/path"));
-    assertEquals(parse("http://host/path"), parse("http:\\\\/host/path"));
-    assertEquals(parse("http://host/path"), parse("http:/\\\\host/path"));
-    assertEquals(parse("http://host/path"), parse("http:\\\\\\host/path"));
-    assertEquals(parse("http://host/path"), parse("http:////host/path"));
-  }
-
-  @Test public void resolveAuthoritySlashCountDoesntMatterWithDifferentScheme() throws Exception {
-    HttpUrl base = parse("https://a/b/c");
-    assertEquals(parse("http://host/path"), base.resolve("http:host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:/host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:\\host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http://host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:\\/host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:/\\host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:\\\\host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:///host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:\\//host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:/\\/host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http://\\host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:\\\\/host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:/\\\\host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:////host/path"));
-  }
-
-  @Test public void resolveAuthoritySlashCountMattersWithSameScheme() throws Exception {
-    HttpUrl base = parse("http://a/b/c");
-    assertEquals(parse("http://a/b/host/path"), base.resolve("http:host/path"));
-    assertEquals(parse("http://a/host/path"), base.resolve("http:/host/path"));
-    assertEquals(parse("http://a/host/path"), base.resolve("http:\\host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http://host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:\\/host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:/\\host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:\\\\host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:///host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:\\//host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:/\\/host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http://\\host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:\\\\/host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:/\\\\host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
-    assertEquals(parse("http://host/path"), base.resolve("http:////host/path"));
-  }
-
-  @Test public void username() throws Exception {
-    assertEquals(parse("http://host/path"), parse("http://@host/path"));
-    assertEquals(parse("http://user@host/path"), parse("http://user@host/path"));
-  }
-
-  /** Given multiple '@' characters, the last one is the delimiter. */
-  @Test public void authorityWithMultipleAtSigns() throws Exception {
-    HttpUrl httpUrl = parse("http://foo@bar@baz/path");
-    assertEquals("foo@bar", httpUrl.username());
-    assertEquals("", httpUrl.password());
-    assertEquals(parse("http://foo%40bar@baz/path"), httpUrl);
-  }
-
-  /** Given multiple ':' characters, the first one is the delimiter. */
-  @Test public void authorityWithMultipleColons() throws Exception {
-    HttpUrl httpUrl = parse("http://foo:pass1@bar:pass2@baz/path");
-    assertEquals("foo", httpUrl.username());
-    assertEquals("pass1@bar:pass2", httpUrl.password());
-    assertEquals(parse("http://foo:pass1%40bar%3Apass2@baz/path"), httpUrl);
-  }
-
-  @Test public void usernameAndPassword() throws Exception {
-    assertEquals(parse("http://username:password@host/path"),
-        parse("http://username:password@host/path"));
-    assertEquals(parse("http://username@host/path"),
-        parse("http://username:@host/path"));
-  }
-
-  @Test public void passwordWithEmptyUsername() throws Exception {
-    // Chrome doesn't mind, but Firefox rejects URLs with empty usernames and non-empty passwords.
-    assertEquals(parse("http://host/path"), parse("http://:@host/path"));
-    assertEquals("password%40", parse("http://:password@@host/path").encodedPassword());
-  }
-
-  @Test public void unprintableCharactersArePercentEncoded() throws Exception {
-    assertEquals("/%00", parse("http://host/\u0000").encodedPath());
-    assertEquals("/%08", parse("http://host/\u0008").encodedPath());
-    assertEquals("/%EF%BF%BD", parse("http://host/\ufffd").encodedPath());
-  }
-
-  @Test public void usernameCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.PERCENT, '[', ']', '{', '}', '|', '^', '\'', ';', '=', '@')
-        .override(Encoding.SKIP, ':', '/', '\\', '?', '#')
-        .skipForUri('%')
-        .test(Component.USER);
-  }
-
-  @Test public void passwordCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.PERCENT, '[', ']', '{', '}', '|', '^', '\'', ':', ';', '=', '@')
-        .override(Encoding.SKIP, '/', '\\', '?', '#')
-        .skipForUri('%')
-        .test(Component.PASSWORD);
-  }
-
-  @Test public void hostContainsIllegalCharacter() throws Exception {
-    assertInvalid("http://\n/", "Invalid URL host: \"\n\"");
-    assertInvalid("http:// /", "Invalid URL host: \" \"");
-    assertInvalid("http://%20/", "Invalid URL host: \"%20\"");
-  }
-
-  @Test public void hostnameLowercaseCharactersMappedDirectly() throws Exception {
-    assertEquals("abcd", parse("http://abcd").host());
-    assertEquals("xn--4xa", parse("http://").host());
-  }
-
-  @Test public void hostnameUppercaseCharactersConvertedToLowercase() throws Exception {
-    assertEquals("abcd", parse("http://ABCD").host());
-    assertEquals("xn--4xa", parse("http://").host());
-  }
-
-  @Test public void hostnameIgnoredCharacters() throws Exception {
-    // The soft hyphen () should be ignored.
-    assertEquals("abcd", parse("http://AB\u00adCD").host());
-  }
-
-  @Test public void hostnameMultipleCharacterMapping() throws Exception {
-    // Map the single character telephone symbol () to the string "tel".
-    assertEquals("tel", parse("http://\u2121").host());
-  }
-
-  @Test public void hostnameMappingLastMappedCodePoint() throws Exception {
-    assertEquals("xn--pu5l", parse("http://\uD87E\uDE1D").host());
-  }
-
-  @Ignore("The java.net.IDN implementation doesn't ignore characters that it should.")
-  @Test public void hostnameMappingLastIgnoredCodePoint() throws Exception {
-    assertEquals("abcd", parse("http://ab\uDB40\uDDEFcd").host());
-  }
-
-  @Test public void hostnameMappingLastDisallowedCodePoint() throws Exception {
-    assertInvalid("http://\uDBFF\uDFFF", "Invalid URL host: \"\uDBFF\uDFFF\"");
-  }
-
-  @Test public void hostIpv6() throws Exception {
-    // Square braces are absent from host()...
-    assertEquals("::1", parse("http://[::1]/").host());
-
-    // ... but they're included in toString().
-    assertEquals("http://[::1]/", parse("http://[::1]/").toString());
-
-    // IPv6 colons don't interfere with port numbers or passwords.
-    assertEquals(8080, parse("http://[::1]:8080/").port());
-    assertEquals("password", parse("http://user:password@[::1]/").password());
-    assertEquals("::1", parse("http://user:password@[::1]:8080/").host());
-
-    // Permit the contents of IPv6 addresses to be percent-encoded...
-    assertEquals("::1", parse("http://[%3A%3A%31]/").host());
-
-    // Including the Square braces themselves! (This is what Chrome does.)
-    assertEquals("::1", parse("http://%5B%3A%3A1%5D/").host());
-  }
-
-  @Test public void hostIpv6AddressDifferentFormats() throws Exception {
-    // Multiple representations of the same address; see http://tools.ietf.org/html/rfc5952.
-    String a3 = "2001:db8::1:0:0:1";
-    assertEquals(a3, parse("http://[2001:db8:0:0:1:0:0:1]").host());
-    assertEquals(a3, parse("http://[2001:0db8:0:0:1:0:0:1]").host());
-    assertEquals(a3, parse("http://[2001:db8::1:0:0:1]").host());
-    assertEquals(a3, parse("http://[2001:db8::0:1:0:0:1]").host());
-    assertEquals(a3, parse("http://[2001:0db8::1:0:0:1]").host());
-    assertEquals(a3, parse("http://[2001:db8:0:0:1::1]").host());
-    assertEquals(a3, parse("http://[2001:db8:0000:0:1::1]").host());
-    assertEquals(a3, parse("http://[2001:DB8:0:0:1::1]").host());
-  }
-
-  @Test public void hostIpv6AddressLeadingCompression() throws Exception {
-    assertEquals("::1", parse("http://[::0001]").host());
-    assertEquals("::1", parse("http://[0000::0001]").host());
-    assertEquals("::1", parse("http://[0000:0000:0000:0000:0000:0000:0000:0001]").host());
-    assertEquals("::1", parse("http://[0000:0000:0000:0000:0000:0000::0001]").host());
-  }
-
-  @Test public void hostIpv6AddressTrailingCompression() throws Exception {
-    assertEquals("1::", parse("http://[0001:0000::]").host());
-    assertEquals("1::", parse("http://[0001::0000]").host());
-    assertEquals("1::", parse("http://[0001::]").host());
-    assertEquals("1::", parse("http://[1::]").host());
-  }
-
-  @Test public void hostIpv6AddressTooManyDigitsInGroup() throws Exception {
-    assertInvalid("http://[00000:0000:0000:0000:0000:0000:0000:0001]",
-        "Invalid URL host: \"[00000:0000:0000:0000:0000:0000:0000:0001]\"");
-    assertInvalid("http://[::00001]", "Invalid URL host: \"[::00001]\"");
-  }
-
-  @Test public void hostIpv6AddressMisplacedColons() throws Exception {
-    assertInvalid("http://[:0000:0000:0000:0000:0000:0000:0000:0001]",
-        "Invalid URL host: \"[:0000:0000:0000:0000:0000:0000:0000:0001]\"");
-    assertInvalid("http://[:::0000:0000:0000:0000:0000:0000:0000:0001]",
-        "Invalid URL host: \"[:::0000:0000:0000:0000:0000:0000:0000:0001]\"");
-    assertInvalid("http://[:1]", "Invalid URL host: \"[:1]\"");
-    assertInvalid("http://[:::1]", "Invalid URL host: \"[:::1]\"");
-    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0001:]",
-        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0001:]\"");
-    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001:]",
-        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001:]\"");
-    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001::]",
-        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001::]\"");
-    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001:::]",
-        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001:::]\"");
-    assertInvalid("http://[1:]", "Invalid URL host: \"[1:]\"");
-    assertInvalid("http://[1:::]", "Invalid URL host: \"[1:::]\"");
-    assertInvalid("http://[1:::1]", "Invalid URL host: \"[1:::1]\"");
-    assertInvalid("http://[0000:0000:0000:0000::0000:0000:0000:0001]",
-        "Invalid URL host: \"[0000:0000:0000:0000::0000:0000:0000:0001]\"");
-  }
-
-  @Test public void hostIpv6AddressTooManyGroups() throws Exception {
-    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0000:0001]",
-        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0000:0001]\"");
-  }
-
-  @Test public void hostIpv6AddressTooMuchCompression() throws Exception {
-    assertInvalid("http://[0000::0000:0000:0000:0000::0001]",
-        "Invalid URL host: \"[0000::0000:0000:0000:0000::0001]\"");
-    assertInvalid("http://[::0000:0000:0000:0000::0001]",
-        "Invalid URL host: \"[::0000:0000:0000:0000::0001]\"");
-  }
-
-  @Test public void hostIpv6ScopedAddress() throws Exception {
-    // java.net.InetAddress parses scoped addresses. These aren't valid in URLs.
-    assertInvalid("http://[::1%2544]", "Invalid URL host: \"[::1%2544]\"");
-  }
-
-  @Test public void hostIpv6AddressTooManyLeadingZeros() throws Exception {
-    // Guava's been buggy on this case. https://github.com/google/guava/issues/3116
-    assertInvalid("http://[2001:db8:0:0:1:0:0:00001]",
-        "Invalid URL host: \"[2001:db8:0:0:1:0:0:00001]\"");
-  }
-
-  @Test public void hostIpv6WithIpv4Suffix() throws Exception {
-    assertEquals("::1:ffff:ffff", parse("http://[::1:255.255.255.255]/").host());
-    assertEquals("::1:0:0", parse("http://[0:0:0:0:0:1:0.0.0.0]/").host());
-  }
-
-  @Test public void hostIpv6WithIpv4SuffixWithOctalPrefix() throws Exception {
-    // Chrome interprets a leading '0' as octal; Firefox rejects them. (We reject them.)
-    assertInvalid("http://[0:0:0:0:0:1:0.0.0.000000]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:0.0.0.000000]\"");
-    assertInvalid("http://[0:0:0:0:0:1:0.010.0.010]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:0.010.0.010]\"");
-    assertInvalid("http://[0:0:0:0:0:1:0.0.0.000001]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:0.0.0.000001]\"");
-  }
-
-  @Test public void hostIpv6WithIpv4SuffixWithHexadecimalPrefix() throws Exception {
-    // Chrome interprets a leading '0x' as hexadecimal; Firefox rejects them. (We reject them.)
-    assertInvalid("http://[0:0:0:0:0:1:0.0x10.0.0x10]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:0.0x10.0.0x10]\"");
-  }
-
-  @Test public void hostIpv6WithMalformedIpv4Suffix() throws Exception {
-    assertInvalid("http://[0:0:0:0:0:1:0.0:0.0]/", "Invalid URL host: \"[0:0:0:0:0:1:0.0:0.0]\"");
-    assertInvalid("http://[0:0:0:0:0:1:0.0-0.0]/", "Invalid URL host: \"[0:0:0:0:0:1:0.0-0.0]\"");
-    assertInvalid("http://[0:0:0:0:0:1:.255.255.255]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:.255.255.255]\"");
-    assertInvalid("http://[0:0:0:0:0:1:255..255.255]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:255..255.255]\"");
-    assertInvalid("http://[0:0:0:0:0:1:255.255..255]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:255.255..255]\"");
-    assertInvalid("http://[0:0:0:0:0:0:1:255.255]/",
-        "Invalid URL host: \"[0:0:0:0:0:0:1:255.255]\"");
-    assertInvalid("http://[0:0:0:0:0:1:256.255.255.255]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:256.255.255.255]\"");
-    assertInvalid("http://[0:0:0:0:0:1:ff.255.255.255]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:ff.255.255.255]\"");
-    assertInvalid("http://[0:0:0:0:0:0:1:255.255.255.255]/",
-        "Invalid URL host: \"[0:0:0:0:0:0:1:255.255.255.255]\"");
-    assertInvalid("http://[0:0:0:0:1:255.255.255.255]/",
-        "Invalid URL host: \"[0:0:0:0:1:255.255.255.255]\"");
-    assertInvalid("http://[0:0:0:0:1:0.0.0.0:1]/", "Invalid URL host: \"[0:0:0:0:1:0.0.0.0:1]\"");
-    assertInvalid("http://[0:0.0.0.0:1:0:0:0:0:1]/",
-        "Invalid URL host: \"[0:0.0.0.0:1:0:0:0:0:1]\"");
-    assertInvalid("http://[0.0.0.0:0:0:0:0:0:1]/", "Invalid URL host: \"[0.0.0.0:0:0:0:0:0:1]\"");
-  }
-
-  @Test public void hostIpv6WithIncompleteIpv4Suffix() throws Exception {
-    // To Chrome & Safari these are well-formed; Firefox disagrees. (We're consistent with Firefox).
-    assertInvalid("http://[0:0:0:0:0:1:255.255.255.]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:255.255.255.]\"");
-    assertInvalid("http://[0:0:0:0:0:1:255.255.255]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:255.255.255]\"");
-  }
-
-  @Test public void hostIpv6Malformed() throws Exception {
-    assertInvalid("http://[::g]/", "Invalid URL host: \"[::g]\"");
-  }
-
-  @Test public void hostIpv6CanonicalForm() throws Exception {
-    assertEquals("abcd:ef01:2345:6789:abcd:ef01:2345:6789",
-        parse("http://[abcd:ef01:2345:6789:abcd:ef01:2345:6789]/").host());
-    assertEquals("a::b:0:0:0", parse("http://[a:0:0:0:b:0:0:0]/").host());
-    assertEquals("a:b:0:0:c::", parse("http://[a:b:0:0:c:0:0:0]/").host());
-    assertEquals("a:b::c:0:0", parse("http://[a:b:0:0:0:c:0:0]/").host());
-    assertEquals("a::b:0:0:0", parse("http://[a:0:0:0:b:0:0:0]/").host());
-    assertEquals("::a:b:0:0:0", parse("http://[0:0:0:a:b:0:0:0]/").host());
-    assertEquals("::a:0:0:0:b", parse("http://[0:0:0:a:0:0:0:b]/").host());
-    assertEquals("0:a:b:c:d:e:f:1", parse("http://[0:a:b:c:d:e:f:1]/").host());
-    assertEquals("a:b:c:d:e:f:1:0", parse("http://[a:b:c:d:e:f:1:0]/").host());
-    assertEquals("ff01::101", parse("http://[FF01:0:0:0:0:0:0:101]/").host());
-    assertEquals("2001:db8::1", parse("http://[2001:db8::1]/").host());
-    assertEquals("2001:db8::2:1", parse("http://[2001:db8:0:0:0:0:2:1]/").host());
-    assertEquals("2001:db8:0:1:1:1:1:1", parse("http://[2001:db8:0:1:1:1:1:1]/").host());
-    assertEquals("2001:db8::1:0:0:1", parse("http://[2001:db8:0:0:1:0:0:1]/").host());
-    assertEquals("2001:0:0:1::1", parse("http://[2001:0:0:1:0:0:0:1]/").host());
-    assertEquals("1::", parse("http://[1:0:0:0:0:0:0:0]/").host());
-    assertEquals("::1", parse("http://[0:0:0:0:0:0:0:1]/").host());
-    assertEquals("::", parse("http://[0:0:0:0:0:0:0:0]/").host());
-    assertEquals("192.168.1.254", parse("http://[::ffff:c0a8:1fe]/").host());
-  }
-
-  /** The builder permits square braces but does not require them. */
-  @Test public void hostIpv6Builder() throws Exception {
-    HttpUrl base = parse("http://example.com/");
-    assertEquals("http://[::1]/", base.newBuilder().host("[::1]").build().toString());
-    assertEquals("http://[::1]/", base.newBuilder().host("[::0001]").build().toString());
-    assertEquals("http://[::1]/", base.newBuilder().host("::1").build().toString());
-    assertEquals("http://[::1]/", base.newBuilder().host("::0001").build().toString());
-  }
-
-  @Test public void hostIpv4CanonicalForm() throws Exception {
-    assertEquals("255.255.255.255", parse("http://255.255.255.255/").host());
-    assertEquals("1.2.3.4", parse("http://1.2.3.4/").host());
-    assertEquals("0.0.0.0", parse("http://0.0.0.0/").host());
-  }
-
-  @Test public void hostWithTrailingDot() throws Exception {
-    assertEquals("host.", parse("http://host./").host());
-  }
-
-  @Test public void port() throws Exception {
-    assertEquals(parse("http://host/"), parse("http://host:80/"));
-    assertEquals(parse("http://host:99/"), parse("http://host:99/"));
-    assertEquals(parse("http://host/"), parse("http://host:/"));
-    assertEquals(65535, parse("http://host:65535/").port());
-    assertInvalid("http://host:0/", "Invalid URL port: \"0\"");
-    assertInvalid("http://host:65536/", "Invalid URL port: \"65536\"");
-    assertInvalid("http://host:-1/", "Invalid URL port: \"-1\"");
-    assertInvalid("http://host:a/", "Invalid URL port: \"a\"");
-    assertInvalid("http://host:%39%39/", "Invalid URL port: \"%39%39\"");
-  }
-
-  @Test public void pathCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.PERCENT, '^', '{', '}', '|')
-        .override(Encoding.SKIP, '\\', '?', '#')
-        .skipForUri('%', '[', ']')
-        .test(Component.PATH);
-  }
-
-  @Test public void queryCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.IDENTITY, '?', '`')
-        .override(Encoding.PERCENT, '\'')
-        .override(Encoding.SKIP, '#', '+')
-        .skipForUri('%', '\\', '^', '`', '{', '|', '}')
-        .test(Component.QUERY);
-  }
-
-  @Test public void queryValueCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.IDENTITY, '?', '`')
-        .override(Encoding.PERCENT, '\'')
-        .override(Encoding.SKIP, '#', '+')
-        .skipForUri('%', '\\', '^', '`', '{', '|', '}')
-        .test(Component.QUERY_VALUE);
-  }
-
-  @Test public void fragmentCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.IDENTITY, ' ', '"', '#', '<', '>', '?', '`')
-        .skipForUri('%', ' ', '"', '#', '<', '>', '\\', '^', '`', '{', '|', '}')
-        .identityForNonAscii()
-        .test(Component.FRAGMENT);
-  }
-
-  @Test public void fragmentNonAscii() throws Exception {
-    HttpUrl url = parse("http://host/#");
-    assertEquals("http://host/#", url.toString());
-    assertEquals("", url.fragment());
-    assertEquals("", url.encodedFragment());
-    assertEquals("http://host/#", url.uri().toString());
-  }
-
-  @Test public void fragmentNonAsciiThatOffendsJavaNetUri() throws Exception {
-    HttpUrl url = parse("http://host/#\u0080");
-    assertEquals("http://host/#\u0080", url.toString());
-    assertEquals("\u0080", url.fragment());
-    assertEquals("\u0080", url.encodedFragment());
-    assertEquals(new URI("http://host/#"), url.uri()); // Control characters may be stripped!
-  }
-
-  @Test public void fragmentPercentEncodedNonAscii() throws Exception {
-    HttpUrl url = parse("http://host/#%C2%80");
-    assertEquals("http://host/#%C2%80", url.toString());
-    assertEquals("\u0080", url.fragment());
-    assertEquals("%C2%80", url.encodedFragment());
-    assertEquals("http://host/#%C2%80", url.uri().toString());
-  }
-
-  @Test public void fragmentPercentEncodedPartialCodePoint() throws Exception {
-    HttpUrl url = parse("http://host/#%80");
-    assertEquals("http://host/#%80", url.toString());
-    assertEquals("\ufffd", url.fragment()); // Unicode replacement character.
-    assertEquals("%80", url.encodedFragment());
-    assertEquals("http://host/#%80", url.uri().toString());
-  }
-
-  @Test public void relativePath() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertEquals(parse("http://host/a/b/d/e/f"), base.resolve("d/e/f"));
-    assertEquals(parse("http://host/d/e/f"), base.resolve("../../d/e/f"));
-    assertEquals(parse("http://host/a/"), base.resolve(".."));
-    assertEquals(parse("http://host/"), base.resolve("../.."));
-    assertEquals(parse("http://host/"), base.resolve("../../.."));
-    assertEquals(parse("http://host/a/b/"), base.resolve("."));
-    assertEquals(parse("http://host/a/"), base.resolve("././.."));
-    assertEquals(parse("http://host/a/b/c/"), base.resolve("c/d/../e/../"));
-    assertEquals(parse("http://host/a/b/..e/"), base.resolve("..e/"));
-    assertEquals(parse("http://host/a/b/e/f../"), base.resolve("e/f../"));
-    assertEquals(parse("http://host/a/"), base.resolve("%2E."));
-    assertEquals(parse("http://host/a/"), base.resolve(".%2E"));
-    assertEquals(parse("http://host/a/"), base.resolve("%2E%2E"));
-    assertEquals(parse("http://host/a/"), base.resolve("%2e."));
-    assertEquals(parse("http://host/a/"), base.resolve(".%2e"));
-    assertEquals(parse("http://host/a/"), base.resolve("%2e%2e"));
-    assertEquals(parse("http://host/a/b/"), base.resolve("%2E"));
-    assertEquals(parse("http://host/a/b/"), base.resolve("%2e"));
-  }
-
-  @Test public void relativePathWithTrailingSlash() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c/");
-    assertEquals(parse("http://host/a/b/"), base.resolve(".."));
-    assertEquals(parse("http://host/a/b/"), base.resolve("../"));
-    assertEquals(parse("http://host/a/"), base.resolve("../.."));
-    assertEquals(parse("http://host/a/"), base.resolve("../../"));
-    assertEquals(parse("http://host/"), base.resolve("../../.."));
-    assertEquals(parse("http://host/"), base.resolve("../../../"));
-    assertEquals(parse("http://host/"), base.resolve("../../../.."));
-    assertEquals(parse("http://host/"), base.resolve("../../../../"));
-    assertEquals(parse("http://host/a"), base.resolve("../../../../a"));
-    assertEquals(parse("http://host/"), base.resolve("../../../../a/.."));
-    assertEquals(parse("http://host/a/"), base.resolve("../../../../a/b/.."));
-  }
-
-  @Test public void pathWithBackslash() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertEquals(parse("http://host/a/b/d/e/f"), base.resolve("d\\e\\f"));
-    assertEquals(parse("http://host/d/e/f"), base.resolve("../..\\d\\e\\f"));
-    assertEquals(parse("http://host/"), base.resolve("..\\.."));
-  }
-
-  @Test public void relativePathWithSameScheme() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertEquals(parse("http://host/a/b/d/e/f"), base.resolve("http:d/e/f"));
-    assertEquals(parse("http://host/d/e/f"), base.resolve("http:../../d/e/f"));
-  }
-
-  @Test public void decodeUsername() {
-    assertEquals("user", parse("http://user@host/").username());
-    assertEquals("\uD83C\uDF69", parse("http://%F0%9F%8D%A9@host/").username());
-  }
-
-  @Test public void decodePassword() {
-    assertEquals("password", parse("http://user:password@host/").password());
-    assertEquals("", parse("http://user:@host/").password());
-    assertEquals("\uD83C\uDF69", parse("http://user:%F0%9F%8D%A9@host/").password());
-  }
-
-  @Test public void decodeSlashCharacterInDecodedPathSegment() {
-    assertEquals(Arrays.asList("a/b/c"),
-        parse("http://host/a%2Fb%2Fc").pathSegments());
-  }
-
-  @Test public void decodeEmptyPathSegments() {
-    assertEquals(Arrays.asList(""),
-        parse("http://host/").pathSegments());
-  }
-
-  @Test public void percentDecode() throws Exception {
-    assertEquals(Arrays.asList("\u0000"),
-        parse("http://host/%00").pathSegments());
-    assertEquals(Arrays.asList("a", "\u2603", "c"),
-        parse("http://host/a/%E2%98%83/c").pathSegments());
-    assertEquals(Arrays.asList("a", "\uD83C\uDF69", "c"),
-        parse("http://host/a/%F0%9F%8D%A9/c").pathSegments());
-    assertEquals(Arrays.asList("a", "b", "c"),
-        parse("http://host/a/%62/c").pathSegments());
-    assertEquals(Arrays.asList("a", "z", "c"),
-        parse("http://host/a/%7A/c").pathSegments());
-    assertEquals(Arrays.asList("a", "z", "c"),
-        parse("http://host/a/%7a/c").pathSegments());
-  }
-
-  @Test public void malformedPercentEncoding() {
-    assertEquals(Arrays.asList("a%f", "b"),
-        parse("http://host/a%f/b").pathSegments());
-    assertEquals(Arrays.asList("%", "b"),
-        parse("http://host/%/b").pathSegments());
-    assertEquals(Arrays.asList("%"),
-        parse("http://host/%").pathSegments());
-    assertEquals(Arrays.asList("%00"),
-        parse("http://github.com/%%30%30").pathSegments());
-  }
-
-  @Test public void malformedUtf8Encoding() {
-    // Replace a partial UTF-8 sequence with the Unicode replacement character.
-    assertEquals(Arrays.asList("a", "\ufffdx", "c"),
-        parse("http://host/a/%E2%98x/c").pathSegments());
-  }
-
-  @Test public void incompleteUrlComposition() throws Exception {
-    try {
-      new HttpUrl.Builder().scheme("http").build();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertEquals("host == null", expected.getMessage());
-    }
-    try {
-      new HttpUrl.Builder().host("host").build();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertEquals("scheme == null", expected.getMessage());
-    }
-  }
-
-  @Test public void builderToString() {
-    assertEquals("https://host.com/path", parse("https://host.com/path").newBuilder().toString());
-  }
-
-  @Test public void incompleteBuilderToString() {
-    assertEquals("https:///path",
-        new HttpUrl.Builder().scheme("https").encodedPath("/path").toString());
-    assertEquals("//host.com/path",
-        new HttpUrl.Builder().host("host.com").encodedPath("/path").toString());
-    assertEquals("//host.com:8080/path",
-        new HttpUrl.Builder().host("host.com").encodedPath("/path").port(8080).toString());
-  }
-
-  @Test public void minimalUrlComposition() throws Exception {
-    HttpUrl url = new HttpUrl.Builder().scheme("http").host("host").build();
-    assertEquals("http://host/", url.toString());
-    assertEquals("http", url.scheme());
-    assertEquals("", url.username());
-    assertEquals("", url.password());
-    assertEquals("host", url.host());
-    assertEquals(80, url.port());
-    assertEquals("/", url.encodedPath());
-    assertNull(url.query());
-    assertNull(url.fragment());
-  }
-
-  @Test public void fullUrlComposition() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .username("username")
-        .password("password")
-        .host("host")
-        .port(8080)
-        .addPathSegment("path")
-        .query("query")
-        .fragment("fragment")
-        .build();
-    assertEquals("http://username:password@host:8080/path?query#fragment", url.toString());
-    assertEquals("http", url.scheme());
-    assertEquals("username", url.username());
-    assertEquals("password", url.password());
-    assertEquals("host", url.host());
-    assertEquals(8080, url.port());
-    assertEquals("/path", url.encodedPath());
-    assertEquals("query", url.query());
-    assertEquals("fragment", url.fragment());
-  }
-
-  @Test public void changingSchemeChangesDefaultPort() throws Exception {
-    assertEquals(443, parse("http://example.com")
-        .newBuilder()
-        .scheme("https")
-        .build().port());
-
-    assertEquals(80, parse("https://example.com")
-        .newBuilder()
-        .scheme("http")
-        .build().port());
-
-    assertEquals(1234, parse("https://example.com:1234")
-        .newBuilder()
-        .scheme("http")
-        .build().port());
-  }
-
-  @Test public void composeEncodesWhitespace() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .username("a\r\n\f\t b")
-        .password("c\r\n\f\t d")
-        .host("host")
-        .addPathSegment("e\r\n\f\t f")
-        .query("g\r\n\f\t h")
-        .fragment("i\r\n\f\t j")
-        .build();
-    assertEquals("http://a%0D%0A%0C%09%20b:c%0D%0A%0C%09%20d@host"
-        + "/e%0D%0A%0C%09%20f?g%0D%0A%0C%09%20h#i%0D%0A%0C%09 j", url.toString());
-    assertEquals("a\r\n\f\t b", url.username());
-    assertEquals("c\r\n\f\t d", url.password());
-    assertEquals("e\r\n\f\t f", url.pathSegments().get(0));
-    assertEquals("g\r\n\f\t h", url.query());
-    assertEquals("i\r\n\f\t j", url.fragment());
-  }
-
-  @Test public void composeFromUnencodedComponents() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .username("a:\u0001@/\\?#%b")
-        .password("c:\u0001@/\\?#%d")
-        .host("ef")
-        .port(8080)
-        .addPathSegment("g:\u0001@/\\?#%h")
-        .query("i:\u0001@/\\?#%j")
-        .fragment("k:\u0001@/\\?#%l")
-        .build();
-    assertEquals("http://a%3A%01%40%2F%5C%3F%23%25b:c%3A%01%40%2F%5C%3F%23%25d@ef:8080/"
-        + "g:%01@%2F%5C%3F%23%25h?i:%01@/\\?%23%25j#k:%01@/\\?#%25l", url.toString());
-    assertEquals("http", url.scheme());
-    assertEquals("a:\u0001@/\\?#%b", url.username());
-    assertEquals("c:\u0001@/\\?#%d", url.password());
-    assertEquals(Arrays.asList("g:\u0001@/\\?#%h"), url.pathSegments());
-    assertEquals("i:\u0001@/\\?#%j", url.query());
-    assertEquals("k:\u0001@/\\?#%l", url.fragment());
-    assertEquals("a%3A%01%40%2F%5C%3F%23%25b", url.encodedUsername());
-    assertEquals("c%3A%01%40%2F%5C%3F%23%25d", url.encodedPassword());
-    assertEquals("/g:%01@%2F%5C%3F%23%25h", url.encodedPath());
-    assertEquals("i:%01@/\\?%23%25j", url.encodedQuery());
-    assertEquals("k:%01@/\\?#%25l", url.encodedFragment());
-  }
-
-  @Test public void composeFromEncodedComponents() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .encodedUsername("a:\u0001@/\\?#%25b")
-        .encodedPassword("c:\u0001@/\\?#%25d")
-        .host("ef")
-        .port(8080)
-        .addEncodedPathSegment("g:\u0001@/\\?#%25h")
-        .encodedQuery("i:\u0001@/\\?#%25j")
-        .encodedFragment("k:\u0001@/\\?#%25l")
-        .build();
-    assertEquals("http://a%3A%01%40%2F%5C%3F%23%25b:c%3A%01%40%2F%5C%3F%23%25d@ef:8080/"
-        + "g:%01@%2F%5C%3F%23%25h?i:%01@/\\?%23%25j#k:%01@/\\?#%25l", url.toString());
-    assertEquals("http", url.scheme());
-    assertEquals("a:\u0001@/\\?#%b", url.username());
-    assertEquals("c:\u0001@/\\?#%d", url.password());
-    assertEquals(Arrays.asList("g:\u0001@/\\?#%h"), url.pathSegments());
-    assertEquals("i:\u0001@/\\?#%j", url.query());
-    assertEquals("k:\u0001@/\\?#%l", url.fragment());
-    assertEquals("a%3A%01%40%2F%5C%3F%23%25b", url.encodedUsername());
-    assertEquals("c%3A%01%40%2F%5C%3F%23%25d", url.encodedPassword());
-    assertEquals("/g:%01@%2F%5C%3F%23%25h", url.encodedPath());
-    assertEquals("i:%01@/\\?%23%25j", url.encodedQuery());
-    assertEquals("k:%01@/\\?#%25l", url.encodedFragment());
-  }
-
-  @Test public void composeWithEncodedPath() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .encodedPath("/a%2Fb/c")
-        .build();
-    assertEquals("http://host/a%2Fb/c", url.toString());
-    assertEquals("/a%2Fb/c", url.encodedPath());
-    assertEquals(Arrays.asList("a/b", "c"), url.pathSegments());
-  }
-
-  @Test public void composeMixingPathSegments() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .encodedPath("/a%2fb/c")
-        .addPathSegment("d%25e")
-        .addEncodedPathSegment("f%25g")
-        .build();
-    assertEquals("http://host/a%2fb/c/d%2525e/f%25g", url.toString());
-    assertEquals("/a%2fb/c/d%2525e/f%25g", url.encodedPath());
-    assertEquals(Arrays.asList("a%2fb", "c", "d%2525e", "f%25g"), url.encodedPathSegments());
-    assertEquals(Arrays.asList("a/b", "c", "d%25e", "f%g"), url.pathSegments());
-  }
-
-  @Test public void composeWithAddSegment() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertEquals("/a/b/c/", base.newBuilder().addPathSegment("").build().encodedPath());
-    assertEquals("/a/b/c/d",
-        base.newBuilder().addPathSegment("").addPathSegment("d").build().encodedPath());
-    assertEquals("/a/b/", base.newBuilder().addPathSegment("..").build().encodedPath());
-    assertEquals("/a/b/", base.newBuilder().addPathSegment("").addPathSegment("..").build()
-        .encodedPath());
-    assertEquals("/a/b/c/", base.newBuilder().addPathSegment("").addPathSegment("").build()
-        .encodedPath());
-  }
-
-  @Test public void pathSize() throws Exception {
-    assertEquals(1, parse("http://host/").pathSize());
-    assertEquals(3, parse("http://host/a/b/c").pathSize());
-  }
-
-  @Test public void addPathSegments() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-
-    // Add a string with zero slashes: resulting URL gains one slash.
-    assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
-    assertEquals("/a/b/c/d", base.newBuilder().addPathSegments("d").build().encodedPath());
-
-    // Add a string with one slash: resulting URL gains two slashes.
-    assertEquals("/a/b/c//", base.newBuilder().addPathSegments("/").build().encodedPath());
-    assertEquals("/a/b/c/d/", base.newBuilder().addPathSegments("d/").build().encodedPath());
-    assertEquals("/a/b/c//d", base.newBuilder().addPathSegments("/d").build().encodedPath());
-
-    // Add a string with two slashes: resulting URL gains three slashes.
-    assertEquals("/a/b/c///", base.newBuilder().addPathSegments("//").build().encodedPath());
-    assertEquals("/a/b/c//d/", base.newBuilder().addPathSegments("/d/").build().encodedPath());
-    assertEquals("/a/b/c/d//", base.newBuilder().addPathSegments("d//").build().encodedPath());
-    assertEquals("/a/b/c///d", base.newBuilder().addPathSegments("//d").build().encodedPath());
-    assertEquals("/a/b/c/d/e/f", base.newBuilder().addPathSegments("d/e/f").build().encodedPath());
-  }
-
-  @Test public void addPathSegmentsOntoTrailingSlash() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c/");
-
-    // Add a string with zero slashes: resulting URL gains zero slashes.
-    assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
-    assertEquals("/a/b/c/d", base.newBuilder().addPathSegments("d").build().encodedPath());
-
-    // Add a string with one slash: resulting URL gains one slash.
-    assertEquals("/a/b/c//", base.newBuilder().addPathSegments("/").build().encodedPath());
-    assertEquals("/a/b/c/d/", base.newBuilder().addPathSegments("d/").build().encodedPath());
-    assertEquals("/a/b/c//d", base.newBuilder().addPathSegments("/d").build().encodedPath());
-
-    // Add a string with two slashes: resulting URL gains two slashes.
-    assertEquals("/a/b/c///", base.newBuilder().addPathSegments("//").build().encodedPath());
-    assertEquals("/a/b/c//d/", base.newBuilder().addPathSegments("/d/").build().encodedPath());
-    assertEquals("/a/b/c/d//", base.newBuilder().addPathSegments("d//").build().encodedPath());
-    assertEquals("/a/b/c///d", base.newBuilder().addPathSegments("//d").build().encodedPath());
-    assertEquals("/a/b/c/d/e/f", base.newBuilder().addPathSegments("d/e/f").build().encodedPath());
-  }
-
-  @Test public void addPathSegmentsWithBackslash() throws Exception {
-    HttpUrl base = parse("http://host/");
-    assertEquals("/d/e", base.newBuilder().addPathSegments("d\\e").build().encodedPath());
-    assertEquals("/d/e", base.newBuilder().addEncodedPathSegments("d\\e").build().encodedPath());
-  }
-
-  @Test public void addPathSegmentsWithEmptyPaths() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertEquals("/a/b/c//d/e///f",
-        base.newBuilder().addPathSegments("/d/e///f").build().encodedPath());
-  }
-
-  @Test public void addEncodedPathSegments() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertEquals("/a/b/c/d/e/%20/",
-        base.newBuilder().addEncodedPathSegments("d/e/%20/\n").build().encodedPath());
-  }
-
-  @Test public void addPathSegmentDotDoesNothing() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertEquals("/a/b/c", base.newBuilder().addPathSegment(".").build().encodedPath());
-  }
-
-  @Test public void addPathSegmentEncodes() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertEquals("/a/b/c/%252e",
-        base.newBuilder().addPathSegment("%2e").build().encodedPath());
-    assertEquals("/a/b/c/%252e%252e",
-        base.newBuilder().addPathSegment("%2e%2e").build().encodedPath());
-  }
-
-  @Test public void addPathSegmentDotDotPopsDirectory() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertEquals("/a/b/", base.newBuilder().addPathSegment("..").build().encodedPath());
-  }
-
-  @Test public void addPathSegmentDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertEquals("/a/b/c/.%0A", base.newBuilder().addPathSegment(".\n").build().encodedPath());
-  }
-
-  @Test public void addEncodedPathSegmentDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertEquals("/a/b/c", base.newBuilder().addEncodedPathSegment(".\n").build().encodedPath());
-  }
-
-  @Test public void addEncodedPathSegmentDotDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertEquals("/a/b/", base.newBuilder().addEncodedPathSegment("..\n").build().encodedPath());
-  }
-
-  @Test public void setPathSegment() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertEquals("/d/b/c", base.newBuilder().setPathSegment(0, "d").build().encodedPath());
-    assertEquals("/a/d/c", base.newBuilder().setPathSegment(1, "d").build().encodedPath());
-    assertEquals("/a/b/d", base.newBuilder().setPathSegment(2, "d").build().encodedPath());
-  }
-
-  @Test public void setPathSegmentEncodes() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertEquals("/%2525/b/c", base.newBuilder().setPathSegment(0, "%25").build().encodedPath());
-    assertEquals("/.%0A/b/c", base.newBuilder().setPathSegment(0, ".\n").build().encodedPath());
-    assertEquals("/%252e/b/c", base.newBuilder().setPathSegment(0, "%2e").build().encodedPath());
-  }
-
-  @Test public void setPathSegmentAcceptsEmpty() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertEquals("//b/c", base.newBuilder().setPathSegment(0, "").build().encodedPath());
-    assertEquals("/a/b/", base.newBuilder().setPathSegment(2, "").build().encodedPath());
-  }
-
-  @Test public void setPathSegmentRejectsDot() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setPathSegment(0, ".");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setPathSegmentRejectsDotDot() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setPathSegment(0, "..");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setPathSegmentWithSlash() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    HttpUrl url = base.newBuilder().setPathSegment(1, "/").build();
-    assertEquals("/a/%2F/c", url.encodedPath());
-  }
-
-  @Test public void setPathSegmentOutOfBounds() throws Exception {
-    try {
-      new HttpUrl.Builder().setPathSegment(1, "a");
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void setEncodedPathSegmentEncodes() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertEquals("/%25/b/c",
-        base.newBuilder().setEncodedPathSegment(0, "%25").build().encodedPath());
-  }
-
-  @Test public void setEncodedPathSegmentRejectsDot() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setEncodedPathSegment(0, ".");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setEncodedPathSegmentRejectsDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setEncodedPathSegment(0, ".\n");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setEncodedPathSegmentRejectsDotDot() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setEncodedPathSegment(0, "..");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setEncodedPathSegmentRejectsDotDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setEncodedPathSegment(0, "..\n");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setEncodedPathSegmentWithSlash() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    HttpUrl url = base.newBuilder().setEncodedPathSegment(1, "/").build();
-    assertEquals("/a/%2F/c", url.encodedPath());
-  }
-
-  @Test public void setEncodedPathSegmentOutOfBounds() throws Exception {
-    try {
-      new HttpUrl.Builder().setEncodedPathSegment(1, "a");
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void removePathSegment() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    HttpUrl url = base.newBuilder()
-        .removePathSegment(0)
-        .build();
-    assertEquals("/b/c", url.encodedPath());
-  }
-
-  @Test public void removePathSegmentDoesntRemovePath() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    HttpUrl url = base.newBuilder()
-        .removePathSegment(0)
-        .removePathSegment(0)
-        .removePathSegment(0)
-        .build();
-    assertEquals(Arrays.asList(""), url.pathSegments());
-    assertEquals("/", url.encodedPath());
-  }
-
-  @Test public void removePathSegmentOutOfBounds() throws Exception {
-    try {
-      new HttpUrl.Builder().removePathSegment(1);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void toJavaNetUrl() throws Exception {
-    HttpUrl httpUrl = parse("http://username:password@host/path?query#fragment");
-    URL javaNetUrl = httpUrl.url();
-    assertEquals("http://username:password@host/path?query#fragment", javaNetUrl.toString());
-  }
-
-  @Test public void toUri() throws Exception {
-    HttpUrl httpUrl = parse("http://username:password@host/path?query#fragment");
-    URI uri = httpUrl.uri();
-    assertEquals("http://username:password@host/path?query#fragment", uri.toString());
-  }
-
-  @Test public void toUriSpecialQueryCharacters() throws Exception {
-    HttpUrl httpUrl = parse("http://host/?d=abc!@[]^`{}|\\");
-    URI uri = httpUrl.uri();
-    assertEquals("http://host/?d=abc!@[]%5E%60%7B%7D%7C%5C", uri.toString());
-  }
-
-  @Test public void toUriWithUsernameNoPassword() throws Exception {
-    HttpUrl httpUrl = new HttpUrl.Builder()
-        .scheme("http")
-        .username("user")
-        .host("host")
-        .build();
-    assertEquals("http://user@host/", httpUrl.toString());
-    assertEquals("http://user@host/", httpUrl.uri().toString());
-  }
-
-  @Test public void toUriUsernameSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .username("=[]:;\"~|?#@^/$%*")
-        .build();
-    assertEquals("http://%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/", url.toString());
-    assertEquals("http://%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/", url.uri().toString());
-  }
-
-  @Test public void toUriPasswordSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .username("user")
-        .password("=[]:;\"~|?#@^/$%*")
-        .build();
-    assertEquals("http://user:%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/", url.toString());
-    assertEquals("http://user:%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/",
-        url.uri().toString());
-  }
-
-  @Test public void toUriPathSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .addPathSegment("=[]:;\"~|?#@^/$%*")
-        .build();
-    assertEquals("http://host/=[]:;%22~%7C%3F%23@%5E%2F$%25*", url.toString());
-    assertEquals("http://host/=%5B%5D:;%22~%7C%3F%23@%5E%2F$%25*", url.uri().toString());
-  }
-
-  @Test public void toUriQueryParameterNameSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .addQueryParameter("=[]:;\"~|?#@^/$%*", "a")
-        .build();
-    assertEquals("http://host/?%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*=a",
-        url.toString());
-    assertEquals("http://host/?%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*=a",
-        url.uri().toString());
-    assertEquals("a", url.queryParameter("=[]:;\"~|?#@^/$%*"));
-  }
-
-  @Test public void toUriQueryParameterValueSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .addQueryParameter("a", "=[]:;\"~|?#@^/$%*")
-        .build();
-    assertEquals("http://host/?a=%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*",
-        url.toString());
-    assertEquals("http://host/?a=%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*",
-        url.uri().toString());
-    assertEquals("=[]:;\"~|?#@^/$%*", url.queryParameter("a"));
-  }
-
-  @Test public void toUriQueryValueSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .query("=[]:;\"~|?#@^/$%*")
-        .build();
-    assertEquals("http://host/?=[]:;%22~|?%23@^/$%25*", url.toString());
-    assertEquals("http://host/?=[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
-  }
-
-  @Test public void queryCharactersEncodedWhenComposed() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .addQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
-        .build();
-    assertEquals("http://host/?a=%21%24%28%29%2C%2F%3A%3B%3F%40%5B%5D%5C%5E%60%7B%7C%7D%7E",
-        url.toString());
-    assertEquals("!$(),/:;?@[]\\^`{|}~", url.queryParameter("a"));
-  }
-
-  /**
-   * When callers use {@code addEncodedQueryParameter()} we only encode what's strictly required.
-   * We retain the encoded (or non-encoded) state of the input.
-   */
-  @Test public void queryCharactersNotReencodedWhenComposedWithAddEncoded() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .addEncodedQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
-        .build();
-    assertEquals("http://host/?a=!$(),/:;?@[]\\^`{|}~",
-        url.toString());
-    assertEquals("!$(),/:;?@[]\\^`{|}~", url.queryParameter("a"));
-  }
-
-  /**
-   * When callers parse a URL with query components that aren't encoded, we shouldn't convert them
-   * into a canonical form because doing so could be semantically different.
-   */
-  @Test public void queryCharactersNotReencodedWhenParsed() throws Exception {
-    HttpUrl url = parse("http://host/?a=!$(),/:;?@[]\\^`{|}~");
-    assertEquals("http://host/?a=!$(),/:;?@[]\\^`{|}~", url.toString());
-    assertEquals("!$(),/:;?@[]\\^`{|}~", url.queryParameter("a"));
-  }
-
-  @Test public void toUriFragmentSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .fragment("=[]:;\"~|?#@^/$%*")
-        .build();
-    assertEquals("http://host/#=[]:;\"~|?#@^/$%25*", url.toString());
-    assertEquals("http://host/#=[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
-  }
-
-  @Test public void toUriWithControlCharacters() throws Exception {
-    // Percent-encoded in the path.
-    assertEquals(new URI("http://host/a%00b"), parse("http://host/a\u0000b").uri());
-    assertEquals(new URI("http://host/a%C2%80b"), parse("http://host/a\u0080b").uri());
-    assertEquals(new URI("http://host/a%C2%9Fb"), parse("http://host/a\u009fb").uri());
-    // Percent-encoded in the query.
-    assertEquals(new URI("http://host/?a%00b"), parse("http://host/?a\u0000b").uri());
-    assertEquals(new URI("http://host/?a%C2%80b"), parse("http://host/?a\u0080b").uri());
-    assertEquals(new URI("http://host/?a%C2%9Fb"), parse("http://host/?a\u009fb").uri());
-    // Stripped from the fragment.
-    assertEquals(new URI("http://host/#a%00b"), parse("http://host/#a\u0000b").uri());
-    assertEquals(new URI("http://host/#ab"), parse("http://host/#a\u0080b").uri());
-    assertEquals(new URI("http://host/#ab"), parse("http://host/#a\u009fb").uri());
-  }
-
-  @Test public void toUriWithSpaceCharacters() throws Exception {
-    // Percent-encoded in the path.
-    assertEquals(new URI("http://host/a%0Bb"), parse("http://host/a\u000bb").uri());
-    assertEquals(new URI("http://host/a%20b"), parse("http://host/a b").uri());
-    assertEquals(new URI("http://host/a%E2%80%89b"), parse("http://host/a\u2009b").uri());
-    assertEquals(new URI("http://host/a%E3%80%80b"), parse("http://host/a\u3000b").uri());
-    // Percent-encoded in the query.
-    assertEquals(new URI("http://host/?a%0Bb"), parse("http://host/?a\u000bb").uri());
-    assertEquals(new URI("http://host/?a%20b"), parse("http://host/?a b").uri());
-    assertEquals(new URI("http://host/?a%E2%80%89b"), parse("http://host/?a\u2009b").uri());
-    assertEquals(new URI("http://host/?a%E3%80%80b"), parse("http://host/?a\u3000b").uri());
-    // Stripped from the fragment.
-    assertEquals(new URI("http://host/#a%0Bb"), parse("http://host/#a\u000bb").uri());
-    assertEquals(new URI("http://host/#a%20b"), parse("http://host/#a b").uri());
-    assertEquals(new URI("http://host/#ab"), parse("http://host/#a\u2009b").uri());
-    assertEquals(new URI("http://host/#ab"), parse("http://host/#a\u3000b").uri());
-  }
-
-  @Test public void toUriWithNonHexPercentEscape() throws Exception {
-    assertEquals(new URI("http://host/%25xx"), parse("http://host/%xx").uri());
-  }
-
-  @Test public void toUriWithTruncatedPercentEscape() throws Exception {
-    assertEquals(new URI("http://host/%25a"), parse("http://host/%a").uri());
-    assertEquals(new URI("http://host/%25"), parse("http://host/%").uri());
-  }
-
-  @Test public void fromJavaNetUrl() throws Exception {
-    URL javaNetUrl = new URL("http://username:password@host/path?query#fragment");
-    HttpUrl httpUrl = HttpUrl.get(javaNetUrl);
-    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
-  }
-
-  @Test public void fromJavaNetUrlUnsupportedScheme() throws Exception {
-    URL javaNetUrl = new URL("mailto:user@example.com");
-    assertNull(HttpUrl.get(javaNetUrl));
-  }
-
-  @Test public void fromUri() throws Exception {
-    URI uri = new URI("http://username:password@host/path?query#fragment");
-    HttpUrl httpUrl = HttpUrl.get(uri);
-    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
-  }
-
-  @Test public void fromUriUnsupportedScheme() throws Exception {
-    URI uri = new URI("mailto:user@example.com");
-    assertNull(HttpUrl.get(uri));
-  }
-
-  @Test public void fromUriPartial() throws Exception {
-    URI uri = new URI("/path");
-    assertNull(HttpUrl.get(uri));
-  }
-
-  @Test public void composeQueryWithComponents() throws Exception {
-    HttpUrl base = parse("http://host/");
-    HttpUrl url = base.newBuilder().addQueryParameter("a+=& b", "c+=& d").build();
-    assertEquals("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d", url.toString());
-    assertEquals("c+=& d", url.queryParameterValue(0));
-    assertEquals("a+=& b", url.queryParameterName(0));
-    assertEquals("c+=& d", url.queryParameter("a+=& b"));
-    assertEquals(Collections.singleton("a+=& b"), url.queryParameterNames());
-    assertEquals(singletonList("c+=& d"), url.queryParameterValues("a+=& b"));
-    assertEquals(1, url.querySize());
-    assertEquals("a+=& b=c+=& d", url.query()); // Ambiguous! (Though working as designed.)
-    assertEquals("a%2B%3D%26%20b=c%2B%3D%26%20d", url.encodedQuery());
-  }
-
-  @Test public void composeQueryWithEncodedComponents() throws Exception {
-    HttpUrl base = parse("http://host/");
-    HttpUrl url = base.newBuilder().addEncodedQueryParameter("a+=& b", "c+=& d").build();
-    assertEquals("http://host/?a+%3D%26%20b=c+%3D%26%20d", url.toString());
-    assertEquals("c =& d", url.queryParameter("a =& b"));
-  }
-
-  @Test public void composeQueryRemoveQueryParameter() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .addQueryParameter("a+=& b", "c+=& d")
-        .removeAllQueryParameters("a+=& b")
-        .build();
-    assertEquals("http://host/", url.toString());
-    assertNull(url.queryParameter("a+=& b"));
-  }
-
-  @Test public void composeQueryRemoveEncodedQueryParameter() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .addEncodedQueryParameter("a+=& b", "c+=& d")
-        .removeAllEncodedQueryParameters("a+=& b")
-        .build();
-    assertEquals("http://host/", url.toString());
-    assertNull(url.queryParameter("a =& b"));
-  }
-
-  @Test public void composeQuerySetQueryParameter() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .addQueryParameter("a+=& b", "c+=& d")
-        .setQueryParameter("a+=& b", "ef")
-        .build();
-    assertEquals("http://host/?a%2B%3D%26%20b=ef", url.toString());
-    assertEquals("ef", url.queryParameter("a+=& b"));
-  }
-
-  @Test public void composeQuerySetEncodedQueryParameter() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .addEncodedQueryParameter("a+=& b", "c+=& d")
-        .setEncodedQueryParameter("a+=& b", "ef")
-        .build();
-    assertEquals("http://host/?a+%3D%26%20b=ef", url.toString());
-    assertEquals("ef", url.queryParameter("a =& b"));
-  }
-
-  @Test public void composeQueryMultipleEncodedValuesForParameter() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .addQueryParameter("a+=& b", "c+=& d")
-        .addQueryParameter("a+=& b", "e+=& f")
-        .build();
-    assertEquals("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d&a%2B%3D%26%20b=e%2B%3D%26%20f",
-        url.toString());
-    assertEquals(2, url.querySize());
-    assertEquals(Collections.singleton("a+=& b"), url.queryParameterNames());
-    assertEquals(Arrays.asList("c+=& d", "e+=& f"), url.queryParameterValues("a+=& b"));
-  }
-
-  @Test public void absentQueryIsZeroNameValuePairs() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .query(null)
-        .build();
-    assertEquals(0, url.querySize());
-  }
-
-  @Test public void emptyQueryIsSingleNameValuePairWithEmptyKey() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .query("")
-        .build();
-    assertEquals(1, url.querySize());
-    assertEquals("", url.queryParameterName(0));
-    assertNull(url.queryParameterValue(0));
-  }
-
-  @Test public void ampersandQueryIsTwoNameValuePairsWithEmptyKeys() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .query("&")
-        .build();
-    assertEquals(2, url.querySize());
-    assertEquals("", url.queryParameterName(0));
-    assertNull(url.queryParameterValue(0));
-    assertEquals("", url.queryParameterName(1));
-    assertNull(url.queryParameterValue(1));
-  }
-
-  @Test public void removeAllDoesNotRemoveQueryIfNoParametersWereRemoved() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .query("")
-        .removeAllQueryParameters("a")
-        .build();
-    assertEquals("http://host/?", url.toString());
-  }
-
-  @Test public void queryParametersWithoutValues() throws Exception {
-    HttpUrl url = parse("http://host/?foo&bar&baz");
-    assertEquals(3, url.querySize());
-    assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
-        url.queryParameterNames());
-    assertNull(url.queryParameterValue(0));
-    assertNull(url.queryParameterValue(1));
-    assertNull(url.queryParameterValue(2));
-    assertEquals(singletonList((String) null), url.queryParameterValues("foo"));
-    assertEquals(singletonList((String) null), url.queryParameterValues("bar"));
-    assertEquals(singletonList((String) null), url.queryParameterValues("baz"));
-  }
-
-  @Test public void queryParametersWithEmptyValues() throws Exception {
-    HttpUrl url = parse("http://host/?foo=&bar=&baz=");
-    assertEquals(3, url.querySize());
-    assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
-        url.queryParameterNames());
-    assertEquals("", url.queryParameterValue(0));
-    assertEquals("", url.queryParameterValue(1));
-    assertEquals("", url.queryParameterValue(2));
-    assertEquals(singletonList(""), url.queryParameterValues("foo"));
-    assertEquals(singletonList(""), url.queryParameterValues("bar"));
-    assertEquals(singletonList(""), url.queryParameterValues("baz"));
-  }
-
-  @Test public void queryParametersWithRepeatedName() throws Exception {
-    HttpUrl url = parse("http://host/?foo[]=1&foo[]=2&foo[]=3");
-    assertEquals(3, url.querySize());
-    assertEquals(Collections.singleton("foo[]"), url.queryParameterNames());
-    assertEquals("1", url.queryParameterValue(0));
-    assertEquals("2", url.queryParameterValue(1));
-    assertEquals("3", url.queryParameterValue(2));
-    assertEquals(Arrays.asList("1", "2", "3"), url.queryParameterValues("foo[]"));
-  }
-
-  @Test public void queryParameterLookupWithNonCanonicalEncoding() throws Exception {
-    HttpUrl url = parse("http://host/?%6d=m&+=%20");
-    assertEquals("m", url.queryParameterName(0));
-    assertEquals(" ", url.queryParameterName(1));
-    assertEquals("m", url.queryParameter("m"));
-    assertEquals(" ", url.queryParameter(" "));
-  }
-
-  @Test public void parsedQueryDoesntIncludeFragment() {
-    HttpUrl url = parse("http://host/?#fragment");
-    assertEquals("fragment", url.fragment());
-    assertEquals("", url.query());
-    assertEquals("", url.encodedQuery());
-  }
-
-  @Test public void roundTripBuilder() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .username("%")
-        .password("%")
-        .host("host")
-        .addPathSegment("%")
-        .query("%")
-        .fragment("%")
-        .build();
-    assertEquals("http://%25:%25@host/%25?%25#%25", url.toString());
-    assertEquals("http://%25:%25@host/%25?%25#%25", url.newBuilder().build().toString());
-    assertEquals("http://%25:%25@host/%25?%25", url.resolve("").toString());
-  }
-
-  /**
-   * Although HttpUrl prefers percent-encodings in uppercase, it should preserve the exact structure
-   * of the original encoding.
-   */
-  @Test public void rawEncodingRetained() throws Exception {
-    String urlString = "http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D#%6d%6D";
-    HttpUrl url = parse(urlString);
-    assertEquals("%6d%6D", url.encodedUsername());
-    assertEquals("%6d%6D", url.encodedPassword());
-    assertEquals("/%6d%6D", url.encodedPath());
-    assertEquals(Arrays.asList("%6d%6D"), url.encodedPathSegments());
-    assertEquals("%6d%6D", url.encodedQuery());
-    assertEquals("%6d%6D", url.encodedFragment());
-    assertEquals(urlString, url.toString());
-    assertEquals(urlString, url.newBuilder().build().toString());
-    assertEquals("http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D", url.resolve("").toString());
-  }
-
-  @Test public void clearFragment() throws Exception {
-    HttpUrl url = parse("http://host/#fragment")
-        .newBuilder()
-        .fragment(null)
-        .build();
-    assertEquals("http://host/", url.toString());
-    assertNull(url.fragment());
-    assertNull(url.encodedFragment());
-  }
-
-  @Test public void clearEncodedFragment() throws Exception {
-    HttpUrl url = parse("http://host/#fragment")
-        .newBuilder()
-        .encodedFragment(null)
-        .build();
-    assertEquals("http://host/", url.toString());
-    assertNull(url.fragment());
-    assertNull(url.encodedFragment());
-  }
-
-  @Test public void topPrivateDomain() {
-    assertEquals("google.com", parse("https://google.com").topPrivateDomain());
-    assertEquals("google.co.uk", parse("https://adwords.google.co.uk").topPrivateDomain());
-    assertEquals("xn--ewv.xn--4pvxs.jp", parse("https://..jp").topPrivateDomain());
-    assertEquals("xn--ewv.xn--4pvxs.jp",
-        parse("https://xn--ewv.xn--4pvxs.jp").topPrivateDomain());
-
-    assertNull(parse("https://co.uk").topPrivateDomain());
-    assertNull(parse("https://square").topPrivateDomain());
-    assertNull(parse("https://.jp").topPrivateDomain());
-    assertNull(parse("https://xn--4pvxs.jp").topPrivateDomain());
-    assertNull(parse("https://localhost").topPrivateDomain());
-    assertNull(parse("https://127.0.0.1").topPrivateDomain());
-  }
-
-  private void assertInvalid(String string, String exceptionMessage) {
-    if (useGet) {
-      try {
-        parse(string);
-        fail("Expected get of \"" + string + "\" to throw with: " + exceptionMessage);
-      } catch (IllegalArgumentException e) {
-        assertEquals(exceptionMessage, e.getMessage());
-      }
-    } else {
-      assertNull(string, parse(string));
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
deleted file mode 100644
index aad4bfa34b..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ /dev/null
@@ -1,3894 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.Authenticator;
-import java.net.ConnectException;
-import java.net.CookieManager;
-import java.net.HttpRetryException;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.PasswordAuthentication;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.net.SocketException;
-import java.net.SocketTimeoutException;
-import java.net.URI;
-import java.net.URL;
-import java.net.URLConnection;
-import java.net.UnknownHostException;
-import java.security.KeyStore;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.zip.GZIPInputStream;
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLProtocolException;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.DoubleInetAddressDns;
-import okhttp3.internal.Internal;
-import okhttp3.internal.RecordingAuthenticator;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.Util;
-import okhttp3.internal.Version;
-import okhttp3.internal.huc.OkHttpURLConnection;
-import okhttp3.internal.platform.Platform;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static java.nio.charset.StandardCharsets.US_ASCII;
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static java.util.Locale.US;
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-import static okhttp3.internal.huc.OkHttpURLConnection.SELECTED_PROTOCOL;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
-import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeTrue;
-
-/** Android's URLConnectionTest. */
-public final class URLConnectionTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final MockWebServer server2 = new MockWebServer();
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-
-  private HandshakeCertificates handshakeCertificates = localhost();
-  private OkUrlFactory urlFactory;
-  private HttpURLConnection connection;
-  private Cache cache;
-
-  @Before public void setUp() {
-    server.setProtocolNegotiationEnabled(false);
-    urlFactory = new OkUrlFactory(defaultClient());
-  }
-
-  @After public void tearDown() throws Exception {
-    Authenticator.setDefault(null);
-    System.clearProperty("proxyHost");
-    System.clearProperty("proxyPort");
-    System.clearProperty("http.agent");
-    System.clearProperty("http.proxyHost");
-    System.clearProperty("http.proxyPort");
-    System.clearProperty("https.proxyHost");
-    System.clearProperty("https.proxyPort");
-    if (cache != null) {
-      cache.delete();
-    }
-  }
-
-  @Test public void requestHeaders() throws Exception {
-    server.enqueue(new MockResponse());
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("D", "e");
-    connection.addRequestProperty("D", "f");
-    assertEquals("f", connection.getRequestProperty("D"));
-    assertEquals("f", connection.getRequestProperty("d"));
-    Map<String, List<String>> requestHeaders = connection.getRequestProperties();
-    assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("D")));
-    assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("d")));
-    try {
-      requestHeaders.put("G", Arrays.asList("h"));
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      requestHeaders.get("D").add("i");
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      connection.setRequestProperty(null, "j");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      connection.addRequestProperty(null, "k");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    connection.setRequestProperty("NullValue", null);
-    assertNull(connection.getRequestProperty("NullValue"));
-    connection.addRequestProperty("AnotherNullValue", null);
-    assertNull(connection.getRequestProperty("AnotherNullValue"));
-
-    connection.getResponseCode();
-    RecordedRequest request = server.takeRequest();
-    assertEquals(Arrays.asList("e", "f"), request.getHeaders().values("D"));
-    assertNull(request.getHeader("NullValue"));
-    assertNull(request.getHeader("AnotherNullValue"));
-    assertNull(request.getHeader("G"));
-    assertNull(request.getHeader("null"));
-
-    try {
-      connection.addRequestProperty("N", "o");
-      fail("Set header after connect");
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      connection.setRequestProperty("P", "q");
-      fail("Set header after connect");
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      connection.getRequestProperties();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void getRequestPropertyReturnsLastValue() {
-    connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("A", "value1");
-    connection.addRequestProperty("A", "value2");
-    assertEquals("value2", connection.getRequestProperty("A"));
-  }
-
-  @Test public void responseHeaders() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 Fantastic")
-        .addHeader("A: c")
-        .addHeader("B: d")
-        .addHeader("A: e")
-        .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
-
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Fantastic", connection.getResponseMessage());
-    assertEquals("HTTP/1.0 200 Fantastic", connection.getHeaderField(null));
-    Map<String, List<String>> responseHeaders = connection.getHeaderFields();
-    assertEquals(Arrays.asList("HTTP/1.0 200 Fantastic"), responseHeaders.get(null));
-    assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("A")));
-    assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("a")));
-    try {
-      responseHeaders.put("N", Arrays.asList("o"));
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      responseHeaders.get("A").add("f");
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    assertEquals("A", connection.getHeaderFieldKey(0));
-    assertEquals("c", connection.getHeaderField(0));
-    assertEquals("B", connection.getHeaderFieldKey(1));
-    assertEquals("d", connection.getHeaderField(1));
-    assertEquals("A", connection.getHeaderFieldKey(2));
-    assertEquals("e", connection.getHeaderField(2));
-    connection.getInputStream().close();
-  }
-
-  @Test public void serverSendsInvalidResponseHeaders() {
-    server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsInvalidCodeTooLarge() {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsInvalidCodeNotANumber() {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsUnnecessaryWhitespace() {
-    server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void connectRetriesUntilConnectedOrFailed() throws Exception {
-    URL url = server.url("/foo").url();
-    server.shutdown();
-
-    connection = urlFactory.open(url);
-    try {
-      connection.connect();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void requestBodySurvivesRetriesWithFixedLength() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void requestBodySurvivesRetriesWithChunkedStreaming() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.CHUNKED);
-  }
-
-  @Test public void requestBodySurvivesRetriesWithBufferedBody() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.END_OF_STREAM);
-  }
-
-  private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    // Use a misconfigured proxy to guarantee that the request is retried.
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxySelector(new FakeProxySelector()
-            .addProxy(server2.toProxyAddress())
-            .addProxy(Proxy.NO_PROXY))
-        .build());
-    server2.shutdown();
-
-    connection = urlFactory.open(server.url("/def").url());
-    connection.setDoOutput(true);
-    transferKind.setForRequest(connection, 4);
-    connection.getOutputStream().write("body".getBytes(UTF_8));
-    assertContent("abc", connection);
-
-    assertEquals("body", server.takeRequest().getBody().readUtf8());
-  }
-
-  @Test public void streamedBodyIsNotRetried() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-
-    urlFactory = new OkUrlFactory(defaultClient().newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build());
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    connection.setChunkedStreamingMode(100);
-    OutputStream os = connection.getOutputStream();
-    os.write("OutputStream is no fun.".getBytes(UTF_8));
-    os.close();
-
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    assertEquals(1, server.getRequestCount());
-  }
-
-  @Test public void getErrorStreamOnSuccessfulRequest() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    assertNull(connection.getErrorStream());
-    connection.getInputStream().close();
-  }
-
-  @Test public void getErrorStreamOnUnsuccessfulRequest() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection.getErrorStream(), Integer.MAX_VALUE));
-  }
-
-  // Check that if we don't read to the end of a response, the next request on the
-  // recycled connection doesn't get the unread tail of the first request's response.
-  // http://code.google.com/p/android/issues/detail?id=2939
-  @Test public void bug2939() throws Exception {
-    MockResponse response = new MockResponse().setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8);
-
-    server.enqueue(response);
-    server.enqueue(response);
-
-    HttpURLConnection c1 = urlFactory.open(server.url("/").url());
-    assertContent("ABCDE", c1, 5);
-    HttpURLConnection c2 = urlFactory.open(server.url("/").url());
-    assertContent("ABCDE", c2, 5);
-
-    c1.getInputStream().close();
-    c2.getInputStream().close();
-  }
-
-  // Check that we recognize a few basic mime types by extension.
-  // http://code.google.com/p/android/issues/detail?id=10100
-  @Test public void bug10100() {
-    assertEquals("image/jpeg", URLConnection.guessContentTypeFromName("someFile.jpg"));
-    assertEquals("application/pdf", URLConnection.guessContentTypeFromName("stuff.pdf"));
-  }
-
-  @Test public void connectionsArePooled() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDEFGHIJKLMNOPQR");
-
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/foo").url()));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/bar?baz=quux").url()));
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/z").url()));
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void chunkedConnectionsArePooled() throws Exception {
-    MockResponse response = new MockResponse().setChunkedBody("ABCDEFGHIJKLMNOPQR", 5);
-
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/foo").url()));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/bar?baz=quux").url()));
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/z").url()));
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void serverClosesSocket() throws Exception {
-    testServerClosesOutput(DISCONNECT_AT_END);
-  }
-
-  @Test public void serverShutdownInput() throws Exception {
-    testServerClosesOutput(SHUTDOWN_INPUT_AT_END);
-  }
-
-  @Test public void serverShutdownOutput() throws Exception {
-    testServerClosesOutput(SHUTDOWN_OUTPUT_AT_END);
-  }
-
-  @Test public void invalidHost() throws Exception {
-    // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
-    URL url = new URL("http://1234.1.1.1/index.html");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new FakeDns())
-        .build());
-    HttpURLConnection connection = urlFactory.open(url);
-    try {
-      connection.connect();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception {
-    server.enqueue(new MockResponse().setBody("This connection won't pool properly")
-        .setSocketPolicy(socketPolicy));
-    MockResponse responseAfter = new MockResponse().setBody("This comes after a busted connection");
-    server.enqueue(responseAfter);
-    server.enqueue(responseAfter); // Enqueue 2x because the broken connection may be reused.
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/a").url());
-    connection1.setReadTimeout(100);
-    assertContent("This connection won't pool properly", connection1);
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-
-    // Give the server time to enact the socket policy if it's one that could happen after the
-    // client has received the response.
-    Thread.sleep(500);
-
-    HttpURLConnection connection2 = urlFactory.open(server.url("/b").url());
-    connection2.setReadTimeout(100);
-    assertContent("This comes after a busted connection", connection2);
-
-    // Check that a fresh connection was created, either immediately or after attempting reuse.
-    // We know that a fresh connection was created if the server recorded a request with sequence
-    // number 0. Since the client may have attempted to reuse the broken connection just before
-    // creating a fresh connection, the server may have recorded 2 requests at this point. The order
-    // of recording is non-deterministic.
-    RecordedRequest requestAfter = server.takeRequest();
-    assertTrue(
-        requestAfter.getSequenceNumber() == 0
-            || server.getRequestCount() == 3 && server.takeRequest().getSequenceNumber() == 0);
-  }
-
-  enum WriteKind {BYTE_BY_BYTE, SMALL_BUFFERS, LARGE_BUFFERS}
-
-  @Test public void chunkedUpload_byteByByte() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.BYTE_BY_BYTE);
-  }
-
-  @Test public void chunkedUpload_smallBuffers() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.SMALL_BUFFERS);
-  }
-
-  @Test public void chunkedUpload_largeBuffers() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.LARGE_BUFFERS);
-  }
-
-  @Test public void fixedLengthUpload_byteByByte() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.BYTE_BY_BYTE);
-  }
-
-  @Test public void fixedLengthUpload_smallBuffers() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.SMALL_BUFFERS);
-  }
-
-  @Test public void fixedLengthUpload_largeBuffers() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.LARGE_BUFFERS);
-  }
-
-  private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Exception {
-    int n = 512 * 1024;
-    server.setBodyLimit(0);
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection conn = urlFactory.open(server.url("/").url());
-    conn.setDoOutput(true);
-    conn.setRequestMethod("POST");
-    if (uploadKind == TransferKind.CHUNKED) {
-      conn.setChunkedStreamingMode(-1);
-    } else {
-      conn.setFixedLengthStreamingMode(n);
-    }
-    OutputStream out = conn.getOutputStream();
-    if (writeKind == WriteKind.BYTE_BY_BYTE) {
-      for (int i = 0; i < n; ++i) {
-        out.write('x');
-      }
-    } else {
-      byte[] buf = new byte[writeKind == WriteKind.SMALL_BUFFERS ? 256 : 64 * 1024];
-      Arrays.fill(buf, (byte) 'x');
-      for (int i = 0; i < n; i += buf.length) {
-        out.write(buf, 0, Math.min(buf.length, n - i));
-      }
-    }
-    out.close();
-    assertEquals(200, conn.getResponseCode());
-    RecordedRequest request = server.takeRequest();
-    assertEquals(n, request.getBodySize());
-    if (uploadKind == TransferKind.CHUNKED) {
-      assertTrue(request.getChunkSizes().size() > 0);
-    } else {
-      assertTrue(request.getChunkSizes().isEmpty());
-    }
-  }
-
-  @Test public void getResponseCodeNoResponseBody() throws Exception {
-    server.enqueue(new MockResponse().addHeader("abc: def"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection conn = urlFactory.open(url);
-    conn.setDoInput(false);
-    assertEquals("def", conn.getHeaderField("abc"));
-    assertEquals(200, conn.getResponseCode());
-    try {
-      conn.getInputStream();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void connectViaHttps() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    connection = urlFactory.open(server.url("/foo").url());
-
-    assertContent("this response comes via HTTPS", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-  }
-
-  @Test public void inspectHandshakeThroughoutRequestLifecycle() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse());
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-
-    HttpsURLConnection httpsConnection
-        = (HttpsURLConnection) urlFactory.open(server.url("/foo").url());
-
-    // Prior to calling connect(), getting the cipher suite is forbidden.
-    try {
-      httpsConnection.getCipherSuite();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    // Calling connect establishes a handshake...
-    httpsConnection.connect();
-    assertNotNull(httpsConnection.getCipherSuite());
-
-    // ...which remains after we read the response body...
-    assertContent("", httpsConnection);
-    assertNotNull(httpsConnection.getCipherSuite());
-
-    // ...and after we disconnect.
-    httpsConnection.disconnect();
-    assertNotNull(httpsConnection.getCipherSuite());
-  }
-
-  @Test public void connectViaHttpsReusingConnections() throws Exception {
-    connectViaHttpsReusingConnections(false);
-  }
-
-  @Test public void connectViaHttpsReusingConnectionsAfterRebuildingClient() throws Exception {
-    connectViaHttpsReusingConnections(true);
-  }
-
-  private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-    server.enqueue(new MockResponse().setBody("another response via HTTPS"));
-
-    // The pool will only reuse sockets if the SSL socket factories are the same.
-    SSLSocketFactory clientSocketFactory = handshakeCertificates.sslSocketFactory();
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    CookieJar cookieJar = new JavaNetCookieJar(new CookieManager());
-    ConnectionPool connectionPool = new ConnectionPool();
-
-    urlFactory.setClient(new OkHttpClient.Builder()
-        .cache(cache)
-        .connectionPool(connectionPool)
-        .cookieJar(cookieJar)
-        .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertContent("this response comes via HTTPS", connection);
-
-    if (rebuildClient) {
-      urlFactory.setClient(new OkHttpClient.Builder()
-          .cache(cache)
-          .connectionPool(connectionPool)
-          .cookieJar(cookieJar)
-          .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
-          .hostnameVerifier(hostnameVerifier)
-          .build());
-    }
-
-    connection = urlFactory.open(server.url("/").url());
-    assertContent("another response via HTTPS", connection);
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectViaHttpsReusingConnectionsDifferentFactories() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-    server.enqueue(new MockResponse().setBody("another response via HTTPS"));
-
-    // install a custom SSL socket factory so the server can be authorized
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    assertContent("this response comes via HTTPS", connection1);
-
-    SSLContext sslContext2 = Platform.get().getSSLContext();
-    sslContext2.init(null, null, null);
-    SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
-
-    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-        TrustManagerFactory.getDefaultAlgorithm());
-    trustManagerFactory.init((KeyStore) null);
-    X509TrustManager trustManager = (X509TrustManager) trustManagerFactory.getTrustManagers()[0];
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslSocketFactory2, trustManager)
-        .build());
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    try {
-      readAscii(connection2.getInputStream(), Integer.MAX_VALUE);
-      fail("without an SSL socket factory, the connection should fail");
-    } catch (SSLException expected) {
-    }
-  }
-
-  // TODO(jwilson): tests below this marker need to be migrated to OkHttp's request/response API.
-
-  @Test public void connectViaHttpsWithSSLFallback() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("this response comes via SSL"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
-        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build());
-    connection = urlFactory.open(server.url("/foo").url());
-
-    assertContent("this response comes via SSL", connection);
-
-    RecordedRequest failHandshakeRequest = server.takeRequest();
-    assertNull(failHandshakeRequest.getRequestLine());
-
-    RecordedRequest fallbackRequest = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", fallbackRequest.getRequestLine());
-    assertEquals(TlsVersion.TLS_1_2, fallbackRequest.getTlsVersion());
-  }
-
-  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build());
-    connection = urlFactory.open(server.url("/foo").url());
-
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-      assertEquals(1, expected.getSuppressed().length);
-    }
-  }
-
-  /**
-   * When a pooled connection fails, don't blame the route. Otherwise pooled connection failures can
-   * cause unnecessary SSL fallbacks.
-   *
-   * https://github.com/square/okhttp/issues/515
-   */
-  @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .setSocketPolicy(DISCONNECT_AT_END));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build());
-
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-
-    // Give the server time to disconnect.
-    Thread.sleep(500);
-
-    assertContent("def", urlFactory.open(server.url("/").url()));
-
-    Set<TlsVersion> tlsVersions =
-        EnumSet.of(TlsVersion.TLS_1_0, TlsVersion.TLS_1_2); // v1.2 on OpenJDK 8.
-
-    RecordedRequest request1 = server.takeRequest();
-    assertTrue(tlsVersions.contains(request1.getTlsVersion()));
-
-    RecordedRequest request2 = server.takeRequest();
-    assertTrue(tlsVersions.contains(request2.getTlsVersion()));
-  }
-
-  /**
-   * Verify that we don't retry connections on certificate verification errors.
-   *
-   * http://code.google.com/p/android/issues/detail?id=13178
-   */
-  @Test public void connectViaHttpsToUntrustedServer() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()); // unused
-
-    connection = urlFactory.open(server.url("/foo").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (SSLHandshakeException expected) {
-      assertTrue(expected.getCause() instanceof CertificateException);
-    }
-    assertEquals(0, server.getRequestCount());
-  }
-
-  @Test public void connectViaProxyUsingProxyArg() throws Exception {
-    testConnectViaProxy(ProxyConfig.CREATE_ARG);
-  }
-
-  @Test public void connectViaProxyUsingProxySystemProperty() throws Exception {
-    testConnectViaProxy(ProxyConfig.PROXY_SYSTEM_PROPERTY);
-  }
-
-  @Test public void connectViaProxyUsingHttpProxySystemProperty() throws Exception {
-    testConnectViaProxy(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
-  }
-
-  private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
-    MockResponse mockResponse = new MockResponse().setBody("this response comes via a proxy");
-    server.enqueue(mockResponse);
-
-    URL url = new URL("http://android.com/foo");
-    connection = proxyConfig.connect(server, urlFactory, url);
-    assertContent("this response comes via a proxy", connection);
-    assertTrue(connection.usingProxy());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET http://android.com/foo HTTP/1.1", request.getRequestLine());
-    assertEquals("android.com", request.getHeader("Host"));
-  }
-
-  @Test public void contentDisagreesWithContentLengthHeaderBodyTooLong() throws IOException {
-    server.enqueue(new MockResponse().setBody("abc\r\nYOU SHOULD NOT SEE THIS")
-        .clearHeaders()
-        .addHeader("Content-Length: 3"));
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-  }
-
-  @Test public void contentDisagreesWithContentLengthHeaderBodyTooShort() throws IOException {
-    server.enqueue(new MockResponse().setBody("abc")
-        .setHeader("Content-Length", "5")
-        .setSocketPolicy(DISCONNECT_AT_END));
-    try {
-      readAscii(urlFactory.open(server.url("/").url()).getInputStream(), 5);
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  private void testConnectViaSocketFactory(boolean useHttps) throws IOException {
-    SocketFactory uselessSocketFactory = new SocketFactory() {
-      public Socket createSocket() {
-        throw new IllegalArgumentException("useless");
-      }
-
-      public Socket createSocket(InetAddress host, int port) {
-        return null;
-      }
-
-      public Socket createSocket(InetAddress address, int port, InetAddress localAddress,
-          int localPort) {
-        return null;
-      }
-
-      public Socket createSocket(String host, int port) {
-        return null;
-      }
-
-      public Socket createSocket(String host, int port, InetAddress localHost, int localPort) {
-        return null;
-      }
-    };
-
-    if (useHttps) {
-      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-      urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(
-              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-          .hostnameVerifier(new RecordingHostnameVerifier())
-          .build());
-    }
-
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .socketFactory(uselessSocketFactory)
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .socketFactory(SocketFactory.getDefault())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(200, connection.getResponseCode());
-  }
-
-  @Test public void connectHttpViaSocketFactory() throws Exception {
-    testConnectViaSocketFactory(false);
-  }
-
-  @Test public void connectHttpsViaSocketFactory() throws Exception {
-    testConnectViaSocketFactory(true);
-  }
-
-  @Test public void contentDisagreesWithChunkedHeaderBodyTooLong() throws IOException {
-    MockResponse mockResponse = new MockResponse();
-    mockResponse.setChunkedBody("abc", 3);
-    Buffer buffer = mockResponse.getBody();
-    buffer.writeUtf8("\r\nYOU SHOULD NOT SEE THIS");
-    mockResponse.setBody(buffer);
-    mockResponse.clearHeaders();
-    mockResponse.addHeader("Transfer-encoding: chunked");
-
-    server.enqueue(mockResponse);
-
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-  }
-
-  @Test public void contentDisagreesWithChunkedHeaderBodyTooShort() throws IOException {
-    MockResponse mockResponse = new MockResponse();
-    mockResponse.setChunkedBody("abcdefg", 5);
-
-    Buffer truncatedBody = new Buffer();
-    Buffer fullBody = mockResponse.getBody();
-    truncatedBody.write(fullBody, 4);
-    mockResponse.setBody(truncatedBody);
-
-    mockResponse.clearHeaders();
-    mockResponse.addHeader("Transfer-encoding: chunked");
-    mockResponse.setSocketPolicy(DISCONNECT_AT_END);
-
-    server.enqueue(mockResponse);
-
-    try {
-      readAscii(urlFactory.open(server.url("/").url()).getInputStream(), 7);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingProxyArgWithNoProxy() throws Exception {
-    testConnectViaDirectProxyToHttps(ProxyConfig.NO_PROXY);
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingHttpProxySystemProperty() throws Exception {
-    // https should not use http proxy
-    testConnectViaDirectProxyToHttps(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
-  }
-
-  private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-
-    URL url = server.url("/foo").url();
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    connection = proxyConfig.connect(server, urlFactory, url);
-
-    assertContent("this response comes via HTTPS", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingProxyArg() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.CREATE_ARG);
-  }
-
-  /**
-   * We weren't honoring all of the appropriate proxy system properties when connecting via HTTPS.
-   * http://b/3097518
-   */
-  @Test public void connectViaHttpProxyToHttpsUsingProxySystemProperty() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.PROXY_SYSTEM_PROPERTY);
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingHttpsProxySystemProperty() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.HTTPS_PROXY_SYSTEM_PROPERTY);
-  }
-
-  /**
-   * We were verifying the wrong hostname when connecting to an HTTPS site through a proxy.
-   * http://b/3097277
-   */
-  private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
-
-    URL url = new URL("https://android.com/foo");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-    connection = proxyConfig.connect(server, urlFactory, url);
-
-    assertContent("this response comes via a secure proxy", connection);
-
-    RecordedRequest connect = server.takeRequest();
-    assertEquals("Connect line failure on proxy", "CONNECT android.com:443 HTTP/1.1",
-        connect.getRequestLine());
-    assertEquals("android.com:443", connect.getHeader("Host"));
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
-    assertEquals("android.com", get.getHeader("Host"));
-    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
-  }
-
-  /** Tolerate bad https proxy response when using HttpResponseCache. Android bug 6754912. */
-  @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
-    initResponseCache();
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
-    MockResponse badProxyResponse = new MockResponse()
-        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
-        .setBody("bogus proxy connect response content");
-    server.enqueue(badProxyResponse);
-    server.enqueue(new MockResponse().setBody("response"));
-
-    // Configure a single IP address for the host and a single configuration, so we only need one
-    // failure to fail permanently.
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .proxy(server.toProxyAddress())
-        .build());
-
-    URL url = new URL("https://android.com/foo");
-    connection = urlFactory.open(url);
-    assertContent("response", connection);
-
-    RecordedRequest connect = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
-    assertEquals("android.com:443", connect.getHeader("Host"));
-  }
-
-  private void initResponseCache() {
-    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .cache(cache)
-        .build());
-  }
-
-  /** Test which headers are sent unencrypted to the HTTP proxy. */
-  @Test public void proxyConnectIncludesProxyHeadersOnly() throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-
-    URL url = new URL("https://android.com/foo");
-    connection = urlFactory.open(url);
-    connection.addRequestProperty("Private", "Secret");
-    connection.addRequestProperty("Proxy-Authorization", "bar");
-    connection.addRequestProperty("User-Agent", "baz");
-    assertContent("encrypted response from the origin server", connection);
-
-    RecordedRequest connect = server.takeRequest();
-    assertNull(connect.getHeader("Private"));
-    assertNull(connect.getHeader("Proxy-Authorization"));
-    assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
-    assertEquals("android.com:443", connect.getHeader("Host"));
-    assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("Secret", get.getHeader("Private"));
-    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
-  }
-
-  @Test public void proxyAuthenticateOnConnect() throws Exception {
-    Authenticator.setDefault(new RecordingAuthenticator());
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse().setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
-    server.enqueue(
-        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("A"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxyAuthenticator(new JavaNetAuthenticator())
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-
-    URL url = new URL("https://android.com/foo");
-    connection = urlFactory.open(url);
-    assertContent("A", connection);
-
-    RecordedRequest connect1 = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect1.getRequestLine());
-    assertNull(connect1.getHeader("Proxy-Authorization"));
-
-    RecordedRequest connect2 = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect2.getRequestLine());
-    assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-        connect2.getHeader("Proxy-Authorization"));
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
-    assertNull(get.getHeader("Proxy-Authorization"));
-  }
-
-  // Don't disconnect after building a tunnel with CONNECT
-  // http://code.google.com/p/android/issues/detail?id=37221
-  @Test public void proxyWithConnectionClose() throws IOException {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-
-    URL url = new URL("https://android.com/foo");
-    connection = urlFactory.open(url);
-    connection.setRequestProperty("Connection", "close");
-
-    assertContent("this response comes via a proxy", connection);
-  }
-
-  @Test public void proxyWithConnectionReuse() throws IOException {
-    SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(socketFactory, true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("response 1"));
-    server.enqueue(new MockResponse().setBody("response 2"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-    URL url = new URL("https://android.com/foo");
-    assertContent("response 1", urlFactory.open(url));
-    assertContent("response 2", urlFactory.open(url));
-  }
-
-  @Test public void disconnectedConnection() throws IOException {
-    server.enqueue(new MockResponse()
-        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
-        .setBody("ABCD"));
-
-    connection = urlFactory.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals('A', (char) in.read());
-    connection.disconnect();
-    try {
-      // Reading 'B' may succeed if it's buffered.
-      in.read();
-
-      // But 'C' shouldn't be buffered (the response is throttled) and this should fail.
-      in.read();
-      fail("Expected a connection closed exception");
-    } catch (IOException expected) {
-    }
-    in.close();
-  }
-
-  @Test public void disconnectDuringConnect_cookieJar() {
-    final AtomicReference<HttpURLConnection> connectionHolder = new AtomicReference<>();
-    class DisconnectingCookieJar implements CookieJar {
-      @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) { }
-      @Override
-      public List<Cookie> loadForRequest(HttpUrl url) {
-        connectionHolder.get().disconnect();
-        return Collections.emptyList();
-      }
-    }
-    OkHttpClient client = new okhttp3.OkHttpClient.Builder()
-            .cookieJar(new DisconnectingCookieJar())
-            .build();
-
-    URL url = server.url("path that should never be accessed").url();
-    HttpURLConnection connection = new OkHttpURLConnection(url, client);
-    connectionHolder.set(connection);
-    try {
-      connection.getInputStream();
-      fail("Connection should not be established");
-    } catch (IOException expected) {
-      assertEquals("Canceled", expected.getMessage());
-    } finally {
-      connection.disconnect();
-    }
-  }
-
-  @Test public void disconnectBeforeConnect() throws IOException {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.disconnect();
-    assertContent("A", connection);
-    assertEquals(200, connection.getResponseCode());
-  }
-
-  @SuppressWarnings("deprecation") @Test public void defaultRequestProperty() {
-    URLConnection.setDefaultRequestProperty("X-testSetDefaultRequestProperty", "A");
-    assertNull(URLConnection.getDefaultRequestProperty("X-setDefaultRequestProperty"));
-  }
-
-  /**
-   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
-   * characters can be read, the remaining characters are returned and the stream is closed.
-   */
-  private String readAscii(InputStream in, int count) throws IOException {
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  @Test public void markAndResetWithContentLengthHeader() throws IOException {
-    testMarkAndReset(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void markAndResetWithChunkedEncoding() throws IOException {
-    testMarkAndReset(TransferKind.CHUNKED);
-  }
-
-  @Test public void markAndResetWithNoLengthHeaders() throws IOException {
-    testMarkAndReset(TransferKind.END_OF_STREAM);
-  }
-
-  private void testMarkAndReset(TransferKind transferKind) throws IOException {
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    InputStream in = urlFactory.open(server.url("/").url()).getInputStream();
-    assertFalse("This implementation claims to support mark().", in.markSupported());
-    in.mark(5);
-    assertEquals("ABCDE", readAscii(in, 5));
-    try {
-      in.reset();
-      fail();
-    } catch (IOException expected) {
-    }
-    assertEquals("FGHIJKLMNOPQRSTUVWXYZ", readAscii(in, Integer.MAX_VALUE));
-    in.close();
-    assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", urlFactory.open(server.url("/").url()));
-  }
-
-  /**
-   * We've had a bug where we forget the HTTP response when we see response code 401. This causes a
-   * new HTTP request to be issued for every call into the URLConnection.
-   */
-  @Test public void unauthorizedResponseHandling() throws IOException {
-    MockResponse response = new MockResponse().addHeader("WWW-Authenticate: challenge")
-        .setResponseCode(401) // UNAUTHORIZED
-        .setBody("Unauthorized");
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    URL url = server.url("/").url();
-    HttpURLConnection conn = urlFactory.open(url);
-
-    assertEquals(401, conn.getResponseCode());
-    assertEquals(401, conn.getResponseCode());
-    assertEquals(401, conn.getResponseCode());
-    assertEquals(1, server.getRequestCount());
-    conn.getErrorStream().close();
-  }
-
-  @Test public void nonHexChunkSize() throws IOException {
-    server.enqueue(new MockResponse().setBody("5\r\nABCDE\r\nG\r\nFGHIJKLMNOPQRSTU\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException e) {
-    }
-    connection.getInputStream().close();
-  }
-
-  @Test public void malformedChunkSize() throws IOException {
-    server.enqueue(new MockResponse().setBody("5:x\r\nABCDE\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException e) {
-    } finally {
-      connection.getInputStream().close();
-    }
-  }
-
-  @Test public void extensionAfterChunkSize() throws IOException {
-    server.enqueue(new MockResponse().setBody("5;x\r\nABCDE\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertContent("ABCDE", connection);
-  }
-
-  @Test public void missingChunkBody() throws IOException {
-    server.enqueue(new MockResponse().setBody("5")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked")
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException e) {
-    } finally {
-      connection.getInputStream().close();
-    }
-  }
-
-  /**
-   * This test checks whether connections are gzipped by default. This behavior in not required by
-   * the API, so a failure of this test does not imply a bug in the implementation.
-   */
-  @Test public void gzipEncodingEnabledByDefault() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("ABCABCABC", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    assertNull(connection.getContentEncoding());
-    assertEquals(-1, connection.getContentLength());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("gzip", request.getHeader("Accept-Encoding"));
-  }
-
-  @Test public void clientConfiguredGzipContentEncoding() throws Exception {
-    Buffer bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
-    server.enqueue(new MockResponse()
-        .setBody(bodyBytes)
-        .addHeader("Content-Encoding: gzip"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Accept-Encoding", "gzip");
-    InputStream gunzippedIn = new GZIPInputStream(connection.getInputStream());
-    assertEquals("ABCDEFGHIJKLMNOPQRSTUVWXYZ", readAscii(gunzippedIn, Integer.MAX_VALUE));
-    assertEquals(bodyBytes.size(), connection.getContentLength());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("gzip", request.getHeader("Accept-Encoding"));
-  }
-
-  @Test public void gzipAndConnectionReuseWithFixedLength() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, false);
-  }
-
-  @Test public void gzipAndConnectionReuseWithChunkedEncoding() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, false);
-  }
-
-  @Test public void gzipAndConnectionReuseWithFixedLengthAndTls() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, true);
-  }
-
-  @Test public void gzipAndConnectionReuseWithChunkedEncodingAndTls() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, true);
-  }
-
-  @Test public void clientConfiguredCustomContentEncoding() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE").addHeader("Content-Encoding: custom"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Accept-Encoding", "custom");
-    assertEquals("ABCDE", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("custom", request.getHeader("Accept-Encoding"));
-  }
-
-  /**
-   * Test a bug where gzip input streams weren't exhausting the input stream, which corrupted the
-   * request that followed or prevented connection reuse.
-   * http://code.google.com/p/android/issues/detail?id=7059
-   * http://code.google.com/p/android/issues/detail?id=38817
-   */
-  private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind transferKind,
-      boolean tls) throws Exception {
-    if (tls) {
-      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
-      RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-      server.useHttps(socketFactory, false);
-      urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
-          .hostnameVerifier(hostnameVerifier)
-          .build());
-    }
-
-    MockResponse responseOne = new MockResponse();
-    responseOne.addHeader("Content-Encoding: gzip");
-    transferKind.setBody(responseOne, gzip("one (gzipped)"), 5);
-    server.enqueue(responseOne);
-    MockResponse responseTwo = new MockResponse();
-    transferKind.setBody(responseTwo, "two (identity)", 5);
-    server.enqueue(responseTwo);
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    connection1.addRequestProperty("Accept-Encoding", "gzip");
-    InputStream gunzippedIn = new GZIPInputStream(connection1.getInputStream());
-    assertEquals("one (gzipped)", readAscii(gunzippedIn, Integer.MAX_VALUE));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertEquals("two (identity)", readAscii(connection2.getInputStream(), Integer.MAX_VALUE));
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void transparentGzipWorksAfterExceptionRecovery() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("a")
-        .setSocketPolicy(SHUTDOWN_INPUT_AT_END));
-    server.enqueue(new MockResponse()
-        .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("b")));
-
-    // Seed the pool with a bad connection.
-    assertContent("a", urlFactory.open(server.url("/").url()));
-
-    // Give the server time to disconnect.
-    Thread.sleep(500);
-
-    // This connection will need to be recovered. When it is, transparent gzip should still work!
-    assertContent("b", urlFactory.open(server.url("/").url()));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
-  }
-
-  @Test public void endOfStreamResponseIsNotPooled() throws Exception {
-    urlFactory.client().connectionPool().evictAll();
-    server.enqueue(new MockResponse()
-        .setBody("{}")
-        .clearHeaders()
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertContent("{}", connection);
-    assertEquals(0, urlFactory.client().connectionPool().idleConnectionCount());
-  }
-
-  @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
-    testEarlyDisconnectDoesntHarmPooling(TransferKind.CHUNKED);
-  }
-
-  @Test public void earlyDisconnectDoesntHarmPoolingWithFixedLengthEncoding() throws Exception {
-    testEarlyDisconnectDoesntHarmPooling(TransferKind.FIXED_LENGTH);
-  }
-
-  private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) throws Exception {
-    MockResponse response1 = new MockResponse();
-    transferKind.setBody(response1, "ABCDEFGHIJK", 1024);
-    server.enqueue(response1);
-
-    MockResponse response2 = new MockResponse();
-    transferKind.setBody(response2, "LMNOPQRSTUV", 1024);
-    server.enqueue(response2);
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    InputStream in1 = connection1.getInputStream();
-    assertEquals("ABCDE", readAscii(in1, 5));
-    in1.close();
-    connection1.disconnect();
-
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    InputStream in2 = connection2.getInputStream();
-    assertEquals("LMNOP", readAscii(in2, 5));
-    in2.close();
-    connection2.disconnect();
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection is pooled!
-  }
-
-  @Test public void streamDiscardingIsTimely() throws Exception {
-    // This response takes at least a full second to serve: 10,000 bytes served 100 bytes at a time.
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[10000]))
-        .throttleBody(100, 10, MILLISECONDS));
-    server.enqueue(new MockResponse().setBody("A"));
-
-    long startNanos = System.nanoTime();
-    URLConnection connection1 = urlFactory.open(server.url("/").url());
-    InputStream in = connection1.getInputStream();
-    in.close();
-    long elapsedNanos = System.nanoTime() - startNanos;
-    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-
-    // If we're working correctly, this should be greater than 100ms, but less than double that.
-    // Previously we had a bug where we would download the entire response body as long as no
-    // individual read took longer than 100ms.
-    assertTrue(Util.format("Time to close: %sms", elapsedMillis), elapsedMillis < 500);
-
-    // Do another request to confirm that the discarded connection was not pooled.
-    assertContent("A", urlFactory.open(server.url("/").url()));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
-  }
-
-  @Test public void setChunkedStreamingMode() throws Exception {
-    server.enqueue(new MockResponse());
-
-    String body = "ABCDEFGHIJKLMNOPQ";
-    connection = urlFactory.open(server.url("/").url());
-    connection.setChunkedStreamingMode(0); // OkHttp does not honor specific chunk sizes.
-    connection.setDoOutput(true);
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(body.getBytes(US_ASCII));
-    assertEquals(200, connection.getResponseCode());
-    connection.getInputStream().close();
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(body, request.getBody().readUtf8());
-    assertEquals(Arrays.asList(body.length()), request.getChunkSizes());
-  }
-
-  @Test public void authenticateWithFixedLengthStreaming() throws Exception {
-    testAuthenticateWithStreamingPost(StreamingMode.FIXED_LENGTH);
-  }
-
-  @Test public void authenticateWithChunkedStreaming() throws Exception {
-    testAuthenticateWithStreamingPost(StreamingMode.CHUNKED);
-  }
-
-  private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    byte[] requestBody = {'A', 'B', 'C', 'D'};
-    if (streamingMode == StreamingMode.FIXED_LENGTH) {
-      connection.setFixedLengthStreamingMode(requestBody.length);
-    } else if (streamingMode == StreamingMode.CHUNKED) {
-      connection.setChunkedStreamingMode(0);
-    }
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (HttpRetryException expected) {
-    }
-
-    // no authorization header for the request...
-    RecordedRequest request = server.takeRequest();
-    assertNull(request.getHeader("Authorization"));
-    assertEquals("ABCD", request.getBody().readUtf8());
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(401));
-    server.enqueue(new MockResponse());
-
-    String credential = Credentials.basic("jesse", "secret");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build());
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(body.getBytes(UTF_8));
-    outputStream.close();
-    assertEquals(200, connection.getResponseCode());
-    connection.getInputStream().close();
-
-    RecordedRequest recordedRequest1 = server.takeRequest();
-    assertEquals("POST", recordedRequest1.getMethod());
-    assertEquals(body, recordedRequest1.getBody().readUtf8());
-    assertNull(recordedRequest1.getHeader("Authorization"));
-
-    RecordedRequest recordedRequest2 = server.takeRequest();
-    assertEquals("POST", recordedRequest2.getMethod());
-    assertEquals(body, recordedRequest2.getBody().readUtf8());
-    assertEquals(credential, recordedRequest2.getHeader("Authorization"));
-  }
-
-  @Test public void nonStandardAuthenticationScheme() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo");
-    assertEquals(Collections.<String>emptyList(), calls);
-  }
-
-  @Test public void nonStandardAuthenticationSchemeWithRealm() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo realm=\"Bar\"");
-    assertEquals(0, calls.size());
-  }
-
-  // Digest auth is currently unsupported. Test that digest requests should fail reasonably.
-  // http://code.google.com/p/android/issues/detail?id=11140
-  @Test public void digestAuthentication() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Digest "
-        + "realm=\"testrealm@host.com\", qop=\"auth,auth-int\", "
-        + "nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", "
-        + "opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"");
-    assertEquals(0, calls.size());
-  }
-
-  @Test public void allAttributesSetInServerAuthenticationCallbacks() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Basic realm=\"Bar\"");
-    assertEquals(1, calls.size());
-    URL url = server.url("/").url();
-    String call = calls.get(0);
-    assertTrue(call, call.contains("host=" + url.getHost()));
-    assertTrue(call, call.contains("port=" + url.getPort()));
-    assertTrue(call, call.contains("site=" + url.getHost()));
-    assertTrue(call, call.contains("url=" + url));
-    assertTrue(call, call.contains("type=" + Authenticator.RequestorType.SERVER));
-    assertTrue(call, call.contains("prompt=Bar"));
-    assertTrue(call, call.contains("protocol=http"));
-    assertTrue(call, call.toLowerCase(US).contains("scheme=basic")); // lowercase for the RI.
-  }
-
-  @Test public void allAttributesSetInProxyAuthenticationCallbacks() throws Exception {
-    List<String> calls = authCallsForHeader("Proxy-Authenticate: Basic realm=\"Bar\"");
-    assertEquals(1, calls.size());
-    URL url = server.url("/").url();
-    String call = calls.get(0);
-    assertTrue(call, call.contains("host=" + url.getHost()));
-    assertTrue(call, call.contains("port=" + url.getPort()));
-    assertTrue(call, call.contains("site=" + url.getHost()));
-    assertTrue(call, call.contains("url=http://android.com"));
-    assertTrue(call, call.contains("type=" + Authenticator.RequestorType.PROXY));
-    assertTrue(call, call.contains("prompt=Bar"));
-    assertTrue(call, call.contains("protocol=http"));
-    assertTrue(call, call.toLowerCase(US).contains("scheme=basic")); // lowercase for the RI.
-  }
-
-  private List<String> authCallsForHeader(String authHeader) throws IOException {
-    boolean proxy = authHeader.startsWith("Proxy-");
-    int responseCode = proxy ? 407 : 401;
-    RecordingAuthenticator authenticator = new RecordingAuthenticator(null);
-    Authenticator.setDefault(authenticator);
-    MockResponse pleaseAuthenticate = new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader(authHeader)
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-
-    if (proxy) {
-      urlFactory.setClient(urlFactory.client().newBuilder()
-          .proxy(server.toProxyAddress())
-          .proxyAuthenticator(new JavaNetAuthenticator())
-          .build());
-      connection = urlFactory.open(new URL("http://android.com/"));
-    } else {
-      urlFactory.setClient(urlFactory.client().newBuilder()
-          .authenticator(new JavaNetAuthenticator())
-          .build());
-      connection = urlFactory.open(server.url("/").url());
-    }
-    assertEquals(responseCode, connection.getResponseCode());
-    connection.getErrorStream().close();
-    return authenticator.calls;
-  }
-
-  @Test public void setValidRequestMethod() throws Exception {
-    assertValidRequestMethod("GET");
-    assertValidRequestMethod("DELETE");
-    assertValidRequestMethod("HEAD");
-    assertValidRequestMethod("OPTIONS");
-    assertValidRequestMethod("POST");
-    assertValidRequestMethod("PUT");
-    assertValidRequestMethod("TRACE");
-    assertValidRequestMethod("PATCH");
-  }
-
-  private void assertValidRequestMethod(String requestMethod) throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    connection.setRequestMethod(requestMethod);
-    assertEquals(requestMethod, connection.getRequestMethod());
-  }
-
-  @Test public void setInvalidRequestMethodLowercase() {
-    assertInvalidRequestMethod("get");
-  }
-
-  @Test public void setInvalidRequestMethodConnect() {
-    assertInvalidRequestMethod("CONNECT");
-  }
-
-  private void assertInvalidRequestMethod(String requestMethod) {
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.setRequestMethod(requestMethod);
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void shoutcast() throws Exception {
-    server.enqueue(new MockResponse().setStatus("ICY 200 OK")
-        // .addHeader("HTTP/1.0 200 OK")
-        .addHeader("Accept-Ranges: none")
-        .addHeader("Content-Type: audio/mpeg")
-        .addHeader("icy-br:128")
-        .addHeader("ice-audio-info: bitrate=128;samplerate=44100;channels=2")
-        .addHeader("icy-br:128")
-        .addHeader("icy-description:Rock")
-        .addHeader("icy-genre:riders")
-        .addHeader("icy-name:A2RRock")
-        .addHeader("icy-pub:1")
-        .addHeader("icy-url:http://www.A2Rradio.com")
-        .addHeader("Server: Icecast 2.3.3-kh8")
-        .addHeader("Cache-Control: no-cache")
-        .addHeader("Pragma: no-cache")
-        .addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT")
-        .addHeader("icy-metaint:16000")
-        .setBody("mp3 data"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("OK", connection.getResponseMessage());
-    assertContent("mp3 data", connection);
-  }
-
-  @Test public void cannotSetNegativeFixedLengthStreamingMode() {
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.setFixedLengthStreamingMode(-2);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void canSetNegativeChunkedStreamingMode() {
-    connection = urlFactory.open(server.url("/").url());
-    connection.setChunkedStreamingMode(-2);
-  }
-
-  @Test public void cannotSetFixedLengthStreamingModeAfterConnect() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    try {
-      connection.setFixedLengthStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cannotSetChunkedStreamingModeAfterConnect() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    try {
-      connection.setChunkedStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() {
-    connection = urlFactory.open(server.url("/").url());
-    connection.setChunkedStreamingMode(1);
-    try {
-      connection.setFixedLengthStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() {
-    connection = urlFactory.open(server.url("/").url());
-    connection.setFixedLengthStreamingMode(1);
-    try {
-      connection.setChunkedStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void secureFixedLengthStreaming() throws Exception {
-    testSecureStreamingPost(StreamingMode.FIXED_LENGTH);
-  }
-
-  @Test public void secureChunkedStreaming() throws Exception {
-    testSecureStreamingPost(StreamingMode.CHUNKED);
-  }
-
-  /**
-   * Users have reported problems using HTTPS with streaming request bodies.
-   * http://code.google.com/p/android/issues/detail?id=12860
-   */
-  private void testSecureStreamingPost(StreamingMode streamingMode) throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    byte[] requestBody = {'A', 'B', 'C', 'D'};
-    if (streamingMode == StreamingMode.FIXED_LENGTH) {
-      connection.setFixedLengthStreamingMode(requestBody.length);
-    } else if (streamingMode == StreamingMode.CHUNKED) {
-      connection.setChunkedStreamingMode(0);
-    }
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    assertEquals("Success!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST / HTTP/1.1", request.getRequestLine());
-    if (streamingMode == StreamingMode.FIXED_LENGTH) {
-      assertEquals(Collections.<Integer>emptyList(), request.getChunkSizes());
-    } else if (streamingMode == StreamingMode.CHUNKED) {
-      assertEquals(Arrays.asList(4), request.getChunkSizes());
-    }
-    assertEquals("ABCD", request.getBody().readUtf8());
-  }
-
-  enum StreamingMode {
-    FIXED_LENGTH, CHUNKED
-  }
-
-  @Test public void authenticateWithPost() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    byte[] requestBody = {'A', 'B', 'C', 'D'};
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    // no authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertNull(request.getHeader("Authorization"));
-
-    // ...but the three requests that follow include an authorization header
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertEquals("POST / HTTP/1.1", request.getRequestLine());
-      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-          request.getHeader("Authorization"));
-      assertEquals("ABCD", request.getBody().readUtf8());
-    }
-  }
-
-  @Test public void authenticateWithGet() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    // no authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertNull(request.getHeader("Authorization"));
-
-    // ...but the three requests that follow requests include an authorization header
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertEquals("GET / HTTP/1.1", request.getRequestLine());
-      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-          request.getHeader("Authorization"));
-    }
-  }
-
-  @Test public void authenticateWithCharset() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
-        .setBody("Please authenticate with UTF-8."));
-    server.enqueue(new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate with ISO-8859-1."));
-    server.enqueue(new MockResponse()
-        .setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator(
-        new PasswordAuthentication("username", "mtorhead".toCharArray())));
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    // No authorization header for the first request...
-    RecordedRequest request1 = server.takeRequest();
-    assertNull(request1.getHeader("Authorization"));
-
-    // UTF-8 encoding for the first credential.
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("Basic dXNlcm5hbWU6bcO2dG9yaGVhZA==", request2.getHeader("Authorization"));
-
-    // ISO-8859-1 encoding for the second credential.
-    RecordedRequest request3 = server.takeRequest();
-    assertEquals("Basic dXNlcm5hbWU6bfZ0b3JoZWFk", request3.getHeader("Authorization"));
-  }
-
-  /** https://code.google.com/p/android/issues/detail?id=74026 */
-  @Test public void authenticateWithGetAndTransparentGzip() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time
-    MockResponse successfulResponse = new MockResponse()
-        .addHeader("Content-Encoding", "gzip")
-        .setBody(gzip("Successful auth!"));
-    server.enqueue(successfulResponse);
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    // no authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertNull(request.getHeader("Authorization"));
-
-    // ...but the three requests that follow requests include an authorization header
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertEquals("GET / HTTP/1.1", request.getRequestLine());
-      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-          request.getHeader("Authorization"));
-    }
-  }
-
-  /** https://github.com/square/okhttp/issues/342 */
-  @Test public void authenticateRealmUppercase() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(401)
-        .addHeader("wWw-aUtHeNtIcAtE: bAsIc rEaLm=\"pRoTeCtEd aReA\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  @Test public void redirectedWithChunkedEncoding() throws Exception {
-    testRedirected(TransferKind.CHUNKED, true);
-  }
-
-  @Test public void redirectedWithContentLengthHeader() throws Exception {
-    testRedirected(TransferKind.FIXED_LENGTH, true);
-  }
-
-  @Test public void redirectedWithNoLengthHeaders() throws Exception {
-    testRedirected(TransferKind.END_OF_STREAM, false);
-  }
-
-  private void testRedirected(TransferKind transferKind, boolean reuse) throws Exception {
-    MockResponse response = new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo");
-    transferKind.setBody(response, "This page has moved!", 10);
-    server.enqueue(response);
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("This is the new location!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest first = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", first.getRequestLine());
-    RecordedRequest retry = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", retry.getRequestLine());
-    if (reuse) {
-      assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
-    }
-  }
-
-  @Test public void redirectedOnHttps() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("This is the new location!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest first = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", first.getRequestLine());
-    RecordedRequest retry = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", retry.getRequestLine());
-    assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
-  }
-
-  @Test public void notRedirectedFromHttpsToHttp() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: http://anyhost/foo")
-        .setBody("This page has moved!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .followSslRedirects(false)
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  @Test public void notRedirectedFromHttpToHttps() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: https://anyhost/foo")
-        .setBody("This page has moved!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .followSslRedirects(false)
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
-    server2.enqueue(new MockResponse().setBody("This is insecure HTTP!"));
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url())
-        .setBody("This page has moved!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .followSslRedirects(true)
-        .build());
-    HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(server.url("/").url());
-    assertContent("This is insecure HTTP!", connection);
-    assertNull(connection.getCipherSuite());
-    assertNull(connection.getLocalCertificates());
-    assertNull(connection.getServerCertificates());
-    assertNull(connection.getPeerPrincipal());
-    assertNull(connection.getLocalPrincipal());
-  }
-
-  @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
-    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server2.enqueue(new MockResponse().setBody("This is secure HTTPS!"));
-
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url())
-        .setBody("This page has moved!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .followSslRedirects(true)
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertContent("This is secure HTTPS!", connection);
-    assertFalse(connection instanceof HttpsURLConnection);
-  }
-
-  @Test public void redirectToAnotherOriginServer() throws Exception {
-    redirectToAnotherOriginServer(false);
-  }
-
-  @Test public void redirectToAnotherOriginServerWithHttps() throws Exception {
-    redirectToAnotherOriginServer(true);
-  }
-
-  private void redirectToAnotherOriginServer(boolean https) throws Exception {
-    if (https) {
-      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-      server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
-      server2.setProtocolNegotiationEnabled(false);
-      urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(
-              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-          .hostnameVerifier(new RecordingHostnameVerifier())
-          .build());
-    }
-
-    server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
-    server2.enqueue(new MockResponse().setBody("This is the 2nd server, again!"));
-
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url().toString())
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the first server again!"));
-
-    connection = urlFactory.open(server.url("/").url());
-    assertContent("This is the 2nd server!", connection);
-    assertEquals(server2.url("/").url(), connection.getURL());
-
-    // make sure the first server was careful to recycle the connection
-    assertContent("This is the first server again!", urlFactory.open(server.url("/").url()));
-    assertContent("This is the 2nd server, again!", urlFactory.open(server2.url("/").url()));
-
-    String server1Host = server.getHostName() + ":" + server.getPort();
-    String server2Host = server2.getHostName() + ":" + server2.getPort();
-    assertEquals(server1Host, server.takeRequest().getHeader("Host"));
-    assertEquals(server2Host, server2.takeRequest().getHeader("Host"));
-    assertEquals("Expected connection reuse", 1, server.takeRequest().getSequenceNumber());
-    assertEquals("Expected connection reuse", 1, server2.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void redirectWithProxySelector() throws Exception {
-    final List<URI> proxySelectionRequests = new ArrayList<>();
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxySelector(new ProxySelector() {
-          @Override public List<Proxy> select(URI uri) {
-            proxySelectionRequests.add(uri);
-            MockWebServer proxyServer = (uri.getPort() == server.getPort())
-                ? server
-                : server2;
-            return Arrays.asList(proxyServer.toProxyAddress());
-          }
-
-          @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
-            throw new AssertionError();
-          }
-        })
-        .build());
-
-    server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
-
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/b").url().toString())
-        .setBody("This page has moved!"));
-
-    assertContent("This is the 2nd server!", urlFactory.open(server.url("/a").url()));
-
-    assertEquals(Arrays.asList(server.url("/").url().toURI(), server2.url("/").url().toURI()),
-        proxySelectionRequests);
-  }
-
-  @Test public void redirectWithAuthentication() throws Exception {
-    server2.enqueue(new MockResponse().setBody("Page 2"));
-
-    server.enqueue(new MockResponse().setResponseCode(401));
-    server.enqueue(new MockResponse().setResponseCode(302)
-        .addHeader("Location: " + server2.url("/b").url()));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret"), null))
-        .build());
-    assertContent("Page 2", urlFactory.open(server.url("/a").url()));
-
-    RecordedRequest redirectRequest = server2.takeRequest();
-    assertNull(redirectRequest.getHeader("Authorization"));
-    assertEquals("/b", redirectRequest.getPath());
-  }
-
-  @Test public void response300MultipleChoiceWithPost() throws Exception {
-    // Chrome doesn't follow the redirect, but Firefox and the RI both do
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MULT_CHOICE, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response301MovedPermanentlyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_PERM, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response302MovedTemporarilyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response303SeeOtherWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_SEE_OTHER, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void postRedirectToGetWithChunkedRequest() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.CHUNKED);
-  }
-
-  @Test public void postRedirectToGetWithStreamedRequest() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.FIXED_LENGTH);
-  }
-
-  private void testResponseRedirectedWithPost(int redirectCode, TransferKind transferKind)
-      throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(redirectCode)
-        .addHeader("Location: /page2")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    connection = urlFactory.open(server.url("/page1").url());
-    connection.setDoOutput(true);
-    transferKind.setForRequest(connection, 4);
-    byte[] requestBody = {'A', 'B', 'C', 'D'};
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    assertEquals("Page 2", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    assertTrue(connection.getDoOutput());
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
-    assertEquals("ABCD", page1.getBody().readUtf8());
-
-    RecordedRequest page2 = server.takeRequest();
-    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
-  }
-
-  @Test public void redirectedPostStripsRequestBodyHeaders() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /page2"));
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    connection = urlFactory.open(server.url("/page1").url());
-    connection.setDoOutput(true);
-    connection.addRequestProperty("Content-Length", "4");
-    connection.addRequestProperty("Content-Type", "text/plain; charset=utf-8");
-    connection.addRequestProperty("Transfer-Encoding", "identity");
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write("ABCD".getBytes(UTF_8));
-    outputStream.close();
-    assertEquals("Page 2", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    assertEquals("POST /page1 HTTP/1.1", server.takeRequest().getRequestLine());
-
-    RecordedRequest page2 = server.takeRequest();
-    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
-    assertNull(page2.getHeader("Content-Length"));
-    assertNull(page2.getHeader("Content-Type"));
-    assertNull(page2.getHeader("Transfer-Encoding"));
-  }
-
-  @Test public void response305UseProxy() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_USE_PROXY)
-        .addHeader("Location: " + server.url("/").url())
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("Proxy Response"));
-
-    connection = urlFactory.open(server.url("/foo").url());
-    // Fails on the RI, which gets "Proxy Response"
-    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", page1.getRequestLine());
-    assertEquals(1, server.getRequestCount());
-  }
-
-  @Test public void response307WithGet() throws Exception {
-    testRedirect(true, "GET");
-  }
-
-  @Test public void response307WithHead() throws Exception {
-    testRedirect(true, "HEAD");
-  }
-
-  @Test public void response307WithOptions() throws Exception {
-    testRedirect(true, "OPTIONS");
-  }
-
-  @Test public void response307WithPost() throws Exception {
-    testRedirect(true, "POST");
-  }
-
-  @Test public void response308WithGet() throws Exception {
-    testRedirect(false, "GET");
-  }
-
-  @Test public void response308WithHead() throws Exception {
-    testRedirect(false, "HEAD");
-  }
-
-  @Test public void response308WithOptions() throws Exception {
-    testRedirect(false, "OPTIONS");
-  }
-
-  @Test public void response308WithPost() throws Exception {
-    testRedirect(false, "POST");
-  }
-
-  private void testRedirect(boolean temporary, String method) throws Exception {
-    MockResponse response1 = new MockResponse()
-        .setResponseCode(temporary ? HTTP_TEMP_REDIRECT : HTTP_PERM_REDIRECT)
-        .addHeader("Location: /page2");
-    if (!method.equals("HEAD")) {
-      response1.setBody("This page has moved!");
-    }
-    server.enqueue(response1);
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    connection = urlFactory.open(server.url("/page1").url());
-    connection.setRequestMethod(method);
-    byte[] requestBody = {'A', 'B', 'C', 'D'};
-    if (method.equals("POST")) {
-      connection.setDoOutput(true);
-      OutputStream outputStream = connection.getOutputStream();
-      outputStream.write(requestBody);
-      outputStream.close();
-    }
-
-    String response = readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals(method + " /page1 HTTP/1.1", page1.getRequestLine());
-
-    if (method.equals("GET")) {
-      assertEquals("Page 2", response);
-    } else if (method.equals("HEAD")) {
-      assertEquals("", response);
-    } else {
-      // Methods other than GET/HEAD shouldn't follow the redirect
-      if (method.equals("POST")) {
-        assertTrue(connection.getDoOutput());
-        assertEquals("ABCD", page1.getBody().readUtf8());
-      }
-      assertEquals(1, server.getRequestCount());
-      assertEquals("This page has moved!", response);
-      return;
-    }
-
-    // GET/HEAD requests should have followed the redirect with the same method
-    assertFalse(connection.getDoOutput());
-    assertEquals(2, server.getRequestCount());
-    RecordedRequest page2 = server.takeRequest();
-    assertEquals(method + " /page2 HTTP/1.1", page2.getRequestLine());
-  }
-
-  @Test public void follow20Redirects() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    connection = urlFactory.open(server.url("/0").url());
-    assertContent("Success!", connection);
-    assertEquals(server.url("/20").url(), connection.getURL());
-  }
-
-  @Test public void doesNotFollow21Redirects() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-
-    connection = urlFactory.open(server.url("/0").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (ProtocolException expected) {
-      assertEquals(HttpURLConnection.HTTP_MOVED_TEMP, connection.getResponseCode());
-      assertEquals("Too many follow-up requests: 21", expected.getMessage());
-      assertEquals(server.url("/20").url(), connection.getURL());
-    }
-  }
-
-  @Test public void httpsWithCustomTrustManager() throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    RecordingTrustManager trustManager = new RecordingTrustManager(handshakeCertificates.trustManager());
-    SSLContext sslContext = Platform.get().getSSLContext();
-    sslContext.init(null, new TrustManager[] { trustManager }, null);
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .hostnameVerifier(hostnameVerifier)
-        .sslSocketFactory(sslContext.getSocketFactory(), trustManager)
-        .build());
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-    server.enqueue(new MockResponse().setBody("GHI"));
-
-    URL url = server.url("/").url();
-    assertContent("ABC", urlFactory.open(url));
-    assertContent("DEF", urlFactory.open(url));
-    assertContent("GHI", urlFactory.open(url));
-
-    assertEquals(Arrays.asList("verify " + server.getHostName()), hostnameVerifier.calls);
-    assertEquals(Arrays.asList("checkServerTrusted [CN=localhost 1]"), trustManager.calls);
-  }
-
-  @Test public void getClientRequestTimeout() throws Exception {
-    enqueueClientRequestTimeoutResponses();
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Body", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  private void enqueueClientRequestTimeoutResponses() {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(HttpURLConnection.HTTP_CLIENT_TIMEOUT)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse().setBody("Body"));
-  }
-
-  @Test public void bufferedBodyWithClientRequestTimeout() throws Exception {
-    enqueueClientRequestTimeoutResponses();
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setRequestMethod("POST");
-    connection.getOutputStream().write("Hello".getBytes(UTF_8));
-
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Body", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("Hello", request1.getBody().readUtf8());
-
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("Hello", request2.getBody().readUtf8());
-  }
-
-  @Test public void streamedBodyWithClientRequestTimeout() throws Exception {
-    enqueueClientRequestTimeoutResponses();
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setRequestMethod("POST");
-    connection.setChunkedStreamingMode(0);
-    connection.getOutputStream().write("Hello".getBytes(UTF_8));
-
-    assertEquals(408, connection.getResponseCode());
-    assertEquals(1, server.getRequestCount());
-    connection.getErrorStream().close();
-  }
-
-  @Test public void readTimeouts() throws IOException {
-    // This relies on the fact that MockWebServer doesn't close the
-    // connection after a response has been sent. This causes the client to
-    // try to read more bytes than are sent, which results in a timeout.
-    MockResponse timeout =
-        new MockResponse().setBody("ABC").clearHeaders().addHeader("Content-Length: 4");
-    server.enqueue(timeout);
-    server.enqueue(new MockResponse().setBody("unused")); // to keep the server alive
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setReadTimeout(1000);
-    InputStream in = connection.getInputStream();
-    assertEquals('A', in.read());
-    assertEquals('B', in.read());
-    assertEquals('C', in.read());
-    try {
-      in.read(); // if Content-Length was accurate, this would return -1 immediately
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-    in.close();
-  }
-
-  /** Confirm that an unacknowledged write times out. */
-  @Test public void writeTimeouts() throws IOException {
-    MockWebServer server = new MockWebServer();
-    // Sockets on some platforms can have large buffers that mean writes do not block when
-    // required. These socket factories explicitly set the buffer sizes on sockets created.
-    final int SOCKET_BUFFER_SIZE = 4 * 1024;
-    server.setServerSocketFactory(
-        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
-          @Override
-          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
-              throws IOException {
-            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            return serverSocket;
-          }
-        });
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-          @Override protected Socket configureSocket(Socket socket) throws IOException {
-            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-            return socket;
-          }
-        })
-        .writeTimeout(500, TimeUnit.MILLISECONDS)
-        .build());
-
-    server.start();
-    server.enqueue(new MockResponse()
-        .throttleBody(1, 1, TimeUnit.SECONDS)); // Prevent the server from reading!
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    connection.setChunkedStreamingMode(0);
-    OutputStream out = connection.getOutputStream();
-    try {
-      byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
-      out.write(data);
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-  }
-
-  @Test public void setChunkedEncodingAsRequestProperty() throws Exception {
-    server.enqueue(new MockResponse());
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setRequestProperty("Transfer-encoding", "chunked");
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("ABC".getBytes(UTF_8));
-    assertEquals(200, connection.getResponseCode());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("ABC", request.getBody().readUtf8());
-  }
-
-  @Test public void connectionCloseInRequest() throws Exception {
-    server.enqueue(new MockResponse()); // server doesn't honor the connection: close header!
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection a = urlFactory.open(server.url("/").url());
-    a.setRequestProperty("Connection", "close");
-    assertEquals(200, a.getResponseCode());
-
-    HttpURLConnection b = urlFactory.open(server.url("/").url());
-    assertEquals(200, b.getResponseCode());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals("When connection: close is used, each request should get its own connection", 0,
-        server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectionCloseInResponse() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Connection: close"));
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection a = urlFactory.open(server.url("/").url());
-    assertEquals(200, a.getResponseCode());
-
-    HttpURLConnection b = urlFactory.open(server.url("/").url());
-    assertEquals(200, b.getResponseCode());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals("When connection: close is used, each request should get its own connection", 0,
-        server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectionCloseWithRedirect() throws Exception {
-    MockResponse response = new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .addHeader("Connection: close");
-    server.enqueue(response);
-    server.enqueue(new MockResponse()
-        .setBody("This is the new location!"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("This is the new location!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals("When connection: close is used, each request should get its own connection", 0,
-        server.takeRequest().getSequenceNumber());
-  }
-
-  /**
-   * Retry redirects if the socket is closed.
-   * https://code.google.com/p/android/issues/detail?id=41576
-   */
-  @Test public void sameConnectionRedirectAndReuse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .setBody("This is the new page!"));
-
-    assertContent("This is the new page!", urlFactory.open(server.url("/").url()));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void responseCodeDisagreesWithHeaders() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
-        .setBody("This body is not allowed!"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("HTTP 204 had non-zero Content-Length: 25", expected.getMessage());
-    }
-  }
-
-  @Test public void singleByteReadIsSigned() throws IOException {
-    server.enqueue(new MockResponse().setBody(new Buffer().writeByte(-2).writeByte(-1)));
-
-    connection = urlFactory.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals(254, in.read());
-    assertEquals(255, in.read());
-    assertEquals(-1, in.read());
-  }
-
-  @Test public void flushAfterStreamTransmittedWithChunkedEncoding() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.CHUNKED);
-  }
-
-  @Test public void flushAfterStreamTransmittedWithFixedLength() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void flushAfterStreamTransmittedWithNoLengthHeaders() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.END_OF_STREAM);
-  }
-
-  /**
-   * We explicitly permit apps to close the upload stream even after it has been transmitted.  We
-   * also permit flush so that buffered streams can do a no-op flush when they are closed.
-   * http://b/3038470
-   */
-  private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws IOException {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    byte[] upload = "def".getBytes(UTF_8);
-
-    if (transferKind == TransferKind.CHUNKED) {
-      connection.setChunkedStreamingMode(0);
-    } else if (transferKind == TransferKind.FIXED_LENGTH) {
-      connection.setFixedLengthStreamingMode(upload.length);
-    }
-
-    OutputStream out = connection.getOutputStream();
-    out.write(upload);
-    assertEquals("abc", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    out.flush(); // Dubious but permitted.
-    try {
-      out.write("ghi".getBytes(UTF_8));
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void getHeadersThrows() {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void dnsFailureThrowsIOException() throws IOException {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new FakeDns())
-        .build());
-    connection = urlFactory.open(new URL("http://host.unlikelytld"));
-    try {
-      connection.connect();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
-    connection = urlFactory.open(new URL("http://./foo.html"));
-    try {
-      connection.connect();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void getKeepAlive() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC"));
-
-    // The request should work once and then fail
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    connection1.setReadTimeout(100);
-    InputStream input = connection1.getInputStream();
-    assertEquals("ABC", readAscii(input, Integer.MAX_VALUE));
-    server.shutdown();
-    try {
-      HttpURLConnection connection2 = urlFactory.open(server.url("").url());
-      connection2.setReadTimeout(100);
-      connection2.getInputStream();
-      fail();
-    } catch (ConnectException expected) {
-    }
-  }
-
-  /** http://code.google.com/p/android/issues/detail?id=14562 */
-  @Test public void readAfterLastByte() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC")
-        .clearHeaders()
-        .addHeader("Connection: close")
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    connection = urlFactory.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals("ABC", readAscii(in, 3));
-    assertEquals(-1, in.read());
-    assertEquals(-1, in.read()); // throws IOException in Gingerbread
-  }
-
-  @Test public void getContent() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    InputStream in = (InputStream) connection.getContent();
-    assertEquals("A", readAscii(in, Integer.MAX_VALUE));
-  }
-
-  @Test public void getContentOfType() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getContent(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      connection.getContent(new Class[] {null});
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    assertNull(connection.getContent(new Class[] {getClass()}));
-    connection.getInputStream().close();
-  }
-
-  @Test public void getOutputStreamOnGetFails() throws Exception {
-    server.enqueue(new MockResponse());
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getOutputStream();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-    connection.getInputStream().close();
-  }
-
-  @Test public void getOutputAfterGetInputStreamFails() throws Exception {
-    server.enqueue(new MockResponse());
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    try {
-      connection.getInputStream();
-      connection.getOutputStream();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void setDoOutputOrDoInputAfterConnectFails() throws Exception {
-    server.enqueue(new MockResponse());
-    connection = urlFactory.open(server.url("/").url());
-    connection.connect();
-    try {
-      connection.setDoOutput(true);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      connection.setDoInput(true);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    connection.getInputStream().close();
-  }
-
-  @Test public void clientSendsContentLength() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    OutputStream out = connection.getOutputStream();
-    out.write(new byte[] {'A', 'B', 'C'});
-    out.close();
-    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    RecordedRequest request = server.takeRequest();
-    assertEquals("3", request.getHeader("Content-Length"));
-    connection.getInputStream().close();
-  }
-
-  @Test public void getContentLengthConnects() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(3, connection.getContentLength());
-    connection.getInputStream().close();
-  }
-
-  @Test public void getContentTypeConnects() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("ABC"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("text/plain", connection.getContentType());
-    connection.getInputStream().close();
-  }
-
-  @Test public void getContentEncodingConnects() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Encoding: identity").setBody("ABC"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("identity", connection.getContentEncoding());
-    connection.getInputStream().close();
-  }
-
-  // http://b/4361656
-  @Test public void urlContainsQueryButNoPath() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    URL url = new URL("http", server.getHostName(), server.getPort(), "?query");
-    assertEquals("A", readAscii(urlFactory.open(url).getInputStream(), Integer.MAX_VALUE));
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /?query HTTP/1.1", request.getRequestLine());
-  }
-
-  @Test public void doOutputForMethodThatDoesntSupportOutput() throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    connection.setRequestMethod("HEAD");
-    connection.setDoOutput(true);
-    try {
-      connection.connect();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  // http://code.google.com/p/android/issues/detail?id=20442
-  @Test public void inputStreamAvailableWithChunkedEncoding() throws Exception {
-    testInputStreamAvailable(TransferKind.CHUNKED);
-  }
-
-  @Test public void inputStreamAvailableWithContentLengthHeader() throws Exception {
-    testInputStreamAvailable(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void inputStreamAvailableWithNoLengthHeaders() throws Exception {
-    testInputStreamAvailable(TransferKind.END_OF_STREAM);
-  }
-
-  private void testInputStreamAvailable(TransferKind transferKind) throws IOException {
-    String body = "ABCDEFGH";
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, body, 4);
-    server.enqueue(response);
-    connection = urlFactory.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    for (int i = 0; i < body.length(); i++) {
-      assertTrue(in.available() >= 0);
-      assertEquals(body.charAt(i), in.read());
-    }
-    assertEquals(0, in.available());
-    assertEquals(-1, in.read());
-  }
-
-  @Test public void postFailsWithBufferedRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 1024);
-  }
-
-  @Test public void postFailsWithBufferedRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 16384);
-  }
-
-  @Test public void postFailsWithChunkedRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 1024);
-  }
-
-  @Test public void postFailsWithChunkedRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 16384);
-  }
-
-  @Test public void postFailsWithFixedLengthRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 1024);
-  }
-
-  @Test public void postFailsWithFixedLengthRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 16384);
-  }
-
-  private void reusedConnectionFailsWithPost(TransferKind transferKind, int requestSize)
-      throws Exception {
-    server.enqueue(new MockResponse().setBody("A").setSocketPolicy(DISCONNECT_AT_END));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    assertContent("A", urlFactory.open(server.url("/a").url()));
-
-    // Give the server time to disconnect.
-    Thread.sleep(500);
-
-    // If the request body is larger than OkHttp's replay buffer, the failure may still occur.
-    byte[] requestBody = new byte[requestSize];
-    new Random(0).nextBytes(requestBody);
-
-    for (int j = 0; j < 2; j++) {
-      try {
-        connection = urlFactory.open(server.url("/b").url());
-        connection.setRequestMethod("POST");
-        transferKind.setForRequest(connection, requestBody.length);
-        for (int i = 0; i < requestBody.length; i += 1024) {
-          connection.getOutputStream().write(requestBody, i, 1024);
-        }
-        connection.getOutputStream().close();
-        assertContent("B", connection);
-        break;
-      } catch (IOException socketException) {
-        // If there's a socket exception, this must have a streamed request body.
-        assertEquals(0, j);
-        assertTrue(transferKind == TransferKind.CHUNKED
-            || transferKind == TransferKind.FIXED_LENGTH);
-      }
-    }
-
-    RecordedRequest requestA = server.takeRequest();
-    assertEquals("/a", requestA.getPath());
-    RecordedRequest requestB = server.takeRequest();
-    assertEquals("/b", requestB.getPath());
-    assertEquals(Arrays.toString(requestBody), Arrays.toString(requestB.getBody().readByteArray()));
-  }
-
-  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    // Seed the connection pool so we have something that can fail.
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-
-    HttpURLConnection post = urlFactory.open(server.url("/").url());
-    post.setDoOutput(true);
-    post.getOutputStream().write("body!".getBytes(UTF_8));
-    assertContent("def", post);
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals(0, get.getSequenceNumber());
-
-    RecordedRequest post1 = server.takeRequest();
-    assertEquals("body!", post1.getBody().readUtf8());
-    assertEquals(1, post1.getSequenceNumber());
-
-    RecordedRequest post2 = server.takeRequest();
-    assertEquals("body!", post2.getBody().readUtf8());
-    assertEquals(0, post2.getSequenceNumber());
-  }
-
-  @Test public void fullyBufferedPostIsTooShort() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    connection = urlFactory.open(server.url("/b").url());
-    connection.setRequestProperty("Content-Length", "4");
-    connection.setRequestMethod("POST");
-    OutputStream out = connection.getOutputStream();
-    out.write('a');
-    out.write('b');
-    out.write('c');
-    try {
-      out.close();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void fullyBufferedPostIsTooLong() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    connection = urlFactory.open(server.url("/b").url());
-    connection.setRequestProperty("Content-Length", "3");
-    connection.setRequestMethod("POST");
-    OutputStream out = connection.getOutputStream();
-    out.write('a');
-    out.write('b');
-    out.write('c');
-    try {
-      out.write('d');
-      out.flush();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test @Ignore public void testPooledConnectionsDetectHttp10() {
-    // TODO: write a test that shows pooled connections detect HTTP/1.0 (vs. HTTP/1.1)
-    fail("TODO");
-  }
-
-  @Test @Ignore public void postBodiesRetransmittedOnAuthProblems() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void cookiesAndTrailers() {
-    // Do cookie headers get processed too many times?
-    fail("TODO");
-  }
-
-  @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
-    server.enqueue(new MockResponse().setBody("body"));
-    connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("B", "");
-    assertContent("body", connection);
-    assertEquals("", connection.getRequestProperty("B"));
-  }
-
-  @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
-    server.enqueue(new MockResponse().addHeader("A:").setBody("body"));
-    connection = urlFactory.open(server.url("/").url());
-    assertContent("body", connection);
-    assertEquals("", connection.getHeaderField("A"));
-  }
-
-  @Test public void emptyRequestHeaderNameIsStrict() {
-    server.enqueue(new MockResponse().setBody("body"));
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.setRequestProperty("", "A");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void emptyResponseHeaderNameIsLenient() throws Exception {
-    Headers.Builder headers = new Headers.Builder();
-    Internal.instance.addLenient(headers, ":A");
-    server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
-    connection = urlFactory.open(server.url("/").url());
-    connection.getResponseCode();
-    assertEquals("A", connection.getHeaderField(""));
-    connection.getInputStream().close();
-  }
-
-  @Test public void requestHeaderValidationIsStrict() {
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.addRequestProperty("a\tb", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      connection.addRequestProperty("Name", "c\u007fd");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      connection.addRequestProperty("", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      connection.addRequestProperty("\ud83c\udf69", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      connection.addRequestProperty("Name", "\u2615\ufe0f");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void responseHeaderParsingIsLenient() throws Exception {
-    Headers headers = new Headers.Builder()
-        .add("Content-Length", "0")
-        .addLenient("a\tb: c\u007fd")
-        .addLenient(": ef")
-        .addLenient("\ud83c\udf69: \u2615\ufe0f")
-        .build();
-    server.enqueue(new MockResponse().setHeaders(headers));
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.getResponseCode();
-    assertEquals("c\u007fd", connection.getHeaderField("a\tb"));
-    assertEquals("\u2615\ufe0f", connection.getHeaderField("\ud83c\udf69"));
-    assertEquals("ef", connection.getHeaderField(""));
-  }
-
-  @Test @Ignore public void deflateCompression() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void postBodiesRetransmittedOnIpAddressProblems() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void pooledConnectionProblemsNotReportedToProxySelector() {
-    fail("TODO");
-  }
-
-  @Test public void customBasicAuthenticator() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(new MockResponse().setBody("A"));
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential, null);
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(authenticator)
-        .build());
-    assertContent("A", urlFactory.open(server.url("/private").url()));
-
-    assertNull(server.takeRequest().getHeader("Authorization"));
-    assertEquals(credential, server.takeRequest().getHeader("Authorization"));
-
-    assertEquals(Proxy.NO_PROXY, authenticator.onlyRoute().proxy());
-    Response response = authenticator.onlyResponse();
-    assertEquals("/private", response.request().url().url().getPath());
-    assertEquals(Arrays.asList(new Challenge("Basic", "protected area")), response.challenges());
-  }
-
-  @Test public void customTokenAuthenticator() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(new MockResponse().setBody("A"));
-
-    RecordingOkAuthenticator authenticator
-        = new RecordingOkAuthenticator("oauthed abc123", "Bearer");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(authenticator)
-        .build());
-    assertContent("A", urlFactory.open(server.url("/private").url()));
-
-    assertNull(server.takeRequest().getHeader("Authorization"));
-    assertEquals("oauthed abc123", server.takeRequest().getHeader("Authorization"));
-
-    Response response = authenticator.onlyResponse();
-    assertEquals("/private", response.request().url().url().getPath());
-    assertEquals(Arrays.asList(new Challenge("Bearer", "oauthed")), response.challenges());
-  }
-
-  @Test public void authenticateCallsTrackedAsRedirects() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /b"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\""));
-    server.enqueue(new MockResponse().setBody("c"));
-
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
-        Credentials.basic("jesse", "peanutbutter"), "Basic");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(authenticator)
-        .build());
-    assertContent("c", urlFactory.open(server.url("/a").url()));
-
-    Response challengeResponse = authenticator.responses.get(0);
-    assertEquals("/b", challengeResponse.request().url().url().getPath());
-
-    Response redirectedBy = challengeResponse.priorResponse();
-    assertEquals("/a", redirectedBy.request().url().url().getPath());
-  }
-
-  @Test public void attemptAuthorization20Times() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse().setResponseCode(401));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build());
-
-    connection = urlFactory.open(server.url("/0").url());
-    assertContent("Success!", connection);
-  }
-
-  @Test public void doesNotAttemptAuthorization21Times() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse().setResponseCode(401));
-    }
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build());
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (ProtocolException expected) {
-      assertEquals(401, connection.getResponseCode());
-      assertEquals("Too many follow-up requests: 21", expected.getMessage());
-    }
-  }
-
-  @Test public void setsNegotiatedProtocolHeader_HTTP_2() throws Exception {
-    setsNegotiatedProtocolHeader(Protocol.HTTP_2);
-  }
-
-  private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException {
-    enableProtocol(protocol);
-    server.enqueue(new MockResponse().setBody("A"));
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    assertEquals(Arrays.asList(protocol.toString()), protocolValues);
-    assertContent("A", connection);
-  }
-
-  @Test public void http10SelectedProtocol() {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 OK"));
-    connection = urlFactory.open(server.url("/").url());
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    assertEquals(Arrays.asList("http/1.0"), protocolValues);
-  }
-
-  @Test public void http11SelectedProtocol() {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
-    connection = urlFactory.open(server.url("/").url());
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    assertEquals(Arrays.asList("http/1.1"), protocolValues);
-  }
-
-  /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
-  @Test public void zeroLengthPost() throws Exception {
-    zeroLengthPayload("POST");
-  }
-
-  @Test public void zeroLengthPost_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    zeroLengthPost();
-  }
-
-  /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
-  @Test public void zeroLengthPut() throws Exception {
-    zeroLengthPayload("PUT");
-  }
-
-  @Test public void zeroLengthPut_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    zeroLengthPut();
-  }
-
-  private void zeroLengthPayload(String method) throws Exception {
-    server.enqueue(new MockResponse());
-    connection = urlFactory.open(server.url("/").url());
-    connection.setRequestProperty("Content-Length", "0");
-    connection.setRequestMethod(method);
-    connection.setFixedLengthStreamingMode(0);
-    connection.setDoOutput(true);
-    assertContent("", connection);
-    RecordedRequest zeroLengthPayload = server.takeRequest();
-    assertEquals(method, zeroLengthPayload.getMethod());
-    assertEquals("0", zeroLengthPayload.getHeader("content-length"));
-    assertEquals(0L, zeroLengthPayload.getBodySize());
-  }
-
-  @Test public void unspecifiedRequestBodyContentTypeGetsDefault() throws Exception {
-    server.enqueue(new MockResponse());
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("abc".getBytes(UTF_8));
-    assertEquals(200, connection.getResponseCode());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("application/x-www-form-urlencoded", request.getHeader("Content-Type"));
-    assertEquals("3", request.getHeader("Content-Length"));
-    assertEquals("abc", request.getBody().readUtf8());
-  }
-
-  @Test public void setProtocols() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .protocols(Arrays.asList(Protocol.HTTP_1_1))
-        .build());
-    assertContent("A", urlFactory.open(server.url("/").url()));
-  }
-
-  @Test public void setProtocolsWithoutHttp11() {
-    try {
-      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_2));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setProtocolsWithNull() {
-    try {
-      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_1_1, null));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void veryLargeFixedLengthRequest() throws Exception {
-    server.setBodyLimit(0);
-    server.enqueue(new MockResponse());
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    long contentLength = Integer.MAX_VALUE + 1L;
-    connection.setFixedLengthStreamingMode(contentLength);
-    OutputStream out = connection.getOutputStream();
-    byte[] buffer = new byte[1024 * 1024];
-    for (long bytesWritten = 0; bytesWritten < contentLength; ) {
-      int byteCount = (int) Math.min(buffer.length, contentLength - bytesWritten);
-      out.write(buffer, 0, byteCount);
-      bytesWritten += byteCount;
-    }
-    assertContent("", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(Long.toString(contentLength), request.getHeader("Content-Length"));
-  }
-
-  @Test public void testNoSslFallback() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false /* tunnelProxy */);
-    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("Response that would have needed fallbacks"));
-
-    HttpsURLConnection connection = (HttpsURLConnection) server.url("/").url().openConnection();
-    connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (SSLProtocolException expected) {
-      // RI response to the FAIL_HANDSHAKE
-    } catch (SSLHandshakeException expected) {
-      // Android's response to the FAIL_HANDSHAKE
-    } catch (SSLException expected) {
-      // JDK 1.9 response to the FAIL_HANDSHAKE
-      // javax.net.ssl.SSLException: Unexpected handshake message: client_hello
-    } catch (SocketException expected) {
-      // Conscrypt's response to the FAIL_HANDSHAKE
-    }
-  }
-
-  /**
-   * We had a bug where we attempted to gunzip responses that didn't have a body. This only came up
-   * with 304s since that response code can include headers (like "Content-Encoding") without any
-   * content to go along with it. https://github.com/square/okhttp/issues/358
-   */
-  @Test public void noTransparentGzipFor304NotModified() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection1.getResponseCode());
-    assertContent("", connection1);
-
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertContent("b", connection2);
-
-    RecordedRequest requestA = server.takeRequest();
-    assertEquals(0, requestA.getSequenceNumber());
-
-    RecordedRequest requestB = server.takeRequest();
-    assertEquals(1, requestB.getSequenceNumber());
-  }
-
-  @Test public void nullSSLSocketFactory_throws() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false /* tunnelProxy */);
-    HttpsURLConnection connection = (HttpsURLConnection) server.url("/").url().openConnection();
-    try {
-      connection.setSSLSocketFactory(null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  /**
-   * We had a bug where we weren't closing Gzip streams on redirects.
-   * https://github.com/square/okhttp/issues/441
-   */
-  @Test public void gzipWithRedirectAndConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("Moved! Moved! Moved!")));
-    server.enqueue(new MockResponse().setBody("This is the new page!"));
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertContent("This is the new page!", connection);
-
-    RecordedRequest requestA = server.takeRequest();
-    assertEquals(0, requestA.getSequenceNumber());
-
-    RecordedRequest requestB = server.takeRequest();
-    assertEquals(1, requestB.getSequenceNumber());
-  }
-
-  /**
-   * The RFC is unclear in this regard as it only specifies that this should invalidate the cache
-   * entry (if any).
-   */
-  @Test public void bodyPermittedOnDelete() throws Exception {
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setRequestMethod("DELETE");
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("BODY".getBytes(UTF_8));
-    assertEquals(200, connection.getResponseCode());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("DELETE", request.getMethod());
-    assertEquals("BODY", request.getBody().readUtf8());
-  }
-
-  @Test public void userAgentPicksUpHttpAgentSystemProperty() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    System.setProperty("http.agent", "foo");
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("foo", request.getHeader("User-Agent"));
-  }
-
-  /** https://github.com/square/okhttp/issues/891 */
-  @Test public void userAgentSystemPropertyIsNotAscii() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    System.setProperty("http.agent", "a\nb\ud83c\udf69c\ud83c\udf68d\u007fe");
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("a?b?c?d?e", request.getHeader("User-Agent"));
-  }
-
-  @Test public void userAgentDefaultsToOkHttpVersion() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(Version.userAgent(), request.getHeader("User-Agent"));
-  }
-
-  @Test public void interceptorsNotInvoked() throws Exception {
-    Interceptor interceptor = chain -> { throw new AssertionError(); };
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .addInterceptor(interceptor)
-        .addNetworkInterceptor(interceptor)
-        .build());
-
-    server.enqueue(new MockResponse().setBody("abc"));
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-  }
-
-  @Test public void urlWithSpaceInHost() throws Exception {
-    URLConnection urlConnection = urlFactory.open(new URL("http://and roid.com/"));
-    try {
-      urlConnection.getInputStream();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void urlWithSpaceInHostViaHttpProxy() throws Exception {
-    server.enqueue(new MockResponse());
-    URLConnection urlConnection =
-        urlFactory.open(new URL("http://and roid.com/"), server.toProxyAddress());
-
-    try {
-      // This test is to check that a NullPointerException is not thrown.
-      urlConnection.getInputStream();
-      fail(); // the RI makes a bogus proxy request for "GET http://and roid.com/ HTTP/1.1"
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void urlHostWithNul() throws Exception {
-    URLConnection urlConnection = urlFactory.open(new URL("http://host\u0000/"));
-    try {
-      urlConnection.getInputStream();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void urlRedirectToHostWithNul() throws Exception {
-    String redirectUrl = "http://host\u0000/";
-    server.enqueue(new MockResponse().setResponseCode(302)
-        .addHeaderLenient("Location", redirectUrl));
-
-    HttpURLConnection urlConnection = urlFactory.open(server.url("/").url());
-    assertEquals(302, urlConnection.getResponseCode());
-    assertEquals(redirectUrl, urlConnection.getHeaderField("Location"));
-  }
-
-  @Test public void urlWithBadAsciiHost() throws Exception {
-    URLConnection urlConnection = urlFactory.open(new URL("http://host\u0001/"));
-    try {
-      urlConnection.getInputStream();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void instanceFollowsRedirects() throws Exception {
-    testInstanceFollowsRedirects("http://www.google.com/");
-    testInstanceFollowsRedirects("https://www.google.com/");
-  }
-
-  @Test public void setSslSocketFactoryFailsOnJdk9() {
-    assumeTrue(getPlatform().equals("jdk9"));
-
-    enableProtocol(Protocol.HTTP_2);
-    URL url = server.url("/").url();
-    HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(url);
-    try {
-      connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-
-  /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
-  @Test public void unexpectedExceptionSync() throws Exception {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(hostname -> { throw new RuntimeException("boom!"); })
-        .build());
-
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode(); // Use the synchronous implementation.
-      fail();
-    } catch (RuntimeException expected) {
-      assertEquals("boom!", expected.getMessage());
-    }
-  }
-
-  /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
-  @Test public void unexpectedExceptionAsync() throws Exception {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(hostname -> { throw new RuntimeException("boom!"); })
-        .build());
-
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.connect(); // Force the async implementation.
-      fail();
-    } catch (RuntimeException expected) {
-      assertEquals("boom!", expected.getMessage());
-    }
-  }
-
-  @Test public void callsNotManagedByDispatcher() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Dispatcher dispatcher = urlFactory.client().dispatcher();
-    assertEquals(0, dispatcher.runningCallsCount());
-
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(0, dispatcher.runningCallsCount());
-
-    connection.connect();
-    assertEquals(0, dispatcher.runningCallsCount());
-
-    assertContent("abc", connection);
-    assertEquals(0, dispatcher.runningCallsCount());
-  }
-
-  @Test public void streamedBodyIsRetriedOnHttp2Shutdown() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setBody("abc"));
-    server.enqueue(new MockResponse()
-        .setBody("def"));
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    connection1.setChunkedStreamingMode(4096);
-    connection1.setRequestMethod("POST");
-    connection1.connect(); // Establish healthy HTTP/2 connection, but don't write yet.
-
-    // Send a separate request which will trigger a GOAWAY frame on the healthy connection.
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertContent("abc", connection2);
-
-    // Ensure the GOAWAY frame has time to be read and processed.
-    Thread.sleep(500);
-
-    OutputStream os = connection1.getOutputStream();
-    os.write(new byte[] { '1', '2', '3' });
-    os.close();
-    assertContent("def", connection1);
-
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals(0, request1.getSequenceNumber());
-
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("123", request2.getBody().readUtf8());
-    assertEquals(0, request2.getSequenceNumber());
-  }
-
-  @Test public void authenticateNoConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Connection: close")
-        .setResponseCode(401)
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-
-    Authenticator.setDefault(new RecordingAuthenticator(null));
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(401, connection.getResponseCode());
-  }
-
-  private void testInstanceFollowsRedirects(String spec) throws Exception {
-    URL url = new URL(spec);
-    HttpURLConnection urlConnection = urlFactory.open(url);
-    urlConnection.setInstanceFollowRedirects(true);
-    assertTrue(urlConnection.getInstanceFollowRedirects());
-    urlConnection.setInstanceFollowRedirects(false);
-    assertFalse(urlConnection.getInstanceFollowRedirects());
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink gzipSink = Okio.buffer(new GzipSink(result));
-    gzipSink.writeUtf8(data);
-    gzipSink.close();
-    return result;
-  }
-
-  /**
-   * Reads at most {@code limit} characters from {@code in} and asserts that content equals {@code
-   * expected}.
-   */
-  private void assertContent(String expected, HttpURLConnection connection, int limit)
-      throws IOException {
-    connection.connect();
-    assertEquals(expected, readAscii(connection.getInputStream(), limit));
-  }
-
-  private void assertContent(String expected, HttpURLConnection connection) throws IOException {
-    assertContent(expected, connection, Integer.MAX_VALUE);
-  }
-
-  private Set<String> newSet(String... elements) {
-    return new LinkedHashSet<>(Arrays.asList(elements));
-  }
-
-  enum TransferKind {
-    CHUNKED {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setChunkedBody(content, chunkSize);
-      }
-
-      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
-        connection.setChunkedStreamingMode(5);
-      }
-    },
-    FIXED_LENGTH {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-      }
-
-      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
-        connection.setFixedLengthStreamingMode(contentLength);
-      }
-    },
-    END_OF_STREAM {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(DISCONNECT_AT_END);
-        response.removeHeader("Content-Length");
-      }
-
-      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
-      }
-    };
-
-    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
-
-    abstract void setForRequest(HttpURLConnection connection, int contentLength);
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, new Buffer().writeUtf8(content), chunkSize);
-    }
-  }
-
-  enum ProxyConfig {
-    NO_PROXY() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
-        streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
-            .proxy(Proxy.NO_PROXY)
-            .build());
-        return streamHandlerFactory.open(url);
-      }
-    },
-
-    CREATE_ARG() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
-        streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
-            .proxy(server.toProxyAddress())
-            .build());
-        return streamHandlerFactory.open(url);
-      }
-    },
-
-    PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
-        System.setProperty("proxyHost", server.getHostName());
-        System.setProperty("proxyPort", Integer.toString(server.getPort()));
-        return streamHandlerFactory.open(url);
-      }
-    },
-
-    HTTP_PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
-        System.setProperty("http.proxyHost", server.getHostName());
-        System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
-        return streamHandlerFactory.open(url);
-      }
-    },
-
-    HTTPS_PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
-        System.setProperty("https.proxyHost", server.getHostName());
-        System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
-        return streamHandlerFactory.open(url);
-      }
-    };
-
-    public abstract HttpURLConnection connect(
-        MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-        throws IOException;
-  }
-
-  private static class RecordingTrustManager implements X509TrustManager {
-    private final List<String> calls = new ArrayList<>();
-    private final X509TrustManager delegate;
-
-    RecordingTrustManager(X509TrustManager delegate) {
-      this.delegate = delegate;
-    }
-
-    public X509Certificate[] getAcceptedIssuers() {
-      return delegate.getAcceptedIssuers();
-    }
-
-    public void checkClientTrusted(X509Certificate[] chain, String authType) {
-      calls.add("checkClientTrusted " + certificatesToString(chain));
-    }
-
-    public void checkServerTrusted(X509Certificate[] chain, String authType) {
-      calls.add("checkServerTrusted " + certificatesToString(chain));
-    }
-
-    private String certificatesToString(X509Certificate[] certificates) {
-      List<String> result = new ArrayList<>();
-      for (X509Certificate certificate : certificates) {
-        result.add(certificate.getSubjectDN() + " " + certificate.getSerialNumber());
-      }
-      return result.toString();
-    }
-  }
-
-  /**
-   * Tests that use this will fail unless boot classpath is set. Ex. {@code
-   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
-   */
-  private void enableProtocol(Protocol protocol) {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
-        .build());
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.setProtocolNegotiationEnabled(true);
-    server.setProtocols(urlFactory.client().protocols());
-  }
-
-  /**
-   * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
-   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
-   * for details.
-   */
-  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(handshakeCertificates.sslSocketFactory());
-  }
-
-  private String getPlatform() {
-    return System.getProperty("okhttp.platform", "platform");
-  }
-}
diff --git a/okhttp-tls/Module.md b/okhttp-tls/Module.md
new file mode 100644
index 0000000000..b97773f31b
--- /dev/null
+++ b/okhttp-tls/Module.md
@@ -0,0 +1,3 @@
+# Module okhttp-tls
+
+OkHttp Transport Layer Security (TLS) library.
diff --git a/okhttp-tls/build.gradle b/okhttp-tls/build.gradle
new file mode 100644
index 0000000000..3ea56bc9ee
--- /dev/null
+++ b/okhttp-tls/build.gradle
@@ -0,0 +1,63 @@
+apply plugin: 'com.vanniktech.maven.publish'
+apply plugin: 'me.champeau.gradle.japicmp'
+
+jar {
+  manifest {
+    attributes('Automatic-Module-Name': 'okhttp3.tls')
+  }
+}
+
+dependencies {
+  api deps.okio
+  implementation project(':okhttp')
+  implementation deps.bouncycastle
+  compileOnly deps.jsr305
+
+  testImplementation project(':okhttp-testing-support')
+  testImplementation deps.junit
+  testImplementation deps.assertj
+}
+
+task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
+  oldClasspath = files(baselineJar(project, baselineVersion))
+  newClasspath = files(jar.archivePath)
+  onlyBinaryIncompatibleModified = true
+  failOnModification = true
+  txtOutputFile = file("$buildDir/reports/japi.txt")
+  ignoreMissingClasses = true
+  includeSynthetic = true
+  packageExcludes = [
+      'okhttp3.tls.internal',
+  ]
+  methodExcludes = [
+      // Became 'final' in 4.0.0:
+      'okhttp3.tls.HandshakeCertificates#keyManager()',
+      'okhttp3.tls.HandshakeCertificates#sslContext()',
+      'okhttp3.tls.HandshakeCertificates#sslSocketFactory()',
+      'okhttp3.tls.HandshakeCertificates#trustManager()',
+      'okhttp3.tls.HandshakeCertificates$Builder#addPlatformTrustedCertificates()',
+      'okhttp3.tls.HandshakeCertificates$Builder#addTrustedCertificate(java.security.cert.X509Certificate)',
+      'okhttp3.tls.HandshakeCertificates$Builder#build()',
+      'okhttp3.tls.HandshakeCertificates$Builder#heldCertificate(okhttp3.tls.HeldCertificate, java.security.cert.X509Certificate\\[\\])',
+      'okhttp3.tls.HeldCertificate#certificate()',
+      'okhttp3.tls.HeldCertificate#certificatePem()',
+      'okhttp3.tls.HeldCertificate#keyPair()',
+      'okhttp3.tls.HeldCertificate#privateKeyPkcs1Pem()',
+      'okhttp3.tls.HeldCertificate#privateKeyPkcs8Pem()',
+      'okhttp3.tls.HeldCertificate$Builder#addSubjectAlternativeName(java.lang.String)',
+      'okhttp3.tls.HeldCertificate$Builder#build()',
+      'okhttp3.tls.HeldCertificate$Builder#certificateAuthority(int)',
+      'okhttp3.tls.HeldCertificate$Builder#commonName(java.lang.String)',
+      'okhttp3.tls.HeldCertificate$Builder#duration(long, java.util.concurrent.TimeUnit)',
+      'okhttp3.tls.HeldCertificate$Builder#ecdsa256()',
+      'okhttp3.tls.HeldCertificate$Builder#keyPair(java.security.KeyPair)',
+      'okhttp3.tls.HeldCertificate$Builder#keyPair(java.security.PublicKey, java.security.PrivateKey)',
+      'okhttp3.tls.HeldCertificate$Builder#organizationalUnit(java.lang.String)',
+      'okhttp3.tls.HeldCertificate$Builder#rsa2048()',
+      'okhttp3.tls.HeldCertificate$Builder#serialNumber(java.math.BigInteger)',
+      'okhttp3.tls.HeldCertificate$Builder#serialNumber(long)',
+      'okhttp3.tls.HeldCertificate$Builder#signedBy(okhttp3.tls.HeldCertificate)',
+      'okhttp3.tls.HeldCertificate$Builder#validityInterval(long, long)',
+  ]
+}
+check.dependsOn(japicmp)
diff --git a/okhttp-tls/gradle.properties b/okhttp-tls/gradle.properties
new file mode 100644
index 0000000000..7ed0a3b63a
--- /dev/null
+++ b/okhttp-tls/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=okhttp-tls
+POM_NAME=okhttp-tls
+POM_PACKAGING=jar
diff --git a/okhttp-tls/pom.xml b/okhttp-tls/pom.xml
deleted file mode 100644
index 0c7d643913..0000000000
--- a/okhttp-tls/pom.xml
+++ /dev/null
@@ -1,71 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-tls</artifactId>
-  <name>OkHttp Transport Layer Security (TLS)</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.bouncycastle</groupId>
-      <artifactId>bcprov-jdk15on</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>3.0.1</version>
-        <configuration>
-          <excludePackageNames>okhttp3.tls.internal:okhttp3.tls.internal.*</excludePackageNames>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.tls</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java
deleted file mode 100644
index 34e9e9a497..0000000000
--- a/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.tls;
-
-import java.security.GeneralSecurityException;
-import java.security.KeyManagementException;
-import java.security.SecureRandom;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509KeyManager;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.CertificatePinner;
-import okhttp3.internal.Util;
-import okhttp3.internal.platform.Platform;
-
-import static okhttp3.tls.internal.TlsUtil.newKeyManager;
-import static okhttp3.tls.internal.TlsUtil.newTrustManager;
-
-/**
- * Certificates to identify which peers to trust and also to earn the trust of those peers in kind.
- * Client and server exchange these certificates during the handshake phase of a TLS connection.
- *
- * <h3>Server Authentication</h3>
- *
- * <p>This is the most common form of TLS authentication: clients verify that servers are trusted
- * and that they own the hostnames that they represent. Server authentication is required.
- *
- * <p>To perform server authentication:
- *
- * <ul>
- *   <li>The server's handshake certificates must have a {@linkplain HeldCertificate held
- *       certificate} (a certificate and its private key). The certificate's subject alternative
- *       names must match the server's hostname. The server must also have is a (possibly-empty)
- *       chain of intermediate certificates to establish trust from a root certificate to the
- *       server's certificate. The root certificate is not included in this chain.
- *   <li>The client's handshake certificates must include a set of trusted root certificates. They
- *       will be used to authenticate the server's certificate chain. Typically this is a set of
- *       well-known root certificates that is distributed with the HTTP client or its platform. It
- *       may be augmented by certificates private to an organization or service.
- * </ul>
- *
- * <h3>Client Authentication</h3>
- *
- * <p>This is authentication of the client by the server during the TLS handshake. Client
- * authentication is optional.
- *
- * <p>To perform client authentication:
- *
- * <ul>
- *   <li>The client's handshake certificates must have a {@linkplain HeldCertificate held
- *       certificate} (a certificate and its private key). The client must also have a
- *       (possibly-empty) chain of intermediate certificates to establish trust from a root
- *       certificate to the client's certificate. The root certificate is not included in this
- *       chain.
- *   <li>The server's handshake certificates must include a set of trusted root certificates. They
- *       will be used to authenticate the client's certificate chain. Typically this is not the same
- *       set of root certificates used in server authentication. Instead it will be a small set of
- *       roots private to an organization or service.
- * </ul>
- */
-public final class HandshakeCertificates {
-  private final X509KeyManager keyManager;
-  private final X509TrustManager trustManager;
-
-  private HandshakeCertificates(X509KeyManager keyManager, X509TrustManager trustManager) {
-    this.keyManager = keyManager;
-    this.trustManager = trustManager;
-  }
-
-  public X509KeyManager keyManager() {
-    return keyManager;
-  }
-
-  public X509TrustManager trustManager() {
-    return trustManager;
-  }
-
-  public SSLSocketFactory sslSocketFactory() {
-    return sslContext().getSocketFactory();
-  }
-
-  public SSLContext sslContext() {
-    try {
-      SSLContext sslContext = Platform.get().getSSLContext();
-      sslContext.init(new KeyManager[] { keyManager }, new TrustManager[] { trustManager },
-          new SecureRandom());
-      return sslContext;
-    } catch (KeyManagementException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  public static final class Builder {
-    private @Nullable HeldCertificate heldCertificate;
-    private @Nullable X509Certificate[] intermediates;
-
-    private final List<X509Certificate> trustedCertificates = new ArrayList<>();
-
-    /**
-     * Configure the certificate chain to use when being authenticated. The first certificate is
-     * the held certificate, further certificates are included in the handshake so the peer can
-     * build a trusted path to a trusted root certificate.
-     *
-     * <p>The chain should include all intermediate certificates but does not need the root
-     * certificate that we expect to be known by the remote peer. The peer already has that
-     * certificate so transmitting it is unnecessary.
-     */
-    public Builder heldCertificate(HeldCertificate heldCertificate,
-        X509Certificate... intermediates) {
-      this.heldCertificate = heldCertificate;
-      this.intermediates = intermediates.clone(); // Defensive copy.
-      return this;
-    }
-
-    /**
-     * Add a trusted root certificate to use when authenticating a peer. Peers must provide
-     * a chain of certificates whose root is one of these.
-     */
-    public Builder addTrustedCertificate(X509Certificate certificate) {
-      this.trustedCertificates.add(certificate);
-      return this;
-    }
-
-    /**
-     * Add all of the host platform's trusted root certificates. This set varies by platform
-     * (Android vs. Java), by platform release (Android 4.4 vs. Android 9), and with user
-     * customizations.
-     *
-     * <p>Most TLS clients that connect to hosts on the public Internet should call this method.
-     * Otherwise it is necessary to manually prepare a comprehensive set of trusted roots.
-     *
-     * <p>If the host platform is compromised or misconfigured this may contain untrustworthy root
-     * certificates. Applications that connect to a known set of servers may be able to mitigate
-     * this problem with {@linkplain CertificatePinner certificate pinning}.
-     */
-    public Builder addPlatformTrustedCertificates() {
-      X509TrustManager platformTrustManager = Util.platformTrustManager();
-      Collections.addAll(trustedCertificates, platformTrustManager.getAcceptedIssuers());
-      return this;
-    }
-
-    public HandshakeCertificates build() {
-      try {
-        X509KeyManager keyManager = newKeyManager(null, heldCertificate, intermediates);
-        X509TrustManager trustManager = newTrustManager(null, trustedCertificates);
-        return new HandshakeCertificates(keyManager, trustManager);
-      } catch (GeneralSecurityException gse) {
-        throw new AssertionError(gse);
-      }
-    }
-  }
-}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.kt b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.kt
new file mode 100644
index 0000000000..a21f35a0c4
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.kt
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls
+
+import okhttp3.CertificatePinner
+import okhttp3.internal.Util
+import okhttp3.internal.platform.Platform
+import okhttp3.tls.internal.TlsUtil.newKeyManager
+import okhttp3.tls.internal.TlsUtil.newTrustManager
+import java.security.SecureRandom
+import java.security.cert.X509Certificate
+import java.util.Collections
+import javax.net.ssl.KeyManager
+import javax.net.ssl.SSLContext
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.TrustManager
+import javax.net.ssl.X509KeyManager
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Certificates to identify which peers to trust and also to earn the trust of those peers in kind.
+ * Client and server exchange these certificates during the handshake phase of a TLS connection.
+ *
+ * ### Server Authentication
+ *
+ * This is the most common form of TLS authentication: clients verify that servers are trusted and
+ * that they own the hostnames that they represent. Server authentication is required.
+ *
+ * To perform server authentication:
+ *
+ *  * The server's handshake certificates must have a [held certificate][HeldCertificate] (a
+ *    certificate and its private key). The certificate's subject alternative names must match the
+ *    server's hostname. The server must also have is a (possibly-empty) chain of intermediate
+ *    certificates to establish trust from a root certificate to the server's certificate. The root
+ *    certificate is not included in this chain.
+ *  * The client's handshake certificates must include a set of trusted root certificates. They will
+ *    be used to authenticate the server's certificate chain. Typically this is a set of well-known
+ *    root certificates that is distributed with the HTTP client or its platform. It may be
+ *    augmented by certificates private to an organization or service.
+ *
+ * ### Client Authentication
+ *
+ * This is authentication of the client by the server during the TLS handshake. Client
+ * authentication is optional.
+ *
+ * To perform client authentication:
+ *
+ *  * The client's handshake certificates must have a [held certificate][HeldCertificate] (a
+ *    certificate and its private key). The client must also have a (possibly-empty) chain of
+ *    intermediate certificates to establish trust from a root certificate to the client's
+ *    certificate. The root certificate is not included in this chain.
+ *  * The server's handshake certificates must include a set of trusted root certificates. They
+ *    will be used to authenticate the client's certificate chain. Typically this is not the same
+ *    set of root certificates used in server authentication. Instead it will be a small set of
+ *    roots private to an organization or service.
+ */
+class HandshakeCertificates private constructor(
+  private val keyManager: X509KeyManager,
+  private val trustManager: X509TrustManager
+) {
+  fun keyManager(): X509KeyManager = keyManager
+
+  fun trustManager(): X509TrustManager = trustManager
+
+  fun sslSocketFactory(): SSLSocketFactory = sslContext().socketFactory
+
+  fun sslContext(): SSLContext {
+    return Platform.get().newSSLContext().apply {
+      init(arrayOf<KeyManager>(keyManager), arrayOf<TrustManager>(trustManager), SecureRandom())
+    }
+  }
+
+  class Builder {
+    private var heldCertificate: HeldCertificate? = null
+    private var intermediates: Array<X509Certificate>? = null
+    private val trustedCertificates = mutableListOf<X509Certificate>()
+
+    /**
+     * Configure the certificate chain to use when being authenticated. The first certificate is
+     * the held certificate, further certificates are included in the handshake so the peer can
+     * build a trusted path to a trusted root certificate.
+     *
+     * The chain should include all intermediate certificates but does not need the root certificate
+     * that we expect to be known by the remote peer. The peer already has that certificate so
+     * transmitting it is unnecessary.
+     */
+    fun heldCertificate(
+      heldCertificate: HeldCertificate,
+      vararg intermediates: X509Certificate
+    ) = apply {
+      this.heldCertificate = heldCertificate
+      this.intermediates = arrayOf(*intermediates) // Defensive copy.
+    }
+
+    /**
+     * Add a trusted root certificate to use when authenticating a peer. Peers must provide
+     * a chain of certificates whose root is one of these.
+     */
+    fun addTrustedCertificate(certificate: X509Certificate) = apply {
+      this.trustedCertificates += certificate
+    }
+
+    /**
+     * Add all of the host platform's trusted root certificates. This set varies by platform
+     * (Android vs. Java), by platform release (Android 4.4 vs. Android 9), and with user
+     * customizations.
+     *
+     * Most TLS clients that connect to hosts on the public Internet should call this method.
+     * Otherwise it is necessary to manually prepare a comprehensive set of trusted roots.
+     *
+     * If the host platform is compromised or misconfigured this may contain untrustworthy root
+     * certificates. Applications that connect to a known set of servers may be able to mitigate
+     * this problem with [certificate pinning][CertificatePinner].
+     */
+    fun addPlatformTrustedCertificates() = apply {
+      val platformTrustManager = Util.platformTrustManager()
+      Collections.addAll(trustedCertificates, *platformTrustManager.acceptedIssuers)
+    }
+
+    fun build(): HandshakeCertificates {
+      val keyManager = newKeyManager(null, heldCertificate, *(intermediates ?: emptyArray()))
+      val trustManager = newTrustManager(null, trustedCertificates)
+      return HandshakeCertificates(keyManager, trustManager)
+    }
+  }
+}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java
deleted file mode 100644
index c659f58196..0000000000
--- a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java
+++ /dev/null
@@ -1,433 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.tls;
-
-import java.io.IOException;
-import java.math.BigInteger;
-import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.KeyPairGenerator;
-import java.security.PrivateKey;
-import java.security.PublicKey;
-import java.security.SecureRandom;
-import java.security.Security;
-import java.security.cert.CertificateEncodingException;
-import java.security.cert.X509Certificate;
-import java.security.interfaces.RSAPrivateKey;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-import java.util.UUID;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import javax.security.auth.x500.X500Principal;
-import okio.ByteString;
-import org.bouncycastle.asn1.ASN1Encodable;
-import org.bouncycastle.asn1.DERSequence;
-import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
-import org.bouncycastle.asn1.x509.BasicConstraints;
-import org.bouncycastle.asn1.x509.GeneralName;
-import org.bouncycastle.asn1.x509.X509Extensions;
-import org.bouncycastle.jce.provider.BouncyCastleProvider;
-import org.bouncycastle.x509.X509V3CertificateGenerator;
-
-import static okhttp3.internal.Util.verifyAsIpAddress;
-
-/**
- * A certificate and its private key. These are some properties of certificates that are used with
- * TLS:
- *
- * <ul>
- *   <li><strong>A common name.</strong> This is a string identifier for the certificate. It usually
- *       describes the purpose of the certificate like "Entrust Root Certification Authority - G2"
- *       or "www.squareup.com".
- *   <li><strong>A set of hostnames.</strong> These are in the certificate's subject alternative
- *       name (SAN) extension. A subject alternative name is either a literal hostname ({@code
- *       squareup.com}), a literal IP address ({@code 74.122.190.80}), or a hostname pattern ({@code
- *       *.api.squareup.com}).
- *   <li><strong>A validity interval.</strong> A certificate should not be used before its validity
- *       interval starts or after it ends.
- *   <li><strong>A public key.</strong> This cryptographic key is used for asymmetric encryption
- *       digital signatures. Note that the private key is not a part of the certificate!
- *   <li><strong>A signature issued by another certificate's private key.</strong> This mechanism
- *       allows a trusted third-party to endorse a certificate. Third parties should only endorse
- *       certificates once they've confirmed that the owner of the private key is also the owner of
- *       the certificate's other properties.
- * </ul>
- *
- * <p>Certificates are signed by other certificates and a sequence of them is called a certificate
- * chain. The chain terminates in a self-signed "root" certificate. Signing certificates in the
- * middle of the chain are called "intermediates". Organizations that offer certificate signing are
- * called certificate authorities (CAs).
- *
- * <p>Browsers and other HTTP clients need a set of trusted root certificates to authenticate their
- * peers. Sets of root certificates are managed by either the HTTP client (like Firefox), or the
- * host platform (like Android). In July 2018 Android had 134 trusted root certificates for its HTTP
- * clients to trust.
- *
- * <p>For example, in order to establish a secure connection to {@code https://www.squareup.com/},
- * these three certificates are used. <pre>{@code
- *
- * www.squareup.com certificate:
- *
- *   Common Name: www.squareup.com
- *   Subject Alternative Names: www.squareup.com, squareup.com, account.squareup.com...
- *   Validity: 2018-07-03T20:18:17Z  2019-08-01T20:48:15Z
- *   Public Key: d107beecc17325f55da976bcbab207ba4df68bd3f8fce7c3b5850311128264fd53e1baa342f58d93...
- *   Signature: 1fb0e66fac05322721fe3a3917f7c98dee1729af39c99eab415f22d8347b508acdf0bab91781c3720...
- *
- * signed by intermediate certificate:
- *
- *   Common Name: Entrust Certification Authority - L1M
- *   Subject Alternative Names: none
- *   Validity: 2014-12-15T15:25:03Z  2030-10-15T15:55:03Z
- *   Public Key: d081c13923c2b1d1ecf757dd55243691202248f7fcca520ab0ab3f33b5b08407f6df4e7ab0fb9822...
- *   Signature: b487c784221a29c0a478ecf54f1bb484976f77eed4cf59afa843962f1d58dea6f3155b2ed9439c4c4...
- *
- * signed by root certificate:
- *
- *   Common Name: Entrust Root Certification Authority - G2
- *   Subject Alternative Names: none
- *   Validity: 2009-07-07T17:25:54Z  2030-12-07T17:55:54Z
- *   Public Key: ba84b672db9e0c6be299e93001a776ea32b895411ac9da614e5872cffef68279bf7361060aa527d8...
- *   Self-signed Signature: 799f1d96c6b6793f228d87d3870304606a6b9a2e59897311ac43d1f513ff8d392bc0f...
- *
- * }</pre>
- *
- * <p>In this example the HTTP client already knows and trusts the last certificate, "Entrust Root
- * Certification Authority - G2". That certificate is used to verify the signature of the
- * intermediate certificate, "Entrust Certification Authority - L1M". The intermediate certificate
- * is used to verify the signature of the "www.squareup.com" certificate.
- *
- * <p>This roles are reversed for client authentication. In that case the client has a private key
- * and a chain of certificates. The server uses a set of trusted root certificates to authenticate
- * the client. Subject alternative names are not used for client authentication.
- */
-public final class HeldCertificate {
-  private final X509Certificate certificate;
-  private final KeyPair keyPair;
-
-  public HeldCertificate(KeyPair keyPair, X509Certificate certificate) {
-    if (keyPair == null) throw new NullPointerException("keyPair == null");
-    if (certificate == null) throw new NullPointerException("certificate == null");
-    this.certificate = certificate;
-    this.keyPair = keyPair;
-  }
-
-  public X509Certificate certificate() {
-    return certificate;
-  }
-
-  public KeyPair keyPair() {
-    return keyPair;
-  }
-
-  /**
-   * Returns the certificate encoded in <a href="https://tools.ietf.org/html/rfc7468">PEM
-   * format</a>.
-   */
-  public String certificatePem() {
-    try {
-      StringBuilder result = new StringBuilder();
-      result.append("-----BEGIN CERTIFICATE-----\n");
-      encodeBase64Lines(result, ByteString.of(certificate.getEncoded()));
-      result.append("-----END CERTIFICATE-----\n");
-      return result.toString();
-    } catch (CertificateEncodingException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  /**
-   * Returns the RSA private key encoded in <a href="https://tools.ietf.org/html/rfc5208">PKCS
-   * #8</a> <a href="https://tools.ietf.org/html/rfc7468">PEM format</a>.
-   */
-  public String privateKeyPkcs8Pem() {
-    StringBuilder result = new StringBuilder();
-    result.append("-----BEGIN PRIVATE KEY-----\n");
-    encodeBase64Lines(result, ByteString.of(keyPair.getPrivate().getEncoded()));
-    result.append("-----END PRIVATE KEY-----\n");
-    return result.toString();
-  }
-
-  /**
-   * Returns the RSA private key encoded in <a href="https://tools.ietf.org/html/rfc8017">PKCS
-   * #1</a> <a href="https://tools.ietf.org/html/rfc7468">PEM format</a>.
-   */
-  public String privateKeyPkcs1Pem() {
-    if (!(keyPair.getPrivate() instanceof RSAPrivateKey)) {
-      throw new IllegalStateException("PKCS1 only supports RSA keys");
-    }
-    StringBuilder result = new StringBuilder();
-    result.append("-----BEGIN RSA PRIVATE KEY-----\n");
-    encodeBase64Lines(result, pkcs1Bytes());
-    result.append("-----END RSA PRIVATE KEY-----\n");
-    return result.toString();
-  }
-
-  private ByteString pkcs1Bytes() {
-    try {
-      PrivateKeyInfo privateKeyInfo = PrivateKeyInfo.getInstance(keyPair.getPrivate().getEncoded());
-      return ByteString.of(privateKeyInfo.parsePrivateKey().toASN1Primitive().getEncoded());
-    } catch (IOException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  private void encodeBase64Lines(StringBuilder out, ByteString data) {
-    String base64 = data.base64();
-    for (int i = 0; i < base64.length(); i += 64) {
-      out.append(base64, i, Math.min(i + 64, base64.length())).append('\n');
-    }
-  }
-
-  /** Build a held certificate with reasonable defaults. */
-  public static final class Builder {
-    private static final long DEFAULT_DURATION_MILLIS = 1000L * 60 * 60 * 24; // 24 hours.
-
-    static {
-      Security.addProvider(new BouncyCastleProvider());
-    }
-
-    private long notBefore = -1L;
-    private long notAfter = -1L;
-    private @Nullable String cn;
-    private @Nullable String ou;
-    private final List<String> altNames = new ArrayList<>();
-    private @Nullable BigInteger serialNumber;
-    private @Nullable KeyPair keyPair;
-    private @Nullable HeldCertificate signedBy;
-    private int maxIntermediateCas = -1;
-    private @Nullable String keyAlgorithm;
-    private int keySize;
-
-    public Builder() {
-      ecdsa256();
-    }
-
-    /**
-     * Sets the certificate to be valid in {@code [notBefore..notAfter]}. Both endpoints are
-     * specified in the format of {@link System#currentTimeMillis()}. Specify -1L for both values
-     * to use the default interval, 24 hours starting when the certificate is created.
-     */
-    public Builder validityInterval(long notBefore, long notAfter) {
-      if (notBefore > notAfter || (notBefore == -1L) != (notAfter == -1L)) {
-        throw new IllegalArgumentException("invalid interval: " + notBefore + ".." + notAfter);
-      }
-      this.notBefore = notBefore;
-      this.notAfter = notAfter;
-      return this;
-    }
-
-    /**
-     * Sets the certificate to be valid immediately and until the specified duration has elapsed.
-     * The precision of this field is seconds; further precision will be truncated.
-     */
-    public Builder duration(long duration, TimeUnit unit) {
-      long now = System.currentTimeMillis();
-      return validityInterval(now, now + unit.toMillis(duration));
-    }
-
-    /**
-     * Adds a subject alternative name (SAN) to the certificate. This is usually a literal hostname,
-     * a literal IP address, or a hostname pattern. If no subject alternative names are added that
-     * extension will be omitted.
-     */
-    public Builder addSubjectAlternativeName(String altName) {
-      if (altName == null) throw new NullPointerException("altName == null");
-      altNames.add(altName);
-      return this;
-    }
-
-    /**
-     * Set this certificate's common name (CN). Historically this held the hostname of TLS
-     * certificate, but that practice was deprecated by <a
-     * href="https://tools.ietf.org/html/rfc2818">RFC 2818</a> and replaced with {@link
-     * #addSubjectAlternativeName(String) subject alternative names}. If unset a random string will
-     * be used.
-     */
-    public Builder commonName(String cn) {
-      this.cn = cn;
-      return this;
-    }
-
-    /** Sets the certificate's organizational unit (OU). If unset this field will be omitted. */
-    public Builder organizationalUnit(String ou) {
-      this.ou = ou;
-      return this;
-    }
-
-    /** Sets this certificate's serial number. If unset the serial number will be 1. */
-    public Builder serialNumber(BigInteger serialNumber) {
-      this.serialNumber = serialNumber;
-      return this;
-    }
-
-    /** Sets this certificate's serial number. If unset the serial number will be 1. */
-    public Builder serialNumber(long serialNumber) {
-      return serialNumber(BigInteger.valueOf(serialNumber));
-    }
-
-    /**
-     * Sets the public/private key pair used for this certificate. If unset a key pair will be
-     * generated.
-     */
-    public Builder keyPair(KeyPair keyPair) {
-      this.keyPair = keyPair;
-      return this;
-    }
-
-    /**
-     * Sets the public/private key pair used for this certificate. If unset a key pair will be
-     * generated.
-     */
-    public Builder keyPair(PublicKey publicKey, PrivateKey privateKey) {
-      return keyPair(new KeyPair(publicKey, privateKey));
-    }
-
-    /**
-     * Set the certificate that will issue this certificate. If unset the certificate will be
-     * self-signed.
-     */
-    public Builder signedBy(HeldCertificate signedBy) {
-      this.signedBy = signedBy;
-      return this;
-    }
-
-    /**
-     * Set this certificate to be a signing certificate, with up to {@code maxIntermediateCas}
-     * intermediate signing certificates beneath it.
-     *
-     * <p>By default this certificate cannot not sign other certificates. Set this to 0 so this
-     * certificate can sign other certificates (but those certificates cannot themselves sign
-     * certificates). Set this to 1 so this certificate can sign intermediate certificates that can
-     * themselves sign certificates. Add one for each additional layer of intermediates to permit.
-     */
-    public Builder certificateAuthority(int maxIntermediateCas) {
-      if (maxIntermediateCas < 0) {
-        throw new IllegalArgumentException("maxIntermediateCas < 0: " + maxIntermediateCas);
-      }
-      this.maxIntermediateCas = maxIntermediateCas;
-      return this;
-    }
-
-    /**
-     * Configure the certificate to generate a 256-bit ECDSA key, which provides about 128 bits of
-     * security. ECDSA keys are noticeably faster than RSA keys.
-     *
-     * <p>This is the default configuration and has been since this API was introduced in OkHttp
-     * 3.11.0. Note that the default may change in future releases.
-     */
-    public Builder ecdsa256() {
-      keyAlgorithm = "EC";
-      keySize = 256;
-      return this;
-    }
-
-    /**
-     * Configure the certificate to generate a 2048-bit RSA key, which provides about 112 bits of
-     * security. RSA keys are interoperable with very old clients that don't support ECDSA.
-     */
-    public Builder rsa2048() {
-      keyAlgorithm = "RSA";
-      keySize = 2048;
-      return this;
-    }
-
-    public HeldCertificate build() {
-      // Subject, public & private keys for this certificate.
-      KeyPair heldKeyPair = keyPair != null
-          ? keyPair
-          : generateKeyPair();
-
-      X500Principal subject = buildSubject();
-
-      // Subject, public & private keys for this certificate's signer. It may be self signed!
-      KeyPair signedByKeyPair;
-      X500Principal signedByPrincipal;
-      if (signedBy != null) {
-        signedByKeyPair = signedBy.keyPair;
-        signedByPrincipal = signedBy.certificate.getSubjectX500Principal();
-      } else {
-        signedByKeyPair = heldKeyPair;
-        signedByPrincipal = subject;
-      }
-
-      // Generate & sign the certificate.
-      long notBefore = this.notBefore != -1L ? this.notBefore : System.currentTimeMillis();
-      long notAfter = this.notAfter != -1L ? this.notAfter : notBefore + DEFAULT_DURATION_MILLIS;
-      BigInteger serialNumber = this.serialNumber != null ? this.serialNumber : BigInteger.ONE;
-      X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
-      generator.setSerialNumber(serialNumber);
-      generator.setIssuerDN(signedByPrincipal);
-      generator.setNotBefore(new Date(notBefore));
-      generator.setNotAfter(new Date(notAfter));
-      generator.setSubjectDN(subject);
-      generator.setPublicKey(heldKeyPair.getPublic());
-      generator.setSignatureAlgorithm(signedByKeyPair.getPrivate() instanceof RSAPrivateKey
-          ? "SHA256WithRSAEncryption"
-          : "SHA256withECDSA");
-
-      if (maxIntermediateCas != -1) {
-        generator.addExtension(X509Extensions.BasicConstraints, true,
-            new BasicConstraints(maxIntermediateCas));
-      }
-
-      if (!altNames.isEmpty()) {
-        ASN1Encodable[] encodableAltNames = new ASN1Encodable[altNames.size()];
-        for (int i = 0, size = altNames.size(); i < size; i++) {
-          String altName = altNames.get(i);
-          int tag = verifyAsIpAddress(altName)
-              ? GeneralName.iPAddress
-              : GeneralName.dNSName;
-          encodableAltNames[i] = new GeneralName(tag, altName);
-        }
-        generator.addExtension(X509Extensions.SubjectAlternativeName, true,
-            new DERSequence(encodableAltNames));
-      }
-
-      try {
-        X509Certificate certificate = generator.generate(signedByKeyPair.getPrivate());
-        return new HeldCertificate(heldKeyPair, certificate);
-      } catch (GeneralSecurityException e) {
-        throw new AssertionError(e);
-      }
-    }
-
-    private X500Principal buildSubject() {
-      StringBuilder nameBuilder = new StringBuilder();
-      if (cn != null) {
-        nameBuilder.append("CN=").append(cn);
-      } else {
-        nameBuilder.append("CN=").append(UUID.randomUUID());
-      }
-      if (ou != null) {
-        nameBuilder.append(", OU=").append(ou);
-      }
-      return new X500Principal(nameBuilder.toString());
-    }
-
-    private KeyPair generateKeyPair() {
-      try {
-        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyAlgorithm);
-        keyPairGenerator.initialize(keySize, new SecureRandom());
-        return keyPairGenerator.generateKeyPair();
-      } catch (GeneralSecurityException e) {
-        throw new AssertionError(e);
-      }
-    }
-  }
-}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.kt b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.kt
new file mode 100644
index 0000000000..2e9f5deb7c
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.kt
@@ -0,0 +1,407 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls
+
+import okhttp3.internal.Util.verifyAsIpAddress
+import okio.ByteString
+import org.bouncycastle.asn1.ASN1Encodable
+import org.bouncycastle.asn1.DERSequence
+import org.bouncycastle.asn1.pkcs.PrivateKeyInfo
+import org.bouncycastle.asn1.x509.BasicConstraints
+import org.bouncycastle.asn1.x509.GeneralName
+import org.bouncycastle.asn1.x509.X509Extensions
+import org.bouncycastle.jce.provider.BouncyCastleProvider
+import org.bouncycastle.x509.X509V3CertificateGenerator
+import java.math.BigInteger
+import java.security.KeyPair
+import java.security.KeyPairGenerator
+import java.security.PrivateKey
+import java.security.PublicKey
+import java.security.SecureRandom
+import java.security.Security
+import java.security.cert.X509Certificate
+import java.security.interfaces.RSAPrivateKey
+import java.util.Date
+import java.util.UUID
+import java.util.concurrent.TimeUnit
+import javax.security.auth.x500.X500Principal
+
+/**
+ * A certificate and its private key. These are some properties of certificates that are used with
+ * TLS:
+ *
+ *  * **A common name.** This is a string identifier for the certificate. It usually describes the
+ *    purpose of the certificate like "Entrust Root Certification Authority - G2" or
+ *    "www.squareup.com".
+ *
+ *  * **A set of hostnames.** These are in the certificate's subject alternative name (SAN)
+ *    extension. A subject alternative name is either a literal hostname (`squareup.com`), a literal
+ *    IP address (`74.122.190.80`), or a hostname pattern (`*.api.squareup.com`).
+ *
+ *  * **A validity interval.** A certificate should not be used before its validity interval starts
+ *    or after it ends.
+ *
+ *  * **A public key.** This cryptographic key is used for asymmetric encryption digital signatures.
+ *    Note that the private key is not a part of the certificate!
+ *
+ *  * **A signature issued by another certificate's private key.** This mechanism allows a trusted
+ *    third-party to endorse a certificate. Third parties should only endorse certificates once
+ *    they've confirmed that the owner of the private key is also the owner of the certificate's
+ *    other properties.
+ *
+ * Certificates are signed by other certificates and a sequence of them is called a certificate
+ * chain. The chain terminates in a self-signed "root" certificate. Signing certificates in the
+ * middle of the chain are called "intermediates". Organizations that offer certificate signing are
+ * called certificate authorities (CAs).
+ *
+ * Browsers and other HTTP clients need a set of trusted root certificates to authenticate their
+ * peers. Sets of root certificates are managed by either the HTTP client (like Firefox), or the
+ * host platform (like Android). In July 2018 Android had 134 trusted root certificates for its HTTP
+ * clients to trust.
+ *
+ * For example, in order to establish a secure connection to `https://www.squareup.com/`,
+ * these three certificates are used.
+ *
+ * ```
+ * www.squareup.com certificate:
+ *
+ * Common Name: www.squareup.com
+ * Subject Alternative Names: www.squareup.com, squareup.com, account.squareup.com...
+ * Validity: 2018-07-03T20:18:17Z  2019-08-01T20:48:15Z
+ * Public Key: d107beecc17325f55da976bcbab207ba4df68bd3f8fce7c3b5850311128264fd53e1baa342f58d93...
+ * Signature: 1fb0e66fac05322721fe3a3917f7c98dee1729af39c99eab415f22d8347b508acdf0bab91781c3720...
+ *
+ * signed by intermediate certificate:
+ *
+ * Common Name: Entrust Certification Authority - L1M
+ * Subject Alternative Names: none
+ * Validity: 2014-12-15T15:25:03Z  2030-10-15T15:55:03Z
+ * Public Key: d081c13923c2b1d1ecf757dd55243691202248f7fcca520ab0ab3f33b5b08407f6df4e7ab0fb9822...
+ * Signature: b487c784221a29c0a478ecf54f1bb484976f77eed4cf59afa843962f1d58dea6f3155b2ed9439c4c4...
+ *
+ * signed by root certificate:
+ *
+ * Common Name: Entrust Root Certification Authority - G2
+ * Subject Alternative Names: none
+ * Validity: 2009-07-07T17:25:54Z  2030-12-07T17:55:54Z
+ * Public Key: ba84b672db9e0c6be299e93001a776ea32b895411ac9da614e5872cffef68279bf7361060aa527d8...
+ * Self-signed Signature: 799f1d96c6b6793f228d87d3870304606a6b9a2e59897311ac43d1f513ff8d392bc0f...
+ * ```
+ *
+ * In this example the HTTP client already knows and trusts the last certificate, "Entrust Root
+ * Certification Authority - G2". That certificate is used to verify the signature of the
+ * intermediate certificate, "Entrust Certification Authority - L1M". The intermediate certificate
+ * is used to verify the signature of the "www.squareup.com" certificate.
+ *
+ * This roles are reversed for client authentication. In that case the client has a private key and
+ * a chain of certificates. The server uses a set of trusted root certificates to authenticate the
+ * client. Subject alternative names are not used for client authentication.
+ */
+class HeldCertificate(private val keyPair: KeyPair, private val certificate: X509Certificate) {
+  fun certificate(): X509Certificate = certificate
+
+  fun keyPair(): KeyPair = keyPair
+
+  /**
+   * Returns the certificate encoded in [PEM format][rfc_7468].
+   *
+   * [rfc_7468]: https://tools.ietf.org/html/rfc7468
+   */
+  fun certificatePem(): String {
+    return buildString {
+      append("-----BEGIN CERTIFICATE-----\n")
+      encodeBase64Lines(ByteString.of(*certificate.encoded))
+      append("-----END CERTIFICATE-----\n")
+    }
+  }
+
+  /**
+   * Returns the RSA private key encoded in [PKCS #8][rfc_5208] [PEM format][rfc_7468].
+   *
+   * [rfc_5208]: https://tools.ietf.org/html/rfc5208
+   * [rfc_7468]: https://tools.ietf.org/html/rfc7468
+   */
+  fun privateKeyPkcs8Pem(): String {
+    return buildString {
+      append("-----BEGIN PRIVATE KEY-----\n")
+      encodeBase64Lines(ByteString.of(*keyPair.private.encoded))
+      append("-----END PRIVATE KEY-----\n")
+    }
+  }
+
+  /**
+   * Returns the RSA private key encoded in [PKCS #1][rfc_8017] [PEM format][rfc_7468].
+   *
+   * [rfc_8017]: https://tools.ietf.org/html/rfc8017
+   * [rfc_7468]: https://tools.ietf.org/html/rfc7468
+   */
+  fun privateKeyPkcs1Pem(): String {
+    require(keyPair.private is RSAPrivateKey) { "PKCS1 only supports RSA keys" }
+    return buildString {
+      append("-----BEGIN RSA PRIVATE KEY-----\n")
+      encodeBase64Lines(pkcs1Bytes())
+      append("-----END RSA PRIVATE KEY-----\n")
+    }
+  }
+
+  private fun pkcs1Bytes(): ByteString {
+    val privateKeyInfo = PrivateKeyInfo.getInstance(keyPair.private.encoded)
+    return ByteString.of(*privateKeyInfo.parsePrivateKey().toASN1Primitive().encoded)
+  }
+
+  private fun StringBuilder.encodeBase64Lines(data: ByteString) {
+    val base64 = data.base64()
+    for (i in 0 until base64.length step 64) {
+      append(base64, i, Math.min(i + 64, base64.length)).append('\n')
+    }
+  }
+
+  /** Build a held certificate with reasonable defaults.  */
+  class Builder {
+    private var notBefore = -1L
+    private var notAfter = -1L
+    private var cn: String? = null
+    private var ou: String? = null
+    private val altNames = mutableListOf<String>()
+    private var serialNumber: BigInteger? = null
+    private var keyPair: KeyPair? = null
+    private var signedBy: HeldCertificate? = null
+    private var maxIntermediateCas = -1
+    private var keyAlgorithm: String? = null
+    private var keySize: Int = 0
+
+    init {
+      ecdsa256()
+    }
+
+    /**
+     * Sets the certificate to be valid in ```[notBefore..notAfter]```. Both endpoints are specified
+     * in the format of [System.currentTimeMillis]. Specify -1L for both values to use the default
+     * interval, 24 hours starting when the certificate is created.
+     */
+    fun validityInterval(notBefore: Long, notAfter: Long) = apply {
+      require(notBefore <= notAfter && notBefore == -1L == (notAfter == -1L)) {
+        "invalid interval: $notBefore..$notAfter"
+      }
+      this.notBefore = notBefore
+      this.notAfter = notAfter
+    }
+
+    /**
+     * Sets the certificate to be valid immediately and until the specified duration has elapsed.
+     * The precision of this field is seconds; further precision will be truncated.
+     */
+    fun duration(duration: Long, unit: TimeUnit) = apply {
+      val now = System.currentTimeMillis()
+      validityInterval(now, now + unit.toMillis(duration))
+    }
+
+    /**
+     * Adds a subject alternative name (SAN) to the certificate. This is usually a literal hostname,
+     * a literal IP address, or a hostname pattern. If no subject alternative names are added that
+     * extension will be omitted.
+     */
+    fun addSubjectAlternativeName(altName: String) = apply {
+      altNames += altName
+    }
+
+    /**
+     * Set this certificate's common name (CN). Historically this held the hostname of TLS
+     * certificate, but that practice was deprecated by [RFC 2818][rfc_2818] and replaced with
+     * [addSubjectAlternativeName]. If unset a random string will be used.
+     *
+     * [rfc_2818]: https://tools.ietf.org/html/rfc2818
+     */
+    fun commonName(cn: String) = apply {
+      this.cn = cn
+    }
+
+    /** Sets the certificate's organizational unit (OU). If unset this field will be omitted. */
+    fun organizationalUnit(ou: String) = apply {
+      this.ou = ou
+    }
+
+    /** Sets this certificate's serial number. If unset the serial number will be 1. */
+    fun serialNumber(serialNumber: BigInteger) = apply {
+      this.serialNumber = serialNumber
+    }
+
+    /** Sets this certificate's serial number. If unset the serial number will be 1. */
+    fun serialNumber(serialNumber: Long) = apply {
+      serialNumber(BigInteger.valueOf(serialNumber))
+    }
+
+    /**
+     * Sets the public/private key pair used for this certificate. If unset a key pair will be
+     * generated.
+     */
+    fun keyPair(keyPair: KeyPair) = apply {
+      this.keyPair = keyPair
+    }
+
+    /**
+     * Sets the public/private key pair used for this certificate. If unset a key pair will be
+     * generated.
+     */
+    fun keyPair(publicKey: PublicKey, privateKey: PrivateKey) = apply {
+      keyPair(KeyPair(publicKey, privateKey))
+    }
+
+    /**
+     * Set the certificate that will issue this certificate. If unset the certificate will be
+     * self-signed.
+     */
+    fun signedBy(signedBy: HeldCertificate?) = apply {
+      this.signedBy = signedBy
+    }
+
+    /**
+     * Set this certificate to be a signing certificate, with up to `maxIntermediateCas`
+     * intermediate signing certificates beneath it.
+     *
+     * By default this certificate cannot not sign other certificates. Set this to 0 so this
+     * certificate can sign other certificates (but those certificates cannot themselves sign
+     * certificates). Set this to 1 so this certificate can sign intermediate certificates that can
+     * themselves sign certificates. Add one for each additional layer of intermediates to permit.
+     */
+    fun certificateAuthority(maxIntermediateCas: Int) = apply {
+      require(maxIntermediateCas >= 0) {
+        "maxIntermediateCas < 0: $maxIntermediateCas"
+      }
+      this.maxIntermediateCas = maxIntermediateCas
+    }
+
+    /**
+     * Configure the certificate to generate a 256-bit ECDSA key, which provides about 128 bits of
+     * security. ECDSA keys are noticeably faster than RSA keys.
+     *
+     * This is the default configuration and has been since this API was introduced in OkHttp
+     * 3.11.0. Note that the default may change in future releases.
+     */
+    fun ecdsa256() = apply {
+      keyAlgorithm = "EC"
+      keySize = 256
+    }
+
+    /**
+     * Configure the certificate to generate a 2048-bit RSA key, which provides about 112 bits of
+     * security. RSA keys are interoperable with very old clients that don't support ECDSA.
+     */
+    fun rsa2048() = apply {
+      keyAlgorithm = "RSA"
+      keySize = 2048
+    }
+
+    fun build(): HeldCertificate {
+      // Subject, public & private keys for this certificate.
+      val heldKeyPair = keyPair ?: generateKeyPair()
+      val subject = buildSubject()
+
+      // Subject, public & private keys for this certificate's signer. It may be self signed!
+      val signedByKeyPair: KeyPair
+      val signedByPrincipal: X500Principal
+      if (signedBy != null) {
+        signedByKeyPair = signedBy!!.keyPair
+        signedByPrincipal = signedBy!!.certificate.subjectX500Principal
+      } else {
+        signedByKeyPair = heldKeyPair
+        signedByPrincipal = subject
+      }
+
+      // Generate & sign the certificate.
+      val notBefore = if (this.notBefore != -1L) {
+        this.notBefore
+      } else {
+        System.currentTimeMillis()
+      }
+      val notAfter = if (this.notAfter != -1L) {
+        this.notAfter
+      } else {
+        notBefore + DEFAULT_DURATION_MILLIS
+      }
+      val serialNumber = if (this.serialNumber != null) {
+        this.serialNumber
+      } else {
+        BigInteger.ONE
+      }
+      val signatureAlgorithm = if (signedByKeyPair.private is RSAPrivateKey) {
+        "SHA256WithRSAEncryption"
+      } else {
+        "SHA256withECDSA"
+      }
+      val generator = X509V3CertificateGenerator()
+      generator.setSerialNumber(serialNumber)
+      generator.setIssuerDN(signedByPrincipal)
+      generator.setNotBefore(Date(notBefore))
+      generator.setNotAfter(Date(notAfter))
+      generator.setSubjectDN(subject)
+      generator.setPublicKey(heldKeyPair.public)
+      generator.setSignatureAlgorithm(signatureAlgorithm)
+
+      if (maxIntermediateCas != -1) {
+        generator.addExtension(X509Extensions.BasicConstraints, true,
+            BasicConstraints(maxIntermediateCas))
+      }
+
+      if (!altNames.isEmpty()) {
+        val encodableAltNames = arrayOfNulls<ASN1Encodable>(altNames.size)
+        for (i in 0 until altNames.size) {
+          val altName = altNames[i]
+          val tag = when {
+            verifyAsIpAddress(altName) -> GeneralName.iPAddress
+            else -> GeneralName.dNSName
+          }
+          encodableAltNames[i] = GeneralName(tag, altName)
+        }
+        generator.addExtension(X509Extensions.SubjectAlternativeName, true,
+            DERSequence(encodableAltNames))
+      }
+
+      val certificate = generator.generate(signedByKeyPair.private)
+      return HeldCertificate(heldKeyPair, certificate)
+    }
+
+    private fun buildSubject(): X500Principal {
+      val name = buildString {
+        append("CN=")
+        if (cn != null) {
+          append(cn)
+        } else {
+          append(UUID.randomUUID())
+        }
+        if (ou != null) {
+          append(", OU=")
+          append(ou)
+        }
+      }
+      return X500Principal(name)
+    }
+
+    private fun generateKeyPair(): KeyPair {
+      val keyPairGenerator = KeyPairGenerator.getInstance(keyAlgorithm)
+      keyPairGenerator.initialize(keySize, SecureRandom())
+      return keyPairGenerator.generateKeyPair()
+    }
+
+    companion object {
+      private const val DEFAULT_DURATION_MILLIS = 1000L * 60 * 60 * 24 // 24 hours.
+
+      init {
+        Security.addProvider(BouncyCastleProvider())
+      }
+    }
+  }
+}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java b/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java
deleted file mode 100644
index b127b36861..0000000000
--- a/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.tls.internal;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
-import java.security.KeyStore;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.Arrays;
-import java.util.List;
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509KeyManager;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.tls.HeldCertificate;
-import okhttp3.tls.HandshakeCertificates;
-
-public final class TlsUtil {
-  public static final char[] password = "password".toCharArray();
-  private static HandshakeCertificates localhost; // Lazily initialized.
-
-  private TlsUtil() {
-  }
-
-  /** Returns an SSL client for this host's localhost address. */
-  public static synchronized HandshakeCertificates localhost() {
-    if (localhost != null) return localhost;
-
-    try {
-      // Generate a self-signed cert for the server to serve and the client to trust.
-      HeldCertificate heldCertificate = new HeldCertificate.Builder()
-          .commonName("localhost")
-          .addSubjectAlternativeName(InetAddress.getByName("localhost").getCanonicalHostName())
-          .build();
-
-      localhost = new HandshakeCertificates.Builder()
-          .heldCertificate(heldCertificate)
-          .addTrustedCertificate(heldCertificate.certificate())
-          .build();
-
-      return localhost;
-    } catch (UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  /** Returns a trust manager that trusts {@code trustedCertificates}. */
-  public static X509TrustManager newTrustManager(String keyStoreType,
-      List<X509Certificate> trustedCertificates) throws GeneralSecurityException {
-    KeyStore trustStore = newEmptyKeyStore(keyStoreType);
-    for (int i = 0; i < trustedCertificates.size(); i++) {
-      trustStore.setCertificateEntry("cert_" + i, trustedCertificates.get(i));
-    }
-    TrustManagerFactory factory = TrustManagerFactory.getInstance(
-        TrustManagerFactory.getDefaultAlgorithm());
-    factory.init(trustStore);
-    TrustManager[] result = factory.getTrustManagers();
-    if (result.length != 1 || !(result[0] instanceof X509TrustManager)) {
-      throw new IllegalStateException("Unexpected trust managers:" + Arrays.toString(result));
-    }
-    return (X509TrustManager) result[0];
-  }
-
-  /**
-   * Returns a key manager for the held certificate and its chain. Returns an empty key manager if
-   * {@code heldCertificate} is null.
-   */
-  public static X509KeyManager newKeyManager(String keyStoreType, HeldCertificate heldCertificate,
-      X509Certificate... intermediates) throws GeneralSecurityException {
-    KeyStore keyStore = newEmptyKeyStore(keyStoreType);
-
-    if (heldCertificate != null) {
-      Certificate[] chain = new Certificate[1 + intermediates.length];
-      chain[0] = heldCertificate.certificate();
-      System.arraycopy(intermediates, 0, chain, 1, intermediates.length);
-      keyStore.setKeyEntry("private", heldCertificate.keyPair().getPrivate(), password, chain);
-    }
-
-    KeyManagerFactory factory = KeyManagerFactory.getInstance(
-        KeyManagerFactory.getDefaultAlgorithm());
-    factory.init(keyStore, password);
-    KeyManager[] result = factory.getKeyManagers();
-    if (result.length != 1 || !(result[0] instanceof X509KeyManager)) {
-      throw new IllegalStateException("Unexpected key managers:" + Arrays.toString(result));
-    }
-    return (X509KeyManager) result[0];
-  }
-
-  private static KeyStore newEmptyKeyStore(String keyStoreType) throws GeneralSecurityException {
-    if (keyStoreType == null) {
-      keyStoreType = KeyStore.getDefaultType();
-    }
-
-    try {
-      KeyStore keyStore = KeyStore.getInstance(keyStoreType);
-      InputStream in = null; // By convention, 'null' creates an empty key store.
-      keyStore.load(in, password);
-      return keyStore;
-    } catch (IOException e) {
-      throw new AssertionError(e);
-    }
-  }
-}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.kt b/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.kt
new file mode 100644
index 0000000000..32b41832fa
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.kt
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls.internal
+
+import okhttp3.tls.HandshakeCertificates
+import okhttp3.tls.HeldCertificate
+import java.io.InputStream
+import java.net.InetAddress
+import java.security.KeyStore
+import java.security.cert.Certificate
+import java.security.cert.X509Certificate
+import javax.net.ssl.KeyManagerFactory
+import javax.net.ssl.TrustManagerFactory
+import javax.net.ssl.X509KeyManager
+import javax.net.ssl.X509TrustManager
+
+object TlsUtil {
+  val password = "password".toCharArray()
+
+  private val localhost: HandshakeCertificates by lazy {
+    // Generate a self-signed cert for the server to serve and the client to trust.
+    val heldCertificate = HeldCertificate.Builder()
+        .commonName("localhost")
+        .addSubjectAlternativeName(InetAddress.getByName("localhost").canonicalHostName)
+        .build()
+    return@lazy HandshakeCertificates.Builder()
+        .heldCertificate(heldCertificate)
+        .addTrustedCertificate(heldCertificate.certificate())
+        .build()
+  }
+
+  /** Returns an SSL client for this host's localhost address.  */
+  @JvmStatic
+  fun localhost(): HandshakeCertificates = localhost
+
+  /** Returns a trust manager that trusts `trustedCertificates`.  */
+  @JvmStatic
+  fun newTrustManager(
+    keyStoreType: String?,
+    trustedCertificates: List<X509Certificate>
+  ): X509TrustManager {
+    val trustStore = newEmptyKeyStore(keyStoreType)
+    for (i in trustedCertificates.indices) {
+      trustStore.setCertificateEntry("cert_$i", trustedCertificates[i])
+    }
+
+    val factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
+    factory.init(trustStore)
+    val result = factory.trustManagers!!
+    check(result.size == 1 && result[0] is X509TrustManager) {
+      "Unexpected trust managers: ${result.contentToString()}"
+    }
+
+    return result[0] as X509TrustManager
+  }
+
+  /**
+   * Returns a key manager for the held certificate and its chain. Returns an empty key manager if
+   * `heldCertificate` is null.
+   */
+  @JvmStatic
+  fun newKeyManager(
+    keyStoreType: String?,
+    heldCertificate: HeldCertificate?,
+    vararg intermediates: X509Certificate
+  ): X509KeyManager {
+    val keyStore = newEmptyKeyStore(keyStoreType)
+    if (heldCertificate != null) {
+      val chain = arrayOfNulls<Certificate>(1 + intermediates.size)
+      chain[0] = heldCertificate.certificate()
+      intermediates.copyInto(chain, 1)
+      keyStore.setKeyEntry("private", heldCertificate.keyPair().private, password, chain)
+    }
+
+    val factory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
+    factory.init(keyStore, password)
+    val result = factory.keyManagers!!
+    check(result.size == 1 && result[0] is X509KeyManager) {
+      "Unexpected key managers:${result.contentToString()}"
+    }
+
+    return result[0] as X509KeyManager
+  }
+
+  private fun newEmptyKeyStore(keyStoreType: String?): KeyStore {
+    return KeyStore.getInstance(keyStoreType ?: KeyStore.getDefaultType()).apply {
+      val inputStream: InputStream? = null // By convention, 'null' creates an empty key store.
+      load(inputStream, password)
+    }
+  }
+}
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
index 6892e14f0b..9a78178437 100644
--- a/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
+++ b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
@@ -22,7 +22,6 @@
 import java.net.Socket;
 import java.security.PrivateKey;
 import java.security.cert.X509Certificate;
-import java.util.Arrays;
 import java.util.LinkedHashSet;
 import java.util.Set;
 import java.util.concurrent.ExecutorService;
@@ -37,9 +36,10 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static java.util.Arrays.asList;
 import static okhttp3.internal.Util.closeQuietly;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assume.assumeFalse;
 
 public final class HandshakeCertificatesTest {
   private ExecutorService executorService;
@@ -55,6 +55,8 @@
   }
 
   @Test public void clientAndServer() throws Exception {
+    assumeFalse(getPlatform().equals("conscrypt"));
+
     HeldCertificate clientRoot = new HeldCertificate.Builder()
         .certificateAuthority(1)
         .build();
@@ -92,17 +94,16 @@
     Future<Handshake> clientHandshakeFuture = doClientHandshake(client, serverAddress);
 
     Handshake serverHandshake = serverHandshakeFuture.get();
-    assertEquals(serverHandshake.peerCertificates(),
-        Arrays.asList(clientCertificate.certificate(), clientIntermediate.certificate()));
-    assertEquals(serverHandshake.localCertificates(),
-        Arrays.asList(serverCertificate.certificate(), serverIntermediate.certificate()));
+    assertThat(asList(clientCertificate.certificate(), clientIntermediate.certificate()))
+        .isEqualTo(serverHandshake.peerCertificates());
+    assertThat(asList(serverCertificate.certificate(), serverIntermediate.certificate()))
+        .isEqualTo(serverHandshake.localCertificates());
 
     Handshake clientHandshake = clientHandshakeFuture.get();
-    assertEquals(clientHandshake.peerCertificates(),
-        Arrays.asList(serverCertificate.certificate(), serverIntermediate.certificate()));
-    assertEquals(clientHandshake.localCertificates(),
-        Arrays.asList(clientCertificate.certificate(), clientIntermediate.certificate()));
-
+    assertThat(asList(serverCertificate.certificate(), serverIntermediate.certificate()))
+        .isEqualTo(clientHandshake.peerCertificates());
+    assertThat(asList(clientCertificate.certificate(), clientIntermediate.certificate()))
+        .isEqualTo(clientHandshake.localCertificates());
   }
 
   @Test public void keyManager() {
@@ -122,8 +123,8 @@
         .build();
     assertPrivateKeysEquals(certificate.keyPair().getPrivate(),
         handshakeCertificates.keyManager().getPrivateKey("private"));
-    assertEquals(Arrays.asList(certificate.certificate(), intermediate.certificate()),
-        Arrays.asList(handshakeCertificates.keyManager().getCertificateChain("private")));
+    assertThat(asList(handshakeCertificates.keyManager().getCertificateChain("private"))).isEqualTo(
+        asList(certificate.certificate(), intermediate.certificate()));
   }
 
   @Test public void platformTrustedCertificates() {
@@ -137,7 +138,7 @@
       names.add(name.substring(0, name.indexOf(" ")));
     }
     // It's safe to assume all platforms will have a major Internet certificate issuer.
-    assertTrue(names.toString(), names.contains("CN=Entrust"));
+    assertThat(names).contains("CN=Entrust");
   }
 
   private InetSocketAddress startTlsServer() throws IOException {
@@ -186,6 +187,11 @@ private InetSocketAddress startTlsServer() throws IOException {
   }
 
   private void assertPrivateKeysEquals(PrivateKey expected, PrivateKey actual) {
-    assertEquals(ByteString.of(expected.getEncoded()), ByteString.of(actual.getEncoded()));
+    assertThat(ByteString.of(actual.getEncoded())).isEqualTo(
+        ByteString.of(expected.getEncoded()));
+  }
+
+  public static String getPlatform() {
+    return System.getProperty("okhttp.platform", "platform");
   }
 }
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
index ffec150f32..76dbeb81f1 100644
--- a/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
+++ b/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
@@ -23,17 +23,14 @@
 import java.security.cert.X509Certificate;
 import java.security.spec.PKCS8EncodedKeySpec;
 import java.security.spec.X509EncodedKeySpec;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
 import java.util.concurrent.TimeUnit;
 import okio.ByteString;
 import org.bouncycastle.asn1.x509.GeneralName;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 
 public final class HeldCertificateTest {
   @Test public void defaultCertificate() throws CertificateParsingException {
@@ -41,17 +38,18 @@
     HeldCertificate heldCertificate = new HeldCertificate.Builder().build();
 
     X509Certificate certificate = heldCertificate.certificate();
-    assertEquals("self-signed",
-        certificate.getIssuerX500Principal().getName(),
-        certificate.getSubjectX500Principal().getName());
-    assertTrue(certificate.getIssuerX500Principal().getName().matches("CN=[0-9a-f-]{36}"));
-    assertEquals(BigInteger.ONE, certificate.getSerialNumber());
-    assertNull(certificate.getSubjectAlternativeNames());
+    assertThat(certificate.getSubjectX500Principal().getName()).overridingErrorMessage(
+        "self-signed").isEqualTo(certificate.getIssuerX500Principal().getName());
+    assertThat(certificate.getIssuerX500Principal().getName()).matches("CN=[0-9a-f-]{36}");
+    assertThat(certificate.getSerialNumber()).isEqualTo(BigInteger.ONE);
+    assertThat(certificate.getSubjectAlternativeNames()).isNull();
 
     double deltaMillis = 1000.0;
     long durationMillis = TimeUnit.MINUTES.toMillis(60 * 24);
-    assertEquals((double) now, certificate.getNotBefore().getTime(), deltaMillis);
-    assertEquals((double) now + durationMillis, certificate.getNotAfter().getTime(), deltaMillis);
+    assertThat((double) certificate.getNotBefore().getTime()).isCloseTo(
+        (double) now, offset(deltaMillis));
+    assertThat((double) certificate.getNotAfter().getTime()).isCloseTo(
+        (double) now + durationMillis, offset(deltaMillis));
   }
 
   @Test public void customInterval() {
@@ -60,8 +58,8 @@
         .validityInterval(5_000L, 10_000L)
         .build();
     X509Certificate certificate = heldCertificate.certificate();
-    assertEquals(5_000L, certificate.getNotBefore().getTime());
-    assertEquals(10_000L, certificate.getNotAfter().getTime());
+    assertThat(certificate.getNotBefore().getTime()).isEqualTo(5_000L);
+    assertThat(certificate.getNotAfter().getTime()).isEqualTo(10_000L);
   }
 
   @Test public void customDuration() {
@@ -74,8 +72,10 @@
 
     double deltaMillis = 1000.0;
     long durationMillis = 5_000L;
-    assertEquals((double) now, certificate.getNotBefore().getTime(), deltaMillis);
-    assertEquals((double) now + durationMillis, certificate.getNotAfter().getTime(), deltaMillis);
+    assertThat((double) certificate.getNotBefore().getTime()).isCloseTo(
+        (double) now, offset(deltaMillis));
+    assertThat((double) certificate.getNotAfter().getTime()).isCloseTo(
+        (double) now + durationMillis, offset(deltaMillis));
   }
 
   @Test public void subjectAlternativeNames() throws CertificateParsingException {
@@ -85,11 +85,9 @@
         .build();
 
     X509Certificate certificate = heldCertificate.certificate();
-    List<List<?>> subjectAlternativeNames = new ArrayList<>(
-        certificate.getSubjectAlternativeNames());
-    assertEquals(subjectAlternativeNames, Arrays.asList(
-        Arrays.asList(GeneralName.iPAddress, "1.1.1.1"),
-        Arrays.asList(GeneralName.dNSName, "cash.app")));
+    assertThat(certificate.getSubjectAlternativeNames()).containsExactly(
+        asList(GeneralName.iPAddress, "1.1.1.1"),
+        asList(GeneralName.dNSName, "cash.app"));
   }
 
   @Test public void commonName() {
@@ -98,7 +96,7 @@
         .build();
 
     X509Certificate certificate = heldCertificate.certificate();
-    assertEquals("CN=cash.app", certificate.getSubjectX500Principal().getName());
+    assertThat(certificate.getSubjectX500Principal().getName()).isEqualTo("CN=cash.app");
   }
 
   @Test public void organizationalUnit() {
@@ -108,7 +106,8 @@
         .build();
 
     X509Certificate certificate = heldCertificate.certificate();
-    assertEquals("CN=cash.app,OU=cash", certificate.getSubjectX500Principal().getName());
+    assertThat(certificate.getSubjectX500Principal().getName()).isEqualTo(
+        "CN=cash.app,OU=cash");
   }
 
   /** Confirm golden values of encoded PEMs. */
@@ -142,7 +141,7 @@
         .rsa2048()
         .build();
 
-    assertEquals(heldCertificate.certificatePem(), ""
+    assertThat((""
         + "-----BEGIN CERTIFICATE-----\n"
         + "MIIBmjCCAQOgAwIBAgIBATANBgkqhkiG9w0BAQsFADATMREwDwYDVQQDEwhjYXNo\n"
         + "LmFwcDAeFw03MDAxMDEwMDAwMDBaFw03MDAxMDEwMDAwMDFaMBMxETAPBgNVBAMT\n"
@@ -153,9 +152,9 @@
         + "UVwKh5Ry7es3OxtY3IgQunPUoLc0Gw71gl9Z+7t2FJ5VkcI5gWfutmdxZ2bDXCI8\n"
         + "8V0vxo1pHXnbBrnxhS/Z3TBerw8RyQqcaWOdp+pBXyIWmR+jHk9cHZCqQveTIBsY\n"
         + "jaA9VEhgdaVhxBsT2qzUNDsXlOzGsliznDfoqETb\n"
-        + "-----END CERTIFICATE-----\n");
+        + "-----END CERTIFICATE-----\n")).isEqualTo(heldCertificate.certificatePem());
 
-    assertEquals(heldCertificate.privateKeyPkcs1Pem(), ""
+    assertThat((""
         + "-----BEGIN RSA PRIVATE KEY-----\n"
         + "MIICWwIBAAKBgQCApFHhtrLan28q+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1w\n"
         + "J4YEoUCjDlPOtpht7XLbUmBnbIzN89XK4UJVM6Sqp3K88Km8z7gMrdrfTom/274w\n"
@@ -170,9 +169,9 @@
         + "xs/h8kq5HE+woNdjPzZHVEJ2Xt46/PKbf/iBjcKJnOlrf5ieH3FjjU5BjHHzmX39\n"
         + "TUHjVwwGeveNVwrCFQJAEjoNNj5VRy4nVO5iBOubMDDOf0TYUuGhY3s/zMMRTTh2\n"
         + "sXPVYAsGD1wizrXX+wFaL3chtF1oG1Fx/jcsSsG6BA==\n"
-        + "-----END RSA PRIVATE KEY-----\n");
+        + "-----END RSA PRIVATE KEY-----\n")).isEqualTo(heldCertificate.privateKeyPkcs1Pem());
 
-    assertEquals(heldCertificate.privateKeyPkcs8Pem(), ""
+    assertThat((""
         + "-----BEGIN PRIVATE KEY-----\n"
         + "MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAICkUeG2stqfbyr6\n"
         + "gyiVm5pN9YEDRXlowi+rfYGyWhC7ouW9fXAnhgShQKMOU862mG3tcttSYGdsjM3z\n"
@@ -188,7 +187,7 @@
         + "8pt/+IGNwomc6Wt/mJ4fcWONTkGMcfOZff1NQeNXDAZ6941XCsIVAkASOg02PlVH\n"
         + "LidU7mIE65swMM5/RNhS4aFjez/MwxFNOHaxc9VgCwYPXCLOtdf7AVovdyG0XWgb\n"
         + "UXH+NyxKwboE\n"
-        + "-----END PRIVATE KEY-----\n");
+        + "-----END PRIVATE KEY-----\n")).isEqualTo(heldCertificate.privateKeyPkcs8Pem());
   }
 
   @Test public void ecdsaSignedByRsa() {
@@ -202,8 +201,8 @@
         .signedBy(root)
         .build();
 
-    assertEquals("SHA256WITHRSA", root.certificate().getSigAlgName());
-    assertEquals("SHA256WITHRSA", leaf.certificate().getSigAlgName());
+    assertThat(root.certificate().getSigAlgName()).isEqualTo("SHA256WITHRSA");
+    assertThat(leaf.certificate().getSigAlgName()).isEqualTo("SHA256WITHRSA");
   }
 
   @Test public void rsaSignedByEcdsa() {
@@ -217,7 +216,7 @@
         .signedBy(root)
         .build();
 
-    assertEquals("SHA256WITHECDSA", root.certificate().getSigAlgName());
-    assertEquals("SHA256WITHECDSA", leaf.certificate().getSigAlgName());
+    assertThat(root.certificate().getSigAlgName()).isEqualTo("SHA256WITHECDSA");
+    assertThat(leaf.certificate().getSigAlgName()).isEqualTo("SHA256WITHECDSA");
   }
 }
diff --git a/okhttp-urlconnection/build.gradle b/okhttp-urlconnection/build.gradle
new file mode 100644
index 0000000000..4b997f5710
--- /dev/null
+++ b/okhttp-urlconnection/build.gradle
@@ -0,0 +1,31 @@
+apply plugin: 'com.vanniktech.maven.publish'
+apply plugin: 'me.champeau.gradle.japicmp'
+
+jar {
+  manifest {
+    attributes('Automatic-Module-Name': 'okhttp3.urlconnection')
+  }
+}
+
+dependencies {
+  api project(':okhttp')
+  compileOnly deps.jsr305
+  compileOnly deps.animalSniffer
+
+  testImplementation project(':okhttp-testing-support')
+  testImplementation project(':okhttp-tls')
+  testImplementation project(':mockwebserver')
+  testImplementation deps.junit
+  testImplementation deps.assertj
+}
+
+task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
+  oldClasspath = files(baselineJar(project, baselineVersion))
+  newClasspath = files(jar.archivePath)
+  onlyBinaryIncompatibleModified = true
+  failOnModification = true
+  txtOutputFile = file("$buildDir/reports/japi.txt")
+  ignoreMissingClasses = true
+  includeSynthetic = true
+}
+check.dependsOn(japicmp)
diff --git a/okhttp-urlconnection/gradle.properties b/okhttp-urlconnection/gradle.properties
new file mode 100644
index 0000000000..33c8a52a36
--- /dev/null
+++ b/okhttp-urlconnection/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=okhttp-urlconnection
+POM_NAME=okhttp-urlconnection
+POM_PACKAGING=jar
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
deleted file mode 100644
index f98e26264b..0000000000
--- a/okhttp-urlconnection/pom.xml
+++ /dev/null
@@ -1,85 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-urlconnection</artifactId>
-  <name>OkHttp URLConnection</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.codehaus.mojo</groupId>
-      <artifactId>animal-sniffer-annotations</artifactId>
-      <version>${animal.sniffer.version}</version>
-      <optional>true</optional>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-tls</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>3.0.1</version>
-        <configuration>
-          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.urlconnection</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
deleted file mode 100644
index f1892b7199..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.Authenticator.RequestorType;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.PasswordAuthentication;
-import java.net.Proxy;
-import java.util.List;
-import okhttp3.internal.annotations.EverythingIsNonNull;
-
-/**
- * Adapts {@link java.net.Authenticator} to {@link Authenticator}. Configure OkHttp to use {@link
- * java.net.Authenticator} with {@link OkHttpClient.Builder#authenticator} or {@link
- * OkHttpClient.Builder#proxyAuthenticator(Authenticator)}.
- */
-@EverythingIsNonNull
-public final class JavaNetAuthenticator implements Authenticator {
-  @Override public Request authenticate(Route route, Response response) throws IOException {
-    List<Challenge> challenges = response.challenges();
-    Request request = response.request();
-    HttpUrl url = request.url();
-    boolean proxyAuthorization = response.code() == 407;
-    Proxy proxy = route.proxy();
-
-    for (int i = 0, size = challenges.size(); i < size; i++) {
-      Challenge challenge = challenges.get(i);
-      if (!"Basic".equalsIgnoreCase(challenge.scheme())) continue;
-
-      PasswordAuthentication auth;
-      if (proxyAuthorization) {
-        InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
-        auth = java.net.Authenticator.requestPasswordAuthentication(
-            proxyAddress.getHostName(), getConnectToInetAddress(proxy, url), proxyAddress.getPort(),
-            url.scheme(), challenge.realm(), challenge.scheme(), url.url(),
-            RequestorType.PROXY);
-      } else {
-        auth = java.net.Authenticator.requestPasswordAuthentication(
-            url.host(), getConnectToInetAddress(proxy, url), url.port(), url.scheme(),
-            challenge.realm(), challenge.scheme(), url.url(), RequestorType.SERVER);
-      }
-
-      if (auth != null) {
-        String credential = Credentials.basic(
-            auth.getUserName(), new String(auth.getPassword()), challenge.charset());
-        return request.newBuilder()
-            .header(proxyAuthorization ? "Proxy-Authorization" : "Authorization", credential)
-            .build();
-      }
-    }
-
-    return null; // No challenges were satisfied!
-  }
-
-  private InetAddress getConnectToInetAddress(Proxy proxy, HttpUrl url) throws IOException {
-    return proxy.type() != Proxy.Type.DIRECT
-        ? ((InetSocketAddress) proxy.address()).getAddress()
-        : InetAddress.getByName(url.host());
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.kt b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.kt
new file mode 100644
index 0000000000..c0bc871051
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.kt
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.io.IOException
+import java.net.Authenticator
+import java.net.InetAddress
+import java.net.InetSocketAddress
+import java.net.Proxy
+
+/**
+ * Adapts [Authenticator] to [okhttp3.Authenticator]. Configure OkHttp to use [Authenticator] with
+ * [OkHttpClient.Builder.authenticator] or [OkHttpClient.Builder.proxyAuthenticator].
+ */
+class JavaNetAuthenticator : okhttp3.Authenticator {
+  @Throws(IOException::class)
+  override fun authenticate(route: Route?, response: Response): Request? {
+    val challenges = response.challenges()
+    val request = response.request()
+    val url = request.url()
+    val proxyAuthorization = response.code() == 407
+    val proxy = route?.proxy() ?: Proxy.NO_PROXY
+
+    for (challenge in challenges) {
+      if (!"Basic".equals(challenge.scheme(), ignoreCase = true)) {
+        continue
+      }
+
+      val auth = if (proxyAuthorization) {
+        val proxyAddress = proxy.address() as InetSocketAddress
+        Authenticator.requestPasswordAuthentication(
+            proxyAddress.hostName,
+            proxy.connectToInetAddress(url),
+            proxyAddress.port,
+            url.scheme(),
+            challenge.realm(),
+            challenge.scheme(),
+            url.url(),
+            Authenticator.RequestorType.PROXY
+        )
+      } else {
+        Authenticator.requestPasswordAuthentication(
+            url.host(),
+            proxy.connectToInetAddress(url),
+            url.port(),
+            url.scheme(),
+            challenge.realm(),
+            challenge.scheme(),
+            url.url(),
+            Authenticator.RequestorType.SERVER
+        )
+      }
+
+      if (auth != null) {
+        val credentialHeader = if (proxyAuthorization) "Proxy-Authorization" else "Authorization"
+        val credential = Credentials.basic(
+            auth.userName, String(auth.password), challenge.charset())
+        return request.newBuilder()
+            .header(credentialHeader, credential)
+            .build()
+      }
+    }
+
+    return null // No challenges were satisfied!
+  }
+
+  @Throws(IOException::class)
+  private fun Proxy.connectToInetAddress(url: HttpUrl): InetAddress {
+    return when {
+      type() == Proxy.Type.DIRECT -> InetAddress.getByName(url.host())
+      else -> (address() as InetSocketAddress).address
+    }
+  }
+}
\ No newline at end of file
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
deleted file mode 100644
index 6faf288de7..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.CookieHandler;
-import java.net.HttpCookie;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import okhttp3.internal.annotations.EverythingIsNonNull;
-import okhttp3.internal.platform.Platform;
-
-import static okhttp3.internal.Util.delimiterOffset;
-import static okhttp3.internal.Util.trimSubstring;
-import static okhttp3.internal.platform.Platform.WARN;
-
-/** A cookie jar that delegates to a {@link java.net.CookieHandler}. */
-@EverythingIsNonNull
-public final class JavaNetCookieJar implements CookieJar {
-  private final CookieHandler cookieHandler;
-
-  public JavaNetCookieJar(CookieHandler cookieHandler) {
-    this.cookieHandler = cookieHandler;
-  }
-
-  @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
-    if (cookieHandler != null) {
-      List<String> cookieStrings = new ArrayList<>();
-      for (Cookie cookie : cookies) {
-        cookieStrings.add(cookie.toString(true));
-      }
-      Map<String, List<String>> multimap = Collections.singletonMap("Set-Cookie", cookieStrings);
-      try {
-        cookieHandler.put(url.uri(), multimap);
-      } catch (IOException e) {
-        Platform.get().log(WARN, "Saving cookies failed for " + url.resolve("/..."), e);
-      }
-    }
-  }
-
-  @Override public List<Cookie> loadForRequest(HttpUrl url) {
-    // The RI passes all headers. We don't have 'em, so we don't pass 'em!
-    Map<String, List<String>> headers = Collections.emptyMap();
-    Map<String, List<String>> cookieHeaders;
-    try {
-      cookieHeaders = cookieHandler.get(url.uri(), headers);
-    } catch (IOException e) {
-      Platform.get().log(WARN, "Loading cookies failed for " + url.resolve("/..."), e);
-      return Collections.emptyList();
-    }
-
-    List<Cookie> cookies = null;
-    for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
-      String key = entry.getKey();
-      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
-          && !entry.getValue().isEmpty()) {
-        for (String header : entry.getValue()) {
-          if (cookies == null) cookies = new ArrayList<>();
-          cookies.addAll(decodeHeaderAsJavaNetCookies(url, header));
-        }
-      }
-    }
-
-    return cookies != null
-        ? Collections.unmodifiableList(cookies)
-        : Collections.emptyList();
-  }
-
-  /**
-   * Convert a request header to OkHttp's cookies via {@link HttpCookie}. That extra step handles
-   * multiple cookies in a single request header, which {@link Cookie#parse} doesn't support.
-   */
-  private List<Cookie> decodeHeaderAsJavaNetCookies(HttpUrl url, String header) {
-    List<Cookie> result = new ArrayList<>();
-    for (int pos = 0, limit = header.length(), pairEnd; pos < limit; pos = pairEnd + 1) {
-      pairEnd = delimiterOffset(header, pos, limit, ";,");
-      int equalsSign = delimiterOffset(header, pos, pairEnd, '=');
-      String name = trimSubstring(header, pos, equalsSign);
-      if (name.startsWith("$")) continue;
-
-      // We have either name=value or just a name.
-      String value = equalsSign < pairEnd
-          ? trimSubstring(header, equalsSign + 1, pairEnd)
-          : "";
-
-      // If the value is "quoted", drop the quotes.
-      if (value.startsWith("\"") && value.endsWith("\"")) {
-        value = value.substring(1, value.length() - 1);
-      }
-
-      result.add(new Cookie.Builder()
-          .name(name)
-          .value(value)
-          .domain(url.host())
-          .build());
-    }
-    return result;
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
new file mode 100644
index 0000000000..dbed55acba
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.Util.delimiterOffset
+import okhttp3.internal.Util.trimSubstring
+import okhttp3.internal.cookieToString
+import okhttp3.internal.platform.Platform
+import okhttp3.internal.platform.Platform.Companion.WARN
+import java.io.IOException
+import java.net.CookieHandler
+import java.net.HttpCookie
+import java.util.ArrayList
+import java.util.Collections
+
+/** A cookie jar that delegates to a [java.net.CookieHandler].  */
+class JavaNetCookieJar(private val cookieHandler: CookieHandler) : CookieJar {
+
+  override fun saveFromResponse(url: HttpUrl, cookies: List<Cookie>) {
+    val cookieStrings = mutableListOf<String>()
+    for (cookie in cookies) {
+      cookieStrings.add(cookieToString(cookie, true))
+    }
+    val multimap = mapOf("Set-Cookie" to cookieStrings)
+    try {
+      cookieHandler.put(url.uri(), multimap)
+    } catch (e: IOException) {
+      Platform.get().log(WARN, "Saving cookies failed for " + url.resolve("/...")!!, e)
+    }
+  }
+
+  override fun loadForRequest(url: HttpUrl): List<Cookie> {
+    val cookieHeaders = try {
+      // The RI passes all headers. We don't have 'em, so we don't pass 'em!
+      cookieHandler.get(url.uri(), emptyMap<String, List<String>>())
+    } catch (e: IOException) {
+      Platform.get().log(WARN, "Loading cookies failed for " + url.resolve("/...")!!, e)
+      return emptyList()
+    }
+
+    var cookies: MutableList<Cookie>? = null
+    for ((key, value) in cookieHeaders) {
+      if (("Cookie".equals(key, ignoreCase = true) || "Cookie2".equals(key, ignoreCase = true)) &&
+          value.isNotEmpty()) {
+        for (header in value) {
+          if (cookies == null) cookies = ArrayList()
+          cookies.addAll(decodeHeaderAsJavaNetCookies(url, header))
+        }
+      }
+    }
+
+    return if (cookies != null) {
+      Collections.unmodifiableList(cookies)
+    } else {
+      emptyList()
+    }
+  }
+
+  /**
+   * Convert a request header to OkHttp's cookies via [HttpCookie]. That extra step handles
+   * multiple cookies in a single request header, which [Cookie.parse] doesn't support.
+   */
+  private fun decodeHeaderAsJavaNetCookies(url: HttpUrl, header: String): List<Cookie> {
+    val result = mutableListOf<Cookie>()
+    var pos = 0
+    val limit = header.length
+    var pairEnd: Int
+    while (pos < limit) {
+      pairEnd = delimiterOffset(header, pos, limit, ";,")
+      val equalsSign = delimiterOffset(header, pos, pairEnd, '=')
+      val name = trimSubstring(header, pos, equalsSign)
+      if (name.startsWith("$")) {
+        pos = pairEnd + 1
+        continue
+      }
+
+      // We have either name=value or just a name.
+      var value = if (equalsSign < pairEnd) {
+        trimSubstring(header, equalsSign + 1, pairEnd)
+      } else {
+        ""
+      }
+
+      // If the value is "quoted", drop the quotes.
+      if (value.startsWith("\"") && value.endsWith("\"")) {
+        value = value.substring(1, value.length - 1)
+      }
+
+      result.add(Cookie.Builder()
+          .name(name)
+          .value(value)
+          .domain(url.host())
+          .build())
+      pos = pairEnd + 1
+    }
+    return result
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
deleted file mode 100644
index 8e4591e784..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.HttpURLConnection;
-import java.net.Proxy;
-import java.net.URL;
-import java.net.URLConnection;
-import java.net.URLStreamHandler;
-import java.net.URLStreamHandlerFactory;
-import javax.annotation.Nullable;
-import okhttp3.internal.URLFilter;
-import okhttp3.internal.annotations.EverythingIsNonNull;
-import okhttp3.internal.huc.OkHttpURLConnection;
-import okhttp3.internal.huc.OkHttpsURLConnection;
-
-/**
- * @deprecated OkHttp will be dropping its ability to be used with {@link HttpURLConnection} in an
- * upcoming release. Applications that need this should either downgrade to the system's built-in
- * {@link HttpURLConnection} or upgrade to OkHttp's Request/Response API.
- */
-@EverythingIsNonNull
-public final class OkUrlFactory implements URLStreamHandlerFactory, Cloneable {
-  private OkHttpClient client;
-  private URLFilter urlFilter;
-
-  public OkUrlFactory(OkHttpClient client) {
-    this.client = client;
-  }
-
-  public OkHttpClient client() {
-    return client;
-  }
-
-  public OkUrlFactory setClient(OkHttpClient client) {
-    this.client = client;
-    return this;
-  }
-
-  void setUrlFilter(URLFilter filter) {
-    urlFilter = filter;
-  }
-
-  /**
-   * Returns a copy of this stream handler factory that includes a shallow copy of the internal
-   * {@linkplain OkHttpClient HTTP client}.
-   */
-  @Override public OkUrlFactory clone() {
-    return new OkUrlFactory(client);
-  }
-
-  public HttpURLConnection open(URL url) {
-    return open(url, client.proxy());
-  }
-
-  HttpURLConnection open(URL url, @Nullable Proxy proxy) {
-    String protocol = url.getProtocol();
-    OkHttpClient copy = client.newBuilder()
-        .proxy(proxy)
-        .build();
-
-    if (protocol.equals("http")) return new OkHttpURLConnection(url, copy, urlFilter);
-    if (protocol.equals("https")) return new OkHttpsURLConnection(url, copy, urlFilter);
-    throw new IllegalArgumentException("Unexpected protocol: " + protocol);
-  }
-
-  /**
-   * Creates a URLStreamHandler as a {@link java.net.URL#setURLStreamHandlerFactory}.
-   *
-   * <p>This code configures OkHttp to handle all HTTP and HTTPS connections
-   * created with {@link java.net.URL#openConnection()}: <pre>   {@code
-   *
-   *   OkHttpClient okHttpClient = new OkHttpClient();
-   *   URL.setURLStreamHandlerFactory(new OkUrlFactory(okHttpClient));
-   * }</pre>
-   */
-  @Override public URLStreamHandler createURLStreamHandler(final String protocol) {
-    if (!protocol.equals("http") && !protocol.equals("https")) return null;
-
-    return new URLStreamHandler() {
-      @Override protected URLConnection openConnection(URL url) {
-        return open(url);
-      }
-
-      @Override protected URLConnection openConnection(URL url, Proxy proxy) {
-        return open(url, proxy);
-      }
-
-      @Override protected int getDefaultPort() {
-        if (protocol.equals("http")) return 80;
-        if (protocol.equals("https")) return 443;
-        throw new AssertionError();
-      }
-    };
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
deleted file mode 100644
index 1b4290a7ef..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Map;
-import java.util.TreeMap;
-import okhttp3.Headers;
-
-public final class JavaNetHeaders {
-  private JavaNetHeaders() {
-  }
-
-  private static final Comparator<String> FIELD_NAME_COMPARATOR = (a, b) -> {
-    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
-    if (a == b) {
-      return 0;
-    } else if (a == null) {
-      return -1;
-    } else if (b == null) {
-      return 1;
-    } else {
-      return String.CASE_INSENSITIVE_ORDER.compare(a, b);
-    }
-  };
-
-  /**
-   * Returns an immutable map containing each field to its list of values.
-   *
-   * @param valueForNullKey the request line for requests, or the status line for responses. If
-   * non-null, this value is mapped to the null key.
-   */
-  public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
-    Map<String, List<String>> result = new TreeMap<>(FIELD_NAME_COMPARATOR);
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      String fieldName = headers.name(i);
-      String value = headers.value(i);
-
-      List<String> allValues = new ArrayList<>();
-      List<String> otherValues = result.get(fieldName);
-      if (otherValues != null) {
-        allValues.addAll(otherValues);
-      }
-      allValues.add(value);
-      result.put(fieldName, Collections.unmodifiableList(allValues));
-    }
-    if (valueForNullKey != null) {
-      result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));
-    }
-    return Collections.unmodifiableMap(result);
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java
deleted file mode 100644
index b4b2f68347..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import okhttp3.Request;
-import okio.Buffer;
-import okio.BufferedSink;
-
-/**
- * This request body involves an application thread only. First all bytes are written to the buffer.
- * Only once that is complete are bytes then copied to the network.
- *
- * <p>This body has two special powers. First, it can retransmit the same request body multiple
- * times in order to recover from failures or cope with redirects. Second, it can compute the total
- * length of the request body by measuring it after it has been written to the output stream.
- */
-final class BufferedRequestBody extends OutputStreamRequestBody {
-  final Buffer buffer = new Buffer();
-  long contentLength = -1L;
-
-  BufferedRequestBody(long expectedContentLength) {
-    initOutputStream(buffer, expectedContentLength);
-  }
-
-  @Override public long contentLength() throws IOException {
-    return contentLength;
-  }
-
-  /**
-   * Now that we've buffered the entire request body, update the request headers and the body
-   * itself. This happens late to enable HttpURLConnection users to complete the socket connection
-   * before sending request body bytes.
-   */
-  @Override public Request prepareToSendRequest(Request request) throws IOException {
-    if (request.header("Content-Length") != null) return request;
-
-    outputStream().close();
-    contentLength = buffer.size();
-    return request.newBuilder()
-        .removeHeader("Transfer-Encoding")
-        .header("Content-Length", Long.toString(buffer.size()))
-        .build();
-  }
-
-  @Override public void writeTo(BufferedSink sink) throws IOException {
-    buffer.copyTo(sink.buffer(), 0, buffer.size());
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
deleted file mode 100644
index ae066f64b7..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.URL;
-import java.security.Permission;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.util.List;
-import java.util.Map;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Handshake;
-import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
-
-/**
- * Implement an HTTPS connection by delegating to an HTTP connection for everything but the
- * HTTPS-specific stuff.
- */
-abstract class DelegatingHttpsURLConnection extends HttpsURLConnection {
-  private final HttpURLConnection delegate;
-
-  DelegatingHttpsURLConnection(HttpURLConnection delegate) {
-    super(delegate.getURL());
-    this.delegate = delegate;
-  }
-
-  protected abstract Handshake handshake();
-
-  @Override public abstract void setHostnameVerifier(HostnameVerifier hostnameVerifier);
-
-  @Override public abstract HostnameVerifier getHostnameVerifier();
-
-  @Override public abstract void setSSLSocketFactory(SSLSocketFactory sslSocketFactory);
-
-  @Override public abstract SSLSocketFactory getSSLSocketFactory();
-
-  @Override public String getCipherSuite() {
-    Handshake handshake = handshake();
-    return handshake != null ? handshake.cipherSuite().javaName() : null;
-  }
-
-  @Override public Certificate[] getLocalCertificates() {
-    Handshake handshake = handshake();
-    if (handshake == null) return null;
-    List<Certificate> result = handshake.localCertificates();
-    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
-  }
-
-  @Override public Certificate[] getServerCertificates() throws SSLPeerUnverifiedException {
-    Handshake handshake = handshake();
-    if (handshake == null) return null;
-    List<Certificate> result = handshake.peerCertificates();
-    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
-  }
-
-  @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-    Handshake handshake = handshake();
-    return handshake != null ? handshake.peerPrincipal() : null;
-  }
-
-  @Override public Principal getLocalPrincipal() {
-    Handshake handshake = handshake();
-    return handshake != null ? handshake.localPrincipal() : null;
-  }
-
-  @Override public void connect() throws IOException {
-    connected = true;
-    delegate.connect();
-  }
-
-  @Override public void disconnect() {
-    delegate.disconnect();
-  }
-
-  @Override public InputStream getErrorStream() {
-    return delegate.getErrorStream();
-  }
-
-  @Override public String getRequestMethod() {
-    return delegate.getRequestMethod();
-  }
-
-  @Override public int getResponseCode() throws IOException {
-    return delegate.getResponseCode();
-  }
-
-  @Override public String getResponseMessage() throws IOException {
-    return delegate.getResponseMessage();
-  }
-
-  @Override public void setRequestMethod(String method) throws ProtocolException {
-    delegate.setRequestMethod(method);
-  }
-
-  @Override public boolean usingProxy() {
-    return delegate.usingProxy();
-  }
-
-  @Override public boolean getInstanceFollowRedirects() {
-    return delegate.getInstanceFollowRedirects();
-  }
-
-  @Override public void setInstanceFollowRedirects(boolean followRedirects) {
-    delegate.setInstanceFollowRedirects(followRedirects);
-  }
-
-  @Override public boolean getAllowUserInteraction() {
-    return delegate.getAllowUserInteraction();
-  }
-
-  @Override public Object getContent() throws IOException {
-    return delegate.getContent();
-  }
-
-  @Override public Object getContent(Class[] types) throws IOException {
-    return delegate.getContent(types);
-  }
-
-  @Override public String getContentEncoding() {
-    return delegate.getContentEncoding();
-  }
-
-  @Override public int getContentLength() {
-    return delegate.getContentLength();
-  }
-
-  @IgnoreJRERequirement // Should only be invoked on Java 8+ or Android API 24+.
-  @Override public long getContentLengthLong() {
-    return delegate.getContentLengthLong();
-  }
-
-  @Override public String getContentType() {
-    return delegate.getContentType();
-  }
-
-  @Override public long getDate() {
-    return delegate.getDate();
-  }
-
-  @Override public boolean getDefaultUseCaches() {
-    return delegate.getDefaultUseCaches();
-  }
-
-  @Override public boolean getDoInput() {
-    return delegate.getDoInput();
-  }
-
-  @Override public boolean getDoOutput() {
-    return delegate.getDoOutput();
-  }
-
-  @Override public long getExpiration() {
-    return delegate.getExpiration();
-  }
-
-  @Override public String getHeaderField(int pos) {
-    return delegate.getHeaderField(pos);
-  }
-
-  @Override public Map<String, List<String>> getHeaderFields() {
-    return delegate.getHeaderFields();
-  }
-
-  @Override public Map<String, List<String>> getRequestProperties() {
-    return delegate.getRequestProperties();
-  }
-
-  @Override public void addRequestProperty(String field, String newValue) {
-    delegate.addRequestProperty(field, newValue);
-  }
-
-  @Override public String getHeaderField(String key) {
-    return delegate.getHeaderField(key);
-  }
-
-  @IgnoreJRERequirement // Should only be invoked on Java 8+ or Android API 24+.
-  @Override public long getHeaderFieldLong(String field, long defaultValue) {
-    return delegate.getHeaderFieldLong(field, defaultValue);
-  }
-
-  @Override public long getHeaderFieldDate(String field, long defaultValue) {
-    return delegate.getHeaderFieldDate(field, defaultValue);
-  }
-
-  @Override public int getHeaderFieldInt(String field, int defaultValue) {
-    return delegate.getHeaderFieldInt(field, defaultValue);
-  }
-
-  @Override public String getHeaderFieldKey(int position) {
-    return delegate.getHeaderFieldKey(position);
-  }
-
-  @Override public long getIfModifiedSince() {
-    return delegate.getIfModifiedSince();
-  }
-
-  @Override public InputStream getInputStream() throws IOException {
-    return delegate.getInputStream();
-  }
-
-  @Override public long getLastModified() {
-    return delegate.getLastModified();
-  }
-
-  @Override public OutputStream getOutputStream() throws IOException {
-    return delegate.getOutputStream();
-  }
-
-  @Override public Permission getPermission() throws IOException {
-    return delegate.getPermission();
-  }
-
-  @Override public String getRequestProperty(String field) {
-    return delegate.getRequestProperty(field);
-  }
-
-  @Override public URL getURL() {
-    return delegate.getURL();
-  }
-
-  @Override public boolean getUseCaches() {
-    return delegate.getUseCaches();
-  }
-
-  @Override public void setAllowUserInteraction(boolean newValue) {
-    delegate.setAllowUserInteraction(newValue);
-  }
-
-  @Override public void setDefaultUseCaches(boolean newValue) {
-    delegate.setDefaultUseCaches(newValue);
-  }
-
-  @Override public void setDoInput(boolean newValue) {
-    delegate.setDoInput(newValue);
-  }
-
-  @Override public void setDoOutput(boolean newValue) {
-    delegate.setDoOutput(newValue);
-  }
-
-  @IgnoreJRERequirement // Should only be invoked on Java 8+ or Android API 24+.
-  @Override public void setFixedLengthStreamingMode(long contentLength) {
-    delegate.setFixedLengthStreamingMode(contentLength);
-  }
-
-  @Override public void setIfModifiedSince(long newValue) {
-    delegate.setIfModifiedSince(newValue);
-  }
-
-  @Override public void setRequestProperty(String field, String newValue) {
-    delegate.setRequestProperty(field, newValue);
-  }
-
-  @Override public void setUseCaches(boolean newValue) {
-    delegate.setUseCaches(newValue);
-  }
-
-  @Override public void setConnectTimeout(int timeoutMillis) {
-    delegate.setConnectTimeout(timeoutMillis);
-  }
-
-  @Override public int getConnectTimeout() {
-    return delegate.getConnectTimeout();
-  }
-
-  @Override public void setReadTimeout(int timeoutMillis) {
-    delegate.setReadTimeout(timeoutMillis);
-  }
-
-  @Override public int getReadTimeout() {
-    return delegate.getReadTimeout();
-  }
-
-  @Override public String toString() {
-    return delegate.toString();
-  }
-
-  @Override public void setFixedLengthStreamingMode(int contentLength) {
-    delegate.setFixedLengthStreamingMode(contentLength);
-  }
-
-  @Override public void setChunkedStreamingMode(int chunkLength) {
-    delegate.setChunkedStreamingMode(chunkLength);
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
deleted file mode 100644
index 1286cb7f53..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
+++ /dev/null
@@ -1,675 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InterruptedIOException;
-import java.io.OutputStream;
-import java.net.HttpURLConnection;
-import java.net.InetSocketAddress;
-import java.net.MalformedURLException;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.SocketPermission;
-import java.net.URL;
-import java.net.UnknownHostException;
-import java.security.Permission;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.Dispatcher;
-import okhttp3.Handshake;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Internal;
-import okhttp3.internal.JavaNetHeaders;
-import okhttp3.internal.URLFilter;
-import okhttp3.internal.Util;
-import okhttp3.internal.Version;
-import okhttp3.internal.http.HttpDate;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.StatusLine;
-import okhttp3.internal.platform.Platform;
-import okio.Buffer;
-
-import static okhttp3.internal.platform.Platform.WARN;
-
-/**
- * This implementation uses {@linkplain Call} to send requests and receive responses.
- *
- * <h3>What does 'connected' mean?</h3> This class inherits a {@code connected} field from the
- * superclass. That field is <strong>not</strong> used to indicate whether this URLConnection is
- * currently connected. Instead, it indicates whether a connection has ever been attempted. Once a
- * connection has been attempted, certain properties (request header fields, request method, etc.)
- * are immutable.
- */
-public final class OkHttpURLConnection extends HttpURLConnection implements Callback {
-  /**
-   * Synthetic response header: the selected {@link Protocol protocol} ("spdy/3.1", "http/1.1",
-   * etc).
-   */
-  public static final String SELECTED_PROTOCOL = Platform.get().getPrefix() + "-Selected-Protocol";
-
-  /** Synthetic response header: the location from which the response was loaded. */
-  public static final String RESPONSE_SOURCE = Platform.get().getPrefix() + "-Response-Source";
-
-  private static final Set<String> METHODS = new LinkedHashSet<>(
-      Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
-
-  // These fields are confined to the application thread that uses HttpURLConnection.
-
-  OkHttpClient client;
-  private final NetworkInterceptor networkInterceptor = new NetworkInterceptor();
-  private Headers.Builder requestHeaders = new Headers.Builder();
-  private boolean executed;
-  Call call;
-  URLFilter urlFilter;
-
-  /** Lazily created (with synthetic headers) on first call to getHeaders(). */
-  private Headers responseHeaders;
-
-  /** Like the superclass field of the same name, but a long and available on all platforms. */
-  private long fixedContentLength = -1L;
-
-  // These fields are guarded by lock.
-  private final Object lock = new Object();
-  private Response response;
-  private Throwable callFailure;
-  Response networkResponse;
-  boolean connectPending = true;
-  Proxy proxy;
-  Handshake handshake;
-
-  public OkHttpURLConnection(URL url, OkHttpClient client) {
-    super(url);
-    this.client = client;
-  }
-
-  public OkHttpURLConnection(URL url, OkHttpClient client, URLFilter urlFilter) {
-    this(url, client);
-    this.urlFilter = urlFilter;
-  }
-
-  @Override public void connect() throws IOException {
-    if (executed) return;
-
-    Call call = buildCall();
-    executed = true;
-    call.enqueue(this);
-
-    synchronized (lock) {
-      try {
-        while (connectPending && response == null && callFailure == null) {
-          lock.wait(); // Wait 'til the network interceptor is reached or the call fails.
-        }
-        if (callFailure != null) {
-          throw propagate(callFailure);
-        }
-      } catch (InterruptedException e) {
-        Thread.currentThread().interrupt(); // Retain interrupted status.
-        throw new InterruptedIOException();
-      }
-    }
-  }
-
-  @Override public void disconnect() {
-    // Calling disconnect() before a connection exists should have no effect.
-    if (call == null) return;
-
-    networkInterceptor.proceed(); // Unblock any waiting async thread.
-    call.cancel();
-  }
-
-  /**
-   * Returns an input stream from the server in the case of error such as the requested file (txt,
-   * htm, html) is not found on the remote server.
-   */
-  @Override public InputStream getErrorStream() {
-    try {
-      Response response = getResponse(true);
-      if (HttpHeaders.hasBody(response) && response.code() >= HTTP_BAD_REQUEST) {
-        return response.body().byteStream();
-      }
-      return null;
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  private Headers getHeaders() throws IOException {
-    if (responseHeaders == null) {
-      Response response = getResponse(true);
-      Headers headers = response.headers();
-      responseHeaders = headers.newBuilder()
-          .add(SELECTED_PROTOCOL, response.protocol().toString())
-          .add(RESPONSE_SOURCE, responseSourceHeader(response))
-          .build();
-    }
-    return responseHeaders;
-  }
-
-  private static String responseSourceHeader(Response response) {
-    if (response.networkResponse() == null) {
-      if (response.cacheResponse() == null) {
-        return "NONE";
-      }
-      return "CACHE " + response.code();
-    }
-    if (response.cacheResponse() == null) {
-      return "NETWORK " + response.code();
-    }
-    return "CONDITIONAL_CACHE " + response.networkResponse().code();
-  }
-
-  /**
-   * Returns the value of the field at {@code position}. Returns null if there are fewer than {@code
-   * position} headers.
-   */
-  @Override public String getHeaderField(int position) {
-    try {
-      Headers headers = getHeaders();
-      if (position < 0 || position >= headers.size()) return null;
-      return headers.value(position);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Returns the value of the field corresponding to the {@code fieldName}, or null if there is no
-   * such field. If the field has multiple values, the last value is returned.
-   */
-  @Override public String getHeaderField(String fieldName) {
-    try {
-      return fieldName == null
-          ? StatusLine.get(getResponse(true)).toString()
-          : getHeaders().get(fieldName);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  @Override public String getHeaderFieldKey(int position) {
-    try {
-      Headers headers = getHeaders();
-      if (position < 0 || position >= headers.size()) return null;
-      return headers.name(position);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  @Override public Map<String, List<String>> getHeaderFields() {
-    try {
-      return JavaNetHeaders.toMultimap(getHeaders(),
-          StatusLine.get(getResponse(true)).toString());
-    } catch (IOException e) {
-      return Collections.emptyMap();
-    }
-  }
-
-  @Override public Map<String, List<String>> getRequestProperties() {
-    if (connected) {
-      throw new IllegalStateException(
-          "Cannot access request header fields after connection is set");
-    }
-
-    return JavaNetHeaders.toMultimap(requestHeaders.build(), null);
-  }
-
-  @Override public InputStream getInputStream() throws IOException {
-    if (!doInput) {
-      throw new ProtocolException("This protocol does not support input");
-    }
-
-    Response response = getResponse(false);
-
-    if (response.code() >= HTTP_BAD_REQUEST) {
-      throw new FileNotFoundException(url.toString());
-    }
-
-    return response.body().byteStream();
-  }
-
-  @Override public OutputStream getOutputStream() throws IOException {
-    OutputStreamRequestBody requestBody = (OutputStreamRequestBody) buildCall().request().body();
-    if (requestBody == null) {
-      throw new ProtocolException("method does not support a request body: " + method);
-    }
-
-    // If this request needs to stream bytes to the server, build a physical connection immediately
-    // and start streaming those bytes over that connection.
-    if (requestBody instanceof StreamedRequestBody) {
-      connect();
-      networkInterceptor.proceed();
-    }
-
-    if (requestBody.isClosed()) {
-      throw new ProtocolException("cannot write request body after response has been read");
-    }
-
-    return requestBody.outputStream();
-  }
-
-  @Override public Permission getPermission() throws IOException {
-    URL url = getURL();
-    String hostname = url.getHost();
-    int hostPort = url.getPort() != -1
-        ? url.getPort()
-        : HttpUrl.defaultPort(url.getProtocol());
-    if (usingProxy()) {
-      InetSocketAddress proxyAddress = (InetSocketAddress) client.proxy().address();
-      hostname = proxyAddress.getHostName();
-      hostPort = proxyAddress.getPort();
-    }
-    return new SocketPermission(hostname + ":" + hostPort, "connect, resolve");
-  }
-
-  @Override public String getRequestProperty(String field) {
-    if (field == null) return null;
-    return requestHeaders.get(field);
-  }
-
-  @Override public void setConnectTimeout(int timeoutMillis) {
-    client = client.newBuilder()
-        .connectTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
-        .build();
-  }
-
-  @Override public void setInstanceFollowRedirects(boolean followRedirects) {
-    client = client.newBuilder()
-        .followRedirects(followRedirects)
-        .build();
-  }
-
-  @Override public boolean getInstanceFollowRedirects() {
-    return client.followRedirects();
-  }
-
-  @Override public int getConnectTimeout() {
-    return client.connectTimeoutMillis();
-  }
-
-  @Override public void setReadTimeout(int timeoutMillis) {
-    client = client.newBuilder()
-        .readTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
-        .build();
-  }
-
-  @Override public int getReadTimeout() {
-    return client.readTimeoutMillis();
-  }
-
-  private Call buildCall() throws IOException {
-    if (call != null) {
-      return call;
-    }
-
-    connected = true;
-    if (doOutput) {
-      if (method.equals("GET")) {
-        // they are requesting a stream to write to. This implies a POST method
-        method = "POST";
-      } else if (!HttpMethod.permitsRequestBody(method)) {
-        throw new ProtocolException(method + " does not support writing");
-      }
-    }
-
-    if (requestHeaders.get("User-Agent") == null) {
-      requestHeaders.add("User-Agent", defaultUserAgent());
-    }
-
-    OutputStreamRequestBody requestBody = null;
-    if (HttpMethod.permitsRequestBody(method)) {
-      // Add a content type for the request body, if one isn't already present.
-      String contentType = requestHeaders.get("Content-Type");
-      if (contentType == null) {
-        contentType = "application/x-www-form-urlencoded";
-        requestHeaders.add("Content-Type", contentType);
-      }
-
-      boolean stream = fixedContentLength != -1L || chunkLength > 0;
-
-      long contentLength = -1L;
-      String contentLengthString = requestHeaders.get("Content-Length");
-      if (fixedContentLength != -1L) {
-        contentLength = fixedContentLength;
-      } else if (contentLengthString != null) {
-        contentLength = Long.parseLong(contentLengthString);
-      }
-
-      requestBody = stream
-          ? new StreamedRequestBody(contentLength)
-          : new BufferedRequestBody(contentLength);
-      requestBody.timeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
-    }
-
-    HttpUrl url;
-    try {
-      url = HttpUrl.get(getURL().toString());
-    } catch (IllegalArgumentException e) {
-      if (Internal.instance.isInvalidHttpUrlHost(e)) {
-        UnknownHostException unknownHost = new UnknownHostException();
-        unknownHost.initCause(e);
-        throw unknownHost;
-      }
-      MalformedURLException malformedUrl = new MalformedURLException();
-      malformedUrl.initCause(e);
-      throw malformedUrl;
-    }
-
-    Request request = new Request.Builder()
-        .url(url)
-        .headers(requestHeaders.build())
-        .method(method, requestBody)
-        .build();
-
-    if (urlFilter != null) {
-      urlFilter.checkURLPermitted(request.url().url());
-    }
-
-    OkHttpClient.Builder clientBuilder = client.newBuilder();
-    clientBuilder.interceptors().clear();
-    clientBuilder.interceptors().add(UnexpectedException.INTERCEPTOR);
-    clientBuilder.networkInterceptors().clear();
-    clientBuilder.networkInterceptors().add(networkInterceptor);
-
-    // Use a separate dispatcher so that limits aren't impacted. But use the same executor service!
-    clientBuilder.dispatcher(new Dispatcher(client.dispatcher().executorService()));
-
-    // If we're currently not using caches, make sure the engine's client doesn't have one.
-    if (!getUseCaches()) {
-      clientBuilder.cache(null);
-    }
-
-    return call = clientBuilder.build().newCall(request);
-  }
-
-  private String defaultUserAgent() {
-    String agent = Util.getSystemProperty("http.agent", null);
-    return agent != null ? toHumanReadableAscii(agent) : Version.userAgent();
-  }
-
-  /** Returns {@code s} with control characters and non-ASCII characters replaced with '?'. */
-  private static String toHumanReadableAscii(String s) {
-    for (int i = 0, length = s.length(), c; i < length; i += Character.charCount(c)) {
-      c = s.codePointAt(i);
-      if (c > '\u001f' && c < '\u007f') continue;
-
-      Buffer buffer = new Buffer();
-      buffer.writeUtf8(s, 0, i);
-      buffer.writeUtf8CodePoint('?');
-      for (int j = i + Character.charCount(c); j < length; j += Character.charCount(c)) {
-        c = s.codePointAt(j);
-        buffer.writeUtf8CodePoint(c > '\u001f' && c < '\u007f' ? c : '?');
-      }
-      return buffer.readUtf8();
-    }
-    return s;
-  }
-
-  /**
-   * Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the
-   * process in order to cope with redirects and authentication.
-   */
-  private Response getResponse(boolean networkResponseOnError) throws IOException {
-    synchronized (lock) {
-      if (response != null) return response;
-      if (callFailure != null) {
-        if (networkResponseOnError && networkResponse != null) return networkResponse;
-        throw propagate(callFailure);
-      }
-    }
-
-    Call call = buildCall();
-    networkInterceptor.proceed();
-
-    OutputStreamRequestBody requestBody = (OutputStreamRequestBody) call.request().body();
-    if (requestBody != null) requestBody.outputStream().close();
-
-    if (executed) {
-      synchronized (lock) {
-        try {
-          while (response == null && callFailure == null) {
-            lock.wait(); // Wait until the response is returned or the call fails.
-          }
-        } catch (InterruptedException e) {
-          Thread.currentThread().interrupt(); // Retain interrupted status.
-          throw new InterruptedIOException();
-        }
-      }
-    } else {
-      executed = true;
-      try {
-        onResponse(call, call.execute());
-      } catch (IOException e) {
-        onFailure(call, e);
-      }
-    }
-
-    synchronized (lock) {
-      if (callFailure != null) throw propagate(callFailure);
-      if (response != null) return response;
-    }
-
-    throw new AssertionError();
-  }
-
-  /**
-   * Returns true if either:
-   *
-   * <ul>
-   *   <li>A specific proxy was explicitly configured for this connection.
-   *   <li>The response has already been retrieved, and a proxy was {@link
-   *       java.net.ProxySelector selected} in order to get it.
-   * </ul>
-   *
-   * <p><strong>Warning:</strong> This method may return false before attempting to connect and true
-   * afterwards.
-   */
-  @Override public boolean usingProxy() {
-    if (proxy != null) return true;
-    Proxy clientProxy = client.proxy();
-    return clientProxy != null && clientProxy.type() != Proxy.Type.DIRECT;
-  }
-
-  @Override public String getResponseMessage() throws IOException {
-    return getResponse(true).message();
-  }
-
-  @Override public int getResponseCode() throws IOException {
-    return getResponse(true).code();
-  }
-
-  @Override public void setRequestProperty(String field, String newValue) {
-    if (connected) {
-      throw new IllegalStateException("Cannot set request property after connection is made");
-    }
-    if (field == null) {
-      throw new NullPointerException("field == null");
-    }
-    if (newValue == null) {
-      // Silently ignore null header values for backwards compatibility with older
-      // android versions as well as with other URLConnection implementations.
-      //
-      // Some implementations send a malformed HTTP header when faced with
-      // such requests, we respect the spec and ignore the header.
-      Platform.get().log(WARN, "Ignoring header " + field + " because its value was null.", null);
-      return;
-    }
-
-    requestHeaders.set(field, newValue);
-  }
-
-  @Override public void setIfModifiedSince(long newValue) {
-    super.setIfModifiedSince(newValue);
-    if (ifModifiedSince != 0) {
-      requestHeaders.set("If-Modified-Since", HttpDate.format(new Date(ifModifiedSince)));
-    } else {
-      requestHeaders.removeAll("If-Modified-Since");
-    }
-  }
-
-  @Override public void addRequestProperty(String field, String value) {
-    if (connected) {
-      throw new IllegalStateException("Cannot add request property after connection is made");
-    }
-    if (field == null) {
-      throw new NullPointerException("field == null");
-    }
-    if (value == null) {
-      // Silently ignore null header values for backwards compatibility with older
-      // android versions as well as with other URLConnection implementations.
-      //
-      // Some implementations send a malformed HTTP header when faced with
-      // such requests, we respect the spec and ignore the header.
-      Platform.get().log(WARN, "Ignoring header " + field + " because its value was null.", null);
-      return;
-    }
-
-    requestHeaders.add(field, value);
-  }
-
-  @Override public void setRequestMethod(String method) throws ProtocolException {
-    if (!METHODS.contains(method)) {
-      throw new ProtocolException("Expected one of " + METHODS + " but was " + method);
-    }
-    this.method = method;
-  }
-
-  @Override public void setFixedLengthStreamingMode(int contentLength) {
-    setFixedLengthStreamingMode((long) contentLength);
-  }
-
-  @Override public void setFixedLengthStreamingMode(long contentLength) {
-    if (super.connected) throw new IllegalStateException("Already connected");
-    if (chunkLength > 0) throw new IllegalStateException("Already in chunked mode");
-    if (contentLength < 0) throw new IllegalArgumentException("contentLength < 0");
-    this.fixedContentLength = contentLength;
-    super.fixedContentLength = (int) Math.min(contentLength, Integer.MAX_VALUE);
-  }
-
-  @Override public void onFailure(Call call, IOException e) {
-    synchronized (lock) {
-      this.callFailure = (e instanceof UnexpectedException) ? e.getCause() : e;
-      lock.notifyAll();
-    }
-  }
-
-  @Override public void onResponse(Call call, Response response) {
-    synchronized (lock) {
-      this.response = response;
-      this.handshake = response.handshake();
-      this.url = response.request().url().url();
-      lock.notifyAll();
-    }
-  }
-
-  static final class UnexpectedException extends IOException {
-    static final Interceptor INTERCEPTOR = chain -> {
-      try {
-        return chain.proceed(chain.request());
-      } catch (Error | RuntimeException e) {
-        throw new UnexpectedException(e);
-      }
-    };
-
-    UnexpectedException(Throwable cause) {
-      super(cause);
-    }
-  }
-
-  /** Throws {@code throwable} as either an IOException, RuntimeException, or Error. */
-  private static IOException propagate(Throwable throwable) throws IOException {
-    if (throwable instanceof IOException) throw (IOException) throwable;
-    if (throwable instanceof Error) throw (Error) throwable;
-    if (throwable instanceof RuntimeException) throw (RuntimeException) throwable;
-    throw new AssertionError();
-  }
-
-  /**
-   * The HttpURLConnection gives the application control between establishing the connection and
-   * transmitting the request body. This interceptor stalls async calls right at this point. The
-   * call will remain stalled until {@link #proceed()} is called.
-   */
-  final class NetworkInterceptor implements Interceptor {
-    // Guarded by HttpUrlConnection.this.
-    private boolean proceed;
-
-    public void proceed() {
-      synchronized (lock) {
-        this.proceed = true;
-        lock.notifyAll();
-      }
-    }
-
-    @Override public Response intercept(Chain chain) throws IOException {
-      Request request = chain.request();
-
-      // Double-check the URL filter to prevent redirects from hitting filtered URLs.
-      if (urlFilter != null) {
-        urlFilter.checkURLPermitted(request.url().url());
-      }
-
-      synchronized (lock) {
-        connectPending = false;
-        proxy = chain.connection().route().proxy();
-        handshake = chain.connection().handshake();
-        lock.notifyAll();
-
-        try {
-          while (!proceed) {
-            lock.wait(); // Wait until proceed() is called.
-          }
-        } catch (InterruptedException e) {
-          Thread.currentThread().interrupt(); // Retain interrupted status.
-          throw new InterruptedIOException();
-        }
-      }
-
-      // Try to lock in the Content-Length before transmitting the request body.
-      if (request.body() instanceof OutputStreamRequestBody) {
-        OutputStreamRequestBody requestBody = (OutputStreamRequestBody) request.body();
-        request = requestBody.prepareToSendRequest(request);
-      }
-
-      Response response = chain.proceed(request);
-
-      synchronized (lock) {
-        networkResponse = response;
-        url = response.request().url().url();
-      }
-
-      return response;
-    }
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
deleted file mode 100644
index 9dc40b80a2..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.net.URL;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Handshake;
-import okhttp3.OkHttpClient;
-import okhttp3.internal.URLFilter;
-
-public final class OkHttpsURLConnection extends DelegatingHttpsURLConnection {
-  private final OkHttpURLConnection delegate;
-
-  public OkHttpsURLConnection(URL url, OkHttpClient client) {
-    this(new OkHttpURLConnection(url, client));
-  }
-
-  public OkHttpsURLConnection(URL url, OkHttpClient client, URLFilter filter) {
-    this(new OkHttpURLConnection(url, client, filter));
-  }
-
-  public OkHttpsURLConnection(OkHttpURLConnection delegate) {
-    super(delegate);
-    this.delegate = delegate;
-  }
-
-  @Override protected Handshake handshake() {
-    if (delegate.call == null) {
-      throw new IllegalStateException("Connection has not yet been established");
-    }
-
-    return delegate.handshake;
-  }
-
-  @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
-    delegate.client = delegate.client.newBuilder()
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-  }
-
-  @Override public HostnameVerifier getHostnameVerifier() {
-    return delegate.client.hostnameVerifier();
-  }
-
-  @Override public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
-    if (sslSocketFactory == null) {
-      throw new IllegalArgumentException("sslSocketFactory == null");
-    }
-    // This fails in JDK 9 because OkHttp is unable to extract the trust manager.
-    delegate.client = delegate.client.newBuilder()
-        .sslSocketFactory(sslSocketFactory)
-        .build();
-  }
-
-  @Override public SSLSocketFactory getSSLSocketFactory() {
-    return delegate.client.sslSocketFactory();
-  }
-
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java
deleted file mode 100644
index 6f4e8ef9e9..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.io.OutputStream;
-import java.net.ProtocolException;
-import java.net.SocketTimeoutException;
-import okhttp3.MediaType;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okio.BufferedSink;
-import okio.Timeout;
-
-/**
- * A request body that's populated by blocking writes to an output stream. The output data is either
- * fully buffered (with {@link BufferedRequestBody}) or streamed (with {@link StreamedRequestBody}).
- * In either case the bytes of the body aren't known until the caller writes them to the output
- * stream.
- */
-abstract class OutputStreamRequestBody extends RequestBody {
-  private Timeout timeout;
-  private long expectedContentLength;
-  private OutputStream outputStream;
-  boolean closed;
-
-  protected void initOutputStream(final BufferedSink sink, final long expectedContentLength) {
-    this.timeout = sink.timeout();
-    this.expectedContentLength = expectedContentLength;
-
-    // An output stream that writes to sink. If expectedContentLength is not -1, then this expects
-    // exactly that many bytes to be written.
-    this.outputStream = new OutputStream() {
-      private long bytesReceived;
-
-      @Override public void write(int b) throws IOException {
-        write(new byte[] {(byte) b}, 0, 1);
-      }
-
-      @Override public void write(byte[] source, int offset, int byteCount) throws IOException {
-        if (closed) throw new IOException("closed"); // Not IllegalStateException!
-
-        if (expectedContentLength != -1L && bytesReceived + byteCount > expectedContentLength) {
-          throw new ProtocolException("expected " + expectedContentLength
-              + " bytes but received " + bytesReceived + byteCount);
-        }
-
-        bytesReceived += byteCount;
-        try {
-          sink.write(source, offset, byteCount);
-        } catch (InterruptedIOException e) {
-          throw new SocketTimeoutException(e.getMessage());
-        }
-      }
-
-      @Override public void flush() throws IOException {
-        if (closed) return; // Weird, but consistent with historical behavior.
-        sink.flush();
-      }
-
-      @Override public void close() throws IOException {
-        closed = true;
-
-        if (expectedContentLength != -1L && bytesReceived < expectedContentLength) {
-          throw new ProtocolException("expected " + expectedContentLength
-              + " bytes but received " + bytesReceived);
-        }
-
-        sink.close();
-      }
-    };
-  }
-
-  public final OutputStream outputStream() {
-    return outputStream;
-  }
-
-  public final Timeout timeout() {
-    return timeout;
-  }
-
-  public final boolean isClosed() {
-    return closed;
-  }
-
-  @Override public long contentLength() throws IOException {
-    return expectedContentLength;
-  }
-
-  @Override public final MediaType contentType() {
-    return null; // Let the caller provide this in a regular header.
-  }
-
-  public Request prepareToSendRequest(Request request) throws IOException {
-    return request;
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java
deleted file mode 100644
index 201ab09b66..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import okhttp3.internal.http.UnrepeatableRequestBody;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.Okio;
-import okio.Pipe;
-
-/**
- * This request body streams bytes from an application thread to an OkHttp dispatcher thread via a
- * pipe. Because the data is not buffered it can only be transmitted once.
- */
-final class StreamedRequestBody extends OutputStreamRequestBody implements UnrepeatableRequestBody {
-  private final Pipe pipe = new Pipe(8192);
-
-  StreamedRequestBody(long expectedContentLength) {
-    initOutputStream(Okio.buffer(pipe.sink()), expectedContentLength);
-  }
-
-  @Override public void writeTo(BufferedSink sink) throws IOException {
-    Buffer buffer = new Buffer();
-    while (pipe.source().read(buffer, 8192) != -1L) {
-      sink.write(buffer, buffer.size());
-    }
-  }
-}
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
deleted file mode 100644
index 1476dc69c4..0000000000
--- a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
+++ /dev/null
@@ -1,298 +0,0 @@
-package okhttp3;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.net.UnknownHostException;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-import java.util.TimeZone;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.HttpsURLConnection;
-import okhttp3.internal.huc.OkHttpURLConnection;
-import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.tls.HandshakeCertificates;
-import okio.BufferedSource;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.nio.charset.StandardCharsets.US_ASCII;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static okio.Okio.buffer;
-import static okio.Okio.source;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-public class OkUrlFactoryTest {
-  @Rule public MockWebServer server = new MockWebServer();
-  @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
-
-  private OkUrlFactory factory;
-  private Cache cache;
-
-  @Before public void setUp() {
-    cache = new Cache(new File("/cache/"), 10 * 1024 * 1024, fileSystem);
-    OkHttpClient client = new OkHttpClient.Builder()
-        .cache(cache)
-        .build();
-    factory = new OkUrlFactory(client);
-  }
-
-  @After public void tearDown() throws IOException {
-    cache.delete();
-  }
-
-  /**
-   * Response code 407 should only come from proxy servers. Android's client throws if it is sent by
-   * an origin server.
-   */
-  @Test public void originServerSends407() {
-    server.enqueue(new MockResponse().setResponseCode(407));
-
-    HttpURLConnection conn = factory.open(server.url("/").url());
-    try {
-      conn.getResponseCode();
-      fail();
-    } catch (IOException ignored) {
-    }
-  }
-
-  @Test public void networkResponseSourceHeader() throws Exception {
-    server.enqueue(new MockResponse().setBody("Isla Sorna"));
-
-    HttpURLConnection connection = factory.open(server.url("/").url());
-    assertResponseHeader(connection, "NETWORK 200");
-    assertResponseBody(connection, "Isla Sorna");
-  }
-
-  @Test public void networkFailureResponseSourceHeader() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    HttpURLConnection connection = factory.open(server.url("/").url());
-    assertResponseHeader(connection, "NETWORK 404");
-    connection.getErrorStream().close();
-  }
-
-  @Test public void conditionalCacheHitResponseSourceHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("Isla Nublar"));
-    server.enqueue(new MockResponse().setResponseCode(304));
-
-    HttpURLConnection connection1 = factory.open(server.url("/").url());
-    assertResponseHeader(connection1, "NETWORK 200");
-    assertResponseBody(connection1, "Isla Nublar");
-
-    HttpURLConnection connection2 = factory.open(server.url("/").url());
-    assertResponseHeader(connection2, "CONDITIONAL_CACHE 304");
-    assertResponseBody(connection2, "Isla Nublar");
-  }
-
-  @Test public void conditionalCacheMissResponseSourceHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("Isla Nublar"));
-    server.enqueue(new MockResponse().setBody("Isla Sorna"));
-
-    HttpURLConnection connection1 = factory.open(server.url("/").url());
-    assertResponseHeader(connection1, "NETWORK 200");
-    assertResponseBody(connection1, "Isla Nublar");
-
-    HttpURLConnection connection2 = factory.open(server.url("/").url());
-    assertResponseHeader(connection2, "CONDITIONAL_CACHE 200");
-    assertResponseBody(connection2, "Isla Sorna");
-  }
-
-  @Test public void cacheResponseSourceHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Expires: " + formatDate(2, TimeUnit.HOURS))
-        .setBody("Isla Nublar"));
-
-    HttpURLConnection connection1 = factory.open(server.url("/").url());
-    assertResponseHeader(connection1, "NETWORK 200");
-    assertResponseBody(connection1, "Isla Nublar");
-
-    HttpURLConnection connection2 = factory.open(server.url("/").url());
-    assertResponseHeader(connection2, "CACHE 200");
-    assertResponseBody(connection2, "Isla Nublar");
-  }
-
-  @Test public void noneResponseSourceHeaders() throws Exception {
-    server.enqueue(new MockResponse().setBody("Isla Nublar"));
-
-    HttpURLConnection connection1 = factory.open(server.url("/").url());
-    assertResponseHeader(connection1, "NETWORK 200");
-    assertResponseBody(connection1, "Isla Nublar");
-
-    HttpURLConnection connection2 = factory.open(server.url("/").url());
-    connection2.setRequestProperty("Cache-Control", "only-if-cached");
-    assertResponseHeader(connection2, "NONE");
-  }
-
-  @Test
-  public void setInstanceFollowRedirectsFalse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /b")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpURLConnection connection = factory.open(server.url("/a").url());
-    connection.setInstanceFollowRedirects(false);
-    assertResponseBody(connection, "A");
-    assertResponseCode(connection, 302);
-  }
-
-  @Test
-  public void testURLFilter() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-    final URL blockedURL = server.url("/a").url();
-    factory.setUrlFilter(url -> {
-      if (blockedURL.equals(url)) throw new IOException("Blocked");
-    });
-    try {
-      HttpURLConnection connection = factory.open(server.url("/a").url());
-      connection.getInputStream();
-      fail("Connection was successful");
-    } catch (IOException e) {
-      assertEquals("Blocked", e.getMessage());
-    }
-    HttpURLConnection connection = factory.open(server.url("/b").url());
-    assertResponseBody(connection, "B");
-  }
-
-  @Test
-  public void testURLFilterRedirect() {
-    MockWebServer cleartextServer = new MockWebServer();
-    cleartextServer.enqueue(new MockResponse()
-        .setBody("Blocked!"));
-    final URL blockedURL = cleartextServer.url("/").url();
-
-    HandshakeCertificates handshakeCertificates = localhost();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    factory.setClient(factory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .followSslRedirects(true)
-        .build());
-    factory.setUrlFilter(url -> {
-      if (blockedURL.equals(url)) throw new IOException("Blocked");
-    });
-
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: " + blockedURL)
-        .setBody("This page has moved"));
-    URL destination = server.url("/").url();
-    try {
-      HttpsURLConnection httpsConnection = (HttpsURLConnection) factory.open(destination);
-      httpsConnection.getInputStream();
-      fail("Connection was successful");
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void usesValidHeaderValueForDefaultUserAgent() throws Exception {
-    String userAgent =  " " + "\u001F" + ('\u001f' + 1) + ('\u007f' - 1)+ '\u007f' + " ";
-    String expected = "? ?" + ('\u001f' + 1) + ('\u007f' - 1) + "? ?";
-
-    System.setProperty("http.agent", userAgent);
-    server.enqueue(new MockResponse().setResponseCode(200));
-    InputStream inputStream = factory.open(server.url("/").url()).getInputStream();
-    long skipped;
-    do {
-      skipped = inputStream.skip(Long.MAX_VALUE);
-    } while (skipped != 0);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(expected, recordedRequest.getHeader("User-Agent"));
-  }
-
-  @Test public void usesSimpleDefaultUserAgentWithoutModification() throws Exception {
-    String userAgent = "OkHttp";
-    String expected = "OkHttp";
-
-    System.setProperty("http.agent", userAgent);
-    server.enqueue(new MockResponse().setResponseCode(200));
-    InputStream inputStream = factory.open(server.url("/").url()).getInputStream();
-    long skipped;
-    do {
-      skipped = inputStream.skip(Long.MAX_VALUE);
-    } while (skipped != 0);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(expected, recordedRequest.getHeader("User-Agent"));
-  }
-
-  @Test public void handlesBadUnicodeStringsInDefaultUserAgent() throws Exception {
-    String userAgent =  "".substring(0, 1);
-    String expected = "?";
-
-    System.setProperty("http.agent", userAgent);
-    server.enqueue(new MockResponse().setResponseCode(200));
-    InputStream inputStream = factory.open(server.url("/").url()).getInputStream();
-    long skipped;
-    do {
-      skipped = inputStream.skip(Long.MAX_VALUE);
-    } while (skipped != 0);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(expected, recordedRequest.getHeader("User-Agent"));
-  }
-
-  @Test public void javaNetUrlMalformedUrl() throws Exception {
-    server.enqueue(new MockResponse());
-    HttpURLConnection connection = factory.open(new URL("http://example.com:-1"));
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (MalformedURLException expected) {
-    }
-  }
-
-  @Test public void javaNetUrlBadHost() throws Exception {
-    server.enqueue(new MockResponse());
-    HttpURLConnection connection = factory.open(new URL("http://hostw ithspace/"));
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  private void assertResponseBody(HttpURLConnection connection, String expected) throws Exception {
-    BufferedSource source = buffer(source(connection.getInputStream()));
-    String actual = source.readString(US_ASCII);
-    source.close();
-    assertEquals(expected, actual);
-  }
-
-  private void assertResponseHeader(HttpURLConnection connection, String expected) {
-    assertEquals(expected, connection.getHeaderField(OkHttpURLConnection.RESPONSE_SOURCE));
-  }
-
-  private void assertResponseCode(HttpURLConnection connection, int expected) throws IOException {
-    assertEquals(expected, connection.getResponseCode());
-  }
-
-  private static String formatDate(long delta, TimeUnit timeUnit) {
-    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private static String formatDate(Date date) {
-    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
-    return rfc1123.format(date);
-  }
-}
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
deleted file mode 100644
index d9434abddf..0000000000
--- a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
+++ /dev/null
@@ -1,1846 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.CookieManager;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.URL;
-import java.net.URLConnection;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import java.util.TimeZone;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import okhttp3.internal.Internal;
-import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.internal.platform.Platform;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeFalse;
-
-/** Test caching with {@link OkUrlFactory}. */
-public final class UrlConnectionCacheTest {
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = (name, session) -> true;
-
-  @Rule public MockWebServer server = new MockWebServer();
-  @Rule public MockWebServer server2 = new MockWebServer();
-  @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
-
-  private final HandshakeCertificates handshakeCertificates = localhost();
-  private OkUrlFactory urlFactory = new OkUrlFactory(new OkHttpClient());
-  private Cache cache;
-  private final CookieManager cookieManager = new CookieManager();
-
-  @Before public void setUp() {
-    server.setProtocolNegotiationEnabled(false);
-    cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-    urlFactory = new OkUrlFactory(new OkHttpClient.Builder()
-        .cache(cache)
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build());
-  }
-
-  @After public void tearDown() throws Exception {
-    ResponseCache.setDefault(null);
-    cache.delete();
-  }
-
-  @Test public void responseCacheAccessWithOkHttpMember() {
-    assertSame(cache, urlFactory.client().cache());
-  }
-
-  /**
-   * Test that response caching is consistent with the RI and the spec.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
-   */
-  @Test public void responseCachingByResponseCode() throws Exception {
-    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
-    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
-
-    // We can't test 100 because it's not really a response.
-    // assertCached(false, 100);
-    assertCached(false, 101);
-    assertCached(false, 102);
-    assertCached(true, 200);
-    assertCached(false, 201);
-    assertCached(false, 202);
-    assertCached(true, 203);
-    assertCached(true, 204);
-    assertCached(false, 205);
-    assertCached(false, 206); //Electing to not cache partial responses
-    assertCached(false, 207);
-    assertCached(true, 300);
-    assertCached(true, 301);
-    assertCached(true, 302);
-    assertCached(false, 303);
-    assertCached(false, 304);
-    assertCached(false, 305);
-    assertCached(false, 306);
-    assertCached(true, 307);
-    assertCached(true, 308);
-    assertCached(false, 400);
-    assertCached(false, 401);
-    assertCached(false, 402);
-    assertCached(false, 403);
-    assertCached(true, 404);
-    assertCached(true, 405);
-    assertCached(false, 406);
-    assertCached(false, 408);
-    assertCached(false, 409);
-    // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true, 410);
-    assertCached(false, 411);
-    assertCached(false, 412);
-    assertCached(false, 413);
-    assertCached(true, 414);
-    assertCached(false, 415);
-    assertCached(false, 416);
-    assertCached(false, 417);
-    assertCached(false, 418);
-
-    assertCached(false, 500);
-    assertCached(true, 501);
-    assertCached(false, 502);
-    assertCached(false, 503);
-    assertCached(false, 504);
-    assertCached(false, 505);
-    assertCached(false, 506);
-  }
-
-  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
-    int expectedResponseCode = responseCode;
-
-    server = new MockWebServer();
-    MockResponse response = new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(responseCode)
-        .setBody("ABCDE")
-        .addHeader("WWW-Authenticate: challenge");
-    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
-      response.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
-      response.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
-        || responseCode == HttpURLConnection.HTTP_RESET) {
-      response.setBody(""); // We forbid bodies for 204 and 205.
-    }
-    server.enqueue(response);
-
-    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
-      // 408's are a bit of an outlier because we may repeat the request if we encounter this
-      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
-      // because of the retry. We just want to ensure the initial 408 isn't cached.
-      expectedResponseCode = 200;
-      server.enqueue(new MockResponse()
-          .addHeader("Cache-Control", "no-store")
-          .setBody("FGHIJ"));
-    }
-
-    server.start();
-
-    URL url = server.url("/").url();
-    HttpURLConnection conn = urlFactory.open(url);
-    assertEquals(expectedResponseCode, conn.getResponseCode());
-
-    // exhaust the content stream
-    readAscii(conn);
-
-    Response cached = cache.get(new Request.Builder().url(url).build());
-    if (shouldPut) {
-      assertNotNull(Integer.toString(responseCode), cached);
-      cached.body().close();
-    } else {
-      assertNull(Integer.toString(responseCode), cached);
-    }
-    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
-    testResponseCaching(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
-    testResponseCaching(TransferKind.CHUNKED);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
-    testResponseCaching(TransferKind.END_OF_STREAM);
-  }
-
-  /**
-   * HttpURLConnection.getInputStream().skip(long) causes ResponseCache corruption
-   * http://code.google.com/p/android/issues/detail?id=8175
-   */
-  private void testResponseCaching(TransferKind transferKind) throws IOException {
-    MockResponse response =
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .setStatus("HTTP/1.1 200 Fantastic");
-    transferKind.setBody(response, "I love puppies but hate spiders", 1);
-    server.enqueue(response);
-
-    // Make sure that calling skip() doesn't omit bytes from the cache.
-    HttpURLConnection urlConnection = urlFactory.open(server.url("/").url());
-    InputStream in = urlConnection.getInputStream();
-    assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
-    reliableSkip(in, "puppies but hate ".length());
-    assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
-    assertEquals(-1, in.read());
-    in.close();
-    assertEquals(1, cache.writeSuccessCount());
-    assertEquals(0, cache.writeAbortCount());
-
-    urlConnection = urlFactory.open(server.url("/").url()); // cached!
-    in = urlConnection.getInputStream();
-    assertEquals("I love puppies but hate spiders",
-        readAscii(urlConnection, "I love puppies but hate spiders".length()));
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-
-    assertEquals(-1, in.read());
-    in.close();
-    assertEquals(1, cache.writeSuccessCount());
-    assertEquals(0, cache.writeAbortCount());
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.hitCount());
-  }
-
-  @Test public void secureResponseCaching() throws IOException {
-    assumeFalse(getPlatform().equals("jdk9"));
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-
-    HttpsURLConnection c1 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
-    c1.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
-    c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(c1));
-
-    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    String suite = c1.getCipherSuite();
-    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
-    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
-    Principal peerPrincipal = c1.getPeerPrincipal();
-    Principal localPrincipal = c1.getLocalPrincipal();
-
-    HttpsURLConnection c2 = (HttpsURLConnection) urlFactory.open(server.url("/").url()); // cached!
-    c2.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
-    c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(c2));
-
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(1, cache.hitCount());
-
-    assertEquals(suite, c2.getCipherSuite());
-    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
-    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
-    assertEquals(peerPrincipal, c2.getPeerPrincipal());
-    assertEquals(localPrincipal, c2.getLocalPrincipal());
-  }
-
-  @Test public void responseCachingAndRedirects() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("ABC", readAscii(connection));
-
-    connection = urlFactory.open(server.url("/").url()); // cached!
-    assertEquals("ABC", readAscii(connection));
-
-    assertEquals(4, cache.requestCount()); // 2 requests + 2 redirects
-    assertEquals(2, cache.networkCount());
-    assertEquals(2, cache.hitCount());
-  }
-
-  @Test public void redirectToCachedResult() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("ABC"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-
-    assertEquals("ABC", readAscii(urlFactory.open(server.url("/foo").url())));
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
-    assertEquals(0, request1.getSequenceNumber());
-
-    assertEquals("ABC", readAscii(urlFactory.open(server.url("/bar").url())));
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
-    assertEquals(1, request2.getSequenceNumber());
-
-    // an unrelated request should reuse the pooled connection
-    assertEquals("DEF", readAscii(urlFactory.open(server.url("/baz").url())));
-    RecordedRequest request3 = server.takeRequest();
-    assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
-    assertEquals(2, request3.getSequenceNumber());
-  }
-
-  @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
-        .build());
-
-    HttpsURLConnection connection1 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
-    assertEquals("ABC", readAscii(connection1));
-    assertNotNull(connection1.getCipherSuite());
-
-    // Cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
-    assertEquals("ABC", readAscii(connection2));
-    assertNotNull(connection2.getCipherSuite());
-
-    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.hitCount());
-    assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
-  }
-
-  /**
-   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
-   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
-   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
-   *
-   * https://github.com/square/okhttp/issues/214
-   */
-  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server2.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server2.enqueue(new MockResponse().setBody("DEF"));
-
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: " + server2.url("/").url()));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
-        .build());
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    assertEquals("ABC", readAscii(connection1));
-
-    // Cached!
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertEquals("ABC", readAscii(connection2));
-
-    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.hitCount());
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
-    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
-    testServerPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() {
-    // Intentionally empty. This case doesn't make sense because there's no
-    // such thing as a premature disconnect when the disconnect itself
-    // indicates the end of the data stream.
-  }
-
-  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
-    server.enqueue(truncateViolently(response, 16));
-    server.enqueue(new MockResponse().setBody("Request #2"));
-
-    BufferedSource source = Okio.buffer(Okio.source(
-        urlFactory.open(server.url("/").url()).getInputStream()));
-    assertEquals("ABCDE\n", source.readUtf8(6));
-    try {
-      source.readUtf8(21);
-      fail("This implementation silently ignored a truncated HTTP body.");
-    } catch (IOException expected) {
-    } finally {
-      source.close();
-    }
-
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(0, cache.writeSuccessCount());
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("Request #2", readAscii(connection));
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(1, cache.writeSuccessCount());
-  }
-
-  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
-    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
-    testClientPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
-    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
-  }
-
-  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
-    // Setting a low transfer speed ensures that stream discarding will time out.
-    MockResponse response = new MockResponse().throttleBody(6, 1, TimeUnit.SECONDS);
-    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(response);
-    server.enqueue(new MockResponse().setBody("Request #2"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals("ABCDE", readAscii(connection, 5));
-    in.close();
-    try {
-      in.read();
-      fail("Expected an IOException because the stream is closed.");
-    } catch (IOException expected) {
-    }
-
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(0, cache.writeSuccessCount());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("Request #2", readAscii(connection));
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(1, cache.writeSuccessCount());
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
-    //      last modified: 105 seconds ago
-    //             served:   5 seconds ago
-    //   default lifetime: (105 - 5) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds from now
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-            .setBody("A"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    URLConnection connection = urlFactory.open(url);
-    assertEquals("A", readAscii(connection));
-    assertNull(connection.getHeaderField("Warning"));
-  }
-
-  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
-    //      last modified: 115 seconds ago
-    //             served:  15 seconds ago
-    //   default lifetime: (115 - 15) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds ago
-    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
-    //      last modified: 105 days ago
-    //             served:   5 days ago
-    //   default lifetime: (105 - 5) / 10 = 10 days
-    //            expires:  10 days from served date = 5 days from now
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
-        .setBody("A"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection));
-    assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
-        connection.getHeaderField("Warning"));
-  }
-
-  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/?foo=bar").url();
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    assertEquals("B", readAscii(urlFactory.open(url)));
-  }
-
-  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void expirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Cache-Control: max-age=60"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
-    // Chrome interprets max-age relative to the local clock. Both our cache
-    // and Firefox both use the earlier of the local and server's clock.
-    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
-    assertFullyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
-    assertFullyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=60")
-        .addHeader("Cache-Control: max-age=180"));
-  }
-
-  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=180")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void requestMethodOptionsIsNotCached() throws Exception {
-    testRequestMethod("OPTIONS", false);
-  }
-
-  @Test public void requestMethodGetIsCached() throws Exception {
-    testRequestMethod("GET", true);
-  }
-
-  @Test public void requestMethodHeadIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("HEAD", false);
-  }
-
-  @Test public void requestMethodPostIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("POST", false);
-  }
-
-  @Test public void requestMethodPutIsNotCached() throws Exception {
-    testRequestMethod("PUT", false);
-  }
-
-  @Test public void requestMethodDeleteIsNotCached() throws Exception {
-    testRequestMethod("DELETE", false);
-  }
-
-  @Test public void requestMethodTraceIsNotCached() throws Exception {
-    testRequestMethod("TRACE", false);
-  }
-
-  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
-    // 1. seed the cache (potentially)
-    // 2. expect a cache hit or miss
-    server.enqueue(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("X-Response-ID: 1"));
-    server.enqueue(new MockResponse().addHeader("X-Response-ID: 2"));
-
-    URL url = server.url("/").url();
-
-    HttpURLConnection request1 = urlFactory.open(url);
-    request1.setRequestMethod(requestMethod);
-    addRequestBodyIfNecessary(requestMethod, request1);
-    request1.getInputStream().close();
-    assertEquals("1", request1.getHeaderField("X-Response-ID"));
-
-    URLConnection request2 = urlFactory.open(url);
-    request2.getInputStream().close();
-    if (expectCached) {
-      assertEquals("1", request2.getHeaderField("X-Response-ID"));
-    } else {
-      assertEquals("2", request2.getHeaderField("X-Response-ID"));
-    }
-  }
-
-  @Test public void postInvalidatesCache() throws Exception {
-    testMethodInvalidates("POST");
-  }
-
-  @Test public void putInvalidatesCache() throws Exception {
-    testMethodInvalidates("PUT");
-  }
-
-  @Test public void deleteMethodInvalidatesCache() throws Exception {
-    testMethodInvalidates("DELETE");
-  }
-
-  private void testMethodInvalidates(String requestMethod) throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it
-    // 3. expect a cache miss
-    server.enqueue(
-        new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    URL url = server.url("/").url();
-
-    assertEquals("A", readAscii(urlFactory.open(url)));
-
-    HttpURLConnection invalidate = urlFactory.open(url);
-    invalidate.setRequestMethod(requestMethod);
-    addRequestBodyIfNecessary(requestMethod, invalidate);
-    assertEquals("B", readAscii(invalidate));
-
-    assertEquals("C", readAscii(urlFactory.open(url)));
-  }
-
-  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it with uncacheable response
-    // 3. expect a cache miss
-    server.enqueue(
-        new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B").setResponseCode(500));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    URL url = server.url("/").url();
-
-    assertEquals("A", readAscii(urlFactory.open(url)));
-
-    HttpURLConnection invalidate = urlFactory.open(url);
-    invalidate.setRequestMethod("POST");
-    addRequestBodyIfNecessary("POST", invalidate);
-    assertEquals("B", readAscii(invalidate));
-
-    assertEquals("C", readAscii(urlFactory.open(url)));
-  }
-
-  @Test public void etag() throws Exception {
-    RecordedRequest conditionalRequest =
-        assertConditionallyCached(new MockResponse().addHeader("ETag: v1"));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-  }
-
-  @Test public void etagAndExpirationDateInThePast() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("ETag: v1")
-            .addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("ETag: v1")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void cacheControlNoCache() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Cache-Control: no-cache"));
-  }
-
-  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .addHeader("Cache-Control: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void pragmaNoCache() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Pragma: no-cache"));
-  }
-
-  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .addHeader("Pragma: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void cacheControlNoStore() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
-    // 1. request a range
-    // 2. request a full document, expecting a cache miss
-    server.enqueue(new MockResponse().setBody("AA")
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 1000-1001/2000"));
-    server.enqueue(new MockResponse().setBody("BB"));
-
-    URL url = server.url("/").url();
-
-    URLConnection range = urlFactory.open(url);
-    range.addRequestProperty("Range", "bytes=1000-1001");
-    assertEquals("AA", readAscii(range));
-
-    assertEquals("BB", readAscii(urlFactory.open(url)));
-  }
-
-  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B")
-        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
-
-    URL url = server.url("/").url();
-
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    assertEquals("B", readAscii(urlFactory.open(url)));
-  }
-
-  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
-    assertNonIdentityEncodingCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
-    assertNonIdentityEncodingCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
-    server.enqueue(
-        response.setBody(gzip("ABCABCABC")).addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // At least three request/response pairs are required because after the first request is cached
-    // a different execution path might be taken. Thus modifications to the cache applied during
-    // the second request might not be visible until another request is performed.
-    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
-  }
-
-  @Test public void notModifiedSpecifiesEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setBody("DEFDEFDEF"));
-
-    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("DEFDEFDEF", readAscii(urlFactory.open(server.url("/").url())));
-  }
-
-  /** https://github.com/square/okhttp/issues/947 */
-  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Vary: Accept-Encoding")
-        .addHeader("Cache-Control: max-age=60"));
-    server.enqueue(new MockResponse().setBody("FAIL"));
-
-    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
-  }
-
-  @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
-    server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(1, urlFactory.client().connectionPool().idleConnectionCount());
-  }
-
-  @Test public void expiresDateBeforeModifiedDate() throws Exception {
-    assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
-  }
-
-  @Test public void requestMaxAge() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "max-age=30");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestMinFresh() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "min-fresh=120");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestMaxStale() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "max-stale=180");
-    assertEquals("A", readAscii(connection));
-    assertEquals("110 HttpURLConnection \"Response is stale\"",
-        connection.getHeaderField("Warning"));
-  }
-
-  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=120, must-revalidate")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "max-stale=180");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
-    // (no responses enqueued)
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-    assertEquals(1, cache.requestCount());
-    assertEquals(0, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-  }
-
-  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertEquals("A", readAscii(connection));
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(1, cache.hitCount());
-  }
-
-  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-  }
-
-  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-  }
-
-  @Test public void requestCacheControlNoCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60")
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    URLConnection connection = urlFactory.open(url);
-    connection.setRequestProperty("Cache-Control", "no-cache");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestPragmaNoCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60")
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    URLConnection connection = urlFactory.open(url);
-    connection.setRequestProperty("Pragma", "no-cache");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
-    MockResponse response =
-        new MockResponse().addHeader("ETag: v3").addHeader("Cache-Control: max-age=0");
-    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
-    RecordedRequest request =
-        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
-    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
-    assertNull(request.getHeader("If-None-Match"));
-  }
-
-  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
-    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
-    MockResponse response = new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: max-age=0");
-    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
-    assertEquals("v1", request.getHeader("If-None-Match"));
-    assertNull(request.getHeader("If-Modified-Since"));
-  }
-
-  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
-      String conditionValue) throws Exception {
-    server.enqueue(seed.setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(urlFactory.open(url)));
-
-    HttpURLConnection connection = urlFactory.open(url);
-    connection.addRequestProperty(conditionName, conditionValue);
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
-    assertEquals("", readAscii(connection));
-
-    server.takeRequest(); // seed
-    return server.takeRequest();
-  }
-
-  /**
-   * Confirm that {@link URLConnection#setIfModifiedSince} causes an If-Modified-Since header with a
-   * GMT timestamp.
-   *
-   * https://code.google.com/p/android/issues/detail?id=66135
-   */
-  @Test public void setIfModifiedSince() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    URL url = server.url("/").url();
-    URLConnection connection = urlFactory.open(url);
-    connection.setIfModifiedSince(1393666200000L);
-    assertEquals("A", readAscii(connection));
-    RecordedRequest request = server.takeRequest();
-    String ifModifiedSinceHeader = request.getHeader("If-Modified-Since");
-    assertEquals("Sat, 01 Mar 2014 09:30:00 GMT", ifModifiedSinceHeader);
-  }
-
-  /**
-   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
-   * served.
-   */
-  @Test public void retainServedDateFormat() throws Exception {
-    // Serve a response with a non-standard date format that OkHttp supports.
-    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
-    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
-    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
-    String lastModifiedString = dateFormat.format(lastModifiedDate);
-    String servedString = dateFormat.format(servedDate);
-
-    // This response should be conditionally cached.
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedString)
-        .addHeader("Expires: " + servedString)
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-
-    // The first request has no conditions.
-    RecordedRequest request1 = server.takeRequest();
-    assertNull(request1.getHeader("If-Modified-Since"));
-
-    // The 2nd request uses the server's date format.
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
-    connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
-    assertEquals("", readAscii(connection));
-  }
-
-  @Test public void authorizationRequestFullyCached() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection connection = urlFactory.open(url);
-    connection.addRequestProperty("Authorization", "password");
-    assertEquals("A", readAscii(connection));
-    assertEquals("A", readAscii(urlFactory.open(url)));
-  }
-
-  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Content-Location: /bar")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/foo").url())));
-    assertEquals("B", readAscii(urlFactory.open(server.url("/bar").url())));
-  }
-
-  @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setUseCaches(false);
-    assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
-  }
-
-  @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setUseCaches(false);
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
-    URL url = new URL("http://localhost/");
-    URLConnection c1 = urlFactory.open(url);
-    URLConnection c2 = urlFactory.open(url);
-    assertTrue(c1.getDefaultUseCaches());
-    c1.setDefaultUseCaches(false);
-    try {
-      assertTrue(c1.getUseCaches());
-      assertTrue(c2.getUseCaches());
-      URLConnection c3 = urlFactory.open(url);
-      assertFalse(c3.getUseCaches());
-    } finally {
-      c1.setDefaultUseCaches(true);
-    }
-  }
-
-  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/a").url())));
-    assertEquals("A", readAscii(urlFactory.open(server.url("/a").url())));
-    assertEquals("B", readAscii(urlFactory.open(server.url("/b").url())));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void statisticsConditionalCacheMiss() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("C", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(3, cache.requestCount());
-    assertEquals(3, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-  }
-
-  @Test public void statisticsConditionalCacheHit() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(3, cache.requestCount());
-    assertEquals(3, cache.networkCount());
-    assertEquals(2, cache.hitCount());
-  }
-
-  @Test public void statisticsFullCacheHit() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(3, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(2, cache.hitCount());
-  }
-
-  @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frConnection = urlFactory.open(url);
-    frConnection.addRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(frConnection));
-
-    HttpURLConnection enConnection = urlFactory.open(url);
-    enConnection.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("B", readAscii(enConnection));
-  }
-
-  @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection connection1 = urlFactory.open(url);
-    connection1.addRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = urlFactory.open(url);
-    connection2.addRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-  }
-
-  @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    URLConnection fooConnection = urlFactory.open(server.url("/").url());
-    fooConnection.addRequestProperty("Foo", "bar");
-    assertEquals("B", readAscii(fooConnection));
-  }
-
-  @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URLConnection fooConnection = urlFactory.open(server.url("/").url());
-    fooConnection.addRequestProperty("Foo", "bar");
-    assertEquals("A", readAscii(fooConnection));
-    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
-  }
-
-  @Test public void varyFieldsAreCaseInsensitive() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: ACCEPT-LANGUAGE")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection connection1 = urlFactory.open(url);
-    connection1.addRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = urlFactory.open(url);
-    connection2.addRequestProperty("accept-language", "fr-CA");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void varyMultipleFieldsWithMatch() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection connection1 = urlFactory.open(url);
-    connection1.addRequestProperty("Accept-Language", "fr-CA");
-    connection1.addRequestProperty("Accept-Charset", "UTF-8");
-    connection1.addRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = urlFactory.open(url);
-    connection2.addRequestProperty("Accept-Language", "fr-CA");
-    connection2.addRequestProperty("Accept-Charset", "UTF-8");
-    connection2.addRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection frConnection = urlFactory.open(url);
-    frConnection.addRequestProperty("Accept-Language", "fr-CA");
-    frConnection.addRequestProperty("Accept-Charset", "UTF-8");
-    frConnection.addRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(frConnection));
-    URLConnection enConnection = urlFactory.open(url);
-    enConnection.addRequestProperty("Accept-Language", "en-CA");
-    enConnection.addRequestProperty("Accept-Charset", "UTF-8");
-    enConnection.addRequestProperty("Accept-Encoding", "identity");
-    assertEquals("B", readAscii(enConnection));
-  }
-
-  @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection connection1 = urlFactory.open(url);
-    connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    connection1.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection1));
-
-    URLConnection connection2 = urlFactory.open(url);
-    connection2.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    connection2.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection connection1 = urlFactory.open(url);
-    connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    connection1.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection1));
-
-    URLConnection connection2 = urlFactory.open(url);
-    connection2.addRequestProperty("Accept-Language", "fr-CA");
-    connection2.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("B", readAscii(connection2));
-  }
-
-  @Test public void varyAsterisk() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: *")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
-  }
-
-  @Test public void varyAndHttps() throws Exception {
-    assumeFalse(getPlatform().equals("jdk9"));
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpsURLConnection connection1 = (HttpsURLConnection) urlFactory.open(url);
-    connection1.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
-    connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    connection1.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection1));
-
-    HttpsURLConnection connection2 = (HttpsURLConnection) urlFactory.open(url);
-    connection2.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
-    connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    connection2.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void cachePlusCookies() throws Exception {
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .cookieJar(cookieJar)
-        .build());
-
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=FIRST")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=SECOND")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    cookieJar.assertResponseCookies("a=FIRST; path=/");
-
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    cookieJar.assertResponseCookies("a=SECOND; path=/");
-  }
-
-  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD, PUT")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
-
-    URLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
-  }
-
-  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: identity")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: none")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
-
-    URLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
-  }
-
-  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Warning: 199 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("199 test danger", connection1.getHeaderField("Warning"));
-
-    URLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertNull(connection2.getHeaderField("Warning"));
-  }
-
-  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Warning: 299 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("299 test danger", connection1.getHeaderField("Warning"));
-
-    URLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("299 test danger", connection2.getHeaderField("Warning"));
-  }
-
-  @Test public void cachePlusRange() throws Exception {
-    assertNotCached(new MockResponse().setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 100-100/200")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void conditionalHitUpdatesCache() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=30")
-        .addHeader("Allow: GET, HEAD")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    // cache miss; seed the cache
-    HttpURLConnection connection1 = urlFactory.open(server.url("/a").url());
-    assertEquals("A", readAscii(connection1));
-    assertNull(connection1.getHeaderField("Allow"));
-
-    // conditional cache hit; update the cache
-    HttpURLConnection connection2 = urlFactory.open(server.url("/a").url());
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
-
-    // full cache hit
-    HttpURLConnection connection3 = urlFactory.open(server.url("/a").url());
-    assertEquals("A", readAscii(connection3));
-    assertEquals("GET, HEAD", connection3.getHeaderField("Allow"));
-
-    assertEquals(2, server.getRequestCount());
-  }
-
-  @Test public void responseSourceHeaderCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=0")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setResponseCode(304));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderFetched() throws IOException {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
-    Headers.Builder headers = new Headers.Builder()
-        .add("Cache-Control: max-age=120");
-    Internal.instance.addLenient(headers, ": A");
-    server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", connection.getHeaderField(""));
-    assertEquals("body", readAscii(connection));
-  }
-
-  /**
-   * Old implementations of OkHttp's response cache wrote header fields like ":status: 200 OK". This
-   * broke our cached response parser because it split on the first colon. This regression test
-   * exists to help us read these old bad cache entries.
-   *
-   * https://github.com/square/okhttp/issues/227
-   */
-  @Test public void testGoldenCacheResponse() throws Exception {
-    cache.close();
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URL url = server.url("/").url();
-    String urlKey = Cache.key(HttpUrl.get(url));
-    String prefix = Platform.get().getPrefix();
-    String entryMetadata = ""
-        + "" + url + "\n"
-        + "GET\n"
-        + "0\n"
-        + "HTTP/1.1 200 OK\n"
-        + "7\n"
-        + ":status: 200 OK\n"
-        + ":version: HTTP/1.1\n"
-        + "etag: foo\n"
-        + "content-length: 3\n"
-        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + "X-Android-Response-Source: NETWORK 200\n"
-        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
-        + "\n"
-        + "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n"
-        + "1\n"
-        + "MIIBpDCCAQ2gAwIBAgIBATANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDEw1qd2lsc29uLmxvY2FsMB4XDTEzMDgy"
-        + "OTA1MDE1OVoXDTEzMDgzMDA1MDE1OVowGDEWMBQGA1UEAxMNandpbHNvbi5sb2NhbDCBnzANBgkqhkiG9w0BAQEF"
-        + "AAOBjQAwgYkCgYEAlFW+rGo/YikCcRghOyKkJanmVmJSce/p2/jH1QvNIFKizZdh8AKNwojt3ywRWaDULA/RlCUc"
-        + "ltF3HGNsCyjQI/+Lf40x7JpxXF8oim1E6EtDoYtGWAseelawus3IQ13nmo6nWzfyCA55KhAWf4VipelEy8DjcuFK"
-        + "v6L0xwXnI0ECAwEAATANBgkqhkiG9w0BAQsFAAOBgQAuluNyPo1HksU3+Mr/PyRQIQS4BI7pRXN8mcejXmqyscdP"
-        + "7S6J21FBFeRR8/XNjVOp4HT9uSc2hrRtTEHEZCmpyoxixbnM706ikTmC7SN/GgM+SmcoJ1ipJcNcl8N0X6zym4dm"
-        + "yFfXKHu2PkTo7QFdpOJFvP3lIigcSZXozfmEDg==\n"
-        + "-1\n";
-    String entryBody = "abc";
-    String journalBody = ""
-        + "libcore.io.DiskLruCache\n"
-        + "1\n"
-        + "201105\n"
-        + "2\n"
-        + "\n"
-        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.directory(), urlKey + ".1", entryBody);
-    writeFile(cache.directory(), "journal", journalBody);
-    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .cache(cache)
-        .build());
-
-    HttpURLConnection connection = urlFactory.open(url);
-    assertEquals(entryBody, readAscii(connection));
-    assertEquals("3", connection.getHeaderField("Content-Length"));
-    assertEquals("foo", connection.getHeaderField("etag"));
-  }
-
-  private void writeFile(File directory, String file, String content) throws IOException {
-    BufferedSink sink = Okio.buffer(fileSystem.sink(new File(directory, file)));
-    sink.writeUtf8(content);
-    sink.close();
-  }
-
-  /**
-   * @param delta the offset from the current date to use. Negative values yield dates in the past;
-   * positive values yield dates in the future.
-   */
-  private String formatDate(long delta, TimeUnit timeUnit) {
-    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private String formatDate(Date date) {
-    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
-    return rfc1123.format(date);
-  }
-
-  private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection invalidate)
-      throws IOException {
-    if (requestMethod.equals("POST") || requestMethod.equals("PUT")) {
-      invalidate.setDoOutput(true);
-      OutputStream requestBody = invalidate.getOutputStream();
-      requestBody.write('x');
-      requestBody.close();
-    }
-  }
-
-  private void assertNotCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    assertEquals("B", readAscii(urlFactory.open(url)));
-  }
-
-  /** @return the request with the conditional get headers. */
-  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
-    // scenario 1: condition succeeds
-    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // scenario 2: condition fails
-    server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
-
-    URL valid = server.url("/valid").url();
-    HttpURLConnection connection1 = urlFactory.open(valid);
-    assertEquals("A", readAscii(connection1));
-    assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
-    assertEquals("A-OK", connection1.getResponseMessage());
-    HttpURLConnection connection2 = urlFactory.open(valid);
-    assertEquals("A", readAscii(connection2));
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertEquals("A-OK", connection2.getResponseMessage());
-
-    URL invalid = server.url("/invalid").url();
-    HttpURLConnection connection3 = urlFactory.open(invalid);
-    assertEquals("B", readAscii(connection3));
-    assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
-    assertEquals("B-OK", connection3.getResponseMessage());
-    HttpURLConnection connection4 = urlFactory.open(invalid);
-    assertEquals("C", readAscii(connection4));
-    assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
-    assertEquals("C-OK", connection4.getResponseMessage());
-
-    server.takeRequest(); // regular get
-    return server.takeRequest(); // conditional get
-  }
-
-  private void assertFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(response.setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    assertEquals("A", readAscii(urlFactory.open(url)));
-  }
-
-  /**
-   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
-   * how clients respond to the premature conclusion of the HTTP body.
-   */
-  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
-    response.setSocketPolicy(DISCONNECT_AT_END);
-    Headers headers = response.getHeaders();
-    Buffer truncatedBody = new Buffer();
-    truncatedBody.write(response.getBody(), numBytesToKeep);
-    response.setBody(truncatedBody);
-    response.setHeaders(headers);
-    return response;
-  }
-
-  /**
-   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
-   * characters can be read, the remaining characters are returned and the stream is closed.
-   */
-  private String readAscii(URLConnection connection, int count) throws IOException {
-    HttpURLConnection httpConnection = (HttpURLConnection) connection;
-    InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
-        ? connection.getInputStream()
-        : httpConnection.getErrorStream();
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  private String readAscii(URLConnection connection) throws IOException {
-    return readAscii(connection, Integer.MAX_VALUE);
-  }
-
-  private void reliableSkip(InputStream in, int length) throws IOException {
-    while (length > 0) {
-      length -= in.skip(length);
-    }
-  }
-
-  private void assertGatewayTimeout(HttpURLConnection connection) throws IOException {
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (FileNotFoundException expected) {
-    }
-    assertEquals(504, connection.getResponseCode());
-    assertEquals(-1, connection.getErrorStream().read());
-  }
-
-  enum TransferKind {
-    CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setChunkedBody(content, chunkSize);
-      }
-    },
-    FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-      }
-    },
-    END_OF_STREAM() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(DISCONNECT_AT_END);
-        response.removeHeader("Content-Length");
-      }
-    };
-
-    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, new Buffer().writeUtf8(content), chunkSize);
-    }
-  }
-
-  private <T> List<T> toListOrNull(T[] arrayOrNull) {
-    return arrayOrNull != null ? Arrays.asList(arrayOrNull) : null;
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(result));
-    sink.writeUtf8(data);
-    sink.close();
-    return result;
-  }
-
-  private String getPlatform() {
-    return System.getProperty("okhttp.platform", "platform");
-  }
-}
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
deleted file mode 100644
index ec0de83e52..0000000000
--- a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Internal;
-import okhttp3.internal.cache.CacheRequest;
-import okhttp3.internal.cache.CacheStrategy;
-import okhttp3.internal.cache.InternalCache;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-/**
- * Exercises HttpURLConnection to convert URL to a URI. Unlike URL#toURI, HttpURLConnection recovers
- * from URLs with unescaped but unsupported URI characters like '{' and '|' by escaping these
- * characters.
- */
-public final class URLEncodingTest {
-  /**
-   * This test goes through the exhaustive set of interesting ASCII characters because most of those
-   * characters are interesting in some way according to RFC 2396 and RFC 2732. http://b/1158780
-   */
-  @Test @Ignore public void lenientUrlToUri() throws Exception {
-    // alphanum
-    testUrlToUriMapping("abzABZ09", "abzABZ09", "abzABZ09", "abzABZ09", "abzABZ09");
-
-    // control characters
-    testUrlToUriMapping("\u0001", "%01", "%01", "%01", "%01");
-    testUrlToUriMapping("\u001f", "%1F", "%1F", "%1F", "%1F");
-
-    // ascii characters
-    testUrlToUriMapping("%20", "%20", "%20", "%20", "%20");
-    testUrlToUriMapping("%20", "%20", "%20", "%20", "%20");
-    testUrlToUriMapping(" ", "%20", "%20", "%20", "%20");
-    testUrlToUriMapping("!", "!", "!", "!", "!");
-    testUrlToUriMapping("\"", "%22", "%22", "%22", "%22");
-    testUrlToUriMapping("#", null, null, null, "%23");
-    testUrlToUriMapping("$", "$", "$", "$", "$");
-    testUrlToUriMapping("&", "&", "&", "&", "&");
-    testUrlToUriMapping("'", "'", "'", "'", "'");
-    testUrlToUriMapping("(", "(", "(", "(", "(");
-    testUrlToUriMapping(")", ")", ")", ")", ")");
-    testUrlToUriMapping("*", "*", "*", "*", "*");
-    testUrlToUriMapping("+", "+", "+", "+", "+");
-    testUrlToUriMapping(",", ",", ",", ",", ",");
-    testUrlToUriMapping("-", "-", "-", "-", "-");
-    testUrlToUriMapping(".", ".", ".", ".", ".");
-    testUrlToUriMapping("/", null, "/", "/", "/");
-    testUrlToUriMapping(":", null, ":", ":", ":");
-    testUrlToUriMapping(";", ";", ";", ";", ";");
-    testUrlToUriMapping("<", "%3C", "%3C", "%3C", "%3C");
-    testUrlToUriMapping("=", "=", "=", "=", "=");
-    testUrlToUriMapping(">", "%3E", "%3E", "%3E", "%3E");
-    testUrlToUriMapping("?", null, null, "?", "?");
-    testUrlToUriMapping("@", "@", "@", "@", "@");
-    testUrlToUriMapping("[", null, "%5B", null, "%5B");
-    testUrlToUriMapping("\\", "%5C", "%5C", "%5C", "%5C");
-    testUrlToUriMapping("]", null, "%5D", null, "%5D");
-    testUrlToUriMapping("^", "%5E", "%5E", "%5E", "%5E");
-    testUrlToUriMapping("_", "_", "_", "_", "_");
-    testUrlToUriMapping("`", "%60", "%60", "%60", "%60");
-    testUrlToUriMapping("{", "%7B", "%7B", "%7B", "%7B");
-    testUrlToUriMapping("|", "%7C", "%7C", "%7C", "%7C");
-    testUrlToUriMapping("}", "%7D", "%7D", "%7D", "%7D");
-    testUrlToUriMapping("~", "~", "~", "~", "~");
-    testUrlToUriMapping("~", "~", "~", "~", "~");
-    testUrlToUriMapping("\u007f", "%7F", "%7F", "%7F", "%7F");
-
-    // beyond ascii
-    testUrlToUriMapping("\u0080", "%C2%80", "%C2%80", "%C2%80", "%C2%80");
-    testUrlToUriMapping("\u20ac", "\u20ac", "\u20ac", "\u20ac", "\u20ac");
-    testUrlToUriMapping("\ud842\udf9f", "\ud842\udf9f", "\ud842\udf9f", "\ud842\udf9f",
-        "\ud842\udf9f");
-  }
-
-  @Test @Ignore public void lenientUrlToUriNul() throws Exception {
-    testUrlToUriMapping("\u0000", "%00", "%00", "%00", "%00"); // RI fails this
-  }
-
-  private void testUrlToUriMapping(String string, String asAuthority, String asFile, String asQuery,
-      String asFragment) throws Exception {
-    if (asAuthority != null) {
-      assertEquals("http://host" + asAuthority + ".tld/",
-          backdoorUrlToUri(new URL("http://host" + string + ".tld/")).toString());
-    }
-    if (asFile != null) {
-      assertEquals("http://host.tld/file" + asFile + "/",
-          backdoorUrlToUri(new URL("http://host.tld/file" + string + "/")).toString());
-    }
-    if (asQuery != null) {
-      assertEquals("http://host.tld/file?q" + asQuery + "=x",
-          backdoorUrlToUri(new URL("http://host.tld/file?q" + string + "=x")).toString());
-    }
-    assertEquals("http://host.tld/file#" + asFragment + "-x",
-        backdoorUrlToUri(new URL("http://host.tld/file#" + asFragment + "-x")).toString());
-  }
-
-  private URI backdoorUrlToUri(URL url) throws Exception {
-    final AtomicReference<URI> uriReference = new AtomicReference<>();
-
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    Internal.instance.setCache(builder, new InternalCache() {
-      @Override public Response get(Request request) throws IOException {
-        uriReference.set(request.url().uri());
-        throw new UnsupportedOperationException();
-      }
-
-      @Override public CacheRequest put(Response response) throws IOException {
-        return null;
-      }
-
-      @Override public void remove(Request request) throws IOException {
-      }
-
-      @Override public void update(Response cached, Response network) {
-      }
-
-      @Override public void trackConditionalCacheHit() {
-      }
-
-      @Override public void trackResponse(CacheStrategy cacheStrategy) {
-      }
-    });
-
-    try {
-      HttpURLConnection connection = new OkUrlFactory(builder.build()).open(url);
-      connection.getResponseCode();
-    } catch (Exception expected) {
-      if (expected.getCause() instanceof URISyntaxException) {
-        expected.printStackTrace();
-      }
-    }
-
-    return uriReference.get();
-  }
-}
diff --git a/okhttp/Module.md b/okhttp/Module.md
new file mode 100644
index 0000000000..889dd17cc7
--- /dev/null
+++ b/okhttp/Module.md
@@ -0,0 +1,3 @@
+# Module okhttp
+
+An HTTP+HTTP/2 client for Android and Java applications.
diff --git a/okhttp/build.gradle b/okhttp/build.gradle
new file mode 100644
index 0000000000..10172a0841
--- /dev/null
+++ b/okhttp/build.gradle
@@ -0,0 +1,359 @@
+apply plugin: 'com.vanniktech.maven.publish'
+apply plugin: 'me.champeau.gradle.japicmp'
+
+jar {
+  manifest {
+    attributes('Automatic-Module-Name': 'okhttp3')
+  }
+}
+
+sourceSets {
+  main.java.srcDirs += "$buildDir/generated/sources/java-templates/java/main"
+}
+
+compileKotlin {
+  dependsOn 'copyJavaTemplates'
+}
+
+task copyJavaTemplates(type: Copy) {
+  from 'src/main/java-templates'
+  into "$buildDir/generated/sources/java-templates/java/main"
+  expand('projectVersion': "$VERSION_NAME")
+  filteringCharset = 'UTF-8'
+}
+
+dependencies {
+  api deps.okio
+  api deps.kotlinStdlib
+  compileOnly deps.conscrypt
+  compileOnly deps.android
+  compileOnly deps.jsr305
+  compileOnly deps.animalSniffer
+
+  testImplementation deps.okio
+  testImplementation project(':okhttp-testing-support')
+  testImplementation project(':okhttp-tls')
+  testImplementation project(':okhttp-urlconnection')
+  testImplementation project(':mockwebserver')
+  testImplementation project(':okhttp-logging-interceptor')
+  testImplementation deps.conscrypt
+  testImplementation deps.junit
+  testImplementation deps.assertj
+  testCompileOnly deps.jsr305
+}
+
+task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
+  oldClasspath = files(baselineJar(project, baselineVersion))
+  newClasspath = files(jar.archivePath)
+  onlyBinaryIncompatibleModified = true
+  failOnModification = true
+  txtOutputFile = file("$buildDir/reports/japi.txt")
+  ignoreMissingClasses = true
+  includeSynthetic = true
+  packageExcludes = [
+      'okhttp3.internal',
+  ]
+  classExcludes = [
+      // Package-private in 3.x, internal in 4.0.0:
+      'okhttp3.Cache$CacheResponseBody$1',
+  ]
+  methodExcludes = [
+      // Became 'final' in 4.0.0:
+      'okhttp3.Address#certificatePinner()',
+      'okhttp3.Address#connectionSpecs()',
+      'okhttp3.Address#dns()',
+      'okhttp3.Address#hostnameVerifier()',
+      'okhttp3.Address#protocols()',
+      'okhttp3.Address#proxy()',
+      'okhttp3.Address#proxyAuthenticator()',
+      'okhttp3.Address#proxySelector()',
+      'okhttp3.Address#socketFactory()',
+      'okhttp3.Address#sslSocketFactory()',
+      'okhttp3.Address#url()',
+      'okhttp3.Cache#delete()',
+      'okhttp3.Cache#directory()',
+      'okhttp3.Cache#evictAll()',
+      'okhttp3.Cache#hitCount()',
+      'okhttp3.Cache#initialize()',
+      'okhttp3.Cache#isClosed()',
+      'okhttp3.Cache#maxSize()',
+      'okhttp3.Cache#networkCount()',
+      'okhttp3.Cache#requestCount()',
+      'okhttp3.Cache#size()',
+      'okhttp3.Cache#urls()',
+      'okhttp3.Cache#writeAbortCount()',
+      'okhttp3.Cache#writeSuccessCount()',
+      'okhttp3.CacheControl#immutable()',
+      'okhttp3.CacheControl#isPrivate()',
+      'okhttp3.CacheControl#isPublic()',
+      'okhttp3.CacheControl#maxAgeSeconds()',
+      'okhttp3.CacheControl#maxStaleSeconds()',
+      'okhttp3.CacheControl#minFreshSeconds()',
+      'okhttp3.CacheControl#mustRevalidate()',
+      'okhttp3.CacheControl#noCache()',
+      'okhttp3.CacheControl#noStore()',
+      'okhttp3.CacheControl#noTransform()',
+      'okhttp3.CacheControl#onlyIfCached()',
+      'okhttp3.CacheControl#sMaxAgeSeconds()',
+      'okhttp3.CacheControl$Builder#build()',
+      'okhttp3.CacheControl$Builder#immutable()',
+      'okhttp3.CacheControl$Builder#maxAge(int, java.util.concurrent.TimeUnit)',
+      'okhttp3.CacheControl$Builder#maxStale(int, java.util.concurrent.TimeUnit)',
+      'okhttp3.CacheControl$Builder#minFresh(int, java.util.concurrent.TimeUnit)',
+      'okhttp3.CacheControl$Builder#noCache()',
+      'okhttp3.CacheControl$Builder#noStore()',
+      'okhttp3.CacheControl$Builder#noTransform()',
+      'okhttp3.CacheControl$Builder#onlyIfCached()',
+      'okhttp3.CertificatePinner#check(java.lang.String, java.security.cert.Certificate\\[\\])',
+      'okhttp3.CertificatePinner#check(java.lang.String, java.util.List)',
+      'okhttp3.CertificatePinner$Builder#add(java.lang.String, java.lang.String\\[\\])',
+      'okhttp3.CertificatePinner$Builder#build()',
+      'okhttp3.CertificatePinner$Pin#matches(java.lang.String)',
+      'okhttp3.Challenge#authParams()',
+      'okhttp3.Challenge#charset()',
+      'okhttp3.Challenge#realm()',
+      'okhttp3.Challenge#scheme()',
+      'okhttp3.Challenge#withCharset(java.nio.charset.Charset)',
+      'okhttp3.CipherSuite#javaName()',
+      'okhttp3.ConnectionPool#connectionCount()',
+      'okhttp3.ConnectionPool#evictAll()',
+      'okhttp3.ConnectionPool#idleConnectionCount()',
+      'okhttp3.ConnectionSpec#cipherSuites()',
+      'okhttp3.ConnectionSpec#isCompatible(javax.net.ssl.SSLSocket)',
+      'okhttp3.ConnectionSpec#isTls()',
+      'okhttp3.ConnectionSpec#supportsTlsExtensions()',
+      'okhttp3.ConnectionSpec#tlsVersions()',
+      'okhttp3.ConnectionSpec$Builder#allEnabledCipherSuites()',
+      'okhttp3.ConnectionSpec$Builder#allEnabledTlsVersions()',
+      'okhttp3.ConnectionSpec$Builder#build()',
+      'okhttp3.ConnectionSpec$Builder#cipherSuites(java.lang.String\\[\\])',
+      'okhttp3.ConnectionSpec$Builder#cipherSuites(okhttp3.CipherSuite\\[\\])',
+      'okhttp3.ConnectionSpec$Builder#supportsTlsExtensions(boolean)',
+      'okhttp3.ConnectionSpec$Builder#tlsVersions(java.lang.String\\[\\])',
+      'okhttp3.ConnectionSpec$Builder#tlsVersions(okhttp3.TlsVersion\\[\\])',
+      'okhttp3.Cookie#domain()',
+      'okhttp3.Cookie#expiresAt()',
+      'okhttp3.Cookie#hostOnly()',
+      'okhttp3.Cookie#httpOnly()',
+      'okhttp3.Cookie#matches(okhttp3.HttpUrl)',
+      'okhttp3.Cookie#name()',
+      'okhttp3.Cookie#path()',
+      'okhttp3.Cookie#persistent()',
+      'okhttp3.Cookie#secure()',
+      'okhttp3.Cookie#value()',
+      'okhttp3.Cookie$Builder#build()',
+      'okhttp3.Cookie$Builder#domain(java.lang.String)',
+      'okhttp3.Cookie$Builder#expiresAt(long)',
+      'okhttp3.Cookie$Builder#hostOnlyDomain(java.lang.String)',
+      'okhttp3.Cookie$Builder#httpOnly()',
+      'okhttp3.Cookie$Builder#name(java.lang.String)',
+      'okhttp3.Cookie$Builder#path(java.lang.String)',
+      'okhttp3.Cookie$Builder#secure()',
+      'okhttp3.Cookie$Builder#value(java.lang.String)',
+      'okhttp3.Dispatcher#cancelAll()',
+      'okhttp3.Dispatcher#executorService()',
+      'okhttp3.Dispatcher#getMaxRequests()',
+      'okhttp3.Dispatcher#getMaxRequestsPerHost()',
+      'okhttp3.Dispatcher#queuedCalls()',
+      'okhttp3.Dispatcher#queuedCallsCount()',
+      'okhttp3.Dispatcher#runningCalls()',
+      'okhttp3.Dispatcher#runningCallsCount()',
+      'okhttp3.Dispatcher#setIdleCallback(java.lang.Runnable)',
+      'okhttp3.Dispatcher#setMaxRequests(int)',
+      'okhttp3.Dispatcher#setMaxRequestsPerHost(int)',
+      'okhttp3.FormBody#encodedName(int)',
+      'okhttp3.FormBody#encodedValue(int)',
+      'okhttp3.FormBody#name(int)',
+      'okhttp3.FormBody#size()',
+      'okhttp3.FormBody#value(int)',
+      'okhttp3.FormBody$Builder#add(java.lang.String, java.lang.String)',
+      'okhttp3.FormBody$Builder#addEncoded(java.lang.String, java.lang.String)',
+      'okhttp3.FormBody$Builder#build()',
+      'okhttp3.Handshake#cipherSuite()',
+      'okhttp3.Handshake#localCertificates()',
+      'okhttp3.Handshake#localPrincipal()',
+      'okhttp3.Handshake#peerCertificates()',
+      'okhttp3.Handshake#peerPrincipal()',
+      'okhttp3.Handshake#tlsVersion()',
+      'okhttp3.Headers#byteCount()',
+      'okhttp3.Headers#get(java.lang.String)',
+      'okhttp3.Headers#getDate(java.lang.String)',
+      'okhttp3.Headers#getInstant(java.lang.String)',
+      'okhttp3.Headers#name(int)',
+      'okhttp3.Headers#names()',
+      'okhttp3.Headers#newBuilder()',
+      'okhttp3.Headers#size()',
+      'okhttp3.Headers#toMultimap()',
+      'okhttp3.Headers#value(int)',
+      'okhttp3.Headers#values(java.lang.String)',
+      'okhttp3.Headers$Builder#add(java.lang.String)',
+      'okhttp3.Headers$Builder#add(java.lang.String, java.lang.String)',
+      'okhttp3.Headers$Builder#add(java.lang.String, java.time.Instant)',
+      'okhttp3.Headers$Builder#add(java.lang.String, java.util.Date)',
+      'okhttp3.Headers$Builder#addAll(okhttp3.Headers)',
+      'okhttp3.Headers$Builder#addUnsafeNonAscii(java.lang.String, java.lang.String)',
+      'okhttp3.Headers$Builder#build()',
+      'okhttp3.Headers$Builder#get(java.lang.String)',
+      'okhttp3.Headers$Builder#removeAll(java.lang.String)',
+      'okhttp3.Headers$Builder#set(java.lang.String, java.lang.String)',
+      'okhttp3.Headers$Builder#set(java.lang.String, java.time.Instant)',
+      'okhttp3.Headers$Builder#set(java.lang.String, java.util.Date)',
+      'okhttp3.HttpUrl#encodedFragment()',
+      'okhttp3.HttpUrl#encodedPassword()',
+      'okhttp3.HttpUrl#encodedPath()',
+      'okhttp3.HttpUrl#encodedPathSegments()',
+      'okhttp3.HttpUrl#encodedQuery()',
+      'okhttp3.HttpUrl#encodedUsername()',
+      'okhttp3.HttpUrl#fragment()',
+      'okhttp3.HttpUrl#host()',
+      'okhttp3.HttpUrl#isHttps()',
+      'okhttp3.HttpUrl#newBuilder()',
+      'okhttp3.HttpUrl#newBuilder(java.lang.String)',
+      'okhttp3.HttpUrl#password()',
+      'okhttp3.HttpUrl#pathSegments()',
+      'okhttp3.HttpUrl#pathSize()',
+      'okhttp3.HttpUrl#port()',
+      'okhttp3.HttpUrl#query()',
+      'okhttp3.HttpUrl#queryParameter(java.lang.String)',
+      'okhttp3.HttpUrl#queryParameterName(int)',
+      'okhttp3.HttpUrl#queryParameterNames()',
+      'okhttp3.HttpUrl#queryParameterValue(int)',
+      'okhttp3.HttpUrl#queryParameterValues(java.lang.String)',
+      'okhttp3.HttpUrl#querySize()',
+      'okhttp3.HttpUrl#redact()',
+      'okhttp3.HttpUrl#resolve(java.lang.String)',
+      'okhttp3.HttpUrl#scheme()',
+      'okhttp3.HttpUrl#topPrivateDomain()',
+      'okhttp3.HttpUrl#uri()',
+      'okhttp3.HttpUrl#url()',
+      'okhttp3.HttpUrl#username()',
+      'okhttp3.HttpUrl$Builder#addEncodedPathSegment(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#addEncodedPathSegments(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#addEncodedQueryParameter(java.lang.String, java.lang.String)',
+      'okhttp3.HttpUrl$Builder#addPathSegment(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#addPathSegments(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#addQueryParameter(java.lang.String, java.lang.String)',
+      'okhttp3.HttpUrl$Builder#build()',
+      'okhttp3.HttpUrl$Builder#encodedFragment(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#encodedPassword(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#encodedPath(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#encodedQuery(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#encodedUsername(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#fragment(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#host(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#password(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#port(int)',
+      'okhttp3.HttpUrl$Builder#query(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#removeAllEncodedQueryParameters(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#removeAllQueryParameters(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#removePathSegment(int)',
+      'okhttp3.HttpUrl$Builder#scheme(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#setEncodedPathSegment(int, java.lang.String)',
+      'okhttp3.HttpUrl$Builder#setEncodedQueryParameter(java.lang.String, java.lang.String)',
+      'okhttp3.HttpUrl$Builder#setPathSegment(int, java.lang.String)',
+      'okhttp3.HttpUrl$Builder#setQueryParameter(java.lang.String, java.lang.String)',
+      'okhttp3.HttpUrl$Builder#username(java.lang.String)',
+      'okhttp3.MediaType#charset()',
+      'okhttp3.MediaType#charset(java.nio.charset.Charset)',
+      'okhttp3.MediaType#subtype()',
+      'okhttp3.MediaType#type()',
+      'okhttp3.MultipartBody#boundary()',
+      'okhttp3.MultipartBody#part(int)',
+      'okhttp3.MultipartBody#parts()',
+      'okhttp3.MultipartBody#size()',
+      'okhttp3.MultipartBody#type()',
+      'okhttp3.MultipartBody$Builder#addFormDataPart(java.lang.String, java.lang.String)',
+      'okhttp3.MultipartBody$Builder#addFormDataPart(java.lang.String, java.lang.String, okhttp3.RequestBody)',
+      'okhttp3.MultipartBody$Builder#addPart(okhttp3.Headers, okhttp3.RequestBody)',
+      'okhttp3.MultipartBody$Builder#addPart(okhttp3.MultipartBody$Part)',
+      'okhttp3.MultipartBody$Builder#addPart(okhttp3.RequestBody)',
+      'okhttp3.MultipartBody$Builder#build()',
+      'okhttp3.MultipartBody$Builder#setType(okhttp3.MediaType)',
+      'okhttp3.MultipartBody$Part#body()',
+      'okhttp3.MultipartBody$Part#headers()',
+      'okhttp3.OkHttpClient$Builder#addInterceptor(okhttp3.Interceptor)',
+      'okhttp3.OkHttpClient$Builder#addNetworkInterceptor(okhttp3.Interceptor)',
+      'okhttp3.OkHttpClient$Builder#authenticator(okhttp3.Authenticator)',
+      'okhttp3.OkHttpClient$Builder#build()',
+      'okhttp3.OkHttpClient$Builder#cache(okhttp3.Cache)',
+      'okhttp3.OkHttpClient$Builder#callTimeout(java.time.Duration)',
+      'okhttp3.OkHttpClient$Builder#callTimeout(long, java.util.concurrent.TimeUnit)',
+      'okhttp3.OkHttpClient$Builder#certificatePinner(okhttp3.CertificatePinner)',
+      'okhttp3.OkHttpClient$Builder#connectTimeout(java.time.Duration)',
+      'okhttp3.OkHttpClient$Builder#connectTimeout(long, java.util.concurrent.TimeUnit)',
+      'okhttp3.OkHttpClient$Builder#connectionPool(okhttp3.ConnectionPool)',
+      'okhttp3.OkHttpClient$Builder#connectionSpecs(java.util.List)',
+      'okhttp3.OkHttpClient$Builder#cookieJar(okhttp3.CookieJar)',
+      'okhttp3.OkHttpClient$Builder#dispatcher(okhttp3.Dispatcher)',
+      'okhttp3.OkHttpClient$Builder#dns(okhttp3.Dns)',
+      'okhttp3.OkHttpClient$Builder#eventListener(okhttp3.EventListener)',
+      'okhttp3.OkHttpClient$Builder#eventListenerFactory(okhttp3.EventListener$Factory)',
+      'okhttp3.OkHttpClient$Builder#followRedirects(boolean)',
+      'okhttp3.OkHttpClient$Builder#followSslRedirects(boolean)',
+      'okhttp3.OkHttpClient$Builder#hostnameVerifier(javax.net.ssl.HostnameVerifier)',
+      'okhttp3.OkHttpClient$Builder#interceptors()',
+      'okhttp3.OkHttpClient$Builder#networkInterceptors()',
+      'okhttp3.OkHttpClient$Builder#pingInterval(java.time.Duration)',
+      'okhttp3.OkHttpClient$Builder#pingInterval(long, java.util.concurrent.TimeUnit)',
+      'okhttp3.OkHttpClient$Builder#protocols(java.util.List)',
+      'okhttp3.OkHttpClient$Builder#proxy(java.net.Proxy)',
+      'okhttp3.OkHttpClient$Builder#proxyAuthenticator(okhttp3.Authenticator)',
+      'okhttp3.OkHttpClient$Builder#proxySelector(java.net.ProxySelector)',
+      'okhttp3.OkHttpClient$Builder#readTimeout(java.time.Duration)',
+      'okhttp3.OkHttpClient$Builder#readTimeout(long, java.util.concurrent.TimeUnit)',
+      'okhttp3.OkHttpClient$Builder#retryOnConnectionFailure(boolean)',
+      'okhttp3.OkHttpClient$Builder#socketFactory(javax.net.SocketFactory)',
+      'okhttp3.OkHttpClient$Builder#sslSocketFactory(javax.net.ssl.SSLSocketFactory)',
+      'okhttp3.OkHttpClient$Builder#sslSocketFactory(javax.net.ssl.SSLSocketFactory, javax.net.ssl.X509TrustManager)',
+      'okhttp3.OkHttpClient$Builder#writeTimeout(java.time.Duration)',
+      'okhttp3.OkHttpClient$Builder#writeTimeout(long, java.util.concurrent.TimeUnit)',
+      'okhttp3.RealCall#getResponseWithInterceptorChain()',
+      'okhttp3.RealCall#redactedUrl()',
+      'okhttp3.RealCall#toLoggableString()',
+      'okhttp3.RealCall$AsyncCall#callsPerHost()',
+      'okhttp3.RealCall$AsyncCall#executeOn(java.util.concurrent.ExecutorService)',
+      'okhttp3.RealCall$AsyncCall#get()',
+      'okhttp3.RealCall$AsyncCall#host()',
+      'okhttp3.RealCall$AsyncCall#request()',
+      'okhttp3.RealCall$AsyncCall#reuseCallsPerHostFrom(okhttp3.RealCall$AsyncCall)',
+      'okhttp3.Request#body()',
+      'okhttp3.Request#cacheControl()',
+      'okhttp3.Request#header(java.lang.String)',
+      'okhttp3.Request#headers()',
+      'okhttp3.Request#headers(java.lang.String)',
+      'okhttp3.Request#isHttps()',
+      'okhttp3.Request#method()',
+      'okhttp3.Request#newBuilder()',
+      'okhttp3.Request#tag()',
+      'okhttp3.Request#tag(java.lang.Class)',
+      'okhttp3.Request#url()',
+      'okhttp3.Response#body()',
+      'okhttp3.Response#cacheControl()',
+      'okhttp3.Response#cacheResponse()',
+      'okhttp3.Response#challenges()',
+      'okhttp3.Response#code()',
+      'okhttp3.Response#handshake()',
+      'okhttp3.Response#header(java.lang.String)',
+      'okhttp3.Response#header(java.lang.String, java.lang.String)',
+      'okhttp3.Response#headers()',
+      'okhttp3.Response#headers(java.lang.String)',
+      'okhttp3.Response#isRedirect()',
+      'okhttp3.Response#isSuccessful()',
+      'okhttp3.Response#message()',
+      'okhttp3.Response#networkResponse()',
+      'okhttp3.Response#newBuilder()',
+      'okhttp3.Response#peekBody(long)',
+      'okhttp3.Response#priorResponse()',
+      'okhttp3.Response#protocol()',
+      'okhttp3.Response#receivedResponseAtMillis()',
+      'okhttp3.Response#request()',
+      'okhttp3.Response#sentRequestAtMillis()',
+      'okhttp3.Response#trailers()',
+      'okhttp3.Route#address()',
+      'okhttp3.Route#proxy()',
+      'okhttp3.Route#requiresTunnel()',
+      'okhttp3.Route#socketAddress()',
+      'okhttp3.TlsVersion#javaName()',
+  ]
+}
+check.dependsOn(japicmp)
diff --git a/okhttp/gradle.properties b/okhttp/gradle.properties
new file mode 100644
index 0000000000..f847919b06
--- /dev/null
+++ b/okhttp/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=okhttp
+POM_NAME=okhttp
+POM_PACKAGING=jar
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
deleted file mode 100644
index 9be94a0861..0000000000
--- a/okhttp/pom.xml
+++ /dev/null
@@ -1,82 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp</artifactId>
-  <name>OkHttp</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okio</groupId>
-      <artifactId>okio</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>org.conscrypt</groupId>
-      <artifactId>conscrypt-openjdk-uber</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.codehaus.mojo</groupId>
-      <artifactId>animal-sniffer-annotations</artifactId>
-      <version>1.17</version>
-      <scope>provided</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>templating-maven-plugin</artifactId>
-        <version>1.0.0</version>
-        <executions>
-          <execution>
-            <goals>
-              <goal>filter-sources</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>3.0.1</version>
-        <configuration>
-          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
-          <links>
-            <link>http://square.github.io/okio/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.1.1</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java b/okhttp/src/main/java-templates/okhttp3/internal/Version.kt
similarity index 81%
rename from okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java
rename to okhttp/src/main/java-templates/okhttp3/internal/Version.kt
index 60b893fbf3..59cb6a5f0b 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java
+++ b/okhttp/src/main/java-templates/okhttp3/internal/Version.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Square, Inc.
+ * Copyright (C) 2014 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+@file:JvmName("Version")
+package okhttp3.internal
 
-public interface UnrepeatableRequestBody {
-}
+const val userAgent = "okhttp/$projectVersion"
diff --git a/okhttp/src/main/java/okhttp3/Address.java b/okhttp/src/main/java/okhttp3/Address.java
deleted file mode 100644
index 5ad2a8d455..0000000000
--- a/okhttp/src/main/java/okhttp3/Address.java
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.util.List;
-import java.util.Objects;
-import javax.annotation.Nullable;
-import javax.net.SocketFactory;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.internal.Util;
-
-/**
- * A specification for a connection to an origin server. For simple connections, this is the
- * server's hostname and port. If an explicit proxy is requested (or {@linkplain Proxy#NO_PROXY no
- * proxy} is explicitly requested), this also includes that proxy information. For secure
- * connections the address also includes the SSL socket factory, hostname verifier, and certificate
- * pinner.
- *
- * <p>HTTP requests that share the same {@code Address} may also share the same {@link Connection}.
- */
-public final class Address {
-  final HttpUrl url;
-  final Dns dns;
-  final SocketFactory socketFactory;
-  final Authenticator proxyAuthenticator;
-  final List<Protocol> protocols;
-  final List<ConnectionSpec> connectionSpecs;
-  final ProxySelector proxySelector;
-  final @Nullable Proxy proxy;
-  final @Nullable SSLSocketFactory sslSocketFactory;
-  final @Nullable HostnameVerifier hostnameVerifier;
-  final @Nullable CertificatePinner certificatePinner;
-
-  public Address(String uriHost, int uriPort, Dns dns, SocketFactory socketFactory,
-      @Nullable SSLSocketFactory sslSocketFactory, @Nullable HostnameVerifier hostnameVerifier,
-      @Nullable CertificatePinner certificatePinner, Authenticator proxyAuthenticator,
-      @Nullable Proxy proxy, List<Protocol> protocols, List<ConnectionSpec> connectionSpecs,
-      ProxySelector proxySelector) {
-    this.url = new HttpUrl.Builder()
-        .scheme(sslSocketFactory != null ? "https" : "http")
-        .host(uriHost)
-        .port(uriPort)
-        .build();
-
-    if (dns == null) throw new NullPointerException("dns == null");
-    this.dns = dns;
-
-    if (socketFactory == null) throw new NullPointerException("socketFactory == null");
-    this.socketFactory = socketFactory;
-
-    if (proxyAuthenticator == null) {
-      throw new NullPointerException("proxyAuthenticator == null");
-    }
-    this.proxyAuthenticator = proxyAuthenticator;
-
-    if (protocols == null) throw new NullPointerException("protocols == null");
-    this.protocols = Util.immutableList(protocols);
-
-    if (connectionSpecs == null) throw new NullPointerException("connectionSpecs == null");
-    this.connectionSpecs = Util.immutableList(connectionSpecs);
-
-    if (proxySelector == null) throw new NullPointerException("proxySelector == null");
-    this.proxySelector = proxySelector;
-
-    this.proxy = proxy;
-    this.sslSocketFactory = sslSocketFactory;
-    this.hostnameVerifier = hostnameVerifier;
-    this.certificatePinner = certificatePinner;
-  }
-
-  /**
-   * Returns a URL with the hostname and port of the origin server. The path, query, and fragment of
-   * this URL are always empty, since they are not significant for planning a route.
-   */
-  public HttpUrl url() {
-    return url;
-  }
-
-  /** Returns the service that will be used to resolve IP addresses for hostnames. */
-  public Dns dns() {
-    return dns;
-  }
-
-  /** Returns the socket factory for new connections. */
-  public SocketFactory socketFactory() {
-    return socketFactory;
-  }
-
-  /** Returns the client's proxy authenticator. */
-  public Authenticator proxyAuthenticator() {
-    return proxyAuthenticator;
-  }
-
-  /**
-   * Returns the protocols the client supports. This method always returns a non-null list that
-   * contains minimally {@link Protocol#HTTP_1_1}.
-   */
-  public List<Protocol> protocols() {
-    return protocols;
-  }
-
-  public List<ConnectionSpec> connectionSpecs() {
-    return connectionSpecs;
-  }
-
-  /**
-   * Returns this address's proxy selector. Only used if the proxy is null. If none of this
-   * selector's proxies are reachable, a direct connection will be attempted.
-   */
-  public ProxySelector proxySelector() {
-    return proxySelector;
-  }
-
-  /**
-   * Returns this address's explicitly-specified HTTP proxy, or null to delegate to the {@linkplain
-   * #proxySelector proxy selector}.
-   */
-  public @Nullable Proxy proxy() {
-    return proxy;
-  }
-
-  /** Returns the SSL socket factory, or null if this is not an HTTPS address. */
-  public @Nullable SSLSocketFactory sslSocketFactory() {
-    return sslSocketFactory;
-  }
-
-  /** Returns the hostname verifier, or null if this is not an HTTPS address. */
-  public @Nullable HostnameVerifier hostnameVerifier() {
-    return hostnameVerifier;
-  }
-
-  /** Returns this address's certificate pinner, or null if this is not an HTTPS address. */
-  public @Nullable CertificatePinner certificatePinner() {
-    return certificatePinner;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof Address
-        && url.equals(((Address) other).url)
-        && equalsNonHost((Address) other);
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + url.hashCode();
-    result = 31 * result + dns.hashCode();
-    result = 31 * result + proxyAuthenticator.hashCode();
-    result = 31 * result + protocols.hashCode();
-    result = 31 * result + connectionSpecs.hashCode();
-    result = 31 * result + proxySelector.hashCode();
-    result = 31 * result + Objects.hashCode(proxy);
-    result = 31 * result + Objects.hashCode(sslSocketFactory);
-    result = 31 * result + Objects.hashCode(hostnameVerifier);
-    result = 31 * result + Objects.hashCode(certificatePinner);
-    return result;
-  }
-
-  boolean equalsNonHost(Address that) {
-    return this.dns.equals(that.dns)
-        && this.proxyAuthenticator.equals(that.proxyAuthenticator)
-        && this.protocols.equals(that.protocols)
-        && this.connectionSpecs.equals(that.connectionSpecs)
-        && this.proxySelector.equals(that.proxySelector)
-        && Objects.equals(this.proxy, that.proxy)
-        && Objects.equals(this.sslSocketFactory, that.sslSocketFactory)
-        && Objects.equals(this.hostnameVerifier, that.hostnameVerifier)
-        && Objects.equals(this.certificatePinner, that.certificatePinner)
-        && this.url().port() == that.url().port();
-  }
-
-  @Override public String toString() {
-    StringBuilder result = new StringBuilder()
-        .append("Address{")
-        .append(url.host()).append(":").append(url.port());
-
-    if (proxy != null) {
-      result.append(", proxy=").append(proxy);
-    } else {
-      result.append(", proxySelector=").append(proxySelector);
-    }
-
-    result.append("}");
-    return result.toString();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Address.kt b/okhttp/src/main/java/okhttp3/Address.kt
new file mode 100644
index 0000000000..8d24789752
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Address.kt
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.net.Proxy
+import java.net.ProxySelector
+import java.util.Objects
+import javax.net.SocketFactory
+import javax.net.ssl.HostnameVerifier
+import javax.net.ssl.SSLSocketFactory
+import okhttp3.internal.Util
+
+/**
+ * A specification for a connection to an origin server. For simple connections, this is the
+ * server's hostname and port. If an explicit proxy is requested (or [no proxy][Proxy.NO_PROXY] is explicitly requested),
+ * this also includes that proxy information. For secure connections the address also includes the SSL socket factory,
+ * hostname verifier, and certificate pinner.
+ *
+ * HTTP requests that share the same `Address` may also share the same [Connection].
+ */
+class Address(
+  uriHost: String,
+  uriPort: Int,
+  private val dns: Dns,
+  private val socketFactory: SocketFactory,
+  private val sslSocketFactory: SSLSocketFactory?,
+  private val hostnameVerifier: HostnameVerifier?,
+  private val certificatePinner: CertificatePinner?,
+  private val proxyAuthenticator: Authenticator,
+  private val proxy: Proxy?,
+  protocols: List<Protocol>,
+  connectionSpecs: List<ConnectionSpec>,
+  private val proxySelector: ProxySelector
+) {
+  private val url: HttpUrl = HttpUrl.Builder()
+      .scheme(if (sslSocketFactory != null) "https" else "http")
+      .host(uriHost)
+      .port(uriPort)
+      .build()
+
+  /**
+   * The protocols the client supports. This method always returns a non-null list that
+   * contains minimally [Protocol.HTTP_1_1].
+   */
+  private val protocols: List<Protocol> = Util.immutableList(protocols)
+
+  private val connectionSpecs: List<ConnectionSpec> = Util.immutableList(connectionSpecs)
+
+  /**
+   * Returns a URL with the hostname and port of the origin server. The path, query, and fragment of
+   * this URL are always empty, since they are not significant for planning a route.
+   */
+  fun url() = url
+
+  /** Returns the service that will be used to resolve IP addresses for hostnames. */
+  fun dns() = dns
+
+  /** Returns the socket factory for new connections. */
+  fun socketFactory() = socketFactory
+
+  /** Returns the client's proxy authenticator. */
+  fun proxyAuthenticator() = proxyAuthenticator
+
+  /**
+   * Returns the protocols the client supports. This method always returns a non-null list that
+   * contains minimally {@link Protocol#HTTP_1_1}.
+   */
+  fun protocols() = protocols
+
+  fun connectionSpecs() = connectionSpecs
+
+  /**
+   * Returns this address's proxy selector. Only used if the proxy is null. If none of this
+   * selector's proxies are reachable, a direct connection will be attempted.
+   */
+  fun proxySelector() = proxySelector
+
+  /**
+   * Returns this address's explicitly-specified HTTP proxy, or null to delegate to the {@linkplain
+   * #proxySelector proxy selector}.
+   */
+  fun proxy() = proxy
+
+  /** Returns the SSL socket factory, or null if this is not an HTTPS address. */
+  fun sslSocketFactory() = sslSocketFactory
+
+  /** Returns the hostname verifier, or null if this is not an HTTPS address. */
+  fun hostnameVerifier() = hostnameVerifier
+
+  /** Returns this address's certificate pinner, or null if this is not an HTTPS address. */
+  fun certificatePinner() = certificatePinner
+
+  override fun equals(other: Any?): Boolean {
+    return other is Address &&
+        url == other.url &&
+        equalsNonHost(other)
+  }
+
+  override fun hashCode(): Int {
+    var result = 17
+    result = 31 * result + url.hashCode()
+    result = 31 * result + dns.hashCode()
+    result = 31 * result + proxyAuthenticator.hashCode()
+    result = 31 * result + protocols.hashCode()
+    result = 31 * result + connectionSpecs.hashCode()
+    result = 31 * result + proxySelector.hashCode()
+    result = 31 * result + Objects.hashCode(proxy)
+    result = 31 * result + Objects.hashCode(sslSocketFactory)
+    result = 31 * result + Objects.hashCode(hostnameVerifier)
+    result = 31 * result + Objects.hashCode(certificatePinner)
+    return result
+  }
+
+  internal fun equalsNonHost(that: Address): Boolean {
+    return this.dns == that.dns &&
+        this.proxyAuthenticator == that.proxyAuthenticator &&
+        this.protocols == that.protocols &&
+        this.connectionSpecs == that.connectionSpecs &&
+        this.proxySelector == that.proxySelector &&
+        this.proxy == that.proxy &&
+        this.sslSocketFactory == that.sslSocketFactory &&
+        this.hostnameVerifier == that.hostnameVerifier &&
+        this.certificatePinner == that.certificatePinner &&
+        this.url().port() == that.url().port()
+  }
+
+  override fun toString(): String {
+    return "Address{" +
+        "${url.host()}:${url.port()}, " +
+        (if (proxy != null) "proxy=$proxy" else "proxySelector=$proxySelector") +
+        "}"
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
deleted file mode 100644
index 6e1d1a4fd5..0000000000
--- a/okhttp/src/main/java/okhttp3/Authenticator.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import javax.annotation.Nullable;
-
-/**
- * Performs either <strong>preemptive</strong> authentication before connecting to a proxy server,
- * or <strong>reactive</strong> authentication after receiving a challenge from either an origin web
- * server or proxy server.
- *
- * <h3>Preemptive Authentication</h3>
- *
- * <p>To make HTTPS calls using an HTTP proxy server OkHttp must first negotiate a connection with
- * the proxy. This proxy connection is called a "TLS Tunnel" and is specified by <a
- * href="https://tools.ietf.org/html/rfc2817">RFC 2817</a>. The HTTP CONNECT request that creates
- * this tunnel connection is special: it does not participate in any {@linkplain Interceptor
- * interceptors} or {@linkplain EventListener event listeners}. It doesn't include the motivating
- * request's HTTP headers or even its full URL; only the target server's hostname is sent to the
- * proxy.
- *
- * <p>Prior to sending any CONNECT request OkHttp always calls the proxy authenticator so that it
- * may prepare preemptive authentication. OkHttp will call {@link #authenticate} with a fake {@code
- * HTTP/1.1 407 Proxy Authentication Required} response that has a {@code Proxy-Authenticate:
- * OkHttp-Preemptive} challenge. The proxy authenticator may return either either an authenticated
- * request, or null to connect without authentication.
- * <pre>   {@code
- *    for (Challenge challenge : response.challenges()) {
- *      // If this is preemptive auth, use a preemptive credential.
- *      if (challenge.scheme().equalsIgnoreCase("OkHttp-Preemptive")) {
- *        return response.request().newBuilder()
- *            .header("Proxy-Authorization", "secret")
- *            .build();
- *      }
- *    }
- *
- *    return null; // Didn't find a preemptive auth scheme.
- * }</pre>
- *
- * <h3>Reactive Authentication</h3>
- *
- * <p>Implementations authenticate by returning a follow-up request that includes an authorization
- * header, or they may decline the challenge by returning null. In this case the unauthenticated
- * response will be returned to the caller that triggered it.
- *
- * <p>Implementations should check if the initial request already included an attempt to
- * authenticate. If so it is likely that further attempts will not be useful and the authenticator
- * should give up.
- *
- * <p>When reactive authentication is requested by an origin web server, the response code is 401
- * and the implementation should respond with a new request that sets the "Authorization" header.
- * <pre>   {@code
- *
- *    if (response.request().header("Authorization") != null) {
- *      return null; // Give up, we've already failed to authenticate.
- *    }
- *
- *    String credential = Credentials.basic(...)
- *    return response.request().newBuilder()
- *        .header("Authorization", credential)
- *        .build();
- * }</pre>
- *
- * <p>When reactive authentication is requested by a proxy server, the response code is 407 and the
- * implementation should respond with a new request that sets the "Proxy-Authorization" header.
- * <pre>   {@code
- *
- *    if (response.request().header("Proxy-Authorization") != null) {
- *      return null; // Give up, we've already failed to authenticate.
- *    }
- *
- *    String credential = Credentials.basic(...)
- *    return response.request().newBuilder()
- *        .header("Proxy-Authorization", credential)
- *        .build();
- * }</pre>
- *
- * <p>The proxy authenticator may implement preemptive authentication, reactive authentication, or
- * both.
- *
- * <p>Applications may configure OkHttp with an authenticator for origin servers, or proxy servers,
- * or both.
- */
-public interface Authenticator {
-  /** An authenticator that knows no credentials and makes no attempt to authenticate. */
-  Authenticator NONE = (route, response) -> null;
-
-  /**
-   * Returns a request that includes a credential to satisfy an authentication challenge in {@code
-   * response}. Returns null if the challenge cannot be satisfied.
-   *
-   * <p>The route is best effort, it currently may not always be provided even when logically
-   * available. It may also not be provided when an authenticator is re-used manually in an
-   * application interceptor, such as when implementing client-specific retries.
-   */
-  @Nullable Request authenticate(@Nullable Route route, Response response) throws IOException;
-}
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.kt b/okhttp/src/main/java/okhttp3/Authenticator.kt
new file mode 100644
index 0000000000..31031f3879
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Authenticator.kt
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.io.IOException
+
+/**
+ * Performs either **preemptive** authentication before connecting to a proxy server, or
+ * **reactive** authentication after receiving a challenge from either an origin web server or proxy
+ * server.
+ *
+ * ## Preemptive Authentication
+ *
+ * To make HTTPS calls using an HTTP proxy server OkHttp must first negotiate a connection with
+ * the proxy. This proxy connection is called a "TLS Tunnel" and is specified by
+ * [RFC 2817][rfc_2817]. The HTTP CONNECT request that creates this tunnel connection is special: it
+ * does not participate in any [interceptors][Interceptor] or [event listeners][EventListener]. It
+ * doesn't include the motivating request's HTTP headers or even its full URL; only the target
+ * server's hostname is sent to the proxy.
+ *
+ * Prior to sending any CONNECT request OkHttp always calls the proxy authenticator so that it may
+ * prepare preemptive authentication. OkHttp will call [authenticate] with a fake `HTTP/1.1 407
+ * Proxy Authentication Required` response that has a `Proxy-Authenticate: OkHttp-Preemptive`
+ * challenge. The proxy authenticator may return either either an authenticated request, or null to
+ * connect without authentication.
+ *
+ * ```
+ * for (Challenge challenge : response.challenges()) {
+ *   // If this is preemptive auth, use a preemptive credential.
+ *   if (challenge.scheme().equalsIgnoreCase("OkHttp-Preemptive")) {
+ *     return response.request().newBuilder()
+ *         .header("Proxy-Authorization", "secret")
+ *         .build();
+ *   }
+ * }
+ * return null; // Didn't find a preemptive auth scheme.
+ * ```
+ *
+ * ## Reactive Authentication
+ *
+ * Implementations authenticate by returning a follow-up request that includes an authorization
+ * header, or they may decline the challenge by returning null. In this case the unauthenticated
+ * response will be returned to the caller that triggered it.
+ *
+ * Implementations should check if the initial request already included an attempt to
+ * authenticate. If so it is likely that further attempts will not be useful and the authenticator
+ * should give up.
+ *
+ * When reactive authentication is requested by an origin web server, the response code is 401
+ * and the implementation should respond with a new request that sets the "Authorization" header.
+ *
+ * ```
+ * if (response.request().header("Authorization") != null) {
+ *   return null; // Give up, we've already failed to authenticate.
+ * }
+ *
+ * String credential = Credentials.basic(...)
+ * return response.request().newBuilder()
+ *     .header("Authorization", credential)
+ *     .build();
+ * ```
+ *
+ * When reactive authentication is requested by a proxy server, the response code is 407 and the
+ * implementation should respond with a new request that sets the "Proxy-Authorization" header.
+ *
+ * ```
+ * if (response.request().header("Proxy-Authorization") != null) {
+ *   return null; // Give up, we've already failed to authenticate.
+ * }
+ *
+ * String credential = Credentials.basic(...)
+ * return response.request().newBuilder()
+ *     .header("Proxy-Authorization", credential)
+ *     .build();
+ * ```
+ *
+ * The proxy authenticator may implement preemptive authentication, reactive authentication, or
+ * both.
+ *
+ * Applications may configure OkHttp with an authenticator for origin servers, or proxy servers,
+ * or both.
+ *
+ * [rfc_2817]: https://tools.ietf.org/html/rfc2817
+ */
+interface Authenticator {
+  /**
+   * Returns a request that includes a credential to satisfy an authentication challenge in
+   * `response`. Returns null if the challenge cannot be satisfied.
+   *
+   * The route is best effort, it currently may not always be provided even when logically
+   * available. It may also not be provided when an authenticator is re-used manually in an
+   * application interceptor, such as when implementing client-specific retries.
+   */
+  @Throws(IOException::class)
+  fun authenticate(route: Route?, response: Response): Request?
+
+  companion object {
+    /** An authenticator that knows no credentials and makes no attempt to authenticate.  */
+    @JvmField
+    val NONE = object : Authenticator {
+      override fun authenticate(route: Route?, response: Response): Request? = null
+    }
+
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName("-deprecated_Authenticator")
+    inline operator fun invoke(
+      crossinline block: (route: Route?, response: Response) -> Request?
+    ): Authenticator = object : Authenticator {
+      override fun authenticate(route: Route?, response: Response) = block(route, response)
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
deleted file mode 100644
index 2ba97ffd0f..0000000000
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ /dev/null
@@ -1,771 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.Closeable;
-import java.io.File;
-import java.io.Flushable;
-import java.io.IOException;
-import java.security.cert.Certificate;
-import java.security.cert.CertificateEncodingException;
-import java.security.cert.CertificateException;
-import java.security.cert.CertificateFactory;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.NoSuchElementException;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.cache.CacheRequest;
-import okhttp3.internal.cache.CacheStrategy;
-import okhttp3.internal.cache.DiskLruCache;
-import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.StatusLine;
-import okhttp3.internal.io.FileSystem;
-import okhttp3.internal.platform.Platform;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.ForwardingSink;
-import okio.ForwardingSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-
-/**
- * Caches HTTP and HTTPS responses to the filesystem so they may be reused, saving time and
- * bandwidth.
- *
- * <h3>Cache Optimization</h3>
- *
- * <p>To measure cache effectiveness, this class tracks three statistics:
- * <ul>
- *     <li><strong>{@linkplain #requestCount() Request Count:}</strong> the number of HTTP
- *         requests issued since this cache was created.
- *     <li><strong>{@linkplain #networkCount() Network Count:}</strong> the number of those
- *         requests that required network use.
- *     <li><strong>{@linkplain #hitCount() Hit Count:}</strong> the number of those requests
- *         whose responses were served by the cache.
- * </ul>
- *
- * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
- * the response, the client will issue a conditional {@code GET}. The server will then send either
- * the updated response if it has changed, or a short 'not modified' response if the client's copy
- * is still valid. Such responses increment both the network count and hit count.
- *
- * <p>The best way to improve the cache hit rate is by configuring the web server to return
- * cacheable responses. Although this client honors all <a
- * href="http://tools.ietf.org/html/rfc7234">HTTP/1.1 (RFC 7234)</a> cache headers, it doesn't cache
- * partial responses.
- *
- * <h3>Force a Network Response</h3>
- *
- * <p>In some situations, such as after a user clicks a 'refresh' button, it may be necessary to
- * skip the cache, and fetch data directly from the server. To force a full refresh, add the {@code
- * no-cache} directive: <pre>   {@code
- *
- *   Request request = new Request.Builder()
- *       .cacheControl(new CacheControl.Builder().noCache().build())
- *       .url("http://publicobject.com/helloworld.txt")
- *       .build();
- * }</pre>
- *
- * If it is only necessary to force a cached response to be validated by the server, use the more
- * efficient {@code max-age=0} directive instead: <pre>   {@code
- *
- *   Request request = new Request.Builder()
- *       .cacheControl(new CacheControl.Builder()
- *           .maxAge(0, TimeUnit.SECONDS)
- *           .build())
- *       .url("http://publicobject.com/helloworld.txt")
- *       .build();
- * }</pre>
- *
- * <h3>Force a Cache Response</h3>
- *
- * <p>Sometimes you'll want to show resources if they are available immediately, but not otherwise.
- * This can be used so your application can show <i>something</i> while waiting for the latest data
- * to be downloaded. To restrict a request to locally-cached resources, add the {@code
- * only-if-cached} directive: <pre>   {@code
- *
- *     Request request = new Request.Builder()
- *         .cacheControl(new CacheControl.Builder()
- *             .onlyIfCached()
- *             .build())
- *         .url("http://publicobject.com/helloworld.txt")
- *         .build();
- *     Response forceCacheResponse = client.newCall(request).execute();
- *     if (forceCacheResponse.code() != 504) {
- *       // The resource was cached! Show it.
- *     } else {
- *       // The resource was not cached.
- *     }
- * }</pre>
- * This technique works even better in situations where a stale response is better than no response.
- * To permit stale cached responses, use the {@code max-stale} directive with the maximum staleness
- * in seconds: <pre>   {@code
- *
- *   Request request = new Request.Builder()
- *       .cacheControl(new CacheControl.Builder()
- *           .maxStale(365, TimeUnit.DAYS)
- *           .build())
- *       .url("http://publicobject.com/helloworld.txt")
- *       .build();
- * }</pre>
- *
- * <p>The {@link CacheControl} class can configure request caching directives and parse response
- * caching directives. It even offers convenient constants {@link CacheControl#FORCE_NETWORK} and
- * {@link CacheControl#FORCE_CACHE} that address the use cases above.
- */
-public final class Cache implements Closeable, Flushable {
-  private static final int VERSION = 201105;
-  private static final int ENTRY_METADATA = 0;
-  private static final int ENTRY_BODY = 1;
-  private static final int ENTRY_COUNT = 2;
-
-  final InternalCache internalCache = new InternalCache() {
-    @Override public @Nullable Response get(Request request) throws IOException {
-      return Cache.this.get(request);
-    }
-
-    @Override public @Nullable CacheRequest put(Response response) throws IOException {
-      return Cache.this.put(response);
-    }
-
-    @Override public void remove(Request request) throws IOException {
-      Cache.this.remove(request);
-    }
-
-    @Override public void update(Response cached, Response network) {
-      Cache.this.update(cached, network);
-    }
-
-    @Override public void trackConditionalCacheHit() {
-      Cache.this.trackConditionalCacheHit();
-    }
-
-    @Override public void trackResponse(CacheStrategy cacheStrategy) {
-      Cache.this.trackResponse(cacheStrategy);
-    }
-  };
-
-  final DiskLruCache cache;
-
-  /* read and write statistics, all guarded by 'this' */
-  int writeSuccessCount;
-  int writeAbortCount;
-  private int networkCount;
-  private int hitCount;
-  private int requestCount;
-
-  /**
-   * Create a cache of at most {@code maxSize} bytes in {@code directory}.
-   */
-  public Cache(File directory, long maxSize) {
-    this(directory, maxSize, FileSystem.SYSTEM);
-  }
-
-  Cache(File directory, long maxSize, FileSystem fileSystem) {
-    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);
-  }
-
-  public static String key(HttpUrl url) {
-    return ByteString.encodeUtf8(url.toString()).md5().hex();
-  }
-
-  @Nullable Response get(Request request) {
-    String key = key(request.url());
-    DiskLruCache.Snapshot snapshot;
-    Entry entry;
-    try {
-      snapshot = cache.get(key);
-      if (snapshot == null) {
-        return null;
-      }
-    } catch (IOException e) {
-      // Give up because the cache cannot be read.
-      return null;
-    }
-
-    try {
-      entry = new Entry(snapshot.getSource(ENTRY_METADATA));
-    } catch (IOException e) {
-      Util.closeQuietly(snapshot);
-      return null;
-    }
-
-    Response response = entry.response(snapshot);
-
-    if (!entry.matches(request, response)) {
-      Util.closeQuietly(response.body());
-      return null;
-    }
-
-    return response;
-  }
-
-  @Nullable CacheRequest put(Response response) {
-    String requestMethod = response.request().method();
-
-    if (HttpMethod.invalidatesCache(response.request().method())) {
-      try {
-        remove(response.request());
-      } catch (IOException ignored) {
-        // The cache cannot be written.
-      }
-      return null;
-    }
-    if (!requestMethod.equals("GET")) {
-      // Don't cache non-GET responses. We're technically allowed to cache
-      // HEAD requests and some POST requests, but the complexity of doing
-      // so is high and the benefit is low.
-      return null;
-    }
-
-    if (HttpHeaders.hasVaryAll(response)) {
-      return null;
-    }
-
-    Entry entry = new Entry(response);
-    DiskLruCache.Editor editor = null;
-    try {
-      editor = cache.edit(key(response.request().url()));
-      if (editor == null) {
-        return null;
-      }
-      entry.writeTo(editor);
-      return new CacheRequestImpl(editor);
-    } catch (IOException e) {
-      abortQuietly(editor);
-      return null;
-    }
-  }
-
-  void remove(Request request) throws IOException {
-    cache.remove(key(request.url()));
-  }
-
-  void update(Response cached, Response network) {
-    Entry entry = new Entry(network);
-    DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
-    DiskLruCache.Editor editor = null;
-    try {
-      editor = snapshot.edit(); // Returns null if snapshot is not current.
-      if (editor != null) {
-        entry.writeTo(editor);
-        editor.commit();
-      }
-    } catch (IOException e) {
-      abortQuietly(editor);
-    }
-  }
-
-  private void abortQuietly(@Nullable DiskLruCache.Editor editor) {
-    // Give up because the cache cannot be written.
-    try {
-      if (editor != null) {
-        editor.abort();
-      }
-    } catch (IOException ignored) {
-    }
-  }
-
-  /**
-   * Initialize the cache. This will include reading the journal files from the storage and building
-   * up the necessary in-memory cache information.
-   *
-   * <p>The initialization time may vary depending on the journal file size and the current actual
-   * cache size. The application needs to be aware of calling this function during the
-   * initialization phase and preferably in a background worker thread.
-   *
-   * <p>Note that if the application chooses to not call this method to initialize the cache. By
-   * default, the okhttp will perform lazy initialization upon the first usage of the cache.
-   */
-  public void initialize() throws IOException {
-    cache.initialize();
-  }
-
-  /**
-   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
-   * directory including files that weren't created by the cache.
-   */
-  public void delete() throws IOException {
-    cache.delete();
-  }
-
-  /**
-   * Deletes all values stored in the cache. In-flight writes to the cache will complete normally,
-   * but the corresponding responses will not be stored.
-   */
-  public void evictAll() throws IOException {
-    cache.evictAll();
-  }
-
-  /**
-   * Returns an iterator over the URLs in this cache. This iterator doesn't throw {@code
-   * ConcurrentModificationException}, but if new responses are added while iterating, their URLs
-   * will not be returned. If existing responses are evicted during iteration, they will be absent
-   * (unless they were already returned).
-   *
-   * <p>The iterator supports {@linkplain Iterator#remove}. Removing a URL from the iterator evicts
-   * the corresponding response from the cache. Use this to evict selected responses.
-   */
-  public Iterator<String> urls() throws IOException {
-    return new Iterator<String>() {
-      final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
-
-      @Nullable String nextUrl;
-      boolean canRemove;
-
-      @Override public boolean hasNext() {
-        if (nextUrl != null) return true;
-
-        canRemove = false; // Prevent delegate.remove() on the wrong item!
-        while (delegate.hasNext()) {
-          try (DiskLruCache.Snapshot snapshot = delegate.next()) {
-            BufferedSource metadata = Okio.buffer(snapshot.getSource(ENTRY_METADATA));
-            nextUrl = metadata.readUtf8LineStrict();
-            return true;
-          } catch (IOException ignored) {
-            // We couldn't read the metadata for this snapshot; possibly because the host filesystem
-            // has disappeared! Skip it.
-          }
-        }
-
-        return false;
-      }
-
-      @Override public String next() {
-        if (!hasNext()) throw new NoSuchElementException();
-        String result = nextUrl;
-        nextUrl = null;
-        canRemove = true;
-        return result;
-      }
-
-      @Override public void remove() {
-        if (!canRemove) throw new IllegalStateException("remove() before next()");
-        delegate.remove();
-      }
-    };
-  }
-
-  public synchronized int writeAbortCount() {
-    return writeAbortCount;
-  }
-
-  public synchronized int writeSuccessCount() {
-    return writeSuccessCount;
-  }
-
-  public long size() throws IOException {
-    return cache.size();
-  }
-
-  /** Max size of the cache (in bytes). */
-  public long maxSize() {
-    return cache.getMaxSize();
-  }
-
-  @Override public void flush() throws IOException {
-    cache.flush();
-  }
-
-  @Override public void close() throws IOException {
-    cache.close();
-  }
-
-  public File directory() {
-    return cache.getDirectory();
-  }
-
-  public boolean isClosed() {
-    return cache.isClosed();
-  }
-
-  synchronized void trackResponse(CacheStrategy cacheStrategy) {
-    requestCount++;
-
-    if (cacheStrategy.networkRequest != null) {
-      // If this is a conditional request, we'll increment hitCount if/when it hits.
-      networkCount++;
-    } else if (cacheStrategy.cacheResponse != null) {
-      // This response uses the cache and not the network. That's a cache hit.
-      hitCount++;
-    }
-  }
-
-  synchronized void trackConditionalCacheHit() {
-    hitCount++;
-  }
-
-  public synchronized int networkCount() {
-    return networkCount;
-  }
-
-  public synchronized int hitCount() {
-    return hitCount;
-  }
-
-  public synchronized int requestCount() {
-    return requestCount;
-  }
-
-  private final class CacheRequestImpl implements CacheRequest {
-    private final DiskLruCache.Editor editor;
-    private Sink cacheOut;
-    private Sink body;
-    boolean done;
-
-    CacheRequestImpl(final DiskLruCache.Editor editor) {
-      this.editor = editor;
-      this.cacheOut = editor.newSink(ENTRY_BODY);
-      this.body = new ForwardingSink(cacheOut) {
-        @Override public void close() throws IOException {
-          synchronized (Cache.this) {
-            if (done) {
-              return;
-            }
-            done = true;
-            writeSuccessCount++;
-          }
-          super.close();
-          editor.commit();
-        }
-      };
-    }
-
-    @Override public void abort() {
-      synchronized (Cache.this) {
-        if (done) {
-          return;
-        }
-        done = true;
-        writeAbortCount++;
-      }
-      Util.closeQuietly(cacheOut);
-      try {
-        editor.abort();
-      } catch (IOException ignored) {
-      }
-    }
-
-    @Override public Sink body() {
-      return body;
-    }
-  }
-
-  private static final class Entry {
-    /** Synthetic response header: the local time when the request was sent. */
-    private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
-
-    /** Synthetic response header: the local time when the response was received. */
-    private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
-
-    private final String url;
-    private final Headers varyHeaders;
-    private final String requestMethod;
-    private final Protocol protocol;
-    private final int code;
-    private final String message;
-    private final Headers responseHeaders;
-    private final @Nullable Handshake handshake;
-    private final long sentRequestMillis;
-    private final long receivedResponseMillis;
-
-    /**
-     * Reads an entry from an input stream. A typical entry looks like this:
-     * <pre>{@code
-     *   http://google.com/foo
-     *   GET
-     *   2
-     *   Accept-Language: fr-CA
-     *   Accept-Charset: UTF-8
-     *   HTTP/1.1 200 OK
-     *   3
-     *   Content-Type: image/png
-     *   Content-Length: 100
-     *   Cache-Control: max-age=600
-     * }</pre>
-     *
-     * <p>A typical HTTPS file looks like this:
-     * <pre>{@code
-     *   https://google.com/foo
-     *   GET
-     *   2
-     *   Accept-Language: fr-CA
-     *   Accept-Charset: UTF-8
-     *   HTTP/1.1 200 OK
-     *   3
-     *   Content-Type: image/png
-     *   Content-Length: 100
-     *   Cache-Control: max-age=600
-     *
-     *   AES_256_WITH_MD5
-     *   2
-     *   base64-encoded peerCertificate[0]
-     *   base64-encoded peerCertificate[1]
-     *   -1
-     *   TLSv1.2
-     * }</pre>
-     * The file is newline separated. The first two lines are the URL and the request method. Next
-     * is the number of HTTP Vary request header lines, followed by those lines.
-     *
-     * <p>Next is the response status line, followed by the number of HTTP response header lines,
-     * followed by those lines.
-     *
-     * <p>HTTPS responses also contain SSL session information. This begins with a blank line, and
-     * then a line containing the cipher suite. Next is the length of the peer certificate chain.
-     * These certificates are base64-encoded and appear each on their own line. The next line
-     * contains the length of the local certificate chain. These certificates are also
-     * base64-encoded and appear each on their own line. A length of -1 is used to encode a null
-     * array. The last line is optional. If present, it contains the TLS version.
-     */
-    Entry(Source in) throws IOException {
-      try {
-        BufferedSource source = Okio.buffer(in);
-        url = source.readUtf8LineStrict();
-        requestMethod = source.readUtf8LineStrict();
-        Headers.Builder varyHeadersBuilder = new Headers.Builder();
-        int varyRequestHeaderLineCount = readInt(source);
-        for (int i = 0; i < varyRequestHeaderLineCount; i++) {
-          varyHeadersBuilder.addLenient(source.readUtf8LineStrict());
-        }
-        varyHeaders = varyHeadersBuilder.build();
-
-        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
-        protocol = statusLine.protocol;
-        code = statusLine.code;
-        message = statusLine.message;
-        Headers.Builder responseHeadersBuilder = new Headers.Builder();
-        int responseHeaderLineCount = readInt(source);
-        for (int i = 0; i < responseHeaderLineCount; i++) {
-          responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
-        }
-        String sendRequestMillisString = responseHeadersBuilder.get(SENT_MILLIS);
-        String receivedResponseMillisString = responseHeadersBuilder.get(RECEIVED_MILLIS);
-        responseHeadersBuilder.removeAll(SENT_MILLIS);
-        responseHeadersBuilder.removeAll(RECEIVED_MILLIS);
-        sentRequestMillis = sendRequestMillisString != null
-            ? Long.parseLong(sendRequestMillisString)
-            : 0L;
-        receivedResponseMillis = receivedResponseMillisString != null
-            ? Long.parseLong(receivedResponseMillisString)
-            : 0L;
-        responseHeaders = responseHeadersBuilder.build();
-
-        if (isHttps()) {
-          String blank = source.readUtf8LineStrict();
-          if (blank.length() > 0) {
-            throw new IOException("expected \"\" but was \"" + blank + "\"");
-          }
-          String cipherSuiteString = source.readUtf8LineStrict();
-          CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-          List<Certificate> peerCertificates = readCertificateList(source);
-          List<Certificate> localCertificates = readCertificateList(source);
-          TlsVersion tlsVersion = !source.exhausted()
-              ? TlsVersion.forJavaName(source.readUtf8LineStrict())
-              : TlsVersion.SSL_3_0;
-          handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);
-        } else {
-          handshake = null;
-        }
-      } finally {
-        in.close();
-      }
-    }
-
-    Entry(Response response) {
-      this.url = response.request().url().toString();
-      this.varyHeaders = HttpHeaders.varyHeaders(response);
-      this.requestMethod = response.request().method();
-      this.protocol = response.protocol();
-      this.code = response.code();
-      this.message = response.message();
-      this.responseHeaders = response.headers();
-      this.handshake = response.handshake();
-      this.sentRequestMillis = response.sentRequestAtMillis();
-      this.receivedResponseMillis = response.receivedResponseAtMillis();
-    }
-
-    public void writeTo(DiskLruCache.Editor editor) throws IOException {
-      BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
-
-      sink.writeUtf8(url)
-          .writeByte('\n');
-      sink.writeUtf8(requestMethod)
-          .writeByte('\n');
-      sink.writeDecimalLong(varyHeaders.size())
-          .writeByte('\n');
-      for (int i = 0, size = varyHeaders.size(); i < size; i++) {
-        sink.writeUtf8(varyHeaders.name(i))
-            .writeUtf8(": ")
-            .writeUtf8(varyHeaders.value(i))
-            .writeByte('\n');
-      }
-
-      sink.writeUtf8(new StatusLine(protocol, code, message).toString())
-          .writeByte('\n');
-      sink.writeDecimalLong(responseHeaders.size() + 2)
-          .writeByte('\n');
-      for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-        sink.writeUtf8(responseHeaders.name(i))
-            .writeUtf8(": ")
-            .writeUtf8(responseHeaders.value(i))
-            .writeByte('\n');
-      }
-      sink.writeUtf8(SENT_MILLIS)
-          .writeUtf8(": ")
-          .writeDecimalLong(sentRequestMillis)
-          .writeByte('\n');
-      sink.writeUtf8(RECEIVED_MILLIS)
-          .writeUtf8(": ")
-          .writeDecimalLong(receivedResponseMillis)
-          .writeByte('\n');
-
-      if (isHttps()) {
-        sink.writeByte('\n');
-        sink.writeUtf8(handshake.cipherSuite().javaName())
-            .writeByte('\n');
-        writeCertList(sink, handshake.peerCertificates());
-        writeCertList(sink, handshake.localCertificates());
-        sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte('\n');
-      }
-      sink.close();
-    }
-
-    private boolean isHttps() {
-      return url.startsWith("https://");
-    }
-
-    private List<Certificate> readCertificateList(BufferedSource source) throws IOException {
-      int length = readInt(source);
-      if (length == -1) return Collections.emptyList(); // OkHttp v1.2 used -1 to indicate null.
-
-      try {
-        CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-        List<Certificate> result = new ArrayList<>(length);
-        for (int i = 0; i < length; i++) {
-          String line = source.readUtf8LineStrict();
-          Buffer bytes = new Buffer();
-          bytes.write(ByteString.decodeBase64(line));
-          result.add(certificateFactory.generateCertificate(bytes.inputStream()));
-        }
-        return result;
-      } catch (CertificateException e) {
-        throw new IOException(e.getMessage());
-      }
-    }
-
-    private void writeCertList(BufferedSink sink, List<Certificate> certificates)
-        throws IOException {
-      try {
-        sink.writeDecimalLong(certificates.size())
-            .writeByte('\n');
-        for (int i = 0, size = certificates.size(); i < size; i++) {
-          byte[] bytes = certificates.get(i).getEncoded();
-          String line = ByteString.of(bytes).base64();
-          sink.writeUtf8(line)
-              .writeByte('\n');
-        }
-      } catch (CertificateEncodingException e) {
-        throw new IOException(e.getMessage());
-      }
-    }
-
-    public boolean matches(Request request, Response response) {
-      return url.equals(request.url().toString())
-          && requestMethod.equals(request.method())
-          && HttpHeaders.varyMatches(response, varyHeaders, request);
-    }
-
-    public Response response(DiskLruCache.Snapshot snapshot) {
-      String contentType = responseHeaders.get("Content-Type");
-      String contentLength = responseHeaders.get("Content-Length");
-      Request cacheRequest = new Request.Builder()
-          .url(url)
-          .method(requestMethod, null)
-          .headers(varyHeaders)
-          .build();
-      return new Response.Builder()
-          .request(cacheRequest)
-          .protocol(protocol)
-          .code(code)
-          .message(message)
-          .headers(responseHeaders)
-          .body(new CacheResponseBody(snapshot, contentType, contentLength))
-          .handshake(handshake)
-          .sentRequestAtMillis(sentRequestMillis)
-          .receivedResponseAtMillis(receivedResponseMillis)
-          .build();
-    }
-  }
-
-  static int readInt(BufferedSource source) throws IOException {
-    try {
-      long result = source.readDecimalLong();
-      String line = source.readUtf8LineStrict();
-      if (result < 0 || result > Integer.MAX_VALUE || !line.isEmpty()) {
-        throw new IOException("expected an int but was \"" + result + line + "\"");
-      }
-      return (int) result;
-    } catch (NumberFormatException e) {
-      throw new IOException(e.getMessage());
-    }
-  }
-
-  private static class CacheResponseBody extends ResponseBody {
-    final DiskLruCache.Snapshot snapshot;
-    private final BufferedSource bodySource;
-    private final @Nullable String contentType;
-    private final @Nullable String contentLength;
-
-    CacheResponseBody(final DiskLruCache.Snapshot snapshot,
-        String contentType, String contentLength) {
-      this.snapshot = snapshot;
-      this.contentType = contentType;
-      this.contentLength = contentLength;
-
-      Source source = snapshot.getSource(ENTRY_BODY);
-      bodySource = Okio.buffer(new ForwardingSource(source) {
-        @Override public void close() throws IOException {
-          snapshot.close();
-          super.close();
-        }
-      });
-    }
-
-    @Override public MediaType contentType() {
-      return contentType != null ? MediaType.parse(contentType) : null;
-    }
-
-    @Override public long contentLength() {
-      try {
-        return contentLength != null ? Long.parseLong(contentLength) : -1;
-      } catch (NumberFormatException e) {
-        return -1;
-      }
-    }
-
-    @Override public BufferedSource source() {
-      return bodySource;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Cache.kt b/okhttp/src/main/java/okhttp3/Cache.kt
new file mode 100644
index 0000000000..2f4763d2c8
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Cache.kt
@@ -0,0 +1,740 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.Util.closeQuietly
+import okhttp3.internal.addHeaderLenient
+import okhttp3.internal.cache.CacheRequest
+import okhttp3.internal.cache.CacheStrategy
+import okhttp3.internal.cache.DiskLruCache
+import okhttp3.internal.cache.InternalCache
+import okhttp3.internal.http.HttpHeaders
+import okhttp3.internal.http.HttpMethod
+import okhttp3.internal.http.StatusLine
+import okhttp3.internal.io.FileSystem
+import okhttp3.internal.platform.Platform
+import okio.Buffer
+import okio.BufferedSink
+import okio.BufferedSource
+import okio.ByteString
+import okio.ByteString.Companion.decodeBase64
+import okio.ByteString.Companion.encodeUtf8
+import okio.ForwardingSink
+import okio.ForwardingSource
+import okio.Sink
+import okio.Source
+import okio.buffer
+import java.io.Closeable
+import java.io.File
+import java.io.Flushable
+import java.io.IOException
+import java.security.cert.Certificate
+import java.security.cert.CertificateEncodingException
+import java.security.cert.CertificateException
+import java.security.cert.CertificateFactory
+import java.util.ArrayList
+import java.util.NoSuchElementException
+
+/**
+ * Caches HTTP and HTTPS responses to the filesystem so they may be reused, saving time and
+ * bandwidth.
+ *
+ * ## Cache Optimization
+ *
+ * To measure cache effectiveness, this class tracks three statistics:
+ *
+ *  * **[Request Count:][requestCount]** the number of HTTP requests issued since this cache was
+ *    created.
+ *  * **[Network Count:][networkCount]** the number of those requests that required network use.
+ *  * **[Hit Count:][hitCount]** the number of those requests whose responses were served by the
+ *    cache.
+ *
+ * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
+ * the response, the client will issue a conditional `GET`. The server will then send either
+ * the updated response if it has changed, or a short 'not modified' response if the client's copy
+ * is still valid. Such responses increment both the network count and hit count.
+ *
+ * The best way to improve the cache hit rate is by configuring the web server to return cacheable
+ * responses. Although this client honors all [HTTP/1.1 (RFC 7234)][rfc_7234] cache headers, it
+ * doesn't cache partial responses.
+ *
+ * ## Force a Network Response
+ *
+ * In some situations, such as after a user clicks a 'refresh' button, it may be necessary to skip
+ * the cache, and fetch data directly from the server. To force a full refresh, add the `no-cache`
+ * directive:
+ *
+ * ```
+ * Request request = new Request.Builder()
+ *     .cacheControl(new CacheControl.Builder().noCache().build())
+ *     .url("http://publicobject.com/helloworld.txt")
+ *     .build();
+ * ```
+ *
+ * If it is only necessary to force a cached response to be validated by the server, use the more
+ * efficient `max-age=0` directive instead:
+ *
+ * ```
+ * Request request = new Request.Builder()
+ *     .cacheControl(new CacheControl.Builder()
+ *         .maxAge(0, TimeUnit.SECONDS)
+ *         .build())
+ *     .url("http://publicobject.com/helloworld.txt")
+ *     .build();
+ * ```
+ *
+ * ## Force a Cache Response
+ *
+ * Sometimes you'll want to show resources if they are available immediately, but not otherwise.
+ * This can be used so your application can show *something* while waiting for the latest data to be
+ * downloaded. To restrict a request to locally-cached resources, add the `only-if-cached`
+ * directive:
+ *
+ * ```
+ * Request request = new Request.Builder()
+ *     .cacheControl(new CacheControl.Builder()
+ *         .onlyIfCached()
+ *         .build())
+ *     .url("http://publicobject.com/helloworld.txt")
+ *     .build();
+ * Response forceCacheResponse = client.newCall(request).execute();
+ * if (forceCacheResponse.code() != 504) {
+ *   // The resource was cached! Show it.
+ * } else {
+ *   // The resource was not cached.
+ * }
+ * ```
+ *
+ * This technique works even better in situations where a stale response is better than no response.
+ * To permit stale cached responses, use the `max-stale` directive with the maximum staleness in
+ * seconds:
+ *
+ * ```
+ * Request request = new Request.Builder()
+ *     .cacheControl(new CacheControl.Builder()
+ *         .maxStale(365, TimeUnit.DAYS)
+ *         .build())
+ *     .url("http://publicobject.com/helloworld.txt")
+ *     .build();
+ * ```
+ *
+ * The [CacheControl] class can configure request caching directives and parse response caching
+ * directives. It even offers convenient constants [CacheControl.FORCE_NETWORK] and
+ * [CacheControl.FORCE_CACHE] that address the use cases above.
+ *
+ * [rfc_7234]: http://tools.ietf.org/html/rfc7234
+ */
+class Cache internal constructor(
+  directory: File,
+  maxSize: Long,
+  fileSystem: FileSystem
+) : Closeable, Flushable {
+  internal val internalCache: InternalCache = object : InternalCache {
+    override fun get(request: Request): Response? {
+      return this@Cache.get(request)
+    }
+
+    override fun put(response: Response): CacheRequest? {
+      return this@Cache.put(response)
+    }
+
+    override fun remove(request: Request) {
+      this@Cache.remove(request)
+    }
+
+    override fun update(cached: Response, network: Response) {
+      this@Cache.update(cached, network)
+    }
+
+    override fun trackConditionalCacheHit() {
+      this@Cache.trackConditionalCacheHit()
+    }
+
+    override fun trackResponse(cacheStrategy: CacheStrategy) {
+      this@Cache.trackResponse(cacheStrategy)
+    }
+  }
+
+  internal val cache: DiskLruCache
+
+  // read and write statistics, all guarded by 'this'.
+  internal var writeSuccessCount: Int = 0
+  internal var writeAbortCount: Int = 0
+  private var networkCount: Int = 0
+  private var hitCount: Int = 0
+  private var requestCount: Int = 0
+
+  val isClosed: Boolean get() = cache.isClosed()
+
+  /** Create a cache of at most `maxSize` bytes in `directory`. */
+  constructor(directory: File, maxSize: Long) : this(directory, maxSize, FileSystem.SYSTEM)
+
+  init {
+    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize)
+  }
+
+  internal fun get(request: Request): Response? {
+    val key = key(request.url())
+    val snapshot: DiskLruCache.Snapshot = try {
+      cache.get(key) ?: return null
+    } catch (e: IOException) {
+      return null // Give up because the cache cannot be read.
+    }
+
+    val entry: Entry = try {
+      Entry(snapshot.getSource(ENTRY_METADATA))
+    } catch (e: IOException) {
+      closeQuietly(snapshot)
+      return null
+    }
+
+    val response = entry.response(snapshot)
+    if (!entry.matches(request, response)) {
+      closeQuietly(response.body())
+      return null
+    }
+
+    return response
+  }
+
+  internal fun put(response: Response): CacheRequest? {
+    val requestMethod = response.request().method()
+
+    if (HttpMethod.invalidatesCache(response.request().method())) {
+      try {
+        remove(response.request())
+      } catch (ignored: IOException) {
+        // The cache cannot be written.
+      }
+      return null
+    }
+
+    if (requestMethod != "GET") {
+      // Don't cache non-GET responses. We're technically allowed to cache HEAD requests and some
+      // POST requests, but the complexity of doing so is high and the benefit is low.
+      return null
+    }
+
+    if (HttpHeaders.hasVaryAll(response)) {
+      return null
+    }
+
+    val entry = Entry(response)
+    var editor: DiskLruCache.Editor? = null
+    try {
+      editor = cache.edit(key(response.request().url())) ?: return null
+      entry.writeTo(editor)
+      return RealCacheRequest(editor)
+    } catch (e: IOException) {
+      abortQuietly(editor)
+      return null
+    }
+  }
+
+  @Throws(IOException::class)
+  internal fun remove(request: Request) {
+    cache.remove(key(request.url()))
+  }
+
+  internal fun update(cached: Response, network: Response) {
+    val entry = Entry(network)
+    val snapshot = (cached.body() as CacheResponseBody).snapshot
+    var editor: DiskLruCache.Editor? = null
+    try {
+      editor = snapshot.edit() // Returns null if snapshot is not current.
+      if (editor != null) {
+        entry.writeTo(editor)
+        editor.commit()
+      }
+    } catch (e: IOException) {
+      abortQuietly(editor)
+    }
+  }
+
+  private fun abortQuietly(editor: DiskLruCache.Editor?) {
+    // Give up because the cache cannot be written.
+    try {
+      editor?.abort()
+    } catch (ignored: IOException) {
+    }
+  }
+
+  /**
+   * Initialize the cache. This will include reading the journal files from the storage and building
+   * up the necessary in-memory cache information.
+   *
+   * The initialization time may vary depending on the journal file size and the current actual
+   * cache size. The application needs to be aware of calling this function during the
+   * initialization phase and preferably in a background worker thread.
+   *
+   * Note that if the application chooses to not call this method to initialize the cache. By
+   * default, OkHttp will perform lazy initialization upon the first usage of the cache.
+   */
+  @Throws(IOException::class)
+  fun initialize() {
+    cache.initialize()
+  }
+
+  /**
+   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
+   * directory including files that weren't created by the cache.
+   */
+  @Throws(IOException::class)
+  fun delete() {
+    cache.delete()
+  }
+
+  /**
+   * Deletes all values stored in the cache. In-flight writes to the cache will complete normally,
+   * but the corresponding responses will not be stored.
+   */
+  @Throws(IOException::class)
+  fun evictAll() {
+    cache.evictAll()
+  }
+
+  /**
+   * Returns an iterator over the URLs in this cache. This iterator doesn't throw
+   * `ConcurrentModificationException`, but if new responses are added while iterating, their URLs
+   * will not be returned. If existing responses are evicted during iteration, they will be absent
+   * (unless they were already returned).
+   *
+   * The iterator supports [MutableIterator.remove]. Removing a URL from the iterator evicts the
+   * corresponding response from the cache. Use this to evict selected responses.
+   */
+  @Throws(IOException::class)
+  fun urls(): MutableIterator<String> {
+    return object : MutableIterator<String> {
+      val delegate: MutableIterator<DiskLruCache.Snapshot> = cache.snapshots()
+      var nextUrl: String? = null
+      var canRemove: Boolean = false
+
+      override fun hasNext(): Boolean {
+        if (nextUrl != null) return true
+
+        canRemove = false // Prevent delegate.remove() on the wrong item!
+        while (delegate.hasNext()) {
+          try {
+            delegate.next().use { snapshot ->
+              val metadata = snapshot.getSource(ENTRY_METADATA).buffer()
+              nextUrl = metadata.readUtf8LineStrict()
+              return true
+            }
+          } catch (ignored: IOException) {
+            // We couldn't read the metadata for this snapshot; possibly because the host filesystem
+            // has disappeared! Skip it.
+          }
+        }
+
+        return false
+      }
+
+      override fun next(): String {
+        if (!hasNext()) throw NoSuchElementException()
+        val result = nextUrl!!
+        nextUrl = null
+        canRemove = true
+        return result
+      }
+
+      override fun remove() {
+        if (!canRemove) throw IllegalStateException("remove() before next()")
+        delegate.remove()
+      }
+    }
+  }
+
+  @Synchronized fun writeAbortCount(): Int = writeAbortCount
+
+  @Synchronized fun writeSuccessCount(): Int = writeSuccessCount
+
+  @Throws(IOException::class)
+  fun size(): Long = cache.size()
+
+  /** Max size of the cache (in bytes).  */
+  fun maxSize(): Long = cache.maxSize
+
+  @Throws(IOException::class)
+  override fun flush() {
+    cache.flush()
+  }
+
+  @Throws(IOException::class)
+  override fun close() {
+    cache.close()
+  }
+
+  fun directory(): File = cache.directory
+
+  @Synchronized internal fun trackResponse(cacheStrategy: CacheStrategy) {
+    requestCount++
+
+    if (cacheStrategy.networkRequest != null) {
+      // If this is a conditional request, we'll increment hitCount if/when it hits.
+      networkCount++
+    } else if (cacheStrategy.cacheResponse != null) {
+      // This response uses the cache and not the network. That's a cache hit.
+      hitCount++
+    }
+  }
+
+  @Synchronized internal fun trackConditionalCacheHit() {
+    hitCount++
+  }
+
+  @Synchronized fun networkCount(): Int = networkCount
+
+  @Synchronized fun hitCount(): Int = hitCount
+
+  @Synchronized fun requestCount(): Int = requestCount
+
+  private inner class RealCacheRequest internal constructor(
+    private val editor: DiskLruCache.Editor
+  ) : CacheRequest {
+    private val cacheOut: Sink = editor.newSink(ENTRY_BODY)
+    private val body: Sink
+    internal var done: Boolean = false
+
+    init {
+      this.body = object : ForwardingSink(cacheOut) {
+        @Throws(IOException::class)
+        override fun close() {
+          synchronized(this@Cache) {
+            if (done) return
+            done = true
+            writeSuccessCount++
+          }
+          super.close()
+          editor.commit()
+        }
+      }
+    }
+
+    override fun abort() {
+      synchronized(this@Cache) {
+        if (done) return
+        done = true
+        writeAbortCount++
+      }
+      closeQuietly(cacheOut)
+      try {
+        editor.abort()
+      } catch (ignored: IOException) {
+      }
+    }
+
+    override fun body(): Sink = body
+  }
+
+  private class Entry {
+    private val url: String
+    private val varyHeaders: Headers
+    private val requestMethod: String
+    private val protocol: Protocol
+    private val code: Int
+    private val message: String
+    private val responseHeaders: Headers
+    private val handshake: Handshake?
+    private val sentRequestMillis: Long
+    private val receivedResponseMillis: Long
+
+    private val isHttps: Boolean get() = url.startsWith("https://")
+
+    /**
+     * Reads an entry from an input stream. A typical entry looks like this:
+     *
+     * ```
+     * http://google.com/foo
+     * GET
+     * 2
+     * Accept-Language: fr-CA
+     * Accept-Charset: UTF-8
+     * HTTP/1.1 200 OK
+     * 3
+     * Content-Type: image/png
+     * Content-Length: 100
+     * Cache-Control: max-age=600
+     * ```
+     *
+     * A typical HTTPS file looks like this:
+     *
+     * ```
+     * https://google.com/foo
+     * GET
+     * 2
+     * Accept-Language: fr-CA
+     * Accept-Charset: UTF-8
+     * HTTP/1.1 200 OK
+     * 3
+     * Content-Type: image/png
+     * Content-Length: 100
+     * Cache-Control: max-age=600
+     *
+     * AES_256_WITH_MD5
+     * 2
+     * base64-encoded peerCertificate[0]
+     * base64-encoded peerCertificate[1]
+     * -1
+     * TLSv1.2
+     * ```
+     *
+     * The file is newline separated. The first two lines are the URL and the request method. Next
+     * is the number of HTTP Vary request header lines, followed by those lines.
+     *
+     * Next is the response status line, followed by the number of HTTP response header lines,
+     * followed by those lines.
+     *
+     * HTTPS responses also contain SSL session information. This begins with a blank line, and then
+     * a line containing the cipher suite. Next is the length of the peer certificate chain. These
+     * certificates are base64-encoded and appear each on their own line. The next line contains the
+     * length of the local certificate chain. These certificates are also base64-encoded and appear
+     * each on their own line. A length of -1 is used to encode a null array. The last line is
+     * optional. If present, it contains the TLS version.
+     */
+    @Throws(IOException::class)
+    internal constructor(rawSource: Source) {
+      try {
+        val source = rawSource.buffer()
+        url = source.readUtf8LineStrict()
+        requestMethod = source.readUtf8LineStrict()
+        val varyHeadersBuilder = Headers.Builder()
+        val varyRequestHeaderLineCount = readInt(source)
+        for (i in 0 until varyRequestHeaderLineCount) {
+          addHeaderLenient(varyHeadersBuilder, source.readUtf8LineStrict())
+        }
+        varyHeaders = varyHeadersBuilder.build()
+
+        val statusLine = StatusLine.parse(source.readUtf8LineStrict())
+        protocol = statusLine.protocol
+        code = statusLine.code
+        message = statusLine.message
+        val responseHeadersBuilder = Headers.Builder()
+        val responseHeaderLineCount = readInt(source)
+        for (i in 0 until responseHeaderLineCount) {
+          addHeaderLenient(responseHeadersBuilder, source.readUtf8LineStrict())
+        }
+        val sendRequestMillisString = responseHeadersBuilder[SENT_MILLIS]
+        val receivedResponseMillisString = responseHeadersBuilder[RECEIVED_MILLIS]
+        responseHeadersBuilder.removeAll(SENT_MILLIS)
+        responseHeadersBuilder.removeAll(RECEIVED_MILLIS)
+        sentRequestMillis = sendRequestMillisString?.toLong() ?: 0L
+        receivedResponseMillis = receivedResponseMillisString?.toLong() ?: 0L
+        responseHeaders = responseHeadersBuilder.build()
+
+        if (isHttps) {
+          val blank = source.readUtf8LineStrict()
+          if (blank.isNotEmpty()) {
+            throw IOException("expected \"\" but was \"$blank\"")
+          }
+          val cipherSuiteString = source.readUtf8LineStrict()
+          val cipherSuite = CipherSuite.forJavaName(cipherSuiteString)
+          val peerCertificates = readCertificateList(source)
+          val localCertificates = readCertificateList(source)
+          val tlsVersion = if (!source.exhausted()) {
+            TlsVersion.forJavaName(source.readUtf8LineStrict())
+          } else {
+            TlsVersion.SSL_3_0
+          }
+          handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates)
+        } else {
+          handshake = null
+        }
+      } finally {
+        rawSource.close()
+      }
+    }
+
+    internal constructor(response: Response) {
+      this.url = response.request().url().toString()
+      this.varyHeaders = HttpHeaders.varyHeaders(response)
+      this.requestMethod = response.request().method()
+      this.protocol = response.protocol()
+      this.code = response.code()
+      this.message = response.message()
+      this.responseHeaders = response.headers()
+      this.handshake = response.handshake()
+      this.sentRequestMillis = response.sentRequestAtMillis()
+      this.receivedResponseMillis = response.receivedResponseAtMillis()
+    }
+
+    @Throws(IOException::class)
+    fun writeTo(editor: DiskLruCache.Editor) {
+      val sink = editor.newSink(ENTRY_METADATA).buffer()
+      sink.writeUtf8(url).writeByte('\n'.toInt())
+      sink.writeUtf8(requestMethod).writeByte('\n'.toInt())
+      sink.writeDecimalLong(varyHeaders.size().toLong()).writeByte('\n'.toInt())
+      for (i in 0 until varyHeaders.size()) {
+        sink.writeUtf8(varyHeaders.name(i))
+            .writeUtf8(": ")
+            .writeUtf8(varyHeaders.value(i))
+            .writeByte('\n'.toInt())
+      }
+
+      sink.writeUtf8(StatusLine(protocol, code, message).toString()).writeByte('\n'.toInt())
+      sink.writeDecimalLong((responseHeaders.size() + 2).toLong()).writeByte('\n'.toInt())
+      for (i in 0 until responseHeaders.size()) {
+        sink.writeUtf8(responseHeaders.name(i))
+            .writeUtf8(": ")
+            .writeUtf8(responseHeaders.value(i))
+            .writeByte('\n'.toInt())
+      }
+      sink.writeUtf8(SENT_MILLIS)
+          .writeUtf8(": ")
+          .writeDecimalLong(sentRequestMillis)
+          .writeByte('\n'.toInt())
+      sink.writeUtf8(RECEIVED_MILLIS)
+          .writeUtf8(": ")
+          .writeDecimalLong(receivedResponseMillis)
+          .writeByte('\n'.toInt())
+
+      if (isHttps) {
+        sink.writeByte('\n'.toInt())
+        sink.writeUtf8(handshake!!.cipherSuite().javaName()).writeByte('\n'.toInt())
+        writeCertList(sink, handshake.peerCertificates())
+        writeCertList(sink, handshake.localCertificates())
+        sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte('\n'.toInt())
+      }
+      sink.close()
+    }
+
+    @Throws(IOException::class)
+    private fun readCertificateList(source: BufferedSource): List<Certificate> {
+      val length = readInt(source)
+      if (length == -1) return emptyList() // OkHttp v1.2 used -1 to indicate null.
+
+      try {
+        val certificateFactory = CertificateFactory.getInstance("X.509")
+        val result = ArrayList<Certificate>(length)
+        for (i in 0 until length) {
+          val line = source.readUtf8LineStrict()
+          val bytes = Buffer()
+          bytes.write(line.decodeBase64()!!)
+          result.add(certificateFactory.generateCertificate(bytes.inputStream()))
+        }
+        return result
+      } catch (e: CertificateException) {
+        throw IOException(e.message)
+      }
+    }
+
+    @Throws(IOException::class)
+    private fun writeCertList(sink: BufferedSink, certificates: List<Certificate>) {
+      try {
+        sink.writeDecimalLong(certificates.size.toLong()).writeByte('\n'.toInt())
+        for (i in 0 until certificates.size) {
+          val bytes = certificates[i].encoded
+          val line = ByteString.of(*bytes).base64()
+          sink.writeUtf8(line).writeByte('\n'.toInt())
+        }
+      } catch (e: CertificateEncodingException) {
+        throw IOException(e.message)
+      }
+    }
+
+    fun matches(request: Request, response: Response): Boolean {
+      return url == request.url().toString() &&
+          requestMethod == request.method() &&
+          HttpHeaders.varyMatches(response, varyHeaders, request)
+    }
+
+    fun response(snapshot: DiskLruCache.Snapshot): Response {
+      val contentType = responseHeaders["Content-Type"]
+      val contentLength = responseHeaders["Content-Length"]
+      val cacheRequest = Request.Builder()
+          .url(url)
+          .method(requestMethod, null)
+          .headers(varyHeaders)
+          .build()
+      return Response.Builder()
+          .request(cacheRequest)
+          .protocol(protocol)
+          .code(code)
+          .message(message)
+          .headers(responseHeaders)
+          .body(CacheResponseBody(snapshot, contentType, contentLength))
+          .handshake(handshake)
+          .sentRequestAtMillis(sentRequestMillis)
+          .receivedResponseAtMillis(receivedResponseMillis)
+          .build()
+    }
+
+    companion object {
+      /** Synthetic response header: the local time when the request was sent.  */
+      private val SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis"
+
+      /** Synthetic response header: the local time when the response was received.  */
+      private val RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis"
+    }
+  }
+
+  private class CacheResponseBody internal constructor(
+    internal val snapshot: DiskLruCache.Snapshot,
+    private val contentType: String?,
+    private val contentLength: String?
+  ) : ResponseBody() {
+    private val bodySource: BufferedSource
+
+    init {
+      val source = snapshot.getSource(ENTRY_BODY)
+      bodySource = object : ForwardingSource(source) {
+        @Throws(IOException::class)
+        override fun close() {
+          snapshot.close()
+          super.close()
+        }
+      }.buffer()
+    }
+
+    override fun contentType(): MediaType? {
+      return if (contentType != null) MediaType.parse(contentType) else null
+    }
+
+    override fun contentLength(): Long {
+      return try {
+        contentLength?.toLong() ?: -1
+      } catch (e: NumberFormatException) {
+        -1L
+      }
+    }
+
+    override fun source(): BufferedSource = bodySource
+  }
+
+  companion object {
+    private const val VERSION = 201105
+    private const val ENTRY_METADATA = 0
+    private const val ENTRY_BODY = 1
+    private const val ENTRY_COUNT = 2
+
+    @JvmStatic
+    fun key(url: HttpUrl): String = url.toString().encodeUtf8().md5().hex()
+
+    @Throws(IOException::class)
+    @JvmStatic
+    internal fun readInt(source: BufferedSource): Int {
+      try {
+        val result = source.readDecimalLong()
+        val line = source.readUtf8LineStrict()
+        if (result < 0 || result > Integer.MAX_VALUE || line.isNotEmpty()) {
+          throw IOException("expected an int but was \"$result$line\"")
+        }
+        return result.toInt()
+      } catch (e: NumberFormatException) {
+        throw IOException(e.message)
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/CacheControl.java b/okhttp/src/main/java/okhttp3/CacheControl.java
deleted file mode 100644
index a32add5f97..0000000000
--- a/okhttp/src/main/java/okhttp3/CacheControl.java
+++ /dev/null
@@ -1,373 +0,0 @@
-package okhttp3;
-
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.internal.http.HttpHeaders;
-
-/**
- * A Cache-Control header with cache directives from a server or client. These directives set policy
- * on what responses can be stored, and which requests can be satisfied by those stored responses.
- *
- * <p>See <a href="https://tools.ietf.org/html/rfc7234#section-5.2">RFC 7234, 5.2</a>.
- */
-public final class CacheControl {
-  /**
-   * Cache control request directives that require network validation of responses. Note that such
-   * requests may be assisted by the cache via conditional GET requests.
-   */
-  public static final CacheControl FORCE_NETWORK = new Builder().noCache().build();
-
-  /**
-   * Cache control request directives that uses the cache only, even if the cached response is
-   * stale. If the response isn't available in the cache or requires server validation, the call
-   * will fail with a {@code 504 Unsatisfiable Request}.
-   */
-  public static final CacheControl FORCE_CACHE = new Builder()
-      .onlyIfCached()
-      .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)
-      .build();
-
-  private final boolean noCache;
-  private final boolean noStore;
-  private final int maxAgeSeconds;
-  private final int sMaxAgeSeconds;
-  private final boolean isPrivate;
-  private final boolean isPublic;
-  private final boolean mustRevalidate;
-  private final int maxStaleSeconds;
-  private final int minFreshSeconds;
-  private final boolean onlyIfCached;
-  private final boolean noTransform;
-  private final boolean immutable;
-
-  @Nullable String headerValue; // Lazily computed, null if absent.
-
-  private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
-      boolean isPrivate, boolean isPublic, boolean mustRevalidate, int maxStaleSeconds,
-      int minFreshSeconds, boolean onlyIfCached, boolean noTransform, boolean immutable,
-      @Nullable String headerValue) {
-    this.noCache = noCache;
-    this.noStore = noStore;
-    this.maxAgeSeconds = maxAgeSeconds;
-    this.sMaxAgeSeconds = sMaxAgeSeconds;
-    this.isPrivate = isPrivate;
-    this.isPublic = isPublic;
-    this.mustRevalidate = mustRevalidate;
-    this.maxStaleSeconds = maxStaleSeconds;
-    this.minFreshSeconds = minFreshSeconds;
-    this.onlyIfCached = onlyIfCached;
-    this.noTransform = noTransform;
-    this.immutable = immutable;
-    this.headerValue = headerValue;
-  }
-
-  CacheControl(Builder builder) {
-    this.noCache = builder.noCache;
-    this.noStore = builder.noStore;
-    this.maxAgeSeconds = builder.maxAgeSeconds;
-    this.sMaxAgeSeconds = -1;
-    this.isPrivate = false;
-    this.isPublic = false;
-    this.mustRevalidate = false;
-    this.maxStaleSeconds = builder.maxStaleSeconds;
-    this.minFreshSeconds = builder.minFreshSeconds;
-    this.onlyIfCached = builder.onlyIfCached;
-    this.noTransform = builder.noTransform;
-    this.immutable = builder.immutable;
-  }
-
-  /**
-   * In a response, this field's name "no-cache" is misleading. It doesn't prevent us from caching
-   * the response; it only means we have to validate the response with the origin server before
-   * returning it. We can do this with a conditional GET.
-   *
-   * <p>In a request, it means do not use a cache to satisfy the request.
-   */
-  public boolean noCache() {
-    return noCache;
-  }
-
-  /** If true, this response should not be cached. */
-  public boolean noStore() {
-    return noStore;
-  }
-
-  /**
-   * The duration past the response's served date that it can be served without validation.
-   */
-  public int maxAgeSeconds() {
-    return maxAgeSeconds;
-  }
-
-  /**
-   * The "s-maxage" directive is the max age for shared caches. Not to be confused with "max-age"
-   * for non-shared caches, As in Firefox and Chrome, this directive is not honored by this cache.
-   */
-  public int sMaxAgeSeconds() {
-    return sMaxAgeSeconds;
-  }
-
-  public boolean isPrivate() {
-    return isPrivate;
-  }
-
-  public boolean isPublic() {
-    return isPublic;
-  }
-
-  public boolean mustRevalidate() {
-    return mustRevalidate;
-  }
-
-  public int maxStaleSeconds() {
-    return maxStaleSeconds;
-  }
-
-  public int minFreshSeconds() {
-    return minFreshSeconds;
-  }
-
-  /**
-   * This field's name "only-if-cached" is misleading. It actually means "do not use the network".
-   * It is set by a client who only wants to make a request if it can be fully satisfied by the
-   * cache. Cached responses that would require validation (ie. conditional gets) are not permitted
-   * if this header is set.
-   */
-  public boolean onlyIfCached() {
-    return onlyIfCached;
-  }
-
-  public boolean noTransform() {
-    return noTransform;
-  }
-
-  public boolean immutable() {
-    return immutable;
-  }
-
-  /**
-   * Returns the cache directives of {@code headers}. This honors both Cache-Control and Pragma
-   * headers if they are present.
-   */
-  public static CacheControl parse(Headers headers) {
-    boolean noCache = false;
-    boolean noStore = false;
-    int maxAgeSeconds = -1;
-    int sMaxAgeSeconds = -1;
-    boolean isPrivate = false;
-    boolean isPublic = false;
-    boolean mustRevalidate = false;
-    int maxStaleSeconds = -1;
-    int minFreshSeconds = -1;
-    boolean onlyIfCached = false;
-    boolean noTransform = false;
-    boolean immutable = false;
-
-    boolean canUseHeaderValue = true;
-    String headerValue = null;
-
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      String name = headers.name(i);
-      String value = headers.value(i);
-
-      if (name.equalsIgnoreCase("Cache-Control")) {
-        if (headerValue != null) {
-          // Multiple cache-control headers means we can't use the raw value.
-          canUseHeaderValue = false;
-        } else {
-          headerValue = value;
-        }
-      } else if (name.equalsIgnoreCase("Pragma")) {
-        // Might specify additional cache-control params. We invalidate just in case.
-        canUseHeaderValue = false;
-      } else {
-        continue;
-      }
-
-      int pos = 0;
-      while (pos < value.length()) {
-        int tokenStart = pos;
-        pos = HttpHeaders.skipUntil(value, pos, "=,;");
-        String directive = value.substring(tokenStart, pos).trim();
-        String parameter;
-
-        if (pos == value.length() || value.charAt(pos) == ',' || value.charAt(pos) == ';') {
-          pos++; // consume ',' or ';' (if necessary)
-          parameter = null;
-        } else {
-          pos++; // consume '='
-          pos = HttpHeaders.skipWhitespace(value, pos);
-
-          // quoted string
-          if (pos < value.length() && value.charAt(pos) == '\"') {
-            pos++; // consume '"' open quote
-            int parameterStart = pos;
-            pos = HttpHeaders.skipUntil(value, pos, "\"");
-            parameter = value.substring(parameterStart, pos);
-            pos++; // consume '"' close quote (if necessary)
-
-            // unquoted string
-          } else {
-            int parameterStart = pos;
-            pos = HttpHeaders.skipUntil(value, pos, ",;");
-            parameter = value.substring(parameterStart, pos).trim();
-          }
-        }
-
-        if ("no-cache".equalsIgnoreCase(directive)) {
-          noCache = true;
-        } else if ("no-store".equalsIgnoreCase(directive)) {
-          noStore = true;
-        } else if ("max-age".equalsIgnoreCase(directive)) {
-          maxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1);
-        } else if ("s-maxage".equalsIgnoreCase(directive)) {
-          sMaxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1);
-        } else if ("private".equalsIgnoreCase(directive)) {
-          isPrivate = true;
-        } else if ("public".equalsIgnoreCase(directive)) {
-          isPublic = true;
-        } else if ("must-revalidate".equalsIgnoreCase(directive)) {
-          mustRevalidate = true;
-        } else if ("max-stale".equalsIgnoreCase(directive)) {
-          maxStaleSeconds = HttpHeaders.parseSeconds(parameter, Integer.MAX_VALUE);
-        } else if ("min-fresh".equalsIgnoreCase(directive)) {
-          minFreshSeconds = HttpHeaders.parseSeconds(parameter, -1);
-        } else if ("only-if-cached".equalsIgnoreCase(directive)) {
-          onlyIfCached = true;
-        } else if ("no-transform".equalsIgnoreCase(directive)) {
-          noTransform = true;
-        } else if ("immutable".equalsIgnoreCase(directive)) {
-          immutable = true;
-        }
-      }
-    }
-
-    if (!canUseHeaderValue) {
-      headerValue = null;
-    }
-    return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic,
-        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, immutable,
-        headerValue);
-  }
-
-  @Override public String toString() {
-    String result = headerValue;
-    return result != null ? result : (headerValue = headerValue());
-  }
-
-  private String headerValue() {
-    StringBuilder result = new StringBuilder();
-    if (noCache) result.append("no-cache, ");
-    if (noStore) result.append("no-store, ");
-    if (maxAgeSeconds != -1) result.append("max-age=").append(maxAgeSeconds).append(", ");
-    if (sMaxAgeSeconds != -1) result.append("s-maxage=").append(sMaxAgeSeconds).append(", ");
-    if (isPrivate) result.append("private, ");
-    if (isPublic) result.append("public, ");
-    if (mustRevalidate) result.append("must-revalidate, ");
-    if (maxStaleSeconds != -1) result.append("max-stale=").append(maxStaleSeconds).append(", ");
-    if (minFreshSeconds != -1) result.append("min-fresh=").append(minFreshSeconds).append(", ");
-    if (onlyIfCached) result.append("only-if-cached, ");
-    if (noTransform) result.append("no-transform, ");
-    if (immutable) result.append("immutable, ");
-    if (result.length() == 0) return "";
-    result.delete(result.length() - 2, result.length());
-    return result.toString();
-  }
-
-  /** Builds a {@code Cache-Control} request header. */
-  public static final class Builder {
-    boolean noCache;
-    boolean noStore;
-    int maxAgeSeconds = -1;
-    int maxStaleSeconds = -1;
-    int minFreshSeconds = -1;
-    boolean onlyIfCached;
-    boolean noTransform;
-    boolean immutable;
-
-    /** Don't accept an unvalidated cached response. */
-    public Builder noCache() {
-      this.noCache = true;
-      return this;
-    }
-
-    /** Don't store the server's response in any cache. */
-    public Builder noStore() {
-      this.noStore = true;
-      return this;
-    }
-
-    /**
-     * Sets the maximum age of a cached response. If the cache response's age exceeds {@code
-     * maxAge}, it will not be used and a network request will be made.
-     *
-     * @param maxAge a non-negative integer. This is stored and transmitted with {@link
-     * TimeUnit#SECONDS} precision; finer precision will be lost.
-     */
-    public Builder maxAge(int maxAge, TimeUnit timeUnit) {
-      if (maxAge < 0) throw new IllegalArgumentException("maxAge < 0: " + maxAge);
-      long maxAgeSecondsLong = timeUnit.toSeconds(maxAge);
-      this.maxAgeSeconds = maxAgeSecondsLong > Integer.MAX_VALUE
-          ? Integer.MAX_VALUE
-          : (int) maxAgeSecondsLong;
-      return this;
-    }
-
-    /**
-     * Accept cached responses that have exceeded their freshness lifetime by up to {@code
-     * maxStale}. If unspecified, stale cache responses will not be used.
-     *
-     * @param maxStale a non-negative integer. This is stored and transmitted with {@link
-     * TimeUnit#SECONDS} precision; finer precision will be lost.
-     */
-    public Builder maxStale(int maxStale, TimeUnit timeUnit) {
-      if (maxStale < 0) throw new IllegalArgumentException("maxStale < 0: " + maxStale);
-      long maxStaleSecondsLong = timeUnit.toSeconds(maxStale);
-      this.maxStaleSeconds = maxStaleSecondsLong > Integer.MAX_VALUE
-          ? Integer.MAX_VALUE
-          : (int) maxStaleSecondsLong;
-      return this;
-    }
-
-    /**
-     * Sets the minimum number of seconds that a response will continue to be fresh for. If the
-     * response will be stale when {@code minFresh} have elapsed, the cached response will not be
-     * used and a network request will be made.
-     *
-     * @param minFresh a non-negative integer. This is stored and transmitted with {@link
-     * TimeUnit#SECONDS} precision; finer precision will be lost.
-     */
-    public Builder minFresh(int minFresh, TimeUnit timeUnit) {
-      if (minFresh < 0) throw new IllegalArgumentException("minFresh < 0: " + minFresh);
-      long minFreshSecondsLong = timeUnit.toSeconds(minFresh);
-      this.minFreshSeconds = minFreshSecondsLong > Integer.MAX_VALUE
-          ? Integer.MAX_VALUE
-          : (int) minFreshSecondsLong;
-      return this;
-    }
-
-    /**
-     * Only accept the response if it is in the cache. If the response isn't cached, a {@code 504
-     * Unsatisfiable Request} response will be returned.
-     */
-    public Builder onlyIfCached() {
-      this.onlyIfCached = true;
-      return this;
-    }
-
-    /** Don't accept a transformed response. */
-    public Builder noTransform() {
-      this.noTransform = true;
-      return this;
-    }
-
-    public Builder immutable() {
-      this.immutable = true;
-      return this;
-    }
-
-    public CacheControl build() {
-      return new CacheControl(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/CacheControl.kt b/okhttp/src/main/java/okhttp3/CacheControl.kt
new file mode 100644
index 0000000000..cb13511a98
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CacheControl.kt
@@ -0,0 +1,340 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.http.HttpHeaders
+import java.util.concurrent.TimeUnit
+
+/**
+ * A Cache-Control header with cache directives from a server or client. These directives set policy
+ * on what responses can be stored, and which requests can be satisfied by those stored responses.
+ *
+ * See [RFC 7234, 5.2](https://tools.ietf.org/html/rfc7234#section-5.2).
+ */
+class CacheControl private constructor(
+  private val noCache: Boolean,
+  private val noStore: Boolean,
+  private val maxAgeSeconds: Int,
+  private val sMaxAgeSeconds: Int,
+  val isPrivate: Boolean,
+  val isPublic: Boolean,
+  private val mustRevalidate: Boolean,
+  private val maxStaleSeconds: Int,
+  private val minFreshSeconds: Int,
+  private val onlyIfCached: Boolean,
+  private val noTransform: Boolean,
+  private val immutable: Boolean,
+  private var headerValue: String?
+) {
+  /**
+   * In a response, this field's name "no-cache" is misleading. It doesn't prevent us from caching
+   * the response; it only means we have to validate the response with the origin server before
+   * returning it. We can do this with a conditional GET.
+   *
+   * In a request, it means do not use a cache to satisfy the request.
+   */
+  fun noCache() = noCache
+
+  /** If true, this response should not be cached.  */
+  fun noStore() = noStore
+
+  /** The duration past the response's served date that it can be served without validation. */
+  fun maxAgeSeconds() = maxAgeSeconds
+
+  /**
+   * The "s-maxage" directive is the max age for shared caches. Not to be confused with "max-age"
+   * for non-shared caches, As in Firefox and Chrome, this directive is not honored by this cache.
+   */
+  fun sMaxAgeSeconds() = sMaxAgeSeconds
+
+  fun mustRevalidate() = mustRevalidate
+
+  fun maxStaleSeconds() = maxStaleSeconds
+
+  fun minFreshSeconds() = minFreshSeconds
+
+  /**
+   * This field's name "only-if-cached" is misleading. It actually means "do not use the network".
+   * It is set by a client who only wants to make a request if it can be fully satisfied by the
+   * cache. Cached responses that would require validation (ie. conditional gets) are not permitted
+   * if this header is set.
+   */
+  fun onlyIfCached() = onlyIfCached
+
+  fun noTransform() = noTransform
+
+  fun immutable() = immutable
+
+  override fun toString(): String {
+    var result = headerValue
+    if (result == null) {
+      result = buildString {
+        if (noCache) append("no-cache, ")
+        if (noStore) append("no-store, ")
+        if (maxAgeSeconds != -1) append("max-age=").append(maxAgeSeconds).append(", ")
+        if (sMaxAgeSeconds != -1) append("s-maxage=").append(sMaxAgeSeconds).append(", ")
+        if (isPrivate) append("private, ")
+        if (isPublic) append("public, ")
+        if (mustRevalidate) append("must-revalidate, ")
+        if (maxStaleSeconds != -1) append("max-stale=").append(maxStaleSeconds).append(", ")
+        if (minFreshSeconds != -1) append("min-fresh=").append(minFreshSeconds).append(", ")
+        if (onlyIfCached) append("only-if-cached, ")
+        if (noTransform) append("no-transform, ")
+        if (immutable) append("immutable, ")
+        if (isEmpty()) return ""
+        delete(length - 2, length)
+      }
+      headerValue = result
+    }
+    return result
+  }
+
+  /** Builds a `Cache-Control` request header.  */
+  class Builder {
+    private var noCache: Boolean = false
+    private var noStore: Boolean = false
+    private var maxAgeSeconds = -1
+    private var maxStaleSeconds = -1
+    private var minFreshSeconds = -1
+    private var onlyIfCached: Boolean = false
+    private var noTransform: Boolean = false
+    private var immutable: Boolean = false
+
+    /** Don't accept an unvalidated cached response.  */
+    fun noCache() = apply {
+      this.noCache = true
+    }
+
+    /** Don't store the server's response in any cache.  */
+    fun noStore() = apply {
+      this.noStore = true
+    }
+
+    /**
+     * Sets the maximum age of a cached response. If the cache response's age exceeds `maxAge`, it
+     * will not be used and a network request will be made.
+     *
+     * @param maxAge a non-negative integer. This is stored and transmitted with [TimeUnit.SECONDS]
+     *     precision; finer precision will be lost.
+     */
+    fun maxAge(maxAge: Int, timeUnit: TimeUnit) = apply {
+      if (maxAge < 0) throw IllegalArgumentException("maxAge < 0: $maxAge")
+      val maxAgeSecondsLong = timeUnit.toSeconds(maxAge.toLong())
+      this.maxAgeSeconds = maxAgeSecondsLong.clampToInt()
+    }
+
+    /**
+     * Accept cached responses that have exceeded their freshness lifetime by up to `maxStale`. If
+     * unspecified, stale cache responses will not be used.
+     *
+     * @param maxStale a non-negative integer. This is stored and transmitted with
+     *     [TimeUnit.SECONDS] precision; finer precision will be lost.
+     */
+    fun maxStale(maxStale: Int, timeUnit: TimeUnit) = apply {
+      if (maxStale < 0) throw IllegalArgumentException("maxStale < 0: $maxStale")
+      val maxStaleSecondsLong = timeUnit.toSeconds(maxStale.toLong())
+      this.maxStaleSeconds = maxStaleSecondsLong.clampToInt()
+    }
+
+    /**
+     * Sets the minimum number of seconds that a response will continue to be fresh for. If the
+     * response will be stale when `minFresh` have elapsed, the cached response will not be used and
+     * a network request will be made.
+     *
+     * @param minFresh a non-negative integer. This is stored and transmitted with
+     *     [TimeUnit.SECONDS] precision; finer precision will be lost.
+     */
+    fun minFresh(minFresh: Int, timeUnit: TimeUnit) = apply {
+      if (minFresh < 0) throw IllegalArgumentException("minFresh < 0: $minFresh")
+      val minFreshSecondsLong = timeUnit.toSeconds(minFresh.toLong())
+      this.minFreshSeconds = minFreshSecondsLong.clampToInt()
+    }
+
+    /**
+     * Only accept the response if it is in the cache. If the response isn't cached, a `504
+     * Unsatisfiable Request` response will be returned.
+     */
+    fun onlyIfCached() = apply {
+      this.onlyIfCached = true
+    }
+
+    /** Don't accept a transformed response.  */
+    fun noTransform() = apply {
+      this.noTransform = true
+    }
+
+    fun immutable() = apply {
+      this.immutable = true
+    }
+
+    private fun Long.clampToInt(): Int {
+      return when {
+        this > Integer.MAX_VALUE -> Integer.MAX_VALUE
+        else -> toInt()
+      }
+    }
+
+    fun build(): CacheControl {
+      return CacheControl(noCache, noStore, maxAgeSeconds, -1, false, false, false, maxStaleSeconds,
+          minFreshSeconds, onlyIfCached, noTransform, immutable, null)
+    }
+  }
+
+  companion object {
+    /**
+     * Cache control request directives that require network validation of responses. Note that such
+     * requests may be assisted by the cache via conditional GET requests.
+     */
+    @JvmField
+    val FORCE_NETWORK = Builder()
+        .noCache()
+        .build()
+
+    /**
+     * Cache control request directives that uses the cache only, even if the cached response is
+     * stale. If the response isn't available in the cache or requires server validation, the call
+     * will fail with a `504 Unsatisfiable Request`.
+     */
+    @JvmField
+    val FORCE_CACHE = Builder()
+        .onlyIfCached()
+        .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)
+        .build()
+
+    /**
+     * Returns the cache directives of `headers`. This honors both Cache-Control and Pragma headers
+     * if they are present.
+     */
+    @JvmStatic
+    fun parse(headers: Headers): CacheControl {
+      var noCache = false
+      var noStore = false
+      var maxAgeSeconds = -1
+      var sMaxAgeSeconds = -1
+      var isPrivate = false
+      var isPublic = false
+      var mustRevalidate = false
+      var maxStaleSeconds = -1
+      var minFreshSeconds = -1
+      var onlyIfCached = false
+      var noTransform = false
+      var immutable = false
+
+      var canUseHeaderValue = true
+      var headerValue: String? = null
+
+      loop@ for (i in 0 until headers.size()) {
+        val name = headers.name(i)
+        val value = headers.value(i)
+
+        when {
+          name.equals("Cache-Control", ignoreCase = true) -> {
+            if (headerValue != null) {
+              // Multiple cache-control headers means we can't use the raw value.
+              canUseHeaderValue = false
+            } else {
+              headerValue = value
+            }
+          }
+          name.equals("Pragma", ignoreCase = true) -> {
+            // Might specify additional cache-control params. We invalidate just in case.
+            canUseHeaderValue = false
+          }
+          else -> {
+            continue@loop
+          }
+        }
+
+        var pos = 0
+        while (pos < value.length) {
+          val tokenStart = pos
+          pos = HttpHeaders.skipUntil(value, pos, "=,;")
+          val directive = value.substring(tokenStart, pos).trim { it <= ' ' }
+          val parameter: String?
+
+          if (pos == value.length || value[pos] == ',' || value[pos] == ';') {
+            pos++ // Consume ',' or ';' (if necessary).
+            parameter = null
+          } else {
+            pos++ // Consume '='.
+            pos = HttpHeaders.skipWhitespace(value, pos)
+
+            if (pos < value.length && value[pos] == '\"') {
+              // Quoted string.
+              pos++ // Consume '"' open quote.
+              val parameterStart = pos
+              pos = HttpHeaders.skipUntil(value, pos, "\"")
+              parameter = value.substring(parameterStart, pos)
+              pos++ // Consume '"' close quote (if necessary).
+            } else {
+              // Unquoted string.
+              val parameterStart = pos
+              pos = HttpHeaders.skipUntil(value, pos, ",;")
+              parameter = value.substring(parameterStart, pos).trim { it <= ' ' }
+            }
+          }
+
+          when {
+            "no-cache".equals(directive, ignoreCase = true) -> {
+              noCache = true
+            }
+            "no-store".equals(directive, ignoreCase = true) -> {
+              noStore = true
+            }
+            "max-age".equals(directive, ignoreCase = true) -> {
+              maxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1)
+            }
+            "s-maxage".equals(directive, ignoreCase = true) -> {
+              sMaxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1)
+            }
+            "private".equals(directive, ignoreCase = true) -> {
+              isPrivate = true
+            }
+            "public".equals(directive, ignoreCase = true) -> {
+              isPublic = true
+            }
+            "must-revalidate".equals(directive, ignoreCase = true) -> {
+              mustRevalidate = true
+            }
+            "max-stale".equals(directive, ignoreCase = true) -> {
+              maxStaleSeconds = HttpHeaders.parseSeconds(parameter, Integer.MAX_VALUE)
+            }
+            "min-fresh".equals(directive, ignoreCase = true) -> {
+              minFreshSeconds = HttpHeaders.parseSeconds(parameter, -1)
+            }
+            "only-if-cached".equals(directive, ignoreCase = true) -> {
+              onlyIfCached = true
+            }
+            "no-transform".equals(directive, ignoreCase = true) -> {
+              noTransform = true
+            }
+            "immutable".equals(directive, ignoreCase = true) -> {
+              immutable = true
+            }
+          }
+        }
+      }
+
+      if (!canUseHeaderValue) {
+        headerValue = null
+      }
+
+      return CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic,
+          mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, immutable,
+          headerValue)
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
deleted file mode 100644
index 67d0f88d3d..0000000000
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import okio.Timeout;
-
-/**
- * A call is a request that has been prepared for execution. A call can be canceled. As this object
- * represents a single request/response pair (stream), it cannot be executed twice.
- */
-public interface Call extends Cloneable {
-  /** Returns the original request that initiated this call. */
-  Request request();
-
-  /**
-   * Invokes the request immediately, and blocks until the response can be processed or is in
-   * error.
-   *
-   * <p>To avoid leaking resources callers should close the {@link Response} which in turn will
-   * close the underlying {@link ResponseBody}.
-   *
-   * <pre>{@code
-   *
-   *   // ensure the response (and underlying response body) is closed
-   *   try (Response response = client.newCall(request).execute()) {
-   *     ...
-   *   }
-   *
-   * }</pre>
-   *
-   * <p>The caller may read the response body with the response's {@link Response#body} method. To
-   * avoid leaking resources callers must {@linkplain ResponseBody close the response body} or the
-   * Response.
-   *
-   * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
-   * not necessarily indicate application-layer success: {@code response} may still indicate an
-   * unhappy HTTP response code like 404 or 500.
-   *
-   * @throws IOException if the request could not be executed due to cancellation, a connectivity
-   * problem or timeout. Because networks can fail during an exchange, it is possible that the
-   * remote server accepted the request before the failure.
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  Response execute() throws IOException;
-
-  /**
-   * Schedules the request to be executed at some point in the future.
-   *
-   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
-   * immediately unless there are several other requests currently being executed.
-   *
-   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
-   * failure exception.
-   *
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  void enqueue(Callback responseCallback);
-
-  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
-  void cancel();
-
-  /**
-   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
-   * #enqueue(Callback) enqueued}. It is an error to execute a call more than once.
-   */
-  boolean isExecuted();
-
-  boolean isCanceled();
-
-  /**
-   * Returns a timeout that spans the entire call: resolving DNS, connecting, writing the request
-   * body, server processing, and reading the response body. If the call requires redirects or
-   * retries all must complete within one timeout period.
-   *
-   * <p>Configure the client's default timeout with {@link OkHttpClient.Builder#callTimeout}.
-   */
-  Timeout timeout();
-
-  /**
-   * Create a new, identical call to this one which can be enqueued or executed even if this call
-   * has already been.
-   */
-  Call clone();
-
-  interface Factory {
-    Call newCall(Request request);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Call.kt b/okhttp/src/main/java/okhttp3/Call.kt
new file mode 100644
index 0000000000..cc36ccef9b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Call.kt
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okio.Timeout
+import java.io.IOException
+
+/**
+ * A call is a request that has been prepared for execution. A call can be canceled. As this object
+ * represents a single request/response pair (stream), it cannot be executed twice.
+ */
+interface Call : Cloneable {
+  /** Returns the original request that initiated this call.  */
+  fun request(): Request
+
+  /**
+   * Invokes the request immediately, and blocks until the response can be processed or is in error.
+   *
+   * To avoid leaking resources callers should close the [Response] which in turn will close the
+   * underlying [ResponseBody].
+   *
+   * ```
+   * // ensure the response (and underlying response body) is closed
+   * try (Response response = client.newCall(request).execute()) {
+   *   ...
+   * }
+   * ```
+   *
+   * The caller may read the response body with the response's [Response.body] method. To avoid
+   * leaking resources callers must [close the response body][ResponseBody] or the response.
+   *
+   * Note that transport-layer success (receiving a HTTP response code, headers and body) does not
+   * necessarily indicate application-layer success: `response` may still indicate an unhappy HTTP
+   * response code like 404 or 500.
+   *
+   * @throws IOException if the request could not be executed due to cancellation, a connectivity
+   *     problem or timeout. Because networks can fail during an exchange, it is possible that the
+   *     remote server accepted the request before the failure.
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  @Throws(IOException::class)
+  fun execute(): Response
+
+  /**
+   * Schedules the request to be executed at some point in the future.
+   *
+   * The [dispatcher][OkHttpClient.dispatcher] defines when the request will run: usually
+   * immediately unless there are several other requests currently being executed.
+   *
+   * This client will later call back `responseCallback` with either an HTTP response or a failure
+   * exception.
+   *
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  fun enqueue(responseCallback: Callback)
+
+  /** Cancels the request, if possible. Requests that are already complete cannot be canceled.  */
+  fun cancel()
+
+  /**
+   * Returns true if this call has been either [executed][execute] or [enqueued][enqueue]. It is an
+   * error to execute a call more than once.
+   */
+  fun isExecuted(): Boolean
+
+  fun isCanceled(): Boolean
+
+  /**
+   * Returns a timeout that spans the entire call: resolving DNS, connecting, writing the request
+   * body, server processing, and reading the response body. If the call requires redirects or
+   * retries all must complete within one timeout period.
+   *
+   * Configure the client's default timeout with [OkHttpClient.Builder.callTimeout].
+   */
+  fun timeout(): Timeout
+
+  /**
+   * Create a new, identical call to this one which can be enqueued or executed even if this call
+   * has already been.
+   */
+  override fun clone(): Call
+
+  interface Factory {
+    fun newCall(request: Request): Call
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Callback.java b/okhttp/src/main/java/okhttp3/Callback.kt
similarity index 59%
rename from okhttp/src/main/java/okhttp3/Callback.java
rename to okhttp/src/main/java/okhttp3/Callback.kt
index 3b7ed85bf4..84a0702935 100644
--- a/okhttp/src/main/java/okhttp3/Callback.java
+++ b/okhttp/src/main/java/okhttp3/Callback.kt
@@ -13,27 +13,28 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3;
+package okhttp3
 
-import java.io.IOException;
+import java.io.IOException
 
-public interface Callback {
+interface Callback {
   /**
    * Called when the request could not be executed due to cancellation, a connectivity problem or
    * timeout. Because networks can fail during an exchange, it is possible that the remote server
    * accepted the request before the failure.
    */
-  void onFailure(Call call, IOException e);
+  fun onFailure(call: Call, e: IOException)
 
   /**
    * Called when the HTTP response was successfully returned by the remote server. The callback may
-   * proceed to read the response body with {@link Response#body}. The response is still live until
-   * its response body is {@linkplain ResponseBody closed}. The recipient of the callback may
-   * consume the response body on another thread.
+   * proceed to read the response body with [Response.body]. The response is still live until its
+   * response body is [closed][ResponseBody]. The recipient of the callback may consume the response
+   * body on another thread.
    *
-   * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
-   * not necessarily indicate application-layer success: {@code response} may still indicate an
-   * unhappy HTTP response code like 404 or 500.
+   * Note that transport-layer success (receiving a HTTP response code, headers and body) does not
+   * necessarily indicate application-layer success: `response` may still indicate an unhappy HTTP
+   * response code like 404 or 500.
    */
-  void onResponse(Call call, Response response) throws IOException;
+  @Throws(IOException::class)
+  fun onResponse(call: Call, response: Response)
 }
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
deleted file mode 100644
index 474c245ae6..0000000000
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ /dev/null
@@ -1,344 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Objects;
-import java.util.Set;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import okhttp3.internal.tls.CertificateChainCleaner;
-import okio.ByteString;
-
-/**
- * Constrains which certificates are trusted. Pinning certificates defends against attacks on
- * certificate authorities. It also prevents connections through man-in-the-middle certificate
- * authorities either known or unknown to the application's user.
- *
- * <p>This class currently pins a certificate's Subject Public Key Info as described on <a
- * href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins are either base64 SHA-256 hashes as
- * in <a href="http://tools.ietf.org/html/rfc7469">HTTP Public Key Pinning (HPKP)</a> or SHA-1
- * base64 hashes as in Chromium's <a href="http://goo.gl/XDh6je">static certificates</a>.
- *
- * <h3>Setting up Certificate Pinning</h3>
- *
- * <p>The easiest way to pin a host is turn on pinning with a broken configuration and read the
- * expected configuration when the connection fails. Be sure to do this on a trusted network, and
- * without man-in-the-middle tools like <a href="http://charlesproxy.com">Charles</a> or <a
- * href="http://fiddlertool.com">Fiddler</a>.
- *
- * <p>For example, to pin {@code https://publicobject.com}, start with a broken
- * configuration: <pre>   {@code
- *
- *     String hostname = "publicobject.com";
- *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
- *         .add(hostname, "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
- *         .build();
- *     OkHttpClient client = OkHttpClient.Builder()
- *         .certificatePinner(certificatePinner)
- *         .build();
- *
- *     Request request = new Request.Builder()
- *         .url("https://" + hostname)
- *         .build();
- *     client.newCall(request).execute();
- * }</pre>
- *
- * As expected, this fails with a certificate pinning exception: <pre>   {@code
- *
- * javax.net.ssl.SSLPeerUnverifiedException: Certificate pinning failure!
- *   Peer certificate chain:
- *     sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=: CN=publicobject.com, OU=PositiveSSL
- *     sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=: CN=COMODO RSA Secure Server CA
- *     sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=: CN=COMODO RSA Certification Authority
- *     sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=: CN=AddTrust External CA Root
- *   Pinned certificates for publicobject.com:
- *     sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
- *   at okhttp3.CertificatePinner.check(CertificatePinner.java)
- *   at okhttp3.Connection.upgradeToTls(Connection.java)
- *   at okhttp3.Connection.connect(Connection.java)
- *   at okhttp3.Connection.connectAndSetOwner(Connection.java)
- * }</pre>
- *
- * Follow up by pasting the public key hashes from the exception into the
- * certificate pinner's configuration: <pre>   {@code
- *
- *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
- *       .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
- *       .add("publicobject.com", "sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=")
- *       .add("publicobject.com", "sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=")
- *       .add("publicobject.com", "sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=")
- *       .build();
- * }</pre>
- *
- * Pinning is per-hostname and/or per-wildcard pattern. To pin both {@code publicobject.com} and
- * {@code www.publicobject.com}, you must configure both hostnames.
- *
- * <p>Wildcard pattern rules:
- * <ol>
- *     <li>Asterisk {@code *} is only permitted in the left-most domain name label and must be the
- *         only character in that label (i.e., must match the whole left-most label). For example,
- *         {@code *.example.com} is permitted, while {@code *a.example.com}, {@code a*.example.com},
- *         {@code a*b.example.com}, {@code a.*.example.com} are not permitted.
- *     <li>Asterisk {@code *} cannot match across domain name labels. For example,
- *         {@code *.example.com} matches {@code test.example.com} but does not match
- *         {@code sub.test.example.com}.
- *     <li>Wildcard patterns for single-label domain names are not permitted.
- * </ol>
- *
- * If hostname pinned directly and via wildcard pattern, both direct and wildcard pins will be used.
- * For example: {@code *.example.com} pinned with {@code pin1} and {@code a.example.com} pinned with
- * {@code pin2}, to check {@code a.example.com} both {@code pin1} and {@code pin2} will be used.
- *
- * <h3>Warning: Certificate Pinning is Dangerous!</h3>
- *
- * <p>Pinning certificates limits your server team's abilities to update their TLS certificates. By
- * pinning certificates, you take on additional operational complexity and limit your ability to
- * migrate between certificate authorities. Do not use certificate pinning without the blessing of
- * your server's TLS administrator!
- *
- * <h4>Note about self-signed certificates</h4>
- *
- * <p>{@link CertificatePinner} can not be used to pin self-signed certificate if such certificate
- * is not accepted by {@link javax.net.ssl.TrustManager}.
- *
- * @see <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning"> OWASP:
- * Certificate and Public Key Pinning</a>
- */
-public final class CertificatePinner {
-  public static final CertificatePinner DEFAULT = new Builder().build();
-
-  private final Set<Pin> pins;
-  private final @Nullable CertificateChainCleaner certificateChainCleaner;
-
-  CertificatePinner(Set<Pin> pins, @Nullable CertificateChainCleaner certificateChainCleaner) {
-    this.pins = pins;
-    this.certificateChainCleaner = certificateChainCleaner;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    if (other == this) return true;
-    return other instanceof CertificatePinner
-        && (Objects.equals(certificateChainCleaner,
-        ((CertificatePinner) other).certificateChainCleaner)
-        && pins.equals(((CertificatePinner) other).pins));
-  }
-
-  @Override public int hashCode() {
-    int result = Objects.hashCode(certificateChainCleaner);
-    result = 31 * result + pins.hashCode();
-    return result;
-  }
-
-  /**
-   * Confirms that at least one of the certificates pinned for {@code hostname} is in {@code
-   * peerCertificates}. Does nothing if there are no certificates pinned for {@code hostname}.
-   * OkHttp calls this after a successful TLS handshake, but before the connection is used.
-   *
-   * @throws SSLPeerUnverifiedException if {@code peerCertificates} don't match the certificates
-   * pinned for {@code hostname}.
-   */
-  public void check(String hostname, List<Certificate> peerCertificates)
-      throws SSLPeerUnverifiedException {
-    List<Pin> pins = findMatchingPins(hostname);
-    if (pins.isEmpty()) return;
-
-    if (certificateChainCleaner != null) {
-      peerCertificates = certificateChainCleaner.clean(peerCertificates, hostname);
-    }
-
-    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
-      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
-
-      // Lazily compute the hashes for each certificate.
-      ByteString sha1 = null;
-      ByteString sha256 = null;
-
-      for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
-        Pin pin = pins.get(p);
-        if (pin.hashAlgorithm.equals("sha256/")) {
-          if (sha256 == null) sha256 = sha256(x509Certificate);
-          if (pin.hash.equals(sha256)) return; // Success!
-        } else if (pin.hashAlgorithm.equals("sha1/")) {
-          if (sha1 == null) sha1 = sha1(x509Certificate);
-          if (pin.hash.equals(sha1)) return; // Success!
-        } else {
-          throw new AssertionError("unsupported hashAlgorithm: " + pin.hashAlgorithm);
-        }
-      }
-    }
-
-    // If we couldn't find a matching pin, format a nice exception.
-    StringBuilder message = new StringBuilder()
-        .append("Certificate pinning failure!")
-        .append("\n  Peer certificate chain:");
-    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
-      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
-      message.append("\n    ").append(pin(x509Certificate))
-          .append(": ").append(x509Certificate.getSubjectDN().getName());
-    }
-    message.append("\n  Pinned certificates for ").append(hostname).append(":");
-    for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
-      Pin pin = pins.get(p);
-      message.append("\n    ").append(pin);
-    }
-    throw new SSLPeerUnverifiedException(message.toString());
-  }
-
-  /** @deprecated replaced with {@link #check(String, List)}. */
-  public void check(String hostname, Certificate... peerCertificates)
-      throws SSLPeerUnverifiedException {
-    check(hostname, Arrays.asList(peerCertificates));
-  }
-
-  /**
-   * Returns list of matching certificates' pins for the hostname. Returns an empty list if the
-   * hostname does not have pinned certificates.
-   */
-  List<Pin> findMatchingPins(String hostname) {
-    List<Pin> result = Collections.emptyList();
-    for (Pin pin : pins) {
-      if (pin.matches(hostname)) {
-        if (result.isEmpty()) result = new ArrayList<>();
-        result.add(pin);
-      }
-    }
-    return result;
-  }
-
-  /** Returns a certificate pinner that uses {@code certificateChainCleaner}. */
-  CertificatePinner withCertificateChainCleaner(
-      @Nullable CertificateChainCleaner certificateChainCleaner) {
-    return Objects.equals(this.certificateChainCleaner, certificateChainCleaner)
-        ? this
-        : new CertificatePinner(pins, certificateChainCleaner);
-  }
-
-  /**
-   * Returns the SHA-256 of {@code certificate}'s public key.
-   *
-   * <p>In OkHttp 3.1.2 and earlier, this returned a SHA-1 hash of the public key. Both types are
-   * supported, but SHA-256 is preferred.
-   */
-  public static String pin(Certificate certificate) {
-    if (!(certificate instanceof X509Certificate)) {
-      throw new IllegalArgumentException("Certificate pinning requires X509 certificates");
-    }
-    return "sha256/" + sha256((X509Certificate) certificate).base64();
-  }
-
-  static ByteString sha1(X509Certificate x509Certificate) {
-    return ByteString.of(x509Certificate.getPublicKey().getEncoded()).sha1();
-  }
-
-  static ByteString sha256(X509Certificate x509Certificate) {
-    return ByteString.of(x509Certificate.getPublicKey().getEncoded()).sha256();
-  }
-
-  static final class Pin {
-    private static final String WILDCARD = "*.";
-    /** A hostname like {@code example.com} or a pattern like {@code *.example.com}. */
-    final String pattern;
-    /** The canonical hostname, i.e. {@code EXAMPLE.com} becomes {@code example.com}. */
-    final String canonicalHostname;
-    /** Either {@code sha1/} or {@code sha256/}. */
-    final String hashAlgorithm;
-    /** The hash of the pinned certificate using {@link #hashAlgorithm}. */
-    final ByteString hash;
-
-    Pin(String pattern, String pin) {
-      this.pattern = pattern;
-      this.canonicalHostname = pattern.startsWith(WILDCARD)
-          ? HttpUrl.get("http://" + pattern.substring(WILDCARD.length())).host()
-          : HttpUrl.get("http://" + pattern).host();
-      if (pin.startsWith("sha1/")) {
-        this.hashAlgorithm = "sha1/";
-        this.hash = ByteString.decodeBase64(pin.substring("sha1/".length()));
-      } else if (pin.startsWith("sha256/")) {
-        this.hashAlgorithm = "sha256/";
-        this.hash = ByteString.decodeBase64(pin.substring("sha256/".length()));
-      } else {
-        throw new IllegalArgumentException("pins must start with 'sha256/' or 'sha1/': " + pin);
-      }
-
-      if (this.hash == null) {
-        throw new IllegalArgumentException("pins must be base64: " + pin);
-      }
-    }
-
-    boolean matches(String hostname) {
-      if (pattern.startsWith(WILDCARD)) {
-        int firstDot = hostname.indexOf('.');
-        return (hostname.length() - firstDot - 1) == canonicalHostname.length()
-            && hostname.regionMatches(false, firstDot + 1, canonicalHostname, 0,
-            canonicalHostname.length());
-      }
-
-      return hostname.equals(canonicalHostname);
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof Pin
-          && pattern.equals(((Pin) other).pattern)
-          && hashAlgorithm.equals(((Pin) other).hashAlgorithm)
-          && hash.equals(((Pin) other).hash);
-    }
-
-    @Override public int hashCode() {
-      int result = 17;
-      result = 31 * result + pattern.hashCode();
-      result = 31 * result + hashAlgorithm.hashCode();
-      result = 31 * result + hash.hashCode();
-      return result;
-    }
-
-    @Override public String toString() {
-      return hashAlgorithm + hash.base64();
-    }
-  }
-
-  /** Builds a configured certificate pinner. */
-  public static final class Builder {
-    private final List<Pin> pins = new ArrayList<>();
-
-    /**
-     * Pins certificates for {@code pattern}.
-     *
-     * @param pattern lower-case host name or wildcard pattern such as {@code *.example.com}.
-     * @param pins SHA-256 or SHA-1 hashes. Each pin is a hash of a certificate's Subject Public Key
-     * Info, base64-encoded and prefixed with either {@code sha256/} or {@code sha1/}.
-     */
-    public Builder add(String pattern, String... pins) {
-      if (pattern == null) throw new NullPointerException("pattern == null");
-
-      for (String pin : pins) {
-        this.pins.add(new Pin(pattern, pin));
-      }
-
-      return this;
-    }
-
-    public CertificatePinner build() {
-      return new CertificatePinner(new LinkedHashSet<>(pins), null);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.kt b/okhttp/src/main/java/okhttp3/CertificatePinner.kt
new file mode 100644
index 0000000000..ec4e07f61d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.kt
@@ -0,0 +1,315 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.tls.CertificateChainCleaner
+import okio.ByteString
+import okio.ByteString.Companion.decodeBase64
+import java.security.cert.Certificate
+import java.security.cert.X509Certificate
+import javax.net.ssl.SSLPeerUnverifiedException
+
+/**
+ * Constrains which certificates are trusted. Pinning certificates defends against attacks on
+ * certificate authorities. It also prevents connections through man-in-the-middle certificate
+ * authorities either known or unknown to the application's user.
+ * This class currently pins a certificate's Subject Public Key Info as described on
+ * [Adam Langley's Weblog][langley]. Pins are either base64 SHA-256 hashes as in
+ * [HTTP Public Key Pinning (HPKP)][rfc_7469] or SHA-1 base64 hashes as in Chromium's
+ * [static certificates][static_certificates].
+ *
+ * ## Setting up Certificate Pinning
+ *
+ * The easiest way to pin a host is turn on pinning with a broken configuration and read the
+ * expected configuration when the connection fails. Be sure to do this on a trusted network, and
+ * without man-in-the-middle tools like [Charles][charles] or [Fiddler][fiddler].
+ *
+ * For example, to pin `https://publicobject.com`, start with a broken configuration:
+ *
+ * ```
+ * String hostname = "publicobject.com";
+ * CertificatePinner certificatePinner = new CertificatePinner.Builder()
+ *     .add(hostname, "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
+ *     .build();
+ * OkHttpClient client = OkHttpClient.Builder()
+ *     .certificatePinner(certificatePinner)
+ *     .build();
+ *
+ * Request request = new Request.Builder()
+ *     .url("https://" + hostname)
+ *     .build();
+ * client.newCall(request).execute();
+ * ```
+ *
+ * As expected, this fails with a certificate pinning exception:
+ *
+ * ```
+ * javax.net.ssl.SSLPeerUnverifiedException: Certificate pinning failure!
+ * Peer certificate chain:
+ *     sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=: CN=publicobject.com, OU=PositiveSSL
+ *     sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=: CN=COMODO RSA Secure Server CA
+ *     sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=: CN=COMODO RSA Certification Authority
+ *     sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=: CN=AddTrust External CA Root
+ * Pinned certificates for publicobject.com:
+ *     sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
+ *   at okhttp3.CertificatePinner.check(CertificatePinner.java)
+ *   at okhttp3.Connection.upgradeToTls(Connection.java)
+ *   at okhttp3.Connection.connect(Connection.java)
+ *   at okhttp3.Connection.connectAndSetOwner(Connection.java)
+ * ```
+ *
+ * Follow up by pasting the public key hashes from the exception into the
+ * certificate pinner's configuration:
+ *
+ * ```
+ * CertificatePinner certificatePinner = new CertificatePinner.Builder()
+ *     .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+ *     .add("publicobject.com", "sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=")
+ *     .add("publicobject.com", "sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=")
+ *     .add("publicobject.com", "sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=")
+ *     .build();
+ * ```
+ *
+ * Pinning is per-hostname and/or per-wildcard pattern. To pin both `publicobject.com` and
+ * `www.publicobject.com`, you must configure both hostnames.
+ *
+ * Wildcard pattern rules:
+ *
+ *  1. Asterisk `*` is only permitted in the left-most domain name label and must be the only
+ *     character in that label (i.e., must match the whole left-most label). For example,
+ *     `*.example.com` is permitted, while `*a.example.com`, `a*.example.com`, `a*b.example.com`,
+ *     `a.*.example.com` are not permitted.
+ *  2. Asterisk `*` cannot match across domain name labels. For example, `*.example.com` matches
+ *     `test.example.com` but does not match `sub.test.example.com`.
+ *  3. Wildcard patterns for single-label domain names are not permitted.
+ *
+ * If hostname pinned directly and via wildcard pattern, both direct and wildcard pins will be used.
+ * For example: `*.example.com` pinned with `pin1` and `a.example.com` pinned with `pin2`, to check
+ * `a.example.com` both `pin1` and `pin2` will be used.
+ *
+ * ## Warning: Certificate Pinning is Dangerous!
+ *
+ * Pinning certificates limits your server team's abilities to update their TLS certificates. By
+ * pinning certificates, you take on additional operational complexity and limit your ability to
+ * migrate between certificate authorities. Do not use certificate pinning without the blessing of
+ * your server's TLS administrator!
+ *
+ * ### Note about self-signed certificates
+ *
+ * [CertificatePinner] can not be used to pin self-signed certificate if such certificate is not
+ * accepted by [javax.net.ssl.TrustManager].
+ *
+ * See also [OWASP: Certificate and Public Key Pinning][owasp].
+ *
+ * [charles]: http://charlesproxy.com
+ * [fiddler]: http://fiddlertool.com
+ * [langley]: http://goo.gl/AIx3e5
+ * [owasp]: https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning
+ * [rfc_7469]: http://tools.ietf.org/html/rfc7469
+ * [static_certificates]: http://goo.gl/XDh6je
+ */
+data class CertificatePinner internal constructor(
+  private val pins: Set<Pin>,
+  private val certificateChainCleaner: CertificateChainCleaner?
+) {
+  /**
+   * Confirms that at least one of the certificates pinned for `hostname` is in `peerCertificates`.
+   * Does nothing if there are no certificates pinned for `hostname`. OkHttp calls this after a
+   * successful TLS handshake, but before the connection is used.
+   *
+   * @throws SSLPeerUnverifiedException if `peerCertificates` don't match the certificates pinned
+   *     for `hostname`.
+   */
+  @Throws(SSLPeerUnverifiedException::class)
+  fun check(hostname: String, peerCertificates: List<Certificate>) {
+    var peerCertificates = peerCertificates
+    val pins = findMatchingPins(hostname)
+    if (pins.isEmpty()) return
+
+    if (certificateChainCleaner != null) {
+      peerCertificates = certificateChainCleaner.clean(peerCertificates, hostname)
+    }
+
+    for (peerCertificate in peerCertificates) {
+      val x509Certificate = peerCertificate as X509Certificate
+
+      // Lazily compute the hashes for each certificate.
+      var sha1: ByteString? = null
+      var sha256: ByteString? = null
+
+      for (pin in pins) {
+        when (pin.hashAlgorithm) {
+          "sha256/" -> {
+            if (sha256 == null) sha256 = sha256(x509Certificate)
+            if (pin.hash == sha256) return // Success!
+          }
+          "sha1/" -> {
+            if (sha1 == null) sha1 = sha1(x509Certificate)
+            if (pin.hash == sha1) return // Success!
+          }
+          else -> throw AssertionError("unsupported hashAlgorithm: ${pin.hashAlgorithm}")
+        }
+      }
+    }
+
+    // If we couldn't find a matching pin, format a nice exception.
+    val message = buildString {
+      append("Certificate pinning failure!")
+      append("\n  Peer certificate chain:")
+      for (c in 0 until peerCertificates.size) {
+        val x509Certificate = peerCertificates[c] as X509Certificate
+        append("\n    ")
+        append(pin(x509Certificate))
+        append(": ")
+        append(x509Certificate.subjectDN.name)
+      }
+      append("\n  Pinned certificates for ")
+      append(hostname)
+      append(":")
+      for (pin in pins) {
+        append("\n    ")
+        append(pin)
+      }
+    }
+    throw SSLPeerUnverifiedException(message)
+  }
+
+  @Deprecated(
+      "replaced with {@link #check(String, List)}.",
+      ReplaceWith("check(hostname, peerCertificates.toList())")
+  )
+  @Throws(SSLPeerUnverifiedException::class)
+  inline fun check(hostname: String, vararg peerCertificates: Certificate) {
+    check(hostname, peerCertificates.toList())
+  }
+
+  /**
+   * Returns list of matching certificates' pins for the hostname. Returns an empty list if the
+   * hostname does not have pinned certificates.
+   */
+  internal fun findMatchingPins(hostname: String): List<Pin> {
+    var result: List<Pin> = emptyList()
+    for (pin in pins) {
+      if (pin.matches(hostname)) {
+        if (result.isEmpty()) result = mutableListOf()
+        (result as MutableList<Pin>).add(pin)
+      }
+    }
+    return result
+  }
+
+  /** Returns a certificate pinner that uses `certificateChainCleaner`.  */
+  internal fun withCertificateChainCleaner(
+    certificateChainCleaner: CertificateChainCleaner?
+  ): CertificatePinner {
+    return if (this.certificateChainCleaner == certificateChainCleaner) {
+      this
+    } else {
+      CertificatePinner(pins, certificateChainCleaner)
+    }
+  }
+
+  internal data class Pin(
+    /** A hostname like `example.com` or a pattern like `*.example.com`.  */
+    val pattern: String,
+    /** The canonical hostname, i.e. `EXAMPLE.com` becomes `example.com`.  */
+    private val canonicalHostname: String,
+    /** Either `sha1/` or `sha256/`.  */
+    val hashAlgorithm: String,
+    /** The hash of the pinned certificate using [.hashAlgorithm].  */
+    val hash: ByteString
+  ) {
+    fun matches(hostname: String): Boolean {
+      if (pattern.startsWith(WILDCARD)) {
+        val firstDot = hostname.indexOf('.')
+        return hostname.length - firstDot - 1 == canonicalHostname.length &&
+            hostname.regionMatches(firstDot + 1, canonicalHostname, 0, canonicalHostname.length,
+            ignoreCase = false)
+      }
+      return hostname == canonicalHostname
+    }
+
+    override fun toString(): String = hashAlgorithm + hash.base64()
+  }
+
+  /** Builds a configured certificate pinner.  */
+  class Builder {
+    private val pins = mutableListOf<Pin>()
+
+    /**
+     * Pins certificates for `pattern`.
+     *
+     * @param pattern lower-case host name or wildcard pattern such as `*.example.com`.
+     * @param pins SHA-256 or SHA-1 hashes. Each pin is a hash of a certificate's Subject Public Key
+     * Info, base64-encoded and prefixed with either `sha256/` or `sha1/`.
+     */
+    fun add(pattern: String, vararg pins: String) = apply {
+      for (pin in pins) {
+        this.pins.add(newPin(pattern, pin))
+      }
+    }
+
+    fun build(): CertificatePinner = CertificatePinner(pins.toSet(), null)
+  }
+
+  companion object {
+    internal const val WILDCARD = "*."
+
+    @JvmField
+    val DEFAULT = Builder().build()
+
+    /**
+     * Returns the SHA-256 of `certificate`'s public key.
+     *
+     * In OkHttp 3.1.2 and earlier, this returned a SHA-1 hash of the public key. Both types are
+     * supported, but SHA-256 is preferred.
+     */
+    @JvmStatic
+    fun pin(certificate: Certificate): String {
+      require(certificate is X509Certificate) { "Certificate pinning requires X509 certificates" }
+      return "sha256/${sha256(certificate).base64()}"
+    }
+
+    internal fun sha1(x509Certificate: X509Certificate): ByteString =
+        ByteString.of(*x509Certificate.publicKey.encoded).sha1()
+
+    internal fun sha256(x509Certificate: X509Certificate): ByteString =
+        ByteString.of(*x509Certificate.publicKey.encoded).sha256()
+
+    internal fun newPin(pattern: String, pin: String): Pin {
+      val canonicalHostname = when {
+        pattern.startsWith(WILDCARD) -> {
+          HttpUrl.get("http://${pattern.substring(WILDCARD.length)}").host()
+        }
+        else -> {
+          HttpUrl.get("http://$pattern").host()
+        }
+      }
+
+      return when {
+        pin.startsWith("sha1/") -> {
+          val hash = pin.substring("sha1/".length).decodeBase64()!!
+          Pin(pattern, canonicalHostname, "sha1/", hash)
+        }
+        pin.startsWith("sha256/") -> {
+          val hash = pin.substring("sha256/".length).decodeBase64()!!
+          Pin(pattern, canonicalHostname, "sha256/", hash)
+        }
+        else -> throw IllegalArgumentException("pins must start with 'sha256/' or 'sha1/': $pin")
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Challenge.java b/okhttp/src/main/java/okhttp3/Challenge.java
deleted file mode 100644
index 0fb4c868a6..0000000000
--- a/okhttp/src/main/java/okhttp3/Challenge.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.nio.charset.Charset;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.Map.Entry;
-import javax.annotation.Nullable;
-
-import static java.nio.charset.StandardCharsets.ISO_8859_1;
-import static java.util.Collections.singletonMap;
-import static java.util.Collections.unmodifiableMap;
-import static java.util.Locale.US;
-
-/** An RFC 7235 challenge. */
-public final class Challenge {
-  private final String scheme;
-  private final Map<String, String> authParams;
-
-  public Challenge(String scheme, Map<String, String> authParams) {
-    if (scheme == null) throw new NullPointerException("scheme == null");
-    if (authParams == null) throw new NullPointerException("authParams == null");
-    this.scheme = scheme;
-    Map<String, String> newAuthParams = new LinkedHashMap<>();
-    for (Entry<String, String> authParam : authParams.entrySet()) {
-      String key = (authParam.getKey() == null) ? null : authParam.getKey().toLowerCase(US);
-      newAuthParams.put(key, authParam.getValue());
-    }
-    this.authParams = unmodifiableMap(newAuthParams);
-  }
-
-  public Challenge(String scheme, String realm) {
-    if (scheme == null) throw new NullPointerException("scheme == null");
-    if (realm == null) throw new NullPointerException("realm == null");
-    this.scheme = scheme;
-    this.authParams = singletonMap("realm", realm);
-  }
-
-  /** Returns a copy of this charset that expects a credential encoded with {@code charset}. */
-  public Challenge withCharset(Charset charset) {
-    if (charset == null) throw new NullPointerException("charset == null");
-    Map<String, String> authParams = new LinkedHashMap<>(this.authParams);
-    authParams.put("charset", charset.name());
-    return new Challenge(scheme, authParams);
-  }
-
-  /** Returns the authentication scheme, like {@code Basic}. */
-  public String scheme() {
-    return scheme;
-  }
-
-  /**
-   * Returns the auth params, including {@code realm} and {@code charset} if present, but as
-   * strings. The map's keys are lowercase and should be treated case-insensitively.
-   */
-  public Map<String, String> authParams() {
-    return authParams;
-  }
-
-  /** Returns the protection space. */
-  public String realm() {
-    return authParams.get("realm");
-  }
-
-  /** Returns the charset that should be used to encode the credentials. */
-  public Charset charset() {
-    String charset = authParams.get("charset");
-    if (charset != null) {
-      try {
-        return Charset.forName(charset);
-      } catch (Exception ignore) {
-      }
-    }
-    return ISO_8859_1;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof Challenge
-        && ((Challenge) other).scheme.equals(scheme)
-        && ((Challenge) other).authParams.equals(authParams);
-  }
-
-  @Override public int hashCode() {
-    int result = 29;
-    result = 31 * result + scheme.hashCode();
-    result = 31 * result + authParams.hashCode();
-    return result;
-  }
-
-  @Override public String toString() {
-    return scheme + " authParams=" + authParams;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Challenge.kt b/okhttp/src/main/java/okhttp3/Challenge.kt
new file mode 100644
index 0000000000..c69b7950df
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Challenge.kt
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.nio.charset.Charset
+import java.nio.charset.StandardCharsets.ISO_8859_1
+import java.util.Collections.singletonMap
+import java.util.Collections.unmodifiableMap
+import java.util.Locale.US
+
+/** An RFC 7235 challenge. */
+class Challenge(
+  private val scheme: String,
+  authParams: Map<String?, String>
+) {
+  private val authParams: Map<String?, String>
+
+  init {
+    val newAuthParams = mutableMapOf<String?, String>()
+    for ((key, value) in authParams) {
+      val newKey = key?.toLowerCase(US)
+      newAuthParams[newKey] = value
+    }
+    this.authParams = unmodifiableMap<String?, String>(newAuthParams)
+  }
+
+  constructor(scheme: String, realm: String) : this(scheme, singletonMap("realm", realm))
+
+  /** Returns a copy of this charset that expects a credential encoded with [charset]. */
+  fun withCharset(charset: Charset): Challenge {
+    val authParams = this.authParams.toMutableMap()
+    authParams["charset"] = charset.name()
+    return Challenge(scheme, authParams)
+  }
+
+  /** Returns the authentication scheme, like `Basic`. */
+  fun scheme() = scheme
+
+  /**
+   * Returns the auth params, including [realm] and [charset] if present, but as
+   * strings. The map's keys are lowercase and should be treated case-insensitively.
+   */
+  fun authParams() = authParams
+
+  /** Returns the protection space. */
+  fun realm(): String? = authParams["realm"]
+
+  /** Returns the charset that should be used to encode the credentials. */
+  fun charset(): Charset {
+    val charset = authParams["charset"]
+    if (charset != null) {
+      try {
+        return Charset.forName(charset)
+      } catch (ignore: Exception) {
+      }
+    }
+    return ISO_8859_1
+  }
+
+  override fun equals(other: Any?): Boolean {
+    return other is Challenge &&
+        other.scheme == scheme &&
+        other.authParams == authParams
+  }
+
+  override fun hashCode(): Int {
+    var result = 29
+    result = 31 * result + scheme.hashCode()
+    result = 31 * result + authParams.hashCode()
+    return result
+  }
+
+  override fun toString(): String {
+    return "$scheme authParams=$authParams"
+  }
+}
\ No newline at end of file
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.java b/okhttp/src/main/java/okhttp3/CipherSuite.java
deleted file mode 100644
index 376e1fe0fa..0000000000
--- a/okhttp/src/main/java/okhttp3/CipherSuite.java
+++ /dev/null
@@ -1,473 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml">TLS cipher
- * suites</a>.
- *
- * <p><strong>Not all cipher suites are supported on all platforms.</strong> As newer cipher suites
- * are created (for stronger privacy, better performance, etc.) they will be adopted by the platform
- * and then exposed here. Cipher suites that are not available on either Android (through API level
- * 24) or Java (through JDK 9) are omitted for brevity.
- *
- * <p>See <a href="https://developer.android.com/reference/javax/net/ssl/SSLEngine.html">Android SSLEngine</a>
- * which lists the cipher suites supported by Android.
- *
- * <p>See <a href="https://docs.oracle.com/javase/10/security/oracle-providers.htm">JDK 10 Providers</a>
- * which lists the cipher suites supported by Oracle.
- *
- * <p>See <a href="https://github.com/google/conscrypt/blob/master/common/src/main/java/org/conscrypt/NativeCrypto.java">NativeCrypto.java</a>
- * from conscrypt, which lists the cipher suites supported by Conscrypt.
- */
-public final class CipherSuite {
-  /**
-   * Compares cipher suites names like "TLS_RSA_WITH_NULL_MD5" and "SSL_RSA_WITH_NULL_MD5", ignoring
-   * the "TLS_" or "SSL_" prefix which is not consistent across platforms. In particular some IBM
-   * JVMs use the "SSL_" prefix everywhere whereas Oracle JVMs mix "TLS_" and "SSL_".
-   */
-  static final Comparator<String> ORDER_BY_NAME = (a, b) -> {
-    for (int i = 4, limit = Math.min(a.length(), b.length()); i < limit; i++) {
-      char charA = a.charAt(i);
-      char charB = b.charAt(i);
-      if (charA != charB) return charA < charB ? -1 : 1;
-    }
-    int lengthA = a.length();
-    int lengthB = b.length();
-    if (lengthA != lengthB) return lengthA < lengthB ? -1 : 1;
-    return 0;
-  };
-
-  /**
-   * Holds interned instances. This needs to be above the init() calls below so that it's
-   * initialized by the time those parts of {@code <clinit>()} run. Guarded by CipherSuite.class.
-   */
-  private static final Map<String, CipherSuite> INSTANCES = new LinkedHashMap<>();
-
-  // Last updated 2016-07-03 using cipher suites from Android 24 and Java 9.
-
-  // public static final CipherSuite TLS_NULL_WITH_NULL_NULL = init("TLS_NULL_WITH_NULL_NULL", 0x0000);
-  public static final CipherSuite TLS_RSA_WITH_NULL_MD5 = init("SSL_RSA_WITH_NULL_MD5", 0x0001);
-  public static final CipherSuite TLS_RSA_WITH_NULL_SHA = init("SSL_RSA_WITH_NULL_SHA", 0x0002);
-  public static final CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5 = init("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003);
-  public static final CipherSuite TLS_RSA_WITH_RC4_128_MD5 = init("SSL_RSA_WITH_RC4_128_MD5", 0x0004);
-  public static final CipherSuite TLS_RSA_WITH_RC4_128_SHA = init("SSL_RSA_WITH_RC4_128_SHA", 0x0005);
-  // public static final CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = init("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006);
-  // public static final CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = init("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007);
-  public static final CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008);
-  public static final CipherSuite TLS_RSA_WITH_DES_CBC_SHA = init("SSL_RSA_WITH_DES_CBC_SHA", 0x0009);
-  public static final CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = init("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a);
-  // public static final CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b);
-  // public static final CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA = init("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c);
-  // public static final CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = init("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d);
-  // public static final CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA = init("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010);
-  public static final CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011);
-  public static final CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA = init("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012);
-  public static final CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = init("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013);
-  public static final CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014);
-  public static final CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA = init("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015);
-  public static final CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = init("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016);
-  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = init("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017);
-  public static final CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = init("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018);
-  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019);
-  public static final CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA = init("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a);
-  public static final CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = init("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b);
-  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_SHA = init("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e);
-  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA = init("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f);
-  public static final CipherSuite TLS_KRB5_WITH_RC4_128_SHA = init("TLS_KRB5_WITH_RC4_128_SHA", 0x0020);
-  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA = init("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021);
-  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_MD5 = init("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022);
-  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = init("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023);
-  public static final CipherSuite TLS_KRB5_WITH_RC4_128_MD5 = init("TLS_KRB5_WITH_RC4_128_MD5", 0x0024);
-  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5 = init("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = init("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026);
-  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = init("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA = init("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = init("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029);
-  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = init("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = init("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA = init("TLS_PSK_WITH_NULL_SHA", 0x002c);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA = init("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA = init("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = init("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = init("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = init("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = init("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = init("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = init("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = init("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = init("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = init("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = init("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = init("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = init("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a);
-  public static final CipherSuite TLS_RSA_WITH_NULL_SHA256 = init("TLS_RSA_WITH_NULL_SHA256", 0x003b);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040);
-  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043);
-  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044);
-  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = init("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = init("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = init("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = init("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d);
-  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086);
-  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087);
-  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089);
-  public static final CipherSuite TLS_PSK_WITH_RC4_128_SHA = init("TLS_PSK_WITH_RC4_128_SHA", 0x008a);
-  public static final CipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b);
-  public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA = init("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c);
-  public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA = init("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA = init("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA = init("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA = init("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA = init("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA = init("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA = init("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095);
-  public static final CipherSuite TLS_RSA_WITH_SEED_CBC_SHA = init("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096);
-  // public static final CipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA = init("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097);
-  // public static final CipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA = init("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA = init("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA = init("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a);
-  // public static final CipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA = init("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256 = init("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384 = init("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA256 = init("TLS_PSK_WITH_NULL_SHA256", 0x00b0);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA384 = init("TLS_PSK_WITH_NULL_SHA384", 0x00b1);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA256 = init("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA384 = init("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA256 = init("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA384 = init("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5);
-  public static final CipherSuite TLS_EMPTY_RENEGOTIATION_INFO_SCSV = init("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff);
-  public static final CipherSuite TLS_FALLBACK_SCSV = init("TLS_FALLBACK_SCSV", 0x5600);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA = init("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA = init("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA = init("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = init("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA = init("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA = init("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = init("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = init("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA = init("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA = init("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014);
-  public static final CipherSuite TLS_ECDH_anon_WITH_NULL_SHA = init("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015);
-  public static final CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA = init("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016);
-  public static final CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017);
-  public static final CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA = init("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018);
-  public static final CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA = init("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_RC4_128_SHA = init("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034);
-  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035);
-  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA = init("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA256 = init("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA384 = init("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b);
-  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM = init("TLS_RSA_WITH_AES_128_CCM", 0xc09c);
-  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM = init("TLS_RSA_WITH_AES_256_CCM", 0xc09d);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM = init("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM = init("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f);
-  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM_8 = init("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0);
-  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM_8 = init("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM_8 = init("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM_8 = init("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM = init("TLS_PSK_WITH_AES_128_CCM", 0xc0a4);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM = init("TLS_PSK_WITH_AES_256_CCM", 0xc0a5);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CCM = init("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CCM = init("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM_8 = init("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM_8 = init("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9);
-  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_128_CCM_8 = init("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa);
-  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_256_CCM_8 = init("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM = init("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM = init("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = init("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = init("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9);
-  public static final CipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa);
-  // public static final CipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccab);
-  public static final CipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccad);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccae);
-
-  // TLS 1.3 https://tools.ietf.org/html/rfc8446
-  public static final CipherSuite TLS_AES_128_GCM_SHA256 = init("TLS_AES_128_GCM_SHA256", 0x1301);
-  public static final CipherSuite TLS_AES_256_GCM_SHA384 = init("TLS_AES_256_GCM_SHA384", 0x1302);
-  public static final CipherSuite TLS_CHACHA20_POLY1305_SHA256 = init("TLS_CHACHA20_POLY1305_SHA256", 0x1303);
-  public static final CipherSuite TLS_AES_128_CCM_SHA256 = init("TLS_AES_128_CCM_SHA256", 0x1304);
-  public static final CipherSuite TLS_AES_256_CCM_8_SHA256 = init("TLS_AES_256_CCM_8_SHA256", 0x1305);
-
-  final String javaName;
-
-  /**
-   * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
-   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
-   */
-  public static synchronized CipherSuite forJavaName(String javaName) {
-    CipherSuite result = INSTANCES.get(javaName);
-    if (result == null) {
-      result = INSTANCES.get(secondaryName(javaName));
-
-      if (result == null) {
-        result = new CipherSuite(javaName);
-      }
-
-      // Add the new cipher suite, or a confirmed alias.
-      INSTANCES.put(javaName, result);
-    }
-    return result;
-  }
-
-  private static String secondaryName(String javaName) {
-    if (javaName.startsWith("TLS_")) {
-      return "SSL_" + javaName.substring(4);
-    } else if (javaName.startsWith("SSL_")) {
-      return "TLS_" + javaName.substring(4);
-    } else {
-      return javaName;
-    }
-  }
-
-  static List<CipherSuite> forJavaNames(String... cipherSuites) {
-    List<CipherSuite> result = new ArrayList<>(cipherSuites.length);
-    for (String cipherSuite : cipherSuites) {
-      result.add(forJavaName(cipherSuite));
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  private CipherSuite(String javaName) {
-    if (javaName == null) {
-      throw new NullPointerException();
-    }
-    this.javaName = javaName;
-  }
-
-  /**
-   * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
-   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
-   * @param value the integer identifier for this cipher suite. (Documentation only.)
-   */
-  private static CipherSuite init(String javaName, int value) {
-    CipherSuite suite = new CipherSuite(javaName);
-    INSTANCES.put(javaName, suite);
-    return suite;
-  }
-
-  /**
-   * Returns the Java name of this cipher suite. For some older cipher suites the Java name has the
-   * prefix {@code SSL_}, causing the Java name to be different from the instance name which is
-   * always prefixed {@code TLS_}. For example, {@code TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName()}
-   * is {@code "SSL_RSA_EXPORT_WITH_RC4_40_MD5"}.
-   */
-  public String javaName() {
-    return javaName;
-  }
-
-  @Override public String toString() {
-    return javaName;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.kt b/okhttp/src/main/java/okhttp3/CipherSuite.kt
new file mode 100644
index 0000000000..877bbfd733
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CipherSuite.kt
@@ -0,0 +1,455 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+/**
+ * [TLS cipher suites][iana_tls_parameters].
+ *
+ * **Not all cipher suites are supported on all platforms.** As newer cipher suites are created (for
+ * stronger privacy, better performance, etc.) they will be adopted by the platform and then exposed
+ * here. Cipher suites that are not available on either Android (through API level 24) or Java
+ * (through JDK 9) are omitted for brevity.
+ *
+ * See [Android SSLEngine][sslengine] which lists the cipher suites supported by Android.
+ *
+ * See [JDK Providers][oracle_providers] which lists the cipher suites supported by Oracle.
+ *
+ * See [NativeCrypto.java][conscrypt_providers] which lists the cipher suites supported by
+ * Conscrypt.
+ *
+ * [iana_tls_parameters]: https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml
+ * [sslengine]: https://developer.android.com/reference/javax/net/ssl/SSLEngine.html
+ * [oracle_providers]: https://docs.oracle.com/javase/10/security/oracle-providers.htm
+ * [conscrypt_providers]: https://github.com/google/conscrypt/blob/master/common/src/main/java/org/conscrypt/NativeCrypto.java
+ */
+class CipherSuite private constructor(
+  private val javaName: String
+) {
+  /**
+   * Returns the Java name of this cipher suite. For some older cipher suites the Java name has the
+   * prefix `SSL_`, causing the Java name to be different from the instance name which is always
+   * prefixed `TLS_`. For example, `TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName()` is
+   * `"SSL_RSA_EXPORT_WITH_RC4_40_MD5"`.
+   */
+  fun javaName(): String = javaName
+
+  override fun toString(): String = javaName
+
+  companion object {
+    /**
+     * Compares cipher suites names like "TLS_RSA_WITH_NULL_MD5" and "SSL_RSA_WITH_NULL_MD5",
+     * ignoring the "TLS_" or "SSL_" prefix which is not consistent across platforms. In particular
+     * some IBM JVMs use the "SSL_" prefix everywhere whereas Oracle JVMs mix "TLS_" and "SSL_".
+     */
+    internal val ORDER_BY_NAME = object : Comparator<String> {
+      override fun compare(a: String, b: String): Int {
+        var i = 4
+        val limit = Math.min(a.length, b.length)
+        while (i < limit) {
+          val charA = a[i]
+          val charB = b[i]
+          if (charA != charB) return if (charA < charB) -1 else 1
+          i++
+        }
+        val lengthA = a.length
+        val lengthB = b.length
+        if (lengthA != lengthB) return if (lengthA < lengthB) -1 else 1
+        return 0
+      }
+    }
+
+    /**
+     * Holds interned instances. This needs to be above the init() calls below so that it's
+     * initialized by the time those parts of `<clinit>()` run. Guarded by CipherSuite.class.
+     */
+    private val INSTANCES = mutableMapOf<String, CipherSuite>()
+
+    // Last updated 2016-07-03 using cipher suites from Android 24 and Java 9.
+
+    // @JvmField val TLS_NULL_WITH_NULL_NULL = init("TLS_NULL_WITH_NULL_NULL", 0x0000)
+    @JvmField val TLS_RSA_WITH_NULL_MD5 = init("SSL_RSA_WITH_NULL_MD5", 0x0001)
+    @JvmField val TLS_RSA_WITH_NULL_SHA = init("SSL_RSA_WITH_NULL_SHA", 0x0002)
+    @JvmField val TLS_RSA_EXPORT_WITH_RC4_40_MD5 = init("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003)
+    @JvmField val TLS_RSA_WITH_RC4_128_MD5 = init("SSL_RSA_WITH_RC4_128_MD5", 0x0004)
+    @JvmField val TLS_RSA_WITH_RC4_128_SHA = init("SSL_RSA_WITH_RC4_128_SHA", 0x0005)
+    // @JvmField val TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = init("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006)
+    // @JvmField val TLS_RSA_WITH_IDEA_CBC_SHA = init("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007)
+    @JvmField val TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008)
+    @JvmField val TLS_RSA_WITH_DES_CBC_SHA = init("SSL_RSA_WITH_DES_CBC_SHA", 0x0009)
+    @JvmField val TLS_RSA_WITH_3DES_EDE_CBC_SHA = init("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a)
+    // @JvmField val TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b)
+    // @JvmField val TLS_DH_DSS_WITH_DES_CBC_SHA = init("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c)
+    // @JvmField val TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = init("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d)
+    // @JvmField val TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e)
+    // @JvmField val TLS_DH_RSA_WITH_DES_CBC_SHA = init("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f)
+    // @JvmField val TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010)
+    @JvmField val TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011)
+    @JvmField val TLS_DHE_DSS_WITH_DES_CBC_SHA = init("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012)
+    @JvmField val TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = init("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013)
+    @JvmField val TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014)
+    @JvmField val TLS_DHE_RSA_WITH_DES_CBC_SHA = init("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015)
+    @JvmField val TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = init("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016)
+    @JvmField val TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = init("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017)
+    @JvmField val TLS_DH_anon_WITH_RC4_128_MD5 = init("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018)
+    @JvmField val TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019)
+    @JvmField val TLS_DH_anon_WITH_DES_CBC_SHA = init("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a)
+    @JvmField val TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = init("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b)
+    @JvmField val TLS_KRB5_WITH_DES_CBC_SHA = init("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e)
+    @JvmField val TLS_KRB5_WITH_3DES_EDE_CBC_SHA = init("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f)
+    @JvmField val TLS_KRB5_WITH_RC4_128_SHA = init("TLS_KRB5_WITH_RC4_128_SHA", 0x0020)
+    // @JvmField val TLS_KRB5_WITH_IDEA_CBC_SHA = init("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021)
+    @JvmField val TLS_KRB5_WITH_DES_CBC_MD5 = init("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022)
+    @JvmField val TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = init("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023)
+    @JvmField val TLS_KRB5_WITH_RC4_128_MD5 = init("TLS_KRB5_WITH_RC4_128_MD5", 0x0024)
+    // @JvmField val TLS_KRB5_WITH_IDEA_CBC_MD5 = init("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025)
+    @JvmField val TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = init("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026)
+    // @JvmField val TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = init("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027)
+    @JvmField val TLS_KRB5_EXPORT_WITH_RC4_40_SHA = init("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028)
+    @JvmField val TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = init("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029)
+    // @JvmField val TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = init("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a)
+    @JvmField val TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = init("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b)
+    // @JvmField val TLS_PSK_WITH_NULL_SHA = init("TLS_PSK_WITH_NULL_SHA", 0x002c)
+    // @JvmField val TLS_DHE_PSK_WITH_NULL_SHA = init("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d)
+    // @JvmField val TLS_RSA_PSK_WITH_NULL_SHA = init("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e)
+    @JvmField val TLS_RSA_WITH_AES_128_CBC_SHA = init("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f)
+    // @JvmField val TLS_DH_DSS_WITH_AES_128_CBC_SHA = init("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030)
+    // @JvmField val TLS_DH_RSA_WITH_AES_128_CBC_SHA = init("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031)
+    @JvmField val TLS_DHE_DSS_WITH_AES_128_CBC_SHA = init("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032)
+    @JvmField val TLS_DHE_RSA_WITH_AES_128_CBC_SHA = init("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033)
+    @JvmField val TLS_DH_anon_WITH_AES_128_CBC_SHA = init("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034)
+    @JvmField val TLS_RSA_WITH_AES_256_CBC_SHA = init("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035)
+    // @JvmField val TLS_DH_DSS_WITH_AES_256_CBC_SHA = init("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036)
+    // @JvmField val TLS_DH_RSA_WITH_AES_256_CBC_SHA = init("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037)
+    @JvmField val TLS_DHE_DSS_WITH_AES_256_CBC_SHA = init("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038)
+    @JvmField val TLS_DHE_RSA_WITH_AES_256_CBC_SHA = init("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039)
+    @JvmField val TLS_DH_anon_WITH_AES_256_CBC_SHA = init("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a)
+    @JvmField val TLS_RSA_WITH_NULL_SHA256 = init("TLS_RSA_WITH_NULL_SHA256", 0x003b)
+    @JvmField val TLS_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c)
+    @JvmField val TLS_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d)
+    // @JvmField val TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e)
+    // @JvmField val TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f)
+    @JvmField val TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040)
+    @JvmField val TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041)
+    // @JvmField val TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042)
+    // @JvmField val TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043)
+    @JvmField val TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044)
+    @JvmField val TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045)
+    // @JvmField val TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046)
+    @JvmField val TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067)
+    // @JvmField val TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = init("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068)
+    // @JvmField val TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069)
+    @JvmField val TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = init("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a)
+    @JvmField val TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b)
+    @JvmField val TLS_DH_anon_WITH_AES_128_CBC_SHA256 = init("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c)
+    @JvmField val TLS_DH_anon_WITH_AES_256_CBC_SHA256 = init("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d)
+    @JvmField val TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084)
+    // @JvmField val TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085)
+    // @JvmField val TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086)
+    @JvmField val TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087)
+    @JvmField val TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088)
+    // @JvmField val TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089)
+    @JvmField val TLS_PSK_WITH_RC4_128_SHA = init("TLS_PSK_WITH_RC4_128_SHA", 0x008a)
+    @JvmField val TLS_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b)
+    @JvmField val TLS_PSK_WITH_AES_128_CBC_SHA = init("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c)
+    @JvmField val TLS_PSK_WITH_AES_256_CBC_SHA = init("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d)
+    // @JvmField val TLS_DHE_PSK_WITH_RC4_128_SHA = init("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e)
+    // @JvmField val TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f)
+    // @JvmField val TLS_DHE_PSK_WITH_AES_128_CBC_SHA = init("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090)
+    // @JvmField val TLS_DHE_PSK_WITH_AES_256_CBC_SHA = init("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091)
+    // @JvmField val TLS_RSA_PSK_WITH_RC4_128_SHA = init("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092)
+    // @JvmField val TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093)
+    // @JvmField val TLS_RSA_PSK_WITH_AES_128_CBC_SHA = init("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094)
+    // @JvmField val TLS_RSA_PSK_WITH_AES_256_CBC_SHA = init("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095)
+    @JvmField val TLS_RSA_WITH_SEED_CBC_SHA = init("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096)
+    // @JvmField val TLS_DH_DSS_WITH_SEED_CBC_SHA = init("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097)
+    // @JvmField val TLS_DH_RSA_WITH_SEED_CBC_SHA = init("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098)
+    // @JvmField val TLS_DHE_DSS_WITH_SEED_CBC_SHA = init("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099)
+    // @JvmField val TLS_DHE_RSA_WITH_SEED_CBC_SHA = init("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a)
+    // @JvmField val TLS_DH_anon_WITH_SEED_CBC_SHA = init("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b)
+    @JvmField val TLS_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c)
+    @JvmField val TLS_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d)
+    @JvmField val TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e)
+    @JvmField val TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f)
+    // @JvmField val TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0)
+    // @JvmField val TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1)
+    @JvmField val TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2)
+    @JvmField val TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3)
+    // @JvmField val TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4)
+    // @JvmField val TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5)
+    @JvmField val TLS_DH_anon_WITH_AES_128_GCM_SHA256 = init("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6)
+    @JvmField val TLS_DH_anon_WITH_AES_256_GCM_SHA384 = init("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7)
+    // @JvmField val TLS_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8)
+    // @JvmField val TLS_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9)
+    // @JvmField val TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa)
+    // @JvmField val TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab)
+    // @JvmField val TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac)
+    // @JvmField val TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad)
+    // @JvmField val TLS_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae)
+    // @JvmField val TLS_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af)
+    // @JvmField val TLS_PSK_WITH_NULL_SHA256 = init("TLS_PSK_WITH_NULL_SHA256", 0x00b0)
+    // @JvmField val TLS_PSK_WITH_NULL_SHA384 = init("TLS_PSK_WITH_NULL_SHA384", 0x00b1)
+    // @JvmField val TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2)
+    // @JvmField val TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3)
+    // @JvmField val TLS_DHE_PSK_WITH_NULL_SHA256 = init("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4)
+    // @JvmField val TLS_DHE_PSK_WITH_NULL_SHA384 = init("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5)
+    // @JvmField val TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6)
+    // @JvmField val TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7)
+    // @JvmField val TLS_RSA_PSK_WITH_NULL_SHA256 = init("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8)
+    // @JvmField val TLS_RSA_PSK_WITH_NULL_SHA384 = init("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9)
+    // @JvmField val TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba)
+    // @JvmField val TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb)
+    // @JvmField val TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc)
+    // @JvmField val TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd)
+    // @JvmField val TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be)
+    // @JvmField val TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf)
+    // @JvmField val TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0)
+    // @JvmField val TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1)
+    // @JvmField val TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2)
+    // @JvmField val TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3)
+    // @JvmField val TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4)
+    // @JvmField val TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5)
+    @JvmField val TLS_EMPTY_RENEGOTIATION_INFO_SCSV = init("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff)
+    @JvmField val TLS_FALLBACK_SCSV = init("TLS_FALLBACK_SCSV", 0x5600)
+    @JvmField val TLS_ECDH_ECDSA_WITH_NULL_SHA = init("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001)
+    @JvmField val TLS_ECDH_ECDSA_WITH_RC4_128_SHA = init("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002)
+    @JvmField val TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003)
+    @JvmField val TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004)
+    @JvmField val TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_NULL_SHA = init("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = init("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a)
+    @JvmField val TLS_ECDH_RSA_WITH_NULL_SHA = init("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b)
+    @JvmField val TLS_ECDH_RSA_WITH_RC4_128_SHA = init("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c)
+    @JvmField val TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d)
+    @JvmField val TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = init("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e)
+    @JvmField val TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = init("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f)
+    @JvmField val TLS_ECDHE_RSA_WITH_NULL_SHA = init("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010)
+    @JvmField val TLS_ECDHE_RSA_WITH_RC4_128_SHA = init("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011)
+    @JvmField val TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012)
+    @JvmField val TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013)
+    @JvmField val TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014)
+    @JvmField val TLS_ECDH_anon_WITH_NULL_SHA = init("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015)
+    @JvmField val TLS_ECDH_anon_WITH_RC4_128_SHA = init("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016)
+    @JvmField val TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017)
+    @JvmField val TLS_ECDH_anon_WITH_AES_128_CBC_SHA = init("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018)
+    @JvmField val TLS_ECDH_anon_WITH_AES_256_CBC_SHA = init("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019)
+    // @JvmField val TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a)
+    // @JvmField val TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b)
+    // @JvmField val TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c)
+    // @JvmField val TLS_SRP_SHA_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d)
+    // @JvmField val TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e)
+    // @JvmField val TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f)
+    // @JvmField val TLS_SRP_SHA_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020)
+    // @JvmField val TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021)
+    // @JvmField val TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024)
+    @JvmField val TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025)
+    @JvmField val TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026)
+    @JvmField val TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027)
+    @JvmField val TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028)
+    @JvmField val TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029)
+    @JvmField val TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c)
+    @JvmField val TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d)
+    @JvmField val TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e)
+    @JvmField val TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f)
+    @JvmField val TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030)
+    @JvmField val TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031)
+    @JvmField val TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032)
+    // @JvmField val TLS_ECDHE_PSK_WITH_RC4_128_SHA = init("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033)
+    // @JvmField val TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034)
+    @JvmField val TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035)
+    @JvmField val TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036)
+    // @JvmField val TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037)
+    // @JvmField val TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038)
+    // @JvmField val TLS_ECDHE_PSK_WITH_NULL_SHA = init("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039)
+    // @JvmField val TLS_ECDHE_PSK_WITH_NULL_SHA256 = init("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a)
+    // @JvmField val TLS_ECDHE_PSK_WITH_NULL_SHA384 = init("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b)
+    // @JvmField val TLS_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c)
+    // @JvmField val TLS_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d)
+    // @JvmField val TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e)
+    // @JvmField val TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f)
+    // @JvmField val TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040)
+    // @JvmField val TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041)
+    // @JvmField val TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042)
+    // @JvmField val TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043)
+    // @JvmField val TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044)
+    // @JvmField val TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045)
+    // @JvmField val TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046)
+    // @JvmField val TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049)
+    // @JvmField val TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a)
+    // @JvmField val TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b)
+    // @JvmField val TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c)
+    // @JvmField val TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d)
+    // @JvmField val TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e)
+    // @JvmField val TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f)
+    // @JvmField val TLS_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050)
+    // @JvmField val TLS_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051)
+    // @JvmField val TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052)
+    // @JvmField val TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053)
+    // @JvmField val TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054)
+    // @JvmField val TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055)
+    // @JvmField val TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056)
+    // @JvmField val TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057)
+    // @JvmField val TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058)
+    // @JvmField val TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059)
+    // @JvmField val TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a)
+    // @JvmField val TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d)
+    // @JvmField val TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e)
+    // @JvmField val TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f)
+    // @JvmField val TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060)
+    // @JvmField val TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061)
+    // @JvmField val TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062)
+    // @JvmField val TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063)
+    // @JvmField val TLS_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064)
+    // @JvmField val TLS_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065)
+    // @JvmField val TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066)
+    // @JvmField val TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067)
+    // @JvmField val TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068)
+    // @JvmField val TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069)
+    // @JvmField val TLS_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a)
+    // @JvmField val TLS_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b)
+    // @JvmField val TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c)
+    // @JvmField val TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d)
+    // @JvmField val TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e)
+    // @JvmField val TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f)
+    // @JvmField val TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070)
+    // @JvmField val TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073)
+    // @JvmField val TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074)
+    // @JvmField val TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075)
+    // @JvmField val TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076)
+    // @JvmField val TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077)
+    // @JvmField val TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078)
+    // @JvmField val TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079)
+    // @JvmField val TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a)
+    // @JvmField val TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b)
+    // @JvmField val TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c)
+    // @JvmField val TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d)
+    // @JvmField val TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e)
+    // @JvmField val TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f)
+    // @JvmField val TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080)
+    // @JvmField val TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081)
+    // @JvmField val TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082)
+    // @JvmField val TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083)
+    // @JvmField val TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084)
+    // @JvmField val TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087)
+    // @JvmField val TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088)
+    // @JvmField val TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089)
+    // @JvmField val TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a)
+    // @JvmField val TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b)
+    // @JvmField val TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c)
+    // @JvmField val TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d)
+    // @JvmField val TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e)
+    // @JvmField val TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f)
+    // @JvmField val TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090)
+    // @JvmField val TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091)
+    // @JvmField val TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092)
+    // @JvmField val TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093)
+    // @JvmField val TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094)
+    // @JvmField val TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095)
+    // @JvmField val TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096)
+    // @JvmField val TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097)
+    // @JvmField val TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098)
+    // @JvmField val TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099)
+    // @JvmField val TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a)
+    // @JvmField val TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b)
+    // @JvmField val TLS_RSA_WITH_AES_128_CCM = init("TLS_RSA_WITH_AES_128_CCM", 0xc09c)
+    // @JvmField val TLS_RSA_WITH_AES_256_CCM = init("TLS_RSA_WITH_AES_256_CCM", 0xc09d)
+    // @JvmField val TLS_DHE_RSA_WITH_AES_128_CCM = init("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e)
+    // @JvmField val TLS_DHE_RSA_WITH_AES_256_CCM = init("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f)
+    // @JvmField val TLS_RSA_WITH_AES_128_CCM_8 = init("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0)
+    // @JvmField val TLS_RSA_WITH_AES_256_CCM_8 = init("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1)
+    // @JvmField val TLS_DHE_RSA_WITH_AES_128_CCM_8 = init("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2)
+    // @JvmField val TLS_DHE_RSA_WITH_AES_256_CCM_8 = init("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3)
+    // @JvmField val TLS_PSK_WITH_AES_128_CCM = init("TLS_PSK_WITH_AES_128_CCM", 0xc0a4)
+    // @JvmField val TLS_PSK_WITH_AES_256_CCM = init("TLS_PSK_WITH_AES_256_CCM", 0xc0a5)
+    // @JvmField val TLS_DHE_PSK_WITH_AES_128_CCM = init("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6)
+    // @JvmField val TLS_DHE_PSK_WITH_AES_256_CCM = init("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7)
+    // @JvmField val TLS_PSK_WITH_AES_128_CCM_8 = init("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8)
+    // @JvmField val TLS_PSK_WITH_AES_256_CCM_8 = init("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9)
+    // @JvmField val TLS_PSK_DHE_WITH_AES_128_CCM_8 = init("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa)
+    // @JvmField val TLS_PSK_DHE_WITH_AES_256_CCM_8 = init("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_AES_128_CCM = init("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_AES_256_CCM = init("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = init("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = init("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af)
+    @JvmField val TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9)
+    @JvmField val TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa)
+    // @JvmField val TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccab)
+    @JvmField val TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac)
+    // @JvmField val TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccad)
+    // @JvmField val TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccae)
+
+    // TLS 1.3 https://tools.ietf.org/html/rfc8446
+    @JvmField val TLS_AES_128_GCM_SHA256 = init("TLS_AES_128_GCM_SHA256", 0x1301)
+    @JvmField val TLS_AES_256_GCM_SHA384 = init("TLS_AES_256_GCM_SHA384", 0x1302)
+    @JvmField val TLS_CHACHA20_POLY1305_SHA256 = init("TLS_CHACHA20_POLY1305_SHA256", 0x1303)
+    @JvmField val TLS_AES_128_CCM_SHA256 = init("TLS_AES_128_CCM_SHA256", 0x1304)
+    @JvmField val TLS_AES_128_CCM_8_SHA256 = init("TLS_AES_128_CCM_8_SHA256", 0x1305)
+
+    /**
+     * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA
+     *     name for older cipher suites because the prefix is `SSL_` instead of `TLS_`.
+     */
+    @JvmStatic
+    @Synchronized fun forJavaName(javaName: String): CipherSuite {
+      var result: CipherSuite? = INSTANCES[javaName]
+      if (result == null) {
+        result = INSTANCES[secondaryName(javaName)]
+
+        if (result == null) {
+          result = CipherSuite(javaName)
+        }
+
+        // Add the new cipher suite, or a confirmed alias.
+        INSTANCES[javaName] = result
+      }
+      return result
+    }
+
+    private fun secondaryName(javaName: String): String {
+      return when {
+        javaName.startsWith("TLS_") -> "SSL_" + javaName.substring(4)
+        javaName.startsWith("SSL_") -> "TLS_" + javaName.substring(4)
+        else -> javaName
+      }
+    }
+
+    /**
+     * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA
+     *     name for older cipher suites because the prefix is `SSL_` instead of `TLS_`.
+     * @param value the integer identifier for this cipher suite. (Documentation only.)
+     */
+    private fun init(javaName: String, value: Int): CipherSuite {
+      val suite = CipherSuite(javaName)
+      INSTANCES[javaName] = suite
+      return suite
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Connection.java b/okhttp/src/main/java/okhttp3/Connection.java
deleted file mode 100644
index cb6d70996d..0000000000
--- a/okhttp/src/main/java/okhttp3/Connection.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3;
-
-import java.net.Socket;
-import javax.annotation.Nullable;
-
-/**
- * The sockets and streams of an HTTP, HTTPS, or HTTPS+HTTP/2 connection. May be used for multiple
- * HTTP request/response exchanges. Connections may be direct to the origin server or via a proxy.
- *
- * <p>Typically instances of this class are created, connected and exercised automatically by the
- * HTTP client. Applications may use this class to monitor HTTP connections as members of a
- * {@linkplain ConnectionPool connection pool}.
- *
- * <p>Do not confuse this class with the misnamed {@code HttpURLConnection}, which isn't so much a
- * connection as a single request/response exchange.
- *
- * <h3>Modern TLS</h3>
- *
- * <p>There are tradeoffs when selecting which options to include when negotiating a secure
- * connection to a remote host. Newer TLS options are quite useful:
- *
- * <ul>
- *     <li>Server Name Indication (SNI) enables one IP address to negotiate secure connections for
- *         multiple domain names.
- *     <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used to
- *         negotiate HTTP/2.
- * </ul>
- *
- * <p>Unfortunately, older HTTPS servers refuse to connect when such options are presented. Rather
- * than avoiding these options entirely, this class allows a connection to be attempted with modern
- * options and then retried without them should the attempt fail.
- *
- * <h3>Connection Reuse</h3>
- *
- * <p>Each connection can carry a varying number of streams, depending on the underlying protocol
- * being used. HTTP/1.x connections can carry either zero or one streams. HTTP/2 connections can
- * carry any number of streams, dynamically configured with {@code SETTINGS_MAX_CONCURRENT_STREAMS}.
- * A connection currently carrying zero streams is an idle stream. We keep it alive because reusing
- * an existing connection is typically faster than establishing a new one.
- *
- * <p>When a single logical call requires multiple streams due to redirects or authorization
- * challenges, we prefer to use the same physical connection for all streams in the sequence. There
- * are potential performance and behavior consequences to this preference. To support this feature,
- * this class separates <i>allocations</i> from <i>streams</i>. An allocation is created by a call,
- * used for one or more streams, and then released. An allocated connection won't be stolen by other
- * calls while a redirect or authorization challenge is being handled.
- *
- * <p>When the maximum concurrent streams limit is reduced, some allocations will be rescinded.
- * Attempting to create new streams on these allocations will fail.
- *
- * <p>Note that an allocation may be released before its stream is completed. This is intended to
- * make bookkeeping easier for the caller: releasing the allocation as soon as the terminal stream
- * has been found. But only complete the stream once its data stream has been exhausted.
- */
-public interface Connection {
-  /** Returns the route used by this connection. */
-  Route route();
-
-  /**
-   * Returns the socket that this connection is using. Returns an {@linkplain
-   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2
-   * connection the socket may be shared by multiple concurrent calls.
-   */
-  Socket socket();
-
-  /**
-   * Returns the TLS handshake used to establish this connection, or null if the connection is not
-   * HTTPS.
-   */
-  @Nullable Handshake handshake();
-
-  /**
-   * Returns the protocol negotiated by this connection, or {@link Protocol#HTTP_1_1} if no protocol
-   * has been negotiated. This method returns {@link Protocol#HTTP_1_1} even if the remote peer is
-   * using {@link Protocol#HTTP_1_0}.
-   */
-  Protocol protocol();
-}
diff --git a/okhttp/src/main/java/okhttp3/Connection.kt b/okhttp/src/main/java/okhttp3/Connection.kt
new file mode 100644
index 0000000000..20dda3de9d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Connection.kt
@@ -0,0 +1,92 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3
+
+import java.net.Socket
+
+/**
+ * The sockets and streams of an HTTP, HTTPS, or HTTPS+HTTP/2 connection. May be used for multiple
+ * HTTP request/response exchanges. Connections may be direct to the origin server or via a proxy.
+ *
+ * Typically instances of this class are created, connected and exercised automatically by the HTTP
+ * client. Applications may use this class to monitor HTTP connections as members of a
+ * [connection pool][ConnectionPool].
+ *
+ * Do not confuse this class with the misnamed `HttpURLConnection`, which isn't so much a connection
+ * as a single request/response exchange.
+ *
+ * ## Modern TLS
+ *
+ * There are trade-offs when selecting which options to include when negotiating a secure connection
+ * to a remote host. Newer TLS options are quite useful:
+ *
+ *  * Server Name Indication (SNI) enables one IP address to negotiate secure connections for
+ *    multiple domain names.
+ *
+ *  * Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used to
+ *    negotiate HTTP/2.
+ *
+ * Unfortunately, older HTTPS servers refuse to connect when such options are presented. Rather than
+ * avoiding these options entirely, this class allows a connection to be attempted with modern
+ * options and then retried without them should the attempt fail.
+ *
+ * ## Connection Reuse
+ *
+ * Each connection can carry a varying number of streams, depending on the underlying protocol being
+ * used. HTTP/1.x connections can carry either zero or one streams. HTTP/2 connections can carry any
+ * number of streams, dynamically configured with `SETTINGS_MAX_CONCURRENT_STREAMS`. A connection
+ * currently carrying zero streams is an idle stream. We keep it alive because reusing an existing
+ * connection is typically faster than establishing a new one.
+ *
+ * When a single logical call requires multiple streams due to redirects or authorization
+ * challenges, we prefer to use the same physical connection for all streams in the sequence. There
+ * are potential performance and behavior consequences to this preference. To support this feature,
+ * this class separates _allocations_ from _streams_. An allocation is created by a call, used for
+ * one or more streams, and then released. An allocated connection won't be stolen by other calls
+ * while a redirect or authorization challenge is being handled.
+ *
+ * When the maximum concurrent streams limit is reduced, some allocations will be rescinded.
+ * Attempting to create new streams on these allocations will fail.
+ *
+ * Note that an allocation may be released before its stream is completed. This is intended to make
+ * bookkeeping easier for the caller: releasing the allocation as soon as the terminal stream has
+ * been found. But only complete the stream once its data stream has been exhausted.
+ */
+interface Connection {
+  /** Returns the route used by this connection. */
+  fun route(): Route
+
+  /**
+   * Returns the socket that this connection is using. Returns an
+   * [SSL socket][javax.net.ssl.SSLSocket] if this connection is HTTPS. If this is an HTTP/2
+   * connection the socket may be shared by multiple concurrent calls.
+   */
+  fun socket(): Socket
+
+  /**
+   * Returns the TLS handshake used to establish this connection, or null if the connection is not
+   * HTTPS.
+   */
+  fun handshake(): Handshake?
+
+  /**
+   * Returns the protocol negotiated by this connection, or [Protocol.HTTP_1_1] if no protocol
+   * has been negotiated. This method returns [Protocol.HTTP_1_1] even if the remote peer is using
+   * [Protocol.HTTP_1_0].
+   */
+  fun protocol(): Protocol
+}
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
deleted file mode 100644
index 2c0c6fffbd..0000000000
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ /dev/null
@@ -1,277 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3;
-
-import java.lang.ref.Reference;
-import java.net.Socket;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Deque;
-import java.util.Iterator;
-import java.util.List;
-import java.util.concurrent.Executor;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.connection.RouteDatabase;
-import okhttp3.internal.connection.StreamAllocation;
-import okhttp3.internal.platform.Platform;
-
-import static okhttp3.internal.Util.closeQuietly;
-
-/**
- * Manages reuse of HTTP and HTTP/2 connections for reduced network latency. HTTP requests that
- * share the same {@link Address} may share a {@link Connection}. This class implements the policy
- * of which connections to keep open for future use.
- */
-public final class ConnectionPool {
-  /**
-   * Background threads are used to cleanup expired connections. There will be at most a single
-   * thread running per connection pool. The thread pool executor permits the pool itself to be
-   * garbage collected.
-   */
-  private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,
-      Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
-      new SynchronousQueue<>(), Util.threadFactory("OkHttp ConnectionPool", true));
-
-  /** The maximum number of idle connections for each address. */
-  private final int maxIdleConnections;
-  private final long keepAliveDurationNs;
-  private final Runnable cleanupRunnable = () -> {
-    while (true) {
-      long waitNanos = cleanup(System.nanoTime());
-      if (waitNanos == -1) return;
-      if (waitNanos > 0) {
-        long waitMillis = waitNanos / 1000000L;
-        waitNanos -= (waitMillis * 1000000L);
-        synchronized (ConnectionPool.this) {
-          try {
-            ConnectionPool.this.wait(waitMillis, (int) waitNanos);
-          } catch (InterruptedException ignored) {
-          }
-        }
-      }
-    }
-  };
-
-  private final Deque<RealConnection> connections = new ArrayDeque<>();
-  final RouteDatabase routeDatabase = new RouteDatabase();
-  boolean cleanupRunning;
-
-  /**
-   * Create a new connection pool with tuning parameters appropriate for a single-user application.
-   * The tuning parameters in this pool are subject to change in future OkHttp releases. Currently
-   * this pool holds up to 5 idle connections which will be evicted after 5 minutes of inactivity.
-   */
-  public ConnectionPool() {
-    this(5, 5, TimeUnit.MINUTES);
-  }
-
-  public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) {
-    this.maxIdleConnections = maxIdleConnections;
-    this.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);
-
-    // Put a floor on the keep alive duration, otherwise cleanup will spin loop.
-    if (keepAliveDuration <= 0) {
-      throw new IllegalArgumentException("keepAliveDuration <= 0: " + keepAliveDuration);
-    }
-  }
-
-  /** Returns the number of idle connections in the pool. */
-  public synchronized int idleConnectionCount() {
-    int total = 0;
-    for (RealConnection connection : connections) {
-      if (connection.allocations.isEmpty()) total++;
-    }
-    return total;
-  }
-
-  /** Returns total number of connections in the pool. */
-  public synchronized int connectionCount() {
-    return connections.size();
-  }
-
-  /**
-   * Acquires a recycled connection to {@code address} for {@code streamAllocation}. If non-null
-   * {@code route} is the resolved route for a connection.
-   */
-  void acquire(Address address, StreamAllocation streamAllocation, @Nullable Route route) {
-    assert (Thread.holdsLock(this));
-    for (RealConnection connection : connections) {
-      if (connection.isEligible(address, route)) {
-        streamAllocation.acquire(connection, true);
-        return;
-      }
-    }
-  }
-
-  /**
-   * Replaces the connection held by {@code streamAllocation} with a shared connection if possible.
-   * This recovers when multiple multiplexed connections are created concurrently.
-   */
-  @Nullable Socket deduplicate(Address address, StreamAllocation streamAllocation) {
-    assert (Thread.holdsLock(this));
-    for (RealConnection connection : connections) {
-      if (connection.isEligible(address, null)
-          && connection.isMultiplexed()
-          && connection != streamAllocation.connection()) {
-        return streamAllocation.releaseAndAcquire(connection);
-      }
-    }
-    return null;
-  }
-
-  void put(RealConnection connection) {
-    assert (Thread.holdsLock(this));
-    if (!cleanupRunning) {
-      cleanupRunning = true;
-      executor.execute(cleanupRunnable);
-    }
-    connections.add(connection);
-  }
-
-  /**
-   * Notify this pool that {@code connection} has become idle. Returns true if the connection has
-   * been removed from the pool and should be closed.
-   */
-  boolean connectionBecameIdle(RealConnection connection) {
-    assert (Thread.holdsLock(this));
-    if (connection.noNewStreams || maxIdleConnections == 0) {
-      connections.remove(connection);
-      return true;
-    } else {
-      notifyAll(); // Awake the cleanup thread: we may have exceeded the idle connection limit.
-      return false;
-    }
-  }
-
-  /** Close and remove all idle connections in the pool. */
-  public void evictAll() {
-    List<RealConnection> evictedConnections = new ArrayList<>();
-    synchronized (this) {
-      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
-        RealConnection connection = i.next();
-        if (connection.allocations.isEmpty()) {
-          connection.noNewStreams = true;
-          evictedConnections.add(connection);
-          i.remove();
-        }
-      }
-    }
-
-    for (RealConnection connection : evictedConnections) {
-      closeQuietly(connection.socket());
-    }
-  }
-
-  /**
-   * Performs maintenance on this pool, evicting the connection that has been idle the longest if
-   * either it has exceeded the keep alive limit or the idle connections limit.
-   *
-   * <p>Returns the duration in nanos to sleep until the next scheduled call to this method. Returns
-   * -1 if no further cleanups are required.
-   */
-  long cleanup(long now) {
-    int inUseConnectionCount = 0;
-    int idleConnectionCount = 0;
-    RealConnection longestIdleConnection = null;
-    long longestIdleDurationNs = Long.MIN_VALUE;
-
-    // Find either a connection to evict, or the time that the next eviction is due.
-    synchronized (this) {
-      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
-        RealConnection connection = i.next();
-
-        // If the connection is in use, keep searching.
-        if (pruneAndGetAllocationCount(connection, now) > 0) {
-          inUseConnectionCount++;
-          continue;
-        }
-
-        idleConnectionCount++;
-
-        // If the connection is ready to be evicted, we're done.
-        long idleDurationNs = now - connection.idleAtNanos;
-        if (idleDurationNs > longestIdleDurationNs) {
-          longestIdleDurationNs = idleDurationNs;
-          longestIdleConnection = connection;
-        }
-      }
-
-      if (longestIdleDurationNs >= this.keepAliveDurationNs
-          || idleConnectionCount > this.maxIdleConnections) {
-        // We've found a connection to evict. Remove it from the list, then close it below (outside
-        // of the synchronized block).
-        connections.remove(longestIdleConnection);
-      } else if (idleConnectionCount > 0) {
-        // A connection will be ready to evict soon.
-        return keepAliveDurationNs - longestIdleDurationNs;
-      } else if (inUseConnectionCount > 0) {
-        // All connections are in use. It'll be at least the keep alive duration 'til we run again.
-        return keepAliveDurationNs;
-      } else {
-        // No connections, idle or in use.
-        cleanupRunning = false;
-        return -1;
-      }
-    }
-
-    closeQuietly(longestIdleConnection.socket());
-
-    // Cleanup again immediately.
-    return 0;
-  }
-
-  /**
-   * Prunes any leaked allocations and then returns the number of remaining live allocations on
-   * {@code connection}. Allocations are leaked if the connection is tracking them but the
-   * application code has abandoned them. Leak detection is imprecise and relies on garbage
-   * collection.
-   */
-  private int pruneAndGetAllocationCount(RealConnection connection, long now) {
-    List<Reference<StreamAllocation>> references = connection.allocations;
-    for (int i = 0; i < references.size(); ) {
-      Reference<StreamAllocation> reference = references.get(i);
-
-      if (reference.get() != null) {
-        i++;
-        continue;
-      }
-
-      // We've discovered a leaked allocation. This is an application bug.
-      StreamAllocation.StreamAllocationReference streamAllocRef =
-          (StreamAllocation.StreamAllocationReference) reference;
-      String message = "A connection to " + connection.route().address().url()
-          + " was leaked. Did you forget to close a response body?";
-      Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);
-
-      references.remove(i);
-      connection.noNewStreams = true;
-
-      // If this was the last allocation, the connection is eligible for immediate eviction.
-      if (references.isEmpty()) {
-        connection.idleAtNanos = now - keepAliveDurationNs;
-        return 0;
-      }
-    }
-
-    return references.size();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.kt b/okhttp/src/main/java/okhttp3/ConnectionPool.kt
new file mode 100644
index 0000000000..0a85d80849
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.kt
@@ -0,0 +1,53 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.connection.RealConnectionPool
+import java.util.concurrent.TimeUnit
+
+/**
+ * Manages reuse of HTTP and HTTP/2 connections for reduced network latency. HTTP requests that
+ * share the same [Address] may share a [Connection]. This class implements the policy
+ * of which connections to keep open for future use.
+ *
+ * @constructor Create a new connection pool with tuning parameters appropriate for a single-user
+ * application. The tuning parameters in this pool are subject to change in future OkHttp releases.
+ * Currently this pool holds up to 5 idle connections which will be evicted after 5 minutes of
+ * inactivity.
+ */
+class ConnectionPool(
+  maxIdleConnections: Int,
+  keepAliveDuration: Long,
+  timeUnit: TimeUnit
+) {
+  // TODO(kotlin): remove @JvmField once OkHttpClient is in Kotlin
+  @JvmField internal val delegate =
+      RealConnectionPool(maxIdleConnections, keepAliveDuration, timeUnit)
+
+  constructor() : this(5, 5, TimeUnit.MINUTES)
+
+  /** Returns the number of idle connections in the pool.  */
+  fun idleConnectionCount(): Int = delegate.idleConnectionCount()
+
+  /** Returns total number of connections in the pool.  */
+  fun connectionCount(): Int = delegate.connectionCount()
+
+  /** Close and remove all idle connections in the pool.  */
+  fun evictAll() {
+    delegate.evictAll()
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
deleted file mode 100644
index 83efef4839..0000000000
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ /dev/null
@@ -1,358 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.Arrays;
-import java.util.List;
-import java.util.Objects;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLSocket;
-import okhttp3.internal.Util;
-
-import static okhttp3.internal.Util.concat;
-import static okhttp3.internal.Util.indexOf;
-import static okhttp3.internal.Util.intersect;
-import static okhttp3.internal.Util.nonEmptyIntersection;
-
-/**
- * Specifies configuration for the socket connection that HTTP traffic travels through. For {@code
- * https:} URLs, this includes the TLS version and cipher suites to use when negotiating a secure
- * connection.
- *
- * <p>The TLS versions configured in a connection spec are only be used if they are also enabled in
- * the SSL socket. For example, if an SSL socket does not have TLS 1.3 enabled, it will not be used
- * even if it is present on the connection spec. The same policy also applies to cipher suites.
- *
- * <p>Use {@link Builder#allEnabledTlsVersions()} and {@link Builder#allEnabledCipherSuites} to
- * defer all feature selection to the underlying SSL socket.
- *
- * <p>The configuration of each spec changes with each OkHttp release. This is annoying: upgrading
- * your OkHttp library can break connectivity to certain web servers! But its a necessary annoyance
- * because the TLS ecosystem is dynamic and staying up to date is necessary to stay secure. See
- * <a href="https://github.com/square/okhttp/wiki/TLS-Configuration-History">OkHttp's TLS
- * Configuration History</a> to track these changes.
- */
-public final class ConnectionSpec {
-
-  // Most secure but generally supported list.
-  private static final CipherSuite[] RESTRICTED_CIPHER_SUITES = new CipherSuite[] {
-      // TLSv1.3
-      CipherSuite.TLS_AES_128_GCM_SHA256,
-      CipherSuite.TLS_AES_256_GCM_SHA384,
-      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
-      CipherSuite.TLS_AES_128_CCM_SHA256,
-      CipherSuite.TLS_AES_256_CCM_8_SHA256,
-
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
-  };
-
-  // This is nearly equal to the cipher suites supported in Chrome 51, current as of 2016-05-25.
-  // All of these suites are available on Android 7.0; earlier releases support a subset of these
-  // suites. https://github.com/square/okhttp/issues/1972
-  private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
-      // TLSv1.3
-      CipherSuite.TLS_AES_128_GCM_SHA256,
-      CipherSuite.TLS_AES_256_GCM_SHA384,
-      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
-      CipherSuite.TLS_AES_128_CCM_SHA256,
-      CipherSuite.TLS_AES_256_CCM_8_SHA256,
-
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
-
-      // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
-      // continue to include them until better suites are commonly available. For example, none
-      // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
-      CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
-      CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
-  };
-
-  /** A secure TLS connection that requires a recent client platform and a recent server. */
-  public static final ConnectionSpec RESTRICTED_TLS = new Builder(true)
-      .cipherSuites(RESTRICTED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
-      .supportsTlsExtensions(true)
-      .build();
-
-  /**
-   * A modern TLS configuration that works on most client platforms and can connect to most servers.
-   * This is OkHttp's default configuration.
-   */
-  public static final ConnectionSpec MODERN_TLS = new Builder(true)
-      .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
-      .supportsTlsExtensions(true)
-      .build();
-
-  /**
-   * A backwards-compatible fallback configuration that works on obsolete client platforms and can
-   * connect to obsolete servers. When possible, prefer to upgrade your client platform or server
-   * rather than using this configuration.
-   */
-  public static final ConnectionSpec COMPATIBLE_TLS = new Builder(true)
-      .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
-      .supportsTlsExtensions(true)
-      .build();
-
-  /** Unencrypted, unauthenticated connections for {@code http:} URLs. */
-  public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
-
-  final boolean tls;
-  final boolean supportsTlsExtensions;
-  final @Nullable String[] cipherSuites;
-  final @Nullable String[] tlsVersions;
-
-  ConnectionSpec(Builder builder) {
-    this.tls = builder.tls;
-    this.cipherSuites = builder.cipherSuites;
-    this.tlsVersions = builder.tlsVersions;
-    this.supportsTlsExtensions = builder.supportsTlsExtensions;
-  }
-
-  public boolean isTls() {
-    return tls;
-  }
-
-  /**
-   * Returns the cipher suites to use for a connection. Returns null if all of the SSL socket's
-   * enabled cipher suites should be used.
-   */
-  public @Nullable List<CipherSuite> cipherSuites() {
-    return cipherSuites != null ? CipherSuite.forJavaNames(cipherSuites) : null;
-  }
-
-  /**
-   * Returns the TLS versions to use when negotiating a connection. Returns null if all of the SSL
-   * socket's enabled TLS versions should be used.
-   */
-  public @Nullable List<TlsVersion> tlsVersions() {
-    return tlsVersions != null ? TlsVersion.forJavaNames(tlsVersions) : null;
-  }
-
-  public boolean supportsTlsExtensions() {
-    return supportsTlsExtensions;
-  }
-
-  /** Applies this spec to {@code sslSocket}. */
-  void apply(SSLSocket sslSocket, boolean isFallback) {
-    ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);
-
-    if (specToApply.tlsVersions != null) {
-      sslSocket.setEnabledProtocols(specToApply.tlsVersions);
-    }
-    if (specToApply.cipherSuites != null) {
-      sslSocket.setEnabledCipherSuites(specToApply.cipherSuites);
-    }
-  }
-
-  /**
-   * Returns a copy of this that omits cipher suites and TLS versions not enabled by {@code
-   * sslSocket}.
-   */
-  private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
-    String[] cipherSuitesIntersection = cipherSuites != null
-        ? intersect(CipherSuite.ORDER_BY_NAME, sslSocket.getEnabledCipherSuites(), cipherSuites)
-        : sslSocket.getEnabledCipherSuites();
-    String[] tlsVersionsIntersection = tlsVersions != null
-        ? intersect(Util.NATURAL_ORDER, sslSocket.getEnabledProtocols(), tlsVersions)
-        : sslSocket.getEnabledProtocols();
-
-    // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
-    // the SCSV cipher is added to signal that a protocol fallback has taken place.
-    String[] supportedCipherSuites = sslSocket.getSupportedCipherSuites();
-    int indexOfFallbackScsv = indexOf(
-        CipherSuite.ORDER_BY_NAME, supportedCipherSuites, "TLS_FALLBACK_SCSV");
-    if (isFallback && indexOfFallbackScsv != -1) {
-      cipherSuitesIntersection = concat(
-          cipherSuitesIntersection, supportedCipherSuites[indexOfFallbackScsv]);
-    }
-
-    return new Builder(this)
-        .cipherSuites(cipherSuitesIntersection)
-        .tlsVersions(tlsVersionsIntersection)
-        .build();
-  }
-
-  /**
-   * Returns {@code true} if the socket, as currently configured, supports this connection spec. In
-   * order for a socket to be compatible the enabled cipher suites and protocols must intersect.
-   *
-   * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
-   * match the socket's enabled cipher suites. If there are no required cipher suites the socket
-   * must have at least one cipher suite enabled.
-   *
-   * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the
-   * socket's enabled protocols.
-   */
-  public boolean isCompatible(SSLSocket socket) {
-    if (!tls) {
-      return false;
-    }
-
-    if (tlsVersions != null && !nonEmptyIntersection(
-        Util.NATURAL_ORDER, tlsVersions, socket.getEnabledProtocols())) {
-      return false;
-    }
-
-    if (cipherSuites != null && !nonEmptyIntersection(
-        CipherSuite.ORDER_BY_NAME, cipherSuites, socket.getEnabledCipherSuites())) {
-      return false;
-    }
-
-    return true;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    if (!(other instanceof ConnectionSpec)) return false;
-    if (other == this) return true;
-
-    ConnectionSpec that = (ConnectionSpec) other;
-    if (this.tls != that.tls) return false;
-
-    if (tls) {
-      if (!Arrays.equals(this.cipherSuites, that.cipherSuites)) return false;
-      if (!Arrays.equals(this.tlsVersions, that.tlsVersions)) return false;
-      if (this.supportsTlsExtensions != that.supportsTlsExtensions) return false;
-    }
-
-    return true;
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    if (tls) {
-      result = 31 * result + Arrays.hashCode(cipherSuites);
-      result = 31 * result + Arrays.hashCode(tlsVersions);
-      result = 31 * result + (supportsTlsExtensions ? 0 : 1);
-    }
-    return result;
-  }
-
-  @Override public String toString() {
-    if (!tls) {
-      return "ConnectionSpec()";
-    }
-
-    return "ConnectionSpec("
-        + "cipherSuites=" + Objects.toString(cipherSuites(), "[all enabled]")
-        + ", tlsVersions=" + Objects.toString(tlsVersions(), "[all enabled]")
-        + ", supportsTlsExtensions=" + supportsTlsExtensions
-        + ")";
-  }
-
-  public static final class Builder {
-    boolean tls;
-    @Nullable String[] cipherSuites;
-    @Nullable String[] tlsVersions;
-    boolean supportsTlsExtensions;
-
-    Builder(boolean tls) {
-      this.tls = tls;
-    }
-
-    public Builder(ConnectionSpec connectionSpec) {
-      this.tls = connectionSpec.tls;
-      this.cipherSuites = connectionSpec.cipherSuites;
-      this.tlsVersions = connectionSpec.tlsVersions;
-      this.supportsTlsExtensions = connectionSpec.supportsTlsExtensions;
-    }
-
-    public Builder allEnabledCipherSuites() {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
-      this.cipherSuites = null;
-      return this;
-    }
-
-    public Builder cipherSuites(CipherSuite... cipherSuites) {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
-
-      String[] strings = new String[cipherSuites.length];
-      for (int i = 0; i < cipherSuites.length; i++) {
-        strings[i] = cipherSuites[i].javaName;
-      }
-      return cipherSuites(strings);
-    }
-
-    public Builder cipherSuites(String... cipherSuites) {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
-
-      if (cipherSuites.length == 0) {
-        throw new IllegalArgumentException("At least one cipher suite is required");
-      }
-
-      this.cipherSuites = cipherSuites.clone(); // Defensive copy.
-      return this;
-    }
-
-    public Builder allEnabledTlsVersions() {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
-      this.tlsVersions = null;
-      return this;
-    }
-
-    public Builder tlsVersions(TlsVersion... tlsVersions) {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
-
-      String[] strings = new String[tlsVersions.length];
-      for (int i = 0; i < tlsVersions.length; i++) {
-        strings[i] = tlsVersions[i].javaName;
-      }
-
-      return tlsVersions(strings);
-    }
-
-    public Builder tlsVersions(String... tlsVersions) {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
-
-      if (tlsVersions.length == 0) {
-        throw new IllegalArgumentException("At least one TLS version is required");
-      }
-
-      this.tlsVersions = tlsVersions.clone(); // Defensive copy.
-      return this;
-    }
-
-    /**
-     * @deprecated since OkHttp 3.13 all TLS-connections are expected to support TLS extensions.
-     *     In a future release setting this to true will be unnecessary and setting it to false will
-     *     have no effect.
-     */
-    public Builder supportsTlsExtensions(boolean supportsTlsExtensions) {
-      if (!tls) throw new IllegalStateException("no TLS extensions for cleartext connections");
-      this.supportsTlsExtensions = supportsTlsExtensions;
-      return this;
-    }
-
-    public ConnectionSpec build() {
-      return new ConnectionSpec(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.kt b/okhttp/src/main/java/okhttp3/ConnectionSpec.kt
new file mode 100644
index 0000000000..1f8e4816a7
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.kt
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.ConnectionSpec.Builder
+import okhttp3.internal.Util
+import okhttp3.internal.Util.concat
+import okhttp3.internal.Util.indexOf
+import okhttp3.internal.Util.intersect
+import okhttp3.internal.Util.nonEmptyIntersection
+import java.util.Arrays
+import java.util.Objects
+import javax.net.ssl.SSLSocket
+
+/**
+ * Specifies configuration for the socket connection that HTTP traffic travels through. For `https:`
+ * URLs, this includes the TLS version and cipher suites to use when negotiating a secure
+ * connection.
+ *
+ * The TLS versions configured in a connection spec are only be used if they are also enabled in the
+ * SSL socket. For example, if an SSL socket does not have TLS 1.3 enabled, it will not be used even
+ * if it is present on the connection spec. The same policy also applies to cipher suites.
+ *
+ * Use [Builder.allEnabledTlsVersions] and [Builder.allEnabledCipherSuites] to defer all feature
+ * selection to the underlying SSL socket.
+ *
+ * The configuration of each spec changes with each OkHttp release. This is annoying: upgrading
+ * your OkHttp library can break connectivity to certain web servers! But its a necessary annoyance
+ * because the TLS ecosystem is dynamic and staying up to date is necessary to stay secure. See
+ * [OkHttp's TLS Configuration History][tls_history] to track these changes.
+ *
+ * [tls_history]: https://github.com/square/okhttp/wiki/TLS-Configuration-History
+ */
+class ConnectionSpec internal constructor(builder: Builder) {
+  val isTls: Boolean = builder.tls
+  internal val supportsTlsExtensions: Boolean = builder.supportsTlsExtensions
+  internal val cipherSuites: Array<String>? = builder.cipherSuites
+  internal val tlsVersions: Array<String>? = builder.tlsVersions
+
+  /**
+   * Returns the cipher suites to use for a connection. Returns null if all of the SSL socket's
+   * enabled cipher suites should be used.
+   */
+  fun cipherSuites(): List<CipherSuite>? = cipherSuites?.map(CipherSuite.Companion::forJavaName)
+
+  /**
+   * Returns the TLS versions to use when negotiating a connection. Returns null if all of the SSL
+   * socket's enabled TLS versions should be used.
+   */
+  fun tlsVersions(): List<TlsVersion>? = tlsVersions?.map(TlsVersion.Companion::forJavaName)
+
+  fun supportsTlsExtensions(): Boolean = supportsTlsExtensions
+
+  /** Applies this spec to `sslSocket`.  */
+  internal fun apply(sslSocket: SSLSocket, isFallback: Boolean) {
+    val specToApply = supportedSpec(sslSocket, isFallback)
+
+    if (specToApply.tlsVersions != null) {
+      sslSocket.enabledProtocols = specToApply.tlsVersions
+    }
+
+    if (specToApply.cipherSuites != null) {
+      sslSocket.enabledCipherSuites = specToApply.cipherSuites
+    }
+  }
+
+  /**
+   * Returns a copy of this that omits cipher suites and TLS versions not enabled by `sslSocket`.
+   */
+  private fun supportedSpec(sslSocket: SSLSocket, isFallback: Boolean): ConnectionSpec {
+    var cipherSuitesIntersection = if (cipherSuites != null) {
+      intersect(CipherSuite.ORDER_BY_NAME, sslSocket.enabledCipherSuites, cipherSuites)
+    } else {
+      sslSocket.enabledCipherSuites
+    }
+
+    val tlsVersionsIntersection = if (tlsVersions != null) {
+      intersect(Util.NATURAL_ORDER, sslSocket.enabledProtocols, tlsVersions)
+    } else {
+      sslSocket.enabledProtocols
+    }
+
+    // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00 the SCSV
+    // cipher is added to signal that a protocol fallback has taken place.
+    val supportedCipherSuites = sslSocket.supportedCipherSuites
+    val indexOfFallbackScsv = indexOf(
+        CipherSuite.ORDER_BY_NAME, supportedCipherSuites, "TLS_FALLBACK_SCSV")
+    if (isFallback && indexOfFallbackScsv != -1) {
+      cipherSuitesIntersection = concat(
+          cipherSuitesIntersection, supportedCipherSuites[indexOfFallbackScsv])
+    }
+
+    return Builder(this)
+        .cipherSuites(*cipherSuitesIntersection)
+        .tlsVersions(*tlsVersionsIntersection)
+        .build()
+  }
+
+  /**
+   * Returns `true` if the socket, as currently configured, supports this connection spec. In
+   * order for a socket to be compatible the enabled cipher suites and protocols must intersect.
+   *
+   * For cipher suites, at least one of the [required cipher suites][cipherSuites] must match the
+   * socket's enabled cipher suites. If there are no required cipher suites the socket must have at
+   * least one cipher suite enabled.
+   *
+   * For protocols, at least one of the [required protocols][tlsVersions] must match the socket's
+   * enabled protocols.
+   */
+  fun isCompatible(socket: SSLSocket): Boolean {
+    if (!isTls) {
+      return false
+    }
+
+    if (tlsVersions != null &&
+        !nonEmptyIntersection(Util.NATURAL_ORDER, tlsVersions, socket.enabledProtocols)) {
+      return false
+    }
+
+    if (cipherSuites != null &&
+        !nonEmptyIntersection(
+            CipherSuite.ORDER_BY_NAME, cipherSuites, socket.enabledCipherSuites)) {
+      return false
+    }
+
+    return true
+  }
+
+  override fun equals(other: Any?): Boolean {
+    if (other !is ConnectionSpec) return false
+    if (other === this) return true
+
+    val that = other as ConnectionSpec?
+    if (this.isTls != that!!.isTls) return false
+
+    if (isTls) {
+      if (!Arrays.equals(this.cipherSuites, that.cipherSuites)) return false
+      if (!Arrays.equals(this.tlsVersions, that.tlsVersions)) return false
+      if (this.supportsTlsExtensions != that.supportsTlsExtensions) return false
+    }
+
+    return true
+  }
+
+  override fun hashCode(): Int {
+    var result = 17
+    if (isTls) {
+      result = 31 * result + cipherSuites!!.contentHashCode()
+      result = 31 * result + tlsVersions!!.contentHashCode()
+      result = 31 * result + if (supportsTlsExtensions) 0 else 1
+    }
+    return result
+  }
+
+  override fun toString(): String {
+    if (!isTls) return "ConnectionSpec()"
+
+    return ("ConnectionSpec(" +
+        "cipherSuites=${Objects.toString(cipherSuites(), "[all enabled]")}, " +
+        "tlsVersions=${Objects.toString(tlsVersions(), "[all enabled]")}, " +
+        "supportsTlsExtensions=$supportsTlsExtensions)")
+  }
+
+  class Builder {
+    internal var tls: Boolean = false
+    internal var cipherSuites: Array<String>? = null
+    internal var tlsVersions: Array<String>? = null
+    internal var supportsTlsExtensions: Boolean = false
+
+    internal constructor(tls: Boolean) {
+      this.tls = tls
+    }
+
+    constructor(connectionSpec: ConnectionSpec) {
+      this.tls = connectionSpec.isTls
+      this.cipherSuites = connectionSpec.cipherSuites
+      this.tlsVersions = connectionSpec.tlsVersions
+      this.supportsTlsExtensions = connectionSpec.supportsTlsExtensions
+    }
+
+    fun allEnabledCipherSuites() = apply {
+      require(tls) { "no cipher suites for cleartext connections" }
+      this.cipherSuites = null
+    }
+
+    fun cipherSuites(vararg cipherSuites: CipherSuite): Builder = apply {
+      require(tls) { "no cipher suites for cleartext connections" }
+      val strings = cipherSuites.map(CipherSuite::javaName).toTypedArray()
+      return cipherSuites(*strings)
+    }
+
+    fun cipherSuites(vararg cipherSuites: String) = apply {
+      require(tls) { "no cipher suites for cleartext connections" }
+      require(cipherSuites.isNotEmpty()) { "At least one cipher suite is required" }
+
+      this.cipherSuites = cipherSuites.clone() as Array<String> // Defensive copy.
+    }
+
+    fun allEnabledTlsVersions() = apply {
+      require(tls) { "no TLS versions for cleartext connections" }
+      this.tlsVersions = null
+    }
+
+    fun tlsVersions(vararg tlsVersions: TlsVersion): Builder = apply {
+      require(tls) { "no TLS versions for cleartext connections" }
+
+      val strings = tlsVersions.map(TlsVersion::javaName).toTypedArray()
+      return tlsVersions(*strings)
+    }
+
+    fun tlsVersions(vararg tlsVersions: String) = apply {
+      require(tls) { "no TLS versions for cleartext connections" }
+      require(tlsVersions.isNotEmpty()) { "At least one TLS version is required" }
+
+      this.tlsVersions = tlsVersions.clone() as Array<String> // Defensive copy.
+    }
+
+    @Deprecated("since OkHttp 3.13 all TLS-connections are expected to support TLS extensions.\n" +
+        "In a future release setting this to true will be unnecessary and setting it to false\n" +
+        "will have no effect.")
+    fun supportsTlsExtensions(supportsTlsExtensions: Boolean) = apply {
+      require(tls) { "no TLS extensions for cleartext connections" }
+      this.supportsTlsExtensions = supportsTlsExtensions
+    }
+
+    fun build(): ConnectionSpec = ConnectionSpec(this)
+  }
+
+  companion object {
+    // Most secure but generally supported list.
+    private val RESTRICTED_CIPHER_SUITES = arrayOf(
+        // TLSv1.3.
+        CipherSuite.TLS_AES_128_GCM_SHA256,
+        CipherSuite.TLS_AES_256_GCM_SHA384,
+        CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+
+        // TLSv1.0, TLSv1.1, TLSv1.2.
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+        CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256)
+
+    // This is nearly equal to the cipher suites supported in Chrome 72, current as of 2019-02-24.
+    // See https://tinyurl.com/okhttp-cipher-suites for availability.
+    private val APPROVED_CIPHER_SUITES = arrayOf(
+        // TLSv1.3.
+        CipherSuite.TLS_AES_128_GCM_SHA256,
+        CipherSuite.TLS_AES_256_GCM_SHA384,
+        CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+
+        // TLSv1.0, TLSv1.1, TLSv1.2.
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+        CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
+
+        // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
+        // continue to include them until better suites are commonly available.
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+        CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,
+        CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
+        CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
+        CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA)
+
+    /** A secure TLS connection that requires a recent client platform and a recent server.  */
+    @JvmField
+    val RESTRICTED_TLS = Builder(true)
+        .cipherSuites(*RESTRICTED_CIPHER_SUITES)
+        .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(true)
+        .build()
+
+    /**
+     * A modern TLS configuration that works on most client platforms and can connect to most servers.
+     * This is OkHttp's default configuration.
+     */
+    @JvmField
+    val MODERN_TLS = Builder(true)
+        .cipherSuites(*APPROVED_CIPHER_SUITES)
+        .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(true)
+        .build()
+
+    /**
+     * A backwards-compatible fallback configuration that works on obsolete client platforms and can
+     * connect to obsolete servers. When possible, prefer to upgrade your client platform or server
+     * rather than using this configuration.
+     */
+    @JvmField
+    val COMPATIBLE_TLS = Builder(true)
+        .cipherSuites(*APPROVED_CIPHER_SUITES)
+        .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
+        .supportsTlsExtensions(true)
+        .build()
+
+    /** Unencrypted, unauthenticated connections for `http:` URLs.  */
+    @JvmField
+    val CLEARTEXT = Builder(false).build()
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
deleted file mode 100644
index 867451e387..0000000000
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ /dev/null
@@ -1,612 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.Collections;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.List;
-import java.util.Locale;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpDate;
-import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
-
-import static okhttp3.internal.Util.UTC;
-import static okhttp3.internal.Util.canonicalizeHost;
-import static okhttp3.internal.Util.delimiterOffset;
-import static okhttp3.internal.Util.indexOfControlOrNonAscii;
-import static okhttp3.internal.Util.trimSubstring;
-import static okhttp3.internal.Util.verifyAsIpAddress;
-
-/**
- * An <a href="http://tools.ietf.org/html/rfc6265">RFC 6265</a> Cookie.
- *
- * <p>This class doesn't support additional attributes on cookies, like <a
- * href="https://code.google.com/p/chromium/issues/detail?id=232693">Chromium's Priority=HIGH
- * extension</a>.
- */
-public final class Cookie {
-  private static final Pattern YEAR_PATTERN
-      = Pattern.compile("(\\d{2,4})[^\\d]*");
-  private static final Pattern MONTH_PATTERN
-      = Pattern.compile("(?i)(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec).*");
-  private static final Pattern DAY_OF_MONTH_PATTERN
-      = Pattern.compile("(\\d{1,2})[^\\d]*");
-  private static final Pattern TIME_PATTERN
-      = Pattern.compile("(\\d{1,2}):(\\d{1,2}):(\\d{1,2})[^\\d]*");
-
-  private final String name;
-  private final String value;
-  private final long expiresAt;
-  private final String domain;
-  private final String path;
-  private final boolean secure;
-  private final boolean httpOnly;
-
-  private final boolean persistent; // True if 'expires' or 'max-age' is present.
-  private final boolean hostOnly; // True unless 'domain' is present.
-
-  private Cookie(String name, String value, long expiresAt, String domain, String path,
-      boolean secure, boolean httpOnly, boolean hostOnly, boolean persistent) {
-    this.name = name;
-    this.value = value;
-    this.expiresAt = expiresAt;
-    this.domain = domain;
-    this.path = path;
-    this.secure = secure;
-    this.httpOnly = httpOnly;
-    this.hostOnly = hostOnly;
-    this.persistent = persistent;
-  }
-
-  Cookie(Builder builder) {
-    if (builder.name == null) throw new NullPointerException("builder.name == null");
-    if (builder.value == null) throw new NullPointerException("builder.value == null");
-    if (builder.domain == null) throw new NullPointerException("builder.domain == null");
-
-    this.name = builder.name;
-    this.value = builder.value;
-    this.expiresAt = builder.expiresAt;
-    this.domain = builder.domain;
-    this.path = builder.path;
-    this.secure = builder.secure;
-    this.httpOnly = builder.httpOnly;
-    this.persistent = builder.persistent;
-    this.hostOnly = builder.hostOnly;
-  }
-
-  /** Returns a non-empty string with this cookie's name. */
-  public String name() {
-    return name;
-  }
-
-  /** Returns a possibly-empty string with this cookie's value. */
-  public String value() {
-    return value;
-  }
-
-  /** Returns true if this cookie does not expire at the end of the current session. */
-  public boolean persistent() {
-    return persistent;
-  }
-
-  /**
-   * Returns the time that this cookie expires, in the same format as {@link
-   * System#currentTimeMillis()}. This is December 31, 9999 if the cookie is {@linkplain
-   * #persistent() not persistent}, in which case it will expire at the end of the current session.
-   *
-   * <p>This may return a value less than the current time, in which case the cookie is already
-   * expired. Webservers may return expired cookies as a mechanism to delete previously set cookies
-   * that may or may not themselves be expired.
-   */
-  public long expiresAt() {
-    return expiresAt;
-  }
-
-  /**
-   * Returns true if this cookie's domain should be interpreted as a single host name, or false if
-   * it should be interpreted as a pattern. This flag will be false if its {@code Set-Cookie} header
-   * included a {@code domain} attribute.
-   *
-   * <p>For example, suppose the cookie's domain is {@code example.com}. If this flag is true it
-   * matches <strong>only</strong> {@code example.com}. If this flag is false it matches {@code
-   * example.com} and all subdomains including {@code api.example.com}, {@code www.example.com}, and
-   * {@code beta.api.example.com}.
-   */
-  public boolean hostOnly() {
-    return hostOnly;
-  }
-
-  /**
-   * Returns the cookie's domain. If {@link #hostOnly()} returns true this is the only domain that
-   * matches this cookie; otherwise it matches this domain and all subdomains.
-   */
-  public String domain() {
-    return domain;
-  }
-
-  /**
-   * Returns this cookie's path. This cookie matches URLs prefixed with path segments that match
-   * this path's segments. For example, if this path is {@code /foo} this cookie matches requests to
-   * {@code /foo} and {@code /foo/bar}, but not {@code /} or {@code /football}.
-   */
-  public String path() {
-    return path;
-  }
-
-  /**
-   * Returns true if this cookie should be limited to only HTTP APIs. In web browsers this prevents
-   * the cookie from being accessible to scripts.
-   */
-  public boolean httpOnly() {
-    return httpOnly;
-  }
-
-  /** Returns true if this cookie should be limited to only HTTPS requests. */
-  public boolean secure() {
-    return secure;
-  }
-
-  /**
-   * Returns true if this cookie should be included on a request to {@code url}. In addition to this
-   * check callers should also confirm that this cookie has not expired.
-   */
-  public boolean matches(HttpUrl url) {
-    boolean domainMatch = hostOnly
-        ? url.host().equals(domain)
-        : domainMatch(url.host(), domain);
-    if (!domainMatch) return false;
-
-    if (!pathMatch(url, path)) return false;
-
-    if (secure && !url.isHttps()) return false;
-
-    return true;
-  }
-
-  private static boolean domainMatch(String urlHost, String domain) {
-    if (urlHost.equals(domain)) {
-      return true; // As in 'example.com' matching 'example.com'.
-    }
-
-    if (urlHost.endsWith(domain)
-        && urlHost.charAt(urlHost.length() - domain.length() - 1) == '.'
-        && !verifyAsIpAddress(urlHost)) {
-      return true; // As in 'example.com' matching 'www.example.com'.
-    }
-
-    return false;
-  }
-
-  private static boolean pathMatch(HttpUrl url, String path) {
-    String urlPath = url.encodedPath();
-
-    if (urlPath.equals(path)) {
-      return true; // As in '/foo' matching '/foo'.
-    }
-
-    if (urlPath.startsWith(path)) {
-      if (path.endsWith("/")) return true; // As in '/' matching '/foo'.
-      if (urlPath.charAt(path.length()) == '/') return true; // As in '/foo' matching '/foo/bar'.
-    }
-
-    return false;
-  }
-
-  /**
-   * Attempt to parse a {@code Set-Cookie} HTTP header value {@code setCookie} as a cookie. Returns
-   * null if {@code setCookie} is not a well-formed cookie.
-   */
-  public static @Nullable Cookie parse(HttpUrl url, String setCookie) {
-    return parse(System.currentTimeMillis(), url, setCookie);
-  }
-
-  static @Nullable Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
-    int pos = 0;
-    int limit = setCookie.length();
-    int cookiePairEnd = delimiterOffset(setCookie, pos, limit, ';');
-
-    int pairEqualsSign = delimiterOffset(setCookie, pos, cookiePairEnd, '=');
-    if (pairEqualsSign == cookiePairEnd) return null;
-
-    String cookieName = trimSubstring(setCookie, pos, pairEqualsSign);
-    if (cookieName.isEmpty() || indexOfControlOrNonAscii(cookieName) != -1) return null;
-
-    String cookieValue = trimSubstring(setCookie, pairEqualsSign + 1, cookiePairEnd);
-    if (indexOfControlOrNonAscii(cookieValue) != -1) return null;
-
-    long expiresAt = HttpDate.MAX_DATE;
-    long deltaSeconds = -1L;
-    String domain = null;
-    String path = null;
-    boolean secureOnly = false;
-    boolean httpOnly = false;
-    boolean hostOnly = true;
-    boolean persistent = false;
-
-    pos = cookiePairEnd + 1;
-    while (pos < limit) {
-      int attributePairEnd = delimiterOffset(setCookie, pos, limit, ';');
-
-      int attributeEqualsSign = delimiterOffset(setCookie, pos, attributePairEnd, '=');
-      String attributeName = trimSubstring(setCookie, pos, attributeEqualsSign);
-      String attributeValue = attributeEqualsSign < attributePairEnd
-          ? trimSubstring(setCookie, attributeEqualsSign + 1, attributePairEnd)
-          : "";
-
-      if (attributeName.equalsIgnoreCase("expires")) {
-        try {
-          expiresAt = parseExpires(attributeValue, 0, attributeValue.length());
-          persistent = true;
-        } catch (IllegalArgumentException e) {
-          // Ignore this attribute, it isn't recognizable as a date.
-        }
-      } else if (attributeName.equalsIgnoreCase("max-age")) {
-        try {
-          deltaSeconds = parseMaxAge(attributeValue);
-          persistent = true;
-        } catch (NumberFormatException e) {
-          // Ignore this attribute, it isn't recognizable as a max age.
-        }
-      } else if (attributeName.equalsIgnoreCase("domain")) {
-        try {
-          domain = parseDomain(attributeValue);
-          hostOnly = false;
-        } catch (IllegalArgumentException e) {
-          // Ignore this attribute, it isn't recognizable as a domain.
-        }
-      } else if (attributeName.equalsIgnoreCase("path")) {
-        path = attributeValue;
-      } else if (attributeName.equalsIgnoreCase("secure")) {
-        secureOnly = true;
-      } else if (attributeName.equalsIgnoreCase("httponly")) {
-        httpOnly = true;
-      }
-
-      pos = attributePairEnd + 1;
-    }
-
-    // If 'Max-Age' is present, it takes precedence over 'Expires', regardless of the order the two
-    // attributes are declared in the cookie string.
-    if (deltaSeconds == Long.MIN_VALUE) {
-      expiresAt = Long.MIN_VALUE;
-    } else if (deltaSeconds != -1L) {
-      long deltaMilliseconds = deltaSeconds <= (Long.MAX_VALUE / 1000)
-          ? deltaSeconds * 1000
-          : Long.MAX_VALUE;
-      expiresAt = currentTimeMillis + deltaMilliseconds;
-      if (expiresAt < currentTimeMillis || expiresAt > HttpDate.MAX_DATE) {
-        expiresAt = HttpDate.MAX_DATE; // Handle overflow & limit the date range.
-      }
-    }
-
-    // If the domain is present, it must domain match. Otherwise we have a host-only cookie.
-    String urlHost = url.host();
-    if (domain == null) {
-      domain = urlHost;
-    } else if (!domainMatch(urlHost, domain)) {
-      return null; // No domain match? This is either incompetence or malice!
-    }
-
-    // If the domain is a suffix of the url host, it must not be a public suffix.
-    if (urlHost.length() != domain.length()
-        && PublicSuffixDatabase.get().getEffectiveTldPlusOne(domain) == null) {
-      return null;
-    }
-
-    // If the path is absent or didn't start with '/', use the default path. It's a string like
-    // '/foo/bar' for a URL like 'http://example.com/foo/bar/baz'. It always starts with '/'.
-    if (path == null || !path.startsWith("/")) {
-      String encodedPath = url.encodedPath();
-      int lastSlash = encodedPath.lastIndexOf('/');
-      path = lastSlash != 0 ? encodedPath.substring(0, lastSlash) : "/";
-    }
-
-    return new Cookie(cookieName, cookieValue, expiresAt, domain, path, secureOnly, httpOnly,
-        hostOnly, persistent);
-  }
-
-  /** Parse a date as specified in RFC 6265, section 5.1.1. */
-  private static long parseExpires(String s, int pos, int limit) {
-    pos = dateCharacterOffset(s, pos, limit, false);
-
-    int hour = -1;
-    int minute = -1;
-    int second = -1;
-    int dayOfMonth = -1;
-    int month = -1;
-    int year = -1;
-    Matcher matcher = TIME_PATTERN.matcher(s);
-
-    while (pos < limit) {
-      int end = dateCharacterOffset(s, pos + 1, limit, true);
-      matcher.region(pos, end);
-
-      if (hour == -1 && matcher.usePattern(TIME_PATTERN).matches()) {
-        hour = Integer.parseInt(matcher.group(1));
-        minute = Integer.parseInt(matcher.group(2));
-        second = Integer.parseInt(matcher.group(3));
-      } else if (dayOfMonth == -1 && matcher.usePattern(DAY_OF_MONTH_PATTERN).matches()) {
-        dayOfMonth = Integer.parseInt(matcher.group(1));
-      } else if (month == -1 && matcher.usePattern(MONTH_PATTERN).matches()) {
-        String monthString = matcher.group(1).toLowerCase(Locale.US);
-        month = MONTH_PATTERN.pattern().indexOf(monthString) / 4; // Sneaky! jan=1, dec=12.
-      } else if (year == -1 && matcher.usePattern(YEAR_PATTERN).matches()) {
-        year = Integer.parseInt(matcher.group(1));
-      }
-
-      pos = dateCharacterOffset(s, end + 1, limit, false);
-    }
-
-    // Convert two-digit years into four-digit years. 99 becomes 1999, 15 becomes 2015.
-    if (year >= 70 && year <= 99) year += 1900;
-    if (year >= 0 && year <= 69) year += 2000;
-
-    // If any partial is omitted or out of range, return -1. The date is impossible. Note that leap
-    // seconds are not supported by this syntax.
-    if (year < 1601) throw new IllegalArgumentException();
-    if (month == -1) throw new IllegalArgumentException();
-    if (dayOfMonth < 1 || dayOfMonth > 31) throw new IllegalArgumentException();
-    if (hour < 0 || hour > 23) throw new IllegalArgumentException();
-    if (minute < 0 || minute > 59) throw new IllegalArgumentException();
-    if (second < 0 || second > 59) throw new IllegalArgumentException();
-
-    Calendar calendar = new GregorianCalendar(UTC);
-    calendar.setLenient(false);
-    calendar.set(Calendar.YEAR, year);
-    calendar.set(Calendar.MONTH, month - 1);
-    calendar.set(Calendar.DAY_OF_MONTH, dayOfMonth);
-    calendar.set(Calendar.HOUR_OF_DAY, hour);
-    calendar.set(Calendar.MINUTE, minute);
-    calendar.set(Calendar.SECOND, second);
-    calendar.set(Calendar.MILLISECOND, 0);
-    return calendar.getTimeInMillis();
-  }
-
-  /**
-   * Returns the index of the next date character in {@code input}, or if {@code invert} the index
-   * of the next non-date character in {@code input}.
-   */
-  private static int dateCharacterOffset(String input, int pos, int limit, boolean invert) {
-    for (int i = pos; i < limit; i++) {
-      int c = input.charAt(i);
-      boolean dateCharacter = (c < ' ' && c != '\t') || (c >= '\u007f')
-          || (c >= '0' && c <= '9')
-          || (c >= 'a' && c <= 'z')
-          || (c >= 'A' && c <= 'Z')
-          || (c == ':');
-      if (dateCharacter == !invert) return i;
-    }
-    return limit;
-  }
-
-  /**
-   * Returns the positive value if {@code attributeValue} is positive, or {@link Long#MIN_VALUE} if
-   * it is either 0 or negative. If the value is positive but out of range, this returns {@link
-   * Long#MAX_VALUE}.
-   *
-   * @throws NumberFormatException if {@code s} is not an integer of any precision.
-   */
-  private static long parseMaxAge(String s) {
-    try {
-      long parsed = Long.parseLong(s);
-      return parsed <= 0L ? Long.MIN_VALUE : parsed;
-    } catch (NumberFormatException e) {
-      // Check if the value is an integer (positive or negative) that's too big for a long.
-      if (s.matches("-?\\d+")) {
-        return s.startsWith("-") ? Long.MIN_VALUE : Long.MAX_VALUE;
-      }
-      throw e;
-    }
-  }
-
-  /**
-   * Returns a domain string like {@code example.com} for an input domain like {@code EXAMPLE.COM}
-   * or {@code .example.com}.
-   */
-  private static String parseDomain(String s) {
-    if (s.endsWith(".")) {
-      throw new IllegalArgumentException();
-    }
-    if (s.startsWith(".")) {
-      s = s.substring(1);
-    }
-    String canonicalDomain = canonicalizeHost(s);
-    if (canonicalDomain == null) {
-      throw new IllegalArgumentException();
-    }
-    return canonicalDomain;
-  }
-
-  /** Returns all of the cookies from a set of HTTP response headers. */
-  public static List<Cookie> parseAll(HttpUrl url, Headers headers) {
-    List<String> cookieStrings = headers.values("Set-Cookie");
-    List<Cookie> cookies = null;
-
-    for (int i = 0, size = cookieStrings.size(); i < size; i++) {
-      Cookie cookie = Cookie.parse(url, cookieStrings.get(i));
-      if (cookie == null) continue;
-      if (cookies == null) cookies = new ArrayList<>();
-      cookies.add(cookie);
-    }
-
-    return cookies != null
-        ? Collections.unmodifiableList(cookies)
-        : Collections.emptyList();
-  }
-
-  /**
-   * Builds a cookie. The {@linkplain #name() name}, {@linkplain #value() value}, and {@linkplain
-   * #domain() domain} values must all be set before calling {@link #build}.
-   */
-  public static final class Builder {
-    @Nullable String name;
-    @Nullable String value;
-    long expiresAt = HttpDate.MAX_DATE;
-    @Nullable String domain;
-    String path = "/";
-    boolean secure;
-    boolean httpOnly;
-    boolean persistent;
-    boolean hostOnly;
-
-    public Builder name(String name) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (!name.trim().equals(name)) throw new IllegalArgumentException("name is not trimmed");
-      this.name = name;
-      return this;
-    }
-
-    public Builder value(String value) {
-      if (value == null) throw new NullPointerException("value == null");
-      if (!value.trim().equals(value)) throw new IllegalArgumentException("value is not trimmed");
-      this.value = value;
-      return this;
-    }
-
-    public Builder expiresAt(long expiresAt) {
-      if (expiresAt <= 0) expiresAt = Long.MIN_VALUE;
-      if (expiresAt > HttpDate.MAX_DATE) expiresAt = HttpDate.MAX_DATE;
-      this.expiresAt = expiresAt;
-      this.persistent = true;
-      return this;
-    }
-
-    /**
-     * Set the domain pattern for this cookie. The cookie will match {@code domain} and all of its
-     * subdomains.
-     */
-    public Builder domain(String domain) {
-      return domain(domain, false);
-    }
-
-    /**
-     * Set the host-only domain for this cookie. The cookie will match {@code domain} but none of
-     * its subdomains.
-     */
-    public Builder hostOnlyDomain(String domain) {
-      return domain(domain, true);
-    }
-
-    private Builder domain(String domain, boolean hostOnly) {
-      if (domain == null) throw new NullPointerException("domain == null");
-      String canonicalDomain = Util.canonicalizeHost(domain);
-      if (canonicalDomain == null) {
-        throw new IllegalArgumentException("unexpected domain: " + domain);
-      }
-      this.domain = canonicalDomain;
-      this.hostOnly = hostOnly;
-      return this;
-    }
-
-    public Builder path(String path) {
-      if (!path.startsWith("/")) throw new IllegalArgumentException("path must start with '/'");
-      this.path = path;
-      return this;
-    }
-
-    public Builder secure() {
-      this.secure = true;
-      return this;
-    }
-
-    public Builder httpOnly() {
-      this.httpOnly = true;
-      return this;
-    }
-
-    public Cookie build() {
-      return new Cookie(this);
-    }
-  }
-
-  @Override public String toString() {
-    return toString(false);
-  }
-
-  /**
-   * @param forObsoleteRfc2965 true to include a leading {@code .} on the domain pattern. This is
-   *     necessary for {@code example.com} to match {@code www.example.com} under RFC 2965. This
-   *     extra dot is ignored by more recent specifications.
-   */
-  String toString(boolean forObsoleteRfc2965) {
-    StringBuilder result = new StringBuilder();
-    result.append(name);
-    result.append('=');
-    result.append(value);
-
-    if (persistent) {
-      if (expiresAt == Long.MIN_VALUE) {
-        result.append("; max-age=0");
-      } else {
-        result.append("; expires=").append(HttpDate.format(new Date(expiresAt)));
-      }
-    }
-
-    if (!hostOnly) {
-      result.append("; domain=");
-      if (forObsoleteRfc2965) {
-        result.append(".");
-      }
-      result.append(domain);
-    }
-
-    result.append("; path=").append(path);
-
-    if (secure) {
-      result.append("; secure");
-    }
-
-    if (httpOnly) {
-      result.append("; httponly");
-    }
-
-    return result.toString();
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    if (!(other instanceof Cookie)) return false;
-    Cookie that = (Cookie) other;
-    return that.name.equals(name)
-        && that.value.equals(value)
-        && that.domain.equals(domain)
-        && that.path.equals(path)
-        && that.expiresAt == expiresAt
-        && that.secure == secure
-        && that.httpOnly == httpOnly
-        && that.persistent == persistent
-        && that.hostOnly == hostOnly;
-  }
-
-  @Override public int hashCode() {
-    int hash = 17;
-    hash = 31 * hash + name.hashCode();
-    hash = 31 * hash + value.hashCode();
-    hash = 31 * hash + domain.hashCode();
-    hash = 31 * hash + path.hashCode();
-    hash = 31 * hash + (int) (expiresAt ^ (expiresAt >>> 32));
-    hash = 31 * hash + (secure ? 0 : 1);
-    hash = 31 * hash + (httpOnly ? 0 : 1);
-    hash = 31 * hash + (persistent ? 0 : 1);
-    hash = 31 * hash + (hostOnly ? 0 : 1);
-    return hash;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Cookie.kt b/okhttp/src/main/java/okhttp3/Cookie.kt
new file mode 100644
index 0000000000..020b64b19e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Cookie.kt
@@ -0,0 +1,530 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.Util
+import okhttp3.internal.Util.UTC
+import okhttp3.internal.Util.canonicalizeHost
+import okhttp3.internal.Util.delimiterOffset
+import okhttp3.internal.Util.indexOfControlOrNonAscii
+import okhttp3.internal.Util.trimSubstring
+import okhttp3.internal.Util.verifyAsIpAddress
+import okhttp3.internal.http.HttpDate
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase
+import java.util.Calendar
+import java.util.Collections
+import java.util.Date
+import java.util.GregorianCalendar
+import java.util.Locale
+import java.util.regex.Pattern
+
+/**
+ * An [RFC 6265](http://tools.ietf.org/html/rfc6265) Cookie.
+ *
+ * This class doesn't support additional attributes on cookies, like
+ * [Chromium's Priority=HIGH extension][chromium_extension].
+ *
+ * [chromium_extension]: https://code.google.com/p/chromium/issues/detail?id=232693
+ */
+data class Cookie private constructor(
+  private val name: String,
+  private val value: String,
+  private val expiresAt: Long,
+  private val domain: String,
+  private val path: String,
+  private val secure: Boolean,
+  private val httpOnly: Boolean,
+  private val persistent: Boolean, // True if 'expires' or 'max-age' is present.
+  private val hostOnly: Boolean // True unless 'domain' is present.
+) {
+  /** Returns a non-empty string with this cookie's name.  */
+  fun name(): String = name
+
+  /** Returns a possibly-empty string with this cookie's value.  */
+  fun value(): String = value
+
+  /** Returns true if this cookie does not expire at the end of the current session.  */
+  fun persistent(): Boolean = persistent
+
+  /**
+   * Returns the time that this cookie expires, in the same format as [System.currentTimeMillis].
+   * This is December 31, 9999 if the cookie is [persistent], in which case it will expire at the
+   * end of the current session.
+   *
+   * This may return a value less than the current time, in which case the cookie is already
+   * expired. Webservers may return expired cookies as a mechanism to delete previously set cookies
+   * that may or may not themselves be expired.
+   */
+  fun expiresAt(): Long = expiresAt
+
+  /**
+   * Returns true if this cookie's domain should be interpreted as a single host name, or false if
+   * it should be interpreted as a pattern. This flag will be false if its `Set-Cookie` header
+   * included a `domain` attribute.
+   *
+   * For example, suppose the cookie's domain is `example.com`. If this flag is true it matches
+   * **only** `example.com`. If this flag is false it matches `example.com` and all subdomains
+   * including `api.example.com`, `www.example.com`, and `beta.api.example.com`.
+   */
+  fun hostOnly(): Boolean = hostOnly
+
+  /**
+   * Returns the cookie's domain. If [hostOnly] returns true this is the only domain that matches
+   * this cookie; otherwise it matches this domain and all subdomains.
+   */
+  fun domain(): String = domain
+
+  /**
+   * Returns this cookie's path. This cookie matches URLs prefixed with path segments that match
+   * this path's segments. For example, if this path is `/foo` this cookie matches requests to
+   * `/foo` and `/foo/bar`, but not `/` or `/football`.
+   */
+  fun path(): String = path
+
+  /**
+   * Returns true if this cookie should be limited to only HTTP APIs. In web browsers this prevents
+   * the cookie from being accessible to scripts.
+   */
+  fun httpOnly(): Boolean = httpOnly
+
+  /** Returns true if this cookie should be limited to only HTTPS requests.  */
+  fun secure(): Boolean = secure
+
+  /**
+   * Returns true if this cookie should be included on a request to `url`. In addition to this
+   * check callers should also confirm that this cookie has not expired.
+   */
+  fun matches(url: HttpUrl): Boolean {
+    val domainMatch = if (hostOnly) {
+      url.host() == domain
+    } else {
+      domainMatch(url.host(), domain)
+    }
+    if (!domainMatch) return false
+
+    if (!pathMatch(url, path)) return false
+
+    return !secure || url.isHttps
+  }
+
+  /**
+   * Builds a cookie. The [name], [value], and [domain] values must all be set before calling
+   * [build].
+   */
+  class Builder {
+    private var name: String? = null
+    private var value: String? = null
+    private var expiresAt = HttpDate.MAX_DATE
+    private var domain: String? = null
+    private var path = "/"
+    private var secure: Boolean = false
+    private var httpOnly: Boolean = false
+    private var persistent: Boolean = false
+    private var hostOnly: Boolean = false
+
+    fun name(name: String) = apply {
+      require(name.trim { it <= ' ' } == name) { "name is not trimmed" }
+      this.name = name
+    }
+
+    fun value(value: String) = apply {
+      require(value.trim { it <= ' ' } == value) { "value is not trimmed" }
+      this.value = value
+    }
+
+    fun expiresAt(expiresAt: Long) = apply {
+      var expiresAt = expiresAt
+      if (expiresAt <= 0) expiresAt = Long.MIN_VALUE
+      if (expiresAt > HttpDate.MAX_DATE) expiresAt = HttpDate.MAX_DATE
+      this.expiresAt = expiresAt
+      this.persistent = true
+    }
+
+    /**
+     * Set the domain pattern for this cookie. The cookie will match `domain` and all of its
+     * subdomains.
+     */
+    fun domain(domain: String): Builder = domain(domain, false)
+
+    /**
+     * Set the host-only domain for this cookie. The cookie will match `domain` but none of
+     * its subdomains.
+     */
+    fun hostOnlyDomain(domain: String): Builder = domain(domain, true)
+
+    private fun domain(domain: String, hostOnly: Boolean) = apply {
+      val canonicalDomain = Util.canonicalizeHost(domain)
+          ?: throw IllegalArgumentException("unexpected domain: $domain")
+      this.domain = canonicalDomain
+      this.hostOnly = hostOnly
+    }
+
+    fun path(path: String) = apply {
+      require(path.startsWith("/")) { "path must start with '/'" }
+      this.path = path
+    }
+
+    fun secure() = apply {
+      this.secure = true
+    }
+
+    fun httpOnly() = apply {
+      this.httpOnly = true
+    }
+
+    fun build(): Cookie {
+      return Cookie(
+          name ?: throw NullPointerException("builder.name == null"),
+          value ?: throw NullPointerException("builder.value == null"),
+          expiresAt,
+          domain ?: throw NullPointerException("builder.domain == null"),
+          path,
+          secure,
+          httpOnly,
+          persistent,
+          hostOnly)
+    }
+  }
+
+  override fun toString(): String = toString(false)
+
+  /**
+   * @param forObsoleteRfc2965 true to include a leading `.` on the domain pattern. This is
+   *     necessary for `example.com` to match `www.example.com` under RFC 2965. This extra dot is
+   *     ignored by more recent specifications.
+   */
+  internal fun toString(forObsoleteRfc2965: Boolean): String {
+    return buildString {
+      append(name)
+      append('=')
+      append(value)
+
+      if (persistent) {
+        if (expiresAt == Long.MIN_VALUE) {
+          append("; max-age=0")
+        } else {
+          append("; expires=").append(HttpDate.format(Date(expiresAt)))
+        }
+      }
+
+      if (!hostOnly) {
+        append("; domain=")
+        if (forObsoleteRfc2965) {
+          append(".")
+        }
+        append(domain)
+      }
+
+      append("; path=").append(path)
+
+      if (secure) {
+        append("; secure")
+      }
+
+      if (httpOnly) {
+        append("; httponly")
+      }
+
+      return toString()
+    }
+  }
+
+  companion object {
+    private val YEAR_PATTERN = Pattern.compile("(\\d{2,4})[^\\d]*")
+    private val MONTH_PATTERN =
+        Pattern.compile("(?i)(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec).*")
+    private val DAY_OF_MONTH_PATTERN = Pattern.compile("(\\d{1,2})[^\\d]*")
+    private val TIME_PATTERN = Pattern.compile("(\\d{1,2}):(\\d{1,2}):(\\d{1,2})[^\\d]*")
+
+    private fun domainMatch(urlHost: String, domain: String): Boolean {
+      if (urlHost == domain) {
+        return true // As in 'example.com' matching 'example.com'.
+      }
+
+      return urlHost.endsWith(domain) &&
+          urlHost[urlHost.length - domain.length - 1] == '.' &&
+          !verifyAsIpAddress(urlHost)
+    }
+
+    private fun pathMatch(url: HttpUrl, path: String): Boolean {
+      val urlPath = url.encodedPath()
+
+      if (urlPath == path) {
+        return true // As in '/foo' matching '/foo'.
+      }
+
+      if (urlPath.startsWith(path)) {
+        if (path.endsWith("/")) return true // As in '/' matching '/foo'.
+        if (urlPath[path.length] == '/') return true // As in '/foo' matching '/foo/bar'.
+      }
+
+      return false
+    }
+
+    /**
+     * Attempt to parse a `Set-Cookie` HTTP header value `setCookie` as a cookie. Returns null if
+     * `setCookie` is not a well-formed cookie.
+     */
+    @JvmStatic
+    fun parse(url: HttpUrl, setCookie: String): Cookie? =
+        parse(System.currentTimeMillis(), url, setCookie)
+
+    internal fun parse(currentTimeMillis: Long, url: HttpUrl, setCookie: String): Cookie? {
+      var pos = 0
+      val limit = setCookie.length
+      val cookiePairEnd = delimiterOffset(setCookie, pos, limit, ';')
+
+      val pairEqualsSign = delimiterOffset(setCookie, pos, cookiePairEnd, '=')
+      if (pairEqualsSign == cookiePairEnd) return null
+
+      val cookieName = trimSubstring(setCookie, pos, pairEqualsSign)
+      if (cookieName.isEmpty() || indexOfControlOrNonAscii(cookieName) != -1) return null
+
+      val cookieValue = trimSubstring(setCookie, pairEqualsSign + 1, cookiePairEnd)
+      if (indexOfControlOrNonAscii(cookieValue) != -1) return null
+
+      var expiresAt = HttpDate.MAX_DATE
+      var deltaSeconds = -1L
+      var domain: String? = null
+      var path: String? = null
+      var secureOnly = false
+      var httpOnly = false
+      var hostOnly = true
+      var persistent = false
+
+      pos = cookiePairEnd + 1
+      while (pos < limit) {
+        val attributePairEnd = delimiterOffset(setCookie, pos, limit, ';')
+
+        val attributeEqualsSign = delimiterOffset(setCookie, pos, attributePairEnd, '=')
+        val attributeName = trimSubstring(setCookie, pos, attributeEqualsSign)
+        val attributeValue = if (attributeEqualsSign < attributePairEnd) {
+          trimSubstring(setCookie, attributeEqualsSign + 1, attributePairEnd)
+        } else {
+          ""
+        }
+
+        when {
+          attributeName.equals("expires", ignoreCase = true) -> {
+            try {
+              expiresAt = parseExpires(attributeValue, 0, attributeValue.length)
+              persistent = true
+            } catch (e: IllegalArgumentException) {
+              // Ignore this attribute, it isn't recognizable as a date.
+            }
+          }
+          attributeName.equals("max-age", ignoreCase = true) -> {
+            try {
+              deltaSeconds = parseMaxAge(attributeValue)
+              persistent = true
+            } catch (e: NumberFormatException) {
+              // Ignore this attribute, it isn't recognizable as a max age.
+            }
+          }
+          attributeName.equals("domain", ignoreCase = true) -> {
+            try {
+              domain = parseDomain(attributeValue)
+              hostOnly = false
+            } catch (e: IllegalArgumentException) {
+              // Ignore this attribute, it isn't recognizable as a domain.
+            }
+          }
+          attributeName.equals("path", ignoreCase = true) -> {
+            path = attributeValue
+          }
+          attributeName.equals("secure", ignoreCase = true) -> {
+            secureOnly = true
+          }
+          attributeName.equals("httponly", ignoreCase = true) -> {
+            httpOnly = true
+          }
+        }
+
+        pos = attributePairEnd + 1
+      }
+
+      // If 'Max-Age' is present, it takes precedence over 'Expires', regardless of the order the two
+      // attributes are declared in the cookie string.
+      if (deltaSeconds == Long.MIN_VALUE) {
+        expiresAt = Long.MIN_VALUE
+      } else if (deltaSeconds != -1L) {
+        val deltaMilliseconds = if (deltaSeconds <= Long.MAX_VALUE / 1000) {
+          deltaSeconds * 1000
+        } else {
+          Long.MAX_VALUE
+        }
+        expiresAt = currentTimeMillis + deltaMilliseconds
+        if (expiresAt < currentTimeMillis || expiresAt > HttpDate.MAX_DATE) {
+          expiresAt = HttpDate.MAX_DATE // Handle overflow & limit the date range.
+        }
+      }
+
+      // If the domain is present, it must domain match. Otherwise we have a host-only cookie.
+      val urlHost = url.host()
+      if (domain == null) {
+        domain = urlHost
+      } else if (!domainMatch(urlHost, domain)) {
+        return null // No domain match? This is either incompetence or malice!
+      }
+
+      // If the domain is a suffix of the url host, it must not be a public suffix.
+      if (urlHost.length != domain.length &&
+          PublicSuffixDatabase.get().getEffectiveTldPlusOne(domain) == null) {
+        return null
+      }
+
+      // If the path is absent or didn't start with '/', use the default path. It's a string like
+      // '/foo/bar' for a URL like 'http://example.com/foo/bar/baz'. It always starts with '/'.
+      if (path == null || !path.startsWith("/")) {
+        val encodedPath = url.encodedPath()
+        val lastSlash = encodedPath.lastIndexOf('/')
+        path = if (lastSlash != 0) encodedPath.substring(0, lastSlash) else "/"
+      }
+
+      return Cookie(cookieName, cookieValue, expiresAt, domain, path, secureOnly, httpOnly,
+          persistent, hostOnly)
+    }
+
+    /** Parse a date as specified in RFC 6265, section 5.1.1.  */
+    private fun parseExpires(s: String, pos: Int, limit: Int): Long {
+      var pos = pos
+      pos = dateCharacterOffset(s, pos, limit, false)
+
+      var hour = -1
+      var minute = -1
+      var second = -1
+      var dayOfMonth = -1
+      var month = -1
+      var year = -1
+      val matcher = TIME_PATTERN.matcher(s)
+
+      while (pos < limit) {
+        val end = dateCharacterOffset(s, pos + 1, limit, true)
+        matcher.region(pos, end)
+
+        when {
+          hour == -1 && matcher.usePattern(TIME_PATTERN).matches() -> {
+            hour = Integer.parseInt(matcher.group(1))
+            minute = Integer.parseInt(matcher.group(2))
+            second = Integer.parseInt(matcher.group(3))
+          }
+          dayOfMonth == -1 && matcher.usePattern(DAY_OF_MONTH_PATTERN).matches() -> {
+            dayOfMonth = Integer.parseInt(matcher.group(1))
+          }
+          month == -1 && matcher.usePattern(MONTH_PATTERN).matches() -> {
+            val monthString = matcher.group(1).toLowerCase(Locale.US)
+            month = MONTH_PATTERN.pattern().indexOf(monthString) / 4 // Sneaky! jan=1, dec=12.
+          }
+          year == -1 && matcher.usePattern(YEAR_PATTERN).matches() -> {
+            year = Integer.parseInt(matcher.group(1))
+          }
+        }
+
+        pos = dateCharacterOffset(s, end + 1, limit, false)
+      }
+
+      // Convert two-digit years into four-digit years. 99 becomes 1999, 15 becomes 2015.
+      if (year in 70..99) year += 1900
+      if (year in 0..69) year += 2000
+
+      // If any partial is omitted or out of range, return -1. The date is impossible. Note that leap
+      // seconds are not supported by this syntax.
+      require(year >= 1601)
+      require(month != -1)
+      require(dayOfMonth in 1..31)
+      require(hour in 0..23)
+      require(minute in 0..59)
+      require(second in 0..59)
+
+      GregorianCalendar(UTC).apply {
+        isLenient = false
+        set(Calendar.YEAR, year)
+        set(Calendar.MONTH, month - 1)
+        set(Calendar.DAY_OF_MONTH, dayOfMonth)
+        set(Calendar.HOUR_OF_DAY, hour)
+        set(Calendar.MINUTE, minute)
+        set(Calendar.SECOND, second)
+        set(Calendar.MILLISECOND, 0)
+        return timeInMillis
+      }
+    }
+
+    /**
+     * Returns the index of the next date character in `input`, or if `invert` the index
+     * of the next non-date character in `input`.
+     */
+    private fun dateCharacterOffset(input: String, pos: Int, limit: Int, invert: Boolean): Int {
+      for (i in pos until limit) {
+        val c = input[i].toInt()
+        val dateCharacter = (c < ' '.toInt() && c != '\t'.toInt() || c >= '\u007f'.toInt() ||
+            c in '0'.toInt()..'9'.toInt() ||
+            c in 'a'.toInt()..'z'.toInt() ||
+            c in 'A'.toInt()..'Z'.toInt() ||
+            c == ':'.toInt())
+        if (dateCharacter == !invert) return i
+      }
+      return limit
+    }
+
+    /**
+     * Returns the positive value if `attributeValue` is positive, or [Long.MIN_VALUE] if it is
+     * either 0 or negative. If the value is positive but out of range, this returns
+     * [Long.MAX_VALUE].
+     *
+     * @throws NumberFormatException if `s` is not an integer of any precision.
+     */
+    private fun parseMaxAge(s: String): Long {
+      try {
+        val parsed = s.toLong()
+        return if (parsed <= 0L) Long.MIN_VALUE else parsed
+      } catch (e: NumberFormatException) {
+        // Check if the value is an integer (positive or negative) that's too big for a long.
+        if (s.matches("-?\\d+".toRegex())) {
+          return if (s.startsWith("-")) Long.MIN_VALUE else Long.MAX_VALUE
+        }
+        throw e
+      }
+    }
+
+    /**
+     * Returns a domain string like `example.com` for an input domain like `EXAMPLE.COM`
+     * or `.example.com`.
+     */
+    private fun parseDomain(s: String): String {
+      require(!s.endsWith("."))
+      return canonicalizeHost(s.removePrefix(".")) ?: throw IllegalArgumentException()
+    }
+
+    /** Returns all of the cookies from a set of HTTP response headers.  */
+    @JvmStatic
+    fun parseAll(url: HttpUrl, headers: Headers): List<Cookie> {
+      val cookieStrings = headers.values("Set-Cookie")
+      var cookies: MutableList<Cookie>? = null
+
+      for (i in 0 until cookieStrings.size) {
+        val cookie = Cookie.parse(url, cookieStrings[i]) ?: continue
+        if (cookies == null) cookies = mutableListOf()
+        cookies.add(cookie)
+      }
+
+      return if (cookies != null) {
+        Collections.unmodifiableList(cookies)
+      } else {
+        emptyList()
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/CookieJar.java b/okhttp/src/main/java/okhttp3/CookieJar.java
deleted file mode 100644
index bdb3cd552e..0000000000
--- a/okhttp/src/main/java/okhttp3/CookieJar.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.Collections;
-import java.util.List;
-
-/**
- * Provides <strong>policy</strong> and <strong>persistence</strong> for HTTP cookies.
- *
- * <p>As policy, implementations of this interface are responsible for selecting which cookies to
- * accept and which to reject. A reasonable policy is to reject all cookies, though that may
- * interfere with session-based authentication schemes that require cookies.
- *
- * <p>As persistence, implementations of this interface must also provide storage of cookies. Simple
- * implementations may store cookies in memory; sophisticated ones may use the file system or
- * database to hold accepted cookies. The <a
- * href="https://tools.ietf.org/html/rfc6265#section-5.3">cookie storage model</a> specifies
- * policies for updating and expiring cookies.
- */
-public interface CookieJar {
-  /** A cookie jar that never accepts any cookies. */
-  CookieJar NO_COOKIES = new CookieJar() {
-    @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
-    }
-
-    @Override public List<Cookie> loadForRequest(HttpUrl url) {
-      return Collections.emptyList();
-    }
-  };
-
-  /**
-   * Saves {@code cookies} from an HTTP response to this store according to this jar's policy.
-   *
-   * <p>Note that this method may be called a second time for a single HTTP response if the response
-   * includes a trailer. For this obscure HTTP feature, {@code cookies} contains only the trailer's
-   * cookies.
-   */
-  void saveFromResponse(HttpUrl url, List<Cookie> cookies);
-
-  /**
-   * Load cookies from the jar for an HTTP request to {@code url}. This method returns a possibly
-   * empty list of cookies for the network request.
-   *
-   * <p>Simple implementations will return the accepted cookies that have not yet expired and that
-   * {@linkplain Cookie#matches match} {@code url}.
-   */
-  List<Cookie> loadForRequest(HttpUrl url);
-}
diff --git a/okhttp/src/main/java/okhttp3/CookieJar.kt b/okhttp/src/main/java/okhttp3/CookieJar.kt
new file mode 100644
index 0000000000..8ae48fd7cd
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CookieJar.kt
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+/**
+ * Provides **policy** and **persistence** for HTTP cookies.
+ *
+ * As policy, implementations of this interface are responsible for selecting which cookies to
+ * accept and which to reject. A reasonable policy is to reject all cookies, though that may
+ * interfere with session-based authentication schemes that require cookies.
+ *
+ * As persistence, implementations of this interface must also provide storage of cookies. Simple
+ * implementations may store cookies in memory; sophisticated ones may use the file system or
+ * database to hold accepted cookies. The [cookie storage model][rfc_6265_53] specifies policies for
+ * updating and expiring cookies.
+ *
+ * [rfc_6265_53]: https://tools.ietf.org/html/rfc6265#section-5.3
+ */
+interface CookieJar {
+  /**
+   * Saves `cookies` from an HTTP response to this store according to this jar's policy.
+   *
+   * Note that this method may be called a second time for a single HTTP response if the response
+   * includes a trailer. For this obscure HTTP feature, `cookies` contains only the trailer's
+   * cookies.
+   */
+  fun saveFromResponse(url: HttpUrl, cookies: List<Cookie>)
+
+  /**
+   * Load cookies from the jar for an HTTP request to `url`. This method returns a possibly
+   * empty list of cookies for the network request.
+   *
+   * Simple implementations will return the accepted cookies that have not yet expired and that
+   * [match][Cookie.matches] `url`.
+   */
+  fun loadForRequest(url: HttpUrl): List<Cookie>
+
+  companion object {
+    /** A cookie jar that never accepts any cookies. */
+    @JvmField
+    val NO_COOKIES: CookieJar = object : CookieJar {
+      override fun saveFromResponse(url: HttpUrl, cookies: List<Cookie>) {
+      }
+
+      override fun loadForRequest(url: HttpUrl): List<Cookie> {
+        return emptyList()
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Credentials.java b/okhttp/src/main/java/okhttp3/Credentials.kt
similarity index 55%
rename from okhttp/src/main/java/okhttp3/Credentials.java
rename to okhttp/src/main/java/okhttp3/Credentials.kt
index c06c1d61f0..bb670714c7 100644
--- a/okhttp/src/main/java/okhttp3/Credentials.java
+++ b/okhttp/src/main/java/okhttp3/Credentials.kt
@@ -13,26 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3;
+package okhttp3
 
-import java.nio.charset.Charset;
-import okio.ByteString;
-
-import static java.nio.charset.StandardCharsets.ISO_8859_1;
+import okio.ByteString.Companion.encode
+import java.nio.charset.Charset
+import java.nio.charset.StandardCharsets.ISO_8859_1
 
 /** Factory for HTTP authorization credentials. */
-public final class Credentials {
-  private Credentials() {
-  }
-
+object Credentials {
   /** Returns an auth credential for the Basic scheme. */
-  public static String basic(String username, String password) {
-    return basic(username, password, ISO_8859_1);
-  }
-
-  public static String basic(String username, String password, Charset charset) {
-    String usernameAndPassword = username + ":" + password;
-    String encoded = ByteString.encodeString(usernameAndPassword, charset).base64();
-    return "Basic " + encoded;
+  @JvmStatic @JvmOverloads fun basic(
+    username: String,
+    password: String,
+    charset: Charset = ISO_8859_1
+  ): String {
+    val usernameAndPassword = "$username:$password"
+    val encoded = usernameAndPassword.encode(charset).base64()
+    return "Basic $encoded"
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
deleted file mode 100644
index d3d9b21aff..0000000000
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ /dev/null
@@ -1,257 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Deque;
-import java.util.Iterator;
-import java.util.List;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.RealCall.AsyncCall;
-import okhttp3.internal.Util;
-
-/**
- * Policy on when async requests are executed.
- *
- * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you supply your
- * own executor, it should be able to run {@linkplain #getMaxRequests the configured maximum} number
- * of calls concurrently.
- */
-public final class Dispatcher {
-  private int maxRequests = 64;
-  private int maxRequestsPerHost = 5;
-  private @Nullable Runnable idleCallback;
-
-  /** Executes calls. Created lazily. */
-  private @Nullable ExecutorService executorService;
-
-  /** Ready async calls in the order they'll be run. */
-  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
-
-  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
-
-  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
-
-  public Dispatcher(ExecutorService executorService) {
-    this.executorService = executorService;
-  }
-
-  public Dispatcher() {
-  }
-
-  public synchronized ExecutorService executorService() {
-    if (executorService == null) {
-      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
-          new SynchronousQueue<>(), Util.threadFactory("OkHttp Dispatcher", false));
-    }
-    return executorService;
-  }
-
-  /**
-   * Set the maximum number of requests to execute concurrently. Above this requests queue in
-   * memory, waiting for the running calls to complete.
-   *
-   * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
-   * will remain in flight.
-   */
-  public void setMaxRequests(int maxRequests) {
-    if (maxRequests < 1) {
-      throw new IllegalArgumentException("max < 1: " + maxRequests);
-    }
-    synchronized (this) {
-      this.maxRequests = maxRequests;
-    }
-    promoteAndExecute();
-  }
-
-  public synchronized int getMaxRequests() {
-    return maxRequests;
-  }
-
-  /**
-   * Set the maximum number of requests for each host to execute concurrently. This limits requests
-   * by the URL's host name. Note that concurrent requests to a single IP address may still exceed
-   * this limit: multiple hostnames may share an IP address or be routed through the same HTTP
-   * proxy.
-   *
-   * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those
-   * requests will remain in flight.
-   *
-   * <p>WebSocket connections to hosts <b>do not</b> count against this limit.
-   */
-  public void setMaxRequestsPerHost(int maxRequestsPerHost) {
-    if (maxRequestsPerHost < 1) {
-      throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
-    }
-    synchronized (this) {
-      this.maxRequestsPerHost = maxRequestsPerHost;
-    }
-    promoteAndExecute();
-  }
-
-  public synchronized int getMaxRequestsPerHost() {
-    return maxRequestsPerHost;
-  }
-
-  /**
-   * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running
-   * calls returns to zero).
-   *
-   * <p>Note: The time at which a {@linkplain Call call} is considered idle is different depending
-   * on whether it was run {@linkplain Call#enqueue(Callback) asynchronously} or
-   * {@linkplain Call#execute() synchronously}. Asynchronous calls become idle after the
-   * {@link Callback#onResponse onResponse} or {@link Callback#onFailure onFailure} callback has
-   * returned. Synchronous calls become idle once {@link Call#execute() execute()} returns. This
-   * means that if you are doing synchronous calls the network layer will not truly be idle until
-   * every returned {@link Response} has been closed.
-   */
-  public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
-    this.idleCallback = idleCallback;
-  }
-
-  void enqueue(AsyncCall call) {
-    synchronized (this) {
-      readyAsyncCalls.add(call);
-    }
-    promoteAndExecute();
-  }
-
-  /**
-   * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain
-   * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.
-   */
-  public synchronized void cancelAll() {
-    for (AsyncCall call : readyAsyncCalls) {
-      call.get().cancel();
-    }
-
-    for (AsyncCall call : runningAsyncCalls) {
-      call.get().cancel();
-    }
-
-    for (RealCall call : runningSyncCalls) {
-      call.cancel();
-    }
-  }
-
-  /**
-   * Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs
-   * them on the executor service. Must not be called with synchronization because executing calls
-   * can call into user code.
-   *
-   * @return true if the dispatcher is currently running calls.
-   */
-  private boolean promoteAndExecute() {
-    assert (!Thread.holdsLock(this));
-
-    List<AsyncCall> executableCalls = new ArrayList<>();
-    boolean isRunning;
-    synchronized (this) {
-      for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
-        AsyncCall asyncCall = i.next();
-
-        if (runningAsyncCalls.size() >= maxRequests) break; // Max capacity.
-        if (runningCallsForHost(asyncCall) >= maxRequestsPerHost) continue; // Host max capacity.
-
-        i.remove();
-        executableCalls.add(asyncCall);
-        runningAsyncCalls.add(asyncCall);
-      }
-      isRunning = runningCallsCount() > 0;
-    }
-
-    for (int i = 0, size = executableCalls.size(); i < size; i++) {
-      AsyncCall asyncCall = executableCalls.get(i);
-      asyncCall.executeOn(executorService());
-    }
-
-    return isRunning;
-  }
-
-  /** Returns the number of running calls that share a host with {@code call}. */
-  private int runningCallsForHost(AsyncCall call) {
-    int result = 0;
-    for (AsyncCall c : runningAsyncCalls) {
-      if (c.get().forWebSocket) continue;
-      if (c.host().equals(call.host())) result++;
-    }
-    return result;
-  }
-
-  /** Used by {@code Call#execute} to signal it is in-flight. */
-  synchronized void executed(RealCall call) {
-    runningSyncCalls.add(call);
-  }
-
-  /** Used by {@code AsyncCall#run} to signal completion. */
-  void finished(AsyncCall call) {
-    finished(runningAsyncCalls, call);
-  }
-
-  /** Used by {@code Call#execute} to signal completion. */
-  void finished(RealCall call) {
-    finished(runningSyncCalls, call);
-  }
-
-  private <T> void finished(Deque<T> calls, T call) {
-    Runnable idleCallback;
-    synchronized (this) {
-      if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
-      idleCallback = this.idleCallback;
-    }
-
-    boolean isRunning = promoteAndExecute();
-
-    if (!isRunning && idleCallback != null) {
-      idleCallback.run();
-    }
-  }
-
-  /** Returns a snapshot of the calls currently awaiting execution. */
-  public synchronized List<Call> queuedCalls() {
-    List<Call> result = new ArrayList<>();
-    for (AsyncCall asyncCall : readyAsyncCalls) {
-      result.add(asyncCall.get());
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  /** Returns a snapshot of the calls currently being executed. */
-  public synchronized List<Call> runningCalls() {
-    List<Call> result = new ArrayList<>();
-    result.addAll(runningSyncCalls);
-    for (AsyncCall asyncCall : runningAsyncCalls) {
-      result.add(asyncCall.get());
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  public synchronized int queuedCallsCount() {
-    return readyAsyncCalls.size();
-  }
-
-  public synchronized int runningCallsCount() {
-    return runningAsyncCalls.size() + runningSyncCalls.size();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.kt b/okhttp/src/main/java/okhttp3/Dispatcher.kt
new file mode 100644
index 0000000000..fbd92dd67f
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.kt
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.RealCall.AsyncCall
+import okhttp3.internal.Util
+import java.util.ArrayDeque
+import java.util.ArrayList
+import java.util.Collections
+import java.util.Deque
+import java.util.concurrent.ExecutorService
+import java.util.concurrent.SynchronousQueue
+import java.util.concurrent.ThreadPoolExecutor
+import java.util.concurrent.TimeUnit
+
+/**
+ * Policy on when async requests are executed.
+ *
+ *
+ * Each dispatcher uses an [ExecutorService] to run calls internally. If you supply your own
+ * executor, it should be able to run [the configured maximum][maxRequests] number of calls
+ * concurrently.
+ */
+class Dispatcher constructor() {
+  /**
+   * Set the maximum number of requests to execute concurrently. Above this requests queue in
+   * memory, waiting for the running calls to complete.
+   *
+   * If more than `maxRequests` requests are in flight when this is invoked, those requests
+   * will remain in flight.
+   */
+  @get:Synchronized var maxRequests = 64
+    set(maxRequests) {
+      require(maxRequests >= 1) { "max < 1: $maxRequests" }
+      synchronized(this) {
+        field = maxRequests
+      }
+      promoteAndExecute()
+    }
+
+  /**
+   * Set the maximum number of requests for each host to execute concurrently. This limits requests
+   * by the URL's host name. Note that concurrent requests to a single IP address may still exceed
+   * this limit: multiple hostnames may share an IP address or be routed through the same HTTP
+   * proxy.
+   *
+   * If more than `maxRequestsPerHost` requests are in flight when this is invoked, those
+   * requests will remain in flight.
+   *
+   * WebSocket connections to hosts **do not** count against this limit.
+   */
+  @get:Synchronized var maxRequestsPerHost = 5
+    set(maxRequestsPerHost) {
+      require(maxRequestsPerHost >= 1) { "max < 1: $maxRequestsPerHost" }
+      synchronized(this) {
+        field = maxRequestsPerHost
+      }
+      promoteAndExecute()
+    }
+
+  private var idleCallback: Runnable? = null
+
+  /** Executes calls. Created lazily.  */
+  private var executorService: ExecutorService? = null
+
+  /** Ready async calls in the order they'll be run.  */
+  private val readyAsyncCalls = ArrayDeque<AsyncCall>()
+
+  /** Running asynchronous calls. Includes canceled calls that haven't finished yet.  */
+  private val runningAsyncCalls = ArrayDeque<AsyncCall>()
+
+  /** Running synchronous calls. Includes canceled calls that haven't finished yet.  */
+  private val runningSyncCalls = ArrayDeque<RealCall>()
+
+  constructor(executorService: ExecutorService) : this() {
+    this.executorService = executorService
+  }
+
+  @Synchronized fun executorService(): ExecutorService {
+    if (executorService == null) {
+      executorService = ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS,
+          SynchronousQueue(), Util.threadFactory("OkHttp Dispatcher", false))
+    }
+    return executorService!!
+  }
+
+  /**
+   * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running
+   * calls returns to zero).
+   *
+   * Note: The time at which a [call][Call] is considered idle is different depending
+   * on whether it was run [asynchronously][Call.enqueue] or [synchronously][Call.execute].
+   * Asynchronous calls become idle after the [onResponse][Callback.onResponse] or
+   * [onFailure][Callback.onFailure] callback has returned. Synchronous calls become idle once
+   * [execute()][Call.execute] returns. This means that if you are doing synchronous calls the
+   * network layer will not truly be idle until every returned [Response] has been closed.
+   */
+  @Synchronized fun setIdleCallback(idleCallback: Runnable?) {
+    this.idleCallback = idleCallback
+  }
+
+  // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+  @JvmName("-deprecated_setIdleCallback")
+  inline fun setIdleCallback(crossinline idleCallback: () -> Unit) =
+      setIdleCallback(Runnable { idleCallback() })
+
+  internal fun enqueue(call: AsyncCall) {
+    synchronized(this) {
+      readyAsyncCalls.add(call)
+
+      // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to
+      // the same host.
+      if (!call.get().forWebSocket) {
+        val existingCall = findExistingCallWithHost(call.host())
+        if (existingCall != null) call.reuseCallsPerHostFrom(existingCall)
+      }
+    }
+    promoteAndExecute()
+  }
+
+  private fun findExistingCallWithHost(host: String): AsyncCall? {
+    for (existingCall in runningAsyncCalls) {
+      if (existingCall.host() == host) return existingCall
+    }
+    for (existingCall in readyAsyncCalls) {
+      if (existingCall.host() == host) return existingCall
+    }
+    return null
+  }
+
+  /**
+   * Cancel all calls currently enqueued or executing. Includes calls executed both
+   * [synchronously][Call.execute] and [asynchronously][Call.enqueue].
+   */
+  @Synchronized fun cancelAll() {
+    for (call in readyAsyncCalls) {
+      call.get().cancel()
+    }
+    for (call in runningAsyncCalls) {
+      call.get().cancel()
+    }
+    for (call in runningSyncCalls) {
+      call.cancel()
+    }
+  }
+
+  /**
+   * Promotes eligible calls from [readyAsyncCalls] to [runningAsyncCalls] and runs them on the
+   * executor service. Must not be called with synchronization because executing calls can call
+   * into user code.
+   *
+   * @return true if the dispatcher is currently running calls.
+   */
+  private fun promoteAndExecute(): Boolean {
+    assert(!Thread.holdsLock(this))
+
+    val executableCalls = ArrayList<AsyncCall>()
+    val isRunning: Boolean
+    synchronized(this) {
+      val i = readyAsyncCalls.iterator()
+      while (i.hasNext()) {
+        val asyncCall = i.next()
+
+        if (runningAsyncCalls.size >= this.maxRequests) break // Max capacity.
+        if (asyncCall.callsPerHost().get() >= this.maxRequestsPerHost) continue // Host max capacity.
+
+        i.remove()
+        asyncCall.callsPerHost().incrementAndGet()
+        executableCalls.add(asyncCall)
+        runningAsyncCalls.add(asyncCall)
+      }
+      isRunning = runningCallsCount() > 0
+    }
+
+    for (i in 0 until executableCalls.size) {
+      val asyncCall = executableCalls[i]
+      asyncCall.executeOn(executorService())
+    }
+
+    return isRunning
+  }
+
+  /** Used by `Call#execute` to signal it is in-flight.  */
+  @Synchronized internal fun executed(call: RealCall) {
+    runningSyncCalls.add(call)
+  }
+
+  /** Used by `AsyncCall#run` to signal completion.  */
+  internal fun finished(call: AsyncCall) {
+    call.callsPerHost().decrementAndGet()
+    finished(runningAsyncCalls, call)
+  }
+
+  /** Used by `Call#execute` to signal completion.  */
+  internal fun finished(call: RealCall) {
+    finished(runningSyncCalls, call)
+  }
+
+  private fun <T> finished(calls: Deque<T>, call: T) {
+    val idleCallback: Runnable?
+    synchronized(this) {
+      if (!calls.remove(call)) throw AssertionError("Call wasn't in-flight!")
+      idleCallback = this.idleCallback
+    }
+
+    val isRunning = promoteAndExecute()
+
+    if (!isRunning && idleCallback != null) {
+      idleCallback.run()
+    }
+  }
+
+  /** Returns a snapshot of the calls currently awaiting execution.  */
+  @Synchronized fun queuedCalls(): List<Call> {
+    return Collections.unmodifiableList(readyAsyncCalls.map { it.get() })
+  }
+
+  /** Returns a snapshot of the calls currently being executed.  */
+  @Synchronized fun runningCalls(): List<Call> {
+    return Collections.unmodifiableList(runningSyncCalls + runningAsyncCalls.map { it.get() })
+  }
+
+  @Synchronized fun queuedCallsCount(): Int = readyAsyncCalls.size
+
+  @Synchronized fun runningCallsCount(): Int = runningAsyncCalls.size + runningSyncCalls.size
+}
diff --git a/okhttp/src/main/java/okhttp3/Dns.java b/okhttp/src/main/java/okhttp3/Dns.java
deleted file mode 100644
index feba0db7c9..0000000000
--- a/okhttp/src/main/java/okhttp3/Dns.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * A domain name service that resolves IP addresses for host names. Most applications will use the
- * {@linkplain #SYSTEM system DNS service}, which is the default. Some applications may provide
- * their own implementation to use a different DNS server, to prefer IPv6 addresses, to prefer IPv4
- * addresses, or to force a specific known IP address.
- *
- * <p>Implementations of this interface must be safe for concurrent use.
- */
-public interface Dns {
-  /**
-   * A DNS that uses {@link InetAddress#getAllByName} to ask the underlying operating system to
-   * lookup IP addresses. Most custom {@link Dns} implementations should delegate to this instance.
-   */
-  Dns SYSTEM = hostname -> {
-    if (hostname == null) throw new UnknownHostException("hostname == null");
-    try {
-      return Arrays.asList(InetAddress.getAllByName(hostname));
-    } catch (NullPointerException e) {
-      UnknownHostException unknownHostException =
-          new UnknownHostException("Broken system behaviour for dns lookup of " + hostname);
-      unknownHostException.initCause(e);
-      throw unknownHostException;
-    }
-  };
-
-  /**
-   * Returns the IP addresses of {@code hostname}, in the order they will be attempted by OkHttp. If
-   * a connection to an address fails, OkHttp will retry the connection with the next address until
-   * either a connection is made, the set of IP addresses is exhausted, or a limit is exceeded.
-   */
-  List<InetAddress> lookup(String hostname) throws UnknownHostException;
-}
diff --git a/okhttp/src/main/java/okhttp3/Dns.kt b/okhttp/src/main/java/okhttp3/Dns.kt
new file mode 100644
index 0000000000..4aef7fd93b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Dns.kt
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.Dns.Companion.SYSTEM
+import java.net.InetAddress
+import java.net.UnknownHostException
+
+/**
+ * A domain name service that resolves IP addresses for host names. Most applications will use the
+ * [system DNS service][SYSTEM], which is the default. Some applications may provide their own
+ * implementation to use a different DNS server, to prefer IPv6 addresses, to prefer IPv4 addresses,
+ * or to force a specific known IP address.
+ *
+ * Implementations of this interface must be safe for concurrent use.
+ */
+interface Dns {
+  /**
+   * Returns the IP addresses of `hostname`, in the order they will be attempted by OkHttp. If a
+   * connection to an address fails, OkHttp will retry the connection with the next address until
+   * either a connection is made, the set of IP addresses is exhausted, or a limit is exceeded.
+   */
+  @Throws(UnknownHostException::class)
+  fun lookup(hostname: String): List<InetAddress>
+
+  companion object {
+    /**
+     * A DNS that uses [InetAddress.getAllByName] to ask the underlying operating system to
+     * lookup IP addresses. Most custom [Dns] implementations should delegate to this instance.
+     */
+    @JvmField
+    val SYSTEM = object : Dns {
+      override fun lookup(hostname: String): List<InetAddress> {
+        try {
+          return InetAddress.getAllByName(hostname).toList()
+        } catch (e: NullPointerException) {
+          val unknownHostException = UnknownHostException(
+              "Broken system behaviour for dns lookup of $hostname")
+          unknownHostException.initCause(e)
+          throw unknownHostException
+        }
+      }
+    }
+
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName("-deprecated_Dns")
+    inline operator fun invoke(
+      crossinline block: (String) -> List<InetAddress>
+    ): Dns = object : Dns {
+      override fun lookup(hostname: String): List<InetAddress> = block(hostname)
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/EventListener.java b/okhttp/src/main/java/okhttp3/EventListener.java
deleted file mode 100644
index bdd9f050c5..0000000000
--- a/okhttp/src/main/java/okhttp3/EventListener.java
+++ /dev/null
@@ -1,289 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.util.List;
-import javax.annotation.Nullable;
-
-/**
- * Listener for metrics events. Extend this class to monitor the quantity, size, and duration of
- * your application's HTTP calls.
- *
- * <p>All start/connect/acquire events will eventually receive a matching end/release event,
- * either successful (non-null parameters), or failed (non-null throwable).  The first common
- * parameters of each event pair are used to link the event in case of concurrent or repeated
- * events e.g. dnsStart(call, domainName) -&gt; dnsEnd(call, domainName, inetAddressList).
- *
- * <p>Nesting is as follows
- * <ul>
- *   <li>call -&gt; (dns -&gt; connect -&gt; secure connect)* -&gt; request events</li>
- *   <li>call -&gt; (connection acquire/release)*</li>
- * </ul>
- *
- * <p>Request events are ordered:
- * requestHeaders -&gt; requestBody -&gt; responseHeaders -&gt; responseBody
- *
- * <p>Since connections may be reused, the dns and connect events may not be present for a call,
- * or may be repeated in case of failure retries, even concurrently in case of happy eyeballs type
- * scenarios. A redirect cross domain, or to use https may cause additional connection and request
- * events.
- *
- * <p>All event methods must execute fast, without external locking, cannot throw exceptions,
- * attempt to mutate the event parameters, or be reentrant back into the client.
- * Any IO - writing to files or network should be done asynchronously.
- */
-public abstract class EventListener {
-  public static final EventListener NONE = new EventListener() {
-  };
-
-  static EventListener.Factory factory(EventListener listener) {
-    return call -> listener;
-  }
-
-  /**
-   * Invoked as soon as a call is enqueued or executed by a client. In case of thread or stream
-   * limits, this call may be executed well before processing the request is able to begin.
-   *
-   * <p>This will be invoked only once for a single {@link Call}. Retries of different routes
-   * or redirects will be handled within the boundaries of a single callStart and {@link
-   * #callEnd}/{@link #callFailed} pair.
-   */
-  public void callStart(Call call) {
-  }
-
-  /**
-   * Invoked just prior to a DNS lookup. See {@link Dns#lookup(String)}.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different host.
-   *
-   * <p>If the {@link Call} is able to reuse an existing pooled connection, this method will not be
-   * invoked. See {@link ConnectionPool}.
-   */
-  public void dnsStart(Call call, String domainName) {
-  }
-
-  /**
-   * Invoked immediately after a DNS lookup.
-   *
-   * <p>This method is invoked after {@link #dnsStart}.
-   */
-  public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
-  }
-
-  /**
-   * Invoked just prior to initiating a socket connection.
-   *
-   * <p>This method will be invoked if no existing connection in the {@link ConnectionPool} can be
-   * reused.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address, or a connection is retried.
-   */
-  public void connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
-  }
-
-  /**
-   * Invoked just prior to initiating a TLS connection.
-   *
-   * <p>This method is invoked if the following conditions are met:
-   * <ul>
-   * <li>The {@link Call#request()} requires TLS.</li>
-   * <li>No existing connection from the {@link ConnectionPool} can be reused.</li>
-   * </ul>
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address, or a connection is retried.
-   */
-  public void secureConnectStart(Call call) {
-  }
-
-  /**
-   * Invoked immediately after a TLS connection was attempted.
-   *
-   * <p>This method is invoked after {@link #secureConnectStart}.
-   */
-  public void secureConnectEnd(Call call, @Nullable Handshake handshake) {
-  }
-
-  /**
-   * Invoked immediately after a socket connection was attempted.
-   *
-   * <p>If the {@code call} uses HTTPS, this will be invoked after
-   * {@link #secureConnectEnd(Call, Handshake)}, otherwise it will invoked after
-   * {@link #connectStart(Call, InetSocketAddress, Proxy)}.
-   */
-  public void connectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
-      @Nullable Protocol protocol) {
-  }
-
-  /**
-   * Invoked when a connection attempt fails. This failure is not terminal if further routes are
-   * available and failure recovery is enabled.
-   *
-   * <p>If the {@code call} uses HTTPS, this will be invoked after {@link #secureConnectEnd(Call,
-   * Handshake)}, otherwise it will invoked after {@link #connectStart(Call, InetSocketAddress,
-   * Proxy)}.
-   */
-  public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
-      @Nullable Protocol protocol, IOException ioe) {
-  }
-
-  /**
-   * Invoked after a connection has been acquired for the {@code call}.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address.
-   */
-  public void connectionAcquired(Call call, Connection connection) {
-  }
-
-  /**
-   * Invoked after a connection has been released for the {@code call}.
-   *
-   * <p>This method is always invoked after {@link #connectionAcquired(Call, Connection)}.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address.
-   */
-  public void connectionReleased(Call call, Connection connection) {
-  }
-
-  /**
-   * Invoked just prior to sending request headers.
-   *
-   * <p>The connection is implicit, and will generally relate to the last
-   * {@link #connectionAcquired(Call, Connection)} event.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address.
-   */
-  public void requestHeadersStart(Call call) {
-  }
-
-  /**
-   * Invoked immediately after sending request headers.
-   *
-   * <p>This method is always invoked after {@link #requestHeadersStart(Call)}.
-   *
-   * @param request the request sent over the network. It is an error to access the body of this
-   *     request.
-   */
-  public void requestHeadersEnd(Call call, Request request) {
-  }
-
-  /**
-   * Invoked just prior to sending a request body.  Will only be invoked for request allowing and
-   * having a request body to send.
-   *
-   * <p>The connection is implicit, and will generally relate to the last
-   * {@link #connectionAcquired(Call, Connection)} event.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address.
-   */
-  public void requestBodyStart(Call call) {
-  }
-
-  /**
-   * Invoked immediately after sending a request body.
-   *
-   * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
-   */
-  public void requestBodyEnd(Call call, long byteCount) {
-  }
-
-  /**
-   * Invoked just prior to receiving response headers.
-   *
-   * <p>The connection is implicit, and will generally relate to the last
-   * {@link #connectionAcquired(Call, Connection)} event.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address.
-   */
-  public void responseHeadersStart(Call call) {
-  }
-
-  /**
-   * Invoked immediately after receiving response headers.
-   *
-   * <p>This method is always invoked after {@link #responseHeadersStart}.
-   *
-   * @param response the response received over the network. It is an error to access the body of
-   *     this response.
-   */
-  public void responseHeadersEnd(Call call, Response response) {
-  }
-
-  /**
-   * Invoked just prior to receiving the response body.
-   *
-   * <p>The connection is implicit, and will generally relate to the last
-   * {@link #connectionAcquired(Call, Connection)} event.
-   *
-   * <p>This will usually be invoked only 1 time for a single {@link Call},
-   * exceptions are a limited set of cases including failure recovery.
-   */
-  public void responseBodyStart(Call call) {
-  }
-
-  /**
-   * Invoked immediately after receiving a response body and completing reading it.
-   *
-   * <p>Will only be invoked for requests having a response body e.g. won't be invoked for a
-   * websocket upgrade.
-   *
-   * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
-   */
-  public void responseBodyEnd(Call call, long byteCount) {
-  }
-
-  /**
-   * Invoked immediately after a call has completely ended.  This includes delayed consumption
-   * of response body by the caller.
-   *
-   * <p>This method is always invoked after {@link #callStart(Call)}.
-   */
-  public void callEnd(Call call) {
-  }
-
-  /**
-   * Invoked when a call fails permanently.
-   *
-   * <p>This method is always invoked after {@link #callStart(Call)}.
-   */
-  public void callFailed(Call call, IOException ioe) {
-  }
-
-  public interface Factory {
-    /**
-     * Creates an instance of the {@link EventListener} for a particular {@link Call}. The returned
-     * {@link EventListener} instance will be used during the lifecycle of the {@code call}.
-     *
-     * <p>This method is invoked after the {@code call} is created. See
-     * {@link OkHttpClient#newCall(Request)}.
-     *
-     * <p><strong>It is an error for implementations to issue any mutating operations on the
-     * {@code call} instance from this method.</strong>
-     */
-    EventListener create(Call call);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/EventListener.kt b/okhttp/src/main/java/okhttp3/EventListener.kt
new file mode 100644
index 0000000000..169174c13b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/EventListener.kt
@@ -0,0 +1,366 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.io.IOException
+import java.net.InetAddress
+import java.net.InetSocketAddress
+import java.net.Proxy
+
+/**
+ * Listener for metrics events. Extend this class to monitor the quantity, size, and duration of
+ * your application's HTTP calls.
+ *
+ * All start/connect/acquire events will eventually receive a matching end/release event, either
+ * successful (non-null parameters), or failed (non-null throwable).  The first common parameters of
+ * each event pair are used to link the event in case of concurrent or repeated events e.g.
+ * dnsStart(call, domainName) -&gt; dnsEnd(call, domainName, inetAddressList).
+ *
+ * Nesting is as follows
+ *
+ *  * call -&gt; (dns -&gt; connect -&gt; secure connect)* -&gt; request events
+ *  * call -&gt; (connection acquire/release)*
+ *
+ * Request events are ordered:
+ *
+ * requestHeaders -&gt; requestBody -&gt; responseHeaders -&gt; responseBody
+ *
+ * Since connections may be reused, the dns and connect events may not be present for a call, or may
+ * be repeated in case of failure retries, even concurrently in case of happy eyeballs type
+ * scenarios. A redirect cross domain, or to use https may cause additional connection and request
+ * events.
+ *
+ * All event methods must execute fast, without external locking, cannot throw exceptions, attempt
+ * to mutate the event parameters, or be re-entrant back into the client. Any IO - writing to files
+ * or network should be done asynchronously.
+ */
+abstract class EventListener {
+  /**
+   * Invoked as soon as a call is enqueued or executed by a client. In case of thread or stream
+   * limits, this call may be executed well before processing the request is able to begin.
+   *
+   * This will be invoked only once for a single [Call]. Retries of different routes or redirects
+   * will be handled within the boundaries of a single [callStart] and [callEnd]/[callFailed] pair.
+   */
+  open fun callStart(
+    call: Call
+  ) {
+  }
+
+  /**
+   * Invoked just prior to a DNS lookup. See [Dns.lookup].
+   *
+   * This can be invoked more than 1 time for a single [Call]. For example, if the response to the
+   * [Call.request] is a redirect to a different host.
+   *
+   * If the [Call] is able to reuse an existing pooled connection, this method will not be invoked.
+   * See [ConnectionPool].
+   */
+  open fun dnsStart(
+    call: Call,
+    domainName: String
+  ) {
+  }
+
+  /**
+   * Invoked immediately after a DNS lookup.
+   *
+   * This method is invoked after [dnsStart].
+   */
+  open fun dnsEnd(
+    call: Call,
+    domainName: String,
+    inetAddressList: List<@JvmSuppressWildcards InetAddress>
+  ) {
+  }
+
+  /**
+   * Invoked just prior to initiating a socket connection.
+   *
+   * This method will be invoked if no existing connection in the [ConnectionPool] can be reused.
+   *
+   * This can be invoked more than 1 time for a single [Call]. For example, if the response to the
+   * [Call.request] is a redirect to a different address, or a connection is retried.
+   */
+  open fun connectStart(
+    call: Call,
+    inetSocketAddress: InetSocketAddress,
+    proxy: Proxy
+  ) {
+  }
+
+  /**
+   * Invoked just prior to initiating a TLS connection.
+   *
+   * This method is invoked if the following conditions are met:
+   *
+   *  * The [Call.request] requires TLS.
+   *
+   *  * No existing connection from the [ConnectionPool] can be reused.
+   *
+   * This can be invoked more than 1 time for a single [Call]. For example, if the response to the
+   * [Call.request] is a redirect to a different address, or a connection is retried.
+   */
+  open fun secureConnectStart(
+    call: Call
+  ) {
+  }
+
+  /**
+   * Invoked immediately after a TLS connection was attempted.
+   *
+   * This method is invoked after [secureConnectStart].
+   */
+  open fun secureConnectEnd(
+    call: Call,
+    handshake: Handshake?
+  ) {
+  }
+
+  /**
+   * Invoked immediately after a socket connection was attempted.
+   *
+   * If the `call` uses HTTPS, this will be invoked after [secureConnectEnd], otherwise it will
+   * invoked after [connectStart].
+   */
+  open fun connectEnd(
+    call: Call,
+    inetSocketAddress: InetSocketAddress,
+    proxy: Proxy,
+    protocol: Protocol?
+  ) {
+  }
+
+  /**
+   * Invoked when a connection attempt fails. This failure is not terminal if further routes are
+   * available and failure recovery is enabled.
+   *
+   * If the `call` uses HTTPS, this will be invoked after [secureConnectEnd], otherwise it will
+   * invoked after [connectStart].
+   */
+  open fun connectFailed(
+    call: Call,
+    inetSocketAddress: InetSocketAddress,
+    proxy: Proxy,
+    protocol: Protocol?,
+    ioe: IOException
+  ) {
+  }
+
+  /**
+   * Invoked after a connection has been acquired for the `call`.
+   *
+   * This can be invoked more than 1 time for a single [Call]. For example, if the response
+   * to the [Call.request] is a redirect to a different address.
+   */
+  open fun connectionAcquired(
+    call: Call,
+    connection: Connection
+  ) {
+  }
+
+  /**
+   * Invoked after a connection has been released for the `call`.
+   *
+   * This method is always invoked after [connectionAcquired].
+   *
+   * This can be invoked more than 1 time for a single [Call]. For example, if the response to the
+   * [Call.request] is a redirect to a different address.
+   */
+  open fun connectionReleased(
+    call: Call,
+    connection: Connection
+  ) {
+  }
+
+  /**
+   * Invoked just prior to sending request headers.
+   *
+   * The connection is implicit, and will generally relate to the last [connectionAcquired] event.
+   *
+   * This can be invoked more than 1 time for a single [Call]. For example, if the response to the
+   * [Call.request] is a redirect to a different address.
+   */
+  open fun requestHeadersStart(
+    call: Call
+  ) {
+  }
+
+  /**
+   * Invoked immediately after sending request headers.
+   *
+   * This method is always invoked after [requestHeadersStart].
+   *
+   * @param request the request sent over the network. It is an error to access the body of this
+   *     request.
+   */
+  open fun requestHeadersEnd(call: Call, request: Request) {
+  }
+
+  /**
+   * Invoked just prior to sending a request body.  Will only be invoked for request allowing and
+   * having a request body to send.
+   *
+   * The connection is implicit, and will generally relate to the last [connectionAcquired] event.
+   *
+   * This can be invoked more than 1 time for a single [Call]. For example, if the response to the
+   * [Call.request] is a redirect to a different address.
+   */
+  open fun requestBodyStart(
+    call: Call
+  ) {
+  }
+
+  /**
+   * Invoked immediately after sending a request body.
+   *
+   * This method is always invoked after [requestBodyStart].
+   */
+  open fun requestBodyEnd(
+    call: Call,
+    byteCount: Long
+  ) {
+  }
+
+  /**
+   * Invoked when a request fails to be written.
+   *
+   * This method is invoked after [requestHeadersStart] or [requestBodyStart]. Note that request
+   * failures do not necessarily fail the entire call.
+   */
+  open fun requestFailed(
+    call: Call,
+    ioe: IOException
+  ) {
+  }
+
+  /**
+   * Invoked just prior to receiving response headers.
+   *
+   * The connection is implicit, and will generally relate to the last [connectionAcquired] event.
+   *
+   * This can be invoked more than 1 time for a single [Call]. For example, if the response to the
+   * [Call.request] is a redirect to a different address.
+   */
+  open fun responseHeadersStart(
+    call: Call
+  ) {
+  }
+
+  /**
+   * Invoked immediately after receiving response headers.
+   *
+   * This method is always invoked after [responseHeadersStart].
+   *
+   * @param response the response received over the network. It is an error to access the body of
+   *     this response.
+   */
+  open fun responseHeadersEnd(
+    call: Call,
+    response: Response
+  ) {
+  }
+
+  /**
+   * Invoked just prior to receiving the response body.
+   *
+   * The connection is implicit, and will generally relate to the last [connectionAcquired] event.
+   *
+   * This will usually be invoked only 1 time for a single [Call], exceptions are a limited set of
+   * cases including failure recovery.
+   */
+  open fun responseBodyStart(
+    call: Call
+  ) {
+  }
+
+  /**
+   * Invoked immediately after receiving a response body and completing reading it.
+   *
+   * Will only be invoked for requests having a response body e.g. won't be invoked for a web socket
+   * upgrade.
+   *
+   * This method is always invoked after [requestBodyStart].
+   */
+  open fun responseBodyEnd(
+    call: Call,
+    byteCount: Long
+  ) {
+  }
+
+  /**
+   * Invoked when a response fails to be read.
+   *
+   * This method is invoked after [responseHeadersStart] or [responseBodyStart]. Note that response
+   * failures do not necessarily fail the entire call.
+   */
+  open fun responseFailed(
+    call: Call,
+    ioe: IOException
+  ) {
+  }
+
+  /**
+   * Invoked immediately after a call has completely ended.  This includes delayed consumption
+   * of response body by the caller.
+   *
+   * This method is always invoked after [callStart].
+   */
+  open fun callEnd(
+    call: Call
+  ) {
+  }
+
+  /**
+   * Invoked when a call fails permanently.
+   *
+   * This method is always invoked after [callStart].
+   */
+  open fun callFailed(
+    call: Call,
+    ioe: IOException
+  ) {
+  }
+
+  interface Factory {
+    /**
+     * Creates an instance of the [EventListener] for a particular [Call]. The returned
+     * [EventListener] instance will be used during the lifecycle of the `call`.
+     *
+     * This method is invoked after the `call` is created. See [OkHttpClient.newCall].
+     *
+     * **It is an error for implementations to issue any mutating operations on the `call` instance
+     * from this method.**
+     */
+    fun create(call: Call): EventListener
+
+    companion object {
+      // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+      @JvmName("-deprecated_Factory")
+      inline operator fun invoke(
+        crossinline block: (call: Call) -> EventListener
+      ): Factory = object : Factory {
+        override fun create(call: Call) = block(call)
+      }
+    }
+  }
+
+  companion object {
+    @JvmField
+    val NONE: EventListener = object : EventListener() {
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
deleted file mode 100644
index 4216daccd5..0000000000
--- a/okhttp/src/main/java/okhttp3/FormBody.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.List;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSink;
-
-import static okhttp3.HttpUrl.FORM_ENCODE_SET;
-import static okhttp3.HttpUrl.percentDecode;
-
-public final class FormBody extends RequestBody {
-  private static final MediaType CONTENT_TYPE = MediaType.get("application/x-www-form-urlencoded");
-
-  private final List<String> encodedNames;
-  private final List<String> encodedValues;
-
-  FormBody(List<String> encodedNames, List<String> encodedValues) {
-    this.encodedNames = Util.immutableList(encodedNames);
-    this.encodedValues = Util.immutableList(encodedValues);
-  }
-
-  /** The number of key-value pairs in this form-encoded body. */
-  public int size() {
-    return encodedNames.size();
-  }
-
-  public String encodedName(int index) {
-    return encodedNames.get(index);
-  }
-
-  public String name(int index) {
-    return percentDecode(encodedName(index), true);
-  }
-
-  public String encodedValue(int index) {
-    return encodedValues.get(index);
-  }
-
-  public String value(int index) {
-    return percentDecode(encodedValue(index), true);
-  }
-
-  @Override public MediaType contentType() {
-    return CONTENT_TYPE;
-  }
-
-  @Override public long contentLength() {
-    return writeOrCountBytes(null, true);
-  }
-
-  @Override public void writeTo(BufferedSink sink) throws IOException {
-    writeOrCountBytes(sink, false);
-  }
-
-  /**
-   * Either writes this request to {@code sink} or measures its content length. We have one method
-   * do double-duty to make sure the counting and content are consistent, particularly when it comes
-   * to awkward operations like measuring the encoded length of header strings, or the
-   * length-in-digits of an encoded integer.
-   */
-  private long writeOrCountBytes(@Nullable BufferedSink sink, boolean countBytes) {
-    long byteCount = 0L;
-
-    Buffer buffer;
-    if (countBytes) {
-      buffer = new Buffer();
-    } else {
-      buffer = sink.buffer();
-    }
-
-    for (int i = 0, size = encodedNames.size(); i < size; i++) {
-      if (i > 0) buffer.writeByte('&');
-      buffer.writeUtf8(encodedNames.get(i));
-      buffer.writeByte('=');
-      buffer.writeUtf8(encodedValues.get(i));
-    }
-
-    if (countBytes) {
-      byteCount = buffer.size();
-      buffer.clear();
-    }
-
-    return byteCount;
-  }
-
-  public static final class Builder {
-    private final List<String> names = new ArrayList<>();
-    private final List<String> values = new ArrayList<>();
-    private final @Nullable Charset charset;
-
-    public Builder() {
-      this(null);
-    }
-
-    public Builder(@Nullable Charset charset) {
-      this.charset = charset;
-    }
-
-    public Builder add(String name, String value) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (value == null) throw new NullPointerException("value == null");
-
-      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true, charset));
-      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true, charset));
-      return this;
-    }
-
-    public Builder addEncoded(String name, String value) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (value == null) throw new NullPointerException("value == null");
-
-      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true, charset));
-      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true, charset));
-      return this;
-    }
-
-    public FormBody build() {
-      return new FormBody(names, values);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/FormBody.kt b/okhttp/src/main/java/okhttp3/FormBody.kt
new file mode 100644
index 0000000000..cef74278bc
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/FormBody.kt
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.HttpUrl.Companion.FORM_ENCODE_SET
+import okhttp3.HttpUrl.Companion.percentDecode
+import okhttp3.internal.Util
+import okio.Buffer
+import okio.BufferedSink
+import java.io.IOException
+import java.nio.charset.Charset
+
+class FormBody internal constructor(
+  encodedNames: List<String>,
+  encodedValues: List<String>
+) : RequestBody() {
+  private val encodedNames: List<String> = Util.immutableList(encodedNames)
+  private val encodedValues: List<String> = Util.immutableList(encodedValues)
+
+  /** The number of key-value pairs in this form-encoded body.  */
+  fun size(): Int = encodedNames.size
+
+  fun encodedName(index: Int) = encodedNames[index]
+
+  fun name(index: Int) = percentDecode(encodedName(index), true)
+
+  fun encodedValue(index: Int) = encodedValues[index]
+
+  fun value(index: Int) = percentDecode(encodedValue(index), true)
+
+  override fun contentType() = CONTENT_TYPE
+
+  override fun contentLength() = writeOrCountBytes(null, true)
+
+  @Throws(IOException::class)
+  override fun writeTo(sink: BufferedSink) {
+    writeOrCountBytes(sink, false)
+  }
+
+  /**
+   * Either writes this request to `sink` or measures its content length. We have one method
+   * do double-duty to make sure the counting and content are consistent, particularly when it comes
+   * to awkward operations like measuring the encoded length of header strings, or the
+   * length-in-digits of an encoded integer.
+   */
+  private fun writeOrCountBytes(sink: BufferedSink?, countBytes: Boolean): Long {
+    var byteCount = 0L
+    val buffer: Buffer = if (countBytes) Buffer() else sink!!.buffer
+
+    for (i in 0 until encodedNames.size) {
+      if (i > 0) buffer.writeByte('&'.toInt())
+      buffer.writeUtf8(encodedNames[i])
+      buffer.writeByte('='.toInt())
+      buffer.writeUtf8(encodedValues[i])
+    }
+
+    if (countBytes) {
+      byteCount = buffer.size
+      buffer.clear()
+    }
+
+    return byteCount
+  }
+
+  class Builder @JvmOverloads constructor(private val charset: Charset? = null) {
+    private val names = mutableListOf<String>()
+    private val values = mutableListOf<String>()
+
+    fun add(name: String, value: String) = apply {
+      names += HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true, charset)
+      values += HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true, charset)
+    }
+
+    fun addEncoded(name: String, value: String) = apply {
+      names += HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true, charset)
+      values += HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true, charset)
+    }
+
+    fun build(): FormBody = FormBody(names, values)
+  }
+
+  companion object {
+    private val CONTENT_TYPE: MediaType = MediaType.get("application/x-www-form-urlencoded")
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Handshake.java b/okhttp/src/main/java/okhttp3/Handshake.java
deleted file mode 100644
index d2740c8f87..0000000000
--- a/okhttp/src/main/java/okhttp3/Handshake.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import okhttp3.internal.Util;
-
-/**
- * A record of a TLS handshake. For HTTPS clients, the client is <i>local</i> and the remote server
- * is its <i>peer</i>.
- *
- * <p>This value object describes a completed handshake. Use {@link ConnectionSpec} to set policy
- * for new handshakes.
- */
-public final class Handshake {
-  private final TlsVersion tlsVersion;
-  private final CipherSuite cipherSuite;
-  private final List<Certificate> peerCertificates;
-  private final List<Certificate> localCertificates;
-
-  private Handshake(TlsVersion tlsVersion, CipherSuite cipherSuite,
-      List<Certificate> peerCertificates, List<Certificate> localCertificates) {
-    this.tlsVersion = tlsVersion;
-    this.cipherSuite = cipherSuite;
-    this.peerCertificates = peerCertificates;
-    this.localCertificates = localCertificates;
-  }
-
-  public static Handshake get(SSLSession session) throws IOException {
-    String cipherSuiteString = session.getCipherSuite();
-    if (cipherSuiteString == null) throw new IllegalStateException("cipherSuite == null");
-    if ("SSL_NULL_WITH_NULL_NULL".equals(cipherSuiteString)) {
-      throw new IOException("cipherSuite == SSL_NULL_WITH_NULL_NULL");
-    }
-    CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-
-    String tlsVersionString = session.getProtocol();
-    if (tlsVersionString == null) throw new IllegalStateException("tlsVersion == null");
-    if ("NONE".equals(tlsVersionString)) throw new IOException("tlsVersion == NONE");
-    TlsVersion tlsVersion = TlsVersion.forJavaName(tlsVersionString);
-
-    Certificate[] peerCertificates;
-    try {
-      peerCertificates = session.getPeerCertificates();
-    } catch (SSLPeerUnverifiedException ignored) {
-      peerCertificates = null;
-    }
-    List<Certificate> peerCertificatesList = peerCertificates != null
-        ? Util.immutableList(peerCertificates)
-        : Collections.emptyList();
-
-    Certificate[] localCertificates = session.getLocalCertificates();
-    List<Certificate> localCertificatesList = localCertificates != null
-        ? Util.immutableList(localCertificates)
-        : Collections.emptyList();
-
-    return new Handshake(tlsVersion, cipherSuite, peerCertificatesList, localCertificatesList);
-  }
-
-  public static Handshake get(TlsVersion tlsVersion, CipherSuite cipherSuite,
-      List<Certificate> peerCertificates, List<Certificate> localCertificates) {
-    if (tlsVersion == null) throw new NullPointerException("tlsVersion == null");
-    if (cipherSuite == null) throw new NullPointerException("cipherSuite == null");
-    return new Handshake(tlsVersion, cipherSuite, Util.immutableList(peerCertificates),
-        Util.immutableList(localCertificates));
-  }
-
-  /**
-   * Returns the TLS version used for this connection. This value wasn't tracked prior to OkHttp
-   * 3.0. For responses cached by preceding versions this returns {@link TlsVersion#SSL_3_0}.
-   */
-  public TlsVersion tlsVersion() {
-    return tlsVersion;
-  }
-
-  /** Returns the cipher suite used for the connection. */
-  public CipherSuite cipherSuite() {
-    return cipherSuite;
-  }
-
-  /** Returns a possibly-empty list of certificates that identify the remote peer. */
-  public List<Certificate> peerCertificates() {
-    return peerCertificates;
-  }
-
-  /** Returns the remote peer's principle, or null if that peer is anonymous. */
-  public @Nullable Principal peerPrincipal() {
-    return !peerCertificates.isEmpty()
-        ? ((X509Certificate) peerCertificates.get(0)).getSubjectX500Principal()
-        : null;
-  }
-
-  /** Returns a possibly-empty list of certificates that identify this peer. */
-  public List<Certificate> localCertificates() {
-    return localCertificates;
-  }
-
-  /** Returns the local principle, or null if this peer is anonymous. */
-  public @Nullable Principal localPrincipal() {
-    return !localCertificates.isEmpty()
-        ? ((X509Certificate) localCertificates.get(0)).getSubjectX500Principal()
-        : null;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    if (!(other instanceof Handshake)) return false;
-    Handshake that = (Handshake) other;
-    return tlsVersion.equals(that.tlsVersion)
-        && cipherSuite.equals(that.cipherSuite)
-        && peerCertificates.equals(that.peerCertificates)
-        && localCertificates.equals(that.localCertificates);
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + tlsVersion.hashCode();
-    result = 31 * result + cipherSuite.hashCode();
-    result = 31 * result + peerCertificates.hashCode();
-    result = 31 * result + localCertificates.hashCode();
-    return result;
-  }
-
-  @Override public String toString() {
-    return "Handshake{"
-        + "tlsVersion="
-        + tlsVersion
-        + " cipherSuite="
-        + cipherSuite
-        + " peerCertificates="
-        + names(peerCertificates)
-        + " localCertificates="
-        + names(localCertificates)
-        + '}';
-  }
-
-  private List<String> names(List<Certificate> certificates) {
-    ArrayList<String> strings = new ArrayList<>();
-
-    for (Certificate cert : certificates) {
-      if (cert instanceof X509Certificate) {
-        strings.add(String.valueOf(((X509Certificate) cert).getSubjectDN()));
-      } else {
-        strings.add(cert.getType());
-      }
-    }
-
-    return strings;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Handshake.kt b/okhttp/src/main/java/okhttp3/Handshake.kt
new file mode 100644
index 0000000000..edc6e3ebf1
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Handshake.kt
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.Util
+import java.io.IOException
+import java.security.Principal
+import java.security.cert.Certificate
+import java.security.cert.X509Certificate
+import javax.net.ssl.SSLPeerUnverifiedException
+import javax.net.ssl.SSLSession
+
+/**
+ * A record of a TLS handshake. For HTTPS clients, the client is *local* and the remote server
+ * is its *peer*.
+ *
+ * This value object describes a completed handshake. Use [ConnectionSpec] to set policy
+ * for new handshakes.
+ */
+data class Handshake private constructor(
+  private val tlsVersion: TlsVersion,
+  private val cipherSuite: CipherSuite,
+  private val peerCertificates: List<Certificate>,
+  private val localCertificates: List<Certificate>
+) {
+
+  /**
+   * Returns the TLS version used for this connection. This value wasn't tracked prior to OkHttp
+   * 3.0. For responses cached by preceding versions this returns [TlsVersion.SSL_3_0].
+   */
+  fun tlsVersion() = tlsVersion
+
+  /** Returns the cipher suite used for the connection. */
+  fun cipherSuite() = cipherSuite
+
+  /** Returns a possibly-empty list of certificates that identify the remote peer. */
+  fun peerCertificates() = peerCertificates
+
+  /** Returns the remote peer's principle, or null if that peer is anonymous. */
+  fun peerPrincipal(): Principal? {
+    return if (peerCertificates.isNotEmpty()) {
+      (peerCertificates[0] as X509Certificate).subjectX500Principal
+    } else {
+      null
+    }
+  }
+
+  /** Returns a possibly-empty list of certificates that identify this peer. */
+  fun localCertificates() = localCertificates
+
+  /** Returns the local principle, or null if this peer is anonymous. */
+  fun localPrincipal(): Principal? {
+    return if (localCertificates.isNotEmpty()) {
+      (localCertificates[0] as X509Certificate).subjectX500Principal
+    } else {
+      null
+    }
+  }
+
+  override fun toString(): String {
+    return "Handshake{" +
+        "tlsVersion=$tlsVersion " +
+        "cipherSuite=$cipherSuite " +
+        "peerCertificates=${peerCertificates.map { it.name }} " +
+        "localCertificates=${localCertificates.map { it.name }}}"
+  }
+
+  private val Certificate.name: String
+    get() = when (this) {
+      is X509Certificate -> subjectDN.toString()
+      else -> type
+    }
+
+  companion object {
+    @Throws(IOException::class)
+    @JvmStatic
+    fun get(session: SSLSession): Handshake {
+      val cipherSuiteString = checkNotNull(session.cipherSuite) { "cipherSuite == null" }
+      if ("SSL_NULL_WITH_NULL_NULL" == cipherSuiteString) {
+        throw IOException("cipherSuite == SSL_NULL_WITH_NULL_NULL")
+      }
+      val cipherSuite = CipherSuite.forJavaName(cipherSuiteString)
+
+      val tlsVersionString = session.protocol ?: throw IllegalStateException("tlsVersion == null")
+      if ("NONE" == tlsVersionString) throw IOException("tlsVersion == NONE")
+      val tlsVersion = TlsVersion.forJavaName(tlsVersionString)
+
+      val peerCertificates: Array<Certificate>? = try {
+        session.peerCertificates
+      } catch (ignored: SSLPeerUnverifiedException) {
+        null
+      }
+
+      val peerCertificatesList = if (peerCertificates != null) {
+        Util.immutableList(*peerCertificates)
+      } else {
+        emptyList()
+      }
+
+      val localCertificates = session.localCertificates
+      val localCertificatesList = if (localCertificates != null) {
+        Util.immutableList(*localCertificates)
+      } else {
+        emptyList()
+      }
+
+      return Handshake(tlsVersion, cipherSuite, peerCertificatesList, localCertificatesList)
+    }
+
+    @JvmStatic
+    fun get(
+      tlsVersion: TlsVersion,
+      cipherSuite: CipherSuite,
+      peerCertificates: List<Certificate>,
+      localCertificates: List<Certificate>
+    ): Handshake {
+      return Handshake(tlsVersion, cipherSuite, Util.immutableList(peerCertificates),
+          Util.immutableList(localCertificates))
+    }
+  }
+}
\ No newline at end of file
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
deleted file mode 100644
index 06d2a96ccd..0000000000
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ /dev/null
@@ -1,435 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package okhttp3;
-
-import java.time.Instant;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeMap;
-import java.util.TreeSet;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpDate;
-import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
-
-/**
- * The header fields of a single HTTP message. Values are uninterpreted strings; use {@code Request}
- * and {@code Response} for interpreted headers. This class maintains the order of the header fields
- * within the HTTP message.
- *
- * <p>This class tracks header values line-by-line. A field with multiple comma- separated values on
- * the same line will be treated as a field with a single value by this class. It is the caller's
- * responsibility to detect and split on commas if their field permits multiple values. This
- * simplifies use of single-valued fields whose values routinely contain commas, such as cookies or
- * dates.
- *
- * <p>This class trims whitespace from values. It never returns values with leading or trailing
- * whitespace.
- *
- * <p>Instances of this class are immutable. Use {@link Builder} to create instances.
- */
-public final class Headers {
-  private final String[] namesAndValues;
-
-  Headers(Builder builder) {
-    this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
-  }
-
-  private Headers(String[] namesAndValues) {
-    this.namesAndValues = namesAndValues;
-  }
-
-  /** Returns the last value corresponding to the specified field, or null. */
-  public @Nullable String get(String name) {
-    return get(namesAndValues, name);
-  }
-
-  /**
-   * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
-   * either the field is absent or cannot be parsed as a date.
-   */
-  public @Nullable Date getDate(String name) {
-    String value = get(name);
-    return value != null ? HttpDate.parse(value) : null;
-  }
-
-  /**
-   * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
-   * either the field is absent or cannot be parsed as a date.
-   */
-  @IgnoreJRERequirement
-  public @Nullable Instant getInstant(String name) {
-    Date value = getDate(name);
-    return value != null ? value.toInstant() : null;
-  }
-
-  /** Returns the number of field values. */
-  public int size() {
-    return namesAndValues.length / 2;
-  }
-
-  /** Returns the field at {@code position}. */
-  public String name(int index) {
-    return namesAndValues[index * 2];
-  }
-
-  /** Returns the value at {@code index}. */
-  public String value(int index) {
-    return namesAndValues[index * 2 + 1];
-  }
-
-  /** Returns an immutable case-insensitive set of header names. */
-  public Set<String> names() {
-    TreeSet<String> result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
-    for (int i = 0, size = size(); i < size; i++) {
-      result.add(name(i));
-    }
-    return Collections.unmodifiableSet(result);
-  }
-
-  /** Returns an immutable list of the header values for {@code name}. */
-  public List<String> values(String name) {
-    List<String> result = null;
-    for (int i = 0, size = size(); i < size; i++) {
-      if (name.equalsIgnoreCase(name(i))) {
-        if (result == null) result = new ArrayList<>(2);
-        result.add(value(i));
-      }
-    }
-    return result != null
-        ? Collections.unmodifiableList(result)
-        : Collections.emptyList();
-  }
-
-  /**
-   * Returns the number of bytes required to encode these headers using HTTP/1.1. This is also the
-   * approximate size of HTTP/2 headers before they are compressed with HPACK. This value is
-   * intended to be used as a metric: smaller headers are more efficient to encode and transmit.
-   */
-  public long byteCount() {
-    // Each header name has 2 bytes of overhead for ': ' and every header value has 2 bytes of
-    // overhead for '\r\n'.
-    long result = namesAndValues.length * 2;
-
-    for (int i = 0, size = namesAndValues.length; i < size; i++) {
-      result += namesAndValues[i].length();
-    }
-
-    return result;
-  }
-
-  public Builder newBuilder() {
-    Builder result = new Builder();
-    Collections.addAll(result.namesAndValues, namesAndValues);
-    return result;
-  }
-
-  /**
-   * Returns true if {@code other} is a {@code Headers} object with the same headers, with the same
-   * casing, in the same order. Note that two headers instances may be <i>semantically</i> equal
-   * but not equal according to this method. In particular, none of the following sets of headers
-   * are equal according to this method: <pre>   {@code
-   *
-   *   1. Original
-   *   Content-Type: text/html
-   *   Content-Length: 50
-   *
-   *   2. Different order
-   *   Content-Length: 50
-   *   Content-Type: text/html
-   *
-   *   3. Different case
-   *   content-type: text/html
-   *   content-length: 50
-   *
-   *   4. Different values
-   *   Content-Type: text/html
-   *   Content-Length: 050
-   * }</pre>
-   *
-   * Applications that require semantically equal headers should convert them into a canonical form
-   * before comparing them for equality.
-   */
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof Headers
-        && Arrays.equals(((Headers) other).namesAndValues, namesAndValues);
-  }
-
-  @Override public int hashCode() {
-    return Arrays.hashCode(namesAndValues);
-  }
-
-  @Override public String toString() {
-    StringBuilder result = new StringBuilder();
-    for (int i = 0, size = size(); i < size; i++) {
-      result.append(name(i)).append(": ").append(value(i)).append("\n");
-    }
-    return result.toString();
-  }
-
-  public Map<String, List<String>> toMultimap() {
-    Map<String, List<String>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
-    for (int i = 0, size = size(); i < size; i++) {
-      String name = name(i).toLowerCase(Locale.US);
-      List<String> values = result.get(name);
-      if (values == null) {
-        values = new ArrayList<>(2);
-        result.put(name, values);
-      }
-      values.add(value(i));
-    }
-    return result;
-  }
-
-  private static @Nullable String get(String[] namesAndValues, String name) {
-    for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
-      if (name.equalsIgnoreCase(namesAndValues[i])) {
-        return namesAndValues[i + 1];
-      }
-    }
-    return null;
-  }
-
-  /**
-   * Returns headers for the alternating header names and values. There must be an even number of
-   * arguments, and they must alternate between header names and values.
-   */
-  public static Headers of(String... namesAndValues) {
-    if (namesAndValues == null) throw new NullPointerException("namesAndValues == null");
-    if (namesAndValues.length % 2 != 0) {
-      throw new IllegalArgumentException("Expected alternating header names and values");
-    }
-
-    // Make a defensive copy and clean it up.
-    namesAndValues = namesAndValues.clone();
-    for (int i = 0; i < namesAndValues.length; i++) {
-      if (namesAndValues[i] == null) throw new IllegalArgumentException("Headers cannot be null");
-      namesAndValues[i] = namesAndValues[i].trim();
-    }
-
-    // Check for malformed headers.
-    for (int i = 0; i < namesAndValues.length; i += 2) {
-      String name = namesAndValues[i];
-      String value = namesAndValues[i + 1];
-      checkName(name);
-      checkValue(value, name);
-    }
-
-    return new Headers(namesAndValues);
-  }
-
-  /**
-   * Returns headers for the header names and values in the {@link Map}.
-   */
-  public static Headers of(Map<String, String> headers) {
-    if (headers == null) throw new NullPointerException("headers == null");
-
-    // Make a defensive copy and clean it up.
-    String[] namesAndValues = new String[headers.size() * 2];
-    int i = 0;
-    for (Map.Entry<String, String> header : headers.entrySet()) {
-      if (header.getKey() == null || header.getValue() == null) {
-        throw new IllegalArgumentException("Headers cannot be null");
-      }
-      String name = header.getKey().trim();
-      String value = header.getValue().trim();
-      checkName(name);
-      checkValue(value, name);
-      namesAndValues[i] = name;
-      namesAndValues[i + 1] = value;
-      i += 2;
-    }
-
-    return new Headers(namesAndValues);
-  }
-
-  static void checkName(String name) {
-    if (name == null) throw new NullPointerException("name == null");
-    if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
-    for (int i = 0, length = name.length(); i < length; i++) {
-      char c = name.charAt(i);
-      if (c <= '\u0020' || c >= '\u007f') {
-        throw new IllegalArgumentException(Util.format(
-            "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
-      }
-    }
-  }
-
-  static void checkValue(String value, String name) {
-    if (value == null) throw new NullPointerException("value for name " + name + " == null");
-    for (int i = 0, length = value.length(); i < length; i++) {
-      char c = value.charAt(i);
-      if ((c <= '\u001f' && c != '\t') || c >= '\u007f') {
-        throw new IllegalArgumentException(Util.format(
-            "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
-      }
-    }
-  }
-
-  public static final class Builder {
-    final List<String> namesAndValues = new ArrayList<>(20);
-
-    /**
-     * Add a header line without any validation. Only appropriate for headers from the remote peer
-     * or cache.
-     */
-    Builder addLenient(String line) {
-      int index = line.indexOf(":", 1);
-      if (index != -1) {
-        return addLenient(line.substring(0, index), line.substring(index + 1));
-      } else if (line.startsWith(":")) {
-        // Work around empty header names and header names that start with a
-        // colon (created by old broken SPDY versions of the response cache).
-        return addLenient("", line.substring(1)); // Empty header name.
-      } else {
-        return addLenient("", line); // No header name.
-      }
-    }
-
-    /** Add an header line containing a field name, a literal colon, and a value. */
-    public Builder add(String line) {
-      int index = line.indexOf(":");
-      if (index == -1) {
-        throw new IllegalArgumentException("Unexpected header: " + line);
-      }
-      return add(line.substring(0, index).trim(), line.substring(index + 1));
-    }
-
-    /**
-     * Add a header with the specified name and value. Does validation of header names and values.
-     */
-    public Builder add(String name, String value) {
-      checkName(name);
-      checkValue(value, name);
-      return addLenient(name, value);
-    }
-
-    /**
-     * Add a header with the specified name and value. Does validation of header names, allowing
-     * non-ASCII values.
-     */
-    public Builder addUnsafeNonAscii(String name, String value) {
-      checkName(name);
-      return addLenient(name, value);
-    }
-
-    /**
-     * Adds all headers from an existing collection.
-     */
-    public Builder addAll(Headers headers) {
-      for (int i = 0, size = headers.size(); i < size; i++) {
-        addLenient(headers.name(i), headers.value(i));
-      }
-
-      return this;
-    }
-
-    /**
-     * Add a header with the specified name and formatted date. Does validation of header names and
-     * value.
-     */
-    public Builder add(String name, Date value) {
-      if (value == null) throw new NullPointerException("value for name " + name + " == null");
-      add(name, HttpDate.format(value));
-      return this;
-    }
-
-    /**
-     * Add a header with the specified name and formatted instant. Does validation of header names
-     * and value.
-     */
-    @IgnoreJRERequirement
-    public Builder add(String name, Instant value) {
-      if (value == null) throw new NullPointerException("value for name " + name + " == null");
-      return add(name, new Date(value.toEpochMilli()));
-    }
-
-    /**
-     * Set a field with the specified date. If the field is not found, it is added. If the field is
-     * found, the existing values are replaced.
-     */
-    public Builder set(String name, Date value) {
-      if (value == null) throw new NullPointerException("value for name " + name + " == null");
-      set(name, HttpDate.format(value));
-      return this;
-    }
-
-    /**
-     * Set a field with the specified instant. If the field is not found, it is added. If the field
-     * is found, the existing values are replaced.
-     */
-    @IgnoreJRERequirement
-    public Builder set(String name, Instant value) {
-      if (value == null) throw new NullPointerException("value for name " + name + " == null");
-      return set(name, new Date(value.toEpochMilli()));
-    }
-
-    /**
-     * Add a field with the specified value without any validation. Only appropriate for headers
-     * from the remote peer or cache.
-     */
-    Builder addLenient(String name, String value) {
-      namesAndValues.add(name);
-      namesAndValues.add(value.trim());
-      return this;
-    }
-
-    public Builder removeAll(String name) {
-      for (int i = 0; i < namesAndValues.size(); i += 2) {
-        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
-          namesAndValues.remove(i); // name
-          namesAndValues.remove(i); // value
-          i -= 2;
-        }
-      }
-      return this;
-    }
-
-    /**
-     * Set a field with the specified value. If the field is not found, it is added. If the field is
-     * found, the existing values are replaced.
-     */
-    public Builder set(String name, String value) {
-      checkName(name);
-      checkValue(value, name);
-      removeAll(name);
-      addLenient(name, value);
-      return this;
-    }
-
-    /** Equivalent to {@code build().get(name)}, but potentially faster. */
-    public @Nullable String get(String name) {
-      for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
-        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
-          return namesAndValues.get(i + 1);
-        }
-      }
-      return null;
-    }
-
-    public Headers build() {
-      return new Headers(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Headers.kt b/okhttp/src/main/java/okhttp3/Headers.kt
new file mode 100644
index 0000000000..bdc7b65506
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Headers.kt
@@ -0,0 +1,410 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package okhttp3
+
+import okhttp3.Headers.Builder
+import okhttp3.internal.Util
+import okhttp3.internal.http.HttpDate
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
+import java.time.Instant
+import java.util.ArrayList
+import java.util.Arrays
+import java.util.Collections
+import java.util.Date
+import java.util.Locale
+import java.util.TreeMap
+import java.util.TreeSet
+
+/**
+ * The header fields of a single HTTP message. Values are uninterpreted strings; use `Request` and
+ * `Response` for interpreted headers. This class maintains the order of the header fields within
+ * the HTTP message.
+ *
+ * This class tracks header values line-by-line. A field with multiple comma- separated values on
+ * the same line will be treated as a field with a single value by this class. It is the caller's
+ * responsibility to detect and split on commas if their field permits multiple values. This
+ * simplifies use of single-valued fields whose values routinely contain commas, such as cookies or
+ * dates.
+ *
+ * This class trims whitespace from values. It never returns values with leading or trailing
+ * whitespace.
+ *
+ * Instances of this class are immutable. Use [Builder] to create instances.
+ */
+class Headers private constructor(
+  private val namesAndValues: Array<String>
+) {
+  /** Returns the last value corresponding to the specified field, or null. */
+  operator fun get(name: String): String? = get(namesAndValues, name)
+
+  /**
+   * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
+   * either the field is absent or cannot be parsed as a date.
+   */
+  fun getDate(name: String): Date? {
+    val value = get(name)
+    return if (value != null) HttpDate.parse(value) else null
+  }
+
+  /**
+   * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
+   * either the field is absent or cannot be parsed as a date.
+   */
+  @IgnoreJRERequirement
+  fun getInstant(name: String): Instant? {
+    val value = getDate(name)
+    return value?.toInstant()
+  }
+
+  /** Returns the number of field values.  */
+  fun size(): Int = namesAndValues.size / 2
+
+  /** Returns the field at `position`.  */
+  fun name(index: Int): String = namesAndValues[index * 2]
+
+  /** Returns the value at `index`.  */
+  fun value(index: Int): String = namesAndValues[index * 2 + 1]
+
+  /** Returns an immutable case-insensitive set of header names.  */
+  fun names(): Set<String> {
+    val result = TreeSet(String.CASE_INSENSITIVE_ORDER)
+    for (i in 0 until size()) {
+      result.add(name(i))
+    }
+    return Collections.unmodifiableSet(result)
+  }
+
+  /** Returns an immutable list of the header values for `name`.  */
+  fun values(name: String): List<String> {
+    var result: MutableList<String>? = null
+    for (i in 0 until size()) {
+      if (name.equals(name(i), ignoreCase = true)) {
+        if (result == null) result = ArrayList(2)
+        result.add(value(i))
+      }
+    }
+    return if (result != null) {
+      Collections.unmodifiableList(result)
+    } else {
+      emptyList()
+    }
+  }
+
+  /**
+   * Returns the number of bytes required to encode these headers using HTTP/1.1. This is also the
+   * approximate size of HTTP/2 headers before they are compressed with HPACK. This value is
+   * intended to be used as a metric: smaller headers are more efficient to encode and transmit.
+   */
+  fun byteCount(): Long {
+    // Each header name has 2 bytes of overhead for ': ' and every header value has 2 bytes of
+    // overhead for '\r\n'.
+    var result = (namesAndValues.size * 2).toLong()
+
+    for (i in 0 until namesAndValues.size) {
+      result += namesAndValues[i].length.toLong()
+    }
+
+    return result
+  }
+
+  fun newBuilder(): Builder {
+    val result = Builder()
+    Collections.addAll(result.namesAndValues, *namesAndValues)
+    return result
+  }
+
+  /**
+   * Returns true if `other` is a `Headers` object with the same headers, with the same casing, in
+   * the same order. Note that two headers instances may be *semantically* equal but not equal
+   * according to this method. In particular, none of the following sets of headers are equal
+   * according to this method:
+   *
+   * 1. Original
+   * ```
+   * Content-Type: text/html
+   * Content-Length: 50
+   * ```
+   *
+   * 2. Different order
+   *
+   * ```
+   * Content-Length: 50
+   * Content-Type: text/html
+   * ```
+   *
+   * 3. Different case
+   *
+   * ```
+   * content-type: text/html
+   * content-length: 50
+   * ```
+   *
+   * 4. Different values
+   *
+   * ```
+   * Content-Type: text/html
+   * Content-Length: 050
+   * ```
+   *
+   * Applications that require semantically equal headers should convert them into a canonical form
+   * before comparing them for equality.
+   */
+  override fun equals(other: Any?): Boolean {
+    return other is Headers && Arrays.equals(other.namesAndValues, namesAndValues)
+  }
+
+  override fun hashCode(): Int = Arrays.hashCode(namesAndValues)
+
+  override fun toString(): String {
+    return buildString {
+      for (i in 0 until size()) {
+        append(name(i))
+        append(": ")
+        append(value(i))
+        append("\n")
+      }
+    }
+  }
+
+  fun toMultimap(): Map<String, List<String>> {
+    val result = TreeMap<String, MutableList<String>>(String.CASE_INSENSITIVE_ORDER)
+    for (i in 0 until size()) {
+      val name = name(i).toLowerCase(Locale.US)
+      var values: MutableList<String>? = result[name]
+      if (values == null) {
+        values = ArrayList(2)
+        result[name] = values
+      }
+      values.add(value(i))
+    }
+    return result
+  }
+
+  class Builder {
+    internal val namesAndValues: MutableList<String> = ArrayList(20)
+
+    /**
+     * Add a header line without any validation. Only appropriate for headers from the remote peer
+     * or cache.
+     */
+    internal fun addLenient(line: String) = apply {
+      val index = line.indexOf(":", 1)
+      when {
+        index != -1 -> {
+          addLenient(line.substring(0, index), line.substring(index + 1))
+        }
+        line.startsWith(":") -> {
+          // Work around empty header names and header names that start with a
+          // colon (created by old broken SPDY versions of the response cache).
+          addLenient("", line.substring(1)) // Empty header name.
+        }
+        else -> {
+          // No header name.
+          addLenient("", line)
+        }
+      }
+    }
+
+    /** Add an header line containing a field name, a literal colon, and a value. */
+    fun add(line: String) = apply {
+      val index = line.indexOf(":")
+      require(index != -1) { "Unexpected header: $line" }
+      add(line.substring(0, index).trim { it <= ' ' }, line.substring(index + 1))
+    }
+
+    /**
+     * Add a header with the specified name and value. Does validation of header names and values.
+     */
+    fun add(name: String, value: String) = apply {
+      checkName(name)
+      checkValue(value, name)
+      addLenient(name, value)
+    }
+
+    /**
+     * Add a header with the specified name and value. Does validation of header names, allowing
+     * non-ASCII values.
+     */
+    fun addUnsafeNonAscii(name: String, value: String) = apply {
+      checkName(name)
+      addLenient(name, value)
+    }
+
+    /**
+     * Adds all headers from an existing collection.
+     */
+    fun addAll(headers: Headers) = apply {
+      for (i in 0 until headers.size()) {
+        addLenient(headers.name(i), headers.value(i))
+      }
+    }
+
+    /**
+     * Add a header with the specified name and formatted date. Does validation of header names and
+     * value.
+     */
+    fun add(name: String, value: Date) = apply {
+      add(name, HttpDate.format(value))
+    }
+
+    /**
+     * Add a header with the specified name and formatted instant. Does validation of header names
+     * and value.
+     */
+    @IgnoreJRERequirement
+    fun add(name: String, value: Instant) = apply {
+      add(name, Date(value.toEpochMilli()))
+    }
+
+    /**
+     * Set a field with the specified date. If the field is not found, it is added. If the field is
+     * found, the existing values are replaced.
+     */
+    operator fun set(name: String, value: Date) = apply {
+      set(name, HttpDate.format(value))
+    }
+
+    /**
+     * Set a field with the specified instant. If the field is not found, it is added. If the field
+     * is found, the existing values are replaced.
+     */
+    @IgnoreJRERequirement
+    operator fun set(name: String, value: Instant) = apply {
+      return set(name, Date(value.toEpochMilli()))
+    }
+
+    /**
+     * Add a field with the specified value without any validation. Only appropriate for headers
+     * from the remote peer or cache.
+     */
+    internal fun addLenient(name: String, value: String) = apply {
+      namesAndValues.add(name)
+      namesAndValues.add(value.trim { it <= ' ' })
+    }
+
+    fun removeAll(name: String) = apply {
+      var i = 0
+      while (i < namesAndValues.size) {
+        if (name.equals(namesAndValues[i], ignoreCase = true)) {
+          namesAndValues.removeAt(i) // name
+          namesAndValues.removeAt(i) // value
+          i -= 2
+        }
+        i += 2
+      }
+    }
+
+    /**
+     * Set a field with the specified value. If the field is not found, it is added. If the field is
+     * found, the existing values are replaced.
+     */
+    operator fun set(name: String, value: String) = apply {
+      checkName(name)
+      checkValue(value, name)
+      removeAll(name)
+      addLenient(name, value)
+    }
+
+    /** Equivalent to `build().get(name)`, but potentially faster.  */
+    operator fun get(name: String): String? {
+      for (i in namesAndValues.size - 2 downTo 0 step 2) {
+        if (name.equals(namesAndValues[i], ignoreCase = true)) {
+          return namesAndValues[i + 1]
+        }
+      }
+      return null
+    }
+
+    fun build(): Headers = Headers(namesAndValues.toTypedArray())
+  }
+
+  companion object {
+    private fun get(namesAndValues: Array<String>, name: String): String? {
+      for (i in namesAndValues.size - 2 downTo 0 step 2) {
+        if (name.equals(namesAndValues[i], ignoreCase = true)) {
+          return namesAndValues[i + 1]
+        }
+      }
+      return null
+    }
+
+    /**
+     * Returns headers for the alternating header names and values. There must be an even number of
+     * arguments, and they must alternate between header names and values.
+     */
+    @JvmStatic
+    fun of(vararg namesAndValues: String): Headers {
+      require(namesAndValues.size % 2 == 0) { "Expected alternating header names and values" }
+
+      // Make a defensive copy and clean it up.
+      val namesAndValues: Array<String> = namesAndValues.clone() as Array<String>
+      for (i in namesAndValues.indices) {
+        require(namesAndValues[i] != null) { "Headers cannot be null" }
+        namesAndValues[i] = namesAndValues[i].trim { it <= ' ' }
+      }
+
+      // Check for malformed headers.
+      for (i in 0 until namesAndValues.size step 2) {
+        val name = namesAndValues[i]
+        val value = namesAndValues[i + 1]
+        checkName(name)
+        checkValue(value, name)
+      }
+
+      return Headers(namesAndValues)
+    }
+
+    /** Returns headers for the header names and values in the [Map]. */
+    @JvmStatic
+    fun of(headers: Map<String, String>): Headers {
+      // Make a defensive copy and clean it up.
+      val namesAndValues = arrayOfNulls<String>(headers.size * 2)
+      var i = 0
+      for ((key, value1) in headers) {
+        val name = key.trim { it <= ' ' }
+        val value = value1.trim { it <= ' ' }
+        checkName(name)
+        checkValue(value, name)
+        namesAndValues[i] = name
+        namesAndValues[i + 1] = value
+        i += 2
+      }
+
+      return Headers(namesAndValues as Array<String>)
+    }
+
+    internal fun checkName(name: String) {
+      require(name.isNotEmpty()) { "name is empty" }
+      for (i in 0 until name.length) {
+        val c = name[i]
+        require(c in '\u0021'..'\u007e') {
+          Util.format("Unexpected char %#04x at %d in header name: %s", c.toInt(), i, name)
+        }
+      }
+    }
+
+    internal fun checkValue(value: String, name: String) {
+      for (i in 0 until value.length) {
+        val c = value[i]
+        require(c == '\t' || c in '\u0020'..'\u007e') {
+          Util.format("Unexpected char %#04x at %d in %s value: %s", c.toInt(), i, name, value)
+        }
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
deleted file mode 100644
index 26125e306d..0000000000
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ /dev/null
@@ -1,1757 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.InetAddress;
-import java.net.MalformedURLException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
-import okio.Buffer;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static okhttp3.internal.Util.decodeHexDigit;
-import static okhttp3.internal.Util.delimiterOffset;
-import static okhttp3.internal.Util.skipLeadingAsciiWhitespace;
-import static okhttp3.internal.Util.skipTrailingAsciiWhitespace;
-import static okhttp3.internal.Util.verifyAsIpAddress;
-
-/**
- * A uniform resource locator (URL) with a scheme of either {@code http} or {@code https}. Use this
- * class to compose and decompose Internet addresses. For example, this code will compose and print
- * a URL for Google search: <pre>   {@code
- *
- *   HttpUrl url = new HttpUrl.Builder()
- *       .scheme("https")
- *       .host("www.google.com")
- *       .addPathSegment("search")
- *       .addQueryParameter("q", "polar bears")
- *       .build();
- *   System.out.println(url);
- * }</pre>
- *
- * which prints: <pre>   {@code
- *
- *     https://www.google.com/search?q=polar%20bears
- * }</pre>
- *
- * As another example, this code prints the human-readable query parameters of a Twitter search:
- * <pre>   {@code
- *
- *   HttpUrl url = HttpUrl.parse("https://twitter.com/search?q=cute%20%23puppies&f=images");
- *   for (int i = 0, size = url.querySize(); i < size; i++) {
- *     System.out.println(url.queryParameterName(i) + ": " + url.queryParameterValue(i));
- *   }
- * }</pre>
- *
- * which prints: <pre>   {@code
- *
- *   q: cute #puppies
- *   f: images
- * }</pre>
- *
- * In addition to composing URLs from their component parts and decomposing URLs into their
- * component parts, this class implements relative URL resolution: what address you'd reach by
- * clicking a relative link on a specified page. For example: <pre>   {@code
- *
- *   HttpUrl base = HttpUrl.parse("https://www.youtube.com/user/WatchTheDaily/videos");
- *   HttpUrl link = base.resolve("../../watch?v=cbP2N1BQdYc");
- *   System.out.println(link);
- * }</pre>
- *
- * which prints: <pre>   {@code
- *
- *   https://www.youtube.com/watch?v=cbP2N1BQdYc
- * }</pre>
- *
- * <h3>What's in a URL?</h3>
- *
- * A URL has several components.
- *
- * <h4>Scheme</h4>
- *
- * <p>Sometimes referred to as <i>protocol</i>, A URL's scheme describes what mechanism should be
- * used to retrieve the resource. Although URLs have many schemes ({@code mailto}, {@code file},
- * {@code ftp}), this class only supports {@code http} and {@code https}. Use {@link URI
- * java.net.URI} for URLs with arbitrary schemes.
- *
- * <h4>Username and Password</h4>
- *
- * <p>Username and password are either present, or the empty string {@code ""} if absent. This class
- * offers no mechanism to differentiate empty from absent. Neither of these components are popular
- * in practice. Typically HTTP applications use other mechanisms for user identification and
- * authentication.
- *
- * <h4>Host</h4>
- *
- * <p>The host identifies the webserver that serves the URL's resource. It is either a hostname like
- * {@code square.com} or {@code localhost}, an IPv4 address like {@code 192.168.0.1}, or an IPv6
- * address like {@code ::1}.
- *
- * <p>Usually a webserver is reachable with multiple identifiers: its IP addresses, registered
- * domain names, and even {@code localhost} when connecting from the server itself. Each of a
- * webserver's names is a distinct URL and they are not interchangeable. For example, even if {@code
- * http://square.github.io/dagger} and {@code http://google.github.io/dagger} are served by the same
- * IP address, the two URLs identify different resources.
- *
- * <h4>Port</h4>
- *
- * <p>The port used to connect to the webserver. By default this is 80 for HTTP and 443 for HTTPS.
- * This class never returns -1 for the port: if no port is explicitly specified in the URL then the
- * scheme's default is used.
- *
- * <h4>Path</h4>
- *
- * <p>The path identifies a specific resource on the host. Paths have a hierarchical structure like
- * "/square/okhttp/issues/1486" and decompose into a list of segments like ["square", "okhttp",
- * "issues", "1486"].
- *
- * <p>This class offers methods to compose and decompose paths by segment. It composes each path
- * from a list of segments by alternating between "/" and the encoded segment. For example the
- * segments ["a", "b"] build "/a/b" and the segments ["a", "b", ""] build "/a/b/".
- *
- * <p>If a path's last segment is the empty string then the path ends with "/". This class always
- * builds non-empty paths: if the path is omitted it defaults to "/". The default path's segment
- * list is a single empty string: [""].
- *
- * <h4>Query</h4>
- *
- * <p>The query is optional: it can be null, empty, or non-empty. For many HTTP URLs the query
- * string is subdivided into a collection of name-value parameters. This class offers methods to set
- * the query as the single string, or as individual name-value parameters. With name-value
- * parameters the values are optional and names may be repeated.
- *
- * <h4>Fragment</h4>
- *
- * <p>The fragment is optional: it can be null, empty, or non-empty. Unlike host, port, path, and
- * query the fragment is not sent to the webserver: it's private to the client.
- *
- * <h3>Encoding</h3>
- *
- * <p>Each component must be encoded before it is embedded in the complete URL. As we saw above, the
- * string {@code cute #puppies} is encoded as {@code cute%20%23puppies} when used as a query
- * parameter value.
- *
- * <h4>Percent encoding</h4>
- *
- * <p>Percent encoding replaces a character (like {@code \ud83c\udf69}) with its UTF-8 hex bytes
- * (like {@code %F0%9F%8D%A9}). This approach works for whitespace characters, control characters,
- * non-ASCII characters, and characters that already have another meaning in a particular context.
- *
- * <p>Percent encoding is used in every URL component except for the hostname. But the set of
- * characters that need to be encoded is different for each component. For example, the path
- * component must escape all of its {@code ?} characters, otherwise it could be interpreted as the
- * start of the URL's query. But within the query and fragment components, the {@code ?} character
- * doesn't delimit anything and doesn't need to be escaped. <pre>   {@code
- *
- *   HttpUrl url = HttpUrl.parse("http://who-let-the-dogs.out").newBuilder()
- *       .addPathSegment("_Who?_")
- *       .query("_Who?_")
- *       .fragment("_Who?_")
- *       .build();
- *   System.out.println(url);
- * }</pre>
- *
- * This prints: <pre>   {@code
- *
- *   http://who-let-the-dogs.out/_Who%3F_?_Who?_#_Who?_
- * }</pre>
- *
- * When parsing URLs that lack percent encoding where it is required, this class will percent encode
- * the offending characters.
- *
- * <h4>IDNA Mapping and Punycode encoding</h4>
- *
- * <p>Hostnames have different requirements and use a different encoding scheme. It consists of IDNA
- * mapping and Punycode encoding.
- *
- * <p>In order to avoid confusion and discourage phishing attacks, <a
- * href="http://www.unicode.org/reports/tr46/#ToASCII">IDNA Mapping</a> transforms names to avoid
- * confusing characters. This includes basic case folding: transforming shouting {@code SQUARE.COM}
- * into cool and casual {@code square.com}. It also handles more exotic characters. For example, the
- * Unicode trademark sign () could be confused for the letters "TM" in {@code http://homail.com}.
- * To mitigate this, the single character () maps to the string (tm). There is similar policy for
- * all of the 1.1 million Unicode code points. Note that some code points such as "\ud83c\udf69" are
- * not mapped and cannot be used in a hostname.
- *
- * <p><a href="http://ietf.org/rfc/rfc3492.txt">Punycode</a> converts a Unicode string to an ASCII
- * string to make international domain names work everywhere. For example, "" encodes as "xn--4xa".
- * The encoded string is not human readable, but can be used with classes like {@link InetAddress}
- * to establish connections.
- *
- * <h3>Why another URL model?</h3>
- *
- * <p>Java includes both {@link URL java.net.URL} and {@link URI java.net.URI}. We offer a new URL
- * model to address problems that the others don't.
- *
- * <h4>Different URLs should be different</h4>
- *
- * <p>Although they have different content, {@code java.net.URL} considers the following two URLs
- * equal, and the {@link Object#equals equals()} method between them returns true:
- *
- * <ul>
- *   <li>http://square.github.io/
- *   <li>http://google.github.io/
- * </ul>
- *
- * This is because those two hosts share the same IP address. This is an old, bad design decision
- * that makes {@code java.net.URL} unusable for many things. It shouldn't be used as a {@link
- * java.util.Map Map} key or in a {@link Set}. Doing so is both inefficient because equality may
- * require a DNS lookup, and incorrect because unequal URLs may be equal because of how they are
- * hosted.
- *
- * <h4>Equal URLs should be equal</h4>
- *
- * <p>These two URLs are semantically identical, but {@code java.net.URI} disagrees:
- *
- * <ul>
- *   <li>http://host:80/
- *   <li>http://host
- * </ul>
- *
- * Both the unnecessary port specification ({@code :80}) and the absent trailing slash ({@code /})
- * cause URI to bucket the two URLs separately. This harms URI's usefulness in collections. Any
- * application that stores information-per-URL will need to either canonicalize manually, or suffer
- * unnecessary redundancy for such URLs.
- *
- * <p>Because they don't attempt canonical form, these classes are surprisingly difficult to use
- * securely. Suppose you're building a webservice that checks that incoming paths are prefixed
- * "/static/images/" before serving the corresponding assets from the filesystem. <pre>   {@code
- *
- *   String attack = "http://example.com/static/images/../../../../../etc/passwd";
- *   System.out.println(new URL(attack).getPath());
- *   System.out.println(new URI(attack).getPath());
- *   System.out.println(HttpUrl.parse(attack).encodedPath());
- * }</pre>
- *
- * By canonicalizing the input paths, they are complicit in directory traversal attacks. Code that
- * checks only the path prefix may suffer!
- * <pre>   {@code
- *
- *    /static/images/../../../../../etc/passwd
- *    /static/images/../../../../../etc/passwd
- *    /etc/passwd
- * }</pre>
- *
- * <h4>If it works on the web, it should work in your application</h4>
- *
- * <p>The {@code java.net.URI} class is strict around what URLs it accepts. It rejects URLs like
- * "http://example.com/abc|def" because the '|' character is unsupported. This class is more
- * forgiving: it will automatically percent-encode the '|', yielding "http://example.com/abc%7Cdef".
- * This kind behavior is consistent with web browsers. {@code HttpUrl} prefers consistency with
- * major web browsers over consistency with obsolete specifications.
- *
- * <h4>Paths and Queries should decompose</h4>
- *
- * <p>Neither of the built-in URL models offer direct access to path segments or query parameters.
- * Manually using {@code StringBuilder} to assemble these components is cumbersome: do '+'
- * characters get silently replaced with spaces? If a query parameter contains a '&amp;', does that
- * get escaped? By offering methods to read and write individual query parameters directly,
- * application developers are saved from the hassles of encoding and decoding.
- *
- * <h4>Plus a modern API</h4>
- *
- * <p>The URL (JDK1.0) and URI (Java 1.4) classes predate builders and instead use telescoping
- * constructors. For example, there's no API to compose a URI with a custom port without also
- * providing a query and fragment.
- *
- * <p>Instances of {@link HttpUrl} are well-formed and always have a scheme, host, and path. With
- * {@code java.net.URL} it's possible to create an awkward URL like {@code http:/} with scheme and
- * path but no hostname. Building APIs that consume such malformed values is difficult!
- *
- * <p>This class has a modern API. It avoids punitive checked exceptions: {@link #get get()}
- * throws {@link IllegalArgumentException} on invalid input or {@link #parse parse()}
- * returns null if the input is an invalid URL. You can even be explicit about whether each
- * component has been encoded already.
- */
-public final class HttpUrl {
-  private static final char[] HEX_DIGITS =
-      {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
-  static final String USERNAME_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
-  static final String PASSWORD_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
-  static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
-  static final String PATH_SEGMENT_ENCODE_SET_URI = "[]";
-  static final String QUERY_ENCODE_SET = " \"'<>#";
-  static final String QUERY_COMPONENT_REENCODE_SET = " \"'<>#&=";
-  static final String QUERY_COMPONENT_ENCODE_SET = " !\"#$&'(),/:;<=>?@[]\\^`{|}~";
-  static final String QUERY_COMPONENT_ENCODE_SET_URI = "\\^`{|}";
-  static final String FORM_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#&!$(),~";
-  static final String FRAGMENT_ENCODE_SET = "";
-  static final String FRAGMENT_ENCODE_SET_URI = " \"#<>\\^`{|}";
-
-  /** Either "http" or "https". */
-  final String scheme;
-
-  /** Decoded username. */
-  private final String username;
-
-  /** Decoded password. */
-  private final String password;
-
-  /** Canonical hostname. */
-  final String host;
-
-  /** Either 80, 443 or a user-specified port. In range [1..65535]. */
-  final int port;
-
-  /**
-   * A list of canonical path segments. This list always contains at least one element, which may be
-   * the empty string. Each segment is formatted with a leading '/', so if path segments were ["a",
-   * "b", ""], then the encoded path would be "/a/b/".
-   */
-  private final List<String> pathSegments;
-
-  /**
-   * Alternating, decoded query names and values, or null for no query. Names may be empty or
-   * non-empty, but never null. Values are null if the name has no corresponding '=' separator, or
-   * empty, or non-empty.
-   */
-  private final @Nullable List<String> queryNamesAndValues;
-
-  /** Decoded fragment. */
-  private final @Nullable String fragment;
-
-  /** Canonical URL. */
-  private final String url;
-
-  HttpUrl(Builder builder) {
-    this.scheme = builder.scheme;
-    this.username = percentDecode(builder.encodedUsername, false);
-    this.password = percentDecode(builder.encodedPassword, false);
-    this.host = builder.host;
-    this.port = builder.effectivePort();
-    this.pathSegments = percentDecode(builder.encodedPathSegments, false);
-    this.queryNamesAndValues = builder.encodedQueryNamesAndValues != null
-        ? percentDecode(builder.encodedQueryNamesAndValues, true)
-        : null;
-    this.fragment = builder.encodedFragment != null
-        ? percentDecode(builder.encodedFragment, false)
-        : null;
-    this.url = builder.toString();
-  }
-
-  /** Returns this URL as a {@link URL java.net.URL}. */
-  public URL url() {
-    try {
-      return new URL(url);
-    } catch (MalformedURLException e) {
-      throw new RuntimeException(e); // Unexpected!
-    }
-  }
-
-  /**
-   * Returns this URL as a {@link URI java.net.URI}. Because {@code URI} is more strict than this
-   * class, the returned URI may be semantically different from this URL:
-   *
-   * <ul>
-   *     <li>Characters forbidden by URI like {@code [} and {@code |} will be escaped.
-   *     <li>Invalid percent-encoded sequences like {@code %xx} will be encoded like {@code %25xx}.
-   *     <li>Whitespace and control characters in the fragment will be stripped.
-   * </ul>
-   *
-   * <p>These differences may have a significant consequence when the URI is interpreted by a
-   * webserver. For this reason the {@linkplain URI URI class} and this method should be avoided.
-   */
-  public URI uri() {
-    String uri = newBuilder().reencodeForUri().toString();
-    try {
-      return new URI(uri);
-    } catch (URISyntaxException e) {
-      // Unlikely edge case: the URI has a forbidden character in the fragment. Strip it & retry.
-      try {
-        String stripped = uri.replaceAll("[\\u0000-\\u001F\\u007F-\\u009F\\p{javaWhitespace}]", "");
-        return URI.create(stripped);
-      } catch (Exception e1) {
-        throw new RuntimeException(e); // Unexpected!
-      }
-    }
-  }
-
-  /** Returns either "http" or "https". */
-  public String scheme() {
-    return scheme;
-  }
-
-  public boolean isHttps() {
-    return scheme.equals("https");
-  }
-
-  /**
-   * Returns the username, or an empty string if none is set.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code encodedUsername()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://username@host/}</td><td>{@code "username"}</td></tr>
-   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "username"}</td></tr>
-   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "a%20b"}</td></tr>
-   * </table>
-   */
-  public String encodedUsername() {
-    if (username.isEmpty()) return "";
-    int usernameStart = scheme.length() + 3; // "://".length() == 3.
-    int usernameEnd = delimiterOffset(url, usernameStart, url.length(), ":@");
-    return url.substring(usernameStart, usernameEnd);
-  }
-
-  /**
-   * Returns the decoded username, or an empty string if none is present.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code username()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://username@host/}</td><td>{@code "username"}</td></tr>
-   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "username"}</td></tr>
-   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "a b"}</td></tr>
-   * </table>
-   */
-  public String username() {
-    return username;
-  }
-
-  /**
-   * Returns the password, or an empty string if none is set.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code encodedPassword()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://username@host/}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "password"}</td></tr>
-   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "c%20d"}</td></tr>
-   * </table>
-   */
-  public String encodedPassword() {
-    if (password.isEmpty()) return "";
-    int passwordStart = url.indexOf(':', scheme.length() + 3) + 1;
-    int passwordEnd = url.indexOf('@');
-    return url.substring(passwordStart, passwordEnd);
-  }
-
-  /**
-   * Returns the decoded password, or an empty string if none is present.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code password()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://username@host/}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "password"}</td></tr>
-   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "c d"}</td></tr>
-   * </table>
-   */
-  public String password() {
-    return password;
-  }
-
-  /**
-   * Returns the host address suitable for use with {@link InetAddress#getAllByName(String)}. May
-   * be:
-   *
-   * <ul>
-   *   <li>A regular host name, like {@code android.com}.
-   *   <li>An IPv4 address, like {@code 127.0.0.1}.
-   *   <li>An IPv6 address, like {@code ::1}. Note that there are no square braces.
-   *   <li>An encoded IDN, like {@code xn--n3h.net}.
-   * </ul>
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code host()}</th></tr>
-   *   <tr><td>{@code http://android.com/}</td><td>{@code "android.com"}</td></tr>
-   *   <tr><td>{@code http://127.0.0.1/}</td><td>{@code "127.0.0.1"}</td></tr>
-   *   <tr><td>{@code http://[::1]/}</td><td>{@code "::1"}</td></tr>
-   *   <tr><td>{@code http://xn--n3h.net/}</td><td>{@code "xn--n3h.net"}</td></tr>
-   * </table>
-   */
-  public String host() {
-    return host;
-  }
-
-  /**
-   * Returns the explicitly-specified port if one was provided, or the default port for this URL's
-   * scheme. For example, this returns 8443 for {@code https://square.com:8443/} and 443 for {@code
-   * https://square.com/}. The result is in {@code [1..65535]}.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code port()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code 80}</td></tr>
-   *   <tr><td>{@code http://host:8000/}</td><td>{@code 8000}</td></tr>
-   *   <tr><td>{@code https://host/}</td><td>{@code 443}</td></tr>
-   * </table>
-   */
-  public int port() {
-    return port;
-  }
-
-  /**
-   * Returns 80 if {@code scheme.equals("http")}, 443 if {@code scheme.equals("https")} and -1
-   * otherwise.
-   */
-  public static int defaultPort(String scheme) {
-    if (scheme.equals("http")) {
-      return 80;
-    } else if (scheme.equals("https")) {
-      return 443;
-    } else {
-      return -1;
-    }
-  }
-
-  /**
-   * Returns the number of segments in this URL's path. This is also the number of slashes in the
-   * URL's path, like 3 in {@code http://host/a/b/c}. This is always at least 1.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code pathSize()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code 1}</td></tr>
-   *   <tr><td>{@code http://host/a/b/c}</td><td>{@code 3}</td></tr>
-   *   <tr><td>{@code http://host/a/b/c/}</td><td>{@code 4}</td></tr>
-   * </table>
-   */
-  public int pathSize() {
-    return pathSegments.size();
-  }
-
-  /**
-   * Returns the entire path of this URL encoded for use in HTTP resource resolution. The returned
-   * path will start with {@code "/"}.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code encodedPath()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code "/"}</td></tr>
-   *   <tr><td>{@code http://host/a/b/c}</td><td>{@code "/a/b/c"}</td></tr>
-   *   <tr><td>{@code http://host/a/b%20c/d}</td><td>{@code "/a/b%20c/d"}</td></tr>
-   * </table>
-   */
-  public String encodedPath() {
-    int pathStart = url.indexOf('/', scheme.length() + 3); // "://".length() == 3.
-    int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
-    return url.substring(pathStart, pathEnd);
-  }
-
-  static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
-    for (int i = 0, size = pathSegments.size(); i < size; i++) {
-      out.append('/');
-      out.append(pathSegments.get(i));
-    }
-  }
-
-  /**
-   * Returns a list of encoded path segments like {@code ["a", "b", "c"]} for the URL {@code
-   * http://host/a/b/c}. This list is never empty though it may contain a single empty string.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code encodedPathSegments()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code [""]}</td></tr>
-   *   <tr><td>{@code http://host/a/b/c}</td><td>{@code ["a", "b", "c"]}</td></tr>
-   *   <tr><td>{@code http://host/a/b%20c/d}</td><td>{@code ["a", "b%20c", "d"]}</td></tr>
-   * </table>
-   */
-  public List<String> encodedPathSegments() {
-    int pathStart = url.indexOf('/', scheme.length() + 3);
-    int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
-    List<String> result = new ArrayList<>();
-    for (int i = pathStart; i < pathEnd; ) {
-      i++; // Skip the '/'.
-      int segmentEnd = delimiterOffset(url, i, pathEnd, '/');
-      result.add(url.substring(i, segmentEnd));
-      i = segmentEnd;
-    }
-    return result;
-  }
-
-  /**
-   * Returns a list of path segments like {@code ["a", "b", "c"]} for the URL {@code
-   * http://host/a/b/c}. This list is never empty though it may contain a single empty string.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code pathSegments()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code [""]}</td></tr>
-   *   <tr><td>{@code http://host/a/b/c"}</td><td>{@code ["a", "b", "c"]}</td></tr>
-   *   <tr><td>{@code http://host/a/b%20c/d"}</td><td>{@code ["a", "b c", "d"]}</td></tr>
-   * </table>
-   */
-  public List<String> pathSegments() {
-    return pathSegments;
-  }
-
-  /**
-   * Returns the query of this URL, encoded for use in HTTP resource resolution. The returned string
-   * may be null (for URLs with no query), empty (for URLs with an empty query) or non-empty (all
-   * other URLs).
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code encodedQuery()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
-   *   <tr><td>{@code http://host/?}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code
-   *       "a=apple&k=key+lime"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "a=apple&a=apricot"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a=apple&b"}</td></tr>
-   * </table>
-   */
-  public @Nullable String encodedQuery() {
-    if (queryNamesAndValues == null) return null; // No query.
-    int queryStart = url.indexOf('?') + 1;
-    int queryEnd = delimiterOffset(url, queryStart, url.length(), '#');
-    return url.substring(queryStart, queryEnd);
-  }
-
-  static void namesAndValuesToQueryString(StringBuilder out, List<String> namesAndValues) {
-    for (int i = 0, size = namesAndValues.size(); i < size; i += 2) {
-      String name = namesAndValues.get(i);
-      String value = namesAndValues.get(i + 1);
-      if (i > 0) out.append('&');
-      out.append(name);
-      if (value != null) {
-        out.append('=');
-        out.append(value);
-      }
-    }
-  }
-
-  /**
-   * Cuts {@code encodedQuery} up into alternating parameter names and values. This divides a query
-   * string like {@code subject=math&easy&problem=5-2=3} into the list {@code ["subject", "math",
-   * "easy", null, "problem", "5-2=3"]}. Note that values may be null and may contain '='
-   * characters.
-   */
-  static List<String> queryStringToNamesAndValues(String encodedQuery) {
-    List<String> result = new ArrayList<>();
-    for (int pos = 0; pos <= encodedQuery.length(); ) {
-      int ampersandOffset = encodedQuery.indexOf('&', pos);
-      if (ampersandOffset == -1) ampersandOffset = encodedQuery.length();
-
-      int equalsOffset = encodedQuery.indexOf('=', pos);
-      if (equalsOffset == -1 || equalsOffset > ampersandOffset) {
-        result.add(encodedQuery.substring(pos, ampersandOffset));
-        result.add(null); // No value for this name.
-      } else {
-        result.add(encodedQuery.substring(pos, equalsOffset));
-        result.add(encodedQuery.substring(equalsOffset + 1, ampersandOffset));
-      }
-      pos = ampersandOffset + 1;
-    }
-    return result;
-  }
-
-  /**
-   * Returns this URL's query, like {@code "abc"} for {@code http://host/?abc}. Most callers should
-   * prefer {@link #queryParameterName} and {@link #queryParameterValue} because these methods offer
-   * direct access to individual query parameters.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code query()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
-   *   <tr><td>{@code http://host/?}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "a=apple&k=key
-   *       lime"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "a=apple&a=apricot"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a=apple&b"}</td></tr>
-   * </table>
-   */
-  public @Nullable String query() {
-    if (queryNamesAndValues == null) return null; // No query.
-    StringBuilder result = new StringBuilder();
-    namesAndValuesToQueryString(result, queryNamesAndValues);
-    return result.toString();
-  }
-
-  /**
-   * Returns the number of query parameters in this URL, like 2 for {@code
-   * http://host/?a=apple&b=banana}. If this URL has no query this returns 0. Otherwise it returns
-   * one more than the number of {@code "&"} separators in the query.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code querySize()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code 0}</td></tr>
-   *   <tr><td>{@code http://host/?}</td><td>{@code 1}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code 2}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code 2}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code 2}</td></tr>
-   * </table>
-   */
-  public int querySize() {
-    return queryNamesAndValues != null ? queryNamesAndValues.size() / 2 : 0;
-  }
-
-  /**
-   * Returns the first query parameter named {@code name} decoded using UTF-8, or null if there is
-   * no such query parameter.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code queryParameter("a")}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
-   *   <tr><td>{@code http://host/?}</td><td>null</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "apple"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "apple"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "apple"}</td></tr>
-   * </table>
-   */
-  public @Nullable String queryParameter(String name) {
-    if (queryNamesAndValues == null) return null;
-    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
-      if (name.equals(queryNamesAndValues.get(i))) {
-        return queryNamesAndValues.get(i + 1);
-      }
-    }
-    return null;
-  }
-
-  /**
-   * Returns the distinct query parameter names in this URL, like {@code ["a", "b"]} for {@code
-   * http://host/?a=apple&b=banana}. If this URL has no query this returns the empty set.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code queryParameterNames()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code []}</td></tr>
-   *   <tr><td>{@code http://host/?}</td><td>{@code [""]}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code ["a", "k"]}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code ["a"]}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code ["a", "b"]}</td></tr>
-   * </table>
-   */
-  public Set<String> queryParameterNames() {
-    if (queryNamesAndValues == null) return Collections.emptySet();
-    Set<String> result = new LinkedHashSet<>();
-    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
-      result.add(queryNamesAndValues.get(i));
-    }
-    return Collections.unmodifiableSet(result);
-  }
-
-  /**
-   * Returns all values for the query parameter {@code name} ordered by their appearance in this
-   * URL. For example this returns {@code ["banana"]} for {@code queryParameterValue("b")} on {@code
-   * http://host/?a=apple&b=banana}.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code queryParameterValues("a")}</th><th>{@code
-   *       queryParameterValues("b")}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code []}</td><td>{@code []}</td></tr>
-   *   <tr><td>{@code http://host/?}</td><td>{@code []}</td><td>{@code []}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code ["apple"]}</td><td>{@code
-   *       []}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code ["apple",
-   *       "apricot"]}</td><td>{@code []}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code ["apple"]}</td><td>{@code
-   *       [null]}</td></tr>
-   * </table>
-   */
-  public List<String> queryParameterValues(String name) {
-    if (queryNamesAndValues == null) return Collections.emptyList();
-    List<String> result = new ArrayList<>();
-    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
-      if (name.equals(queryNamesAndValues.get(i))) {
-        result.add(queryNamesAndValues.get(i + 1));
-      }
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  /**
-   * Returns the name of the query parameter at {@code index}. For example this returns {@code "a"}
-   * for {@code queryParameterName(0)} on {@code http://host/?a=apple&b=banana}. This throws if
-   * {@code index} is not less than the {@linkplain #querySize query size}.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code queryParameterName(0)}</th><th>{@code
-   *       queryParameterName(1)}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>exception</td><td>exception</td></tr>
-   *   <tr><td>{@code http://host/?}</td><td>{@code ""}</td><td>exception</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "a"}</td><td>{@code
-   *       "k"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "a"}</td><td>{@code
-   *       "a"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a"}</td><td>{@code "b"}</td></tr>
-   * </table>
-   */
-  public String queryParameterName(int index) {
-    if (queryNamesAndValues == null) throw new IndexOutOfBoundsException();
-    return queryNamesAndValues.get(index * 2);
-  }
-
-  /**
-   * Returns the value of the query parameter at {@code index}. For example this returns {@code
-   * "apple"} for {@code queryParameterName(0)} on {@code http://host/?a=apple&b=banana}. This
-   * throws if {@code index} is not less than the {@linkplain #querySize query size}.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code queryParameterValue(0)}</th><th>{@code
-   *       queryParameterValue(1)}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>exception</td><td>exception</td></tr>
-   *   <tr><td>{@code http://host/?}</td><td>null</td><td>exception</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "apple"}</td><td>{@code
-   *       "key lime"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "apple"}</td><td>{@code
-   *       "apricot"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "apple"}</td><td>null</td></tr>
-   * </table>
-   */
-  public String queryParameterValue(int index) {
-    if (queryNamesAndValues == null) throw new IndexOutOfBoundsException();
-    return queryNamesAndValues.get(index * 2 + 1);
-  }
-
-  /**
-   * Returns this URL's encoded fragment, like {@code "abc"} for {@code http://host/#abc}. This
-   * returns null if the URL has no fragment.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code encodedFragment()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
-   *   <tr><td>{@code http://host/#}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://host/#abc}</td><td>{@code "abc"}</td></tr>
-   *   <tr><td>{@code http://host/#abc|def}</td><td>{@code "abc|def"}</td></tr>
-   * </table>
-   */
-  public @Nullable String encodedFragment() {
-    if (fragment == null) return null;
-    int fragmentStart = url.indexOf('#') + 1;
-    return url.substring(fragmentStart);
-  }
-
-  /**
-   * Returns this URL's fragment, like {@code "abc"} for {@code http://host/#abc}. This returns null
-   * if the URL has no fragment.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code fragment()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
-   *   <tr><td>{@code http://host/#}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://host/#abc}</td><td>{@code "abc"}</td></tr>
-   *   <tr><td>{@code http://host/#abc|def}</td><td>{@code "abc|def"}</td></tr>
-   * </table>
-   */
-  public @Nullable String fragment() {
-    return fragment;
-  }
-
-  /**
-   * Returns a string with containing this URL with its username, password, query, and fragment
-   * stripped, and its path replaced with {@code /...}. For example, redacting {@code
-   * http://username:password@example.com/path} returns {@code http://example.com/...}.
-   */
-  public String redact() {
-    return newBuilder("/...")
-        .username("")
-        .password("")
-        .build()
-        .toString();
-  }
-
-  /**
-   * Returns the URL that would be retrieved by following {@code link} from this URL, or null if
-   * the resulting URL is not well-formed.
-   */
-  public @Nullable HttpUrl resolve(String link) {
-    Builder builder = newBuilder(link);
-    return builder != null ? builder.build() : null;
-  }
-
-  public Builder newBuilder() {
-    Builder result = new Builder();
-    result.scheme = scheme;
-    result.encodedUsername = encodedUsername();
-    result.encodedPassword = encodedPassword();
-    result.host = host;
-    // If we're set to a default port, unset it in case of a scheme change.
-    result.port = port != defaultPort(scheme) ? port : -1;
-    result.encodedPathSegments.clear();
-    result.encodedPathSegments.addAll(encodedPathSegments());
-    result.encodedQuery(encodedQuery());
-    result.encodedFragment = encodedFragment();
-    return result;
-  }
-
-  /**
-   * Returns a builder for the URL that would be retrieved by following {@code link} from this URL,
-   * or null if the resulting URL is not well-formed.
-   */
-  public @Nullable Builder newBuilder(String link) {
-    try {
-      return new Builder().parse(this, link);
-    } catch (IllegalArgumentException ignored) {
-      return null;
-    }
-  }
-
-  /**
-   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
-   * URL, or null if it isn't.
-   */
-  public static @Nullable HttpUrl parse(String url) {
-    try {
-      return get(url);
-    } catch (IllegalArgumentException ignored) {
-      return null;
-    }
-  }
-
-  /**
-   * Returns a new {@code HttpUrl} representing {@code url}.
-   *
-   * @throws IllegalArgumentException If {@code url} is not a well-formed HTTP or HTTPS URL.
-   */
-  public static HttpUrl get(String url) {
-    return new Builder().parse(null, url).build();
-  }
-
-  /**
-   * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
-   * null if it has any other protocol.
-   */
-  public static @Nullable HttpUrl get(URL url) {
-    return parse(url.toString());
-  }
-
-  public static @Nullable HttpUrl get(URI uri) {
-    return parse(uri.toString());
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof HttpUrl && ((HttpUrl) other).url.equals(url);
-  }
-
-  @Override public int hashCode() {
-    return url.hashCode();
-  }
-
-  @Override public String toString() {
-    return url;
-  }
-
-  /**
-   * Returns the domain name of this URL's {@link #host()} that is one level beneath the public
-   * suffix by consulting the <a href="https://publicsuffix.org">public suffix list</a>. Returns
-   * null if this URL's {@link #host()} is an IP address or is considered a public suffix by the
-   * public suffix list.
-   *
-   * <p>In general this method <strong>should not</strong> be used to test whether a domain is valid
-   * or routable. Instead, DNS is the recommended source for that information.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code topPrivateDomain()}</th></tr>
-   *   <tr><td>{@code http://google.com}</td><td>{@code "google.com"}</td></tr>
-   *   <tr><td>{@code http://adwords.google.co.uk}</td><td>{@code "google.co.uk"}</td></tr>
-   *   <tr><td>{@code http://square}</td><td>null</td></tr>
-   *   <tr><td>{@code http://co.uk}</td><td>null</td></tr>
-   *   <tr><td>{@code http://localhost}</td><td>null</td></tr>
-   *   <tr><td>{@code http://127.0.0.1}</td><td>null</td></tr>
-   * </table>
-   */
-  public @Nullable String topPrivateDomain() {
-    if (verifyAsIpAddress(host)) return null;
-    return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host);
-  }
-
-  public static final class Builder {
-    @Nullable String scheme;
-    String encodedUsername = "";
-    String encodedPassword = "";
-    @Nullable String host;
-    int port = -1;
-    final List<String> encodedPathSegments = new ArrayList<>();
-    @Nullable List<String> encodedQueryNamesAndValues;
-    @Nullable String encodedFragment;
-
-    public Builder() {
-      encodedPathSegments.add(""); // The default path is '/' which needs a trailing space.
-    }
-
-    public Builder scheme(String scheme) {
-      if (scheme == null) {
-        throw new NullPointerException("scheme == null");
-      } else if (scheme.equalsIgnoreCase("http")) {
-        this.scheme = "http";
-      } else if (scheme.equalsIgnoreCase("https")) {
-        this.scheme = "https";
-      } else {
-        throw new IllegalArgumentException("unexpected scheme: " + scheme);
-      }
-      return this;
-    }
-
-    public Builder username(String username) {
-      if (username == null) throw new NullPointerException("username == null");
-      this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, false, false, false, true);
-      return this;
-    }
-
-    public Builder encodedUsername(String encodedUsername) {
-      if (encodedUsername == null) throw new NullPointerException("encodedUsername == null");
-      this.encodedUsername = canonicalize(
-          encodedUsername, USERNAME_ENCODE_SET, true, false, false, true);
-      return this;
-    }
-
-    public Builder password(String password) {
-      if (password == null) throw new NullPointerException("password == null");
-      this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, false, false, false, true);
-      return this;
-    }
-
-    public Builder encodedPassword(String encodedPassword) {
-      if (encodedPassword == null) throw new NullPointerException("encodedPassword == null");
-      this.encodedPassword = canonicalize(
-          encodedPassword, PASSWORD_ENCODE_SET, true, false, false, true);
-      return this;
-    }
-
-    /**
-     * @param host either a regular hostname, International Domain Name, IPv4 address, or IPv6
-     * address.
-     */
-    public Builder host(String host) {
-      if (host == null) throw new NullPointerException("host == null");
-      String encoded = canonicalizeHost(host, 0, host.length());
-      if (encoded == null) throw new IllegalArgumentException("unexpected host: " + host);
-      this.host = encoded;
-      return this;
-    }
-
-    public Builder port(int port) {
-      if (port <= 0 || port > 65535) throw new IllegalArgumentException("unexpected port: " + port);
-      this.port = port;
-      return this;
-    }
-
-    int effectivePort() {
-      return port != -1 ? port : defaultPort(scheme);
-    }
-
-    public Builder addPathSegment(String pathSegment) {
-      if (pathSegment == null) throw new NullPointerException("pathSegment == null");
-      push(pathSegment, 0, pathSegment.length(), false, false);
-      return this;
-    }
-
-    /**
-     * Adds a set of path segments separated by a slash (either {@code \} or {@code /}). If
-     * {@code pathSegments} starts with a slash, the resulting URL will have empty path segment.
-     */
-    public Builder addPathSegments(String pathSegments) {
-      if (pathSegments == null) throw new NullPointerException("pathSegments == null");
-      return addPathSegments(pathSegments, false);
-    }
-
-    public Builder addEncodedPathSegment(String encodedPathSegment) {
-      if (encodedPathSegment == null) {
-        throw new NullPointerException("encodedPathSegment == null");
-      }
-      push(encodedPathSegment, 0, encodedPathSegment.length(), false, true);
-      return this;
-    }
-
-    /**
-     * Adds a set of encoded path segments separated by a slash (either {@code \} or {@code /}). If
-     * {@code encodedPathSegments} starts with a slash, the resulting URL will have empty path
-     * segment.
-     */
-    public Builder addEncodedPathSegments(String encodedPathSegments) {
-      if (encodedPathSegments == null) {
-        throw new NullPointerException("encodedPathSegments == null");
-      }
-      return addPathSegments(encodedPathSegments, true);
-    }
-
-    private Builder addPathSegments(String pathSegments, boolean alreadyEncoded) {
-      int offset = 0;
-      do {
-        int segmentEnd = delimiterOffset(pathSegments, offset, pathSegments.length(), "/\\");
-        boolean addTrailingSlash = segmentEnd < pathSegments.length();
-        push(pathSegments, offset, segmentEnd, addTrailingSlash, alreadyEncoded);
-        offset = segmentEnd + 1;
-      } while (offset <= pathSegments.length());
-      return this;
-    }
-
-    public Builder setPathSegment(int index, String pathSegment) {
-      if (pathSegment == null) throw new NullPointerException("pathSegment == null");
-      String canonicalPathSegment = canonicalize(pathSegment, 0, pathSegment.length(),
-          PATH_SEGMENT_ENCODE_SET, false, false, false, true, null);
-      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
-        throw new IllegalArgumentException("unexpected path segment: " + pathSegment);
-      }
-      encodedPathSegments.set(index, canonicalPathSegment);
-      return this;
-    }
-
-    public Builder setEncodedPathSegment(int index, String encodedPathSegment) {
-      if (encodedPathSegment == null) {
-        throw new NullPointerException("encodedPathSegment == null");
-      }
-      String canonicalPathSegment = canonicalize(encodedPathSegment, 0, encodedPathSegment.length(),
-          PATH_SEGMENT_ENCODE_SET, true, false, false, true, null);
-      encodedPathSegments.set(index, canonicalPathSegment);
-      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
-        throw new IllegalArgumentException("unexpected path segment: " + encodedPathSegment);
-      }
-      return this;
-    }
-
-    public Builder removePathSegment(int index) {
-      encodedPathSegments.remove(index);
-      if (encodedPathSegments.isEmpty()) {
-        encodedPathSegments.add(""); // Always leave at least one '/'.
-      }
-      return this;
-    }
-
-    public Builder encodedPath(String encodedPath) {
-      if (encodedPath == null) throw new NullPointerException("encodedPath == null");
-      if (!encodedPath.startsWith("/")) {
-        throw new IllegalArgumentException("unexpected encodedPath: " + encodedPath);
-      }
-      resolvePath(encodedPath, 0, encodedPath.length());
-      return this;
-    }
-
-    public Builder query(@Nullable String query) {
-      this.encodedQueryNamesAndValues = query != null
-          ? queryStringToNamesAndValues(canonicalize(
-          query, QUERY_ENCODE_SET, false, false, true, true))
-          : null;
-      return this;
-    }
-
-    public Builder encodedQuery(@Nullable String encodedQuery) {
-      this.encodedQueryNamesAndValues = encodedQuery != null
-          ? queryStringToNamesAndValues(
-          canonicalize(encodedQuery, QUERY_ENCODE_SET, true, false, true, true))
-          : null;
-      return this;
-    }
-
-    /** Encodes the query parameter using UTF-8 and adds it to this URL's query string. */
-    public Builder addQueryParameter(String name, @Nullable String value) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
-      encodedQueryNamesAndValues.add(
-          canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true));
-      encodedQueryNamesAndValues.add(value != null
-          ? canonicalize(value, QUERY_COMPONENT_ENCODE_SET, false, false, true, true)
-          : null);
-      return this;
-    }
-
-    /** Adds the pre-encoded query parameter to this URL's query string. */
-    public Builder addEncodedQueryParameter(String encodedName, @Nullable String encodedValue) {
-      if (encodedName == null) throw new NullPointerException("encodedName == null");
-      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
-      encodedQueryNamesAndValues.add(
-          canonicalize(encodedName, QUERY_COMPONENT_REENCODE_SET, true, false, true, true));
-      encodedQueryNamesAndValues.add(encodedValue != null
-          ? canonicalize(encodedValue, QUERY_COMPONENT_REENCODE_SET, true, false, true, true)
-          : null);
-      return this;
-    }
-
-    public Builder setQueryParameter(String name, @Nullable String value) {
-      removeAllQueryParameters(name);
-      addQueryParameter(name, value);
-      return this;
-    }
-
-    public Builder setEncodedQueryParameter(String encodedName, @Nullable String encodedValue) {
-      removeAllEncodedQueryParameters(encodedName);
-      addEncodedQueryParameter(encodedName, encodedValue);
-      return this;
-    }
-
-    public Builder removeAllQueryParameters(String name) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (encodedQueryNamesAndValues == null) return this;
-      String nameToRemove = canonicalize(
-          name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true);
-      removeAllCanonicalQueryParameters(nameToRemove);
-      return this;
-    }
-
-    public Builder removeAllEncodedQueryParameters(String encodedName) {
-      if (encodedName == null) throw new NullPointerException("encodedName == null");
-      if (encodedQueryNamesAndValues == null) return this;
-      removeAllCanonicalQueryParameters(
-          canonicalize(encodedName, QUERY_COMPONENT_REENCODE_SET, true, false, true, true));
-      return this;
-    }
-
-    private void removeAllCanonicalQueryParameters(String canonicalName) {
-      for (int i = encodedQueryNamesAndValues.size() - 2; i >= 0; i -= 2) {
-        if (canonicalName.equals(encodedQueryNamesAndValues.get(i))) {
-          encodedQueryNamesAndValues.remove(i + 1);
-          encodedQueryNamesAndValues.remove(i);
-          if (encodedQueryNamesAndValues.isEmpty()) {
-            encodedQueryNamesAndValues = null;
-            return;
-          }
-        }
-      }
-    }
-
-    public Builder fragment(@Nullable String fragment) {
-      this.encodedFragment = fragment != null
-          ? canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false, false, false)
-          : null;
-      return this;
-    }
-
-    public Builder encodedFragment(@Nullable String encodedFragment) {
-      this.encodedFragment = encodedFragment != null
-          ? canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false, false, false)
-          : null;
-      return this;
-    }
-
-    /**
-     * Re-encodes the components of this URL so that it satisfies (obsolete) RFC 2396, which is
-     * particularly strict for certain components.
-     */
-    Builder reencodeForUri() {
-      for (int i = 0, size = encodedPathSegments.size(); i < size; i++) {
-        String pathSegment = encodedPathSegments.get(i);
-        encodedPathSegments.set(i,
-            canonicalize(pathSegment, PATH_SEGMENT_ENCODE_SET_URI, true, true, false, true));
-      }
-      if (encodedQueryNamesAndValues != null) {
-        for (int i = 0, size = encodedQueryNamesAndValues.size(); i < size; i++) {
-          String component = encodedQueryNamesAndValues.get(i);
-          if (component != null) {
-            encodedQueryNamesAndValues.set(i,
-                canonicalize(component, QUERY_COMPONENT_ENCODE_SET_URI, true, true, true, true));
-          }
-        }
-      }
-      if (encodedFragment != null) {
-        encodedFragment = canonicalize(
-            encodedFragment, FRAGMENT_ENCODE_SET_URI, true, true, false, false);
-      }
-      return this;
-    }
-
-    public HttpUrl build() {
-      if (scheme == null) throw new IllegalStateException("scheme == null");
-      if (host == null) throw new IllegalStateException("host == null");
-      return new HttpUrl(this);
-    }
-
-    @Override public String toString() {
-      StringBuilder result = new StringBuilder();
-      if (scheme != null) {
-        result.append(scheme);
-        result.append("://");
-      } else {
-        result.append("//");
-      }
-
-      if (!encodedUsername.isEmpty() || !encodedPassword.isEmpty()) {
-        result.append(encodedUsername);
-        if (!encodedPassword.isEmpty()) {
-          result.append(':');
-          result.append(encodedPassword);
-        }
-        result.append('@');
-      }
-
-      if (host != null) {
-        if (host.indexOf(':') != -1) {
-          // Host is an IPv6 address.
-          result.append('[');
-          result.append(host);
-          result.append(']');
-        } else {
-          result.append(host);
-        }
-      }
-
-      if (port != -1 || scheme != null) {
-        int effectivePort = effectivePort();
-        if (scheme == null || effectivePort != defaultPort(scheme)) {
-          result.append(':');
-          result.append(effectivePort);
-        }
-      }
-
-      pathSegmentsToString(result, encodedPathSegments);
-
-      if (encodedQueryNamesAndValues != null) {
-        result.append('?');
-        namesAndValuesToQueryString(result, encodedQueryNamesAndValues);
-      }
-
-      if (encodedFragment != null) {
-        result.append('#');
-        result.append(encodedFragment);
-      }
-
-      return result.toString();
-    }
-
-    static final String INVALID_HOST = "Invalid URL host";
-
-    Builder parse(@Nullable HttpUrl base, String input) {
-      int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
-      int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
-
-      // Scheme.
-      int schemeDelimiterOffset = schemeDelimiterOffset(input, pos, limit);
-      if (schemeDelimiterOffset != -1) {
-        if (input.regionMatches(true, pos, "https:", 0, 6)) {
-          this.scheme = "https";
-          pos += "https:".length();
-        } else if (input.regionMatches(true, pos, "http:", 0, 5)) {
-          this.scheme = "http";
-          pos += "http:".length();
-        } else {
-          throw new IllegalArgumentException("Expected URL scheme 'http' or 'https' but was '"
-              + input.substring(0, schemeDelimiterOffset) + "'");
-        }
-      } else if (base != null) {
-        this.scheme = base.scheme;
-      } else {
-        throw new IllegalArgumentException(
-            "Expected URL scheme 'http' or 'https' but no colon was found");
-      }
-
-      // Authority.
-      boolean hasUsername = false;
-      boolean hasPassword = false;
-      int slashCount = slashCount(input, pos, limit);
-      if (slashCount >= 2 || base == null || !base.scheme.equals(this.scheme)) {
-        // Read an authority if either:
-        //  * The input starts with 2 or more slashes. These follow the scheme if it exists.
-        //  * The input scheme exists and is different from the base URL's scheme.
-        //
-        // The structure of an authority is:
-        //   username:password@host:port
-        //
-        // Username, password and port are optional.
-        //   [username[:password]@]host[:port]
-        pos += slashCount;
-        authority:
-        while (true) {
-          int componentDelimiterOffset = delimiterOffset(input, pos, limit, "@/\\?#");
-          int c = componentDelimiterOffset != limit
-              ? input.charAt(componentDelimiterOffset)
-              : -1;
-          switch (c) {
-            case '@':
-              // User info precedes.
-              if (!hasPassword) {
-                int passwordColonOffset = delimiterOffset(
-                    input, pos, componentDelimiterOffset, ':');
-                String canonicalUsername = canonicalize(input, pos, passwordColonOffset,
-                    USERNAME_ENCODE_SET, true, false, false, true, null);
-                this.encodedUsername = hasUsername
-                    ? this.encodedUsername + "%40" + canonicalUsername
-                    : canonicalUsername;
-                if (passwordColonOffset != componentDelimiterOffset) {
-                  hasPassword = true;
-                  this.encodedPassword = canonicalize(input, passwordColonOffset + 1,
-                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true,
-                      null);
-                }
-                hasUsername = true;
-              } else {
-                this.encodedPassword = this.encodedPassword + "%40" + canonicalize(input, pos,
-                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true, null);
-              }
-              pos = componentDelimiterOffset + 1;
-              break;
-
-            case -1:
-            case '/':
-            case '\\':
-            case '?':
-            case '#':
-              // Host info precedes.
-              int portColonOffset = portColonOffset(input, pos, componentDelimiterOffset);
-              if (portColonOffset + 1 < componentDelimiterOffset) {
-                host = canonicalizeHost(input, pos, portColonOffset);
-                port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
-                if (port == -1) {
-                  throw new IllegalArgumentException("Invalid URL port: \""
-                      + input.substring(portColonOffset + 1, componentDelimiterOffset) + '"');
-                }
-              } else {
-                host = canonicalizeHost(input, pos, portColonOffset);
-                port = defaultPort(scheme);
-              }
-              if (host == null) {
-                throw new IllegalArgumentException(
-                    INVALID_HOST + ": \"" + input.substring(pos, portColonOffset) + '"');
-              }
-              pos = componentDelimiterOffset;
-              break authority;
-          }
-        }
-      } else {
-        // This is a relative link. Copy over all authority components. Also maybe the path & query.
-        this.encodedUsername = base.encodedUsername();
-        this.encodedPassword = base.encodedPassword();
-        this.host = base.host;
-        this.port = base.port;
-        this.encodedPathSegments.clear();
-        this.encodedPathSegments.addAll(base.encodedPathSegments());
-        if (pos == limit || input.charAt(pos) == '#') {
-          encodedQuery(base.encodedQuery());
-        }
-      }
-
-      // Resolve the relative path.
-      int pathDelimiterOffset = delimiterOffset(input, pos, limit, "?#");
-      resolvePath(input, pos, pathDelimiterOffset);
-      pos = pathDelimiterOffset;
-
-      // Query.
-      if (pos < limit && input.charAt(pos) == '?') {
-        int queryDelimiterOffset = delimiterOffset(input, pos, limit, '#');
-        this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
-            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true, null));
-        pos = queryDelimiterOffset;
-      }
-
-      // Fragment.
-      if (pos < limit && input.charAt(pos) == '#') {
-        this.encodedFragment = canonicalize(
-            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false, null);
-      }
-
-      return this;
-    }
-
-    private void resolvePath(String input, int pos, int limit) {
-      // Read a delimiter.
-      if (pos == limit) {
-        // Empty path: keep the base path as-is.
-        return;
-      }
-      char c = input.charAt(pos);
-      if (c == '/' || c == '\\') {
-        // Absolute path: reset to the default "/".
-        encodedPathSegments.clear();
-        encodedPathSegments.add("");
-        pos++;
-      } else {
-        // Relative path: clear everything after the last '/'.
-        encodedPathSegments.set(encodedPathSegments.size() - 1, "");
-      }
-
-      // Read path segments.
-      for (int i = pos; i < limit; ) {
-        int pathSegmentDelimiterOffset = delimiterOffset(input, i, limit, "/\\");
-        boolean segmentHasTrailingSlash = pathSegmentDelimiterOffset < limit;
-        push(input, i, pathSegmentDelimiterOffset, segmentHasTrailingSlash, true);
-        i = pathSegmentDelimiterOffset;
-        if (segmentHasTrailingSlash) i++;
-      }
-    }
-
-    /** Adds a path segment. If the input is ".." or equivalent, this pops a path segment. */
-    private void push(String input, int pos, int limit, boolean addTrailingSlash,
-        boolean alreadyEncoded) {
-      String segment = canonicalize(
-          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false, false, true, null);
-      if (isDot(segment)) {
-        return; // Skip '.' path segments.
-      }
-      if (isDotDot(segment)) {
-        pop();
-        return;
-      }
-      if (encodedPathSegments.get(encodedPathSegments.size() - 1).isEmpty()) {
-        encodedPathSegments.set(encodedPathSegments.size() - 1, segment);
-      } else {
-        encodedPathSegments.add(segment);
-      }
-      if (addTrailingSlash) {
-        encodedPathSegments.add("");
-      }
-    }
-
-    private boolean isDot(String input) {
-      return input.equals(".") || input.equalsIgnoreCase("%2e");
-    }
-
-    private boolean isDotDot(String input) {
-      return input.equals("..")
-          || input.equalsIgnoreCase("%2e.")
-          || input.equalsIgnoreCase(".%2e")
-          || input.equalsIgnoreCase("%2e%2e");
-    }
-
-    /**
-     * Removes a path segment. When this method returns the last segment is always "", which means
-     * the encoded path will have a trailing '/'.
-     *
-     * <p>Popping "/a/b/c/" yields "/a/b/". In this case the list of path segments goes from ["a",
-     * "b", "c", ""] to ["a", "b", ""].
-     *
-     * <p>Popping "/a/b/c" also yields "/a/b/". The list of path segments goes from ["a", "b", "c"]
-     * to ["a", "b", ""].
-     */
-    private void pop() {
-      String removed = encodedPathSegments.remove(encodedPathSegments.size() - 1);
-
-      // Make sure the path ends with a '/' by either adding an empty string or clearing a segment.
-      if (removed.isEmpty() && !encodedPathSegments.isEmpty()) {
-        encodedPathSegments.set(encodedPathSegments.size() - 1, "");
-      } else {
-        encodedPathSegments.add("");
-      }
-    }
-
-    /**
-     * Returns the index of the ':' in {@code input} that is after scheme characters. Returns -1 if
-     * {@code input} does not have a scheme that starts at {@code pos}.
-     */
-    private static int schemeDelimiterOffset(String input, int pos, int limit) {
-      if (limit - pos < 2) return -1;
-
-      char c0 = input.charAt(pos);
-      if ((c0 < 'a' || c0 > 'z') && (c0 < 'A' || c0 > 'Z')) return -1; // Not a scheme start char.
-
-      for (int i = pos + 1; i < limit; i++) {
-        char c = input.charAt(i);
-
-        if ((c >= 'a' && c <= 'z')
-            || (c >= 'A' && c <= 'Z')
-            || (c >= '0' && c <= '9')
-            || c == '+'
-            || c == '-'
-            || c == '.') {
-          continue; // Scheme character. Keep going.
-        } else if (c == ':') {
-          return i; // Scheme prefix!
-        } else {
-          return -1; // Non-scheme character before the first ':'.
-        }
-      }
-
-      return -1; // No ':'; doesn't start with a scheme.
-    }
-
-    /** Returns the number of '/' and '\' slashes in {@code input}, starting at {@code pos}. */
-    private static int slashCount(String input, int pos, int limit) {
-      int slashCount = 0;
-      while (pos < limit) {
-        char c = input.charAt(pos);
-        if (c == '\\' || c == '/') {
-          slashCount++;
-          pos++;
-        } else {
-          break;
-        }
-      }
-      return slashCount;
-    }
-
-    /** Finds the first ':' in {@code input}, skipping characters between square braces "[...]". */
-    private static int portColonOffset(String input, int pos, int limit) {
-      for (int i = pos; i < limit; i++) {
-        switch (input.charAt(i)) {
-          case '[':
-            while (++i < limit) {
-              if (input.charAt(i) == ']') break;
-            }
-            break;
-          case ':':
-            return i;
-        }
-      }
-      return limit; // No colon.
-    }
-
-    private static @Nullable String canonicalizeHost(String input, int pos, int limit) {
-      // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
-      // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
-      String percentDecoded = percentDecode(input, pos, limit, false);
-      return Util.canonicalizeHost(percentDecoded);
-    }
-
-    private static int parsePort(String input, int pos, int limit) {
-      try {
-        // Canonicalize the port string to skip '\n' etc.
-        String portString = canonicalize(input, pos, limit, "", false, false, false, true, null);
-        int i = Integer.parseInt(portString);
-        if (i > 0 && i <= 65535) return i;
-        return -1;
-      } catch (NumberFormatException e) {
-        return -1; // Invalid port.
-      }
-    }
-  }
-
-  static String percentDecode(String encoded, boolean plusIsSpace) {
-    return percentDecode(encoded, 0, encoded.length(), plusIsSpace);
-  }
-
-  private List<String> percentDecode(List<String> list, boolean plusIsSpace) {
-    int size = list.size();
-    List<String> result = new ArrayList<>(size);
-    for (int i = 0; i < size; i++) {
-      String s = list.get(i);
-      result.add(s != null ? percentDecode(s, plusIsSpace) : null);
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  static String percentDecode(String encoded, int pos, int limit, boolean plusIsSpace) {
-    for (int i = pos; i < limit; i++) {
-      char c = encoded.charAt(i);
-      if (c == '%' || (c == '+' && plusIsSpace)) {
-        // Slow path: the character at i requires decoding!
-        Buffer out = new Buffer();
-        out.writeUtf8(encoded, pos, i);
-        percentDecode(out, encoded, i, limit, plusIsSpace);
-        return out.readUtf8();
-      }
-    }
-
-    // Fast path: no characters in [pos..limit) required decoding.
-    return encoded.substring(pos, limit);
-  }
-
-  static void percentDecode(Buffer out, String encoded, int pos, int limit, boolean plusIsSpace) {
-    int codePoint;
-    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
-      codePoint = encoded.codePointAt(i);
-      if (codePoint == '%' && i + 2 < limit) {
-        int d1 = decodeHexDigit(encoded.charAt(i + 1));
-        int d2 = decodeHexDigit(encoded.charAt(i + 2));
-        if (d1 != -1 && d2 != -1) {
-          out.writeByte((d1 << 4) + d2);
-          i += 2;
-          continue;
-        }
-      } else if (codePoint == '+' && plusIsSpace) {
-        out.writeByte(' ');
-        continue;
-      }
-      out.writeUtf8CodePoint(codePoint);
-    }
-  }
-
-  static boolean percentEncoded(String encoded, int pos, int limit) {
-    return pos + 2 < limit
-        && encoded.charAt(pos) == '%'
-        && decodeHexDigit(encoded.charAt(pos + 1)) != -1
-        && decodeHexDigit(encoded.charAt(pos + 2)) != -1;
-  }
-
-  /**
-   * Returns a substring of {@code input} on the range {@code [pos..limit)} with the following
-   * transformations:
-   * <ul>
-   *   <li>Tabs, newlines, form feeds and carriage returns are skipped.
-   *   <li>In queries, ' ' is encoded to '+' and '+' is encoded to "%2B".
-   *   <li>Characters in {@code encodeSet} are percent-encoded.
-   *   <li>Control characters and non-ASCII characters are percent-encoded.
-   *   <li>All other characters are copied without transformation.
-   * </ul>
-   *
-   * @param alreadyEncoded true to leave '%' as-is; false to convert it to '%25'.
-   * @param strict true to encode '%' if it is not the prefix of a valid percent encoding.
-   * @param plusIsSpace true to encode '+' as "%2B" if it is not already encoded.
-   * @param asciiOnly true to encode all non-ASCII codepoints.
-   * @param charset which charset to use, null equals UTF-8.
-   */
-  static String canonicalize(String input, int pos, int limit, String encodeSet,
-      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly,
-      @Nullable Charset charset) {
-    int codePoint;
-    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
-      codePoint = input.codePointAt(i);
-      if (codePoint < 0x20
-          || codePoint == 0x7f
-          || codePoint >= 0x80 && asciiOnly
-          || encodeSet.indexOf(codePoint) != -1
-          || codePoint == '%' && (!alreadyEncoded || strict && !percentEncoded(input, i, limit))
-          || codePoint == '+' && plusIsSpace) {
-        // Slow path: the character at i requires encoding!
-        Buffer out = new Buffer();
-        out.writeUtf8(input, pos, i);
-        canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, strict, plusIsSpace,
-            asciiOnly, charset);
-        return out.readUtf8();
-      }
-    }
-
-    // Fast path: no characters in [pos..limit) required encoding.
-    return input.substring(pos, limit);
-  }
-
-  static void canonicalize(Buffer out, String input, int pos, int limit, String encodeSet,
-      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly,
-      @Nullable Charset charset) {
-    Buffer encodedCharBuffer = null; // Lazily allocated.
-    int codePoint;
-    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
-      codePoint = input.codePointAt(i);
-      if (alreadyEncoded
-          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
-        // Skip this character.
-      } else if (codePoint == '+' && plusIsSpace) {
-        // Encode '+' as '%2B' since we permit ' ' to be encoded as either '+' or '%20'.
-        out.writeUtf8(alreadyEncoded ? "+" : "%2B");
-      } else if (codePoint < 0x20
-          || codePoint == 0x7f
-          || codePoint >= 0x80 && asciiOnly
-          || encodeSet.indexOf(codePoint) != -1
-          || codePoint == '%' && (!alreadyEncoded || strict && !percentEncoded(input, i, limit))) {
-        // Percent encode this character.
-        if (encodedCharBuffer == null) {
-          encodedCharBuffer = new Buffer();
-        }
-
-        if (charset == null || charset.equals(UTF_8)) {
-          encodedCharBuffer.writeUtf8CodePoint(codePoint);
-        } else {
-          encodedCharBuffer.writeString(input, i, i + Character.charCount(codePoint), charset);
-        }
-
-        while (!encodedCharBuffer.exhausted()) {
-          int b = encodedCharBuffer.readByte() & 0xff;
-          out.writeByte('%');
-          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
-          out.writeByte(HEX_DIGITS[b & 0xf]);
-        }
-      } else {
-        // This character doesn't need encoding. Just copy it over.
-        out.writeUtf8CodePoint(codePoint);
-      }
-    }
-  }
-
-  static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
-      boolean plusIsSpace, boolean asciiOnly, @Nullable Charset charset) {
-    return canonicalize(input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace,
-        asciiOnly, charset);
-  }
-
-  static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
-      boolean plusIsSpace, boolean asciiOnly) {
-   return canonicalize(
-        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly, null);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.kt b/okhttp/src/main/java/okhttp3/HttpUrl.kt
new file mode 100644
index 0000000000..38e26808e4
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.kt
@@ -0,0 +1,1778 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.HttpUrl.Companion.get
+import okhttp3.HttpUrl.Companion.parse
+import okhttp3.internal.Util
+import okhttp3.internal.Util.decodeHexDigit
+import okhttp3.internal.Util.delimiterOffset
+import okhttp3.internal.Util.skipLeadingAsciiWhitespace
+import okhttp3.internal.Util.skipTrailingAsciiWhitespace
+import okhttp3.internal.Util.verifyAsIpAddress
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase
+import okio.Buffer
+import java.net.InetAddress
+import java.net.MalformedURLException
+import java.net.URI
+import java.net.URISyntaxException
+import java.net.URL
+import java.nio.charset.Charset
+import java.nio.charset.StandardCharsets.UTF_8
+import java.util.ArrayList
+import java.util.Collections
+import java.util.LinkedHashSet
+
+/**
+ * A uniform resource locator (URL) with a scheme of either `http` or `https`. Use this class to
+ * compose and decompose Internet addresses. For example, this code will compose and print a URL for
+ * Google search:
+ *
+ * ```
+ * HttpUrl url = new HttpUrl.Builder()
+ *     .scheme("https")
+ *     .host("www.google.com")
+ *     .addPathSegment("search")
+ *     .addQueryParameter("q", "polar bears")
+ *     .build();
+ * System.out.println(url);
+ * ```
+ *
+ * which prints:
+ *
+ * ```
+ * https://www.google.com/search?q=polar%20bears
+ * ```
+ *
+ * As another example, this code prints the human-readable query parameters of a Twitter search:
+ *
+ * ```
+ * HttpUrl url = HttpUrl.parse("https://twitter.com/search?q=cute%20%23puppies&f=images");
+ * for (int i = 0, size = url.querySize(); i < size; i++) {
+ *   System.out.println(url.queryParameterName(i) + ": " + url.queryParameterValue(i));
+ * }
+ * ```
+ *
+ * which prints:
+ *
+ * ```
+ * q: cute #puppies
+ * f: images
+ * ```
+ *
+ * In addition to composing URLs from their component parts and decomposing URLs into their
+ * component parts, this class implements relative URL resolution: what address you'd reach by
+ * clicking a relative link on a specified page. For example:
+ *
+ * ```
+ * HttpUrl base = HttpUrl.parse("https://www.youtube.com/user/WatchTheDaily/videos");
+ * HttpUrl link = base.resolve("../../watch?v=cbP2N1BQdYc");
+ * System.out.println(link);
+ * ```
+ *
+ * which prints:
+ *
+ * ```
+ * https://www.youtube.com/watch?v=cbP2N1BQdYc
+ * ```
+ *
+ * ## What's in a URL?
+ *
+ * A URL has several components.
+ *
+ * ### Scheme
+ *
+ * Sometimes referred to as *protocol*, A URL's scheme describes what mechanism should be used to
+ * retrieve the resource. Although URLs have many schemes (`mailto`, `file`, `ftp`), this class only
+ * supports `http` and `https`. Use [java.net.URI][URI] for URLs with arbitrary schemes.
+ *
+ * ### Username and Password
+ *
+ * Username and password are either present, or the empty string `""` if absent. This class offers
+ * no mechanism to differentiate empty from absent. Neither of these components are popular in
+ * practice. Typically HTTP applications use other mechanisms for user identification and
+ * authentication.
+ *
+ * ### Host
+ *
+ * The host identifies the webserver that serves the URL's resource. It is either a hostname like
+ * `square.com` or `localhost`, an IPv4 address like `192.168.0.1`, or an IPv6 address like `::1`.
+ *
+ * Usually a webserver is reachable with multiple identifiers: its IP addresses, registered
+ * domain names, and even `localhost` when connecting from the server itself. Each of a web server's
+ * names is a distinct URL and they are not interchangeable. For example, even if
+ * `http://square.github.io/dagger` and `http://google.github.io/dagger` are served by the same IP
+ * address, the two URLs identify different resources.
+ *
+ * ### Port
+ *
+ * The port used to connect to the web server. By default this is 80 for HTTP and 443 for HTTPS.
+ * This class never returns -1 for the port: if no port is explicitly specified in the URL then the
+ * scheme's default is used.
+ *
+ * ### Path
+ *
+ * The path identifies a specific resource on the host. Paths have a hierarchical structure like
+ * "/square/okhttp/issues/1486" and decompose into a list of segments like `["square", "okhttp",
+ * "issues", "1486"]`.
+ *
+ * This class offers methods to compose and decompose paths by segment. It composes each path
+ * from a list of segments by alternating between "/" and the encoded segment. For example the
+ * segments `["a", "b"]` build "/a/b" and the segments `["a", "b", ""]` build "/a/b/".
+ *
+ * If a path's last segment is the empty string then the path ends with "/". This class always
+ * builds non-empty paths: if the path is omitted it defaults to "/". The default path's segment
+ * list is a single empty string: `[""]`.
+ *
+ * ### Query
+ *
+ * The query is optional: it can be null, empty, or non-empty. For many HTTP URLs the query string
+ * is subdivided into a collection of name-value parameters. This class offers methods to set the
+ * query as the single string, or as individual name-value parameters. With name-value parameters
+ * the values are optional and names may be repeated.
+ *
+ * ### Fragment
+ *
+ * The fragment is optional: it can be null, empty, or non-empty. Unlike host, port, path, and
+ * query the fragment is not sent to the webserver: it's private to the client.
+ *
+ * ## Encoding
+ *
+ * Each component must be encoded before it is embedded in the complete URL. As we saw above, the
+ * string `cute #puppies` is encoded as `cute%20%23puppies` when used as a query parameter value.
+ *
+ * ### Percent encoding
+ *
+ * Percent encoding replaces a character (like `\ud83c\udf69`) with its UTF-8 hex bytes (like
+ * `%F0%9F%8D%A9`). This approach works for whitespace characters, control characters, non-ASCII
+ * characters, and characters that already have another meaning in a particular context.
+ *
+ * Percent encoding is used in every URL component except for the hostname. But the set of
+ * characters that need to be encoded is different for each component. For example, the path
+ * component must escape all of its `?` characters, otherwise it could be interpreted as the
+ * start of the URL's query. But within the query and fragment components, the `?` character
+ * doesn't delimit anything and doesn't need to be escaped.
+ *
+ * ```
+ * HttpUrl url = HttpUrl.parse("http://who-let-the-dogs.out").newBuilder()
+ *     .addPathSegment("_Who?_")
+ *     .query("_Who?_")
+ *     .fragment("_Who?_")
+ *     .build();
+ * System.out.println(url);
+ * ```
+ *
+ * This prints:
+ *
+ * ```
+ * http://who-let-the-dogs.out/_Who%3F_?_Who?_#_Who?_
+ * ```
+ *
+ * When parsing URLs that lack percent encoding where it is required, this class will percent encode
+ * the offending characters.
+ *
+ * ### IDNA Mapping and Punycode encoding
+ *
+ * Hostnames have different requirements and use a different encoding scheme. It consists of IDNA
+ * mapping and Punycode encoding.
+ *
+ * In order to avoid confusion and discourage phishing attacks, [IDNA Mapping][idna] transforms
+ * names to avoid confusing characters. This includes basic case folding: transforming shouting
+ * `SQUARE.COM` into cool and casual `square.com`. It also handles more exotic characters. For
+ * example, the Unicode trademark sign () could be confused for the letters "TM" in
+ * `http://homail.com`. To mitigate this, the single character () maps to the string (tm). There
+ * is similar policy for all of the 1.1 million Unicode code points. Note that some code points such
+ * as "\ud83c\udf69" are not mapped and cannot be used in a hostname.
+ *
+ * [Punycode](http://ietf.org/rfc/rfc3492.txt) converts a Unicode string to an ASCII string to make
+ * international domain names work everywhere. For example, "" encodes as "xn--4xa". The encoded
+ * string is not human readable, but can be used with classes like [InetAddress] to establish
+ * connections.
+ *
+ * ## Why another URL model?
+ *
+ * Java includes both [java.net.URL][URL] and [java.net.URI][URI]. We offer a new URL
+ * model to address problems that the others don't.
+ *
+ * ### Different URLs should be different
+ *
+ * Although they have different content, `java.net.URL` considers the following two URLs
+ * equal, and the [equals()][Object.equals] method between them returns true:
+ *
+ *  * http://square.github.io/
+ *
+ *  * http://google.github.io/
+ *
+ * This is because those two hosts share the same IP address. This is an old, bad design decision
+ * that makes `java.net.URL` unusable for many things. It shouldn't be used as a [Map] key or in a
+ * [Set]. Doing so is both inefficient because equality may require a DNS lookup, and incorrect
+ * because unequal URLs may be equal because of how they are hosted.
+ *
+ * ### Equal URLs should be equal
+ *
+ * These two URLs are semantically identical, but `java.net.URI` disagrees:
+ *
+ *  * http://host:80/
+ *
+ *  * http://host
+ *
+ * Both the unnecessary port specification (`:80`) and the absent trailing slash (`/`) cause URI to
+ * bucket the two URLs separately. This harms URI's usefulness in collections. Any application that
+ * stores information-per-URL will need to either canonicalize manually, or suffer unnecessary
+ * redundancy for such URLs.
+ *
+ * Because they don't attempt canonical form, these classes are surprisingly difficult to use
+ * securely. Suppose you're building a webservice that checks that incoming paths are prefixed
+ * "/static/images/" before serving the corresponding assets from the filesystem.
+ *
+ * ```
+ * String attack = "http://example.com/static/images/../../../../../etc/passwd";
+ * System.out.println(new URL(attack).getPath());
+ * System.out.println(new URI(attack).getPath());
+ * System.out.println(HttpUrl.parse(attack).encodedPath());
+ * ```
+ *
+ * By canonicalizing the input paths, they are complicit in directory traversal attacks. Code that
+ * checks only the path prefix may suffer!
+ *
+ * ```
+ * /static/images/../../../../../etc/passwd
+ * /static/images/../../../../../etc/passwd
+ * /etc/passwd
+ * ```
+ *
+ * ### If it works on the web, it should work in your application
+ *
+ * The `java.net.URI` class is strict around what URLs it accepts. It rejects URLs like
+ * `http://example.com/abc|def` because the `|` character is unsupported. This class is more
+ * forgiving: it will automatically percent-encode the `|'` yielding `http://example.com/abc%7Cdef`.
+ * This kind behavior is consistent with web browsers. `HttpUrl` prefers consistency with major web
+ * browsers over consistency with obsolete specifications.
+ *
+ * ### Paths and Queries should decompose
+ *
+ * Neither of the built-in URL models offer direct access to path segments or query parameters.
+ * Manually using `StringBuilder` to assemble these components is cumbersome: do '+' characters get
+ * silently replaced with spaces? If a query parameter contains a '&amp;', does that get escaped?
+ * By offering methods to read and write individual query parameters directly, application
+ * developers are saved from the hassles of encoding and decoding.
+ *
+ * ### Plus a modern API
+ *
+ * The URL (JDK1.0) and URI (Java 1.4) classes predate builders and instead use telescoping
+ * constructors. For example, there's no API to compose a URI with a custom port without also
+ * providing a query and fragment.
+ *
+ * Instances of [HttpUrl] are well-formed and always have a scheme, host, and path. With
+ * `java.net.URL` it's possible to create an awkward URL like `http:/` with scheme and path but no
+ * hostname. Building APIs that consume such malformed values is difficult!
+ *
+ * This class has a modern API. It avoids punitive checked exceptions: [get] throws
+ * [IllegalArgumentException] on invalid input or [parse] returns null if the input is an invalid
+ * URL. You can even be explicit about whether each component has been encoded already.
+ *
+ * [idna]: http://www.unicode.org/reports/tr46/#ToASCII
+ */
+class HttpUrl internal constructor(builder: Builder) {
+
+  /** Either "http" or "https".  */
+  internal val scheme: String = builder.scheme ?: throw IllegalStateException("scheme == null")
+
+  /** Decoded username.  */
+  private val username: String = percentDecode(builder.encodedUsername, false)
+
+  /** Decoded password.  */
+  private val password: String = percentDecode(builder.encodedPassword, false)
+
+  /** Canonical hostname.  */
+  internal val host: String = builder.host ?: throw IllegalStateException("host == null")
+
+  /** Either 80, 443 or a user-specified port. In range [1..65535].  */
+  internal val port: Int = builder.effectivePort()
+
+  /**
+   * A list of canonical path segments. This list always contains at least one element, which may be
+   * the empty string. Each segment is formatted with a leading '/', so if path segments were ["a",
+   * "b", ""], then the encoded path would be "/a/b/".
+   */
+  @Suppress("UNCHECKED_CAST")
+  private val pathSegments: List<String> =
+      percentDecode(builder.encodedPathSegments, false) as List<String>
+
+  /**
+   * Alternating, decoded query names and values, or null for no query. Names may be empty or
+   * non-empty, but never null. Values are null if the name has no corresponding '=' separator, or
+   * empty, or non-empty.
+   */
+  private val queryNamesAndValues: List<String?>? =
+      builder.encodedQueryNamesAndValues?.let { percentDecode(it, true) }
+
+  /** Decoded fragment.  */
+  private val fragment: String? = builder.encodedFragment?.let { percentDecode(it, false) }
+
+  /** Canonical URL.  */
+  private val url: String = builder.toString()
+
+  val isHttps: Boolean = scheme == "https"
+
+  /** Returns this URL as a [java.net.URL][URL].  */
+  fun url(): URL {
+    try {
+      return URL(url)
+    } catch (e: MalformedURLException) {
+      throw RuntimeException(e) // Unexpected!
+    }
+  }
+
+  /**
+   * Returns this URL as a [java.net.URI][URI]. Because `URI` is more strict than this class, the
+   * returned URI may be semantically different from this URL:
+   *
+   *  * Characters forbidden by URI like `[` and `|` will be escaped.
+   *
+   *  * Invalid percent-encoded sequences like `%xx` will be encoded like `%25xx`.
+   *
+   *  * Whitespace and control characters in the fragment will be stripped.
+   *
+   * These differences may have a significant consequence when the URI is interpreted by a
+   * web server. For this reason the [URI class][URI] and this method should be avoided.
+   */
+  fun uri(): URI {
+    val uri = newBuilder().reencodeForUri().toString()
+    try {
+      return URI(uri)
+    } catch (e: URISyntaxException) {
+      // Unlikely edge case: the URI has a forbidden character in the fragment. Strip it & retry.
+      try {
+        val stripped = uri.replace(Regex("[\\u0000-\\u001F\\u007F-\\u009F\\p{javaWhitespace}]"), "")
+        return URI.create(stripped)
+      } catch (e1: Exception) {
+        throw RuntimeException(e) // Unexpected!
+      }
+    }
+  }
+
+  /** Returns either "http" or "https".  */
+  fun scheme(): String = scheme
+
+  /**
+   * Returns the username, or an empty string if none is set.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`encodedUsername()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`""`</td></tr>
+   * <tr><td>`http://username@host/`</td><td>`"username"`</td></tr>
+   * <tr><td>`http://username:password@host/`</td><td>`"username"`</td></tr>
+   * <tr><td>`http://a%20b:c%20d@host/`</td><td>`"a%20b"`</td></tr>
+   * </table>
+   */
+  fun encodedUsername(): String {
+    if (username.isEmpty()) return ""
+    val usernameStart = scheme.length + 3 // "://".length() == 3.
+    val usernameEnd = delimiterOffset(url, usernameStart, url.length, ":@")
+    return url.substring(usernameStart, usernameEnd)
+  }
+
+  /**
+   * Returns the decoded username, or an empty string if none is present.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`username()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`""`</td></tr>
+   * <tr><td>`http://username@host/`</td><td>`"username"`</td></tr>
+   * <tr><td>`http://username:password@host/`</td><td>`"username"`</td></tr>
+   * <tr><td>`http://a%20b:c%20d@host/`</td><td>`"a b"`</td></tr>
+   * </table>
+   */
+  fun username(): String = username
+
+  /**
+   * Returns the password, or an empty string if none is set.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`encodedPassword()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`""`</td></tr>
+   * <tr><td>`http://username@host/`</td><td>`""`</td></tr>
+   * <tr><td>`http://username:password@host/`</td><td>`"password"`</td></tr>
+   * <tr><td>`http://a%20b:c%20d@host/`</td><td>`"c%20d"`</td></tr>
+   * </table>
+   */
+  fun encodedPassword(): String {
+    if (password.isEmpty()) return ""
+    val passwordStart = url.indexOf(':', scheme.length + 3) + 1
+    val passwordEnd = url.indexOf('@')
+    return url.substring(passwordStart, passwordEnd)
+  }
+
+  /**
+   * Returns the decoded password, or an empty string if none is present.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`password()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`""`</td></tr>
+   * <tr><td>`http://username@host/`</td><td>`""`</td></tr>
+   * <tr><td>`http://username:password@host/`</td><td>`"password"`</td></tr>
+   * <tr><td>`http://a%20b:c%20d@host/`</td><td>`"c d"`</td></tr>
+   * </table>
+   */
+  fun password(): String = password
+
+  /**
+   * Returns the host address suitable for use with [InetAddress.getAllByName]. May be:
+   *
+   *  * A regular host name, like `android.com`.
+   *
+   *  * An IPv4 address, like `127.0.0.1`.
+   *
+   *  * An IPv6 address, like `::1`. Note that there are no square braces.
+   *
+   *  * An encoded IDN, like `xn--n3h.net`.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`host()`</th></tr>
+   * <tr><td>`http://android.com/`</td><td>`"android.com"`</td></tr>
+   * <tr><td>`http://127.0.0.1/`</td><td>`"127.0.0.1"`</td></tr>
+   * <tr><td>`http://[::1]/`</td><td>`"::1"`</td></tr>
+   * <tr><td>`http://xn--n3h.net/`</td><td>`"xn--n3h.net"`</td></tr>
+   * </table>
+   */
+  fun host(): String = host
+
+  /**
+   * Returns the explicitly-specified port if one was provided, or the default port for this URL's
+   * scheme. For example, this returns 8443 for `https://square.com:8443/` and 443 for
+   * `https://square.com/`. The result is in `[1..65535]`.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`port()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`80`</td></tr>
+   * <tr><td>`http://host:8000/`</td><td>`8000`</td></tr>
+   * <tr><td>`https://host/`</td><td>`443`</td></tr>
+   * </table>
+   */
+  fun port(): Int = port
+
+  /**
+   * Returns the number of segments in this URL's path. This is also the number of slashes in the
+   * URL's path, like 3 in `http://host/a/b/c`. This is always at least 1.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`pathSize()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`1`</td></tr>
+   * <tr><td>`http://host/a/b/c`</td><td>`3`</td></tr>
+   * <tr><td>`http://host/a/b/c/`</td><td>`4`</td></tr>
+   * </table>
+   */
+  fun pathSize(): Int = pathSegments.size
+
+  /**
+   * Returns the entire path of this URL encoded for use in HTTP resource resolution. The returned
+   * path will start with `"/"`.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`encodedPath()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`"/"`</td></tr>
+   * <tr><td>`http://host/a/b/c`</td><td>`"/a/b/c"`</td></tr>
+   * <tr><td>`http://host/a/b%20c/d`</td><td>`"/a/b%20c/d"`</td></tr>
+   * </table>
+   */
+  fun encodedPath(): String {
+    val pathStart = url.indexOf('/', scheme.length + 3) // "://".length() == 3.
+    val pathEnd = delimiterOffset(url, pathStart, url.length, "?#")
+    return url.substring(pathStart, pathEnd)
+  }
+
+  /**
+   * Returns a list of encoded path segments like `["a", "b", "c"]` for the URL `http://host/a/b/c`.
+   * This list is never empty though it may contain a single empty string.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`encodedPathSegments()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`[""]`</td></tr>
+   * <tr><td>`http://host/a/b/c`</td><td>`["a", "b", "c"]`</td></tr>
+   * <tr><td>`http://host/a/b%20c/d`</td><td>`["a", "b%20c", "d"]`</td></tr>
+   * </table>
+   */
+  fun encodedPathSegments(): List<String> {
+    val pathStart = url.indexOf('/', scheme.length + 3)
+    val pathEnd = delimiterOffset(url, pathStart, url.length, "?#")
+    val result = ArrayList<String>()
+    var i = pathStart
+    while (i < pathEnd) {
+      i++ // Skip the '/'.
+      val segmentEnd = delimiterOffset(url, i, pathEnd, '/')
+      result.add(url.substring(i, segmentEnd))
+      i = segmentEnd
+    }
+    return result
+  }
+
+  /**
+   * Returns a list of path segments like `["a", "b", "c"]` for the URL `http://host/a/b/c`. This
+   * list is never empty though it may contain a single empty string.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`pathSegments()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`[""]`</td></tr>
+   * <tr><td>`http://host/a/b/c"`</td><td>`["a", "b", "c"]`</td></tr>
+   * <tr><td>`http://host/a/b%20c/d"`</td><td>`["a", "b c", "d"]`</td></tr>
+   * </table>
+   */
+  fun pathSegments(): List<String> = pathSegments
+
+  /**
+   * Returns the query of this URL, encoded for use in HTTP resource resolution. The returned string
+   * may be null (for URLs with no query), empty (for URLs with an empty query) or non-empty (all
+   * other URLs).
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`encodedQuery()`</th></tr>
+   * <tr><td>`http://host/`</td><td>null</td></tr>
+   * <tr><td>`http://host/?`</td><td>`""`</td></tr>
+   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`"a=apple&k=key+lime"`</td></tr>
+   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`"a=apple&a=apricot"`</td></tr>
+   * <tr><td>`http://host/?a=apple&b`</td><td>`"a=apple&b"`</td></tr>
+   * </table>
+   */
+  fun encodedQuery(): String? {
+    if (queryNamesAndValues == null) return null // No query.
+    val queryStart = url.indexOf('?') + 1
+    val queryEnd = delimiterOffset(url, queryStart, url.length, '#')
+    return url.substring(queryStart, queryEnd)
+  }
+
+  /**
+   * Returns this URL's query, like `"abc"` for `http://host/?abc`. Most callers should
+   * prefer [queryParameterName] and [queryParameterValue] because these methods offer direct access
+   * to individual query parameters.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`query()`</th></tr>
+   * <tr><td>`http://host/`</td><td>null</td></tr>
+   * <tr><td>`http://host/?`</td><td>`""`</td></tr>
+   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`"a=apple&k=key
+   * lime"`</td></tr>
+   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`"a=apple&a=apricot"`</td></tr>
+   * <tr><td>`http://host/?a=apple&b`</td><td>`"a=apple&b"`</td></tr>
+   * </table>
+   */
+  fun query(): String? {
+    if (queryNamesAndValues == null) return null // No query.
+    val result = StringBuilder()
+    namesAndValuesToQueryString(result, queryNamesAndValues)
+    return result.toString()
+  }
+
+  /**
+   * Returns the number of query parameters in this URL, like 2 for `http://host/?a=apple&b=banana`.
+   * If this URL has no query this returns 0. Otherwise it returns one more than the number of `"&"`
+   * separators in the query.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`querySize()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`0`</td></tr>
+   * <tr><td>`http://host/?`</td><td>`1`</td></tr>
+   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`2`</td></tr>
+   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`2`</td></tr>
+   * <tr><td>`http://host/?a=apple&b`</td><td>`2`</td></tr>
+   * </table>
+   */
+  fun querySize(): Int {
+    return if (queryNamesAndValues != null) queryNamesAndValues.size / 2 else 0
+  }
+
+  /**
+   * Returns the first query parameter named `name` decoded using UTF-8, or null if there is
+   * no such query parameter.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`queryParameter("a")`</th></tr>
+   * <tr><td>`http://host/`</td><td>null</td></tr>
+   * <tr><td>`http://host/?`</td><td>null</td></tr>
+   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`"apple"`</td></tr>
+   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`"apple"`</td></tr>
+   * <tr><td>`http://host/?a=apple&b`</td><td>`"apple"`</td></tr>
+   * </table>
+   */
+  fun queryParameter(name: String): String? {
+    if (queryNamesAndValues == null) return null
+    for (i in 0 until queryNamesAndValues.size step 2) {
+      if (name == queryNamesAndValues[i]) {
+        return queryNamesAndValues[i + 1]
+      }
+    }
+    return null
+  }
+
+  /**
+   * Returns the distinct query parameter names in this URL, like `["a", "b"]` for
+   * `http://host/?a=apple&b=banana`. If this URL has no query this returns the empty set.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`queryParameterNames()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`[]`</td></tr>
+   * <tr><td>`http://host/?`</td><td>`[""]`</td></tr>
+   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`["a", "k"]`</td></tr>
+   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`["a"]`</td></tr>
+   * <tr><td>`http://host/?a=apple&b`</td><td>`["a", "b"]`</td></tr>
+   * </table>
+   */
+  fun queryParameterNames(): Set<String> {
+    if (queryNamesAndValues == null) return emptySet()
+    val result = LinkedHashSet<String>()
+    for (i in 0 until queryNamesAndValues.size step 2) {
+      result.add(queryNamesAndValues[i]!!)
+    }
+    return Collections.unmodifiableSet(result)
+  }
+
+  /**
+   * Returns all values for the query parameter `name` ordered by their appearance in this
+   * URL. For example this returns `["banana"]` for `queryParameterValue("b")` on
+   * `http://host/?a=apple&b=banana`.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`queryParameterValues("a")`</th><th>`queryParameterValues("b")`</th></tr>
+   * <tr><td>`http://host/`</td><td>`[]`</td><td>`[]`</td></tr>
+   * <tr><td>`http://host/?`</td><td>`[]`</td><td>`[]`</td></tr>
+   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`["apple"]`</td><td>`[]`</td></tr>
+   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`["apple", "apricot"]`</td><td>`[]`</td></tr>
+   * <tr><td>`http://host/?a=apple&b`</td><td>`["apple"]`</td><td>`[null]`</td></tr>
+   * </table>
+   */
+  fun queryParameterValues(name: String): List<String?> {
+    if (queryNamesAndValues == null) return emptyList()
+    val result = ArrayList<String?>()
+    for (i in 0 until queryNamesAndValues.size step 2) {
+      if (name == queryNamesAndValues[i]) {
+        result.add(queryNamesAndValues[i + 1])
+      }
+    }
+    return Collections.unmodifiableList(result)
+  }
+
+  /**
+   * Returns the name of the query parameter at `index`. For example this returns `"a"`
+   * for `queryParameterName(0)` on `http://host/?a=apple&b=banana`. This throws if
+   * `index` is not less than the [query size][querySize].
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`queryParameterName(0)`</th><th>`queryParameterName(1)`</th></tr>
+   * <tr><td>`http://host/`</td><td>exception</td><td>exception</td></tr>
+   * <tr><td>`http://host/?`</td><td>`""`</td><td>exception</td></tr>
+   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`"a"`</td><td>`"k"`</td></tr>
+   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`"a"`</td><td>`"a"`</td></tr>
+   * <tr><td>`http://host/?a=apple&b`</td><td>`"a"`</td><td>`"b"`</td></tr>
+   * </table>
+   */
+  fun queryParameterName(index: Int): String {
+    if (queryNamesAndValues == null) throw IndexOutOfBoundsException()
+    return queryNamesAndValues[index * 2]!!
+  }
+
+  /**
+   * Returns the value of the query parameter at `index`. For example this returns `"apple"` for
+   * `queryParameterName(0)` on `http://host/?a=apple&b=banana`. This throws if `index` is not less
+   * than the [query size][querySize].
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`queryParameterValue(0)`</th><th>`queryParameterValue(1)`</th></tr>
+   * <tr><td>`http://host/`</td><td>exception</td><td>exception</td></tr>
+   * <tr><td>`http://host/?`</td><td>null</td><td>exception</td></tr>
+   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`"apple"`</td><td>`"key lime"`</td></tr>
+   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`"apple"`</td><td>`"apricot"`</td></tr>
+   * <tr><td>`http://host/?a=apple&b`</td><td>`"apple"`</td><td>null</td></tr>
+   * </table>
+   */
+  fun queryParameterValue(index: Int): String? {
+    if (queryNamesAndValues == null) throw IndexOutOfBoundsException()
+    return queryNamesAndValues[index * 2 + 1]
+  }
+
+  /**
+   * Returns this URL's encoded fragment, like `"abc"` for `http://host/#abc`. This returns null if
+   * the URL has no fragment.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`encodedFragment()`</th></tr>
+   * <tr><td>`http://host/`</td><td>null</td></tr>
+   * <tr><td>`http://host/#`</td><td>`""`</td></tr>
+   * <tr><td>`http://host/#abc`</td><td>`"abc"`</td></tr>
+   * <tr><td>`http://host/#abc|def`</td><td>`"abc|def"`</td></tr>
+   * </table>
+   */
+  fun encodedFragment(): String? {
+    if (fragment == null) return null
+    val fragmentStart = url.indexOf('#') + 1
+    return url.substring(fragmentStart)
+  }
+
+  /**
+   * Returns this URL's fragment, like `"abc"` for `http://host/#abc`. This returns null
+   * if the URL has no fragment.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`fragment()`</th></tr>
+   * <tr><td>`http://host/`</td><td>null</td></tr>
+   * <tr><td>`http://host/#`</td><td>`""`</td></tr>
+   * <tr><td>`http://host/#abc`</td><td>`"abc"`</td></tr>
+   * <tr><td>`http://host/#abc|def`</td><td>`"abc|def"`</td></tr>
+   * </table>
+   */
+  fun fragment(): String? = fragment
+
+  /**
+   * Returns a string with containing this URL with its username, password, query, and fragment
+   * stripped, and its path replaced with `/...`. For example, redacting
+   * `http://username:password@example.com/path` returns `http://example.com/...`.
+   */
+  fun redact(): String {
+    return newBuilder("/...")!!
+        .username("")
+        .password("")
+        .build()
+        .toString()
+  }
+
+  /**
+   * Returns the URL that would be retrieved by following `link` from this URL, or null if the
+   * resulting URL is not well-formed.
+   */
+  fun resolve(link: String): HttpUrl? = newBuilder(link)?.build()
+
+  fun newBuilder(): Builder {
+    val result = Builder()
+    result.scheme = scheme
+    result.encodedUsername = encodedUsername()
+    result.encodedPassword = encodedPassword()
+    result.host = host
+    // If we're set to a default port, unset it in case of a scheme change.
+    result.port = if (port != defaultPort(scheme)) port else -1
+    result.encodedPathSegments.clear()
+    result.encodedPathSegments.addAll(encodedPathSegments())
+    result.encodedQuery(encodedQuery())
+    result.encodedFragment = encodedFragment()
+    return result
+  }
+
+  /**
+   * Returns a builder for the URL that would be retrieved by following `link` from this URL,
+   * or null if the resulting URL is not well-formed.
+   */
+  fun newBuilder(link: String): Builder? {
+    try {
+      return Builder().parse(this, link)
+    } catch (ignored: IllegalArgumentException) {
+      return null
+    }
+  }
+
+  override fun equals(other: Any?): Boolean {
+    return other is HttpUrl && other.url == url
+  }
+
+  override fun hashCode(): Int = url.hashCode()
+
+  override fun toString(): String = url
+
+  /**
+   * Returns the domain name of this URL's [host] that is one level beneath the public suffix by
+   * consulting the [public suffix list](https://publicsuffix.org). Returns null if this URL's
+   * [host] is an IP address or is considered a public suffix by the public suffix list.
+   *
+   * In general this method **should not** be used to test whether a domain is valid or routable.
+   * Instead, DNS is the recommended source for that information.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`topPrivateDomain()`</th></tr>
+   * <tr><td>`http://google.com`</td><td>`"google.com"`</td></tr>
+   * <tr><td>`http://adwords.google.co.uk`</td><td>`"google.co.uk"`</td></tr>
+   * <tr><td>`http://square`</td><td>null</td></tr>
+   * <tr><td>`http://co.uk`</td><td>null</td></tr>
+   * <tr><td>`http://localhost`</td><td>null</td></tr>
+   * <tr><td>`http://127.0.0.1`</td><td>null</td></tr>
+   * </table>
+   */
+  fun topPrivateDomain(): String? {
+    if (verifyAsIpAddress(host)) {
+      return null
+    } else {
+      return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host)
+    }
+  }
+
+  class Builder {
+    internal var scheme: String? = null
+    internal var encodedUsername = ""
+    internal var encodedPassword = ""
+    internal var host: String? = null
+    internal var port = -1
+    internal val encodedPathSegments = mutableListOf<String>()
+    internal var encodedQueryNamesAndValues: MutableList<String?>? = null
+    internal var encodedFragment: String? = null
+
+    init {
+      encodedPathSegments.add("") // The default path is '/' which needs a trailing space.
+    }
+
+    fun scheme(scheme: String): Builder {
+      when {
+        scheme.equals("http", ignoreCase = true) -> this.scheme = "http"
+        scheme.equals("https", ignoreCase = true) -> this.scheme = "https"
+        else -> throw IllegalArgumentException("unexpected scheme: $scheme")
+      }
+      return this
+    }
+
+    fun username(username: String): Builder {
+      this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, alreadyEncoded = false,
+              strict = false, plusIsSpace = false, asciiOnly = true)
+      return this
+    }
+
+    fun encodedUsername(encodedUsername: String): Builder {
+      this.encodedUsername = canonicalize(
+          encodedUsername, USERNAME_ENCODE_SET, alreadyEncoded = true, strict = false,
+              plusIsSpace = false, asciiOnly = true)
+      return this
+    }
+
+    fun password(password: String): Builder {
+      this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, alreadyEncoded = false,
+              strict = false, plusIsSpace = false, asciiOnly = true)
+      return this
+    }
+
+    fun encodedPassword(encodedPassword: String): Builder {
+      this.encodedPassword = canonicalize(
+          encodedPassword, PASSWORD_ENCODE_SET, alreadyEncoded = true, strict = false,
+              plusIsSpace = false, asciiOnly = true)
+      return this
+    }
+
+    /**
+     * @param host either a regular hostname, International Domain Name, IPv4 address, or IPv6
+     * address.
+     */
+    fun host(host: String): Builder {
+      val encoded = canonicalizeHost(host, 0, host.length) ?: throw IllegalArgumentException(
+          "unexpected host: $host")
+      this.host = encoded
+      return this
+    }
+
+    fun port(port: Int): Builder {
+      if (port <= 0 || port > 65535) throw IllegalArgumentException("unexpected port: $port")
+      this.port = port
+      return this
+    }
+
+    internal fun effectivePort(): Int {
+      return if (port != -1) port else defaultPort(scheme!!)
+    }
+
+    fun addPathSegment(pathSegment: String): Builder {
+      push(pathSegment, 0, pathSegment.length, addTrailingSlash = false, alreadyEncoded = false)
+      return this
+    }
+
+    /**
+     * Adds a set of path segments separated by a slash (either `\` or `/`). If `pathSegments`
+     * starts with a slash, the resulting URL will have empty path segment.
+     */
+    fun addPathSegments(pathSegments: String): Builder {
+      return addPathSegments(pathSegments, false)
+    }
+
+    fun addEncodedPathSegment(encodedPathSegment: String): Builder {
+      push(encodedPathSegment, 0, encodedPathSegment.length, addTrailingSlash = false,
+              alreadyEncoded = true)
+      return this
+    }
+
+    /**
+     * Adds a set of encoded path segments separated by a slash (either `\` or `/`). If
+     * `encodedPathSegments` starts with a slash, the resulting URL will have empty path segment.
+     */
+    fun addEncodedPathSegments(encodedPathSegments: String): Builder {
+      return addPathSegments(encodedPathSegments, true)
+    }
+
+    private fun addPathSegments(pathSegments: String, alreadyEncoded: Boolean): Builder {
+      var offset = 0
+      do {
+        val segmentEnd = delimiterOffset(pathSegments, offset, pathSegments.length, "/\\")
+        val addTrailingSlash = segmentEnd < pathSegments.length
+        push(pathSegments, offset, segmentEnd, addTrailingSlash, alreadyEncoded)
+        offset = segmentEnd + 1
+      } while (offset <= pathSegments.length)
+      return this
+    }
+
+    fun setPathSegment(index: Int, pathSegment: String): Builder {
+      val canonicalPathSegment = canonicalize(pathSegment, 0, pathSegment.length,
+          PATH_SEGMENT_ENCODE_SET, false, false, false, true, null)
+      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
+        throw IllegalArgumentException("unexpected path segment: $pathSegment")
+      }
+      encodedPathSegments[index] = canonicalPathSegment
+      return this
+    }
+
+    fun setEncodedPathSegment(index: Int, encodedPathSegment: String): Builder {
+      val canonicalPathSegment = canonicalize(encodedPathSegment, 0, encodedPathSegment.length,
+          PATH_SEGMENT_ENCODE_SET, true, false, false, true, null)
+      encodedPathSegments[index] = canonicalPathSegment
+      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
+        throw IllegalArgumentException("unexpected path segment: $encodedPathSegment")
+      }
+      return this
+    }
+
+    fun removePathSegment(index: Int): Builder {
+      encodedPathSegments.removeAt(index)
+      if (encodedPathSegments.isEmpty()) {
+        encodedPathSegments.add("") // Always leave at least one '/'.
+      }
+      return this
+    }
+
+    fun encodedPath(encodedPath: String): Builder {
+      if (!encodedPath.startsWith("/")) {
+        throw IllegalArgumentException("unexpected encodedPath: $encodedPath")
+      }
+      resolvePath(encodedPath, 0, encodedPath.length)
+      return this
+    }
+
+    fun query(query: String?): Builder {
+      this.encodedQueryNamesAndValues = if (query != null) {
+        queryStringToNamesAndValues(canonicalize(query, QUERY_ENCODE_SET, alreadyEncoded = false,
+                strict = false, plusIsSpace = true, asciiOnly = true))
+      } else {
+        null
+      }
+      return this
+    }
+
+    fun encodedQuery(encodedQuery: String?): Builder {
+      this.encodedQueryNamesAndValues = if (encodedQuery != null) {
+        queryStringToNamesAndValues(
+            canonicalize(encodedQuery, QUERY_ENCODE_SET, alreadyEncoded = true, strict = false,
+                    plusIsSpace = true, asciiOnly = true))
+      } else {
+        null
+      }
+      return this
+    }
+
+    /** Encodes the query parameter using UTF-8 and adds it to this URL's query string.  */
+    fun addQueryParameter(name: String, value: String?): Builder {
+      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = ArrayList()
+      encodedQueryNamesAndValues!!.add(
+          canonicalize(name, QUERY_COMPONENT_ENCODE_SET, alreadyEncoded = false, strict = false,
+                  plusIsSpace = true, asciiOnly = true))
+      encodedQueryNamesAndValues!!.add(if (value != null) {
+        canonicalize(value, QUERY_COMPONENT_ENCODE_SET, alreadyEncoded = false, strict = false,
+                plusIsSpace = true, asciiOnly = true)
+      } else {
+        null
+      })
+      return this
+    }
+
+    /** Adds the pre-encoded query parameter to this URL's query string.  */
+    fun addEncodedQueryParameter(encodedName: String, encodedValue: String?): Builder {
+      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = ArrayList()
+      encodedQueryNamesAndValues!!.add(
+          canonicalize(encodedName, QUERY_COMPONENT_REENCODE_SET, alreadyEncoded = true,
+                  strict = false, plusIsSpace = true, asciiOnly = true))
+      encodedQueryNamesAndValues!!.add(if (encodedValue != null) {
+        canonicalize(encodedValue, QUERY_COMPONENT_REENCODE_SET, alreadyEncoded = true,
+                strict = false, plusIsSpace = true, asciiOnly = true)
+      } else {
+        null
+      })
+      return this
+    }
+
+    fun setQueryParameter(name: String, value: String?): Builder {
+      removeAllQueryParameters(name)
+      addQueryParameter(name, value)
+      return this
+    }
+
+    fun setEncodedQueryParameter(encodedName: String, encodedValue: String?): Builder {
+      removeAllEncodedQueryParameters(encodedName)
+      addEncodedQueryParameter(encodedName, encodedValue)
+      return this
+    }
+
+    fun removeAllQueryParameters(name: String): Builder {
+      if (encodedQueryNamesAndValues == null) return this
+      val nameToRemove = canonicalize(name, QUERY_COMPONENT_ENCODE_SET, alreadyEncoded = false,
+              strict = false, plusIsSpace = true, asciiOnly = true)
+      removeAllCanonicalQueryParameters(nameToRemove)
+      return this
+    }
+
+    fun removeAllEncodedQueryParameters(encodedName: String): Builder {
+      if (encodedQueryNamesAndValues == null) return this
+      removeAllCanonicalQueryParameters(
+          canonicalize(encodedName, QUERY_COMPONENT_REENCODE_SET, alreadyEncoded = true,
+                  strict = false, plusIsSpace = true, asciiOnly = true))
+      return this
+    }
+
+    private fun removeAllCanonicalQueryParameters(canonicalName: String) {
+      var i = encodedQueryNamesAndValues!!.size - 2
+      while (i >= 0) {
+        if (canonicalName == encodedQueryNamesAndValues!![i]) {
+          encodedQueryNamesAndValues!!.removeAt(i + 1)
+          encodedQueryNamesAndValues!!.removeAt(i)
+          if (encodedQueryNamesAndValues!!.isEmpty()) {
+            encodedQueryNamesAndValues = null
+            return
+          }
+        }
+        i -= 2
+      }
+    }
+
+    fun fragment(fragment: String?): Builder {
+      this.encodedFragment = if (fragment != null) {
+        canonicalize(fragment, FRAGMENT_ENCODE_SET, alreadyEncoded = false, strict = false,
+                plusIsSpace = false, asciiOnly = false)
+      } else {
+        null
+      }
+      return this
+    }
+
+    fun encodedFragment(encodedFragment: String?): Builder {
+      this.encodedFragment = if (encodedFragment != null) {
+        canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, alreadyEncoded = true, strict = false,
+                plusIsSpace = false, asciiOnly = false)
+      } else {
+        null
+      }
+      return this
+    }
+
+    /**
+     * Re-encodes the components of this URL so that it satisfies (obsolete) RFC 2396, which is
+     * particularly strict for certain components.
+     */
+    internal fun reencodeForUri(): Builder {
+      for (i in 0 until encodedPathSegments.size) {
+        val pathSegment = encodedPathSegments[i]
+        encodedPathSegments[i] =
+            canonicalize(pathSegment, PATH_SEGMENT_ENCODE_SET_URI, alreadyEncoded = true,
+                    strict = true, plusIsSpace = false, asciiOnly = true)
+      }
+      if (encodedQueryNamesAndValues != null) {
+        for (i in 0 until encodedQueryNamesAndValues!!.size) {
+          val component = encodedQueryNamesAndValues!![i]
+          if (component != null) {
+            encodedQueryNamesAndValues!![i] =
+                canonicalize(component, QUERY_COMPONENT_ENCODE_SET_URI, alreadyEncoded = true,
+                        strict = true, plusIsSpace = true, asciiOnly = true)
+          }
+        }
+      }
+      if (encodedFragment != null) {
+        encodedFragment = canonicalize(
+            encodedFragment!!, FRAGMENT_ENCODE_SET_URI, alreadyEncoded = true, strict = true,
+                plusIsSpace = false, asciiOnly = false)
+      }
+      return this
+    }
+
+    fun build(): HttpUrl = HttpUrl(this)
+
+    override fun toString(): String {
+      val result = StringBuilder()
+      if (scheme != null) {
+        result.append(scheme)
+        result.append("://")
+      } else {
+        result.append("//")
+      }
+
+      if (encodedUsername.isNotEmpty() || encodedPassword.isNotEmpty()) {
+        result.append(encodedUsername)
+        if (encodedPassword.isNotEmpty()) {
+          result.append(':')
+          result.append(encodedPassword)
+        }
+        result.append('@')
+      }
+
+      if (host != null) {
+        if (host!!.indexOf(':') != -1) {
+          // Host is an IPv6 address.
+          result.append('[')
+          result.append(host)
+          result.append(']')
+        } else {
+          result.append(host)
+        }
+      }
+
+      if (port != -1 || scheme != null) {
+        val effectivePort = effectivePort()
+        if (scheme == null || effectivePort != defaultPort(scheme!!)) {
+          result.append(':')
+          result.append(effectivePort)
+        }
+      }
+
+      pathSegmentsToString(result, encodedPathSegments)
+
+      if (encodedQueryNamesAndValues != null) {
+        result.append('?')
+        namesAndValuesToQueryString(result, encodedQueryNamesAndValues!!)
+      }
+
+      if (encodedFragment != null) {
+        result.append('#')
+        result.append(encodedFragment)
+      }
+
+      return result.toString()
+    }
+
+    internal fun parse(base: HttpUrl?, input: String): Builder {
+      var pos = skipLeadingAsciiWhitespace(input, 0, input.length)
+      val limit = skipTrailingAsciiWhitespace(input, pos, input.length)
+
+      // Scheme.
+      val schemeDelimiterOffset = schemeDelimiterOffset(input, pos, limit)
+      if (schemeDelimiterOffset != -1) {
+        if (input.regionMatches(pos, "https:", 0, 6, ignoreCase = true)) {
+          this.scheme = "https"
+          pos += "https:".length
+        } else if (input.regionMatches(pos, "http:", 0, 5, ignoreCase = true)) {
+          this.scheme = "http"
+          pos += "http:".length
+        } else {
+          throw IllegalArgumentException("Expected URL scheme 'http' or 'https' but was '" +
+              input.substring(0, schemeDelimiterOffset) + "'")
+        }
+      } else if (base != null) {
+        this.scheme = base.scheme
+      } else {
+        throw IllegalArgumentException(
+            "Expected URL scheme 'http' or 'https' but no colon was found")
+      }
+
+      // Authority.
+      var hasUsername = false
+      var hasPassword = false
+      val slashCount = slashCount(input, pos, limit)
+      if (slashCount >= 2 || base == null || base.scheme != this.scheme) {
+        // Read an authority if either:
+        //  * The input starts with 2 or more slashes. These follow the scheme if it exists.
+        //  * The input scheme exists and is different from the base URL's scheme.
+        //
+        // The structure of an authority is:
+        //   username:password@host:port
+        //
+        // Username, password and port are optional.
+        //   [username[:password]@]host[:port]
+        pos += slashCount
+        authority@ while (true) {
+          val componentDelimiterOffset = delimiterOffset(input, pos, limit, "@/\\?#")
+          val c = if (componentDelimiterOffset != limit) {
+            input[componentDelimiterOffset].toInt()
+          } else {
+            -1
+          }
+          when (c) {
+            '@'.toInt() -> {
+              // User info precedes.
+              if (!hasPassword) {
+                val passwordColonOffset = delimiterOffset(
+                    input, pos, componentDelimiterOffset, ':')
+                val canonicalUsername = canonicalize(input, pos, passwordColonOffset,
+                    USERNAME_ENCODE_SET, true, false, false, true, null)
+                this.encodedUsername = if (hasUsername) {
+                  this.encodedUsername + "%40" + canonicalUsername
+                } else {
+                  canonicalUsername
+                }
+                if (passwordColonOffset != componentDelimiterOffset) {
+                  hasPassword = true
+                  this.encodedPassword = canonicalize(input, passwordColonOffset + 1,
+                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true, null)
+                }
+                hasUsername = true
+              } else {
+                this.encodedPassword = this.encodedPassword + "%40" + canonicalize(input, pos,
+                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true, null)
+              }
+              pos = componentDelimiterOffset + 1
+            }
+
+            -1, '/'.toInt(), '\\'.toInt(), '?'.toInt(), '#'.toInt() -> {
+              // Host info precedes.
+              val portColonOffset = portColonOffset(input, pos, componentDelimiterOffset)
+              if (portColonOffset + 1 < componentDelimiterOffset) {
+                host = canonicalizeHost(input, pos, portColonOffset)
+                port = parsePort(input, portColonOffset + 1, componentDelimiterOffset)
+                require(port != -1) {
+                  "Invalid URL port: \"${input.substring(portColonOffset + 1,
+                      componentDelimiterOffset)}\""
+                }
+              } else {
+                host = canonicalizeHost(input, pos, portColonOffset)
+                port = defaultPort(scheme!!)
+              }
+              require(host != null) {
+                "$INVALID_HOST: \"${input.substring(pos, portColonOffset)}\""
+              }
+              pos = componentDelimiterOffset
+              break@authority
+            }
+          }
+        }
+      } else {
+        // This is a relative link. Copy over all authority components. Also maybe the path & query.
+        this.encodedUsername = base.encodedUsername()
+        this.encodedPassword = base.encodedPassword()
+        this.host = base.host
+        this.port = base.port
+        this.encodedPathSegments.clear()
+        this.encodedPathSegments.addAll(base.encodedPathSegments())
+        if (pos == limit || input[pos] == '#') {
+          encodedQuery(base.encodedQuery())
+        }
+      }
+
+      // Resolve the relative path.
+      val pathDelimiterOffset = delimiterOffset(input, pos, limit, "?#")
+      resolvePath(input, pos, pathDelimiterOffset)
+      pos = pathDelimiterOffset
+
+      // Query.
+      if (pos < limit && input[pos] == '?') {
+        val queryDelimiterOffset = delimiterOffset(input, pos, limit, '#')
+        this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
+            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true, null))
+        pos = queryDelimiterOffset
+      }
+
+      // Fragment.
+      if (pos < limit && input[pos] == '#') {
+        this.encodedFragment = canonicalize(
+            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false, null)
+      }
+
+      return this
+    }
+
+    private fun resolvePath(input: String, startPos: Int, limit: Int) {
+      var pos = startPos
+      // Read a delimiter.
+      if (pos == limit) {
+        // Empty path: keep the base path as-is.
+        return
+      }
+      val c = input[pos]
+      if (c == '/' || c == '\\') {
+        // Absolute path: reset to the default "/".
+        encodedPathSegments.clear()
+        encodedPathSegments.add("")
+        pos++
+      } else {
+        // Relative path: clear everything after the last '/'.
+        encodedPathSegments[encodedPathSegments.size - 1] = ""
+      }
+
+      // Read path segments.
+      var i = pos
+      while (i < limit) {
+        val pathSegmentDelimiterOffset = delimiterOffset(input, i, limit, "/\\")
+        val segmentHasTrailingSlash = pathSegmentDelimiterOffset < limit
+        push(input, i, pathSegmentDelimiterOffset, segmentHasTrailingSlash, true)
+        i = pathSegmentDelimiterOffset
+        if (segmentHasTrailingSlash) i++
+      }
+    }
+
+    /** Adds a path segment. If the input is ".." or equivalent, this pops a path segment.  */
+    private fun push(
+      input: String,
+      pos: Int,
+      limit: Int,
+      addTrailingSlash: Boolean,
+      alreadyEncoded: Boolean
+    ) {
+      val segment = canonicalize(
+          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false, false, true, null)
+      if (isDot(segment)) {
+        return // Skip '.' path segments.
+      }
+      if (isDotDot(segment)) {
+        pop()
+        return
+      }
+      if (encodedPathSegments[encodedPathSegments.size - 1].isEmpty()) {
+        encodedPathSegments[encodedPathSegments.size - 1] = segment
+      } else {
+        encodedPathSegments.add(segment)
+      }
+      if (addTrailingSlash) {
+        encodedPathSegments.add("")
+      }
+    }
+
+    private fun isDot(input: String): Boolean {
+      return input == "." || input.equals("%2e", ignoreCase = true)
+    }
+
+    private fun isDotDot(input: String): Boolean {
+      return (input == ".." ||
+          input.equals("%2e.", ignoreCase = true) ||
+          input.equals(".%2e", ignoreCase = true) ||
+          input.equals("%2e%2e", ignoreCase = true))
+    }
+
+    /**
+     * Removes a path segment. When this method returns the last segment is always "", which means
+     * the encoded path will have a trailing '/'.
+     *
+     * Popping "/a/b/c/" yields "/a/b/". In this case the list of path segments goes from ["a",
+     * "b", "c", ""] to ["a", "b", ""].
+     *
+     * Popping "/a/b/c" also yields "/a/b/". The list of path segments goes from ["a", "b", "c"]
+     * to ["a", "b", ""].
+     */
+    private fun pop() {
+      val removed = encodedPathSegments.removeAt(encodedPathSegments.size - 1)
+
+      // Make sure the path ends with a '/' by either adding an empty string or clearing a segment.
+      if (removed.isEmpty() && encodedPathSegments.isNotEmpty()) {
+        encodedPathSegments[encodedPathSegments.size - 1] = ""
+      } else {
+        encodedPathSegments.add("")
+      }
+    }
+
+    companion object {
+      internal const val INVALID_HOST = "Invalid URL host"
+
+      /**
+       * Returns the index of the ':' in `input` that is after scheme characters. Returns -1 if
+       * `input` does not have a scheme that starts at `pos`.
+       */
+      @JvmStatic
+      private fun schemeDelimiterOffset(input: String, pos: Int, limit: Int): Int {
+        if (limit - pos < 2) return -1
+
+        val c0 = input[pos]
+        if ((c0 < 'a' || c0 > 'z') && (c0 < 'A' || c0 > 'Z')) return -1 // Not a scheme start char.
+
+        for (i in pos + 1 until limit) {
+          val c = input[i]
+
+          if (c in 'a'..'z' ||
+            c in 'A'..'Z' ||
+            c in '0'..'9' ||
+            c == '+' ||
+            c == '-' ||
+            c == '.') {
+            continue // Scheme character. Keep going.
+          } else if (c == ':') {
+            return i // Scheme prefix!
+          } else {
+            return -1 // Non-scheme character before the first ':'.
+          }
+        }
+
+        return -1 // No ':'; doesn't start with a scheme.
+      }
+
+      /** Returns the number of '/' and '\' slashes in `input`, starting at `pos`.  */
+      @JvmStatic
+      private fun slashCount(input: String, pos: Int, limit: Int): Int {
+        var slashCount = 0
+        for (i in pos until limit) {
+          val c = input[i]
+          if (c == '\\' || c == '/') {
+            slashCount++
+          } else {
+            break
+          }
+        }
+        return slashCount
+      }
+
+      /** Finds the first ':' in `input`, skipping characters between square braces "[...]".  */
+      @JvmStatic
+      private fun portColonOffset(input: String, pos: Int, limit: Int): Int {
+        var i = pos
+        while (i < limit) {
+          when (input[i]) {
+            '[' -> {
+              while (++i < limit) {
+                if (input[i] == ']') break
+              }
+            }
+            ':' -> return i
+          }
+          i++
+        }
+        return limit // No colon.
+      }
+
+      @JvmStatic
+      private fun canonicalizeHost(input: String, pos: Int, limit: Int): String? {
+        // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
+        // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
+        val percentDecoded = percentDecode(input, pos, limit, false)
+        return Util.canonicalizeHost(percentDecoded)
+      }
+
+      @JvmStatic
+      private fun parsePort(input: String, pos: Int, limit: Int): Int {
+        try {
+          // Canonicalize the port string to skip '\n' etc.
+          val portString = canonicalize(input, pos, limit, "", false, false, false, true, null)
+          val i = Integer.parseInt(portString)
+          return if (i in 1..65535) i else -1
+        } catch (e: NumberFormatException) {
+          return -1 // Invalid port.
+        }
+      }
+    }
+  }
+
+  private fun percentDecode(list: List<String?>, plusIsSpace: Boolean): List<String?> {
+    val size = list.size
+    val result = ArrayList<String?>(size)
+    for (i in 0 until size) {
+      val s = list[i]
+      result.add(if (s != null) percentDecode(s, plusIsSpace) else null)
+    }
+    return Collections.unmodifiableList(result)
+  }
+
+  companion object {
+    @JvmStatic
+    private val HEX_DIGITS =
+        charArrayOf('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F')
+    internal const val USERNAME_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#"
+    internal const val PASSWORD_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#"
+    internal const val PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#"
+    internal const val PATH_SEGMENT_ENCODE_SET_URI = "[]"
+    internal const val QUERY_ENCODE_SET = " \"'<>#"
+    internal const val QUERY_COMPONENT_REENCODE_SET = " \"'<>#&="
+    internal const val QUERY_COMPONENT_ENCODE_SET = " !\"#$&'(),/:;<=>?@[]\\^`{|}~"
+    internal const val QUERY_COMPONENT_ENCODE_SET_URI = "\\^`{|}"
+    internal const val FORM_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#&!$(),~"
+    internal const val FRAGMENT_ENCODE_SET = ""
+    internal const val FRAGMENT_ENCODE_SET_URI = " \"#<>\\^`{|}"
+
+    /** Returns 80 if `scheme.equals("http")`, 443 if `scheme.equals("https")` and -1 otherwise. */
+    @JvmStatic
+    fun defaultPort(scheme: String): Int {
+      return when (scheme) {
+        "http" -> 80
+        "https" -> 443
+        else -> -1
+      }
+    }
+
+    @JvmStatic
+    internal fun pathSegmentsToString(out: StringBuilder, pathSegments: List<String>) {
+      for (i in 0 until pathSegments.size) {
+        out.append('/')
+        out.append(pathSegments[i])
+      }
+    }
+
+    @JvmStatic
+    internal fun namesAndValuesToQueryString(out: StringBuilder, namesAndValues: List<String?>) {
+      for (i in 0 until namesAndValues.size step 2) {
+        val name = namesAndValues[i]
+        val value = namesAndValues[i + 1]
+        if (i > 0) out.append('&')
+        out.append(name)
+        if (value != null) {
+          out.append('=')
+          out.append(value)
+        }
+      }
+    }
+
+    /**
+     * Cuts `encodedQuery` up into alternating parameter names and values. This divides a query
+     * string like `subject=math&easy&problem=5-2=3` into the list `["subject", "math", "easy",
+     * null, "problem", "5-2=3"]`. Note that values may be null and may contain '=' characters.
+     */
+    @JvmStatic
+    internal fun queryStringToNamesAndValues(encodedQuery: String): MutableList<String?> {
+      val result = mutableListOf<String?>()
+      var pos = 0
+      while (pos <= encodedQuery.length) {
+        var ampersandOffset = encodedQuery.indexOf('&', pos)
+        if (ampersandOffset == -1) ampersandOffset = encodedQuery.length
+
+        val equalsOffset = encodedQuery.indexOf('=', pos)
+        if (equalsOffset == -1 || equalsOffset > ampersandOffset) {
+          result.add(encodedQuery.substring(pos, ampersandOffset))
+          result.add(null) // No value for this name.
+        } else {
+          result.add(encodedQuery.substring(pos, equalsOffset))
+          result.add(encodedQuery.substring(equalsOffset + 1, ampersandOffset))
+        }
+        pos = ampersandOffset + 1
+      }
+      return result
+    }
+
+    /**
+     * Returns a new `HttpUrl` representing `url` if it is a well-formed HTTP or HTTPS URL, or null
+     * if it isn't.
+     */
+    @JvmStatic
+    fun parse(url: String): HttpUrl? {
+      try {
+        return get(url)
+      } catch (ignored: IllegalArgumentException) {
+        return null
+      }
+    }
+
+    /**
+     * Returns a new `HttpUrl` representing `url`.
+     *
+     * @throws IllegalArgumentException If `url` is not a well-formed HTTP or HTTPS URL.
+     */
+    @JvmStatic
+    fun get(url: String): HttpUrl = Builder().parse(null, url).build()
+
+    /**
+     * Returns an [HttpUrl] for `url` if its protocol is `http` or `https`, or
+     * null if it has any other protocol.
+     */
+    @JvmStatic
+    fun get(url: URL): HttpUrl? = parse(url.toString())
+
+    @JvmStatic
+    fun get(uri: URI): HttpUrl? = parse(uri.toString())
+
+    @JvmStatic
+    internal fun percentDecode(encoded: String, plusIsSpace: Boolean): String =
+        percentDecode(encoded, 0, encoded.length, plusIsSpace)
+
+    @JvmStatic
+    internal fun percentDecode(
+      encoded: String,
+      pos: Int,
+      limit: Int,
+      plusIsSpace: Boolean
+    ): String {
+      for (i in pos until limit) {
+        val c = encoded[i]
+        if (c == '%' || c == '+' && plusIsSpace) {
+          // Slow path: the character at i requires decoding!
+          val out = Buffer()
+          out.writeUtf8(encoded, pos, i)
+          percentDecode(out, encoded, i, limit, plusIsSpace)
+          return out.readUtf8()
+        }
+      }
+
+      // Fast path: no characters in [pos..limit) required decoding.
+      return encoded.substring(pos, limit)
+    }
+
+    @JvmStatic
+    internal fun percentDecode(
+      out: Buffer,
+      encoded: String,
+      pos: Int,
+      limit: Int,
+      plusIsSpace: Boolean
+    ) {
+      var codePoint: Int
+      var i = pos
+      while (i < limit) {
+        codePoint = encoded.codePointAt(i)
+        if (codePoint == '%'.toInt() && i + 2 < limit) {
+          val d1 = decodeHexDigit(encoded[i + 1])
+          val d2 = decodeHexDigit(encoded[i + 2])
+          if (d1 != -1 && d2 != -1) {
+            out.writeByte((d1 shl 4) + d2)
+            i += 2
+            i += Character.charCount(codePoint)
+            continue
+          }
+        } else if (codePoint == '+'.toInt() && plusIsSpace) {
+          out.writeByte(' '.toInt())
+          i++
+          continue
+        }
+        out.writeUtf8CodePoint(codePoint)
+        i += Character.charCount(codePoint)
+      }
+    }
+
+    @JvmStatic
+    internal fun percentEncoded(encoded: String, pos: Int, limit: Int): Boolean {
+      return (pos + 2 < limit &&
+          encoded[pos] == '%' &&
+          decodeHexDigit(encoded[pos + 1]) != -1 &&
+          decodeHexDigit(encoded[pos + 2]) != -1)
+    }
+
+    /**
+     * Returns a substring of `input` on the range `[pos..limit)` with the following
+     * transformations:
+     *
+     *  * Tabs, newlines, form feeds and carriage returns are skipped.
+     *
+     *  * In queries, ' ' is encoded to '+' and '+' is encoded to "%2B".
+     *
+     *  * Characters in `encodeSet` are percent-encoded.
+     *
+     *  * Control characters and non-ASCII characters are percent-encoded.
+     *
+     *  * All other characters are copied without transformation.
+     *
+     * @param alreadyEncoded true to leave '%' as-is; false to convert it to '%25'.
+     * @param strict true to encode '%' if it is not the prefix of a valid percent encoding.
+     * @param plusIsSpace true to encode '+' as "%2B" if it is not already encoded.
+     * @param asciiOnly true to encode all non-ASCII codepoints.
+     * @param charset which charset to use, null equals UTF-8.
+     */
+    @JvmStatic
+    internal fun canonicalize(
+      input: String,
+      pos: Int,
+      limit: Int,
+      encodeSet: String,
+      alreadyEncoded: Boolean,
+      strict: Boolean,
+      plusIsSpace: Boolean,
+      asciiOnly: Boolean,
+      charset: Charset?
+    ): String {
+      var codePoint: Int
+      var i = pos
+      while (i < limit) {
+        codePoint = input.codePointAt(i)
+        if (codePoint < 0x20 ||
+            codePoint == 0x7f ||
+            codePoint >= 0x80 && asciiOnly ||
+            encodeSet.indexOf(codePoint.toChar()) != -1 ||
+            codePoint == '%'.toInt() && (!alreadyEncoded || strict && !percentEncoded(input, i,
+                limit)) ||
+            codePoint == '+'.toInt() && plusIsSpace) {
+          // Slow path: the character at i requires encoding!
+          val out = Buffer()
+          out.writeUtf8(input, pos, i)
+          canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, strict, plusIsSpace,
+              asciiOnly, charset)
+          return out.readUtf8()
+        }
+        i += Character.charCount(codePoint)
+      }
+
+      // Fast path: no characters in [pos..limit) required encoding.
+      return input.substring(pos, limit)
+    }
+
+    @JvmStatic
+    internal fun canonicalize(
+      out: Buffer,
+      input: String,
+      pos: Int,
+      limit: Int,
+      encodeSet: String,
+      alreadyEncoded: Boolean,
+      strict: Boolean,
+      plusIsSpace: Boolean,
+      asciiOnly: Boolean,
+      charset: Charset?
+    ) {
+      var encodedCharBuffer: Buffer? = null // Lazily allocated.
+      var codePoint: Int
+      var i = pos
+      while (i < limit) {
+        codePoint = input.codePointAt(i)
+        if (alreadyEncoded && (codePoint == '\t'.toInt() || codePoint == '\n'.toInt() || codePoint == '\u000c'.toInt() || codePoint == '\r'.toInt())) {
+          // Skip this character.
+        } else if (codePoint == '+'.toInt() && plusIsSpace) {
+          // Encode '+' as '%2B' since we permit ' ' to be encoded as either '+' or '%20'.
+          out.writeUtf8(if (alreadyEncoded) "+" else "%2B")
+        } else if (codePoint < 0x20 ||
+            codePoint == 0x7f ||
+            codePoint >= 0x80 && asciiOnly ||
+            encodeSet.indexOf(codePoint.toChar()) != -1 ||
+            codePoint == '%'.toInt() && (!alreadyEncoded || strict && !percentEncoded(input, i,
+                limit))) {
+          // Percent encode this character.
+          if (encodedCharBuffer == null) {
+            encodedCharBuffer = Buffer()
+          }
+
+          if (charset == null || charset == UTF_8) {
+            encodedCharBuffer.writeUtf8CodePoint(codePoint)
+          } else {
+            encodedCharBuffer.writeString(input, i, i + Character.charCount(codePoint), charset)
+          }
+
+          while (!encodedCharBuffer.exhausted()) {
+            val b = encodedCharBuffer.readByte().toInt() and 0xff
+            out.writeByte('%'.toInt())
+            out.writeByte(HEX_DIGITS[b shr 4 and 0xf].toInt())
+            out.writeByte(HEX_DIGITS[b and 0xf].toInt())
+          }
+        } else {
+          // This character doesn't need encoding. Just copy it over.
+          out.writeUtf8CodePoint(codePoint)
+        }
+        i += Character.charCount(codePoint)
+      }
+    }
+
+    @JvmStatic
+    internal fun canonicalize(
+      input: String,
+      encodeSet: String,
+      alreadyEncoded: Boolean,
+      strict: Boolean,
+      plusIsSpace: Boolean,
+      asciiOnly: Boolean,
+      charset: Charset?
+    ): String = canonicalize(input, 0, input.length, encodeSet, alreadyEncoded, strict, plusIsSpace,
+        asciiOnly, charset)
+
+    @JvmStatic
+    internal fun canonicalize(
+      input: String,
+      encodeSet: String,
+      alreadyEncoded: Boolean,
+      strict: Boolean,
+      plusIsSpace: Boolean,
+      asciiOnly: Boolean
+    ): String = canonicalize(
+        input, 0, input.length, encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly, null)
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Interceptor.java b/okhttp/src/main/java/okhttp3/Interceptor.kt
similarity index 51%
rename from okhttp/src/main/java/okhttp3/Interceptor.java
rename to okhttp/src/main/java/okhttp3/Interceptor.kt
index 1005592697..43739a90b2 100644
--- a/okhttp/src/main/java/okhttp3/Interceptor.java
+++ b/okhttp/src/main/java/okhttp3/Interceptor.kt
@@ -13,43 +13,54 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3;
+package okhttp3
 
-import java.io.IOException;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
+import java.io.IOException
+import java.util.concurrent.TimeUnit
 
 /**
  * Observes, modifies, and potentially short-circuits requests going out and the corresponding
  * responses coming back in. Typically interceptors add, remove, or transform headers on the request
  * or response.
  */
-public interface Interceptor {
-  Response intercept(Chain chain) throws IOException;
+interface Interceptor {
+  @Throws(IOException::class)
+  fun intercept(chain: Chain): Response
+
+  companion object {
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName("-deprecated_Interceptor")
+    inline operator fun invoke(
+      crossinline block: (chain: Chain) -> Response
+    ): Interceptor = object : Interceptor {
+      override fun intercept(chain: Chain) = block(chain)
+    }
+  }
 
   interface Chain {
-    Request request();
+    fun request(): Request
 
-    Response proceed(Request request) throws IOException;
+    @Throws(IOException::class)
+    fun proceed(request: Request): Response
 
     /**
      * Returns the connection the request will be executed on. This is only available in the chains
      * of network interceptors; for application interceptors this is always null.
      */
-    @Nullable Connection connection();
+    fun connection(): Connection?
 
-    Call call();
+    fun call(): Call
 
-    int connectTimeoutMillis();
+    fun connectTimeoutMillis(): Int
 
-    Chain withConnectTimeout(int timeout, TimeUnit unit);
+    fun withConnectTimeout(timeout: Int, unit: TimeUnit): Chain
 
-    int readTimeoutMillis();
+    fun readTimeoutMillis(): Int
 
-    Chain withReadTimeout(int timeout, TimeUnit unit);
+    fun withReadTimeout(timeout: Int, unit: TimeUnit): Chain
 
-    int writeTimeoutMillis();
+    fun writeTimeoutMillis(): Int
 
-    Chain withWriteTimeout(int timeout, TimeUnit unit);
+    fun withWriteTimeout(timeout: Int, unit: TimeUnit): Chain
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/MediaType.java b/okhttp/src/main/java/okhttp3/MediaType.java
deleted file mode 100644
index ddbd8fcb16..0000000000
--- a/okhttp/src/main/java/okhttp3/MediaType.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.nio.charset.Charset;
-import java.util.Locale;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import javax.annotation.Nullable;
-
-/**
- * An <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a> Media Type, appropriate to describe
- * the content type of an HTTP request or response body.
- */
-public final class MediaType {
-  private static final String TOKEN = "([a-zA-Z0-9-!#$%&'*+.^_`{|}~]+)";
-  private static final String QUOTED = "\"([^\"]*)\"";
-  private static final Pattern TYPE_SUBTYPE = Pattern.compile(TOKEN + "/" + TOKEN);
-  private static final Pattern PARAMETER = Pattern.compile(
-      ";\\s*(?:" + TOKEN + "=(?:" + TOKEN + "|" + QUOTED + "))?");
-
-  private final String mediaType;
-  private final String type;
-  private final String subtype;
-  private final @Nullable String charset;
-
-  private MediaType(String mediaType, String type, String subtype, @Nullable String charset) {
-    this.mediaType = mediaType;
-    this.type = type;
-    this.subtype = subtype;
-    this.charset = charset;
-  }
-
-  /**
-   * Returns a media type for {@code string}.
-   *
-   * @throws IllegalArgumentException if {@code string} is not a well-formed media type.
-   */
-  public static MediaType get(String string) {
-    Matcher typeSubtype = TYPE_SUBTYPE.matcher(string);
-    if (!typeSubtype.lookingAt()) {
-      throw new IllegalArgumentException("No subtype found for: \"" + string + '"');
-    }
-    String type = typeSubtype.group(1).toLowerCase(Locale.US);
-    String subtype = typeSubtype.group(2).toLowerCase(Locale.US);
-
-    String charset = null;
-    Matcher parameter = PARAMETER.matcher(string);
-    for (int s = typeSubtype.end(); s < string.length(); s = parameter.end()) {
-      parameter.region(s, string.length());
-      if (!parameter.lookingAt()) {
-        throw new IllegalArgumentException("Parameter is not formatted correctly: \""
-            + string.substring(s)
-            + "\" for: \""
-            + string
-            + '"');
-      }
-
-      String name = parameter.group(1);
-      if (name == null || !name.equalsIgnoreCase("charset")) continue;
-      String charsetParameter;
-      String token = parameter.group(2);
-      if (token != null) {
-        // If the token is 'single-quoted' it's invalid! But we're lenient and strip the quotes.
-        charsetParameter = (token.startsWith("'") && token.endsWith("'") && token.length() > 2)
-            ? token.substring(1, token.length() - 1)
-            : token;
-      } else {
-        // Value is "double-quoted". That's valid and our regex group already strips the quotes.
-        charsetParameter = parameter.group(3);
-      }
-      if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
-        throw new IllegalArgumentException("Multiple charsets defined: \""
-            + charset
-            + "\" and: \""
-            + charsetParameter
-            + "\" for: \""
-            + string
-            + '"');
-      }
-      charset = charsetParameter;
-    }
-
-    return new MediaType(string, type, subtype, charset);
-  }
-
-  /**
-   * Returns a media type for {@code string}, or null if {@code string} is not a well-formed media
-   * type.
-   */
-  public static @Nullable MediaType parse(String string) {
-    try {
-      return get(string);
-    } catch (IllegalArgumentException ignored) {
-      return null;
-    }
-  }
-
-  /**
-   * Returns the high-level media type, such as "text", "image", "audio", "video", or
-   * "application".
-   */
-  public String type() {
-    return type;
-  }
-
-  /**
-   * Returns a specific media subtype, such as "plain" or "png", "mpeg", "mp4" or "xml".
-   */
-  public String subtype() {
-    return subtype;
-  }
-
-  /**
-   * Returns the charset of this media type, or null if this media type doesn't specify a charset.
-   */
-  public @Nullable Charset charset() {
-    return charset(null);
-  }
-
-  /**
-   * Returns the charset of this media type, or {@code defaultValue} if either this media type
-   * doesn't specify a charset, of it its charset is unsupported by the current runtime.
-   */
-  public @Nullable Charset charset(@Nullable Charset defaultValue) {
-    try {
-      return charset != null ? Charset.forName(charset) : defaultValue;
-    } catch (IllegalArgumentException e) {
-      return defaultValue; // This charset is invalid or unsupported. Give up.
-    }
-  }
-
-  /**
-   * Returns the encoded media type, like "text/plain; charset=utf-8", appropriate for use in a
-   * Content-Type header.
-   */
-  @Override public String toString() {
-    return mediaType;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof MediaType && ((MediaType) other).mediaType.equals(mediaType);
-  }
-
-  @Override public int hashCode() {
-    return mediaType.hashCode();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/MediaType.kt b/okhttp/src/main/java/okhttp3/MediaType.kt
new file mode 100644
index 0000000000..d628a4aac6
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/MediaType.kt
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.nio.charset.Charset
+import java.util.Locale
+import java.util.regex.Pattern
+
+/**
+ * An [RFC 2045][rfc_2045] Media Type, appropriate to describe the content type of an HTTP request
+ * or response body.
+ *
+ * [rfc_2045]: http://tools.ietf.org/html/rfc2045
+ */
+class MediaType private constructor(
+  private val mediaType: String,
+  val type: String,
+  val subtype: String,
+  private val charset: String?
+) {
+  /**
+   * Returns the charset of this media type, or `defaultValue` if either this media type
+   * doesn't specify a charset, of it its charset is unsupported by the current runtime.
+   */
+  @JvmOverloads
+  fun charset(defaultValue: Charset? = null): Charset? {
+      return try {
+          if (charset != null) Charset.forName(charset) else defaultValue
+      } catch (e: IllegalArgumentException) {
+          defaultValue // This charset is invalid or unsupported. Give up.
+      }
+  }
+
+  /**
+   * Returns the high-level media type, such as "text", "image", "audio", "video", or
+   * "application".
+   */
+  fun type() = type
+
+  /**
+   * Returns a specific media subtype, such as "plain" or "png", "mpeg", "mp4" or "xml".
+   */
+  fun subtype() = subtype
+
+  /**
+   * Returns the encoded media type, like "text/plain; charset=utf-8", appropriate for use in a
+   * Content-Type header.
+   */
+  override fun toString(): String = mediaType
+
+  override fun equals(other: Any?): Boolean = other is MediaType && other.mediaType == mediaType
+
+  override fun hashCode(): Int = mediaType.hashCode()
+
+  companion object {
+    private const val TOKEN = "([a-zA-Z0-9-!#$%&'*+.^_`{|}~]+)"
+    private const val QUOTED = "\"([^\"]*)\""
+    private val TYPE_SUBTYPE = Pattern.compile("$TOKEN/$TOKEN")
+    private val PARAMETER = Pattern.compile(";\\s*(?:$TOKEN=(?:$TOKEN|$QUOTED))?")
+
+    /**
+     * Returns a media type for `string`.
+     *
+     * @throws IllegalArgumentException if `string` is not a well-formed media type.
+     */
+    @JvmStatic
+    fun get(string: String): MediaType {
+      val typeSubtype = TYPE_SUBTYPE.matcher(string)
+      require(typeSubtype.lookingAt()) { "No subtype found for: \"$string\"" }
+      val type = typeSubtype.group(1).toLowerCase(Locale.US)
+      val subtype = typeSubtype.group(2).toLowerCase(Locale.US)
+
+      var charset: String? = null
+      val parameter = PARAMETER.matcher(string)
+      var s = typeSubtype.end()
+      while (s < string.length) {
+        parameter.region(s, string.length)
+        require(parameter.lookingAt()) {
+          "Parameter is not formatted correctly: \"${string.substring(s)}\" for: \"$string\""
+        }
+
+        val name = parameter.group(1)
+        if (name == null || !name.equals("charset", ignoreCase = true)) {
+          s = parameter.end()
+          continue
+        }
+        val charsetParameter: String
+        val token = parameter.group(2)
+        charsetParameter = when {
+          token == null -> {
+            // Value is "double-quoted". That's valid and our regex group already strips the quotes.
+            parameter.group(3)
+          }
+          token.startsWith("'") && token.endsWith("'") && token.length > 2 -> {
+            // If the token is 'single-quoted' it's invalid! But we're lenient and strip the quotes.
+            token.substring(1, token.length - 1)
+          }
+          else -> token
+        }
+        require(charset == null || charsetParameter.equals(charset, ignoreCase = true)) {
+          "Multiple charsets defined: \"$charset\" and: \"$charsetParameter\" for: \"$string\""
+        }
+        charset = charsetParameter
+        s = parameter.end()
+      }
+
+      return MediaType(string, type, subtype, charset)
+    }
+
+    /** Returns a media type for `string`, or null if `string` is not a well-formed media type. */
+    @JvmStatic
+    fun parse(string: String): MediaType? {
+        return try {
+            get(string)
+        } catch (ignored: IllegalArgumentException) {
+            null
+        }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.java b/okhttp/src/main/java/okhttp3/MultipartBody.java
deleted file mode 100644
index e5e6eaa17f..0000000000
--- a/okhttp/src/main/java/okhttp3/MultipartBody.java
+++ /dev/null
@@ -1,341 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.UUID;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-
-/** An <a href="http://www.ietf.org/rfc/rfc2387.txt">RFC 2387</a>-compliant request body. */
-public final class MultipartBody extends RequestBody {
-  /**
-   * The "mixed" subtype of "multipart" is intended for use when the body parts are independent and
-   * need to be bundled in a particular order. Any "multipart" subtypes that an implementation does
-   * not recognize must be treated as being of subtype "mixed".
-   */
-  public static final MediaType MIXED = MediaType.get("multipart/mixed");
-
-  /**
-   * The "multipart/alternative" type is syntactically identical to "multipart/mixed", but the
-   * semantics are different. In particular, each of the body parts is an "alternative" version of
-   * the same information.
-   */
-  public static final MediaType ALTERNATIVE = MediaType.get("multipart/alternative");
-
-  /**
-   * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
-   * particular, in a digest, the default {@code Content-Type} value for a body part is changed from
-   * "text/plain" to "message/rfc822".
-   */
-  public static final MediaType DIGEST = MediaType.get("multipart/digest");
-
-  /**
-   * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
-   * particular, in a parallel entity, the order of body parts is not significant.
-   */
-  public static final MediaType PARALLEL = MediaType.get("multipart/parallel");
-
-  /**
-   * The media-type multipart/form-data follows the rules of all multipart MIME data streams as
-   * outlined in RFC 2046. In forms, there are a series of fields to be supplied by the user who
-   * fills out the form. Each field has a name. Within a given form, the names are unique.
-   */
-  public static final MediaType FORM = MediaType.get("multipart/form-data");
-
-  private static final byte[] COLONSPACE = {':', ' '};
-  private static final byte[] CRLF = {'\r', '\n'};
-  private static final byte[] DASHDASH = {'-', '-'};
-
-  private final ByteString boundary;
-  private final MediaType originalType;
-  private final MediaType contentType;
-  private final List<Part> parts;
-  private long contentLength = -1L;
-
-  MultipartBody(ByteString boundary, MediaType type, List<Part> parts) {
-    this.boundary = boundary;
-    this.originalType = type;
-    this.contentType = MediaType.get(type + "; boundary=" + boundary.utf8());
-    this.parts = Util.immutableList(parts);
-  }
-
-  public MediaType type() {
-    return originalType;
-  }
-
-  public String boundary() {
-    return boundary.utf8();
-  }
-
-  /** The number of parts in this multipart body. */
-  public int size() {
-    return parts.size();
-  }
-
-  public List<Part> parts() {
-    return parts;
-  }
-
-  public Part part(int index) {
-    return parts.get(index);
-  }
-
-  /** A combination of {@link #type()} and {@link #boundary()}. */
-  @Override public MediaType contentType() {
-    return contentType;
-  }
-
-  @Override public long contentLength() throws IOException {
-    long result = contentLength;
-    if (result != -1L) return result;
-    return contentLength = writeOrCountBytes(null, true);
-  }
-
-  @Override public void writeTo(BufferedSink sink) throws IOException {
-    writeOrCountBytes(sink, false);
-  }
-
-  /**
-   * Either writes this request to {@code sink} or measures its content length. We have one method
-   * do double-duty to make sure the counting and content are consistent, particularly when it comes
-   * to awkward operations like measuring the encoded length of header strings, or the
-   * length-in-digits of an encoded integer.
-   */
-  private long writeOrCountBytes(
-      @Nullable BufferedSink sink, boolean countBytes) throws IOException {
-    long byteCount = 0L;
-
-    Buffer byteCountBuffer = null;
-    if (countBytes) {
-      sink = byteCountBuffer = new Buffer();
-    }
-
-    for (int p = 0, partCount = parts.size(); p < partCount; p++) {
-      Part part = parts.get(p);
-      Headers headers = part.headers;
-      RequestBody body = part.body;
-
-      sink.write(DASHDASH);
-      sink.write(boundary);
-      sink.write(CRLF);
-
-      if (headers != null) {
-        for (int h = 0, headerCount = headers.size(); h < headerCount; h++) {
-          sink.writeUtf8(headers.name(h))
-              .write(COLONSPACE)
-              .writeUtf8(headers.value(h))
-              .write(CRLF);
-        }
-      }
-
-      MediaType contentType = body.contentType();
-      if (contentType != null) {
-        sink.writeUtf8("Content-Type: ")
-            .writeUtf8(contentType.toString())
-            .write(CRLF);
-      }
-
-      long contentLength = body.contentLength();
-      if (contentLength != -1) {
-        sink.writeUtf8("Content-Length: ")
-            .writeDecimalLong(contentLength)
-            .write(CRLF);
-      } else if (countBytes) {
-        // We can't measure the body's size without the sizes of its components.
-        byteCountBuffer.clear();
-        return -1L;
-      }
-
-      sink.write(CRLF);
-
-      if (countBytes) {
-        byteCount += contentLength;
-      } else {
-        body.writeTo(sink);
-      }
-
-      sink.write(CRLF);
-    }
-
-    sink.write(DASHDASH);
-    sink.write(boundary);
-    sink.write(DASHDASH);
-    sink.write(CRLF);
-
-    if (countBytes) {
-      byteCount += byteCountBuffer.size();
-      byteCountBuffer.clear();
-    }
-
-    return byteCount;
-  }
-
-  /**
-   * Appends a quoted-string to a StringBuilder.
-   *
-   * <p>RFC 2388 is rather vague about how one should escape special characters in form-data
-   * parameters, and as it turns out Firefox and Chrome actually do rather different things, and
-   * both say in their comments that they're not really sure what the right approach is. We go with
-   * Chrome's behavior (which also experimentally seems to match what IE does), but if you actually
-   * want to have a good chance of things working, please avoid double-quotes, newlines, percent
-   * signs, and the like in your field names.
-   */
-  static void appendQuotedString(StringBuilder target, String key) {
-    target.append('"');
-    for (int i = 0, len = key.length(); i < len; i++) {
-      char ch = key.charAt(i);
-      switch (ch) {
-        case '\n':
-          target.append("%0A");
-          break;
-        case '\r':
-          target.append("%0D");
-          break;
-        case '"':
-          target.append("%22");
-          break;
-        default:
-          target.append(ch);
-          break;
-      }
-    }
-    target.append('"');
-  }
-
-  public static final class Part {
-    public static Part create(RequestBody body) {
-      return create(null, body);
-    }
-
-    public static Part create(@Nullable Headers headers, RequestBody body) {
-      if (body == null) {
-        throw new NullPointerException("body == null");
-      }
-      if (headers != null && headers.get("Content-Type") != null) {
-        throw new IllegalArgumentException("Unexpected header: Content-Type");
-      }
-      if (headers != null && headers.get("Content-Length") != null) {
-        throw new IllegalArgumentException("Unexpected header: Content-Length");
-      }
-      return new Part(headers, body);
-    }
-
-    public static Part createFormData(String name, String value) {
-      return createFormData(name, null, RequestBody.create(null, value));
-    }
-
-    public static Part createFormData(String name, @Nullable String filename, RequestBody body) {
-      if (name == null) {
-        throw new NullPointerException("name == null");
-      }
-      StringBuilder disposition = new StringBuilder("form-data; name=");
-      appendQuotedString(disposition, name);
-
-      if (filename != null) {
-        disposition.append("; filename=");
-        appendQuotedString(disposition, filename);
-      }
-
-      return create(Headers.of("Content-Disposition", disposition.toString()), body);
-    }
-
-    final @Nullable Headers headers;
-    final RequestBody body;
-
-    private Part(@Nullable Headers headers, RequestBody body) {
-      this.headers = headers;
-      this.body = body;
-    }
-
-    public @Nullable Headers headers() {
-      return headers;
-    }
-
-    public RequestBody body() {
-      return body;
-    }
-  }
-
-  public static final class Builder {
-    private final ByteString boundary;
-    private MediaType type = MIXED;
-    private final List<Part> parts = new ArrayList<>();
-
-    public Builder() {
-      this(UUID.randomUUID().toString());
-    }
-
-    public Builder(String boundary) {
-      this.boundary = ByteString.encodeUtf8(boundary);
-    }
-
-    /**
-     * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the default), {@link
-     * #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and {@link #FORM}.
-     */
-    public Builder setType(MediaType type) {
-      if (type == null) {
-        throw new NullPointerException("type == null");
-      }
-      if (!type.type().equals("multipart")) {
-        throw new IllegalArgumentException("multipart != " + type);
-      }
-      this.type = type;
-      return this;
-    }
-
-    /** Add a part to the body. */
-    public Builder addPart(RequestBody body) {
-      return addPart(Part.create(body));
-    }
-
-    /** Add a part to the body. */
-    public Builder addPart(@Nullable Headers headers, RequestBody body) {
-      return addPart(Part.create(headers, body));
-    }
-
-    /** Add a form data part to the body. */
-    public Builder addFormDataPart(String name, String value) {
-      return addPart(Part.createFormData(name, value));
-    }
-
-    /** Add a form data part to the body. */
-    public Builder addFormDataPart(String name, @Nullable String filename, RequestBody body) {
-      return addPart(Part.createFormData(name, filename, body));
-    }
-
-    /** Add a part to the body. */
-    public Builder addPart(Part part) {
-      if (part == null) throw new NullPointerException("part == null");
-      parts.add(part);
-      return this;
-    }
-
-    /** Assemble the specified parts into a request body. */
-    public MultipartBody build() {
-      if (parts.isEmpty()) {
-        throw new IllegalStateException("Multipart body must have at least one part.");
-      }
-      return new MultipartBody(boundary, type, parts);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.kt b/okhttp/src/main/java/okhttp3/MultipartBody.kt
new file mode 100644
index 0000000000..9ff3cfbe9e
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.kt
@@ -0,0 +1,303 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.Util
+import okio.Buffer
+import okio.BufferedSink
+import okio.ByteString
+import okio.ByteString.Companion.encodeUtf8
+import java.io.IOException
+import java.util.UUID
+
+/**
+ * An [RFC 2387][rfc_2387]-compliant request body.
+ *
+ * [rfc_2387]: http://www.ietf.org/rfc/rfc2387.txt
+ */
+class MultipartBody internal constructor(
+  private val boundary: ByteString,
+  private val originalType: MediaType,
+  parts: List<Part>
+) : RequestBody() {
+  private val contentType: MediaType = MediaType.get("$originalType; boundary=${boundary.utf8()}")
+  private val parts: List<Part> = Util.immutableList(parts)
+  private var contentLength = -1L
+
+  fun type(): MediaType = originalType
+
+  fun boundary(): String = boundary.utf8()
+
+  /** The number of parts in this multipart body.  */
+  fun size(): Int = parts.size
+
+  fun parts(): List<Part> = parts
+
+  fun part(index: Int): Part = parts[index]
+
+  /** A combination of [.type] and [.boundary].  */
+  override fun contentType(): MediaType = contentType
+
+  @Throws(IOException::class)
+  override fun contentLength(): Long {
+    var result = contentLength
+    if (result == -1L) {
+      result = writeOrCountBytes(null, true)
+      contentLength = result
+    }
+    return result
+  }
+
+  @Throws(IOException::class)
+  override fun writeTo(sink: BufferedSink) {
+    writeOrCountBytes(sink, false)
+  }
+
+  /**
+   * Either writes this request to [sink] or measures its content length. We have one method do
+   * double-duty to make sure the counting and content are consistent, particularly when it comes
+   * to awkward operations like measuring the encoded length of header strings, or the
+   * length-in-digits of an encoded integer.
+   */
+  @Throws(IOException::class)
+  private fun writeOrCountBytes(
+    sink: BufferedSink?,
+    countBytes: Boolean
+  ): Long {
+    var sink = sink
+    var byteCount = 0L
+
+    var byteCountBuffer: Buffer? = null
+    if (countBytes) {
+      byteCountBuffer = Buffer()
+      sink = byteCountBuffer
+    }
+
+    for (p in 0 until parts.size) {
+      val part = parts[p]
+      val headers = part.headers
+      val body = part.body
+
+      sink!!.write(DASHDASH)
+      sink.write(boundary)
+      sink.write(CRLF)
+
+      if (headers != null) {
+        for (h in 0 until headers.size()) {
+          sink.writeUtf8(headers.name(h))
+              .write(COLONSPACE)
+              .writeUtf8(headers.value(h))
+              .write(CRLF)
+        }
+      }
+
+      val contentType = body.contentType()
+      if (contentType != null) {
+        sink.writeUtf8("Content-Type: ")
+            .writeUtf8(contentType.toString())
+            .write(CRLF)
+      }
+
+      val contentLength = body.contentLength()
+      if (contentLength != -1L) {
+        sink.writeUtf8("Content-Length: ")
+            .writeDecimalLong(contentLength)
+            .write(CRLF)
+      } else if (countBytes) {
+        // We can't measure the body's size without the sizes of its components.
+        byteCountBuffer!!.clear()
+        return -1L
+      }
+
+      sink.write(CRLF)
+
+      if (countBytes) {
+        byteCount += contentLength
+      } else {
+        body.writeTo(sink)
+      }
+
+      sink.write(CRLF)
+    }
+
+    sink!!.write(DASHDASH)
+    sink.write(boundary)
+    sink.write(DASHDASH)
+    sink.write(CRLF)
+
+    if (countBytes) {
+      byteCount += byteCountBuffer!!.size
+      byteCountBuffer.clear()
+    }
+
+    return byteCount
+  }
+
+  class Part private constructor(internal val headers: Headers?, internal val body: RequestBody) {
+
+    fun headers(): Headers? = headers
+
+    fun body(): RequestBody = body
+
+    companion object {
+      @JvmStatic
+      fun create(body: RequestBody): Part = create(null, body)
+
+      @JvmStatic
+      fun create(headers: Headers?, body: RequestBody): Part {
+        require(headers?.get("Content-Type") == null) { "Unexpected header: Content-Type" }
+        require(headers?.get("Content-Length") == null) { "Unexpected header: Content-Length" }
+        return Part(headers, body)
+      }
+
+      @JvmStatic
+      fun createFormData(name: String, value: String): Part =
+          createFormData(name, null, RequestBody.create(null, value))
+
+      @JvmStatic
+      fun createFormData(name: String, filename: String?, body: RequestBody): Part {
+        val disposition = StringBuilder("form-data; name=")
+        disposition.appendQuotedString(name)
+
+        if (filename != null) {
+          disposition.append("; filename=")
+          disposition.appendQuotedString(filename)
+        }
+
+        val headers = Headers.Builder()
+            .addUnsafeNonAscii("Content-Disposition", disposition.toString())
+            .build()
+
+        return create(headers, body)
+      }
+    }
+  }
+
+  class Builder @JvmOverloads constructor(boundary: String = UUID.randomUUID().toString()) {
+    private val boundary: ByteString = boundary.encodeUtf8()
+    private var type = MIXED
+    private val parts = mutableListOf<Part>()
+
+    /**
+     * Set the MIME type. Expected values for `type` are [MIXED] (the default), [ALTERNATIVE],
+     * [DIGEST], [PARALLEL] and [FORM].
+     */
+    fun setType(type: MediaType) = apply {
+      require(type.type() == "multipart") { "multipart != $type" }
+      this.type = type
+    }
+
+    /** Add a part to the body.  */
+    fun addPart(body: RequestBody) = apply {
+      addPart(Part.create(body))
+    }
+
+    /** Add a part to the body.  */
+    fun addPart(headers: Headers?, body: RequestBody) = apply {
+      addPart(Part.create(headers, body))
+    }
+
+    /** Add a form data part to the body.  */
+    fun addFormDataPart(name: String, value: String) = apply {
+      addPart(Part.createFormData(name, value))
+    }
+
+    /** Add a form data part to the body.  */
+    fun addFormDataPart(name: String, filename: String?, body: RequestBody) = apply {
+      addPart(Part.createFormData(name, filename, body))
+    }
+
+    /** Add a part to the body.  */
+    fun addPart(part: Part) = apply {
+      parts.add(part)
+    }
+
+    /** Assemble the specified parts into a request body.  */
+    fun build(): MultipartBody {
+      check(parts.isNotEmpty()) { "Multipart body must have at least one part." }
+      return MultipartBody(boundary, type, parts)
+    }
+  }
+
+  companion object {
+    /**
+     * The "mixed" subtype of "multipart" is intended for use when the body parts are independent
+     * and need to be bundled in a particular order. Any "multipart" subtypes that an implementation
+     * does not recognize must be treated as being of subtype "mixed".
+     */
+    @JvmField
+    val MIXED = MediaType.get("multipart/mixed")
+
+    /**
+     * The "multipart/alternative" type is syntactically identical to "multipart/mixed", but the
+     * semantics are different. In particular, each of the body parts is an "alternative" version of
+     * the same information.
+     */
+    @JvmField
+    val ALTERNATIVE = MediaType.get("multipart/alternative")
+
+    /**
+     * This type is syntactically identical to "multipart/mixed", but the semantics are different.
+     * In particular, in a digest, the default `Content-Type` value for a body part is changed from
+     * "text/plain" to "message/rfc822".
+     */
+    @JvmField
+    val DIGEST = MediaType.get("multipart/digest")
+
+    /**
+     * This type is syntactically identical to "multipart/mixed", but the semantics are different.
+     * In particular, in a parallel entity, the order of body parts is not significant.
+     */
+    @JvmField
+    val PARALLEL = MediaType.get("multipart/parallel")
+
+    /**
+     * The media-type multipart/form-data follows the rules of all multipart MIME data streams as
+     * outlined in RFC 2046. In forms, there are a series of fields to be supplied by the user who
+     * fills out the form. Each field has a name. Within a given form, the names are unique.
+     */
+    @JvmField
+    val FORM = MediaType.get("multipart/form-data")
+
+    private val COLONSPACE = byteArrayOf(':'.toByte(), ' '.toByte())
+    private val CRLF = byteArrayOf('\r'.toByte(), '\n'.toByte())
+    private val DASHDASH = byteArrayOf('-'.toByte(), '-'.toByte())
+
+    /**
+     * Appends a quoted-string to a StringBuilder.
+     *
+     * RFC 2388 is rather vague about how one should escape special characters in form-data
+     * parameters, and as it turns out Firefox and Chrome actually do rather different things, and
+     * both say in their comments that they're not really sure what the right approach is. We go
+     * with Chrome's behavior (which also experimentally seems to match what IE does), but if you
+     * actually want to have a good chance of things working, please avoid double-quotes, newlines,
+     * percent signs, and the like in your field names.
+     */
+    internal fun StringBuilder.appendQuotedString(key: String) {
+      append('"')
+      for (i in 0 until key.length) {
+        val ch = key[i]
+        when (ch) {
+          '\n' -> append("%0A")
+          '\r' -> append("%0D")
+          '"' -> append("%22")
+          else -> append(ch)
+        }
+      }
+      append('"')
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
deleted file mode 100644
index 433982e136..0000000000
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ /dev/null
@@ -1,1057 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.Socket;
-import java.security.GeneralSecurityException;
-import java.time.Duration;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import javax.net.SocketFactory;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.connection.RouteDatabase;
-import okhttp3.internal.connection.StreamAllocation;
-import okhttp3.internal.http.HttpCodec;
-import okhttp3.internal.platform.Platform;
-import okhttp3.internal.proxy.NullProxySelector;
-import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.internal.tls.OkHostnameVerifier;
-import okhttp3.internal.ws.RealWebSocket;
-import okio.Sink;
-import okio.Source;
-import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
-
-import static okhttp3.internal.Util.checkDuration;
-
-/**
- * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
- * responses.
- *
- * <h3>OkHttpClients should be shared</h3>
- *
- * <p>OkHttp performs best when you create a single {@code OkHttpClient} instance and reuse it for
- * all of your HTTP calls. This is because each client holds its own connection pool and thread
- * pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a
- * client for each request wastes resources on idle pools.
- *
- * <p>Use {@code new OkHttpClient()} to create a shared instance with the default settings:
- * <pre>   {@code
- *
- *   // The singleton HTTP client.
- *   public final OkHttpClient client = new OkHttpClient();
- * }</pre>
- *
- * <p>Or use {@code new OkHttpClient.Builder()} to create a shared instance with custom settings:
- * <pre>   {@code
- *
- *   // The singleton HTTP client.
- *   public final OkHttpClient client = new OkHttpClient.Builder()
- *       .addInterceptor(new HttpLoggingInterceptor())
- *       .cache(new Cache(cacheDir, cacheSize))
- *       .build();
- * }</pre>
- *
- * <h3>Customize your client with newBuilder()</h3>
- *
- * <p>You can customize a shared OkHttpClient instance with {@link #newBuilder()}. This builds a
- * client that shares the same connection pool, thread pools, and configuration. Use the builder
- * methods to configure the derived client for a specific purpose.
- *
- * <p>This example shows a call with a short 500 millisecond timeout: <pre>   {@code
- *
- *   OkHttpClient eagerClient = client.newBuilder()
- *       .readTimeout(500, TimeUnit.MILLISECONDS)
- *       .build();
- *   Response response = eagerClient.newCall(request).execute();
- * }</pre>
- *
- * <h3>Shutdown isn't necessary</h3>
- *
- * <p>The threads and connections that are held will be released automatically if they remain idle.
- * But if you are writing a application that needs to aggressively release unused resources you may
- * do so.
- *
- * <p>Shutdown the dispatcher's executor service with {@link ExecutorService#shutdown shutdown()}.
- * This will also cause future calls to the client to be rejected. <pre>   {@code
- *
- *     client.dispatcher().executorService().shutdown();
- * }</pre>
- *
- * <p>Clear the connection pool with {@link ConnectionPool#evictAll() evictAll()}. Note that the
- * connection pool's daemon thread may not exit immediately. <pre>   {@code
- *
- *     client.connectionPool().evictAll();
- * }</pre>
- *
- * <p>If your client has a cache, call {@link Cache#close close()}. Note that it is an error to
- * create calls against a cache that is closed, and doing so will cause the call to crash.
- * <pre>   {@code
- *
- *     client.cache().close();
- * }</pre>
- *
- * <p>OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
- * remain idle.
- */
-public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
-  static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
-      Protocol.HTTP_2, Protocol.HTTP_1_1);
-
-  static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
-      ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
-
-  static {
-    Internal.instance = new Internal() {
-      @Override public void addLenient(Headers.Builder builder, String line) {
-        builder.addLenient(line);
-      }
-
-      @Override public void addLenient(Headers.Builder builder, String name, String value) {
-        builder.addLenient(name, value);
-      }
-
-      @Override public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) {
-        builder.setInternalCache(internalCache);
-      }
-
-      @Override public boolean connectionBecameIdle(
-          ConnectionPool pool, RealConnection connection) {
-        return pool.connectionBecameIdle(connection);
-      }
-
-      @Override public void acquire(ConnectionPool pool, Address address,
-          StreamAllocation streamAllocation, @Nullable Route route) {
-        pool.acquire(address, streamAllocation, route);
-      }
-
-      @Override public boolean equalsNonHost(Address a, Address b) {
-        return a.equalsNonHost(b);
-      }
-
-      @Override public @Nullable Socket deduplicate(
-          ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
-        return pool.deduplicate(address, streamAllocation);
-      }
-
-      @Override public void put(ConnectionPool pool, RealConnection connection) {
-        pool.put(connection);
-      }
-
-      @Override public RouteDatabase routeDatabase(ConnectionPool connectionPool) {
-        return connectionPool.routeDatabase;
-      }
-
-      @Override public int code(Response.Builder responseBuilder) {
-        return responseBuilder.code;
-      }
-
-      @Override
-      public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
-        tlsConfiguration.apply(sslSocket, isFallback);
-      }
-
-      @Override public boolean isInvalidHttpUrlHost(IllegalArgumentException e) {
-        return e.getMessage().startsWith(HttpUrl.Builder.INVALID_HOST);
-      }
-
-      @Override public StreamAllocation streamAllocation(Call call) {
-        return ((RealCall) call).streamAllocation();
-      }
-
-      @Override public @Nullable IOException timeoutExit(Call call, @Nullable IOException e) {
-        return ((RealCall) call).timeoutExit(e);
-      }
-
-      @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
-        return RealCall.newRealCall(client, originalRequest, true);
-      }
-
-      @Override public void initCodec(Response.Builder responseBuilder, HttpCodec httpCodec) {
-        responseBuilder.initCodec(httpCodec);
-      }
-    };
-  }
-
-  final Dispatcher dispatcher;
-  final @Nullable Proxy proxy;
-  final List<Protocol> protocols;
-  final List<ConnectionSpec> connectionSpecs;
-  final List<Interceptor> interceptors;
-  final List<Interceptor> networkInterceptors;
-  final EventListener.Factory eventListenerFactory;
-  final ProxySelector proxySelector;
-  final CookieJar cookieJar;
-  final @Nullable Cache cache;
-  final @Nullable InternalCache internalCache;
-  final SocketFactory socketFactory;
-  final SSLSocketFactory sslSocketFactory;
-  final CertificateChainCleaner certificateChainCleaner;
-  final HostnameVerifier hostnameVerifier;
-  final CertificatePinner certificatePinner;
-  final Authenticator proxyAuthenticator;
-  final Authenticator authenticator;
-  final ConnectionPool connectionPool;
-  final Dns dns;
-  final boolean followSslRedirects;
-  final boolean followRedirects;
-  final boolean retryOnConnectionFailure;
-  final int callTimeout;
-  final int connectTimeout;
-  final int readTimeout;
-  final int writeTimeout;
-  final int pingInterval;
-
-  public OkHttpClient() {
-    this(new Builder());
-  }
-
-  OkHttpClient(Builder builder) {
-    this.dispatcher = builder.dispatcher;
-    this.proxy = builder.proxy;
-    this.protocols = builder.protocols;
-    this.connectionSpecs = builder.connectionSpecs;
-    this.interceptors = Util.immutableList(builder.interceptors);
-    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
-    this.eventListenerFactory = builder.eventListenerFactory;
-    this.proxySelector = builder.proxySelector;
-    this.cookieJar = builder.cookieJar;
-    this.cache = builder.cache;
-    this.internalCache = builder.internalCache;
-    this.socketFactory = builder.socketFactory;
-
-    boolean isTLS = false;
-    for (ConnectionSpec spec : connectionSpecs) {
-      isTLS = isTLS || spec.isTls();
-    }
-
-    if (builder.sslSocketFactory != null || !isTLS) {
-      this.sslSocketFactory = builder.sslSocketFactory;
-      this.certificateChainCleaner = builder.certificateChainCleaner;
-    } else {
-      X509TrustManager trustManager = Util.platformTrustManager();
-      this.sslSocketFactory = newSslSocketFactory(trustManager);
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
-    }
-
-    if (sslSocketFactory != null) {
-      Platform.get().configureSslSocketFactory(sslSocketFactory);
-    }
-
-    this.hostnameVerifier = builder.hostnameVerifier;
-    this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
-        certificateChainCleaner);
-    this.proxyAuthenticator = builder.proxyAuthenticator;
-    this.authenticator = builder.authenticator;
-    this.connectionPool = builder.connectionPool;
-    this.dns = builder.dns;
-    this.followSslRedirects = builder.followSslRedirects;
-    this.followRedirects = builder.followRedirects;
-    this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
-    this.callTimeout = builder.callTimeout;
-    this.connectTimeout = builder.connectTimeout;
-    this.readTimeout = builder.readTimeout;
-    this.writeTimeout = builder.writeTimeout;
-    this.pingInterval = builder.pingInterval;
-
-    if (interceptors.contains(null)) {
-      throw new IllegalStateException("Null interceptor: " + interceptors);
-    }
-    if (networkInterceptors.contains(null)) {
-      throw new IllegalStateException("Null network interceptor: " + networkInterceptors);
-    }
-  }
-
-  private static SSLSocketFactory newSslSocketFactory(X509TrustManager trustManager) {
-    try {
-      SSLContext sslContext = Platform.get().getSSLContext();
-      sslContext.init(null, new TrustManager[] { trustManager }, null);
-      return sslContext.getSocketFactory();
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError("No System TLS", e); // The system has no TLS. Just give up.
-    }
-  }
-
-  /**
-   * Default call timeout (in milliseconds). By default there is no timeout for complete calls, but
-   * there is for the connect, write, and read actions within a call.
-   */
-  public int callTimeoutMillis() {
-    return callTimeout;
-  }
-
-  /** Default connect timeout (in milliseconds). The default is 10 seconds. */
-  public int connectTimeoutMillis() {
-    return connectTimeout;
-  }
-
-  /** Default read timeout (in milliseconds). The default is 10 seconds. */
-  public int readTimeoutMillis() {
-    return readTimeout;
-  }
-
-  /** Default write timeout (in milliseconds). The default is 10 seconds. */
-  public int writeTimeoutMillis() {
-    return writeTimeout;
-  }
-
-  /** Web socket and HTTP/2 ping interval (in milliseconds). By default pings are not sent. */
-  public int pingIntervalMillis() {
-    return pingInterval;
-  }
-
-  public @Nullable Proxy proxy() {
-    return proxy;
-  }
-
-  public ProxySelector proxySelector() {
-    return proxySelector;
-  }
-
-  public CookieJar cookieJar() {
-    return cookieJar;
-  }
-
-  public @Nullable Cache cache() {
-    return cache;
-  }
-
-  @Nullable InternalCache internalCache() {
-    return cache != null ? cache.internalCache : internalCache;
-  }
-
-  public Dns dns() {
-    return dns;
-  }
-
-  public SocketFactory socketFactory() {
-    return socketFactory;
-  }
-
-  public SSLSocketFactory sslSocketFactory() {
-    return sslSocketFactory;
-  }
-
-  public HostnameVerifier hostnameVerifier() {
-    return hostnameVerifier;
-  }
-
-  public CertificatePinner certificatePinner() {
-    return certificatePinner;
-  }
-
-  public Authenticator authenticator() {
-    return authenticator;
-  }
-
-  public Authenticator proxyAuthenticator() {
-    return proxyAuthenticator;
-  }
-
-  public ConnectionPool connectionPool() {
-    return connectionPool;
-  }
-
-  public boolean followSslRedirects() {
-    return followSslRedirects;
-  }
-
-  public boolean followRedirects() {
-    return followRedirects;
-  }
-
-  public boolean retryOnConnectionFailure() {
-    return retryOnConnectionFailure;
-  }
-
-  public Dispatcher dispatcher() {
-    return dispatcher;
-  }
-
-  public List<Protocol> protocols() {
-    return protocols;
-  }
-
-  public List<ConnectionSpec> connectionSpecs() {
-    return connectionSpecs;
-  }
-
-  /**
-   * Returns an immutable list of interceptors that observe the full span of each call: from before
-   * the connection is established (if any) until after the response source is selected (either the
-   * origin server, cache, or both).
-   */
-  public List<Interceptor> interceptors() {
-    return interceptors;
-  }
-
-  /**
-   * Returns an immutable list of interceptors that observe a single network request and response.
-   * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
-   * a network interceptor to short-circuit or repeat a network request.
-   */
-  public List<Interceptor> networkInterceptors() {
-    return networkInterceptors;
-  }
-
-  public EventListener.Factory eventListenerFactory() {
-    return eventListenerFactory;
-  }
-
-  /**
-   * Prepares the {@code request} to be executed at some point in the future.
-   */
-  @Override public Call newCall(Request request) {
-    return RealCall.newRealCall(this, request, false /* for web socket */);
-  }
-
-  /**
-   * Uses {@code request} to connect a new web socket.
-   */
-  @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {
-    RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval);
-    webSocket.connect(this);
-    return webSocket;
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  public static final class Builder {
-    Dispatcher dispatcher;
-    @Nullable Proxy proxy;
-    List<Protocol> protocols;
-    List<ConnectionSpec> connectionSpecs;
-    final List<Interceptor> interceptors = new ArrayList<>();
-    final List<Interceptor> networkInterceptors = new ArrayList<>();
-    EventListener.Factory eventListenerFactory;
-    ProxySelector proxySelector;
-    CookieJar cookieJar;
-    @Nullable Cache cache;
-    @Nullable InternalCache internalCache;
-    SocketFactory socketFactory;
-    @Nullable SSLSocketFactory sslSocketFactory;
-    @Nullable CertificateChainCleaner certificateChainCleaner;
-    HostnameVerifier hostnameVerifier;
-    CertificatePinner certificatePinner;
-    Authenticator proxyAuthenticator;
-    Authenticator authenticator;
-    ConnectionPool connectionPool;
-    Dns dns;
-    boolean followSslRedirects;
-    boolean followRedirects;
-    boolean retryOnConnectionFailure;
-    int callTimeout;
-    int connectTimeout;
-    int readTimeout;
-    int writeTimeout;
-    int pingInterval;
-
-    public Builder() {
-      dispatcher = new Dispatcher();
-      protocols = DEFAULT_PROTOCOLS;
-      connectionSpecs = DEFAULT_CONNECTION_SPECS;
-      eventListenerFactory = EventListener.factory(EventListener.NONE);
-      proxySelector = ProxySelector.getDefault();
-      if (proxySelector == null) {
-        proxySelector = new NullProxySelector();
-      }
-      cookieJar = CookieJar.NO_COOKIES;
-      socketFactory = SocketFactory.getDefault();
-      hostnameVerifier = OkHostnameVerifier.INSTANCE;
-      certificatePinner = CertificatePinner.DEFAULT;
-      proxyAuthenticator = Authenticator.NONE;
-      authenticator = Authenticator.NONE;
-      connectionPool = new ConnectionPool();
-      dns = Dns.SYSTEM;
-      followSslRedirects = true;
-      followRedirects = true;
-      retryOnConnectionFailure = true;
-      callTimeout = 0;
-      connectTimeout = 10_000;
-      readTimeout = 10_000;
-      writeTimeout = 10_000;
-      pingInterval = 0;
-    }
-
-    Builder(OkHttpClient okHttpClient) {
-      this.dispatcher = okHttpClient.dispatcher;
-      this.proxy = okHttpClient.proxy;
-      this.protocols = okHttpClient.protocols;
-      this.connectionSpecs = okHttpClient.connectionSpecs;
-      this.interceptors.addAll(okHttpClient.interceptors);
-      this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
-      this.eventListenerFactory = okHttpClient.eventListenerFactory;
-      this.proxySelector = okHttpClient.proxySelector;
-      this.cookieJar = okHttpClient.cookieJar;
-      this.internalCache = okHttpClient.internalCache;
-      this.cache = okHttpClient.cache;
-      this.socketFactory = okHttpClient.socketFactory;
-      this.sslSocketFactory = okHttpClient.sslSocketFactory;
-      this.certificateChainCleaner = okHttpClient.certificateChainCleaner;
-      this.hostnameVerifier = okHttpClient.hostnameVerifier;
-      this.certificatePinner = okHttpClient.certificatePinner;
-      this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
-      this.authenticator = okHttpClient.authenticator;
-      this.connectionPool = okHttpClient.connectionPool;
-      this.dns = okHttpClient.dns;
-      this.followSslRedirects = okHttpClient.followSslRedirects;
-      this.followRedirects = okHttpClient.followRedirects;
-      this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
-      this.callTimeout = okHttpClient.callTimeout;
-      this.connectTimeout = okHttpClient.connectTimeout;
-      this.readTimeout = okHttpClient.readTimeout;
-      this.writeTimeout = okHttpClient.writeTimeout;
-      this.pingInterval = okHttpClient.pingInterval;
-    }
-
-    /**
-     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
-     * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
-     * body, server processing, and reading the response body. If the call requires redirects or
-     * retries all must complete within one timeout period.
-     *
-     * <p>The default value is 0 which imposes no timeout.
-     */
-    public Builder callTimeout(long timeout, TimeUnit unit) {
-      callTimeout = checkDuration("timeout", timeout, unit);
-      return this;
-    }
-
-    /**
-     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
-     * must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The call timeout spans the entire call: resolving DNS, connecting, writing the request
-     * body, server processing, and reading the response body. If the call requires redirects or
-     * retries all must complete within one timeout period.
-     *
-     * <p>The default value is 0 which imposes no timeout.
-     */
-    @IgnoreJRERequirement
-    public Builder callTimeout(Duration duration) {
-      callTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
-    }
-
-    /**
-     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
-     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
-     * milliseconds.
-     *
-     * <p>The connect timeout is applied when connecting a TCP socket to the target host.
-     * The default value is 10 seconds.
-     */
-    public Builder connectTimeout(long timeout, TimeUnit unit) {
-      connectTimeout = checkDuration("timeout", timeout, unit);
-      return this;
-    }
-
-    /**
-     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
-     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
-     * milliseconds.
-     *
-     * <p>The connect timeout is applied when connecting a TCP socket to the target host.
-     * The default value is 10 seconds.
-     */
-    @IgnoreJRERequirement
-    public Builder connectTimeout(Duration duration) {
-      connectTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
-    }
-
-    /**
-     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
-     * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
-     *
-     * @see Socket#setSoTimeout(int)
-     * @see Source#timeout()
-     */
-    public Builder readTimeout(long timeout, TimeUnit unit) {
-      readTimeout = checkDuration("timeout", timeout, unit);
-      return this;
-    }
-
-    /**
-     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
-     * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
-     *
-     * @see Socket#setSoTimeout(int)
-     * @see Source#timeout()
-     */
-    @IgnoreJRERequirement
-    public Builder readTimeout(Duration duration) {
-      readTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
-    }
-
-    /**
-     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The write timeout is applied for individual write IO operations.
-     * The default value is 10 seconds.
-     *
-     * @see Sink#timeout()
-     */
-    public Builder writeTimeout(long timeout, TimeUnit unit) {
-      writeTimeout = checkDuration("timeout", timeout, unit);
-      return this;
-    }
-
-    /**
-     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The write timeout is applied for individual write IO operations.
-     * The default value is 10 seconds.
-     *
-     * @see Sink#timeout()
-     */
-    @IgnoreJRERequirement
-    public Builder writeTimeout(Duration duration) {
-      writeTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
-    }
-
-    /**
-     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
-     * automatically send ping frames until either the connection fails or it is closed. This keeps
-     * the connection alive and may detect connectivity failures.
-     *
-     * <p>If the server does not respond to each ping with a pong within {@code interval}, this
-     * client will assume that connectivity has been lost. When this happens on a web socket the
-     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
-     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
-     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
-     *
-     * <p>The default value of 0 disables client-initiated pings.
-     */
-    public Builder pingInterval(long interval, TimeUnit unit) {
-      pingInterval = checkDuration("interval", interval, unit);
-      return this;
-    }
-
-    /**
-     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
-     * automatically send ping frames until either the connection fails or it is closed. This keeps
-     * the connection alive and may detect connectivity failures.
-     *
-     * <p>If the server does not respond to each ping with a pong within {@code interval}, this
-     * client will assume that connectivity has been lost. When this happens on a web socket the
-     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
-     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
-     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
-     *
-     * <p>The default value of 0 disables client-initiated pings.
-     */
-    @IgnoreJRERequirement
-    public Builder pingInterval(Duration duration) {
-      pingInterval = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS);
-      return this;
-    }
-
-    /**
-     * Sets the HTTP proxy that will be used by connections created by this client. This takes
-     * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
-     * it is by default). To disable proxy use completely, call {@code proxy(Proxy.NO_PROXY)}.
-     */
-    public Builder proxy(@Nullable Proxy proxy) {
-      this.proxy = proxy;
-      return this;
-    }
-
-    /**
-     * Sets the proxy selection policy to be used if no {@link #proxy proxy} is specified
-     * explicitly. The proxy selector may return multiple proxies; in that case they will be tried
-     * in sequence until a successful connection is established.
-     *
-     * <p>If unset, the {@link ProxySelector#getDefault() system-wide default} proxy selector will
-     * be used.
-     */
-    public Builder proxySelector(ProxySelector proxySelector) {
-      if (proxySelector == null) throw new NullPointerException("proxySelector == null");
-      this.proxySelector = proxySelector;
-      return this;
-    }
-
-    /**
-     * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
-     * outgoing HTTP requests.
-     *
-     * <p>If unset, {@linkplain CookieJar#NO_COOKIES no cookies} will be accepted nor provided.
-     */
-    public Builder cookieJar(CookieJar cookieJar) {
-      if (cookieJar == null) throw new NullPointerException("cookieJar == null");
-      this.cookieJar = cookieJar;
-      return this;
-    }
-
-    /** Sets the response cache to be used to read and write cached responses. */
-    void setInternalCache(@Nullable InternalCache internalCache) {
-      this.internalCache = internalCache;
-      this.cache = null;
-    }
-
-    /** Sets the response cache to be used to read and write cached responses. */
-    public Builder cache(@Nullable Cache cache) {
-      this.cache = cache;
-      this.internalCache = null;
-      return this;
-    }
-
-    /**
-     * Sets the DNS service used to lookup IP addresses for hostnames.
-     *
-     * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.
-     */
-    public Builder dns(Dns dns) {
-      if (dns == null) throw new NullPointerException("dns == null");
-      this.dns = dns;
-      return this;
-    }
-
-    /**
-     * Sets the socket factory used to create connections. OkHttp only uses the parameterless {@link
-     * SocketFactory#createSocket() createSocket()} method to create unconnected sockets. Overriding
-     * this method, e. g., allows the socket to be bound to a specific local address.
-     *
-     * <p>If unset, the {@link SocketFactory#getDefault() system-wide default} socket factory will
-     * be used.
-     */
-    public Builder socketFactory(SocketFactory socketFactory) {
-      if (socketFactory == null) throw new NullPointerException("socketFactory == null");
-      if (socketFactory instanceof SSLSocketFactory) {
-        throw new IllegalArgumentException("socketFactory instanceof SSLSocketFactory");
-      }
-      this.socketFactory = socketFactory;
-      return this;
-    }
-
-    /**
-     * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
-     * be used.
-     *
-     * @deprecated {@code SSLSocketFactory} does not expose its {@link X509TrustManager}, which is
-     *     a field that OkHttp needs to build a clean certificate chain. This method instead must
-     *     use reflection to extract the trust manager. Applications should prefer to call {@link
-     *     #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.
-     */
-    public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
-      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
-      this.sslSocketFactory = sslSocketFactory;
-      this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory);
-      return this;
-    }
-
-    /**
-     * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
-     * system defaults will be used.
-     *
-     * <p>Most applications should not call this method, and instead use the system defaults. Those
-     * classes include special optimizations that can be lost if the implementations are decorated.
-     *
-     * <p>If necessary, you can create and configure the defaults yourself with the following code:
-     *
-     * <pre>   {@code
-     *
-     *   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-     *       TrustManagerFactory.getDefaultAlgorithm());
-     *   trustManagerFactory.init((KeyStore) null);
-     *   TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-     *   if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-     *     throw new IllegalStateException("Unexpected default trust managers:"
-     *         + Arrays.toString(trustManagers));
-     *   }
-     *   X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
-     *
-     *   SSLContext sslContext = SSLContext.getInstance("TLS");
-     *   sslContext.init(null, new TrustManager[] { trustManager }, null);
-     *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
-     *
-     *   OkHttpClient client = new OkHttpClient.Builder()
-     *       .sslSocketFactory(sslSocketFactory, trustManager)
-     *       .build();
-     * }</pre>
-     */
-    public Builder sslSocketFactory(
-        SSLSocketFactory sslSocketFactory, X509TrustManager trustManager) {
-      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
-      if (trustManager == null) throw new NullPointerException("trustManager == null");
-      this.sslSocketFactory = sslSocketFactory;
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
-      return this;
-    }
-
-    /**
-     * Sets the verifier used to confirm that response certificates apply to requested hostnames for
-     * HTTPS connections.
-     *
-     * <p>If unset, a default hostname verifier will be used.
-     */
-    public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
-      if (hostnameVerifier == null) throw new NullPointerException("hostnameVerifier == null");
-      this.hostnameVerifier = hostnameVerifier;
-      return this;
-    }
-
-    /**
-     * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
-     * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish trust.
-     * Pinning certificates avoids the need to trust certificate authorities.
-     */
-    public Builder certificatePinner(CertificatePinner certificatePinner) {
-      if (certificatePinner == null) throw new NullPointerException("certificatePinner == null");
-      this.certificatePinner = certificatePinner;
-      return this;
-    }
-
-    /**
-     * Sets the authenticator used to respond to challenges from origin servers. Use {@link
-     * #proxyAuthenticator} to set the authenticator for proxy servers.
-     *
-     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
-     */
-    public Builder authenticator(Authenticator authenticator) {
-      if (authenticator == null) throw new NullPointerException("authenticator == null");
-      this.authenticator = authenticator;
-      return this;
-    }
-
-    /**
-     * Sets the authenticator used to respond to challenges from proxy servers. Use {@link
-     * #authenticator} to set the authenticator for origin servers.
-     *
-     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
-     */
-    public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {
-      if (proxyAuthenticator == null) throw new NullPointerException("proxyAuthenticator == null");
-      this.proxyAuthenticator = proxyAuthenticator;
-      return this;
-    }
-
-    /**
-     * Sets the connection pool used to recycle HTTP and HTTPS connections.
-     *
-     * <p>If unset, a new connection pool will be used.
-     */
-    public Builder connectionPool(ConnectionPool connectionPool) {
-      if (connectionPool == null) throw new NullPointerException("connectionPool == null");
-      this.connectionPool = connectionPool;
-      return this;
-    }
-
-    /**
-     * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
-     *
-     * <p>If unset, protocol redirects will be followed. This is different than the built-in {@code
-     * HttpURLConnection}'s default.
-     */
-    public Builder followSslRedirects(boolean followProtocolRedirects) {
-      this.followSslRedirects = followProtocolRedirects;
-      return this;
-    }
-
-    /** Configure this client to follow redirects. If unset, redirects will be followed. */
-    public Builder followRedirects(boolean followRedirects) {
-      this.followRedirects = followRedirects;
-      return this;
-    }
-
-    /**
-     * Configure this client to retry or not when a connectivity problem is encountered. By default,
-     * this client silently recovers from the following problems:
-     *
-     * <ul>
-     *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
-     *       failure to reach any individual IP address doesn't fail the overall request. This can
-     *       increase availability of multi-homed services.
-     *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
-     *       to decrease request latency, but these connections will occasionally time out.
-     *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
-     *       attempt multiple proxy servers in sequence, eventually falling back to a direct
-     *       connection.
-     * </ul>
-     *
-     * Set this to false to avoid retrying requests when doing so is destructive. In this case the
-     * calling application should do its own recovery of connectivity failures.
-     */
-    public Builder retryOnConnectionFailure(boolean retryOnConnectionFailure) {
-      this.retryOnConnectionFailure = retryOnConnectionFailure;
-      return this;
-    }
-
-    /**
-     * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
-     */
-    public Builder dispatcher(Dispatcher dispatcher) {
-      if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
-      this.dispatcher = dispatcher;
-      return this;
-    }
-
-    /**
-     * Configure the protocols used by this client to communicate with remote servers. By default
-     * this client will prefer the most efficient transport available, falling back to more
-     * ubiquitous protocols. Applications should only call this method to avoid specific
-     * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
-     *
-     * <p>The following protocols are currently supported:
-     *
-     * <ul>
-     *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-     *     <li><a href="https://tools.ietf.org/html/rfc7540">h2</a>
-     *     <li><a href="https://tools.ietf.org/html/rfc7540#section-3.4">h2 with prior knowledge
-     *         (cleartext only)</a>
-     * </ul>
-     *
-     * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
-     * protocols. The http/1.1 transport will never be dropped.
-     *
-     * <p>If multiple protocols are specified, <a
-     * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
-     * negotiate a transport. Protocol negotiation is only attempted for HTTPS URLs.
-     *
-     * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
-     * HTTP/1.1}. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
-     * Response#protocol()}.
-     *
-     * @param protocols the protocols to use, in order of preference. If the list contains {@link
-     *     Protocol#H2_PRIOR_KNOWLEDGE} then that must be the only protocol and HTTPS URLs will not
-     *     be supported. Otherwise the list must contain {@link Protocol#HTTP_1_1}. The list must
-     *     not contain null or {@link Protocol#HTTP_1_0}.
-     */
-    public Builder protocols(List<Protocol> protocols) {
-      // Create a private copy of the list.
-      protocols = new ArrayList<>(protocols);
-
-      // Validate that the list has everything we require and nothing we forbid.
-      if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
-          && !protocols.contains(Protocol.HTTP_1_1)) {
-        throw new IllegalArgumentException(
-            "protocols must contain h2_prior_knowledge or http/1.1: " + protocols);
-      }
-      if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
-        throw new IllegalArgumentException(
-            "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
-      }
-      if (protocols.contains(Protocol.HTTP_1_0)) {
-        throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
-      }
-      if (protocols.contains(null)) {
-        throw new IllegalArgumentException("protocols must not contain null");
-      }
-
-      // Remove protocols that we no longer support.
-      protocols.remove(Protocol.SPDY_3);
-
-      // Assign as an unmodifiable list. This is effectively immutable.
-      this.protocols = Collections.unmodifiableList(protocols);
-      return this;
-    }
-
-    public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
-      this.connectionSpecs = Util.immutableList(connectionSpecs);
-      return this;
-    }
-
-    /**
-     * Returns a modifiable list of interceptors that observe the full span of each call: from
-     * before the connection is established (if any) until after the response source is selected
-     * (either the origin server, cache, or both).
-     */
-    public List<Interceptor> interceptors() {
-      return interceptors;
-    }
-
-    public Builder addInterceptor(Interceptor interceptor) {
-      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
-      interceptors.add(interceptor);
-      return this;
-    }
-
-    /**
-     * Returns a modifiable list of interceptors that observe a single network request and response.
-     * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error
-     * for a network interceptor to short-circuit or repeat a network request.
-     */
-    public List<Interceptor> networkInterceptors() {
-      return networkInterceptors;
-    }
-
-    public Builder addNetworkInterceptor(Interceptor interceptor) {
-      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
-      networkInterceptors.add(interceptor);
-      return this;
-    }
-
-    /**
-     * Configure a single client scoped listener that will receive all analytic events
-     * for this client.
-     *
-     * @see EventListener for semantics and restrictions on listener implementations.
-     */
-    public Builder eventListener(EventListener eventListener) {
-      if (eventListener == null) throw new NullPointerException("eventListener == null");
-      this.eventListenerFactory = EventListener.factory(eventListener);
-      return this;
-    }
-
-    /**
-     * Configure a factory to provide per-call scoped listeners that will receive analytic events
-     * for this client.
-     *
-     * @see EventListener for semantics and restrictions on listener implementations.
-     */
-    public Builder eventListenerFactory(EventListener.Factory eventListenerFactory) {
-      if (eventListenerFactory == null) {
-        throw new NullPointerException("eventListenerFactory == null");
-      }
-      this.eventListenerFactory = eventListenerFactory;
-      return this;
-    }
-
-    public OkHttpClient build() {
-      return new OkHttpClient(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.kt b/okhttp/src/main/java/okhttp3/OkHttpClient.kt
new file mode 100644
index 0000000000..3ddc869b99
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.kt
@@ -0,0 +1,858 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.Protocol.HTTP_1_1
+import okhttp3.Protocol.HTTP_2
+import okhttp3.internal.Internal
+import okhttp3.internal.Util
+import okhttp3.internal.Util.checkDuration
+import okhttp3.internal.cache.InternalCache
+import okhttp3.internal.connection.Exchange
+import okhttp3.internal.platform.Platform
+import okhttp3.internal.proxy.NullProxySelector
+import okhttp3.internal.tls.CertificateChainCleaner
+import okhttp3.internal.tls.OkHostnameVerifier
+import okhttp3.internal.ws.RealWebSocket
+import okio.Sink
+import okio.Source
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
+import java.net.Proxy
+import java.net.ProxySelector
+import java.net.Socket
+import java.security.GeneralSecurityException
+import java.time.Duration
+import java.util.Collections
+import java.util.Random
+import java.util.concurrent.ExecutorService
+import java.util.concurrent.TimeUnit
+import javax.net.SocketFactory
+import javax.net.ssl.HostnameVerifier
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.TrustManager
+import javax.net.ssl.X509TrustManager
+import kotlin.DeprecationLevel.ERROR
+
+/**
+ * Factory for [calls][Call], which can be used to send HTTP requests and read their responses.
+ *
+ * ## OkHttpClients Should Be Shared
+ *
+ * OkHttp performs best when you create a single `OkHttpClient` instance and reuse it for all of
+ * your HTTP calls. This is because each client holds its own connection pool and thread pools.
+ * Reusing connections and threads reduces latency and saves memory. Conversely, creating a client
+ * for each request wastes resources on idle pools.
+ *
+ * Use `new OkHttpClient()` to create a shared instance with the default settings:
+ *
+ * ```
+ * // The singleton HTTP client.
+ * public final OkHttpClient client = new OkHttpClient();
+ * ```
+ *
+ * Or use `new OkHttpClient.Builder()` to create a shared instance with custom settings:
+ *
+ * ```
+ * // The singleton HTTP client.
+ * public final OkHttpClient client = new OkHttpClient.Builder()
+ *     .addInterceptor(new HttpLoggingInterceptor())
+ *     .cache(new Cache(cacheDir, cacheSize))
+ *     .build();
+ * ```
+ *
+ * ## Customize Your Client With newBuilder()
+ *
+ * You can customize a shared OkHttpClient instance with [newBuilder]. This builds a client that
+ * shares the same connection pool, thread pools, and configuration. Use the builder methods to
+ * configure the derived client for a specific purpose.
+ *
+ * This example shows a call with a short 500 millisecond timeout:
+ *
+ * ```
+ * OkHttpClient eagerClient = client.newBuilder()
+ *     .readTimeout(500, TimeUnit.MILLISECONDS)
+ *     .build();
+ * Response response = eagerClient.newCall(request).execute();
+ * ```
+ *
+ * ## Shutdown Isn't Necessary
+ *
+ * The threads and connections that are held will be released automatically if they remain idle. But
+ * if you are writing a application that needs to aggressively release unused resources you may do
+ * so.
+ *
+ * Shutdown the dispatcher's executor service with [shutdown()][ExecutorService.shutdown]. This will
+ * also cause future calls to the client to be rejected.
+ *
+ * ```
+ * client.dispatcher().executorService().shutdown();
+ * ```
+ *
+ * Clear the connection pool with [evictAll()][ConnectionPool.evictAll]. Note that the connection
+ * pool's daemon thread may not exit immediately.
+ *
+ * ```
+ * client.connectionPool().evictAll();
+ * ```
+ *
+ * If your client has a cache, call [close()][Cache.close]. Note that it is an error to create calls
+ * against a cache that is closed, and doing so will cause the call to crash.
+ *
+ * ```
+ * client.cache().close();
+ * ```
+ *
+ * OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
+ * remain idle.
+ */
+open class OkHttpClient internal constructor(
+  builder: Builder
+) : Cloneable, Call.Factory, WebSocket.Factory {
+  private val dispatcher: Dispatcher = builder.dispatcher
+  private val proxy: Proxy? = builder.proxy
+  private val protocols: List<Protocol> = builder.protocols
+  private val connectionSpecs: List<ConnectionSpec> = builder.connectionSpecs
+  private val interceptors: List<Interceptor> =
+      Util.immutableList(builder.interceptors)
+  private val networkInterceptors: List<Interceptor> =
+      Util.immutableList(builder.networkInterceptors)
+  private val eventListenerFactory: EventListener.Factory = builder.eventListenerFactory
+  private val proxySelector: ProxySelector = builder.proxySelector
+  private val cookieJar: CookieJar = builder.cookieJar
+  private val cache: Cache? = builder.cache
+  private val socketFactory: SocketFactory = builder.socketFactory
+  private val sslSocketFactory: SSLSocketFactory?
+  private val hostnameVerifier: HostnameVerifier = builder.hostnameVerifier
+  private val certificatePinner: CertificatePinner
+  private val proxyAuthenticator: Authenticator = builder.proxyAuthenticator
+  private val authenticator: Authenticator = builder.authenticator
+  private val connectionPool: ConnectionPool = builder.connectionPool
+  private val dns: Dns = builder.dns
+  private val followSslRedirects: Boolean = builder.followSslRedirects
+  private val followRedirects: Boolean = builder.followRedirects
+  private val retryOnConnectionFailure: Boolean = builder.retryOnConnectionFailure
+  private val callTimeout: Int = builder.callTimeout
+  private val connectTimeout: Int = builder.connectTimeout
+  private val readTimeout: Int = builder.readTimeout
+  private val writeTimeout: Int = builder.writeTimeout
+  private val pingInterval: Int = builder.pingInterval
+  private val internalCache: InternalCache? = builder.internalCache
+  private val certificateChainCleaner: CertificateChainCleaner?
+
+  constructor() : this(Builder())
+
+  init {
+    var isTLS = false
+    for (spec in connectionSpecs) {
+      isTLS = isTLS || spec.isTls
+    }
+
+    // TODO - these nullability warnings existed in Java
+    if (builder.sslSocketFactory != null || !isTLS) {
+      this.sslSocketFactory = builder.sslSocketFactory
+      this.certificateChainCleaner = builder.certificateChainCleaner
+    } else {
+      val trustManager = Util.platformTrustManager()
+      Platform.get().configureTrustManager(trustManager)
+      this.sslSocketFactory = newSslSocketFactory(trustManager)
+      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager)
+    }
+
+    if (sslSocketFactory != null) {
+      Platform.get().configureSslSocketFactory(sslSocketFactory)
+    }
+
+    this.certificatePinner = builder.certificatePinner
+        .withCertificateChainCleaner(certificateChainCleaner)
+
+    check(null !in (interceptors as List<Interceptor?>)) {
+      "Null interceptor: $interceptors"
+    }
+    check(null !in (networkInterceptors as List<Interceptor?>)) {
+      "Null network interceptor: $networkInterceptors"
+    }
+  }
+
+  open fun dispatcher(): Dispatcher = dispatcher
+
+  open fun proxy(): Proxy? = proxy
+
+  open fun protocols(): List<Protocol> = protocols
+
+  open fun connectionSpecs(): List<ConnectionSpec> = connectionSpecs
+
+  /**
+   * Returns an immutable list of interceptors that observe the full span of each call: from before
+   * the connection is established (if any) until after the response source is selected (either the
+   * origin server, cache, or both).
+   */
+  open fun interceptors(): List<Interceptor> = interceptors
+
+  /**
+   * Returns an immutable list of interceptors that observe a single network request and response.
+   * These interceptors must call [Interceptor.Chain.proceed] exactly once: it is an error for
+   * a network interceptor to short-circuit or repeat a network request.
+   */
+  open fun networkInterceptors(): List<Interceptor> = networkInterceptors
+
+  open fun eventListenerFactory(): EventListener.Factory = eventListenerFactory
+
+  open fun proxySelector(): ProxySelector = proxySelector
+
+  open fun cookieJar(): CookieJar = cookieJar
+
+  open fun cache(): Cache? = cache
+
+  open fun socketFactory(): SocketFactory = socketFactory
+
+  open fun sslSocketFactory(): SSLSocketFactory = sslSocketFactory!!
+
+  open fun hostnameVerifier(): HostnameVerifier = hostnameVerifier
+
+  open fun certificatePinner(): CertificatePinner = certificatePinner
+
+  open fun proxyAuthenticator(): Authenticator = proxyAuthenticator
+
+  open fun authenticator(): Authenticator = authenticator
+
+  open fun connectionPool(): ConnectionPool = connectionPool
+
+  open fun dns(): Dns = dns
+
+  open fun followSslRedirects(): Boolean = followSslRedirects
+
+  open fun followRedirects(): Boolean = followRedirects
+
+  open fun retryOnConnectionFailure(): Boolean = retryOnConnectionFailure
+
+  /**
+   * Default call timeout (in milliseconds). By default there is no timeout for complete calls, but
+   * there is for the connect, write, and read actions within a call.
+   */
+  open fun callTimeoutMillis(): Int = callTimeout
+
+  /** Default connect timeout (in milliseconds). The default is 10 seconds.  */
+  open fun connectTimeoutMillis(): Int = connectTimeout
+
+  /** Default read timeout (in milliseconds). The default is 10 seconds. */
+  open fun readTimeoutMillis(): Int = readTimeout
+
+  /** Default write timeout (in milliseconds). The default is 10 seconds. */
+  open fun writeTimeoutMillis(): Int = writeTimeout
+
+  /** Web socket and HTTP/2 ping interval (in milliseconds). By default pings are not sent. */
+  open fun pingIntervalMillis(): Int = pingInterval
+
+  internal fun internalCache(): InternalCache? {
+    return cache?.internalCache ?: internalCache
+  }
+
+  /** Prepares the [request] to be executed at some point in the future. */
+  override fun newCall(request: Request): Call {
+    return RealCall.newRealCall(this, request, false /* for web socket */)
+  }
+
+  /** Uses [request] to connect a new web socket. */
+  override fun newWebSocket(request: Request, listener: WebSocketListener): WebSocket {
+    val webSocket = RealWebSocket(request, listener, Random(), pingInterval.toLong())
+    webSocket.connect(this)
+    return webSocket
+  }
+
+  open fun newBuilder(): Builder = Builder(this)
+
+  class Builder constructor() {
+    internal var dispatcher: Dispatcher = Dispatcher()
+    internal var proxy: Proxy? = null
+    internal var protocols: List<Protocol> = DEFAULT_PROTOCOLS
+    internal var connectionSpecs: List<ConnectionSpec> = DEFAULT_CONNECTION_SPECS
+    internal val interceptors: MutableList<Interceptor> = mutableListOf()
+    internal val networkInterceptors: MutableList<Interceptor> = mutableListOf()
+    internal var eventListenerFactory: EventListener.Factory = Util.eventListenerFactory(
+        EventListener.NONE)
+    internal var proxySelector: ProxySelector = ProxySelector.getDefault() ?: NullProxySelector()
+    internal var cookieJar: CookieJar = CookieJar.NO_COOKIES
+    internal var cache: Cache? = null
+    internal var internalCache: InternalCache? = null
+    internal var socketFactory: SocketFactory = SocketFactory.getDefault()
+    internal var sslSocketFactory: SSLSocketFactory? = null
+    internal var certificateChainCleaner: CertificateChainCleaner? = null
+    internal var hostnameVerifier: HostnameVerifier = OkHostnameVerifier
+    internal var certificatePinner: CertificatePinner = CertificatePinner.DEFAULT
+    internal var proxyAuthenticator: Authenticator = Authenticator.NONE
+    internal var authenticator: Authenticator = Authenticator.NONE
+    internal var connectionPool: ConnectionPool = ConnectionPool()
+    internal var dns: Dns = Dns.SYSTEM
+    internal var followSslRedirects: Boolean = true
+    internal var followRedirects: Boolean = true
+    internal var retryOnConnectionFailure: Boolean = true
+    internal var callTimeout: Int = 0
+    internal var connectTimeout: Int = 10000
+    internal var readTimeout: Int = 10000
+    internal var writeTimeout: Int = 10000
+    internal var pingInterval: Int = 0
+
+    internal constructor(okHttpClient: OkHttpClient) : this() {
+      this.dispatcher = okHttpClient.dispatcher
+      this.proxy = okHttpClient.proxy
+      this.protocols = okHttpClient.protocols
+      this.connectionSpecs = okHttpClient.connectionSpecs
+      this.interceptors += okHttpClient.interceptors
+      this.networkInterceptors += okHttpClient.networkInterceptors
+      this.eventListenerFactory = okHttpClient.eventListenerFactory
+      this.proxySelector = okHttpClient.proxySelector
+      this.cookieJar = okHttpClient.cookieJar
+      this.internalCache = okHttpClient.internalCache
+      this.cache = okHttpClient.cache
+      this.socketFactory = okHttpClient.socketFactory
+      this.sslSocketFactory = okHttpClient.sslSocketFactory
+      this.certificateChainCleaner = okHttpClient.certificateChainCleaner
+      this.hostnameVerifier = okHttpClient.hostnameVerifier
+      this.certificatePinner = okHttpClient.certificatePinner
+      this.proxyAuthenticator = okHttpClient.proxyAuthenticator
+      this.authenticator = okHttpClient.authenticator
+      this.connectionPool = okHttpClient.connectionPool
+      this.dns = okHttpClient.dns
+      this.followSslRedirects = okHttpClient.followSslRedirects
+      this.followRedirects = okHttpClient.followRedirects
+      this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure
+      this.callTimeout = okHttpClient.callTimeout
+      this.connectTimeout = okHttpClient.connectTimeout
+      this.readTimeout = okHttpClient.readTimeout
+      this.writeTimeout = okHttpClient.writeTimeout
+      this.pingInterval = okHttpClient.pingInterval
+    }
+
+    /**
+     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+     * must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The call timeout spans the entire call: resolving DNS, connecting, writing the request body,
+     * server processing, and reading the response body. If the call requires redirects or retries
+     * all must complete within one timeout period.
+     *
+     * The default value is 0 which imposes no timeout.
+     */
+    fun callTimeout(timeout: Long, unit: TimeUnit) = apply {
+      callTimeout = checkDuration("timeout", timeout, unit)
+    }
+
+    /**
+     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+     * must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The call timeout spans the entire call: resolving DNS, connecting, writing the request body,
+     * server processing, and reading the response body. If the call requires redirects or retries
+     * all must complete within one timeout period.
+     *
+     * The default value is 0 which imposes no timeout.
+     */
+    @IgnoreJRERequirement
+    fun callTimeout(duration: Duration) = apply {
+      callTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+    }
+
+    /**
+     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+     * otherwise values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The connect timeout is applied when connecting a TCP socket to the target host. The default
+     * value is 10 seconds.
+     */
+    fun connectTimeout(timeout: Long, unit: TimeUnit) = apply {
+      connectTimeout = checkDuration("timeout", timeout, unit)
+    }
+
+    /**
+     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+     * otherwise values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The connect timeout is applied when connecting a TCP socket to the target host. The default
+     * value is 10 seconds.
+     */
+    @IgnoreJRERequirement
+    fun connectTimeout(duration: Duration) = apply {
+      connectTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+    }
+
+    /**
+     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The read timeout is applied to both the TCP socket and for individual read IO operations
+     * including on [Source] of the [Response]. The default value is 10 seconds.
+     *
+     * @see Socket.setSoTimeout
+     * @see Source.timeout
+     */
+    fun readTimeout(timeout: Long, unit: TimeUnit) = apply {
+      readTimeout = checkDuration("timeout", timeout, unit)
+    }
+
+    /**
+     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The read timeout is applied to both the TCP socket and for individual read IO operations
+     * including on [Source] of the [Response]. The default value is 10 seconds.
+     *
+     * @see Socket.setSoTimeout
+     * @see Source.timeout
+     */
+    @IgnoreJRERequirement
+    fun readTimeout(duration: Duration) = apply {
+      readTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+    }
+
+    /**
+     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The write timeout is applied for individual write IO operations. The default value is 10
+     * seconds.
+     *
+     * @see Sink.timeout
+     */
+    fun writeTimeout(timeout: Long, unit: TimeUnit) = apply {
+      writeTimeout = checkDuration("timeout", timeout, unit)
+    }
+
+    /**
+     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The write timeout is applied for individual write IO operations. The default value is 10
+     * seconds.
+     *
+     * @see Sink.timeout
+     */
+    @IgnoreJRERequirement
+    fun writeTimeout(duration: Duration) = apply {
+      writeTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+    }
+
+    /**
+     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+     * automatically send ping frames until either the connection fails or it is closed. This keeps
+     * the connection alive and may detect connectivity failures.
+     *
+     * If the server does not respond to each ping with a pong within `interval`, this client will
+     * assume that connectivity has been lost. When this happens on a web socket the connection is
+     * canceled and its listener is [notified][WebSocketListener.onFailure]. When it happens on an
+     * HTTP/2 connection the connection is closed and any calls it is carrying
+     * [will fail with an IOException][java.io.IOException].
+     *
+     * The default value of 0 disables client-initiated pings.
+     */
+    fun pingInterval(interval: Long, unit: TimeUnit) = apply {
+      pingInterval = checkDuration("interval", interval, unit)
+    }
+
+    /**
+     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+     * automatically send ping frames until either the connection fails or it is closed. This keeps
+     * the connection alive and may detect connectivity failures.
+     *
+     * If the server does not respond to each ping with a pong within `interval`, this client will
+     * assume that connectivity has been lost. When this happens on a web socket the connection is
+     * canceled and its listener is [notified][WebSocketListener.onFailure]. When it happens on an
+     * HTTP/2 connection the connection is closed and any calls it is carrying
+     * [will fail with an IOException][java.io.IOException].
+     *
+     * The default value of 0 disables client-initiated pings.
+     */
+    @IgnoreJRERequirement
+    fun pingInterval(duration: Duration) = apply {
+      pingInterval = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+    }
+
+    /**
+     * Sets the HTTP proxy that will be used by connections created by this client. This takes
+     * precedence over [proxySelector], which is only honored when this proxy is null (which it is
+     * by default). To disable proxy use completely, call `proxy(Proxy.NO_PROXY)`.
+     */
+    fun proxy(proxy: Proxy?) = apply {
+      this.proxy = proxy
+    }
+
+    /**
+     * Sets the proxy selection policy to be used if no [proxy][proxy] is specified explicitly. The
+     * proxy selector may return multiple proxies; in that case they will be tried in sequence until
+     * a successful connection is established.
+     *
+     * If unset, the [system-wide default][ProxySelector.getDefault] proxy selector will be used.
+     */
+    fun proxySelector(proxySelector: ProxySelector) = apply {
+      this.proxySelector = proxySelector
+    }
+
+    /**
+     * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
+     * outgoing HTTP requests.
+     *
+     * If unset, [no cookies][CookieJar.NO_COOKIES] will be accepted nor provided.
+     */
+    fun cookieJar(cookieJar: CookieJar) = apply {
+      this.cookieJar = cookieJar
+    }
+
+    /** Sets the response cache to be used to read and write cached responses.  */
+    fun cache(cache: Cache?) = apply {
+      this.cache = cache
+      this.internalCache = null
+    }
+
+    /**
+     * Sets the DNS service used to lookup IP addresses for hostnames.
+     *
+     * If unset, the [system-wide default][Dns.SYSTEM] DNS will be used.
+     */
+    fun dns(dns: Dns) = apply {
+      this.dns = dns
+    }
+
+    /**
+     * Sets the socket factory used to create connections. OkHttp only uses the parameterless
+     * [SocketFactory.createSocket] method to create unconnected sockets. Overriding this method,
+     * e. g., allows the socket to be bound to a specific local address.
+     *
+     * If unset, the [system-wide default][SocketFactory.getDefault] socket factory will be used.
+     */
+    fun socketFactory(socketFactory: SocketFactory) = apply {
+      if (socketFactory is SSLSocketFactory) {
+        throw IllegalArgumentException("socketFactory instanceof SSLSocketFactory")
+      }
+      this.socketFactory = socketFactory
+    }
+
+    /**
+     * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
+     * be used.
+     *
+     * @deprecated [SSLSocketFactory] does not expose its [X509TrustManager], which is a field that
+     *     OkHttp needs to build a clean certificate chain. This method instead must use reflection
+     *     to extract the trust manager. Applications should prefer to call
+     *     `sslSocketFactory(SSLSocketFactory, X509TrustManager)`, which avoids such reflection.
+     */
+    @Deprecated(
+        message = "Use the sslSocketFactory overload that accepts a X509TrustManager.",
+        level = ERROR
+    )
+    fun sslSocketFactory(sslSocketFactory: SSLSocketFactory) = apply {
+      this.sslSocketFactory = sslSocketFactory
+      this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory)
+    }
+
+    /**
+     * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
+     * system defaults will be used.
+     *
+     * Most applications should not call this method, and instead use the system defaults. Those
+     * classes include special optimizations that can be lost if the implementations are decorated.
+     *
+     * If necessary, you can create and configure the defaults yourself with the following code:
+     *
+     * ```
+     * TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+     * TrustManagerFactory.getDefaultAlgorithm());
+     * trustManagerFactory.init((KeyStore) null);
+     * TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+     * if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+     *     throw new IllegalStateException("Unexpected default trust managers:"
+     *         + Arrays.toString(trustManagers));
+     * }
+     * X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
+     *
+     * SSLContext sslContext = SSLContext.getInstance("TLS");
+     * sslContext.init(null, new TrustManager[] { trustManager }, null);
+     * SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+     *
+     * OkHttpClient client = new OkHttpClient.Builder()
+     *     .sslSocketFactory(sslSocketFactory, trustManager)
+     *     .build();
+     * ```
+     */
+    fun sslSocketFactory(
+      sslSocketFactory: SSLSocketFactory,
+      trustManager: X509TrustManager
+    ) = apply {
+      this.sslSocketFactory = sslSocketFactory
+      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager)
+    }
+
+    /**
+     * Sets the verifier used to confirm that response certificates apply to requested hostnames for
+     * HTTPS connections.
+     *
+     * If unset, a default hostname verifier will be used.
+     */
+    fun hostnameVerifier(hostnameVerifier: HostnameVerifier) = apply {
+      this.hostnameVerifier = hostnameVerifier
+    }
+
+    /**
+     * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
+     * connections rely on only the [SSL socket factory][sslSocketFactory] to establish trust.
+     * Pinning certificates avoids the need to trust certificate authorities.
+     */
+    fun certificatePinner(certificatePinner: CertificatePinner) = apply {
+      this.certificatePinner = certificatePinner
+    }
+
+    /**
+     * Sets the authenticator used to respond to challenges from origin servers. Use
+     * [proxyAuthenticator] to set the authenticator for proxy servers.
+     *
+     * If unset, the [no authentication will be attempted][Authenticator.NONE].
+     */
+    fun authenticator(authenticator: Authenticator) = apply {
+      this.authenticator = authenticator
+    }
+
+    /**
+     * Sets the authenticator used to respond to challenges from proxy servers. Use [authenticator]
+     * to set the authenticator for origin servers.
+     *
+     * If unset, the [no authentication will be attempted][Authenticator.NONE].
+     */
+    fun proxyAuthenticator(proxyAuthenticator: Authenticator) = apply {
+      this.proxyAuthenticator = proxyAuthenticator
+    }
+
+    /**
+     * Sets the connection pool used to recycle HTTP and HTTPS connections.
+     *
+     * If unset, a new connection pool will be used.
+     */
+    fun connectionPool(connectionPool: ConnectionPool) = apply {
+      this.connectionPool = connectionPool
+    }
+
+    /**
+     * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
+     *
+     * If unset, protocol redirects will be followed. This is different than the built-in
+     * `HttpURLConnection`'s default.
+     */
+    fun followSslRedirects(followProtocolRedirects: Boolean) = apply {
+      this.followSslRedirects = followProtocolRedirects
+    }
+
+    /** Configure this client to follow redirects. If unset, redirects will be followed. */
+    fun followRedirects(followRedirects: Boolean) = apply {
+      this.followRedirects = followRedirects
+    }
+
+    /**
+     * Configure this client to retry or not when a connectivity problem is encountered. By default,
+     * this client silently recovers from the following problems:
+     *
+     * * **Unreachable IP addresses.** If the URL's host has multiple IP addresses,
+     *   failure to reach any individual IP address doesn't fail the overall request. This can
+     *   increase availability of multi-homed services.
+     *
+     * * **Stale pooled connections.** The [ConnectionPool] reuses sockets
+     *   to decrease request latency, but these connections will occasionally time out.
+     *
+     * * **Unreachable proxy servers.** A [ProxySelector] can be used to
+     *   attempt multiple proxy servers in sequence, eventually falling back to a direct
+     *   connection.
+     *
+     * Set this to false to avoid retrying requests when doing so is destructive. In this case the
+     * calling application should do its own recovery of connectivity failures.
+     */
+    fun retryOnConnectionFailure(retryOnConnectionFailure: Boolean) = apply {
+      this.retryOnConnectionFailure = retryOnConnectionFailure
+    }
+
+    /**
+     * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
+     */
+    fun dispatcher(dispatcher: Dispatcher) = apply {
+      this.dispatcher = dispatcher
+    }
+
+    /**
+     * Configure the protocols used by this client to communicate with remote servers. By default
+     * this client will prefer the most efficient transport available, falling back to more
+     * ubiquitous protocols. Applications should only call this method to avoid specific
+     * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
+     *
+     * The following protocols are currently supported:
+     *
+     * * [http/1.1][rfc_2616]
+     * * [h2][rfc_7540]
+     * * [h2 with prior knowledge(cleartext only)][rfc_7540_34]
+     *
+     * **This is an evolving set.** Future releases include support for transitional
+     * protocols. The http/1.1 transport will never be dropped.
+     *
+     * If multiple protocols are specified, [ALPN][alpn] will be used to negotiate a transport.
+     * Protocol negotiation is only attempted for HTTPS URLs.
+     *
+     * [Protocol.HTTP_1_0] is not supported in this set. Requests are initiated with `HTTP/1.1`. If
+     * the server responds with `HTTP/1.0`, that will be exposed by [Response.protocol].
+     *
+     * [alpn]: http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg
+     * [rfc_2616]: http://www.w3.org/Protocols/rfc2616/rfc2616.html
+     * [rfc_7540]: https://tools.ietf.org/html/rfc7540
+     * [rfc_7540_34]: https://tools.ietf.org/html/rfc7540#section-3.4
+     *
+     * @param protocols the protocols to use, in order of preference. If the list contains
+     *     [Protocol.H2_PRIOR_KNOWLEDGE] then that must be the only protocol and HTTPS URLs will not
+     *     be supported. Otherwise the list must contain [Protocol.HTTP_1_1]. The list must
+     *     not contain null or [Protocol.HTTP_1_0].
+     */
+    fun protocols(protocols: List<Protocol>) = apply {
+      // Create a private copy of the list.
+      val protocolsCopy = protocols.toMutableList()
+
+      // Validate that the list has everything we require and nothing we forbid.
+      require(Protocol.H2_PRIOR_KNOWLEDGE in protocolsCopy || Protocol.HTTP_1_1 in protocolsCopy) {
+        "protocols must contain h2_prior_knowledge or http/1.1: $protocolsCopy"
+      }
+      require(Protocol.H2_PRIOR_KNOWLEDGE !in protocolsCopy || protocolsCopy.size <= 1) {
+        "protocols containing h2_prior_knowledge cannot use other protocols: $protocolsCopy"
+      }
+      require(Protocol.HTTP_1_0 !in protocolsCopy) {
+        "protocols must not contain http/1.0: $protocolsCopy"
+      }
+      require(null !in (protocols as List<Protocol?>)) {
+        "protocols must not contain null"
+      }
+
+      // Remove protocolsCopy that we no longer support.
+      @Suppress("DEPRECATION")
+      protocolsCopy.remove(Protocol.SPDY_3)
+
+      // Assign as an unmodifiable list. This is effectively immutable.
+      this.protocols = Collections.unmodifiableList(protocols)
+    }
+
+    fun connectionSpecs(connectionSpecs: List<ConnectionSpec>) = apply {
+      this.connectionSpecs = Util.immutableList(connectionSpecs)
+    }
+
+    /**
+     * Returns a modifiable list of interceptors that observe the full span of each call: from
+     * before the connection is established (if any) until after the response source is selected
+     * (either the origin server, cache, or both).
+     */
+    fun interceptors(): MutableList<Interceptor> = interceptors
+
+    fun addInterceptor(interceptor: Interceptor) = apply {
+      interceptors += interceptor
+    }
+
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName("-deprecated_addInterceptor")
+    inline fun addInterceptor(
+      crossinline interceptor: (chain: Interceptor.Chain) -> Response
+    ) = apply {
+      addInterceptor(object : Interceptor {
+        override fun intercept(chain: Interceptor.Chain): Response = interceptor(chain)
+      })
+    }
+
+    /**
+     * Returns a modifiable list of interceptors that observe a single network request and response.
+     * These interceptors must call [Interceptor.Chain.proceed] exactly once: it is an error for a
+     * network interceptor to short-circuit or repeat a network request.
+     */
+    fun networkInterceptors(): MutableList<Interceptor> = networkInterceptors
+
+    fun addNetworkInterceptor(interceptor: Interceptor) = apply {
+      networkInterceptors += interceptor
+    }
+
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName("-deprecated_addNetworkInterceptor")
+    inline fun addNetworkInterceptor(
+      crossinline interceptor: (chain: Interceptor.Chain) -> Response
+    ) = apply {
+      addInterceptor(object : Interceptor {
+        override fun intercept(chain: Interceptor.Chain): Response = interceptor(chain)
+      })
+    }
+
+    /**
+     * Configure a single client scoped listener that will receive all analytic events for this
+     * client.
+     *
+     * @see EventListener for semantics and restrictions on listener implementations.
+     */
+    fun eventListener(eventListener: EventListener) = apply {
+      this.eventListenerFactory = Util.eventListenerFactory(eventListener)
+    }
+
+    /**
+     * Configure a factory to provide per-call scoped listeners that will receive analytic events
+     * for this client.
+     *
+     * @see EventListener for semantics and restrictions on listener implementations.
+     */
+    fun eventListenerFactory(eventListenerFactory: EventListener.Factory) = apply {
+      this.eventListenerFactory = eventListenerFactory
+    }
+
+    // This lambda conversion is for Kotlin callers expecting a Java SAM (single-abstract-method).
+    @JvmName("-deprecated_eventListenerFactory")
+    inline fun eventListenerFactory(crossinline block: (call: Call) -> EventListener) = apply {
+      eventListenerFactory(object : EventListener.Factory {
+        override fun create(call: Call) = block(call)
+      })
+    }
+
+    fun build(): OkHttpClient = OkHttpClient(this)
+  }
+
+  companion object {
+    internal val DEFAULT_PROTOCOLS = Util.immutableList(HTTP_2, HTTP_1_1)
+
+    internal val DEFAULT_CONNECTION_SPECS = Util.immutableList(
+        ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT)
+
+    init {
+      Internal.instance = object : Internal() {
+        override fun realConnectionPool(connectionPool: ConnectionPool) =
+            connectionPool.delegate
+
+        override fun equalsNonHost(a: Address, b: Address) = a.equalsNonHost(b)
+
+        override fun code(responseBuilder: Response.Builder) = responseBuilder.code
+
+        override fun newWebSocketCall(client: OkHttpClient, originalRequest: Request) =
+            RealCall.newRealCall(client, originalRequest, true)
+
+        override fun initExchange(responseBuilder: Response.Builder, exchange: Exchange) {
+          responseBuilder.initExchange(exchange)
+        }
+
+        override fun exchange(response: Response) = response.exchange
+      }
+    }
+
+    private fun newSslSocketFactory(trustManager: X509TrustManager): SSLSocketFactory {
+      try {
+        val sslContext = Platform.get().newSSLContext()
+        sslContext.init(null, arrayOf<TrustManager>(trustManager), null)
+        return sslContext.socketFactory
+      } catch (e: GeneralSecurityException) {
+        throw AssertionError("No System TLS", e) // The system has no TLS. Just give up.
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Protocol.java b/okhttp/src/main/java/okhttp3/Protocol.java
deleted file mode 100644
index a96070ed59..0000000000
--- a/okhttp/src/main/java/okhttp3/Protocol.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-
-/**
- * Protocols that OkHttp implements for <a
- * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> selection.
- *
- * <h3>Protocol vs Scheme</h3> Despite its name, {@link java.net.URL#getProtocol()} returns the
- * {@linkplain java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not the protocol
- * (http/1.1, spdy/3.1, etc.). OkHttp uses the word <i>protocol</i> to identify how HTTP messages
- * are framed.
- */
-public enum Protocol {
-  /**
-   * An obsolete plaintext framing that does not use persistent sockets by default.
-   */
-  HTTP_1_0("http/1.0"),
-
-  /**
-   * A plaintext framing that includes persistent connections.
-   *
-   * <p>This version of OkHttp implements <a href="https://tools.ietf.org/html/rfc7230">RFC
-   * 7230</a>, and tracks revisions to that spec.
-   */
-  HTTP_1_1("http/1.1"),
-
-  /**
-   * Chromium's binary-framed protocol that includes header compression, multiplexing multiple
-   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on SPDY/3.
-   *
-   * <p>Current versions of OkHttp do not support this protocol.
-   *
-   * @deprecated OkHttp has dropped support for SPDY. Prefer {@link #HTTP_2}.
-   */
-  SPDY_3("spdy/3.1"),
-
-  /**
-   * The IETF's binary-framed protocol that includes header compression, multiplexing multiple
-   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on HTTP/2.
-   *
-   * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support {@linkplain
-   * CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256} , present in Java 8+ and Android 5+. Servers
-   * that enforce this may send an exception message including the string {@code
-   * INADEQUATE_SECURITY}.
-   */
-  HTTP_2("h2"),
-
-  /**
-   * Cleartext HTTP/2 with no "upgrade" round trip. This option requires the client to have prior
-   * knowledge that the server supports cleartext HTTP/2.
-   *
-   * @see <a href="https://tools.ietf.org/html/rfc7540#section-3.4">Starting HTTP/2 with Prior
-   * Knowledge</a>
-   */
-  H2_PRIOR_KNOWLEDGE("h2_prior_knowledge"),
-
-  /**
-   * QUIC (Quick UDP Internet Connection) is a new multiplexed and secure transport atop UDP,
-   * designed from the ground up and optimized for HTTP/2 semantics.
-   * HTTP/1.1 semantics are layered on HTTP/2.
-   *
-   * <p>QUIC is not natively supported by OkHttp, but provided to allow a theoretical
-   * interceptor that provides support.
-   */
-  QUIC("quic");
-
-  private final String protocol;
-
-  Protocol(String protocol) {
-    this.protocol = protocol;
-  }
-
-  /**
-   * Returns the protocol identified by {@code protocol}.
-   *
-   * @throws IOException if {@code protocol} is unknown.
-   */
-  public static Protocol get(String protocol) throws IOException {
-    // Unroll the loop over values() to save an allocation.
-    if (protocol.equals(HTTP_1_0.protocol)) return HTTP_1_0;
-    if (protocol.equals(HTTP_1_1.protocol)) return HTTP_1_1;
-    if (protocol.equals(H2_PRIOR_KNOWLEDGE.protocol)) return H2_PRIOR_KNOWLEDGE;
-    if (protocol.equals(HTTP_2.protocol)) return HTTP_2;
-    if (protocol.equals(SPDY_3.protocol)) return SPDY_3;
-    if (protocol.equals(QUIC.protocol)) return QUIC;
-    throw new IOException("Unexpected protocol: " + protocol);
-  }
-
-  /**
-   * Returns the string used to identify this protocol for ALPN, like "http/1.1", "spdy/3.1" or
-   * "h2".
-   *
-   * @see <a href="https://www.iana.org/assignments/tls-extensiontype-values">IANA
-   * tls-extensiontype-values</a>
-   */
-  @Override public String toString() {
-    return protocol;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Protocol.kt b/okhttp/src/main/java/okhttp3/Protocol.kt
new file mode 100644
index 0000000000..466cdf463b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Protocol.kt
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.io.IOException
+
+/**
+ * Protocols that OkHttp implements for [ALPN][ietf_alpn] selection.
+ *
+ * ## Protocol vs Scheme
+ *
+ * Despite its name, [java.net.URL.getProtocol] returns the [scheme][java.net.URI.getScheme] (http,
+ * https, etc.) of the URL, not the protocol (http/1.1, spdy/3.1, etc.). OkHttp uses the word
+ * *protocol* to identify how HTTP messages are framed.
+ *
+ * [ietf_alpn]: http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg
+ */
+enum class Protocol(private val protocol: String) {
+  /**
+   * An obsolete plaintext framing that does not use persistent sockets by default.
+   */
+  HTTP_1_0("http/1.0"),
+
+  /**
+   * A plaintext framing that includes persistent connections.
+   *
+   * This version of OkHttp implements [RFC 7230][rfc_7230], and tracks revisions to that spec.
+   *
+   * [rfc_7230]: https://tools.ietf.org/html/rfc7230
+   */
+  HTTP_1_1("http/1.1"),
+
+  /**
+   * Chromium's binary-framed protocol that includes header compression, multiplexing multiple
+   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on SPDY/3.
+   *
+   * Current versions of OkHttp do not support this protocol.
+   */
+  @Deprecated("OkHttp has dropped support for SPDY. Prefer {@link #HTTP_2}.")
+  SPDY_3("spdy/3.1"),
+
+  /**
+   * The IETF's binary-framed protocol that includes header compression, multiplexing multiple
+   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on HTTP/2.
+   *
+   * HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support
+   * [CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256], present in Java 8+ and Android 5+.
+   * Servers that enforce this may send an exception message including the string
+   * `INADEQUATE_SECURITY`.
+   */
+  HTTP_2("h2"),
+
+  /**
+   * Cleartext HTTP/2 with no "upgrade" round trip. This option requires the client to have prior
+   * knowledge that the server supports cleartext HTTP/2.
+   *
+   * See also [Starting HTTP/2 with Prior Knowledge][rfc_7540_34].
+   *
+   * [rfc_7540_34]: https://tools.ietf.org/html/rfc7540.section-3.4
+   */
+  H2_PRIOR_KNOWLEDGE("h2_prior_knowledge"),
+
+  /**
+   * QUIC (Quick UDP Internet Connection) is a new multiplexed and secure transport atop UDP,
+   * designed from the ground up and optimized for HTTP/2 semantics. HTTP/1.1 semantics are layered
+   * on HTTP/2.
+   *
+   * QUIC is not natively supported by OkHttp, but provided to allow a theoretical interceptor that
+   * provides support.
+   */
+  QUIC("quic");
+
+  /**
+   * Returns the string used to identify this protocol for ALPN, like "http/1.1", "spdy/3.1" or
+   * "h2".
+   *
+   * See also [IANA tls-extensiontype-values][iana].
+   *
+   * [iana]: https://www.iana.org/assignments/tls-extensiontype-values
+   */
+  override fun toString() = protocol
+
+  companion object {
+    /**
+     * Returns the protocol identified by `protocol`.
+     *
+     * @throws IOException if `protocol` is unknown.
+     */
+    @JvmStatic
+    @Throws(IOException::class)
+    fun get(protocol: String): Protocol {
+      // Unroll the loop over values() to save an allocation.
+      @Suppress("DEPRECATION")
+      return when (protocol) {
+        HTTP_1_0.protocol -> HTTP_1_0
+        HTTP_1_1.protocol -> HTTP_1_1
+        H2_PRIOR_KNOWLEDGE.protocol -> H2_PRIOR_KNOWLEDGE
+        HTTP_2.protocol -> HTTP_2
+        SPDY_3.protocol -> SPDY_3
+        QUIC.protocol -> QUIC
+        else -> throw IOException("Unexpected protocol: $protocol")
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
deleted file mode 100644
index dd155e74f5..0000000000
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.RejectedExecutionException;
-import javax.annotation.Nullable;
-import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.cache.CacheInterceptor;
-import okhttp3.internal.connection.ConnectInterceptor;
-import okhttp3.internal.connection.StreamAllocation;
-import okhttp3.internal.http.BridgeInterceptor;
-import okhttp3.internal.http.CallServerInterceptor;
-import okhttp3.internal.http.RealInterceptorChain;
-import okhttp3.internal.http.RetryAndFollowUpInterceptor;
-import okhttp3.internal.platform.Platform;
-import okio.AsyncTimeout;
-import okio.Timeout;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static okhttp3.internal.platform.Platform.INFO;
-
-final class RealCall implements Call {
-  final OkHttpClient client;
-  final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
-  final AsyncTimeout timeout;
-
-  /**
-   * There is a cycle between the {@link Call} and {@link EventListener} that makes this awkward.
-   * This will be set after we create the call instance then create the event listener instance.
-   */
-  private @Nullable EventListener eventListener;
-
-  /** The application's original request unadulterated by redirects or auth headers. */
-  final Request originalRequest;
-  final boolean forWebSocket;
-
-  // Guarded by this.
-  private boolean executed;
-
-  private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
-    this.client = client;
-    this.originalRequest = originalRequest;
-    this.forWebSocket = forWebSocket;
-    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client);
-    this.timeout = new AsyncTimeout() {
-      @Override protected void timedOut() {
-        cancel();
-      }
-    };
-    this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);
-  }
-
-  static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
-    // Safely publish the Call instance to the EventListener.
-    RealCall call = new RealCall(client, originalRequest, forWebSocket);
-    call.eventListener = client.eventListenerFactory().create(call);
-    return call;
-  }
-
-  @Override public Request request() {
-    return originalRequest;
-  }
-
-  @Override public Response execute() throws IOException {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
-      executed = true;
-    }
-    captureCallStackTrace();
-    timeout.enter();
-    eventListener.callStart(this);
-    try {
-      client.dispatcher().executed(this);
-      Response result = getResponseWithInterceptorChain();
-      if (result == null) throw new IOException("Canceled");
-      return result;
-    } catch (IOException e) {
-      e = timeoutExit(e);
-      eventListener.callFailed(this, e);
-      throw e;
-    } finally {
-      client.dispatcher().finished(this);
-    }
-  }
-
-  @Nullable IOException timeoutExit(@Nullable IOException cause) {
-    if (!timeout.exit()) return cause;
-
-    InterruptedIOException e = new InterruptedIOException("timeout");
-    if (cause != null) {
-      e.initCause(cause);
-    }
-    return e;
-  }
-
-  private void captureCallStackTrace() {
-    Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
-    retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
-  }
-
-  @Override public void enqueue(Callback responseCallback) {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
-      executed = true;
-    }
-    captureCallStackTrace();
-    eventListener.callStart(this);
-    client.dispatcher().enqueue(new AsyncCall(responseCallback));
-  }
-
-  @Override public void cancel() {
-    retryAndFollowUpInterceptor.cancel();
-  }
-
-  @Override public Timeout timeout() {
-    return timeout;
-  }
-
-  @Override public synchronized boolean isExecuted() {
-    return executed;
-  }
-
-  @Override public boolean isCanceled() {
-    return retryAndFollowUpInterceptor.isCanceled();
-  }
-
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public RealCall clone() {
-    return RealCall.newRealCall(client, originalRequest, forWebSocket);
-  }
-
-  StreamAllocation streamAllocation() {
-    return retryAndFollowUpInterceptor.streamAllocation();
-  }
-
-  final class AsyncCall extends NamedRunnable {
-    private final Callback responseCallback;
-
-    AsyncCall(Callback responseCallback) {
-      super("OkHttp %s", redactedUrl());
-      this.responseCallback = responseCallback;
-    }
-
-    String host() {
-      return originalRequest.url().host();
-    }
-
-    Request request() {
-      return originalRequest;
-    }
-
-    RealCall get() {
-      return RealCall.this;
-    }
-
-    /**
-     * Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up
-     * if the executor has been shut down by reporting the call as failed.
-     */
-    void executeOn(ExecutorService executorService) {
-      assert (!Thread.holdsLock(client.dispatcher()));
-      boolean success = false;
-      try {
-        executorService.execute(this);
-        success = true;
-      } catch (RejectedExecutionException e) {
-        InterruptedIOException ioException = new InterruptedIOException("executor rejected");
-        ioException.initCause(e);
-        eventListener.callFailed(RealCall.this, ioException);
-        responseCallback.onFailure(RealCall.this, ioException);
-      } finally {
-        if (!success) {
-          client.dispatcher().finished(this); // This call is no longer running!
-        }
-      }
-    }
-
-    @Override protected void execute() {
-      boolean signalledCallback = false;
-      timeout.enter();
-      try {
-        Response response = getResponseWithInterceptorChain();
-        if (retryAndFollowUpInterceptor.isCanceled()) {
-          signalledCallback = true;
-          responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
-        } else {
-          signalledCallback = true;
-          responseCallback.onResponse(RealCall.this, response);
-        }
-      } catch (IOException e) {
-        e = timeoutExit(e);
-        if (signalledCallback) {
-          // Do not signal the callback twice!
-          Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
-        } else {
-          eventListener.callFailed(RealCall.this, e);
-          responseCallback.onFailure(RealCall.this, e);
-        }
-      } finally {
-        client.dispatcher().finished(this);
-      }
-    }
-  }
-
-  /**
-   * Returns a string that describes this call. Doesn't include a full URL as that might contain
-   * sensitive information.
-   */
-  String toLoggableString() {
-    return (isCanceled() ? "canceled " : "")
-        + (forWebSocket ? "web socket" : "call")
-        + " to " + redactedUrl();
-  }
-
-  String redactedUrl() {
-    return originalRequest.url().redact();
-  }
-
-  Response getResponseWithInterceptorChain() throws IOException {
-    // Build a full stack of interceptors.
-    List<Interceptor> interceptors = new ArrayList<>();
-    interceptors.addAll(client.interceptors());
-    interceptors.add(retryAndFollowUpInterceptor);
-    interceptors.add(new BridgeInterceptor(client.cookieJar()));
-    interceptors.add(new CacheInterceptor(client.internalCache()));
-    interceptors.add(new ConnectInterceptor(client));
-    if (!forWebSocket) {
-      interceptors.addAll(client.networkInterceptors());
-    }
-    interceptors.add(new CallServerInterceptor(forWebSocket));
-
-    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
-        originalRequest, this, eventListener, client.connectTimeoutMillis(),
-        client.readTimeoutMillis(), client.writeTimeoutMillis());
-
-    return chain.proceed(originalRequest);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/RealCall.kt b/okhttp/src/main/java/okhttp3/RealCall.kt
new file mode 100644
index 0000000000..7950927a6b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/RealCall.kt
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.NamedRunnable
+import okhttp3.internal.Util.closeQuietly
+import okhttp3.internal.cache.CacheInterceptor
+import okhttp3.internal.connection.ConnectInterceptor
+import okhttp3.internal.connection.Transmitter
+import okhttp3.internal.http.BridgeInterceptor
+import okhttp3.internal.http.CallServerInterceptor
+import okhttp3.internal.http.RealInterceptorChain
+import okhttp3.internal.http.RetryAndFollowUpInterceptor
+import okhttp3.internal.platform.Platform
+import okhttp3.internal.platform.Platform.Companion.INFO
+import okio.Timeout
+import java.io.IOException
+import java.io.InterruptedIOException
+import java.util.ArrayList
+import java.util.concurrent.ExecutorService
+import java.util.concurrent.RejectedExecutionException
+import java.util.concurrent.atomic.AtomicInteger
+
+internal class RealCall private constructor(
+  val client: OkHttpClient,
+  /** The application's original request unadulterated by redirects or auth headers.  */
+  val originalRequest: Request,
+  val forWebSocket: Boolean
+) : Call {
+  /**
+   * There is a cycle between the [Call] and [Transmitter] that makes this awkward.
+   * This is set after immediately after creating the call instance.
+   */
+  private lateinit var transmitter: Transmitter
+
+  // Guarded by this.
+  var executed: Boolean = false
+
+  @Synchronized override fun isExecuted(): Boolean = executed
+
+  override fun isCanceled(): Boolean = transmitter.isCanceled
+
+  override fun request(): Request = originalRequest
+
+  override fun execute(): Response {
+    synchronized(this) {
+      check(!executed) { "Already Executed" }
+      executed = true
+    }
+    transmitter.timeoutEnter()
+    transmitter.callStart()
+    try {
+      client.dispatcher().executed(this)
+      return getResponseWithInterceptorChain()
+    } finally {
+      client.dispatcher().finished(this)
+    }
+  }
+
+  override fun enqueue(responseCallback: Callback) {
+    synchronized(this) {
+      check(!executed) { "Already Executed" }
+      executed = true
+    }
+    transmitter.callStart()
+    client.dispatcher().enqueue(AsyncCall(responseCallback))
+  }
+
+  override fun cancel() {
+    transmitter.cancel()
+  }
+
+  override fun timeout(): Timeout = transmitter.timeout()
+
+  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+  override fun clone(): RealCall {
+    return RealCall.newRealCall(client, originalRequest, forWebSocket)
+  }
+
+  internal inner class AsyncCall(
+    private val responseCallback: Callback
+  ) : NamedRunnable("OkHttp %s", redactedUrl()) {
+    @Volatile private var callsPerHost = AtomicInteger(0)
+
+    fun callsPerHost(): AtomicInteger = callsPerHost
+
+    fun reuseCallsPerHostFrom(other: AsyncCall) {
+      this.callsPerHost = other.callsPerHost
+    }
+
+    fun host(): String = originalRequest.url().host()
+
+    fun request(): Request = originalRequest
+
+    fun get(): RealCall = this@RealCall
+
+    /**
+     * Attempt to enqueue this async call on `executorService`. This will attempt to clean up
+     * if the executor has been shut down by reporting the call as failed.
+     */
+    fun executeOn(executorService: ExecutorService) {
+      assert(!Thread.holdsLock(client.dispatcher()))
+      var success = false
+      try {
+        executorService.execute(this)
+        success = true
+      } catch (e: RejectedExecutionException) {
+        val ioException = InterruptedIOException("executor rejected")
+        ioException.initCause(e)
+        transmitter.noMoreExchanges(ioException)
+        responseCallback.onFailure(this@RealCall, ioException)
+      } finally {
+        if (!success) {
+          client.dispatcher().finished(this) // This call is no longer running!
+        }
+      }
+    }
+
+    override fun execute() {
+      var signalledCallback = false
+      transmitter.timeoutEnter()
+      try {
+        val response = getResponseWithInterceptorChain()
+        signalledCallback = true
+        responseCallback.onResponse(this@RealCall, response)
+      } catch (e: IOException) {
+        if (signalledCallback) {
+          // Do not signal the callback twice!
+          Platform.get().log(INFO, "Callback failure for ${toLoggableString()}", e)
+        } else {
+          responseCallback.onFailure(this@RealCall, e)
+        }
+      } finally {
+        client.dispatcher().finished(this)
+      }
+    }
+  }
+
+  /**
+   * Returns a string that describes this call. Doesn't include a full URL as that might contain
+   * sensitive information.
+   */
+  fun toLoggableString(): String {
+    return ((if (isCanceled()) "canceled " else "") +
+        (if (forWebSocket) "web socket" else "call") +
+        " to " + redactedUrl())
+  }
+
+  fun redactedUrl(): String = originalRequest.url().redact()
+
+  @Throws(IOException::class)
+  fun getResponseWithInterceptorChain(): Response {
+    // Build a full stack of interceptors.
+    val interceptors = ArrayList<Interceptor>()
+    interceptors.addAll(client.interceptors())
+    interceptors.add(RetryAndFollowUpInterceptor(client))
+    interceptors.add(BridgeInterceptor(client.cookieJar()))
+    interceptors.add(CacheInterceptor(client.internalCache()))
+    interceptors.add(ConnectInterceptor(client))
+    if (!forWebSocket) {
+      interceptors.addAll(client.networkInterceptors())
+    }
+    interceptors.add(CallServerInterceptor(forWebSocket))
+
+    val chain = RealInterceptorChain(interceptors, transmitter, null, 0,
+        originalRequest, this, client.connectTimeoutMillis(),
+        client.readTimeoutMillis(), client.writeTimeoutMillis())
+
+    var calledNoMoreExchanges = false
+    try {
+      val response = chain.proceed(originalRequest)
+      if (transmitter.isCanceled) {
+        closeQuietly(response)
+        throw IOException("Canceled")
+      }
+      return response
+    } catch (e: IOException) {
+      calledNoMoreExchanges = true
+      throw transmitter.noMoreExchanges(e) as Throwable
+    } finally {
+      if (!calledNoMoreExchanges) {
+        transmitter.noMoreExchanges(null)
+      }
+    }
+  }
+
+  companion object {
+    fun newRealCall(
+      client: OkHttpClient,
+      originalRequest: Request,
+      forWebSocket: Boolean
+    ): RealCall {
+      // Safely publish the Call instance to the EventListener.
+      return RealCall(client, originalRequest, forWebSocket).apply {
+        transmitter = Transmitter(client, this)
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
deleted file mode 100644
index 9bbdc86407..0000000000
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.URL;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpMethod;
-
-/**
- * An HTTP request. Instances of this class are immutable if their {@link #body} is null or itself
- * immutable.
- */
-public final class Request {
-  final HttpUrl url;
-  final String method;
-  final Headers headers;
-  final @Nullable RequestBody body;
-  final Map<Class<?>, Object> tags;
-
-  private volatile @Nullable CacheControl cacheControl; // Lazily initialized.
-
-  Request(Builder builder) {
-    this.url = builder.url;
-    this.method = builder.method;
-    this.headers = builder.headers.build();
-    this.body = builder.body;
-    this.tags = Util.immutableMap(builder.tags);
-  }
-
-  public HttpUrl url() {
-    return url;
-  }
-
-  public String method() {
-    return method;
-  }
-
-  public Headers headers() {
-    return headers;
-  }
-
-  public @Nullable String header(String name) {
-    return headers.get(name);
-  }
-
-  public List<String> headers(String name) {
-    return headers.values(name);
-  }
-
-  public @Nullable RequestBody body() {
-    return body;
-  }
-
-  /**
-   * Returns the tag attached with {@code Object.class} as a key, or null if no tag is attached with
-   * that key.
-   *
-   * <p>Prior to OkHttp 3.11, this method never returned null if no tag was attached. Instead it
-   * returned either this request, or the request upon which this request was derived with {@link
-   * #newBuilder()}.
-   */
-  public @Nullable Object tag() {
-    return tag(Object.class);
-  }
-
-  /**
-   * Returns the tag attached with {@code type} as a key, or null if no tag is attached with that
-   * key.
-   */
-  public @Nullable <T> T tag(Class<? extends T> type) {
-    return type.cast(tags.get(type));
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  /**
-   * Returns the cache control directives for this response. This is never null, even if this
-   * response contains no {@code Cache-Control} header.
-   */
-  public CacheControl cacheControl() {
-    CacheControl result = cacheControl;
-    return result != null ? result : (cacheControl = CacheControl.parse(headers));
-  }
-
-  public boolean isHttps() {
-    return url.isHttps();
-  }
-
-  @Override public String toString() {
-    return "Request{method="
-        + method
-        + ", url="
-        + url
-        + ", tags="
-        + tags
-        + '}';
-  }
-
-  public static class Builder {
-    @Nullable HttpUrl url;
-    String method;
-    Headers.Builder headers;
-    @Nullable RequestBody body;
-
-    /** A mutable map of tags, or an immutable empty map if we don't have any. */
-    Map<Class<?>, Object> tags = Collections.emptyMap();
-
-    public Builder() {
-      this.method = "GET";
-      this.headers = new Headers.Builder();
-    }
-
-    Builder(Request request) {
-      this.url = request.url;
-      this.method = request.method;
-      this.body = request.body;
-      this.tags = request.tags.isEmpty()
-          ? Collections.emptyMap()
-          : new LinkedHashMap<>(request.tags);
-      this.headers = request.headers.newBuilder();
-    }
-
-    public Builder url(HttpUrl url) {
-      if (url == null) throw new NullPointerException("url == null");
-      this.url = url;
-      return this;
-    }
-
-    /**
-     * Sets the URL target of this request.
-     *
-     * @throws IllegalArgumentException if {@code url} is not a valid HTTP or HTTPS URL. Avoid this
-     * exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs.
-     */
-    public Builder url(String url) {
-      if (url == null) throw new NullPointerException("url == null");
-
-      // Silently replace web socket URLs with HTTP URLs.
-      if (url.regionMatches(true, 0, "ws:", 0, 3)) {
-        url = "http:" + url.substring(3);
-      } else if (url.regionMatches(true, 0, "wss:", 0, 4)) {
-        url = "https:" + url.substring(4);
-      }
-
-      return url(HttpUrl.get(url));
-    }
-
-    /**
-     * Sets the URL target of this request.
-     *
-     * @throws IllegalArgumentException if the scheme of {@code url} is not {@code http} or {@code
-     * https}.
-     */
-    public Builder url(URL url) {
-      if (url == null) throw new NullPointerException("url == null");
-      return url(HttpUrl.get(url.toString()));
-    }
-
-    /**
-     * Sets the header named {@code name} to {@code value}. If this request already has any headers
-     * with that name, they are all replaced.
-     */
-    public Builder header(String name, String value) {
-      headers.set(name, value);
-      return this;
-    }
-
-    /**
-     * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
-     * headers like "Cookie".
-     *
-     * <p>Note that for some headers including {@code Content-Length} and {@code Content-Encoding},
-     * OkHttp may replace {@code value} with a header derived from the request body.
-     */
-    public Builder addHeader(String name, String value) {
-      headers.add(name, value);
-      return this;
-    }
-
-    /** Removes all headers named {@code name} on this builder. */
-    public Builder removeHeader(String name) {
-      headers.removeAll(name);
-      return this;
-    }
-
-    /** Removes all headers on this builder and adds {@code headers}. */
-    public Builder headers(Headers headers) {
-      this.headers = headers.newBuilder();
-      return this;
-    }
-
-    /**
-     * Sets this request's {@code Cache-Control} header, replacing any cache control headers already
-     * present. If {@code cacheControl} doesn't define any directives, this clears this request's
-     * cache-control headers.
-     */
-    public Builder cacheControl(CacheControl cacheControl) {
-      String value = cacheControl.toString();
-      if (value.isEmpty()) return removeHeader("Cache-Control");
-      return header("Cache-Control", value);
-    }
-
-    public Builder get() {
-      return method("GET", null);
-    }
-
-    public Builder head() {
-      return method("HEAD", null);
-    }
-
-    public Builder post(RequestBody body) {
-      return method("POST", body);
-    }
-
-    public Builder delete(@Nullable RequestBody body) {
-      return method("DELETE", body);
-    }
-
-    public Builder delete() {
-      return delete(Util.EMPTY_REQUEST);
-    }
-
-    public Builder put(RequestBody body) {
-      return method("PUT", body);
-    }
-
-    public Builder patch(RequestBody body) {
-      return method("PATCH", body);
-    }
-
-    public Builder method(String method, @Nullable RequestBody body) {
-      if (method == null) throw new NullPointerException("method == null");
-      if (method.length() == 0) throw new IllegalArgumentException("method.length() == 0");
-      if (body != null && !HttpMethod.permitsRequestBody(method)) {
-        throw new IllegalArgumentException("method " + method + " must not have a request body.");
-      }
-      if (body == null && HttpMethod.requiresRequestBody(method)) {
-        throw new IllegalArgumentException("method " + method + " must have a request body.");
-      }
-      this.method = method;
-      this.body = body;
-      return this;
-    }
-
-    /** Attaches {@code tag} to the request using {@code Object.class} as a key. */
-    public Builder tag(@Nullable Object tag) {
-      return tag(Object.class, tag);
-    }
-
-    /**
-     * Attaches {@code tag} to the request using {@code type} as a key. Tags can be read from a
-     * request using {@link Request#tag}. Use null to remove any existing tag assigned for {@code
-     * type}.
-     *
-     * <p>Use this API to attach timing, debugging, or other application data to a request so that
-     * you may read it in interceptors, event listeners, or callbacks.
-     */
-    public <T> Builder tag(Class<? super T> type, @Nullable T tag) {
-      if (type == null) throw new NullPointerException("type == null");
-
-      if (tag == null) {
-        tags.remove(type);
-      } else {
-        if (tags.isEmpty()) tags = new LinkedHashMap<>();
-        tags.put(type, type.cast(tag));
-      }
-
-      return this;
-    }
-
-    public Request build() {
-      if (url == null) throw new IllegalStateException("url == null");
-      return new Request(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Request.kt b/okhttp/src/main/java/okhttp3/Request.kt
new file mode 100644
index 0000000000..244bd86aef
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Request.kt
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.Util
+import okhttp3.internal.http.HttpMethod
+import java.net.URL
+
+/**
+ * An HTTP request. Instances of this class are immutable if their [body] is null or itself
+ * immutable.
+ */
+class Request internal constructor(
+  internal val url: HttpUrl,
+  builder: Builder
+) {
+  internal val method: String = builder.method
+  internal val headers: Headers = builder.headers.build()
+  internal val body: RequestBody? = builder.body
+  internal val tags: Map<Class<*>, Any> = Util.immutableMap(builder.tags)
+
+  @Volatile
+  private var cacheControl: CacheControl? = null // Lazily initialized
+
+  val isHttps: Boolean
+    get() = url.isHttps
+
+  fun url(): HttpUrl = url
+
+  fun method(): String = method
+
+  fun headers(): Headers = headers
+
+  fun header(name: String): String? = headers[name]
+
+  fun headers(name: String): List<String> = headers.values(name)
+
+  fun body(): RequestBody? = body
+
+  /**
+   * Returns the tag attached with `Object.class` as a key, or null if no tag is attached with
+   * that key.
+   *
+   * Prior to OkHttp 3.11, this method never returned null if no tag was attached. Instead it
+   * returned either this request, or the request upon which this request was derived with
+   * [newBuilder].
+   */
+  fun tag(): Any? = tag(Any::class.java)
+
+  /**
+   * Returns the tag attached with [type] as a key, or null if no tag is attached with that
+   * key.
+   */
+  fun <T> tag(type: Class<out T>): T? = type.cast(tags[type])
+
+  fun newBuilder(): Builder = Builder(this)
+
+  /**
+   * Returns the cache control directives for this response. This is never null, even if this
+   * response contains no `Cache-Control` header.
+   */
+  fun cacheControl(): CacheControl {
+    return cacheControl ?: CacheControl.parse(headers).also {
+      this.cacheControl = it
+    }
+  }
+
+  override fun toString(): String = "Request{method=$method, url=$url, tags=$tags}"
+
+  open class Builder {
+    internal var url: HttpUrl? = null
+    internal var method: String
+    internal var headers: Headers.Builder
+    internal var body: RequestBody? = null
+
+    /** A mutable map of tags, or an immutable empty map if we don't have any. */
+    internal var tags: MutableMap<Class<*>, Any> = mutableMapOf()
+
+    constructor() {
+      this.method = "GET"
+      this.headers = Headers.Builder()
+    }
+
+    internal constructor(request: Request) {
+      this.url = request.url
+      this.method = request.method
+      this.body = request.body
+      this.tags = if (request.tags.isEmpty()) {
+        mutableMapOf()
+      } else {
+        request.tags.toMutableMap()
+      }
+      this.headers = request.headers.newBuilder()
+    }
+
+    open fun url(url: HttpUrl): Builder = apply {
+      this.url = url
+    }
+
+    /**
+     * Sets the URL target of this request.
+     *
+     * @throws IllegalArgumentException if [url] is not a valid HTTP or HTTPS URL. Avoid this
+     *     exception by calling [HttpUrl.parse]; it returns null for invalid URLs.
+     */
+    open fun url(url: String): Builder {
+      // Silently replace web socket URLs with HTTP URLs.
+      val finalUrl: String = when {
+        url.regionMatches(0, "ws:", 0, 3, ignoreCase = true) -> {
+          "http:${url.substring(3)}"
+        }
+        url.regionMatches(0, "wss:", 0, 4, ignoreCase = true) -> {
+          "https:${url.substring(4)}"
+        }
+        else -> url
+      }
+
+      return url(HttpUrl.get(finalUrl))
+    }
+
+    /**
+     * Sets the URL target of this request.
+     *
+     * @throws IllegalArgumentException if the scheme of [url] is not `http` or `https`.
+     */
+    open fun url(url: URL) = url(HttpUrl.get(url.toString()))
+
+    /**
+     * Sets the header named [name] to [value]. If this request already has any headers
+     * with that name, they are all replaced.
+     */
+    open fun header(name: String, value: String) = apply {
+      headers[name] = value
+    }
+
+    /**
+     * Adds a header with [name] and [value]. Prefer this method for multiply-valued
+     * headers like "Cookie".
+     *
+     * Note that for some headers including `Content-Length` and `Content-Encoding`,
+     * OkHttp may replace [value] with a header derived from the request body.
+     */
+    open fun addHeader(name: String, value: String) = apply {
+      headers.add(name, value)
+    }
+
+    /** Removes all headers named [name] on this builder. */
+    open fun removeHeader(name: String) = apply {
+      headers.removeAll(name)
+    }
+
+    /** Removes all headers on this builder and adds [headers]. */
+    open fun headers(headers: Headers) = apply {
+      this.headers = headers.newBuilder()
+    }
+
+    /**
+     * Sets this request's `Cache-Control` header, replacing any cache control headers already
+     * present. If [cacheControl] doesn't define any directives, this clears this request's
+     * cache-control headers.
+     */
+    open fun cacheControl(cacheControl: CacheControl): Builder {
+      val value = cacheControl.toString()
+      return when {
+        value.isEmpty() -> removeHeader("Cache-Control")
+        else -> header("Cache-Control", value)
+      }
+    }
+
+    open fun get() = method("GET", null)
+
+    open fun head() = method("HEAD", null)
+
+    open fun post(body: RequestBody) = method("POST", body)
+
+    @JvmOverloads
+    open fun delete(body: RequestBody? = Util.EMPTY_REQUEST) = method("DELETE", body)
+
+    open fun put(body: RequestBody) = method("PUT", body)
+
+    open fun patch(body: RequestBody) = method("PATCH", body)
+
+    open fun method(method: String, body: RequestBody?): Builder = apply {
+      require(method.isNotEmpty()) {
+        "method.isEmpty() == true"
+      }
+      if (body == null) {
+        require(!HttpMethod.requiresRequestBody(method)) {
+          "method $method must have a request body."
+        }
+      } else {
+        require(HttpMethod.permitsRequestBody(method)) {
+          "method $method must not have a request body."
+        }
+      }
+      this.method = method
+      this.body = body
+    }
+
+    /** Attaches [tag] to the request using `Object.class` as a key. */
+    open fun tag(tag: Any?): Builder = tag(Any::class.java, tag)
+
+    /**
+     * Attaches [tag] to the request using [type] as a key. Tags can be read from a
+     * request using [Request.tag]. Use null to remove any existing tag assigned for [type].
+     *
+     * Use this API to attach timing, debugging, or other application data to a request so that
+     * you may read it in interceptors, event listeners, or callbacks.
+     */
+    open fun <T> tag(type: Class<in T>, tag: T?) = apply {
+      if (tag == null) {
+        tags.remove(type)
+      } else {
+        if (tags.isEmpty()) {
+          tags = mutableMapOf()
+        }
+        tags[type] = type.cast(tag)!! // Force-unwrap due to lack of contracts on Class#cast()
+      }
+    }
+
+    open fun build(): Request = Request(
+        checkNotNull(url) { "url == null" },
+        this
+    )
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/RequestBody.java b/okhttp/src/main/java/okhttp3/RequestBody.java
deleted file mode 100644
index c0279f3081..0000000000
--- a/okhttp/src/main/java/okhttp3/RequestBody.java
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.File;
-import java.io.IOException;
-import java.nio.charset.Charset;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okio.BufferedSink;
-import okio.ByteString;
-import okio.Okio;
-import okio.Source;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-public abstract class RequestBody {
-  /** Returns the Content-Type header for this body. */
-  public abstract @Nullable MediaType contentType();
-
-  /**
-   * Returns the number of bytes that will be written to {@code sink} in a call to {@link #writeTo},
-   * or -1 if that count is unknown.
-   */
-  public long contentLength() throws IOException {
-    return -1;
-  }
-
-  /** Writes the content of this request to {@code sink}. */
-  public abstract void writeTo(BufferedSink sink) throws IOException;
-
-  /**
-   * Returns a new request body that transmits {@code content}. If {@code contentType} is non-null
-   * and lacks a charset, this will use UTF-8.
-   */
-  public static RequestBody create(@Nullable MediaType contentType, String content) {
-    Charset charset = UTF_8;
-    if (contentType != null) {
-      charset = contentType.charset();
-      if (charset == null) {
-        charset = UTF_8;
-        contentType = MediaType.parse(contentType + "; charset=utf-8");
-      }
-    }
-    byte[] bytes = content.getBytes(charset);
-    return create(contentType, bytes);
-  }
-
-  /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(
-      final @Nullable MediaType contentType, final ByteString content) {
-    return new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() throws IOException {
-        return content.size();
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.write(content);
-      }
-    };
-  }
-
-  /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final @Nullable MediaType contentType, final byte[] content) {
-    return create(contentType, content, 0, content.length);
-  }
-
-  /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final @Nullable MediaType contentType, final byte[] content,
-      final int offset, final int byteCount) {
-    if (content == null) throw new NullPointerException("content == null");
-    Util.checkOffsetAndCount(content.length, offset, byteCount);
-    return new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() {
-        return byteCount;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.write(content, offset, byteCount);
-      }
-    };
-  }
-
-  /** Returns a new request body that transmits the content of {@code file}. */
-  public static RequestBody create(final @Nullable MediaType contentType, final File file) {
-    if (file == null) throw new NullPointerException("file == null");
-
-    return new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() {
-        return file.length();
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        try (Source source = Okio.source(file)) {
-          sink.writeAll(source);
-        }
-      }
-    };
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/RequestBody.kt b/okhttp/src/main/java/okhttp3/RequestBody.kt
new file mode 100644
index 0000000000..cd3def54ce
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/RequestBody.kt
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.Util
+import okio.BufferedSink
+import okio.ByteString
+import okio.source
+import java.io.File
+import java.io.IOException
+import java.nio.charset.Charset
+import kotlin.text.Charsets.UTF_8
+
+abstract class RequestBody {
+
+  /** Returns the Content-Type header for this body. */
+  abstract fun contentType(): MediaType?
+
+  /**
+   * Returns the number of bytes that will be written to sink in a call to [writeTo],
+   * or -1 if that count is unknown.
+   */
+  @Throws(IOException::class)
+  open fun contentLength(): Long = -1
+
+  /** Writes the content of this request to [sink]. */
+  @Throws(IOException::class)
+  abstract fun writeTo(sink: BufferedSink)
+
+  /**
+   * A duplex request body is special in how it is **transmitted** on the network and
+   * in the **API contract** between OkHttp and the application.
+   *
+   * This method returns false unless it is overridden by a subclass.
+   *
+   * ### Duplex Transmission
+   *
+   * With regular HTTP calls the request always completes sending before the response may begin
+   * receiving. With duplex the request and response may be interleaved! That is, request body bytes
+   * may be sent after response headers or body bytes have been received.
+   *
+   * Though any call may be initiated as a duplex call, only web servers that are specially
+   * designed for this nonstandard interaction will use it. As of 2019-01, the only widely-used
+   * implementation of this pattern is [gRPC][grpc].
+   *
+   * Because the encoding of interleaved data is not well-defined for HTTP/1, duplex request
+   * bodies may only be used with HTTP/2. Calls to HTTP/1 servers will fail before the HTTP request
+   * is transmitted. If you cannot ensure that your client and server both support HTTP/2, do not
+   * use this feature.
+   *
+   * ### Duplex APIs
+   *
+   * With regular request bodies it is not legal to write bytes to the sink passed to
+   * [RequestBody.writeTo] after that method returns. For duplex requests bodies that condition is
+   * lifted. Such writes occur on an application-provided thread and may occur concurrently with
+   * reads of the [ResponseBody]. For duplex request bodies, [writeTo] should return
+   * quickly, possibly by handing off the provided request body to another thread to perform
+   * writing.
+   *
+   * [grpc]: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md
+   */
+  open fun isDuplex(): Boolean = false
+
+  /**
+   * Returns true if this body expects at most one call to [writeTo] and can be transmitted
+   * at most once. This is typically used when writing the request body is destructive and it is not
+   * possible to recreate the request body after it has been sent.
+   *
+   * This method returns false unless it is overridden by a subclass.
+   *
+   * By default OkHttp will attempt to retransmit request bodies when the original request fails
+   * due to a stale connection, a client timeout (HTTP 408), a satisfied authorization challenge
+   * (HTTP 401 and 407), or a retryable server failure (HTTP 503 with a `Retry-After: 0`
+   * header).
+   */
+  open fun isOneShot(): Boolean = false
+
+  companion object {
+
+    /**
+     * Returns a new request body that transmits [content]. If [contentType] is non-null
+     * and lacks a charset, this will use UTF-8.
+     */
+    @JvmStatic
+    fun create(contentType: MediaType?, content: String): RequestBody {
+      var charset: Charset = UTF_8
+      var finalContentType: MediaType? = contentType
+      if (contentType != null) {
+        val resolvedCharset = contentType.charset()
+        if (resolvedCharset == null) {
+          charset = UTF_8
+          finalContentType = MediaType.parse("$contentType; charset=utf-8")
+        } else {
+          charset = resolvedCharset
+        }
+      }
+      val bytes = content.toByteArray(charset)
+      return create(finalContentType, bytes)
+    }
+
+    /** Returns a new request body that transmits [content]. */
+    @JvmStatic
+    fun create(
+      contentType: MediaType?,
+      content: ByteString
+    ): RequestBody = object : RequestBody() {
+      override fun contentType() = contentType
+
+      override fun contentLength() = content.size.toLong()
+
+      override fun writeTo(sink: BufferedSink) {
+        sink.write(content)
+      }
+    }
+
+    /** Returns a new request body that transmits [content]. */
+    @JvmOverloads
+    @JvmStatic
+    fun create(
+      contentType: MediaType?,
+      content: ByteArray,
+      offset: Int = 0,
+      byteCount: Int = content.size
+    ): RequestBody {
+      Util.checkOffsetAndCount(content.size.toLong(), offset.toLong(), byteCount.toLong())
+      return object : RequestBody() {
+        override fun contentType() = contentType
+
+        override fun contentLength() = byteCount.toLong()
+
+        override fun writeTo(sink: BufferedSink) {
+          sink.write(content, offset, byteCount)
+        }
+      }
+    }
+
+    /** Returns a new request body that transmits the content of [file]. */
+    @JvmStatic
+    fun create(contentType: MediaType?, file: File): RequestBody = object : RequestBody() {
+      override fun contentType() = contentType
+
+      override fun contentLength() = file.length()
+
+      override fun writeTo(sink: BufferedSink) {
+        file.source().use { source -> sink.writeAll(source) }
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
deleted file mode 100644
index b58c9aac21..0000000000
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ /dev/null
@@ -1,456 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.util.Collections;
-import java.util.List;
-import javax.annotation.Nullable;
-import okhttp3.internal.http.HttpCodec;
-import okhttp3.internal.http.HttpHeaders;
-import okio.Buffer;
-import okio.BufferedSource;
-
-import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
-import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
-import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
-import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
-import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
-import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-
-/**
- * An HTTP response. Instances of this class are not immutable: the response body is a one-shot
- * value that may be consumed only once and then closed. All other properties are immutable.
- *
- * <p>This class implements {@link Closeable}. Closing it simply closes its response body. See
- * {@link ResponseBody} for an explanation and examples.
- */
-public final class Response implements Closeable {
-  final Request request;
-  final Protocol protocol;
-  final int code;
-  final String message;
-  final @Nullable Handshake handshake;
-  final Headers headers;
-  final @Nullable ResponseBody body;
-  final @Nullable Response networkResponse;
-  final @Nullable Response cacheResponse;
-  final @Nullable Response priorResponse;
-  final long sentRequestAtMillis;
-  final long receivedResponseAtMillis;
-  final @Nullable HttpCodec httpCodec;
-
-  private volatile @Nullable CacheControl cacheControl; // Lazily initialized.
-
-  Response(Builder builder) {
-    this.request = builder.request;
-    this.protocol = builder.protocol;
-    this.code = builder.code;
-    this.message = builder.message;
-    this.handshake = builder.handshake;
-    this.headers = builder.headers.build();
-    this.body = builder.body;
-    this.networkResponse = builder.networkResponse;
-    this.cacheResponse = builder.cacheResponse;
-    this.priorResponse = builder.priorResponse;
-    this.sentRequestAtMillis = builder.sentRequestAtMillis;
-    this.receivedResponseAtMillis = builder.receivedResponseAtMillis;
-    this.httpCodec = builder.httpCodec;
-  }
-
-  /**
-   * The wire-level request that initiated this HTTP response. This is not necessarily the same
-   * request issued by the application:
-   *
-   * <ul>
-   *     <li>It may be transformed by the HTTP client. For example, the client may copy headers like
-   *         {@code Content-Length} from the request body.
-   *     <li>It may be the request generated in response to an HTTP redirect or authentication
-   *         challenge. In this case the request URL may be different than the initial request URL.
-   * </ul>
-   */
-  public Request request() {
-    return request;
-  }
-
-  /**
-   * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link Protocol#HTTP_1_0}.
-   */
-  public Protocol protocol() {
-    return protocol;
-  }
-
-  /** Returns the HTTP status code. */
-  public int code() {
-    return code;
-  }
-
-  /**
-   * Returns true if the code is in [200..300), which means the request was successfully received,
-   * understood, and accepted.
-   */
-  public boolean isSuccessful() {
-    return code >= 200 && code < 300;
-  }
-
-  /** Returns the HTTP status message. */
-  public String message() {
-    return message;
-  }
-
-  /**
-   * Returns the TLS handshake of the connection that carried this response, or null if the response
-   * was received without TLS.
-   */
-  public @Nullable Handshake handshake() {
-    return handshake;
-  }
-
-  public List<String> headers(String name) {
-    return headers.values(name);
-  }
-
-  public @Nullable String header(String name) {
-    return header(name, null);
-  }
-
-  public @Nullable String header(String name, @Nullable String defaultValue) {
-    String result = headers.get(name);
-    return result != null ? result : defaultValue;
-  }
-
-  public Headers headers() {
-    return headers;
-  }
-
-  /**
-   * Returns the trailers after the HTTP response, which may be empty. It is an error to call this
-   * before the entire HTTP response body has been consumed.
-   */
-  public Headers trailers() throws IOException {
-    return httpCodec.trailers();
-  }
-
-  /**
-   * Peeks up to {@code byteCount} bytes from the response body and returns them as a new response
-   * body. If fewer than {@code byteCount} bytes are in the response body, the full response body is
-   * returned. If more than {@code byteCount} bytes are in the response body, the returned value
-   * will be truncated to {@code byteCount} bytes.
-   *
-   * <p>It is an error to call this method after the body has been consumed.
-   *
-   * <p><strong>Warning:</strong> this method loads the requested bytes into memory. Most
-   * applications should set a modest limit on {@code byteCount}, such as 1 MiB.
-   */
-  public ResponseBody peekBody(long byteCount) throws IOException {
-    BufferedSource peeked = body.source().peek();
-    Buffer buffer = new Buffer();
-    peeked.request(byteCount);
-    buffer.write(peeked, Math.min(byteCount, peeked.getBuffer().size()));
-    return ResponseBody.create(body.contentType(), buffer.size(), buffer);
-  }
-
-  /**
-   * Returns a non-null value if this response was passed to {@link Callback#onResponse} or returned
-   * from {@link Call#execute()}. Response bodies must be {@linkplain ResponseBody closed} and may
-   * be consumed only once.
-   *
-   * <p>This always returns null on responses returned from {@link #cacheResponse}, {@link
-   * #networkResponse}, and {@link #priorResponse()}.
-   */
-  public @Nullable ResponseBody body() {
-    return body;
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  /** Returns true if this response redirects to another resource. */
-  public boolean isRedirect() {
-    switch (code) {
-      case HTTP_PERM_REDIRECT:
-      case HTTP_TEMP_REDIRECT:
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-        return true;
-      default:
-        return false;
-    }
-  }
-
-  /**
-   * Returns the raw response received from the network. Will be null if this response didn't use
-   * the network, such as when the response is fully cached. The body of the returned response
-   * should not be read.
-   */
-  public @Nullable Response networkResponse() {
-    return networkResponse;
-  }
-
-  /**
-   * Returns the raw response received from the cache. Will be null if this response didn't use the
-   * cache. For conditional get requests the cache response and network response may both be
-   * non-null. The body of the returned response should not be read.
-   */
-  public @Nullable Response cacheResponse() {
-    return cacheResponse;
-  }
-
-  /**
-   * Returns the response for the HTTP redirect or authorization challenge that triggered this
-   * response, or null if this response wasn't triggered by an automatic retry. The body of the
-   * returned response should not be read because it has already been consumed by the redirecting
-   * client.
-   */
-  public @Nullable Response priorResponse() {
-    return priorResponse;
-  }
-
-  /**
-   * Returns the RFC 7235 authorization challenges appropriate for this response's code. If the
-   * response code is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the
-   * response code is 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges.
-   * Otherwise this returns an empty list of challenges.
-   *
-   * <p>If a challenge uses the {@code token68} variant instead of auth params, there is exactly one
-   * auth param in the challenge at key {@code null}. Invalid headers and challenges are ignored.
-   * No semantic validation is done, for example that {@code Basic} auth must have a {@code realm}
-   * auth param, this is up to the caller that interprets these challenges.
-   */
-  public List<Challenge> challenges() {
-    String responseField;
-    if (code == HTTP_UNAUTHORIZED) {
-      responseField = "WWW-Authenticate";
-    } else if (code == HTTP_PROXY_AUTH) {
-      responseField = "Proxy-Authenticate";
-    } else {
-      return Collections.emptyList();
-    }
-    return HttpHeaders.parseChallenges(headers(), responseField);
-  }
-
-  /**
-   * Returns the cache control directives for this response. This is never null, even if this
-   * response contains no {@code Cache-Control} header.
-   */
-  public CacheControl cacheControl() {
-    CacheControl result = cacheControl;
-    return result != null ? result : (cacheControl = CacheControl.parse(headers));
-  }
-
-  /**
-   * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately before OkHttp
-   * transmitted the initiating request over the network. If this response is being served from the
-   * cache then this is the timestamp of the original request.
-   */
-  public long sentRequestAtMillis() {
-    return sentRequestAtMillis;
-  }
-
-  /**
-   * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately after OkHttp
-   * received this response's headers from the network. If this response is being served from the
-   * cache then this is the timestamp of the original response.
-   */
-  public long receivedResponseAtMillis() {
-    return receivedResponseAtMillis;
-  }
-
-  /**
-   * Closes the response body. Equivalent to {@code body().close()}.
-   *
-   * <p>It is an error to close a response that is not eligible for a body. This includes the
-   * responses returned from {@link #cacheResponse}, {@link #networkResponse}, and {@link
-   * #priorResponse()}.
-   */
-  @Override public void close() {
-    if (body == null) {
-      throw new IllegalStateException("response is not eligible for a body and must not be closed");
-    }
-    body.close();
-  }
-
-  @Override public String toString() {
-    return "Response{protocol="
-        + protocol
-        + ", code="
-        + code
-        + ", message="
-        + message
-        + ", url="
-        + request.url()
-        + '}';
-  }
-
-  public static class Builder {
-    @Nullable Request request;
-    @Nullable Protocol protocol;
-    int code = -1;
-    String message;
-    @Nullable Handshake handshake;
-    Headers.Builder headers;
-    @Nullable ResponseBody body;
-    @Nullable Response networkResponse;
-    @Nullable Response cacheResponse;
-    @Nullable Response priorResponse;
-    long sentRequestAtMillis;
-    long receivedResponseAtMillis;
-    @Nullable HttpCodec httpCodec;
-
-    public Builder() {
-      headers = new Headers.Builder();
-    }
-
-    Builder(Response response) {
-      this.request = response.request;
-      this.protocol = response.protocol;
-      this.code = response.code;
-      this.message = response.message;
-      this.handshake = response.handshake;
-      this.headers = response.headers.newBuilder();
-      this.body = response.body;
-      this.networkResponse = response.networkResponse;
-      this.cacheResponse = response.cacheResponse;
-      this.priorResponse = response.priorResponse;
-      this.sentRequestAtMillis = response.sentRequestAtMillis;
-      this.receivedResponseAtMillis = response.receivedResponseAtMillis;
-      this.httpCodec = response.httpCodec;
-    }
-
-    public Builder request(Request request) {
-      this.request = request;
-      return this;
-    }
-
-    public Builder protocol(Protocol protocol) {
-      this.protocol = protocol;
-      return this;
-    }
-
-    public Builder code(int code) {
-      this.code = code;
-      return this;
-    }
-
-    public Builder message(String message) {
-      this.message = message;
-      return this;
-    }
-
-    public Builder handshake(@Nullable Handshake handshake) {
-      this.handshake = handshake;
-      return this;
-    }
-
-    /**
-     * Sets the header named {@code name} to {@code value}. If this request already has any headers
-     * with that name, they are all replaced.
-     */
-    public Builder header(String name, String value) {
-      headers.set(name, value);
-      return this;
-    }
-
-    /**
-     * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
-     * headers like "Set-Cookie".
-     */
-    public Builder addHeader(String name, String value) {
-      headers.add(name, value);
-      return this;
-    }
-
-    public Builder removeHeader(String name) {
-      headers.removeAll(name);
-      return this;
-    }
-
-    /** Removes all headers on this builder and adds {@code headers}. */
-    public Builder headers(Headers headers) {
-      this.headers = headers.newBuilder();
-      return this;
-    }
-
-    public Builder body(@Nullable ResponseBody body) {
-      this.body = body;
-      return this;
-    }
-
-    public Builder networkResponse(@Nullable Response networkResponse) {
-      if (networkResponse != null) checkSupportResponse("networkResponse", networkResponse);
-      this.networkResponse = networkResponse;
-      return this;
-    }
-
-    public Builder cacheResponse(@Nullable Response cacheResponse) {
-      if (cacheResponse != null) checkSupportResponse("cacheResponse", cacheResponse);
-      this.cacheResponse = cacheResponse;
-      return this;
-    }
-
-    private void checkSupportResponse(String name, Response response) {
-      if (response.body != null) {
-        throw new IllegalArgumentException(name + ".body != null");
-      } else if (response.networkResponse != null) {
-        throw new IllegalArgumentException(name + ".networkResponse != null");
-      } else if (response.cacheResponse != null) {
-        throw new IllegalArgumentException(name + ".cacheResponse != null");
-      } else if (response.priorResponse != null) {
-        throw new IllegalArgumentException(name + ".priorResponse != null");
-      }
-    }
-
-    public Builder priorResponse(@Nullable Response priorResponse) {
-      if (priorResponse != null) checkPriorResponse(priorResponse);
-      this.priorResponse = priorResponse;
-      return this;
-    }
-
-    private void checkPriorResponse(Response response) {
-      if (response.body != null) {
-        throw new IllegalArgumentException("priorResponse.body != null");
-      }
-    }
-
-    public Builder sentRequestAtMillis(long sentRequestAtMillis) {
-      this.sentRequestAtMillis = sentRequestAtMillis;
-      return this;
-    }
-
-    public Builder receivedResponseAtMillis(long receivedResponseAtMillis) {
-      this.receivedResponseAtMillis = receivedResponseAtMillis;
-      return this;
-    }
-
-    void initCodec(HttpCodec httpCodec) {
-      this.httpCodec = httpCodec;
-    }
-
-    public Response build() {
-      if (request == null) throw new IllegalStateException("request == null");
-      if (protocol == null) throw new IllegalStateException("protocol == null");
-      if (code < 0) throw new IllegalStateException("code < 0: " + code);
-      if (message == null) throw new IllegalStateException("message == null");
-      return new Response(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Response.kt b/okhttp/src/main/java/okhttp3/Response.kt
new file mode 100644
index 0000000000..144071fd62
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Response.kt
@@ -0,0 +1,361 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.io.Closeable
+import java.io.IOException
+import okhttp3.internal.connection.Exchange
+import okhttp3.internal.http.HttpHeaders
+import okhttp3.internal.http.StatusLine.Companion.HTTP_PERM_REDIRECT
+import okhttp3.internal.http.StatusLine.Companion.HTTP_TEMP_REDIRECT
+import okio.Buffer
+
+import java.net.HttpURLConnection.HTTP_MOVED_PERM
+import java.net.HttpURLConnection.HTTP_MOVED_TEMP
+import java.net.HttpURLConnection.HTTP_MULT_CHOICE
+import java.net.HttpURLConnection.HTTP_PROXY_AUTH
+import java.net.HttpURLConnection.HTTP_SEE_OTHER
+import java.net.HttpURLConnection.HTTP_UNAUTHORIZED
+
+/**
+ * An HTTP response. Instances of this class are not immutable: the response body is a one-shot
+ * value that may be consumed only once and then closed. All other properties are immutable.
+ *
+ * This class implements [Closeable]. Closing it simply closes its response body. See
+ * [ResponseBody] for an explanation and examples.
+ */
+class Response internal constructor(
+  internal val request: Request,
+  internal val protocol: Protocol,
+  internal val message: String,
+  builder: Builder
+) : Closeable {
+  internal val code: Int = builder.code
+  internal val handshake: Handshake? = builder.handshake
+  internal val headers: Headers = builder.headers.build()
+  internal val body: ResponseBody? = builder.body
+  internal val networkResponse: Response? = builder.networkResponse
+  internal val cacheResponse: Response? = builder.cacheResponse
+  internal val priorResponse: Response? = builder.priorResponse
+  internal val sentRequestAtMillis: Long = builder.sentRequestAtMillis
+  internal val receivedResponseAtMillis: Long = builder.receivedResponseAtMillis
+  internal val exchange: Exchange? = builder.exchange
+
+  @Volatile
+  private var cacheControl: CacheControl? = null // Lazily initialized.
+
+  /**
+   * The wire-level request that initiated this HTTP response. This is not necessarily the same
+   * request issued by the application:
+   *
+   * * It may be transformed by the HTTP client. For example, the client may copy headers like
+   *   `Content-Length` from the request body.
+   * * It may be the request generated in response to an HTTP redirect or authentication
+   *   challenge. In this case the request URL may be different than the initial request URL.
+   */
+  fun request(): Request = request
+
+  /** Returns the HTTP protocol, such as [Protocol.HTTP_1_1] or [Protocol.HTTP_1_0]. */
+  fun protocol(): Protocol = protocol
+
+  /** Returns the HTTP status code. */
+  fun code(): Int = code
+
+  /**
+   * Returns true if the code is in [200..300), which means the request was successfully received,
+   * understood, and accepted.
+   */
+  val isSuccessful: Boolean
+    get() = code in 200..299
+
+  /** Returns the HTTP status message. */
+  fun message(): String = message
+
+  /**
+   * Returns the TLS handshake of the connection that carried this response, or null if the
+   * response was received without TLS.
+   */
+  fun handshake(): Handshake? = handshake
+
+  fun headers(name: String): List<String> = headers.values(name)
+
+  @JvmOverloads
+  fun header(name: String, defaultValue: String? = null): String? = headers[name] ?: defaultValue
+
+  fun headers(): Headers = headers
+
+  /**
+   * Returns the trailers after the HTTP response, which may be empty. It is an error to call this
+   * before the entire HTTP response body has been consumed.
+   */
+  @Throws(IOException::class)
+  fun trailers(): Headers = checkNotNull(exchange) { "trailers not available" }.trailers()
+
+  /**
+   * Peeks up to [byteCount] bytes from the response body and returns them as a new response
+   * body. If fewer than [byteCount] bytes are in the response body, the full response body is
+   * returned. If more than [byteCount] bytes are in the response body, the returned value
+   * will be truncated to [byteCount] bytes.
+   *
+   * It is an error to call this method after the body has been consumed.
+   *
+   * **Warning:** this method loads the requested bytes into memory. Most applications should set
+   * a modest limit on `byteCount`, such as 1 MiB.
+   */
+  @Throws(IOException::class)
+  fun peekBody(byteCount: Long): ResponseBody {
+    val peeked = body!!.source().peek()
+    val buffer = Buffer()
+    peeked.request(byteCount)
+    buffer.write(peeked, Math.min(byteCount, peeked.buffer.size))
+    return ResponseBody.create(body.contentType(), buffer.size, buffer)
+  }
+
+  /**
+   * Returns a non-null value if this response was passed to [Callback.onResponse] or returned
+   * from [Call.execute]. Response bodies must be [closed][ResponseBody] and may
+   * be consumed only once.
+   *
+   * This always returns null on responses returned from [cacheResponse], [networkResponse],
+   * and [priorResponse].
+   */
+  fun body(): ResponseBody? = body
+
+  fun newBuilder(): Builder = Builder(this)
+
+  /** Returns true if this response redirects to another resource. */
+  val isRedirect: Boolean
+    get() = when (code) {
+      HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT, HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -> true
+      else -> false
+    }
+
+  /**
+   * Returns the raw response received from the network. Will be null if this response didn't use
+   * the network, such as when the response is fully cached. The body of the returned response
+   * should not be read.
+   */
+  fun networkResponse(): Response? = networkResponse
+
+  /**
+   * Returns the raw response received from the cache. Will be null if this response didn't use
+   * the cache. For conditional get requests the cache response and network response may both be
+   * non-null. The body of the returned response should not be read.
+   */
+  fun cacheResponse(): Response? = cacheResponse
+
+  /**
+   * Returns the response for the HTTP redirect or authorization challenge that triggered this
+   * response, or null if this response wasn't triggered by an automatic retry. The body of the
+   * returned response should not be read because it has already been consumed by the redirecting
+   * client.
+   */
+  fun priorResponse(): Response? = priorResponse
+
+  /**
+   * Returns the RFC 7235 authorization challenges appropriate for this response's code. If the
+   * response code is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the
+   * response code is 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges.
+   * Otherwise this returns an empty list of challenges.
+   *
+   * If a challenge uses the `token68` variant instead of auth params, there is exactly one
+   * auth param in the challenge at key null. Invalid headers and challenges are ignored.
+   * No semantic validation is done, for example that `Basic` auth must have a `realm`
+   * auth param, this is up to the caller that interprets these challenges.
+   */
+  fun challenges(): List<Challenge> {
+    return HttpHeaders.parseChallenges(
+        headers(),
+        when (code) {
+          HTTP_UNAUTHORIZED -> "WWW-Authenticate"
+          HTTP_PROXY_AUTH -> "Proxy-Authenticate"
+          else -> return emptyList()
+        }
+    )
+  }
+
+  /**
+   * Returns the cache control directives for this response. This is never null, even if this
+   * response contains no `Cache-Control` header.
+   */
+  fun cacheControl(): CacheControl = cacheControl ?: CacheControl.parse(headers).also {
+    cacheControl = it
+  }
+
+  /**
+   * Returns a [timestamp][System.currentTimeMillis] taken immediately before OkHttp
+   * transmitted the initiating request over the network. If this response is being served from the
+   * cache then this is the timestamp of the original request.
+   */
+  fun sentRequestAtMillis(): Long = sentRequestAtMillis
+
+  /**
+   * Returns a [timestamp][System.currentTimeMillis] taken immediately after OkHttp
+   * received this response's headers from the network. If this response is being served from the
+   * cache then this is the timestamp of the original response.
+   */
+  fun receivedResponseAtMillis(): Long = receivedResponseAtMillis
+
+  /**
+   * Closes the response body. Equivalent to `body().close()`.
+   *
+   * It is an error to close a response that is not eligible for a body. This includes the
+   * responses returned from [cacheResponse], [networkResponse], and [priorResponse].
+   */
+  override fun close() {
+    checkNotNull(body) { "response is not eligible for a body and must not be closed" }.close()
+  }
+
+  override fun toString() =
+      "Response{protocol=$protocol, code=$code, message=$message, url=${request.url()}}"
+
+  open class Builder {
+    internal var request: Request? = null
+    internal var protocol: Protocol? = null
+    internal var code = -1
+    internal var message: String? = null
+    internal var handshake: Handshake? = null
+    internal var headers: Headers.Builder
+    internal var body: ResponseBody? = null
+    internal var networkResponse: Response? = null
+    internal var cacheResponse: Response? = null
+    internal var priorResponse: Response? = null
+    internal var sentRequestAtMillis: Long = 0
+    internal var receivedResponseAtMillis: Long = 0
+    internal var exchange: Exchange? = null
+
+    constructor() {
+      headers = Headers.Builder()
+    }
+
+    internal constructor(response: Response) {
+      this.request = response.request
+      this.protocol = response.protocol
+      this.code = response.code
+      this.message = response.message
+      this.handshake = response.handshake
+      this.headers = response.headers.newBuilder()
+      this.body = response.body
+      this.networkResponse = response.networkResponse
+      this.cacheResponse = response.cacheResponse
+      this.priorResponse = response.priorResponse
+      this.sentRequestAtMillis = response.sentRequestAtMillis
+      this.receivedResponseAtMillis = response.receivedResponseAtMillis
+      this.exchange = response.exchange
+    }
+
+    open fun request(request: Request) = apply {
+      this.request = request
+    }
+
+    open fun protocol(protocol: Protocol) = apply {
+      this.protocol = protocol
+    }
+
+    open fun code(code: Int) = apply {
+      this.code = code
+    }
+
+    open fun message(message: String) = apply {
+      this.message = message
+    }
+
+    open fun handshake(handshake: Handshake?) = apply {
+      this.handshake = handshake
+    }
+
+    /**
+     * Sets the header named [name] to [value]. If this request already has any headers
+     * with that name, they are all replaced.
+     */
+    open fun header(name: String, value: String) = apply {
+      headers[name] = value
+    }
+
+    /**
+     * Adds a header with [name] to [value]. Prefer this method for multiply-valued
+     * headers like "Set-Cookie".
+     */
+    open fun addHeader(name: String, value: String) = apply {
+      headers.add(name, value)
+    }
+
+    /** Removes all headers named [name] on this builder. */
+    open fun removeHeader(name: String) = apply {
+      headers.removeAll(name)
+    }
+
+    /** Removes all headers on this builder and adds [headers]. */
+    open fun headers(headers: Headers) = apply {
+      this.headers = headers.newBuilder()
+    }
+
+    open fun body(body: ResponseBody?) = apply {
+      this.body = body
+    }
+
+    open fun networkResponse(networkResponse: Response?) = apply {
+      checkSupportResponse("networkResponse", networkResponse)
+      this.networkResponse = networkResponse
+    }
+
+    open fun cacheResponse(cacheResponse: Response?) = apply {
+      checkSupportResponse("cacheResponse", cacheResponse)
+      this.cacheResponse = cacheResponse
+    }
+
+    private fun checkSupportResponse(name: String, response: Response?) {
+      response?.apply {
+        require(body == null) { "$name.body != null" }
+        require(networkResponse == null) { "$name.networkResponse != null" }
+        require(cacheResponse == null) { "$name.cacheResponse != null" }
+        require(priorResponse == null) { "$name.priorResponse != null" }
+      }
+    }
+
+    open fun priorResponse(priorResponse: Response?) = apply {
+      checkPriorResponse(priorResponse)
+      this.priorResponse = priorResponse
+    }
+
+    private fun checkPriorResponse(response: Response?) {
+      response?.apply {
+        require(body == null) { "priorResponse.body != null" }
+      }
+    }
+
+    open fun sentRequestAtMillis(sentRequestAtMillis: Long) = apply {
+      this.sentRequestAtMillis = sentRequestAtMillis
+    }
+
+    open fun receivedResponseAtMillis(receivedResponseAtMillis: Long) = apply {
+      this.receivedResponseAtMillis = receivedResponseAtMillis
+    }
+
+    internal fun initExchange(deferredTrailers: Exchange) {
+      this.exchange = deferredTrailers
+    }
+
+    open fun build(): Response {
+      check(code > 0) { "code < 0: $code" }
+      return Response(
+          checkNotNull(request) { "request == null" },
+          checkNotNull(protocol) { "protocol == null" },
+          checkNotNull(message) { "message == null" },
+          this)
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
deleted file mode 100644
index 96b7e38a0f..0000000000
--- a/okhttp/src/main/java/okhttp3/ResponseBody.java
+++ /dev/null
@@ -1,275 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.nio.charset.Charset;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-/**
- * A one-shot stream from the origin server to the client application with the raw bytes of the
- * response body. Each response body is supported by an active connection to the webserver. This
- * imposes both obligations and limits on the client application.
- *
- * <h3>The response body must be closed.</h3>
- *
- * Each response body is backed by a limited resource like a socket (live network responses) or
- * an open file (for cached responses). Failing to close the response body will leak resources and
- * may ultimately cause the application to slow down or crash.
- *
- * <p>Both this class and {@link Response} implement {@link Closeable}. Closing a response simply
- * closes its response body. If you invoke {@link Call#execute()} or implement {@link
- * Callback#onResponse} you must close this body by calling any of the following methods:
- *
- * <ul>
- *   <li>Response.close()</li>
- *   <li>Response.body().close()</li>
- *   <li>Response.body().source().close()</li>
- *   <li>Response.body().charStream().close()</li>
- *   <li>Response.body().byteStream().close()</li>
- *   <li>Response.body().bytes()</li>
- *   <li>Response.body().string()</li>
- * </ul>
- *
- * <p>There is no benefit to invoking multiple {@code close()} methods for the same response body.
- *
- * <p>For synchronous calls, the easiest way to make sure a response body is closed is with a {@code
- * try} block. With this structure the compiler inserts an implicit {@code finally} clause that
- * calls {@code close()} for you.
- *
- * <pre>   {@code
- *
- *   Call call = client.newCall(request);
- *   try (Response response = call.execute()) {
- *     ... // Use the response.
- *   }
- * }</pre>
- *
- * You can use a similar block for asynchronous calls: <pre>   {@code
- *
- *   Call call = client.newCall(request);
- *   call.enqueue(new Callback() {
- *     public void onResponse(Call call, Response response) throws IOException {
- *       try (ResponseBody responseBody = response.body()) {
- *         ... // Use the response.
- *       }
- *     }
- *
- *     public void onFailure(Call call, IOException e) {
- *       ... // Handle the failure.
- *     }
- *   });
- * }</pre>
- *
- * These examples will not work if you're consuming the response body on another thread. In such
- * cases the consuming thread must call {@link #close} when it has finished reading the response
- * body.
- *
- * <h3>The response body can be consumed only once.</h3>
- *
- * <p>This class may be used to stream very large responses. For example, it is possible to use this
- * class to read a response that is larger than the entire memory allocated to the current process.
- * It can even stream a response larger than the total storage on the current device, which is a
- * common requirement for video streaming applications.
- *
- * <p>Because this class does not buffer the full response in memory, the application may not
- * re-read the bytes of the response. Use this one shot to read the entire response into memory with
- * {@link #bytes()} or {@link #string()}. Or stream the response with either {@link #source()},
- * {@link #byteStream()}, or {@link #charStream()}.
- */
-public abstract class ResponseBody implements Closeable {
-  /** Multiple calls to {@link #charStream()} must return the same instance. */
-  private @Nullable Reader reader;
-
-  public abstract @Nullable MediaType contentType();
-
-  /**
-   * Returns the number of bytes in that will returned by {@link #bytes}, or {@link #byteStream}, or
-   * -1 if unknown.
-   */
-  public abstract long contentLength();
-
-  public final InputStream byteStream() {
-    return source().inputStream();
-  }
-
-  public abstract BufferedSource source();
-
-  /**
-   * Returns the response as a byte array.
-   *
-   * <p>This method loads entire response body into memory. If the response body is very large this
-   * may trigger an {@link OutOfMemoryError}. Prefer to stream the response body if this is a
-   * possibility for your response.
-   */
-  public final byte[] bytes() throws IOException {
-    long contentLength = contentLength();
-    if (contentLength > Integer.MAX_VALUE) {
-      throw new IOException("Cannot buffer entire body for content length: " + contentLength);
-    }
-
-    byte[] bytes;
-    try (BufferedSource source = source()) {
-      bytes = source.readByteArray();
-    }
-    if (contentLength != -1 && contentLength != bytes.length) {
-      throw new IOException("Content-Length ("
-          + contentLength
-          + ") and stream length ("
-          + bytes.length
-          + ") disagree");
-    }
-    return bytes;
-  }
-
-  /**
-   * Returns the response as a character stream.
-   *
-   * <p>If the response starts with a <a href="https://en.wikipedia.org/wiki/Byte_order_mark">Byte
-   * Order Mark (BOM)</a>, it is consumed and used to determine the charset of the response bytes.
-   *
-   * <p>Otherwise if the response has a Content-Type header that specifies a charset, that is used
-   * to determine the charset of the response bytes.
-   *
-   * <p>Otherwise the response bytes are decoded as UTF-8.
-   */
-  public final Reader charStream() {
-    Reader r = reader;
-    return r != null ? r : (reader = new BomAwareReader(source(), charset()));
-  }
-
-  /**
-   * Returns the response as a string.
-   *
-   * <p>If the response starts with a <a href="https://en.wikipedia.org/wiki/Byte_order_mark">Byte
-   * Order Mark (BOM)</a>, it is consumed and used to determine the charset of the response bytes.
-   *
-   * <p>Otherwise if the response has a Content-Type header that specifies a charset, that is used
-   * to determine the charset of the response bytes.
-   *
-   * <p>Otherwise the response bytes are decoded as UTF-8.
-   *
-   * <p>This method loads entire response body into memory. If the response body is very large this
-   * may trigger an {@link OutOfMemoryError}. Prefer to stream the response body if this is a
-   * possibility for your response.
-   */
-  public final String string() throws IOException {
-    try (BufferedSource source = source()) {
-      Charset charset = Util.bomAwareCharset(source, charset());
-      return source.readString(charset);
-    }
-  }
-
-  private Charset charset() {
-    MediaType contentType = contentType();
-    return contentType != null ? contentType.charset(UTF_8) : UTF_8;
-  }
-
-  @Override public void close() {
-    Util.closeQuietly(source());
-  }
-
-  /**
-   * Returns a new response body that transmits {@code content}. If {@code contentType} is non-null
-   * and lacks a charset, this will use UTF-8.
-   */
-  public static ResponseBody create(@Nullable MediaType contentType, String content) {
-    Charset charset = UTF_8;
-    if (contentType != null) {
-      charset = contentType.charset();
-      if (charset == null) {
-        charset = UTF_8;
-        contentType = MediaType.parse(contentType + "; charset=utf-8");
-      }
-    }
-    Buffer buffer = new Buffer().writeString(content, charset);
-    return create(contentType, buffer.size(), buffer);
-  }
-
-  /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(final @Nullable MediaType contentType, byte[] content) {
-    Buffer buffer = new Buffer().write(content);
-    return create(contentType, content.length, buffer);
-  }
-
-  /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(@Nullable MediaType contentType, ByteString content) {
-    Buffer buffer = new Buffer().write(content);
-    return create(contentType, content.size(), buffer);
-  }
-
-  /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(final @Nullable MediaType contentType,
-      final long contentLength, final BufferedSource content) {
-    if (content == null) throw new NullPointerException("source == null");
-    return new ResponseBody() {
-      @Override public @Nullable MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() {
-        return contentLength;
-      }
-
-      @Override public BufferedSource source() {
-        return content;
-      }
-    };
-  }
-
-  static final class BomAwareReader extends Reader {
-    private final BufferedSource source;
-    private final Charset charset;
-
-    private boolean closed;
-    private @Nullable Reader delegate;
-
-    BomAwareReader(BufferedSource source, Charset charset) {
-      this.source = source;
-      this.charset = charset;
-    }
-
-    @Override public int read(char[] cbuf, int off, int len) throws IOException {
-      if (closed) throw new IOException("Stream closed");
-
-      Reader delegate = this.delegate;
-      if (delegate == null) {
-        Charset charset = Util.bomAwareCharset(source, this.charset);
-        delegate = this.delegate = new InputStreamReader(source.inputStream(), charset);
-      }
-      return delegate.read(cbuf, off, len);
-    }
-
-    @Override public void close() throws IOException {
-      closed = true;
-      if (delegate != null) {
-        delegate.close();
-      } else {
-        source.close();
-      }
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.kt b/okhttp/src/main/java/okhttp3/ResponseBody.kt
new file mode 100644
index 0000000000..ce63dfb1a0
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.kt
@@ -0,0 +1,255 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.Util
+import okio.Buffer
+import okio.BufferedSource
+import okio.ByteString
+import java.io.Closeable
+import java.io.IOException
+import java.io.InputStream
+import java.io.InputStreamReader
+import java.io.Reader
+import java.nio.charset.Charset
+import kotlin.text.Charsets.UTF_8
+
+/**
+ * A one-shot stream from the origin server to the client application with the raw bytes of the
+ * response body. Each response body is supported by an active connection to the webserver. This
+ * imposes both obligations and limits on the client application.
+ *
+ * ### The response body must be closed.
+ *
+ * Each response body is backed by a limited resource like a socket (live network responses) or
+ * an open file (for cached responses). Failing to close the response body will leak resources and
+ * may ultimately cause the application to slow down or crash.
+ *
+ * Both this class and [Response] implement [Closeable]. Closing a response simply
+ * closes its response body. If you invoke [Call.execute] or implement [Callback.onResponse] you
+ * must close this body by calling any of the following methods:
+ *
+ * * `Response.close()`
+ * * `Response.body().close()`
+ * * `Response.body().source().close()`
+ * * `Response.body().charStream().close()`
+ * * `Response.body().byteStream().close()`
+ * * `Response.body().bytes()`
+ * * `Response.body().string()`
+ *
+ * There is no benefit to invoking multiple `close()` methods for the same response body.
+ *
+ * For synchronous calls, the easiest way to make sure a response body is closed is with a `try`
+ * block. With this structure the compiler inserts an implicit `finally` clause that calls
+ * [close()][Response.close] for you.
+ *
+ * ```
+ * Call call = client.newCall(request);
+ * try (Response response = call.execute()) {
+ * ... // Use the response.
+ * }
+ * ```
+ *
+ * You can use a similar block for asynchronous calls:
+ *
+ * ```
+ * Call call = client.newCall(request);
+ * call.enqueue(new Callback() {
+ *   public void onResponse(Call call, Response response) throws IOException {
+ *     try (ResponseBody responseBody = response.body()) {
+ *     ... // Use the response.
+ *     }
+ *   }
+ *
+ *   public void onFailure(Call call, IOException e) {
+ *   ... // Handle the failure.
+ *   }
+ * });
+ * ```
+ *
+ * These examples will not work if you're consuming the response body on another thread. In such
+ * cases the consuming thread must call [close] when it has finished reading the response
+ * body.
+ *
+ * ### The response body can be consumed only once.
+ *
+ * This class may be used to stream very large responses. For example, it is possible to use this
+ * class to read a response that is larger than the entire memory allocated to the current process.
+ * It can even stream a response larger than the total storage on the current device, which is a
+ * common requirement for video streaming applications.
+ *
+ * Because this class does not buffer the full response in memory, the application may not
+ * re-read the bytes of the response. Use this one shot to read the entire response into memory with
+ * [bytes] or [string]. Or stream the response with either [source], [byteStream], or [charStream].
+ */
+abstract class ResponseBody : Closeable {
+  /** Multiple calls to [charStream] must return the same instance. */
+  private var reader: Reader? = null
+
+  abstract fun contentType(): MediaType?
+
+  /**
+   * Returns the number of bytes in that will returned by [bytes], or [byteStream], or -1 if
+   * unknown.
+   */
+  abstract fun contentLength(): Long
+
+  fun byteStream(): InputStream = source().inputStream()
+
+  abstract fun source(): BufferedSource
+
+  /**
+   * Returns the response as a byte array.
+   *
+   * This method loads entire response body into memory. If the response body is very large this
+   * may trigger an [OutOfMemoryError]. Prefer to stream the response body if this is a
+   * possibility for your response.
+   */
+  @Throws(IOException::class)
+  fun bytes(): ByteArray {
+    val contentLength = contentLength()
+    if (contentLength > Integer.MAX_VALUE) {
+      throw IOException("Cannot buffer entire body for content length: $contentLength")
+    }
+
+    val bytes: ByteArray = source().use(BufferedSource::readByteArray)
+    if (contentLength != -1L && contentLength != bytes.size.toLong()) {
+      throw IOException(
+          "Content-Length ($contentLength) and stream length (${bytes.size}) disagree")
+    }
+    return bytes
+  }
+
+  /**
+   * Returns the response as a character stream.
+   *
+   * If the response starts with a
+   * [Byte Order Mark (BOM)](https://en.wikipedia.org/wiki/Byte_order_mark), it is consumed and
+   * used to determine the charset of the response bytes.
+   *
+   * Otherwise if the response has a `Content-Type` header that specifies a charset, that is used
+   * to determine the charset of the response bytes.
+   *
+   * Otherwise the response bytes are decoded as UTF-8.
+   */
+  fun charStream(): Reader = reader ?: BomAwareReader(source(), charset()).also {
+    reader = it
+  }
+
+  /**
+   * Returns the response as a string.
+   *
+   * If the response starts with a
+   * [Byte Order Mark (BOM)](https://en.wikipedia.org/wiki/Byte_order_mark), it is consumed and
+   * used to determine the charset of the response bytes.
+   *
+   * Otherwise if the response has a `Content-Type` header that specifies a charset, that is used
+   * to determine the charset of the response bytes.
+   *
+   * Otherwise the response bytes are decoded as UTF-8.
+   *
+   * This method loads entire response body into memory. If the response body is very large this
+   * may trigger an [OutOfMemoryError]. Prefer to stream the response body if this is a
+   * possibility for your response.
+   */
+  @Throws(IOException::class)
+  fun string(): String = source().use { source ->
+    source.readString(charset = Util.bomAwareCharset(source, charset()))
+  }
+
+  private fun charset() = contentType()?.charset(UTF_8) ?: UTF_8
+
+  override fun close() = Util.closeQuietly(source())
+
+  internal class BomAwareReader(
+    private val source: BufferedSource,
+    private val charset: Charset
+  ) : Reader() {
+
+    private var closed: Boolean = false
+    private var delegate: Reader? = null
+
+    @Throws(IOException::class)
+    override fun read(cbuf: CharArray, off: Int, len: Int): Int {
+      if (closed) throw IOException("Stream closed")
+
+      val finalDelegate = delegate ?: InputStreamReader(
+          source.inputStream(),
+          Util.bomAwareCharset(source, charset)).also {
+        delegate = it
+      }
+      return finalDelegate.read(cbuf, off, len)
+    }
+
+    @Throws(IOException::class)
+    override fun close() {
+      closed = true
+      delegate?.close() ?: run { source.close() }
+    }
+  }
+
+  companion object {
+
+    /**
+     * Returns a new response body that transmits [content]. If `contentType` is non-null
+     * and lacks a charset, this will use UTF-8.
+     */
+    @JvmStatic
+    fun create(contentType: MediaType?, content: String): ResponseBody {
+      var charset: Charset = UTF_8
+      var finalContentType: MediaType? = contentType
+      if (contentType != null) {
+        val resolvedCharset = contentType.charset()
+        if (resolvedCharset == null) {
+          charset = UTF_8
+          finalContentType = MediaType.parse("$contentType; charset=utf-8")
+        } else {
+          charset = resolvedCharset
+        }
+      }
+      val buffer = Buffer().writeString(content, charset)
+      return create(finalContentType, buffer.size, buffer)
+    }
+
+    /** Returns a new response body that transmits [content]. */
+    @JvmStatic
+    fun create(contentType: MediaType?, content: ByteArray): ResponseBody {
+      val buffer = Buffer().write(content)
+      return create(contentType, content.size.toLong(), buffer)
+    }
+
+    /** Returns a new response body that transmits [content]. */
+    @JvmStatic
+    fun create(contentType: MediaType?, content: ByteString): ResponseBody {
+      val buffer = Buffer().write(content)
+      return create(contentType, content.size.toLong(), buffer)
+    }
+
+    /** Returns a new response body that transmits [content]. */
+    @JvmStatic
+    fun create(
+      contentType: MediaType?,
+      contentLength: Long,
+      content: BufferedSource
+    ): ResponseBody = object : ResponseBody() {
+      override fun contentType() = contentType
+
+      override fun contentLength() = contentLength
+
+      override fun source() = content
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Route.java b/okhttp/src/main/java/okhttp3/Route.java
deleted file mode 100644
index 14158673ca..0000000000
--- a/okhttp/src/main/java/okhttp3/Route.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import javax.annotation.Nullable;
-
-/**
- * The concrete route used by a connection to reach an abstract origin server. When creating a
- * connection the client has many options:
- *
- * <ul>
- *     <li><strong>HTTP proxy:</strong> a proxy server may be explicitly configured for the client.
- *         Otherwise the {@linkplain java.net.ProxySelector proxy selector} is used. It may return
- *         multiple proxies to attempt.
- *     <li><strong>IP address:</strong> whether connecting directly to an origin server or a proxy,
- *         opening a socket requires an IP address. The DNS server may return multiple IP addresses
- *         to attempt.
- * </ul>
- *
- * <p>Each route is a specific selection of these options.
- */
-public final class Route {
-  final Address address;
-  final Proxy proxy;
-  final InetSocketAddress inetSocketAddress;
-
-  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress) {
-    if (address == null) {
-      throw new NullPointerException("address == null");
-    }
-    if (proxy == null) {
-      throw new NullPointerException("proxy == null");
-    }
-    if (inetSocketAddress == null) {
-      throw new NullPointerException("inetSocketAddress == null");
-    }
-    this.address = address;
-    this.proxy = proxy;
-    this.inetSocketAddress = inetSocketAddress;
-  }
-
-  public Address address() {
-    return address;
-  }
-
-  /**
-   * Returns the {@link Proxy} of this route.
-   *
-   * <strong>Warning:</strong> This may disagree with {@link Address#proxy} when it is null. When
-   * the address's proxy is null, the proxy selector is used.
-   */
-  public Proxy proxy() {
-    return proxy;
-  }
-
-  public InetSocketAddress socketAddress() {
-    return inetSocketAddress;
-  }
-
-  /**
-   * Returns true if this route tunnels HTTPS through an HTTP proxy. See <a
-   * href="http://www.ietf.org/rfc/rfc2817.txt">RFC 2817, Section 5.2</a>.
-   */
-  public boolean requiresTunnel() {
-    return address.sslSocketFactory != null && proxy.type() == Proxy.Type.HTTP;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof Route
-        && ((Route) other).address.equals(address)
-        && ((Route) other).proxy.equals(proxy)
-        && ((Route) other).inetSocketAddress.equals(inetSocketAddress);
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + address.hashCode();
-    result = 31 * result + proxy.hashCode();
-    result = 31 * result + inetSocketAddress.hashCode();
-    return result;
-  }
-
-  @Override public String toString() {
-    return "Route{" + inetSocketAddress + "}";
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Route.kt b/okhttp/src/main/java/okhttp3/Route.kt
new file mode 100644
index 0000000000..277dcc7609
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Route.kt
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.net.InetSocketAddress
+import java.net.Proxy
+
+/**
+ * The concrete route used by a connection to reach an abstract origin server. When creating a
+ * connection the client has many options:
+ *
+ *  * **HTTP proxy:** a proxy server may be explicitly configured for the client.
+ * Otherwise the [proxy selector][java.net.ProxySelector] is used. It may return
+ * multiple proxies to attempt.
+ *  * **IP address:** whether connecting directly to an origin server or a proxy,
+ * opening a socket requires an IP address. The DNS server may return multiple IP addresses
+ * to attempt.
+ *
+ * Each route is a specific selection of these options.
+ */
+data class Route(
+  internal val address: Address,
+  internal val proxy: Proxy,
+  internal val inetSocketAddress: InetSocketAddress
+) {
+
+  fun address(): Address = address
+
+  /**
+   * Returns the [Proxy] of this route.
+   *
+   * **Warning:** This may disagree with [Address.proxy] when it is null. When
+   * the address's proxy is null, the proxy selector is used.
+   */
+  fun proxy(): Proxy = proxy
+
+  fun socketAddress(): InetSocketAddress = inetSocketAddress
+
+  /**
+   * Returns true if this route tunnels HTTPS through an HTTP proxy.
+   * See [RFC 2817, Section 5.2][rfc_2817].
+   *
+   * [rfc_2817]: http://www.ietf.org/rfc/rfc2817.txt
+   */
+  fun requiresTunnel(): Boolean = address.sslSocketFactory() != null && proxy.type() == Proxy.Type.HTTP
+
+  override fun toString(): String = "Route{$inetSocketAddress}"
+}
diff --git a/okhttp/src/main/java/okhttp3/TlsVersion.java b/okhttp/src/main/java/okhttp3/TlsVersion.java
deleted file mode 100644
index 02cbeca3d1..0000000000
--- a/okhttp/src/main/java/okhttp3/TlsVersion.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * Versions of TLS that can be offered when negotiating a secure socket. See {@link
- * javax.net.ssl.SSLSocket#setEnabledProtocols}.
- */
-public enum TlsVersion {
-  TLS_1_3("TLSv1.3"), // 2016.
-  TLS_1_2("TLSv1.2"), // 2008.
-  TLS_1_1("TLSv1.1"), // 2006.
-  TLS_1_0("TLSv1"),   // 1999.
-  SSL_3_0("SSLv3"),   // 1996.
-  ;
-
-  final String javaName;
-
-  TlsVersion(String javaName) {
-    this.javaName = javaName;
-  }
-
-  public static TlsVersion forJavaName(String javaName) {
-    switch (javaName) {
-      case "TLSv1.3":
-        return TLS_1_3;
-      case "TLSv1.2":
-        return TLS_1_2;
-      case "TLSv1.1":
-        return TLS_1_1;
-      case "TLSv1":
-        return TLS_1_0;
-      case "SSLv3":
-        return SSL_3_0;
-    }
-    throw new IllegalArgumentException("Unexpected TLS version: " + javaName);
-  }
-
-  static List<TlsVersion> forJavaNames(String... tlsVersions) {
-    List<TlsVersion> result = new ArrayList<>(tlsVersions.length);
-    for (String tlsVersion : tlsVersions) {
-      result.add(forJavaName(tlsVersion));
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  public String javaName() {
-    return javaName;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/TlsVersion.kt b/okhttp/src/main/java/okhttp3/TlsVersion.kt
new file mode 100644
index 0000000000..7f583cec66
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/TlsVersion.kt
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+/**
+ * Versions of TLS that can be offered when negotiating a secure socket. See
+ * [javax.net.ssl.SSLSocket.setEnabledProtocols].
+ */
+enum class TlsVersion(private val javaName: String) {
+  TLS_1_3("TLSv1.3"), // 2016.
+  TLS_1_2("TLSv1.2"), // 2008.
+  TLS_1_1("TLSv1.1"), // 2006.
+  TLS_1_0("TLSv1"), // 1999.
+  SSL_3_0("SSLv3"); // 1996.
+
+  fun javaName() = javaName
+
+  companion object {
+    @JvmStatic
+    fun forJavaName(javaName: String): TlsVersion {
+      return when (javaName) {
+        "TLSv1.3" -> TLS_1_3
+        "TLSv1.2" -> TLS_1_2
+        "TLSv1.1" -> TLS_1_1
+        "TLSv1" -> TLS_1_0
+        "SSLv3" -> SSL_3_0
+        else -> throw IllegalArgumentException("Unexpected TLS version: $javaName")
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/WebSocket.java b/okhttp/src/main/java/okhttp3/WebSocket.java
deleted file mode 100644
index 46d95dec3a..0000000000
--- a/okhttp/src/main/java/okhttp3/WebSocket.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import javax.annotation.Nullable;
-import okio.ByteString;
-
-/**
- * A non-blocking interface to a web socket. Use the {@linkplain WebSocket.Factory factory} to
- * create instances; usually this is {@link OkHttpClient}.
- *
- * <h3>Web Socket Lifecycle</h3>
- *
- * Upon normal operation each web socket progresses through a sequence of states:
- *
- * <ul>
- *   <li><strong>Connecting:</strong> the initial state of each web socket. Messages may be enqueued
- *       but they won't be transmitted until the web socket is open.
- *   <li><strong>Open:</strong> the web socket has been accepted by the remote peer and is fully
- *       operational. Messages in either direction are enqueued for immediate transmission.
- *   <li><strong>Closing:</strong> one of the peers on the web socket has initiated a graceful
- *       shutdown. The web socket will continue to transmit already-enqueued messages but will
- *       refuse to enqueue new ones.
- *   <li><strong>Closed:</strong> the web socket has transmitted all of its messages and has
- *       received all messages from the peer.
- * </ul>
- *
- * Web sockets may fail due to HTTP upgrade problems, connectivity problems, or if either peer
- * chooses to short-circuit the graceful shutdown process:
- *
- * <ul>
- *   <li><strong>Canceled:</strong> the web socket connection failed. Messages that were
- *       successfully enqueued by either peer may not have been transmitted to the other.
- * </ul>
- *
- * Note that the state progression is independent for each peer. Arriving at a gracefully-closed
- * state indicates that a peer has sent all of its outgoing messages and received all of its
- * incoming messages. But it does not guarantee that the other peer will successfully receive all of
- * its incoming messages.
- */
-public interface WebSocket {
-  /** Returns the original request that initiated this web socket. */
-  Request request();
-
-  /**
-   * Returns the size in bytes of all messages enqueued to be transmitted to the server. This
-   * doesn't include framing overhead. It also doesn't include any bytes buffered by the operating
-   * system or network intermediaries. This method returns 0 if no messages are waiting
-   * in the queue. If may return a nonzero value after the web socket has been canceled; this
-   * indicates that enqueued messages were not transmitted.
-   */
-  long queueSize();
-
-  /**
-   * Attempts to enqueue {@code text} to be UTF-8 encoded and sent as a the data of a text (type
-   * {@code 0x1}) message.
-   *
-   * <p>This method returns true if the message was enqueued. Messages that would overflow the
-   * outgoing message buffer will be rejected and trigger a {@linkplain #close graceful shutdown} of
-   * this web socket. This method returns false in that case, and in any other case where this
-   * web socket is closing, closed, or canceled.
-   *
-   * <p>This method returns immediately.
-   */
-  boolean send(String text);
-
-  /**
-   * Attempts to enqueue {@code bytes} to be sent as a the data of a binary (type {@code 0x2})
-   * message.
-   *
-   * <p>This method returns true if the message was enqueued. Messages that would overflow the
-   * outgoing message buffer (16 MiB) will be rejected and trigger a
-   * {@linkplain #close graceful shutdown} of this web socket. This method returns false in that
-   * case, and in any other case where this web socket is closing, closed, or canceled.
-   *
-   * <p>This method returns immediately.
-   */
-  boolean send(ByteString bytes);
-
-  /**
-   * Attempts to initiate a graceful shutdown of this web socket. Any already-enqueued messages will
-   * be transmitted before the close message is sent but subsequent calls to {@link #send} will
-   * return false and their messages will not be enqueued.
-   *
-   * <p>This returns true if a graceful shutdown was initiated by this call. It returns false and if
-   * a graceful shutdown was already underway or if the web socket is already closed or canceled.
-   *
-   * @param code Status code as defined by <a
-   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a>.
-   * @param reason Reason for shutting down or {@code null}.
-   * @throws IllegalArgumentException if code is invalid.
-   */
-  boolean close(int code, @Nullable String reason);
-
-  /**
-   * Immediately and violently release resources held by this web socket, discarding any enqueued
-   * messages. This does nothing if the web socket has already been closed or canceled.
-   */
-  void cancel();
-
-  interface Factory {
-    /**
-     * Creates a new web socket and immediately returns it. Creating a web socket initiates an
-     * asynchronous process to connect the socket. Once that succeeds or fails, {@code listener}
-     * will be notified. The caller must either close or cancel the returned web socket when it is
-     * no longer in use.
-     */
-    WebSocket newWebSocket(Request request, WebSocketListener listener);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/WebSocket.kt b/okhttp/src/main/java/okhttp3/WebSocket.kt
new file mode 100644
index 0000000000..fa3524e907
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/WebSocket.kt
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okio.ByteString
+
+/**
+ * A non-blocking interface to a web socket. Use the [factory][WebSocket.Factory] to create
+ * instances; usually this is [OkHttpClient].
+ *
+ * ## Web Socket Lifecycle
+ *
+ * Upon normal operation each web socket progresses through a sequence of states:
+ *
+ *  * **Connecting:** the initial state of each web socket. Messages may be enqueued but they won't
+ *    be transmitted until the web socket is open.
+ *
+ *  * **Open:** the web socket has been accepted by the remote peer and is fully operational.
+ *    Messages in either direction are enqueued for immediate transmission.
+ *
+ *  * **Closing:** one of the peers on the web socket has initiated a graceful shutdown. The web
+ *    socket will continue to transmit already-enqueued messages but will refuse to enqueue new
+ *    ones.
+ *
+ *  * **Closed:** the web socket has transmitted all of its messages and has received all messages
+ *    from the peer.
+ *
+ * Web sockets may fail due to HTTP upgrade problems, connectivity problems, or if either peer
+ * chooses to short-circuit the graceful shutdown process:
+ *
+ *  * **Canceled:** the web socket connection failed. Messages that were successfully enqueued by
+ *    either peer may not have been transmitted to the other.
+ *
+ * Note that the state progression is independent for each peer. Arriving at a gracefully-closed
+ * state indicates that a peer has sent all of its outgoing messages and received all of its
+ * incoming messages. But it does not guarantee that the other peer will successfully receive all of
+ * its incoming messages.
+ */
+interface WebSocket {
+  /** Returns the original request that initiated this web socket. */
+  fun request(): Request
+
+  /**
+   * Returns the size in bytes of all messages enqueued to be transmitted to the server. This
+   * doesn't include framing overhead. It also doesn't include any bytes buffered by the operating
+   * system or network intermediaries. This method returns 0 if no messages are waiting in the
+   * queue. If may return a nonzero value after the web socket has been canceled; this indicates
+   * that enqueued messages were not transmitted.
+   */
+  fun queueSize(): Long
+
+  /**
+   * Attempts to enqueue `text` to be UTF-8 encoded and sent as a the data of a text (type `0x1`)
+   * message.
+   *
+   * This method returns true if the message was enqueued. Messages that would overflow the outgoing
+   * message buffer will be rejected and trigger a [graceful shutdown][close] of this web socket.
+   * This method returns false in that case, and in any other case where this web socket is closing,
+   * closed, or canceled.
+   *
+   * This method returns immediately.
+   */
+  fun send(text: String): Boolean
+
+  /**
+   * Attempts to enqueue `bytes` to be sent as a the data of a binary (type `0x2`) message.
+   *
+   * This method returns true if the message was enqueued. Messages that would overflow the outgoing
+   * message buffer (16 MiB) will be rejected and trigger a [graceful shutdown][close] of this web
+   * socket. This method returns false in that case, and in any other case where this web socket is
+   * closing, closed, or canceled.
+   *
+   * This method returns immediately.
+   */
+  fun send(bytes: ByteString): Boolean
+
+  /**
+   * Attempts to initiate a graceful shutdown of this web socket. Any already-enqueued messages will
+   * be transmitted before the close message is sent but subsequent calls to [send] will return
+   * false and their messages will not be enqueued.
+   *
+   * This returns true if a graceful shutdown was initiated by this call. It returns false if
+   * a graceful shutdown was already underway or if the web socket is already closed or canceled.
+   *
+   * @param code Status code as defined by
+   *     [Section 7.4 of RFC 6455](http://tools.ietf.org/html/rfc6455#section-7.4).
+   * @param reason Reason for shutting down or null.
+   * @throws IllegalArgumentException if code is invalid.
+   */
+  fun close(code: Int, reason: String?): Boolean
+
+  /**
+   * Immediately and violently release resources held by this web socket, discarding any enqueued
+   * messages. This does nothing if the web socket has already been closed or canceled.
+   */
+  fun cancel()
+
+  interface Factory {
+    /**
+     * Creates a new web socket and immediately returns it. Creating a web socket initiates an
+     * asynchronous process to connect the socket. Once that succeeds or fails, `listener` will be
+     * notified. The caller must either close or cancel the returned web socket when it is no longer
+     * in use.
+     */
+    fun newWebSocket(request: Request, listener: WebSocketListener): WebSocket
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/WebSocketListener.java b/okhttp/src/main/java/okhttp3/WebSocketListener.kt
similarity index 63%
rename from okhttp/src/main/java/okhttp3/WebSocketListener.java
rename to okhttp/src/main/java/okhttp3/WebSocketListener.kt
index 69276d933b..56bfef9749 100644
--- a/okhttp/src/main/java/okhttp3/WebSocketListener.java
+++ b/okhttp/src/main/java/okhttp3/WebSocketListener.kt
@@ -13,39 +13,37 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3;
+package okhttp3
 
-import javax.annotation.Nullable;
-import okio.ByteString;
+import okio.ByteString
 
-public abstract class WebSocketListener {
+abstract class WebSocketListener {
   /**
    * Invoked when a web socket has been accepted by the remote peer and may begin transmitting
    * messages.
    */
-  public void onOpen(WebSocket webSocket, Response response) {
+  open fun onOpen(webSocket: WebSocket, response: Response) {
   }
 
-  /** Invoked when a text (type {@code 0x1}) message has been received. */
-  public void onMessage(WebSocket webSocket, String text) {
+  /** Invoked when a text (type `0x1`) message has been received. */
+  open fun onMessage(webSocket: WebSocket, text: String) {
   }
 
-  /** Invoked when a binary (type {@code 0x2}) message has been received. */
-  public void onMessage(WebSocket webSocket, ByteString bytes) {
+  /** Invoked when a binary (type `0x2`) message has been received. */
+  open fun onMessage(webSocket: WebSocket, bytes: ByteString) {
   }
 
   /**
-   * Invoked when the remote peer has indicated that no more incoming messages will be
-   * transmitted.
+   * Invoked when the remote peer has indicated that no more incoming messages will be transmitted.
    */
-  public void onClosing(WebSocket webSocket, int code, String reason) {
+  open fun onClosing(webSocket: WebSocket, code: Int, reason: String) {
   }
 
   /**
    * Invoked when both peers have indicated that no more messages will be transmitted and the
    * connection has been successfully released. No further calls to this listener will be made.
    */
-  public void onClosed(WebSocket webSocket, int code, String reason) {
+  open fun onClosed(webSocket: WebSocket, code: Int, reason: String) {
   }
 
   /**
@@ -53,6 +51,6 @@ public void onClosed(WebSocket webSocket, int code, String reason) {
    * network. Both outgoing and incoming messages may have been lost. No further calls to this
    * listener will be made.
    */
-  public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response) {
+  open fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index ac4d607eb4..44a16ae774 100644
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -15,24 +15,15 @@
  */
 package okhttp3.internal;
 
-import java.io.IOException;
-import java.net.Socket;
 import javax.annotation.Nullable;
-import javax.net.ssl.SSLSocket;
 import okhttp3.Address;
 import okhttp3.Call;
 import okhttp3.ConnectionPool;
-import okhttp3.ConnectionSpec;
-import okhttp3.Headers;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.Route;
-import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.connection.RouteDatabase;
-import okhttp3.internal.connection.StreamAllocation;
-import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.connection.Exchange;
+import okhttp3.internal.connection.RealConnectionPool;
 
 /**
  * Escalate internal APIs in {@code okhttp3} so they can be used from OkHttp's implementation
@@ -47,39 +38,16 @@ public static void initializeInstanceForTests() {
 
   public static Internal instance;
 
-  public abstract void addLenient(Headers.Builder builder, String line);
-
-  public abstract void addLenient(Headers.Builder builder, String name, String value);
-
-  public abstract void setCache(OkHttpClient.Builder builder, InternalCache internalCache);
-
-  public abstract void acquire(ConnectionPool pool, Address address,
-      StreamAllocation streamAllocation, @Nullable Route route);
+  public abstract RealConnectionPool realConnectionPool(ConnectionPool connectionPool);
 
   public abstract boolean equalsNonHost(Address a, Address b);
 
-  public abstract @Nullable Socket deduplicate(
-      ConnectionPool pool, Address address, StreamAllocation streamAllocation);
-
-  public abstract void put(ConnectionPool pool, RealConnection connection);
-
-  public abstract boolean connectionBecameIdle(ConnectionPool pool, RealConnection connection);
-
-  public abstract RouteDatabase routeDatabase(ConnectionPool connectionPool);
-
   public abstract int code(Response.Builder responseBuilder);
 
-  public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
-      boolean isFallback);
-
-  public abstract boolean isInvalidHttpUrlHost(IllegalArgumentException e);
-
-  public abstract StreamAllocation streamAllocation(Call call);
-
-  public abstract @Nullable IOException timeoutExit(Call call, @Nullable IOException e);
-
   public abstract Call newWebSocketCall(OkHttpClient client, Request request);
 
-  public abstract void initCodec(
-      Response.Builder responseBuilder, HttpCodec httpCodec);
+  public abstract void initExchange(
+      Response.Builder responseBuilder, Exchange exchange);
+
+  public abstract @Nullable Exchange exchange(Response response);
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/InternalKt.kt b/okhttp/src/main/java/okhttp3/internal/InternalKt.kt
new file mode 100644
index 0000000000..d47c59ec97
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/InternalKt.kt
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal
+
+import okhttp3.Cache
+import okhttp3.ConnectionSpec
+import okhttp3.Cookie
+import okhttp3.Headers
+import okhttp3.HttpUrl
+import okhttp3.Request
+import javax.net.ssl.SSLSocket
+
+fun parseCookie(currentTimeMillis: Long, url: HttpUrl, setCookie: String): Cookie? =
+    Cookie.parse(currentTimeMillis, url, setCookie)
+
+fun cookieToString(cookie: Cookie, forObsoleteRfc2965: Boolean) =
+    cookie.toString(forObsoleteRfc2965)
+
+fun addHeaderLenient(builder: Headers.Builder, line: String) =
+    builder.addLenient(line)
+
+fun addHeaderLenient(builder: Headers.Builder, name: String, value: String) =
+    builder.addLenient(name, value)
+
+fun cacheGet(cache: Cache, request: Request) = cache.get(request)
+
+fun applyConnectionSpec(connectionSpec: ConnectionSpec, sslSocket: SSLSocket, isFallback: Boolean) =
+    connectionSpec.apply(sslSocket, isFallback)
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 5315a6b685..9c3f710799 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -18,8 +18,6 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 import java.net.IDN;
 import java.net.InetAddress;
 import java.net.ServerSocket;
@@ -27,8 +25,6 @@
 import java.net.UnknownHostException;
 import java.nio.charset.Charset;
 import java.security.AccessControlException;
-import java.security.GeneralSecurityException;
-import java.security.KeyStore;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -42,14 +38,14 @@
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
+import okhttp3.EventListener;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
 import okhttp3.internal.http2.Header;
+import okhttp3.internal.platform.Platform;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -59,6 +55,8 @@
 import static java.nio.charset.StandardCharsets.UTF_16BE;
 import static java.nio.charset.StandardCharsets.UTF_16LE;
 import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Arrays.asList;
+import static okhttp3.internal.InternalKtKt.addHeaderLenient;
 
 /** Junk drawer of utility methods. */
 public final class Util {
@@ -86,27 +84,6 @@
 
   public static final Comparator<String> NATURAL_ORDER = String::compareTo;
 
-  private static final Method addSuppressedExceptionMethod;
-
-  static {
-    Method m;
-    try {
-      m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
-    } catch (Exception e) {
-      m = null;
-    }
-    addSuppressedExceptionMethod = m;
-  }
-
-  public static void addSuppressedIfPossible(Throwable e, Throwable suppressed) {
-    if (addSuppressedExceptionMethod != null) {
-      try {
-        addSuppressedExceptionMethod.invoke(e, suppressed);
-      } catch (InvocationTargetException | IllegalAccessException ignored) {
-      }
-    }
-  }
-
   /**
    * Quick and dirty pattern to differentiate IP addresses from hostnames. This is an approximation
    * of Android's private InetAddress#isNumeric API.
@@ -231,7 +208,7 @@ public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) th
   /** Returns an immutable list containing {@code elements}. */
   @SafeVarargs
   public static <T> List<T> immutableList(T... elements) {
-    return Collections.unmodifiableList(Arrays.asList(elements.clone()));
+    return Collections.unmodifiableList(asList(elements.clone()));
   }
 
   public static ThreadFactory threadFactory(String name, boolean daemon) {
@@ -257,7 +234,7 @@ public static ThreadFactory threadFactory(String name, boolean daemon) {
         }
       }
     }
-    return result.toArray(new String[result.size()]);
+    return result.toArray(new String[0]);
   }
 
   /**
@@ -307,8 +284,7 @@ public static int indexOf(Comparator<String> comparator, String[] array, String
   }
 
   public static String[] concat(String[] array, String value) {
-    String[] result = new String[array.length + 1];
-    System.arraycopy(array, 0, result, 0, array.length);
+    String[] result = Arrays.copyOf(array, array.length + 1);
     result[result.length - 1] = value;
     return result;
   }
@@ -634,25 +610,13 @@ private static String inet6AddressToAscii(byte[] address) {
   }
 
   public static X509TrustManager platformTrustManager() {
-    try {
-      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-          TrustManagerFactory.getDefaultAlgorithm());
-      trustManagerFactory.init((KeyStore) null);
-      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-        throw new IllegalStateException("Unexpected default trust managers:"
-            + Arrays.toString(trustManagers));
-      }
-      return (X509TrustManager) trustManagers[0];
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError("No System TLS", e); // The system has no TLS. Just give up.
-    }
+    return Platform.get().platformTrustManager();
   }
 
   public static Headers toHeaders(List<Header> headerBlock) {
     Headers.Builder builder = new Headers.Builder();
     for (Header header : headerBlock) {
-      Internal.instance.addLenient(builder, header.name.utf8(), header.value.utf8());
+      addHeaderLenient(builder, header.name.utf8(), header.value.utf8());
     }
     return builder.build();
   }
@@ -666,7 +630,7 @@ public static Headers toHeaders(List<Header> headerBlock) {
   }
 
   /**
-   * Returns the system property, or defaultValue if the system property is null or
+   * Returns the system property, or {@code defaultValue} if the system property is null or
    * cannot be read (e.g. because of security policy restrictions).
    */
   public static String getSystemProperty(String key, @Nullable String defaultValue) {
@@ -678,4 +642,15 @@ public static String getSystemProperty(String key, @Nullable String defaultValue
     }
     return value != null ? value : defaultValue;
   }
+
+  /** Returns true if an HTTP request for {@code a} and {@code b} can reuse a connection. */
+  public static boolean sameConnection(HttpUrl a, HttpUrl b) {
+    return a.host().equals(b.host())
+        && a.port() == b.port()
+        && a.scheme().equals(b.scheme());
+  }
+
+  public static EventListener.Factory eventListenerFactory(EventListener listener) {
+    return call -> listener;
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index 30c9a135ea..4b73f5464d 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -23,9 +23,8 @@
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.ExchangeCodec;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http.HttpMethod;
 import okhttp3.internal.http.RealResponseBody;
@@ -39,6 +38,7 @@
 
 import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.InternalKtKt.addHeaderLenient;
 import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.Util.discard;
 
@@ -200,7 +200,7 @@ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response
 
       @Override public void close() throws IOException {
         if (!cacheRequestClosed
-            && !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+            && !discard(this, ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
           cacheRequestClosed = true;
           cacheRequest.abort();
         }
@@ -225,16 +225,17 @@ private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
       if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
         continue; // Drop 100-level freshness warnings.
       }
-      if (isContentSpecificHeader(fieldName) || !isEndToEnd(fieldName)
-              || networkHeaders.get(fieldName) == null) {
-        Internal.instance.addLenient(result, fieldName, value);
+      if (isContentSpecificHeader(fieldName)
+          || !isEndToEnd(fieldName)
+          || networkHeaders.get(fieldName) == null) {
+        addHeaderLenient(result, fieldName, value);
       }
     }
 
     for (int i = 0, size = networkHeaders.size(); i < size; i++) {
       String fieldName = networkHeaders.name(i);
       if (!isContentSpecificHeader(fieldName) && isEndToEnd(fieldName)) {
-        Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
+        addHeaderLenient(result, fieldName, networkHeaders.value(i));
       }
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.kt
similarity index 78%
rename from okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java
rename to okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.kt
index b4432b4e1d..245ccbf049 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.kt
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.cache;
+package okhttp3.internal.cache
 
-import java.io.IOException;
-import okio.Sink;
+import java.io.IOException
+import okio.Sink
 
-public interface CacheRequest {
-  Sink body() throws IOException;
+interface CacheRequest {
+  @Throws(IOException::class)
+  fun body(): Sink
 
-  void abort();
+  fun abort()
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
index c7fb69ceba..2753cf27f4 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -21,7 +21,6 @@
 import okhttp3.Headers;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.Internal;
 import okhttp3.internal.http.HttpDate;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http.StatusLine;
@@ -38,6 +37,7 @@
 import static java.net.HttpURLConnection.HTTP_OK;
 import static java.net.HttpURLConnection.HTTP_REQ_TOO_LONG;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.internal.InternalKtKt.addHeaderLenient;
 
 /**
  * Given a request and cached response, this figures out whether to use the network, the cache, or
@@ -253,7 +253,7 @@ private CacheStrategy getCandidate() {
       }
 
       Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();
-      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);
+      addHeaderLenient(conditionalRequestHeaders, conditionName, conditionValue);
 
       Request conditionalRequest = request.newBuilder()
           .headers(conditionalRequestHeaders.build())
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
deleted file mode 100644
index 3b193f3b91..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
+++ /dev/null
@@ -1,1047 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.io.Closeable;
-import java.io.EOFException;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.Flushable;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.NoSuchElementException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.io.FileSystem;
-import okhttp3.internal.platform.Platform;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-
-import static okhttp3.internal.platform.Platform.WARN;
-
-/**
- * A cache that uses a bounded amount of space on a filesystem. Each cache entry has a string key
- * and a fixed number of values. Each key must match the regex <strong>[a-z0-9_-]{1,64}</strong>.
- * Values are byte sequences, accessible as streams or files. Each value must be between {@code 0}
- * and {@code Integer.MAX_VALUE} bytes in length.
- *
- * <p>The cache stores its data in a directory on the filesystem. This directory must be exclusive
- * to the cache; the cache may delete or overwrite files from its directory. It is an error for
- * multiple processes to use the same cache directory at the same time.
- *
- * <p>This cache limits the number of bytes that it will store on the filesystem. When the number of
- * stored bytes exceeds the limit, the cache will remove entries in the background until the limit
- * is satisfied. The limit is not strict: the cache may temporarily exceed it while waiting for
- * files to be deleted. The limit does not include filesystem overhead or the cache journal so
- * space-sensitive applications should set a conservative limit.
- *
- * <p>Clients call {@link #edit} to create or update the values of an entry. An entry may have only
- * one editor at one time; if a value is not available to be edited then {@link #edit} will return
- * null.
- *
- * <ul>
- *     <li>When an entry is being <strong>created</strong> it is necessary to supply a full set of
- *         values; the empty value should be used as a placeholder if necessary.
- *     <li>When an entry is being <strong>edited</strong>, it is not necessary to supply data for
- *         every value; values default to their previous value.
- * </ul>
- *
- * <p>Every {@link #edit} call must be matched by a call to {@link Editor#commit} or {@link
- * Editor#abort}. Committing is atomic: a read observes the full set of values as they were before
- * or after the commit, but never a mix of values.
- *
- * <p>Clients call {@link #get} to read a snapshot of an entry. The read will observe the value at
- * the time that {@link #get} was called. Updates and removals after the call do not impact ongoing
- * reads.
- *
- * <p>This class is tolerant of some I/O errors. If files are missing from the filesystem, the
- * corresponding entries will be dropped from the cache. If an error occurs while writing a cache
- * value, the edit will fail silently. Callers should handle other problems by catching {@code
- * IOException} and responding appropriately.
- */
-public final class DiskLruCache implements Closeable, Flushable {
-  static final String JOURNAL_FILE = "journal";
-  static final String JOURNAL_FILE_TEMP = "journal.tmp";
-  static final String JOURNAL_FILE_BACKUP = "journal.bkp";
-  static final String MAGIC = "libcore.io.DiskLruCache";
-  static final String VERSION_1 = "1";
-  static final long ANY_SEQUENCE_NUMBER = -1;
-  static final Pattern LEGAL_KEY_PATTERN = Pattern.compile("[a-z0-9_-]{1,120}");
-  private static final String CLEAN = "CLEAN";
-  private static final String DIRTY = "DIRTY";
-  private static final String REMOVE = "REMOVE";
-  private static final String READ = "READ";
-
-    /*
-     * This cache uses a journal file named "journal". A typical journal file
-     * looks like this:
-     *     libcore.io.DiskLruCache
-     *     1
-     *     100
-     *     2
-     *
-     *     CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054
-     *     DIRTY 335c4c6028171cfddfbaae1a9c313c52
-     *     CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
-     *     REMOVE 335c4c6028171cfddfbaae1a9c313c52
-     *     DIRTY 1ab96a171faeeee38496d8b330771a7a
-     *     CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
-     *     READ 335c4c6028171cfddfbaae1a9c313c52
-     *     READ 3400330d1dfc7f3f7f4b8d4d803dfcf6
-     *
-     * The first five lines of the journal form its header. They are the
-     * constant string "libcore.io.DiskLruCache", the disk cache's version,
-     * the application's version, the value count, and a blank line.
-     *
-     * Each of the subsequent lines in the file is a record of the state of a
-     * cache entry. Each line contains space-separated values: a state, a key,
-     * and optional state-specific values.
-     *   o DIRTY lines track that an entry is actively being created or updated.
-     *     Every successful DIRTY action should be followed by a CLEAN or REMOVE
-     *     action. DIRTY lines without a matching CLEAN or REMOVE indicate that
-     *     temporary files may need to be deleted.
-     *   o CLEAN lines track a cache entry that has been successfully published
-     *     and may be read. A publish line is followed by the lengths of each of
-     *     its values.
-     *   o READ lines track accesses for LRU.
-     *   o REMOVE lines track entries that have been deleted.
-     *
-     * The journal file is appended to as cache operations occur. The journal may
-     * occasionally be compacted by dropping redundant lines. A temporary file named
-     * "journal.tmp" will be used during compaction; that file should be deleted if
-     * it exists when the cache is opened.
-     */
-
-  final FileSystem fileSystem;
-  final File directory;
-  private final File journalFile;
-  private final File journalFileTmp;
-  private final File journalFileBackup;
-  private final int appVersion;
-  private long maxSize;
-  final int valueCount;
-  private long size = 0;
-  BufferedSink journalWriter;
-  final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
-  int redundantOpCount;
-  boolean hasJournalErrors;
-
-  // Must be read and written when synchronized on 'this'.
-  boolean initialized;
-  boolean closed;
-  boolean mostRecentTrimFailed;
-  boolean mostRecentRebuildFailed;
-
-  /**
-   * To differentiate between old and current snapshots, each entry is given a sequence number each
-   * time an edit is committed. A snapshot is stale if its sequence number is not equal to its
-   * entry's sequence number.
-   */
-  private long nextSequenceNumber = 0;
-
-  /** Used to run 'cleanupRunnable' for journal rebuilds. */
-  private final Executor executor;
-  private final Runnable cleanupRunnable = new Runnable() {
-    public void run() {
-      synchronized (DiskLruCache.this) {
-        if (!initialized | closed) {
-          return; // Nothing to do
-        }
-
-        try {
-          trimToSize();
-        } catch (IOException ignored) {
-          mostRecentTrimFailed = true;
-        }
-
-        try {
-          if (journalRebuildRequired()) {
-            rebuildJournal();
-            redundantOpCount = 0;
-          }
-        } catch (IOException e) {
-          mostRecentRebuildFailed = true;
-          journalWriter = Okio.buffer(Okio.blackhole());
-        }
-      }
-    }
-  };
-
-  DiskLruCache(FileSystem fileSystem, File directory, int appVersion, int valueCount, long maxSize,
-      Executor executor) {
-    this.fileSystem = fileSystem;
-    this.directory = directory;
-    this.appVersion = appVersion;
-    this.journalFile = new File(directory, JOURNAL_FILE);
-    this.journalFileTmp = new File(directory, JOURNAL_FILE_TEMP);
-    this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP);
-    this.valueCount = valueCount;
-    this.maxSize = maxSize;
-    this.executor = executor;
-  }
-
-  public synchronized void initialize() throws IOException {
-    assert Thread.holdsLock(this);
-
-    if (initialized) {
-      return; // Already initialized.
-    }
-
-    // If a bkp file exists, use it instead.
-    if (fileSystem.exists(journalFileBackup)) {
-      // If journal file also exists just delete backup file.
-      if (fileSystem.exists(journalFile)) {
-        fileSystem.delete(journalFileBackup);
-      } else {
-        fileSystem.rename(journalFileBackup, journalFile);
-      }
-    }
-
-    // Prefer to pick up where we left off.
-    if (fileSystem.exists(journalFile)) {
-      try {
-        readJournal();
-        processJournal();
-        initialized = true;
-        return;
-      } catch (IOException journalIsCorrupt) {
-        Platform.get().log(WARN, "DiskLruCache " + directory + " is corrupt: "
-            + journalIsCorrupt.getMessage() + ", removing", journalIsCorrupt);
-      }
-
-      // The cache is corrupted, attempt to delete the contents of the directory. This can throw and
-      // we'll let that propagate out as it likely means there is a severe filesystem problem.
-      try {
-        delete();
-      } finally {
-        closed = false;
-      }
-    }
-
-    rebuildJournal();
-
-    initialized = true;
-  }
-
-  /**
-   * Create a cache which will reside in {@code directory}. This cache is lazily initialized on
-   * first access and will be created if it does not exist.
-   *
-   * @param directory a writable directory
-   * @param valueCount the number of values per cache entry. Must be positive.
-   * @param maxSize the maximum number of bytes this cache should use to store
-   */
-  public static DiskLruCache create(FileSystem fileSystem, File directory, int appVersion,
-      int valueCount, long maxSize) {
-    if (maxSize <= 0) {
-      throw new IllegalArgumentException("maxSize <= 0");
-    }
-    if (valueCount <= 0) {
-      throw new IllegalArgumentException("valueCount <= 0");
-    }
-
-    // Use a single background thread to evict entries.
-    Executor executor = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
-        new LinkedBlockingQueue<>(), Util.threadFactory("OkHttp DiskLruCache", true));
-
-    return new DiskLruCache(fileSystem, directory, appVersion, valueCount, maxSize, executor);
-  }
-
-  private void readJournal() throws IOException {
-    try (BufferedSource source = Okio.buffer(fileSystem.source(journalFile))) {
-      String magic = source.readUtf8LineStrict();
-      String version = source.readUtf8LineStrict();
-      String appVersionString = source.readUtf8LineStrict();
-      String valueCountString = source.readUtf8LineStrict();
-      String blank = source.readUtf8LineStrict();
-      if (!MAGIC.equals(magic)
-          || !VERSION_1.equals(version)
-          || !Integer.toString(appVersion).equals(appVersionString)
-          || !Integer.toString(valueCount).equals(valueCountString)
-          || !"".equals(blank)) {
-        throw new IOException("unexpected journal header: [" + magic + ", " + version + ", "
-            + valueCountString + ", " + blank + "]");
-      }
-
-      int lineCount = 0;
-      while (true) {
-        try {
-          readJournalLine(source.readUtf8LineStrict());
-          lineCount++;
-        } catch (EOFException endOfJournal) {
-          break;
-        }
-      }
-      redundantOpCount = lineCount - lruEntries.size();
-
-      // If we ended on a truncated line, rebuild the journal before appending to it.
-      if (!source.exhausted()) {
-        rebuildJournal();
-      } else {
-        journalWriter = newJournalWriter();
-      }
-    }
-  }
-
-  private BufferedSink newJournalWriter() throws FileNotFoundException {
-    Sink fileSink = fileSystem.appendingSink(journalFile);
-    Sink faultHidingSink = new FaultHidingSink(fileSink) {
-      @Override protected void onException(IOException e) {
-        assert (Thread.holdsLock(DiskLruCache.this));
-        hasJournalErrors = true;
-      }
-    };
-    return Okio.buffer(faultHidingSink);
-  }
-
-  private void readJournalLine(String line) throws IOException {
-    int firstSpace = line.indexOf(' ');
-    if (firstSpace == -1) {
-      throw new IOException("unexpected journal line: " + line);
-    }
-
-    int keyBegin = firstSpace + 1;
-    int secondSpace = line.indexOf(' ', keyBegin);
-    final String key;
-    if (secondSpace == -1) {
-      key = line.substring(keyBegin);
-      if (firstSpace == REMOVE.length() && line.startsWith(REMOVE)) {
-        lruEntries.remove(key);
-        return;
-      }
-    } else {
-      key = line.substring(keyBegin, secondSpace);
-    }
-
-    Entry entry = lruEntries.get(key);
-    if (entry == null) {
-      entry = new Entry(key);
-      lruEntries.put(key, entry);
-    }
-
-    if (secondSpace != -1 && firstSpace == CLEAN.length() && line.startsWith(CLEAN)) {
-      String[] parts = line.substring(secondSpace + 1).split(" ");
-      entry.readable = true;
-      entry.currentEditor = null;
-      entry.setLengths(parts);
-    } else if (secondSpace == -1 && firstSpace == DIRTY.length() && line.startsWith(DIRTY)) {
-      entry.currentEditor = new Editor(entry);
-    } else if (secondSpace == -1 && firstSpace == READ.length() && line.startsWith(READ)) {
-      // This work was already done by calling lruEntries.get().
-    } else {
-      throw new IOException("unexpected journal line: " + line);
-    }
-  }
-
-  /**
-   * Computes the initial size and collects garbage as a part of opening the cache. Dirty entries
-   * are assumed to be inconsistent and will be deleted.
-   */
-  private void processJournal() throws IOException {
-    fileSystem.delete(journalFileTmp);
-    for (Iterator<Entry> i = lruEntries.values().iterator(); i.hasNext(); ) {
-      Entry entry = i.next();
-      if (entry.currentEditor == null) {
-        for (int t = 0; t < valueCount; t++) {
-          size += entry.lengths[t];
-        }
-      } else {
-        entry.currentEditor = null;
-        for (int t = 0; t < valueCount; t++) {
-          fileSystem.delete(entry.cleanFiles[t]);
-          fileSystem.delete(entry.dirtyFiles[t]);
-        }
-        i.remove();
-      }
-    }
-  }
-
-  /**
-   * Creates a new journal that omits redundant information. This replaces the current journal if it
-   * exists.
-   */
-  synchronized void rebuildJournal() throws IOException {
-    if (journalWriter != null) {
-      journalWriter.close();
-    }
-
-    try (BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp))) {
-      writer.writeUtf8(MAGIC).writeByte('\n');
-      writer.writeUtf8(VERSION_1).writeByte('\n');
-      writer.writeDecimalLong(appVersion).writeByte('\n');
-      writer.writeDecimalLong(valueCount).writeByte('\n');
-      writer.writeByte('\n');
-
-      for (Entry entry : lruEntries.values()) {
-        if (entry.currentEditor != null) {
-          writer.writeUtf8(DIRTY).writeByte(' ');
-          writer.writeUtf8(entry.key);
-          writer.writeByte('\n');
-        } else {
-          writer.writeUtf8(CLEAN).writeByte(' ');
-          writer.writeUtf8(entry.key);
-          entry.writeLengths(writer);
-          writer.writeByte('\n');
-        }
-      }
-    }
-
-    if (fileSystem.exists(journalFile)) {
-      fileSystem.rename(journalFile, journalFileBackup);
-    }
-    fileSystem.rename(journalFileTmp, journalFile);
-    fileSystem.delete(journalFileBackup);
-
-    journalWriter = newJournalWriter();
-    hasJournalErrors = false;
-    mostRecentRebuildFailed = false;
-  }
-
-  /**
-   * Returns a snapshot of the entry named {@code key}, or null if it doesn't exist is not currently
-   * readable. If a value is returned, it is moved to the head of the LRU queue.
-   */
-  public synchronized Snapshot get(String key) throws IOException {
-    initialize();
-
-    checkNotClosed();
-    validateKey(key);
-    Entry entry = lruEntries.get(key);
-    if (entry == null || !entry.readable) return null;
-
-    Snapshot snapshot = entry.snapshot();
-    if (snapshot == null) return null;
-
-    redundantOpCount++;
-    journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\n');
-    if (journalRebuildRequired()) {
-      executor.execute(cleanupRunnable);
-    }
-
-    return snapshot;
-  }
-
-  /**
-   * Returns an editor for the entry named {@code key}, or null if another edit is in progress.
-   */
-  public @Nullable Editor edit(String key) throws IOException {
-    return edit(key, ANY_SEQUENCE_NUMBER);
-  }
-
-  synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException {
-    initialize();
-
-    checkNotClosed();
-    validateKey(key);
-    Entry entry = lruEntries.get(key);
-    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER && (entry == null
-        || entry.sequenceNumber != expectedSequenceNumber)) {
-      return null; // Snapshot is stale.
-    }
-    if (entry != null && entry.currentEditor != null) {
-      return null; // Another edit is in progress.
-    }
-    if (mostRecentTrimFailed || mostRecentRebuildFailed) {
-      // The OS has become our enemy! If the trim job failed, it means we are storing more data than
-      // requested by the user. Do not allow edits so we do not go over that limit any further. If
-      // the journal rebuild failed, the journal writer will not be active, meaning we will not be
-      // able to record the edit, causing file leaks. In both cases, we want to retry the clean up
-      // so we can get out of this state!
-      executor.execute(cleanupRunnable);
-      return null;
-    }
-
-    // Flush the journal before creating files to prevent file leaks.
-    journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n');
-    journalWriter.flush();
-
-    if (hasJournalErrors) {
-      return null; // Don't edit; the journal can't be written.
-    }
-
-    if (entry == null) {
-      entry = new Entry(key);
-      lruEntries.put(key, entry);
-    }
-    Editor editor = new Editor(entry);
-    entry.currentEditor = editor;
-    return editor;
-  }
-
-  /** Returns the directory where this cache stores its data. */
-  public File getDirectory() {
-    return directory;
-  }
-
-  /**
-   * Returns the maximum number of bytes that this cache should use to store its data.
-   */
-  public synchronized long getMaxSize() {
-    return maxSize;
-  }
-
-  /**
-   * Changes the maximum number of bytes the cache can store and queues a job to trim the existing
-   * store, if necessary.
-   */
-  public synchronized void setMaxSize(long maxSize) {
-    this.maxSize = maxSize;
-    if (initialized) {
-      executor.execute(cleanupRunnable);
-    }
-  }
-
-  /**
-   * Returns the number of bytes currently being used to store the values in this cache. This may be
-   * greater than the max size if a background deletion is pending.
-   */
-  public synchronized long size() throws IOException {
-    initialize();
-    return size;
-  }
-
-  synchronized void completeEdit(Editor editor, boolean success) throws IOException {
-    Entry entry = editor.entry;
-    if (entry.currentEditor != editor) {
-      throw new IllegalStateException();
-    }
-
-    // If this edit is creating the entry for the first time, every index must have a value.
-    if (success && !entry.readable) {
-      for (int i = 0; i < valueCount; i++) {
-        if (!editor.written[i]) {
-          editor.abort();
-          throw new IllegalStateException("Newly created entry didn't create value for index " + i);
-        }
-        if (!fileSystem.exists(entry.dirtyFiles[i])) {
-          editor.abort();
-          return;
-        }
-      }
-    }
-
-    for (int i = 0; i < valueCount; i++) {
-      File dirty = entry.dirtyFiles[i];
-      if (success) {
-        if (fileSystem.exists(dirty)) {
-          File clean = entry.cleanFiles[i];
-          fileSystem.rename(dirty, clean);
-          long oldLength = entry.lengths[i];
-          long newLength = fileSystem.size(clean);
-          entry.lengths[i] = newLength;
-          size = size - oldLength + newLength;
-        }
-      } else {
-        fileSystem.delete(dirty);
-      }
-    }
-
-    redundantOpCount++;
-    entry.currentEditor = null;
-    if (entry.readable | success) {
-      entry.readable = true;
-      journalWriter.writeUtf8(CLEAN).writeByte(' ');
-      journalWriter.writeUtf8(entry.key);
-      entry.writeLengths(journalWriter);
-      journalWriter.writeByte('\n');
-      if (success) {
-        entry.sequenceNumber = nextSequenceNumber++;
-      }
-    } else {
-      lruEntries.remove(entry.key);
-      journalWriter.writeUtf8(REMOVE).writeByte(' ');
-      journalWriter.writeUtf8(entry.key);
-      journalWriter.writeByte('\n');
-    }
-    journalWriter.flush();
-
-    if (size > maxSize || journalRebuildRequired()) {
-      executor.execute(cleanupRunnable);
-    }
-  }
-
-  /**
-   * We only rebuild the journal when it will halve the size of the journal and eliminate at least
-   * 2000 ops.
-   */
-  boolean journalRebuildRequired() {
-    final int redundantOpCompactThreshold = 2000;
-    return redundantOpCount >= redundantOpCompactThreshold
-        && redundantOpCount >= lruEntries.size();
-  }
-
-  /**
-   * Drops the entry for {@code key} if it exists and can be removed. If the entry for {@code key}
-   * is currently being edited, that edit will complete normally but its value will not be stored.
-   *
-   * @return true if an entry was removed.
-   */
-  public synchronized boolean remove(String key) throws IOException {
-    initialize();
-
-    checkNotClosed();
-    validateKey(key);
-    Entry entry = lruEntries.get(key);
-    if (entry == null) return false;
-    boolean removed = removeEntry(entry);
-    if (removed && size <= maxSize) mostRecentTrimFailed = false;
-    return removed;
-  }
-
-  boolean removeEntry(Entry entry) throws IOException {
-    if (entry.currentEditor != null) {
-      entry.currentEditor.detach(); // Prevent the edit from completing normally.
-    }
-
-    for (int i = 0; i < valueCount; i++) {
-      fileSystem.delete(entry.cleanFiles[i]);
-      size -= entry.lengths[i];
-      entry.lengths[i] = 0;
-    }
-
-    redundantOpCount++;
-    journalWriter.writeUtf8(REMOVE).writeByte(' ').writeUtf8(entry.key).writeByte('\n');
-    lruEntries.remove(entry.key);
-
-    if (journalRebuildRequired()) {
-      executor.execute(cleanupRunnable);
-    }
-
-    return true;
-  }
-
-  /** Returns true if this cache has been closed. */
-  public synchronized boolean isClosed() {
-    return closed;
-  }
-
-  private synchronized void checkNotClosed() {
-    if (isClosed()) {
-      throw new IllegalStateException("cache is closed");
-    }
-  }
-
-  /** Force buffered operations to the filesystem. */
-  @Override public synchronized void flush() throws IOException {
-    if (!initialized) return;
-
-    checkNotClosed();
-    trimToSize();
-    journalWriter.flush();
-  }
-
-  /** Closes this cache. Stored values will remain on the filesystem. */
-  @Override public synchronized void close() throws IOException {
-    if (!initialized || closed) {
-      closed = true;
-      return;
-    }
-    // Copying for safe iteration.
-    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
-      if (entry.currentEditor != null) {
-        entry.currentEditor.abort();
-      }
-    }
-    trimToSize();
-    journalWriter.close();
-    journalWriter = null;
-    closed = true;
-  }
-
-  void trimToSize() throws IOException {
-    while (size > maxSize) {
-      Entry toEvict = lruEntries.values().iterator().next();
-      removeEntry(toEvict);
-    }
-    mostRecentTrimFailed = false;
-  }
-
-  /**
-   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
-   * directory including files that weren't created by the cache.
-   */
-  public void delete() throws IOException {
-    close();
-    fileSystem.deleteContents(directory);
-  }
-
-  /**
-   * Deletes all stored values from the cache. In-flight edits will complete normally but their
-   * values will not be stored.
-   */
-  public synchronized void evictAll() throws IOException {
-    initialize();
-    // Copying for safe iteration.
-    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
-      removeEntry(entry);
-    }
-    mostRecentTrimFailed = false;
-  }
-
-  private void validateKey(String key) {
-    Matcher matcher = LEGAL_KEY_PATTERN.matcher(key);
-    if (!matcher.matches()) {
-      throw new IllegalArgumentException(
-          "keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"");
-    }
-  }
-
-  /**
-   * Returns an iterator over the cache's current entries. This iterator doesn't throw {@code
-   * ConcurrentModificationException}, but if new entries are added while iterating, those new
-   * entries will not be returned by the iterator. If existing entries are removed during iteration,
-   * they will be absent (unless they were already returned).
-   *
-   * <p>If there are I/O problems during iteration, this iterator fails silently. For example, if
-   * the hosting filesystem becomes unreachable, the iterator will omit elements rather than
-   * throwing exceptions.
-   *
-   * <p><strong>The caller must {@link Snapshot#close close}</strong> each snapshot returned by
-   * {@link Iterator#next}. Failing to do so leaks open files!
-   *
-   * <p>The returned iterator supports {@link Iterator#remove}.
-   */
-  public synchronized Iterator<Snapshot> snapshots() throws IOException {
-    initialize();
-    return new Iterator<Snapshot>() {
-      /** Iterate a copy of the entries to defend against concurrent modification errors. */
-      final Iterator<Entry> delegate = new ArrayList<>(lruEntries.values()).iterator();
-
-      /** The snapshot to return from {@link #next}. Null if we haven't computed that yet. */
-      Snapshot nextSnapshot;
-
-      /** The snapshot to remove with {@link #remove}. Null if removal is illegal. */
-      Snapshot removeSnapshot;
-
-      @Override public boolean hasNext() {
-        if (nextSnapshot != null) return true;
-
-        synchronized (DiskLruCache.this) {
-          // If the cache is closed, truncate the iterator.
-          if (closed) return false;
-
-          while (delegate.hasNext()) {
-            Entry entry = delegate.next();
-            Snapshot snapshot = entry.snapshot();
-            if (snapshot == null) continue; // Evicted since we copied the entries.
-            nextSnapshot = snapshot;
-            return true;
-          }
-        }
-
-        return false;
-      }
-
-      @Override public Snapshot next() {
-        if (!hasNext()) throw new NoSuchElementException();
-        removeSnapshot = nextSnapshot;
-        nextSnapshot = null;
-        return removeSnapshot;
-      }
-
-      @Override public void remove() {
-        if (removeSnapshot == null) throw new IllegalStateException("remove() before next()");
-        try {
-          DiskLruCache.this.remove(removeSnapshot.key);
-        } catch (IOException ignored) {
-          // Nothing useful to do here. We failed to remove from the cache. Most likely that's
-          // because we couldn't update the journal, but the cached entry will still be gone.
-        } finally {
-          removeSnapshot = null;
-        }
-      }
-    };
-  }
-
-  /** A snapshot of the values for an entry. */
-  public final class Snapshot implements Closeable {
-    private final String key;
-    private final long sequenceNumber;
-    private final Source[] sources;
-    private final long[] lengths;
-
-    Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
-      this.key = key;
-      this.sequenceNumber = sequenceNumber;
-      this.sources = sources;
-      this.lengths = lengths;
-    }
-
-    public String key() {
-      return key;
-    }
-
-    /**
-     * Returns an editor for this snapshot's entry, or null if either the entry has changed since
-     * this snapshot was created or if another edit is in progress.
-     */
-    public @Nullable Editor edit() throws IOException {
-      return DiskLruCache.this.edit(key, sequenceNumber);
-    }
-
-    /** Returns the unbuffered stream with the value for {@code index}. */
-    public Source getSource(int index) {
-      return sources[index];
-    }
-
-    /** Returns the byte length of the value for {@code index}. */
-    public long getLength(int index) {
-      return lengths[index];
-    }
-
-    public void close() {
-      for (Source in : sources) {
-        Util.closeQuietly(in);
-      }
-    }
-  }
-
-  /** Edits the values for an entry. */
-  public final class Editor {
-    final Entry entry;
-    final boolean[] written;
-    private boolean done;
-
-    Editor(Entry entry) {
-      this.entry = entry;
-      this.written = (entry.readable) ? null : new boolean[valueCount];
-    }
-
-    /**
-     * Prevents this editor from completing normally. This is necessary either when the edit causes
-     * an I/O error, or if the target entry is evicted while this editor is active. In either case
-     * we delete the editor's created files and prevent new files from being created. Note that once
-     * an editor has been detached it is possible for another editor to edit the entry.
-     */
-    void detach() {
-      if (entry.currentEditor == this) {
-        for (int i = 0; i < valueCount; i++) {
-          try {
-            fileSystem.delete(entry.dirtyFiles[i]);
-          } catch (IOException e) {
-            // This file is potentially leaked. Not much we can do about that.
-          }
-        }
-        entry.currentEditor = null;
-      }
-    }
-
-    /**
-     * Returns an unbuffered input stream to read the last committed value, or null if no value has
-     * been committed.
-     */
-    public Source newSource(int index) {
-      synchronized (DiskLruCache.this) {
-        if (done) {
-          throw new IllegalStateException();
-        }
-        if (!entry.readable || entry.currentEditor != this) {
-          return null;
-        }
-        try {
-          return fileSystem.source(entry.cleanFiles[index]);
-        } catch (FileNotFoundException e) {
-          return null;
-        }
-      }
-    }
-
-    /**
-     * Returns a new unbuffered output stream to write the value at {@code index}. If the underlying
-     * output stream encounters errors when writing to the filesystem, this edit will be aborted
-     * when {@link #commit} is called. The returned output stream does not throw IOExceptions.
-     */
-    public Sink newSink(int index) {
-      synchronized (DiskLruCache.this) {
-        if (done) {
-          throw new IllegalStateException();
-        }
-        if (entry.currentEditor != this) {
-          return Okio.blackhole();
-        }
-        if (!entry.readable) {
-          written[index] = true;
-        }
-        File dirtyFile = entry.dirtyFiles[index];
-        Sink sink;
-        try {
-          sink = fileSystem.sink(dirtyFile);
-        } catch (FileNotFoundException e) {
-          return Okio.blackhole();
-        }
-        return new FaultHidingSink(sink) {
-          @Override protected void onException(IOException e) {
-            synchronized (DiskLruCache.this) {
-              detach();
-            }
-          }
-        };
-      }
-    }
-
-    /**
-     * Commits this edit so it is visible to readers.  This releases the edit lock so another edit
-     * may be started on the same key.
-     */
-    public void commit() throws IOException {
-      synchronized (DiskLruCache.this) {
-        if (done) {
-          throw new IllegalStateException();
-        }
-        if (entry.currentEditor == this) {
-          completeEdit(this, true);
-        }
-        done = true;
-      }
-    }
-
-    /**
-     * Aborts this edit. This releases the edit lock so another edit may be started on the same
-     * key.
-     */
-    public void abort() throws IOException {
-      synchronized (DiskLruCache.this) {
-        if (done) {
-          throw new IllegalStateException();
-        }
-        if (entry.currentEditor == this) {
-          completeEdit(this, false);
-        }
-        done = true;
-      }
-    }
-
-    public void abortUnlessCommitted() {
-      synchronized (DiskLruCache.this) {
-        if (!done && entry.currentEditor == this) {
-          try {
-            completeEdit(this, false);
-          } catch (IOException ignored) {
-          }
-        }
-      }
-    }
-  }
-
-  private final class Entry {
-    final String key;
-
-    /** Lengths of this entry's files. */
-    final long[] lengths;
-    final File[] cleanFiles;
-    final File[] dirtyFiles;
-
-    /** True if this entry has ever been published. */
-    boolean readable;
-
-    /** The ongoing edit or null if this entry is not being edited. */
-    Editor currentEditor;
-
-    /** The sequence number of the most recently committed edit to this entry. */
-    long sequenceNumber;
-
-    Entry(String key) {
-      this.key = key;
-
-      lengths = new long[valueCount];
-      cleanFiles = new File[valueCount];
-      dirtyFiles = new File[valueCount];
-
-      // The names are repetitive so re-use the same builder to avoid allocations.
-      StringBuilder fileBuilder = new StringBuilder(key).append('.');
-      int truncateTo = fileBuilder.length();
-      for (int i = 0; i < valueCount; i++) {
-        fileBuilder.append(i);
-        cleanFiles[i] = new File(directory, fileBuilder.toString());
-        fileBuilder.append(".tmp");
-        dirtyFiles[i] = new File(directory, fileBuilder.toString());
-        fileBuilder.setLength(truncateTo);
-      }
-    }
-
-    /** Set lengths using decimal numbers like "10123". */
-    void setLengths(String[] strings) throws IOException {
-      if (strings.length != valueCount) {
-        throw invalidLengths(strings);
-      }
-
-      try {
-        for (int i = 0; i < strings.length; i++) {
-          lengths[i] = Long.parseLong(strings[i]);
-        }
-      } catch (NumberFormatException e) {
-        throw invalidLengths(strings);
-      }
-    }
-
-    /** Append space-prefixed lengths to {@code writer}. */
-    void writeLengths(BufferedSink writer) throws IOException {
-      for (long length : lengths) {
-        writer.writeByte(' ').writeDecimalLong(length);
-      }
-    }
-
-    private IOException invalidLengths(String[] strings) throws IOException {
-      throw new IOException("unexpected journal line: " + Arrays.toString(strings));
-    }
-
-    /**
-     * Returns a snapshot of this entry. This opens all streams eagerly to guarantee that we see a
-     * single published snapshot. If we opened streams lazily then the streams could come from
-     * different edits.
-     */
-    Snapshot snapshot() {
-      if (!Thread.holdsLock(DiskLruCache.this)) throw new AssertionError();
-
-      Source[] sources = new Source[valueCount];
-      long[] lengths = this.lengths.clone(); // Defensive copy since these can be zeroed out.
-      try {
-        for (int i = 0; i < valueCount; i++) {
-          sources[i] = fileSystem.source(cleanFiles[i]);
-        }
-        return new Snapshot(key, sequenceNumber, sources, lengths);
-      } catch (FileNotFoundException e) {
-        // A file must have been deleted manually!
-        for (int i = 0; i < valueCount; i++) {
-          if (sources[i] != null) {
-            Util.closeQuietly(sources[i]);
-          } else {
-            break;
-          }
-        }
-        // Since the entry is no longer valid, remove it so the metadata is accurate (i.e. the cache
-        // size.)
-        try {
-          removeEntry(this);
-        } catch (IOException ignored) {
-        }
-        return null;
-      }
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
new file mode 100644
index 0000000000..a2be81ae35
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.kt
@@ -0,0 +1,1004 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache
+
+import okhttp3.internal.Util
+import okhttp3.internal.cache.DiskLruCache.Editor
+import okhttp3.internal.io.FileSystem
+import okhttp3.internal.platform.Platform
+import okhttp3.internal.platform.Platform.Companion.WARN
+import okio.BufferedSink
+import okio.Sink
+import okio.Source
+import okio.blackholeSink
+import okio.buffer
+import java.io.Closeable
+import java.io.EOFException
+import java.io.File
+import java.io.FileNotFoundException
+import java.io.Flushable
+import java.io.IOException
+import java.util.ArrayList
+import java.util.LinkedHashMap
+import java.util.NoSuchElementException
+import java.util.concurrent.Executor
+import java.util.concurrent.LinkedBlockingQueue
+import java.util.concurrent.ThreadPoolExecutor
+import java.util.concurrent.TimeUnit
+import java.util.regex.Pattern
+
+/**
+ * A cache that uses a bounded amount of space on a filesystem. Each cache entry has a string key
+ * and a fixed number of values. Each key must match the regex `[a-z0-9_-]{1,64}`. Values are byte
+ * sequences, accessible as streams or files. Each value must be between `0` and `Int.MAX_VALUE`
+ * bytes in length.
+ *
+ * The cache stores its data in a directory on the filesystem. This directory must be exclusive to
+ * the cache; the cache may delete or overwrite files from its directory. It is an error for
+ * multiple processes to use the same cache directory at the same time.
+ *
+ * This cache limits the number of bytes that it will store on the filesystem. When the number of
+ * stored bytes exceeds the limit, the cache will remove entries in the background until the limit
+ * is satisfied. The limit is not strict: the cache may temporarily exceed it while waiting for
+ * files to be deleted. The limit does not include filesystem overhead or the cache journal so
+ * space-sensitive applications should set a conservative limit.
+ *
+ * Clients call [edit] to create or update the values of an entry. An entry may have only one editor
+ * at one time; if a value is not available to be edited then [edit] will return null.
+ *
+ *  * When an entry is being **created** it is necessary to supply a full set of values; the empty
+ *    value should be used as a placeholder if necessary.
+ *
+ *  * When an entry is being **edited**, it is not necessary to supply data for every value; values
+ *    default to their previous value.
+ *
+ * Every [edit] call must be matched by a call to [Editor.commit] or [Editor.abort]. Committing is
+ * atomic: a read observes the full set of values as they were before or after the commit, but never
+ * a mix of values.
+ *
+ * Clients call [get] to read a snapshot of an entry. The read will observe the value at the time
+ * that [get] was called. Updates and removals after the call do not impact ongoing reads.
+ *
+ * This class is tolerant of some I/O errors. If files are missing from the filesystem, the
+ * corresponding entries will be dropped from the cache. If an error occurs while writing a cache
+ * value, the edit will fail silently. Callers should handle other problems by catching
+ * `IOException` and responding appropriately.
+ */
+class DiskLruCache internal constructor(
+  internal val fileSystem: FileSystem,
+
+  /** Returns the directory where this cache stores its data.  */
+  val directory: File,
+
+  private val appVersion: Int,
+
+  internal val valueCount: Int,
+
+  /** Returns the maximum number of bytes that this cache should use to store its data. */
+  maxSize: Long,
+
+  /** Used to run 'cleanupRunnable' for journal rebuilds.  */
+  private val executor: Executor
+
+) : Closeable, Flushable {
+  /** The maximum number of bytes that this cache should use to store its data. */
+  @get:Synchronized @set:Synchronized var maxSize: Long = maxSize
+    set(value) {
+      field = value
+      if (initialized) {
+        executor.execute(cleanupRunnable) // Trim the existing store if necessary.
+      }
+    }
+
+  /*
+   * This cache uses a journal file named "journal". A typical journal file looks like this:
+   *
+   *     libcore.io.DiskLruCache
+   *     1
+   *     100
+   *     2
+   *
+   *     CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054
+   *     DIRTY 335c4c6028171cfddfbaae1a9c313c52
+   *     CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
+   *     REMOVE 335c4c6028171cfddfbaae1a9c313c52
+   *     DIRTY 1ab96a171faeeee38496d8b330771a7a
+   *     CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
+   *     READ 335c4c6028171cfddfbaae1a9c313c52
+   *     READ 3400330d1dfc7f3f7f4b8d4d803dfcf6
+   *
+   * The first five lines of the journal form its header. They are the constant string
+   * "libcore.io.DiskLruCache", the disk cache's version, the application's version, the value
+   * count, and a blank line.
+   *
+   * Each of the subsequent lines in the file is a record of the state of a cache entry. Each line
+   * contains space-separated values: a state, a key, and optional state-specific values.
+   *
+   *   o DIRTY lines track that an entry is actively being created or updated. Every successful
+   *     DIRTY action should be followed by a CLEAN or REMOVE action. DIRTY lines without a matching
+   *     CLEAN or REMOVE indicate that temporary files may need to be deleted.
+   *
+   *   o CLEAN lines track a cache entry that has been successfully published and may be read. A
+   *     publish line is followed by the lengths of each of its values.
+   *
+   *   o READ lines track accesses for LRU.
+   *
+   *   o REMOVE lines track entries that have been deleted.
+   *
+   * The journal file is appended to as cache operations occur. The journal may occasionally be
+   * compacted by dropping redundant lines. A temporary file named "journal.tmp" will be used during
+   * compaction; that file should be deleted if it exists when the cache is opened.
+   */
+
+  private val journalFile: File
+  private val journalFileTmp: File
+  private val journalFileBackup: File
+  private var size: Long = 0L
+  private var journalWriter: BufferedSink? = null
+  internal val lruEntries = LinkedHashMap<String, Entry>(0, 0.75f, true)
+  private var redundantOpCount: Int = 0
+  internal var hasJournalErrors: Boolean = false
+
+  // Must be read and written when synchronized on 'this'.
+  private var initialized: Boolean = false
+  internal var closed: Boolean = false
+  private var mostRecentTrimFailed: Boolean = false
+  private var mostRecentRebuildFailed: Boolean = false
+
+  /**
+   * To differentiate between old and current snapshots, each entry is given a sequence number each
+   * time an edit is committed. A snapshot is stale if its sequence number is not equal to its
+   * entry's sequence number.
+   */
+  private var nextSequenceNumber: Long = 0
+
+  private val cleanupRunnable = Runnable {
+    synchronized(this@DiskLruCache) {
+      if (!initialized || closed) {
+        return@Runnable // Nothing to do
+      }
+
+      try {
+        trimToSize()
+      } catch (_: IOException) {
+        mostRecentTrimFailed = true
+      }
+
+      try {
+        if (journalRebuildRequired()) {
+          rebuildJournal()
+          redundantOpCount = 0
+        }
+      } catch (_: IOException) {
+        mostRecentRebuildFailed = true
+        journalWriter = blackholeSink().buffer()
+      }
+    }
+  }
+
+  init {
+    this.journalFile = File(directory, JOURNAL_FILE)
+    this.journalFileTmp = File(directory, JOURNAL_FILE_TEMP)
+    this.journalFileBackup = File(directory, JOURNAL_FILE_BACKUP)
+  }
+
+  @Synchronized @Throws(IOException::class)
+  fun initialize() {
+    assert(Thread.holdsLock(this))
+
+    if (initialized) {
+      return // Already initialized.
+    }
+
+    // If a bkp file exists, use it instead.
+    if (fileSystem.exists(journalFileBackup)) {
+      // If journal file also exists just delete backup file.
+      if (fileSystem.exists(journalFile)) {
+        fileSystem.delete(journalFileBackup)
+      } else {
+        fileSystem.rename(journalFileBackup, journalFile)
+      }
+    }
+
+    // Prefer to pick up where we left off.
+    if (fileSystem.exists(journalFile)) {
+      try {
+        readJournal()
+        processJournal()
+        initialized = true
+        return
+      } catch (journalIsCorrupt: IOException) {
+        Platform.get().log(WARN,
+            "DiskLruCache $directory is corrupt: ${journalIsCorrupt.message}, removing",
+            journalIsCorrupt)
+      }
+
+      // The cache is corrupted, attempt to delete the contents of the directory. This can throw and
+      // we'll let that propagate out as it likely means there is a severe filesystem problem.
+      try {
+        delete()
+      } finally {
+        closed = false
+      }
+    }
+
+    rebuildJournal()
+
+    initialized = true
+  }
+
+  @Throws(IOException::class)
+  private fun readJournal() {
+    fileSystem.source(journalFile).buffer().use { source ->
+      val magic = source.readUtf8LineStrict()
+      val version = source.readUtf8LineStrict()
+      val appVersionString = source.readUtf8LineStrict()
+      val valueCountString = source.readUtf8LineStrict()
+      val blank = source.readUtf8LineStrict()
+
+      if (MAGIC != magic ||
+          VERSION_1 != version ||
+          appVersion.toString() != appVersionString ||
+          valueCount.toString() != valueCountString ||
+          blank.isNotEmpty()) {
+        throw IOException(
+            "unexpected journal header: [$magic, $version, $valueCountString, $blank]")
+      }
+
+      var lineCount = 0
+      while (true) {
+        try {
+          readJournalLine(source.readUtf8LineStrict())
+          lineCount++
+        } catch (_: EOFException) {
+          break // End of journal.
+        }
+      }
+
+      redundantOpCount = lineCount - lruEntries.size
+
+      // If we ended on a truncated line, rebuild the journal before appending to it.
+      if (!source.exhausted()) {
+        rebuildJournal()
+      } else {
+        journalWriter = newJournalWriter()
+      }
+    }
+  }
+
+  @Throws(FileNotFoundException::class)
+  private fun newJournalWriter(): BufferedSink {
+    val fileSink = fileSystem.appendingSink(journalFile)
+    val faultHidingSink = FaultHidingSink(fileSink) {
+      assert(Thread.holdsLock(this@DiskLruCache))
+      hasJournalErrors = true
+    }
+    return faultHidingSink.buffer()
+  }
+
+  @Throws(IOException::class)
+  private fun readJournalLine(line: String) {
+    val firstSpace = line.indexOf(' ')
+    if (firstSpace == -1) throw IOException("unexpected journal line: $line")
+
+    val keyBegin = firstSpace + 1
+    val secondSpace = line.indexOf(' ', keyBegin)
+    val key: String
+    if (secondSpace == -1) {
+      key = line.substring(keyBegin)
+      if (firstSpace == REMOVE.length && line.startsWith(REMOVE)) {
+        lruEntries.remove(key)
+        return
+      }
+    } else {
+      key = line.substring(keyBegin, secondSpace)
+    }
+
+    var entry: Entry? = lruEntries[key]
+    if (entry == null) {
+      entry = Entry(key)
+      lruEntries[key] = entry
+    }
+
+    when {
+      secondSpace != -1 && firstSpace == CLEAN.length && line.startsWith(CLEAN) -> {
+        val parts = line.substring(secondSpace + 1)
+            .split(" ".toRegex())
+            .toTypedArray()
+        entry.readable = true
+        entry.currentEditor = null
+        entry.setLengths(parts)
+      }
+
+      secondSpace == -1 && firstSpace == DIRTY.length && line.startsWith(DIRTY) -> {
+        entry.currentEditor = Editor(entry)
+      }
+
+      secondSpace == -1 && firstSpace == READ.length && line.startsWith(READ) -> {
+        // This work was already done by calling lruEntries.get().
+      }
+
+      else -> throw IOException("unexpected journal line: $line")
+    }
+  }
+
+  /**
+   * Computes the initial size and collects garbage as a part of opening the cache. Dirty entries
+   * are assumed to be inconsistent and will be deleted.
+   */
+  @Throws(IOException::class)
+  private fun processJournal() {
+    fileSystem.delete(journalFileTmp)
+    val i = lruEntries.values.iterator()
+    while (i.hasNext()) {
+      val entry = i.next()
+      if (entry.currentEditor == null) {
+        for (t in 0 until valueCount) {
+          size += entry.lengths[t]
+        }
+      } else {
+        entry.currentEditor = null
+        for (t in 0 until valueCount) {
+          fileSystem.delete(entry.cleanFiles[t])
+          fileSystem.delete(entry.dirtyFiles[t])
+        }
+        i.remove()
+      }
+    }
+  }
+
+  /**
+   * Creates a new journal that omits redundant information. This replaces the current journal if it
+   * exists.
+   */
+  @Synchronized @Throws(IOException::class)
+  internal fun rebuildJournal() {
+    journalWriter?.close()
+
+    fileSystem.sink(journalFileTmp).buffer().use { sink ->
+      sink.writeUtf8(MAGIC).writeByte('\n'.toInt())
+      sink.writeUtf8(VERSION_1).writeByte('\n'.toInt())
+      sink.writeDecimalLong(appVersion.toLong()).writeByte('\n'.toInt())
+      sink.writeDecimalLong(valueCount.toLong()).writeByte('\n'.toInt())
+      sink.writeByte('\n'.toInt())
+
+      for (entry in lruEntries.values) {
+        if (entry.currentEditor != null) {
+          sink.writeUtf8(DIRTY).writeByte(' '.toInt())
+          sink.writeUtf8(entry.key)
+          sink.writeByte('\n'.toInt())
+        } else {
+          sink.writeUtf8(CLEAN).writeByte(' '.toInt())
+          sink.writeUtf8(entry.key)
+          entry.writeLengths(sink)
+          sink.writeByte('\n'.toInt())
+        }
+      }
+    }
+
+    if (fileSystem.exists(journalFile)) {
+      fileSystem.rename(journalFile, journalFileBackup)
+    }
+    fileSystem.rename(journalFileTmp, journalFile)
+    fileSystem.delete(journalFileBackup)
+
+    journalWriter = newJournalWriter()
+    hasJournalErrors = false
+    mostRecentRebuildFailed = false
+  }
+
+  /**
+   * Returns a snapshot of the entry named `key`, or null if it doesn't exist is not currently
+   * readable. If a value is returned, it is moved to the head of the LRU queue.
+   */
+  @Synchronized @Throws(IOException::class)
+  operator fun get(key: String): Snapshot? {
+    initialize()
+
+    checkNotClosed()
+    validateKey(key)
+    val entry = lruEntries[key] ?: return null
+    if (!entry.readable) return null
+    val snapshot = entry.snapshot() ?: return null
+
+    redundantOpCount++
+    journalWriter!!.writeUtf8(READ)
+        .writeByte(' '.toInt())
+        .writeUtf8(key)
+        .writeByte('\n'.toInt())
+    if (journalRebuildRequired()) {
+      executor.execute(cleanupRunnable)
+    }
+
+    return snapshot
+  }
+
+  /** Returns an editor for the entry named `key`, or null if another edit is in progress. */
+  @Synchronized @Throws(IOException::class)
+  @JvmOverloads
+  fun edit(key: String, expectedSequenceNumber: Long = ANY_SEQUENCE_NUMBER): Editor? {
+    initialize()
+
+    checkNotClosed()
+    validateKey(key)
+    var entry: Entry? = lruEntries[key]
+    if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &&
+        (entry == null || entry.sequenceNumber != expectedSequenceNumber)) {
+      return null // Snapshot is stale.
+    }
+
+    if (entry?.currentEditor != null) {
+      return null // Another edit is in progress.
+    }
+
+    if (mostRecentTrimFailed || mostRecentRebuildFailed) {
+      // The OS has become our enemy! If the trim job failed, it means we are storing more data than
+      // requested by the user. Do not allow edits so we do not go over that limit any further. If
+      // the journal rebuild failed, the journal writer will not be active, meaning we will not be
+      // able to record the edit, causing file leaks. In both cases, we want to retry the clean up
+      // so we can get out of this state!
+      executor.execute(cleanupRunnable)
+      return null
+    }
+
+    // Flush the journal before creating files to prevent file leaks.
+    val journalWriter = this.journalWriter!!
+    journalWriter.writeUtf8(DIRTY)
+        .writeByte(' '.toInt())
+        .writeUtf8(key)
+        .writeByte('\n'.toInt())
+    journalWriter.flush()
+
+    if (hasJournalErrors) {
+      return null // Don't edit; the journal can't be written.
+    }
+
+    if (entry == null) {
+      entry = Entry(key)
+      lruEntries[key] = entry
+    }
+    val editor = Editor(entry)
+    entry.currentEditor = editor
+    return editor
+  }
+
+  /**
+   * Returns the number of bytes currently being used to store the values in this cache. This may be
+   * greater than the max size if a background deletion is pending.
+   */
+  @Synchronized @Throws(IOException::class)
+  fun size(): Long {
+    initialize()
+    return size
+  }
+
+  @Synchronized @Throws(IOException::class)
+  internal fun completeEdit(editor: Editor, success: Boolean) {
+    val entry = editor.entry
+    check(entry.currentEditor == editor)
+
+    // If this edit is creating the entry for the first time, every index must have a value.
+    if (success && !entry.readable) {
+      for (i in 0 until valueCount) {
+        if (!editor.written!![i]) {
+          editor.abort()
+          throw IllegalStateException("Newly created entry didn't create value for index $i")
+        }
+        if (!fileSystem.exists(entry.dirtyFiles[i])) {
+          editor.abort()
+          return
+        }
+      }
+    }
+
+    for (i in 0 until valueCount) {
+      val dirty = entry.dirtyFiles[i]
+      if (success) {
+        if (fileSystem.exists(dirty)) {
+          val clean = entry.cleanFiles[i]
+          fileSystem.rename(dirty, clean)
+          val oldLength = entry.lengths[i]
+          val newLength = fileSystem.size(clean)
+          entry.lengths[i] = newLength
+          size = size - oldLength + newLength
+        }
+      } else {
+        fileSystem.delete(dirty)
+      }
+    }
+
+    redundantOpCount++
+    entry.currentEditor = null
+    journalWriter!!.apply {
+      if (entry.readable || success) {
+        entry.readable = true
+        writeUtf8(CLEAN).writeByte(' '.toInt())
+        writeUtf8(entry.key)
+        entry.writeLengths(this)
+        writeByte('\n'.toInt())
+        if (success) {
+          entry.sequenceNumber = nextSequenceNumber++
+        }
+      } else {
+        lruEntries.remove(entry.key)
+        writeUtf8(REMOVE).writeByte(' '.toInt())
+        writeUtf8(entry.key)
+        writeByte('\n'.toInt())
+      }
+      flush()
+    }
+
+    if (size > maxSize || journalRebuildRequired()) {
+      executor.execute(cleanupRunnable)
+    }
+  }
+
+  /**
+   * We only rebuild the journal when it will halve the size of the journal and eliminate at least
+   * 2000 ops.
+   */
+  private fun journalRebuildRequired(): Boolean {
+    val redundantOpCompactThreshold = 2000
+    return redundantOpCount >= redundantOpCompactThreshold &&
+        redundantOpCount >= lruEntries.size
+  }
+
+  /**
+   * Drops the entry for [key] if it exists and can be removed. If the entry for [key] is currently
+   * being edited, that edit will complete normally but its value will not be stored.
+   *
+   * @return true if an entry was removed.
+   */
+  @Synchronized @Throws(IOException::class)
+  fun remove(key: String): Boolean {
+    initialize()
+
+    checkNotClosed()
+    validateKey(key)
+    val entry = lruEntries[key] ?: return false
+    val removed = removeEntry(entry)
+    if (removed && size <= maxSize) mostRecentTrimFailed = false
+    return removed
+  }
+
+  @Throws(IOException::class)
+  internal fun removeEntry(entry: Entry): Boolean {
+    entry.currentEditor?.detach() // Prevent the edit from completing normally.
+
+    for (i in 0 until valueCount) {
+      fileSystem.delete(entry.cleanFiles[i])
+      size -= entry.lengths[i]
+      entry.lengths[i] = 0
+    }
+
+    redundantOpCount++
+    journalWriter!!.writeUtf8(REMOVE)
+        .writeByte(' '.toInt())
+        .writeUtf8(entry.key)
+        .writeByte('\n'.toInt())
+    lruEntries.remove(entry.key)
+
+    if (journalRebuildRequired()) {
+      executor.execute(cleanupRunnable)
+    }
+
+    return true
+  }
+
+  @Synchronized private fun checkNotClosed() {
+    check(!closed) { "cache is closed" }
+  }
+
+  /** Force buffered operations to the filesystem.  */
+  @Synchronized @Throws(IOException::class)
+  override fun flush() {
+    if (!initialized) return
+
+    checkNotClosed()
+    trimToSize()
+    journalWriter!!.flush()
+  }
+
+  @Synchronized fun isClosed(): Boolean = closed
+
+  /** Closes this cache. Stored values will remain on the filesystem.  */
+  @Synchronized @Throws(IOException::class)
+  override fun close() {
+    if (!initialized || closed) {
+      closed = true
+      return
+    }
+
+    // Copying for concurrent iteration.
+    for (entry in lruEntries.values.toTypedArray()) {
+      if (entry.currentEditor != null) {
+        entry.currentEditor!!.abort()
+      }
+    }
+
+    trimToSize()
+    journalWriter!!.close()
+    journalWriter = null
+    closed = true
+  }
+
+  @Throws(IOException::class)
+  fun trimToSize() {
+    while (size > maxSize) {
+      val toEvict = lruEntries.values.iterator().next()
+      removeEntry(toEvict)
+    }
+    mostRecentTrimFailed = false
+  }
+
+  /**
+   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
+   * directory including files that weren't created by the cache.
+   */
+  @Throws(IOException::class)
+  fun delete() {
+    close()
+    fileSystem.deleteContents(directory)
+  }
+
+  /**
+   * Deletes all stored values from the cache. In-flight edits will complete normally but their
+   * values will not be stored.
+   */
+  @Synchronized @Throws(IOException::class)
+  fun evictAll() {
+    initialize()
+    // Copying for concurrent iteration.
+    for (entry in lruEntries.values.toTypedArray()) {
+      removeEntry(entry)
+    }
+    mostRecentTrimFailed = false
+  }
+
+  private fun validateKey(key: String) {
+    val matcher = LEGAL_KEY_PATTERN.matcher(key)
+    require(matcher.matches()) { "keys must match regex [a-z0-9_-]{1,120}: \"$key\"" }
+  }
+
+  /**
+   * Returns an iterator over the cache's current entries. This iterator doesn't throw
+   * `ConcurrentModificationException`, but if new entries are added while iterating, those new
+   * entries will not be returned by the iterator. If existing entries are removed during iteration,
+   * they will be absent (unless they were already returned).
+   *
+   * If there are I/O problems during iteration, this iterator fails silently. For example, if the
+   * hosting filesystem becomes unreachable, the iterator will omit elements rather than throwing
+   * exceptions.
+   *
+   * **The caller must [close][Snapshot.close]** each snapshot returned by [Iterator.next]. Failing
+   * to do so leaks open files!
+   */
+  @Synchronized @Throws(IOException::class)
+  fun snapshots(): MutableIterator<Snapshot> {
+    initialize()
+    return object : MutableIterator<Snapshot> {
+      /** Iterate a copy of the entries to defend against concurrent modification errors.  */
+      val delegate = ArrayList(lruEntries.values).iterator()
+
+      /** The snapshot to return from [next]. Null if we haven't computed that yet.  */
+      var nextSnapshot: Snapshot? = null
+
+      /** The snapshot to remove with [remove]. Null if removal is illegal.  */
+      var removeSnapshot: Snapshot? = null
+
+      override fun hasNext(): Boolean {
+        if (nextSnapshot != null) return true
+
+        synchronized(this@DiskLruCache) {
+          // If the cache is closed, truncate the iterator.
+          if (closed) return false
+
+          while (delegate.hasNext()) {
+            val entry = delegate.next()
+            val snapshot = entry.snapshot() ?: continue
+            // Evicted since we copied the entries.
+            nextSnapshot = snapshot
+            return true
+          }
+        }
+
+        return false
+      }
+
+      override fun next(): Snapshot {
+        if (!hasNext()) throw NoSuchElementException()
+        removeSnapshot = nextSnapshot
+        nextSnapshot = null
+        return removeSnapshot!!
+      }
+
+      override fun remove() {
+        val removeSnapshot = this.removeSnapshot
+        checkNotNull(removeSnapshot) { "remove() before next()" }
+        try {
+          this@DiskLruCache.remove(removeSnapshot.key())
+        } catch (_: IOException) {
+          // Nothing useful to do here. We failed to remove from the cache. Most likely that's
+          // because we couldn't update the journal, but the cached entry will still be gone.
+        } finally {
+          this.removeSnapshot = null
+        }
+      }
+    }
+  }
+
+  /** A snapshot of the values for an entry.  */
+  inner class Snapshot internal constructor(
+    private val key: String,
+    private val sequenceNumber: Long,
+    private val sources: List<Source>,
+    private val lengths: LongArray
+  ) : Closeable {
+    fun key(): String = key
+
+    /**
+     * Returns an editor for this snapshot's entry, or null if either the entry has changed since
+     * this snapshot was created or if another edit is in progress.
+     */
+    @Throws(IOException::class)
+    fun edit(): Editor? = this@DiskLruCache.edit(key, sequenceNumber)
+
+    /** Returns the unbuffered stream with the value for `index`.  */
+    fun getSource(index: Int): Source = sources[index]
+
+    /** Returns the byte length of the value for `index`.  */
+    fun getLength(index: Int): Long = lengths[index]
+
+    override fun close() {
+      for (source in sources) {
+        Util.closeQuietly(source)
+      }
+    }
+  }
+
+  /** Edits the values for an entry.  */
+  inner class Editor internal constructor(internal val entry: Entry) {
+    internal val written: BooleanArray? = if (entry.readable) null else BooleanArray(valueCount)
+    private var done: Boolean = false
+
+    /**
+     * Prevents this editor from completing normally. This is necessary either when the edit causes
+     * an I/O error, or if the target entry is evicted while this editor is active. In either case
+     * we delete the editor's created files and prevent new files from being created. Note that once
+     * an editor has been detached it is possible for another editor to edit the entry.
+     */
+    internal fun detach() {
+      if (entry.currentEditor == this) {
+        for (i in 0 until valueCount) {
+          try {
+            fileSystem.delete(entry.dirtyFiles[i])
+          } catch (_: IOException) {
+            // This file is potentially leaked. Not much we can do about that.
+          }
+        }
+        entry.currentEditor = null
+      }
+    }
+
+    /**
+     * Returns an unbuffered input stream to read the last committed value, or null if no value has
+     * been committed.
+     */
+    fun newSource(index: Int): Source? {
+      synchronized(this@DiskLruCache) {
+        check(!done)
+        if (!entry.readable || entry.currentEditor != this) {
+          return null
+        }
+        return try {
+          fileSystem.source(entry.cleanFiles[index])
+        } catch (_: FileNotFoundException) {
+          null
+        }
+      }
+    }
+
+    /**
+     * Returns a new unbuffered output stream to write the value at [index]. If the underlying
+     * output stream encounters errors when writing to the filesystem, this edit will be aborted
+     * when [commit] is called. The returned output stream does not throw IOExceptions.
+     */
+    fun newSink(index: Int): Sink {
+      synchronized(this@DiskLruCache) {
+        check(!done)
+        if (entry.currentEditor != this) {
+          return blackholeSink()
+        }
+        if (!entry.readable) {
+          written!![index] = true
+        }
+        val dirtyFile = entry.dirtyFiles[index]
+        val sink: Sink
+        try {
+          sink = fileSystem.sink(dirtyFile)
+        } catch (_: FileNotFoundException) {
+          return blackholeSink()
+        }
+        return FaultHidingSink(sink) {
+          synchronized(this@DiskLruCache) {
+            detach()
+          }
+        }
+      }
+    }
+
+    /**
+     * Commits this edit so it is visible to readers. This releases the edit lock so another edit
+     * may be started on the same key.
+     */
+    @Throws(IOException::class)
+    fun commit() {
+      synchronized(this@DiskLruCache) {
+        check(!done)
+        if (entry.currentEditor == this) {
+          completeEdit(this, true)
+        }
+        done = true
+      }
+    }
+
+    /**
+     * Aborts this edit. This releases the edit lock so another edit may be started on the same
+     * key.
+     */
+    @Throws(IOException::class)
+    fun abort() {
+      synchronized(this@DiskLruCache) {
+        check(!done)
+        if (entry.currentEditor == this) {
+          completeEdit(this, false)
+        }
+        done = true
+      }
+    }
+  }
+
+  internal inner class Entry internal constructor(
+    internal val key: String
+  ) {
+
+    /** Lengths of this entry's files.  */
+    internal val lengths: LongArray = LongArray(valueCount)
+    internal val cleanFiles = mutableListOf<File>()
+    internal val dirtyFiles = mutableListOf<File>()
+
+    /** True if this entry has ever been published.  */
+    internal var readable: Boolean = false
+
+    /** The ongoing edit or null if this entry is not being edited.  */
+    internal var currentEditor: Editor? = null
+
+    /** The sequence number of the most recently committed edit to this entry.  */
+    internal var sequenceNumber: Long = 0
+
+    init {
+      // The names are repetitive so re-use the same builder to avoid allocations.
+      val fileBuilder = StringBuilder(key).append('.')
+      val truncateTo = fileBuilder.length
+      for (i in 0 until valueCount) {
+        fileBuilder.append(i)
+        cleanFiles += File(directory, fileBuilder.toString())
+        fileBuilder.append(".tmp")
+        dirtyFiles += File(directory, fileBuilder.toString())
+        fileBuilder.setLength(truncateTo)
+      }
+    }
+
+    /** Set lengths using decimal numbers like "10123".  */
+    @Throws(IOException::class)
+    internal fun setLengths(strings: Array<String>) {
+      if (strings.size != valueCount) {
+        throw invalidLengths(strings)
+      }
+
+      try {
+        for (i in strings.indices) {
+          lengths[i] = strings[i].toLong()
+        }
+      } catch (_: NumberFormatException) {
+        throw invalidLengths(strings)
+      }
+    }
+
+    /** Append space-prefixed lengths to `writer`.  */
+    @Throws(IOException::class)
+    internal fun writeLengths(writer: BufferedSink) {
+      for (length in lengths) {
+        writer.writeByte(' '.toInt()).writeDecimalLong(length)
+      }
+    }
+
+    @Throws(IOException::class)
+    private fun invalidLengths(strings: Array<String>): IOException {
+      throw IOException("unexpected journal line: ${strings.contentToString()}")
+    }
+
+    /**
+     * Returns a snapshot of this entry. This opens all streams eagerly to guarantee that we see a
+     * single published snapshot. If we opened streams lazily then the streams could come from
+     * different edits.
+     */
+    internal fun snapshot(): Snapshot? {
+      assert(Thread.holdsLock(this@DiskLruCache))
+
+      val sources = mutableListOf<Source>()
+      val lengths = this.lengths.clone() // Defensive copy since these can be zeroed out.
+      try {
+        for (i in 0 until valueCount) {
+          sources += fileSystem.source(cleanFiles[i])
+        }
+        return Snapshot(key, sequenceNumber, sources, lengths)
+      } catch (_: FileNotFoundException) {
+        // A file must have been deleted manually!
+        for (source in sources) {
+          Util.closeQuietly(source)
+        }
+        // Since the entry is no longer valid, remove it so the metadata is accurate (i.e. the cache
+        // size.)
+        try {
+          removeEntry(this)
+        } catch (_: IOException) {
+        }
+        return null
+      }
+    }
+  }
+
+  companion object {
+    @JvmField val JOURNAL_FILE = "journal"
+    @JvmField val JOURNAL_FILE_TEMP = "journal.tmp"
+    @JvmField val JOURNAL_FILE_BACKUP = "journal.bkp"
+    @JvmField val MAGIC = "libcore.io.DiskLruCache"
+    @JvmField val VERSION_1 = "1"
+    @JvmField val ANY_SEQUENCE_NUMBER: Long = -1
+    @JvmField val LEGAL_KEY_PATTERN = Pattern.compile("[a-z0-9_-]{1,120}")
+    @JvmField val CLEAN = "CLEAN"
+    @JvmField val DIRTY = "DIRTY"
+    @JvmField val REMOVE = "REMOVE"
+    @JvmField val READ = "READ"
+
+    /**
+     * Create a cache which will reside in `directory`. This cache is lazily initialized on first
+     * access and will be created if it does not exist.
+     *
+     * @param directory a writable directory
+     * @param valueCount the number of values per cache entry. Must be positive.
+     * @param maxSize the maximum number of bytes this cache should use to store
+     */
+    @JvmStatic
+    fun create(
+      fileSystem: FileSystem,
+      directory: File,
+      appVersion: Int,
+      valueCount: Int,
+      maxSize: Long
+    ): DiskLruCache {
+      require(maxSize > 0) { "maxSize <= 0" }
+      require(valueCount > 0) { "valueCount <= 0" }
+
+      // Use a single background thread to evict entries.
+      val executor = ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
+          LinkedBlockingQueue(), Util.threadFactory("OkHttp DiskLruCache", true))
+
+      return DiskLruCache(fileSystem, directory, appVersion, valueCount, maxSize, executor)
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
deleted file mode 100644
index 561a30507e..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.io.IOException;
-import okio.Buffer;
-import okio.ForwardingSink;
-import okio.Sink;
-
-/** A sink that never throws IOExceptions, even if the underlying sink does. */
-class FaultHidingSink extends ForwardingSink {
-  private boolean hasErrors;
-
-  FaultHidingSink(Sink delegate) {
-    super(delegate);
-  }
-
-  @Override public void write(Buffer source, long byteCount) throws IOException {
-    if (hasErrors) {
-      source.skip(byteCount);
-      return;
-    }
-    try {
-      super.write(source, byteCount);
-    } catch (IOException e) {
-      hasErrors = true;
-      onException(e);
-    }
-  }
-
-  @Override public void flush() throws IOException {
-    if (hasErrors) return;
-    try {
-      super.flush();
-    } catch (IOException e) {
-      hasErrors = true;
-      onException(e);
-    }
-  }
-
-  @Override public void close() throws IOException {
-    if (hasErrors) return;
-    try {
-      super.close();
-    } catch (IOException e) {
-      hasErrors = true;
-      onException(e);
-    }
-  }
-
-  protected void onException(IOException e) {
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.kt b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.kt
new file mode 100644
index 0000000000..68de64b83f
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.kt
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache
+
+import okio.Buffer
+import okio.ForwardingSink
+import okio.Sink
+import java.io.IOException
+
+/** A sink that never throws IOExceptions, even if the underlying sink does. */
+internal open class FaultHidingSink(
+  delegate: Sink,
+  val onException: (IOException) -> Unit
+) : ForwardingSink(delegate) {
+  private var hasErrors = false
+
+  override fun write(source: Buffer, byteCount: Long) {
+    if (hasErrors) {
+      source.skip(byteCount)
+      return
+    }
+    try {
+      super.write(source, byteCount)
+    } catch (e: IOException) {
+      hasErrors = true
+      onException(e)
+    }
+  }
+
+  override fun flush() {
+    if (hasErrors) {
+      return
+    }
+    try {
+      super.flush()
+    } catch (e: IOException) {
+      hasErrors = true
+      onException(e)
+    }
+  }
+
+  override fun close() {
+    if (hasErrors) {
+      return
+    }
+    try {
+      super.close()
+    } catch (e: IOException) {
+      hasErrors = true
+      onException(e)
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.kt
similarity index 51%
rename from okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
rename to okhttp/src/main/java/okhttp3/internal/cache/InternalCache.kt
index abb953472d..f066062fec 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.kt
@@ -13,38 +13,40 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.cache;
+package okhttp3.internal.cache
 
-import java.io.IOException;
-import javax.annotation.Nullable;
-import okhttp3.Request;
-import okhttp3.Response;
+import okhttp3.Request
+import okhttp3.Response
+import java.io.IOException
 
 /**
- * OkHttp's internal cache interface. Applications shouldn't implement this: instead use {@link
- * okhttp3.Cache}.
+ * OkHttp's internal cache interface. Applications shouldn't implement this: instead use [okhttp3.Cache].
  */
-public interface InternalCache {
-  @Nullable Response get(Request request) throws IOException;
+interface InternalCache {
 
-  @Nullable CacheRequest put(Response response) throws IOException;
+  @Throws(IOException::class)
+  fun get(request: Request): Response?
+
+  @Throws(IOException::class)
+  fun put(response: Response): CacheRequest?
 
   /**
-   * Remove any cache entries for the supplied {@code request}. This is invoked when the client
+   * Remove any cache entries for the supplied [request]. This is invoked when the client
    * invalidates the cache, such as when making POST requests.
    */
-  void remove(Request request) throws IOException;
+  @Throws(IOException::class)
+  fun remove(request: Request)
 
   /**
    * Handles a conditional request hit by updating the stored cache response with the headers from
-   * {@code network}. The cached response body is not updated. If the stored response has changed
-   * since {@code cached} was returned, this does nothing.
+   * [network]. The cached response body is not updated. If the stored response has changed
+   * since [cached] was returned, this does nothing.
    */
-  void update(Response cached, Response network);
+  fun update(cached: Response, network: Response)
 
   /** Track an conditional GET that was satisfied by this cache. */
-  void trackConditionalCacheHit();
+  fun trackConditionalCacheHit()
 
-  /** Track an HTTP response being satisfied with {@code cacheStrategy}. */
-  void trackResponse(CacheStrategy cacheStrategy);
+  /** Track an HTTP response being satisfied with [cacheStrategy]. */
+  fun trackResponse(cacheStrategy: CacheStrategy)
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
deleted file mode 100644
index b8a346c03a..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.http.HttpCodec;
-import okhttp3.internal.http.RealInterceptorChain;
-
-/** Opens a connection to the target server and proceeds to the next interceptor. */
-public final class ConnectInterceptor implements Interceptor {
-  public final OkHttpClient client;
-
-  public ConnectInterceptor(OkHttpClient client) {
-    this.client = client;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    Request request = realChain.request();
-    StreamAllocation streamAllocation = realChain.streamAllocation();
-
-    // We need the network to satisfy this request. Possibly for validating a conditional GET.
-    boolean doExtensiveHealthChecks = !request.method().equals("GET");
-    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);
-    RealConnection connection = streamAllocation.connection();
-
-    return realChain.proceed(request, streamAllocation, httpCodec, connection);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.kt b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.kt
new file mode 100644
index 0000000000..961135c696
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.kt
@@ -0,0 +1,40 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.connection
+
+import java.io.IOException
+import okhttp3.Interceptor
+import okhttp3.OkHttpClient
+import okhttp3.Response
+import okhttp3.internal.http.RealInterceptorChain
+
+/** Opens a connection to the target server and proceeds to the next interceptor.  */
+class ConnectInterceptor(val client: OkHttpClient) : Interceptor {
+
+  @Throws(IOException::class)
+  override fun intercept(chain: Interceptor.Chain): Response {
+    val realChain = chain as RealInterceptorChain
+    val request = realChain.request()
+    val transmitter = realChain.transmitter()
+
+    // We need the network to satisfy this request. Possibly for validating a conditional GET.
+    val doExtensiveHealthChecks = request.method() != "GET"
+    val exchange = transmitter.newExchange(chain, doExtensiveHealthChecks)
+
+    return realChain.proceed(request, transmitter, exchange)
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
index 285a10ce46..a40b41b59d 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
@@ -27,21 +27,20 @@
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocket;
 import okhttp3.ConnectionSpec;
-import okhttp3.internal.Internal;
+import okhttp3.internal.InternalKtKt;
 
 /**
  * Handles the connection spec fallback strategy: When a secure socket connection fails due to a
  * handshake / protocol problem the connection may be retried with different protocols. Instances
  * are stateful and should be created and used for a single connection attempt.
  */
-public final class ConnectionSpecSelector {
-
+final class ConnectionSpecSelector {
   private final List<ConnectionSpec> connectionSpecs;
   private int nextModeIndex;
   private boolean isFallbackPossible;
   private boolean isFallback;
 
-  public ConnectionSpecSelector(List<ConnectionSpec> connectionSpecs) {
+  ConnectionSpecSelector(List<ConnectionSpec> connectionSpecs) {
     this.nextModeIndex = 0;
     this.connectionSpecs = connectionSpecs;
   }
@@ -52,7 +51,7 @@ public ConnectionSpecSelector(List<ConnectionSpec> connectionSpecs) {
    *
    * @throws IOException if the socket does not support any of the TLS modes available
    */
-  public ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOException {
+  ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOException {
     ConnectionSpec tlsConfiguration = null;
     for (int i = nextModeIndex, size = connectionSpecs.size(); i < size; i++) {
       ConnectionSpec connectionSpec = connectionSpecs.get(i);
@@ -75,7 +74,7 @@ public ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOExcept
 
     isFallbackPossible = isFallbackPossible(sslSocket);
 
-    Internal.instance.apply(tlsConfiguration, sslSocket, isFallback);
+    InternalKtKt.applyConnectionSpec(tlsConfiguration, sslSocket, isFallback);
 
     return tlsConfiguration;
   }
@@ -87,7 +86,7 @@ public ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOExcept
    * @return {@code true} if the connection should be retried using {@link
    * #configureSecureSocket(SSLSocket)} or {@code false} if not
    */
-  public boolean connectionFailed(IOException e) {
+  boolean connectionFailed(IOException e) {
     // Any future attempt to connect using this strategy will be a fallback attempt.
     isFallback = true;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/Exchange.java b/okhttp/src/main/java/okhttp3/internal/connection/Exchange.java
new file mode 100644
index 0000000000..a5c59fda4a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/Exchange.java
@@ -0,0 +1,326 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.net.SocketException;
+import javax.annotation.Nullable;
+import okhttp3.Call;
+import okhttp3.EventListener;
+import okhttp3.Headers;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.http.ExchangeCodec;
+import okhttp3.internal.http.RealResponseBody;
+import okhttp3.internal.ws.RealWebSocket;
+import okio.Buffer;
+import okio.ForwardingSink;
+import okio.ForwardingSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+/**
+ * Transmits a single HTTP request and a response pair. This layers connection management and events
+ * on {@link ExchangeCodec}, which handles the actual I/O.
+ */
+public final class Exchange {
+  final Transmitter transmitter;
+  final Call call;
+  final EventListener eventListener;
+  final ExchangeFinder finder;
+  final ExchangeCodec codec;
+  private boolean duplex;
+
+  public Exchange(Transmitter transmitter, Call call, EventListener eventListener,
+      ExchangeFinder finder, ExchangeCodec codec) {
+    this.transmitter = transmitter;
+    this.call = call;
+    this.eventListener = eventListener;
+    this.finder = finder;
+    this.codec = codec;
+  }
+
+  public RealConnection connection() {
+    return codec.connection();
+  }
+
+  /** Returns true if the request body need not complete before the response body starts. */
+  public boolean isDuplex() {
+    return duplex;
+  }
+
+  public void writeRequestHeaders(Request request) throws IOException {
+    try {
+      eventListener.requestHeadersStart(call);
+      codec.writeRequestHeaders(request);
+      eventListener.requestHeadersEnd(call, request);
+    } catch (IOException e) {
+      eventListener.requestFailed(call, e);
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public Sink createRequestBody(Request request, boolean duplex) throws IOException {
+    this.duplex = duplex;
+    long contentLength = request.body().contentLength();
+    eventListener.requestBodyStart(call);
+    Sink rawRequestBody = codec.createRequestBody(request, contentLength);
+    return new RequestBodySink(rawRequestBody, contentLength);
+  }
+
+  public void flushRequest() throws IOException {
+    try {
+      codec.flushRequest();
+    } catch (IOException e) {
+      eventListener.requestFailed(call, e);
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public void finishRequest() throws IOException {
+    try {
+      codec.finishRequest();
+    } catch (IOException e) {
+      eventListener.requestFailed(call, e);
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public void responseHeadersStart() {
+    eventListener.responseHeadersStart(call);
+  }
+
+  public @Nullable Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
+    try {
+      Response.Builder result = codec.readResponseHeaders(expectContinue);
+      if (result != null) {
+        Internal.instance.initExchange(result, this);
+      }
+      return result;
+    } catch (IOException e) {
+      eventListener.responseFailed(call, e);
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public void responseHeadersEnd(Response response) {
+    eventListener.responseHeadersEnd(call, response);
+  }
+
+  public ResponseBody openResponseBody(Response response) throws IOException {
+    try {
+      eventListener.responseBodyStart(call);
+      String contentType = response.header("Content-Type");
+      long contentLength = codec.reportedContentLength(response);
+      Source rawSource = codec.openResponseBodySource(response);
+      ResponseBodySource source = new ResponseBodySource(rawSource, contentLength);
+      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
+    } catch (IOException e) {
+      eventListener.responseFailed(call, e);
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public Headers trailers() throws IOException {
+    return codec.trailers();
+  }
+
+  public void timeoutEarlyExit() {
+    transmitter.timeoutEarlyExit();
+  }
+
+  public RealWebSocket.Streams newWebSocketStreams() throws SocketException {
+    transmitter.timeoutEarlyExit();
+    return codec.connection().newWebSocketStreams(this);
+  }
+
+  public void webSocketUpgradeFailed() {
+    bodyComplete(-1L, true, true, null);
+  }
+
+  public void noNewExchangesOnConnection() {
+    codec.connection().noNewExchanges();
+  }
+
+  public void cancel() {
+    codec.cancel();
+  }
+
+  /**
+   * Revoke this exchange's access to streams. This is necessary when a follow-up request is
+   * required but the preceding exchange hasn't completed yet.
+   */
+  public void detachWithViolence() {
+    codec.cancel();
+    transmitter.exchangeMessageDone(this, true, true, null);
+  }
+
+  void trackFailure(IOException e) {
+    finder.trackFailure();
+    codec.connection().trackFailure(e);
+  }
+
+  @Nullable IOException bodyComplete(
+      long bytesRead, boolean responseDone, boolean requestDone, @Nullable IOException e) {
+    if (e != null) {
+      trackFailure(e);
+    }
+    if (requestDone) {
+      if (e != null) {
+        eventListener.requestFailed(call, e);
+      } else {
+        eventListener.requestBodyEnd(call, bytesRead);
+      }
+    }
+    if (responseDone) {
+      if (e != null) {
+        eventListener.responseFailed(call, e);
+      } else {
+        eventListener.responseBodyEnd(call, bytesRead);
+      }
+    }
+    return transmitter.exchangeMessageDone(this, requestDone, responseDone, e);
+  }
+
+  public void noRequestBody() {
+    transmitter.exchangeMessageDone(this, true, false, null);
+  }
+
+  /** A request body that fires events when it completes. */
+  private final class RequestBodySink extends ForwardingSink {
+    private boolean completed;
+    /** The exact number of bytes to be written, or -1L if that is unknown. */
+    private long contentLength;
+    private long bytesReceived;
+    private boolean closed;
+
+    RequestBodySink(Sink delegate, long contentLength) {
+      super(delegate);
+      this.contentLength = contentLength;
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      if (closed) throw new IllegalStateException("closed");
+      if (contentLength != -1L && bytesReceived + byteCount > contentLength) {
+        throw new ProtocolException("expected " + contentLength
+            + " bytes but received " + (bytesReceived + byteCount));
+      }
+      try {
+        super.write(source, byteCount);
+        this.bytesReceived += byteCount;
+      } catch (IOException e) {
+        throw complete(e);
+      }
+    }
+
+    @Override public void flush() throws IOException {
+      try {
+        super.flush();
+      } catch (IOException e) {
+        throw complete(e);
+      }
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      closed = true;
+      if (contentLength != -1L && bytesReceived != contentLength) {
+        throw new ProtocolException("unexpected end of stream");
+      }
+      try {
+        super.close();
+        complete(null);
+      } catch (IOException e) {
+        throw complete(e);
+      }
+    }
+
+    private @Nullable IOException complete(@Nullable IOException e) {
+      if (completed) return e;
+      completed = true;
+      return bodyComplete(bytesReceived, false, true, e);
+    }
+  }
+
+  /** A response body that fires events when it completes. */
+  final class ResponseBodySource extends ForwardingSource {
+    private final long contentLength;
+    private long bytesReceived;
+    private boolean completed;
+    private boolean closed;
+
+    ResponseBodySource(Source delegate, long contentLength) {
+      super(delegate);
+      this.contentLength = contentLength;
+
+      if (contentLength == 0L) {
+        complete(null);
+      }
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      if (closed) throw new IllegalStateException("closed");
+      try {
+        long read = delegate().read(sink, byteCount);
+        if (read == -1L) {
+          complete(null);
+          return -1L;
+        }
+
+        long newBytesReceived = bytesReceived + read;
+        if (contentLength != -1L && newBytesReceived > contentLength) {
+          throw new ProtocolException("expected " + contentLength
+              + " bytes but received " + newBytesReceived);
+        }
+
+        bytesReceived = newBytesReceived;
+        if (newBytesReceived == contentLength) {
+          complete(null);
+        }
+
+        return read;
+      } catch (IOException e) {
+        throw complete(e);
+      }
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      closed = true;
+      try {
+        super.close();
+        complete(null);
+      } catch (IOException e) {
+        throw complete(e);
+      }
+    }
+
+    @Nullable IOException complete(@Nullable IOException e) {
+      if (completed) return e;
+      completed = true;
+      return bodyComplete(bytesReceived, true, false, e);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.java b/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.java
new file mode 100644
index 0000000000..102fbc9b9b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.java
@@ -0,0 +1,287 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.net.Socket;
+import java.util.List;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.EventListener;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Route;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.ExchangeCodec;
+
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * Attempts to find the connections for a sequence of exchanges. This uses the following strategies:
+ *
+ * <ol>
+ *   <li>If the current call already has a connection that can satisfy the request it is used.
+ *       Using the same connection for an initial exchange and its follow-ups may improve locality.
+ *
+ *   <li>If there is a connection in the pool that can satisfy the request it is used. Note that
+ *       it is possible for shared exchanges to make requests to different host names! See {@link
+ *       RealConnection#isEligible} for details.
+ *
+ *   <li>If there's no existing connection, make a list of routes (which may require blocking DNS
+ *       lookups) and attempt a new connection them. When failures occur, retries iterate the list
+ *       of available routes.
+ * </ol>
+ *
+ * <p>If the pool gains an eligible connection while DNS, TCP, or TLS work is in flight, this finder
+ * will prefer pooled connections. Only pooled HTTP/2 connections are used for such de-duplication.
+ *
+ * <p>It is possible to cancel the finding process.
+ */
+final class ExchangeFinder {
+  private final Transmitter transmitter;
+  private final Address address;
+  private final RealConnectionPool connectionPool;
+  private final Call call;
+  private final EventListener eventListener;
+
+  private RouteSelector.Selection routeSelection;
+
+  // State guarded by connectionPool.
+  private final RouteSelector routeSelector;
+  private RealConnection connectingConnection;
+  private boolean hasStreamFailure;
+
+  ExchangeFinder(Transmitter transmitter, RealConnectionPool connectionPool,
+      Address address, Call call, EventListener eventListener) {
+    this.transmitter = transmitter;
+    this.connectionPool = connectionPool;
+    this.address = address;
+    this.call = call;
+    this.eventListener = eventListener;
+    this.routeSelector = new RouteSelector(
+        address, connectionPool.getRouteDatabase(), call, eventListener);
+  }
+
+  public ExchangeCodec find(
+      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
+    int connectTimeout = chain.connectTimeoutMillis();
+    int readTimeout = chain.readTimeoutMillis();
+    int writeTimeout = chain.writeTimeoutMillis();
+    int pingIntervalMillis = client.pingIntervalMillis();
+    boolean connectionRetryEnabled = client.retryOnConnectionFailure();
+
+    try {
+      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
+          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
+      return resultConnection.newCodec(client, chain);
+    } catch (RouteException e) {
+      trackFailure();
+      throw e;
+    } catch (IOException e) {
+      trackFailure();
+      throw new RouteException(e);
+    }
+  }
+
+  /**
+   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
+   * until a healthy connection is found.
+   */
+  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
+      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
+      boolean doExtensiveHealthChecks) throws IOException {
+    while (true) {
+      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
+          pingIntervalMillis, connectionRetryEnabled);
+
+      // If this is a brand new connection, we can skip the extensive health checks.
+      synchronized (connectionPool) {
+        if (candidate.successCount == 0) {
+          return candidate;
+        }
+      }
+
+      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
+      // isn't, take it out of the pool and start again.
+      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
+        candidate.noNewExchanges();
+        continue;
+      }
+
+      return candidate;
+    }
+  }
+
+  /**
+   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
+   * then the pool, finally building a new connection.
+   */
+  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
+      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
+    boolean foundPooledConnection = false;
+    RealConnection result = null;
+    Route selectedRoute = null;
+    RealConnection releasedConnection;
+    Socket toClose;
+    synchronized (connectionPool) {
+      if (transmitter.isCanceled()) throw new IOException("Canceled");
+      hasStreamFailure = false; // This is a fresh attempt.
+
+      Route previousRoute = retryCurrentRoute()
+          ? transmitter.connection.route()
+          : null;
+
+      // Attempt to use an already-allocated connection. We need to be careful here because our
+      // already-allocated connection may have been restricted from creating new exchanges.
+      releasedConnection = transmitter.connection;
+      toClose = transmitter.connection != null && transmitter.connection.noNewExchanges
+          ? transmitter.releaseConnectionNoEvents()
+          : null;
+
+      if (transmitter.connection != null) {
+        // We had an already-allocated connection and it's good.
+        result = transmitter.connection;
+        releasedConnection = null;
+      }
+
+      if (result == null) {
+        // Attempt to get a connection from the pool.
+        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) {
+          foundPooledConnection = true;
+          result = transmitter.connection;
+        } else {
+          selectedRoute = previousRoute;
+        }
+      }
+    }
+    closeQuietly(toClose);
+
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result);
+    }
+    if (result != null) {
+      // If we found an already-allocated or pooled connection, we're done.
+      return result;
+    }
+
+    // If we need a route selection, make one. This is a blocking operation.
+    boolean newRouteSelection = false;
+    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
+      newRouteSelection = true;
+      routeSelection = routeSelector.next();
+    }
+
+    List<Route> routes = null;
+    synchronized (connectionPool) {
+      if (transmitter.isCanceled()) throw new IOException("Canceled");
+
+      if (newRouteSelection) {
+        // Now that we have a set of IP addresses, make another attempt at getting a connection from
+        // the pool. This could match due to connection coalescing.
+        routes = routeSelection.getAll();
+        if (connectionPool.transmitterAcquirePooledConnection(
+            address, transmitter, routes, false)) {
+          foundPooledConnection = true;
+          result = transmitter.connection;
+        }
+      }
+
+      if (!foundPooledConnection) {
+        if (selectedRoute == null) {
+          selectedRoute = routeSelection.next();
+        }
+
+        // Create a connection and assign it to this allocation immediately. This makes it possible
+        // for an asynchronous cancel() to interrupt the handshake we're about to do.
+        result = new RealConnection(connectionPool, selectedRoute);
+        connectingConnection = result;
+      }
+    }
+
+    // If we found a pooled connection on the 2nd time around, we're done.
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result);
+      return result;
+    }
+
+    // Do TCP + TLS handshakes. This is a blocking operation.
+    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
+        connectionRetryEnabled, call, eventListener);
+    connectionPool.getRouteDatabase().connected(result.route());
+
+    Socket socket = null;
+    synchronized (connectionPool) {
+      connectingConnection = null;
+      // Last attempt at connection coalescing, which only occurs if we attempted multiple
+      // concurrent connections to the same host.
+      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) {
+        // We lost the race! Close the connection we created and return the pooled connection.
+        result.noNewExchanges = true;
+        socket = result.socket();
+        result = transmitter.connection;
+      } else {
+        connectionPool.put(result);
+        transmitter.acquireConnectionNoEvents(result);
+      }
+    }
+    closeQuietly(socket);
+
+    eventListener.connectionAcquired(call, result);
+    return result;
+  }
+
+  RealConnection connectingConnection() {
+    assert (Thread.holdsLock(connectionPool));
+    return connectingConnection;
+  }
+
+  void trackFailure() {
+    assert (!Thread.holdsLock(connectionPool));
+    synchronized (connectionPool) {
+      hasStreamFailure = true; // Permit retries.
+    }
+  }
+
+  /** Returns true if there is a failure that retrying might fix. */
+  boolean hasStreamFailure() {
+    synchronized (connectionPool) {
+      return hasStreamFailure;
+    }
+  }
+
+  /** Returns true if a current route is still good or if there are routes we haven't tried yet. */
+  boolean hasRouteToTry() {
+    synchronized (connectionPool) {
+      return retryCurrentRoute()
+          || (routeSelection != null && routeSelection.hasNext())
+          || routeSelector.hasNext();
+    }
+  }
+
+  /**
+   * Return true if the route used for the current connection should be retried, even if the
+   * connection itself is unhealthy. The biggest gotcha here is that we shouldn't reuse routes from
+   * coalesced connections.
+   */
+  private boolean retryCurrentRoute() {
+    return transmitter.connection != null
+        && transmitter.connection.routeFailureCount == 0
+        && Util.sameConnection(transmitter.connection.route().address().url(), address.url());
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index d087e5da65..f52541fdde 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -30,7 +30,6 @@
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.concurrent.TimeUnit;
 import javax.annotation.Nullable;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSession;
@@ -40,7 +39,6 @@
 import okhttp3.Call;
 import okhttp3.CertificatePinner;
 import okhttp3.Connection;
-import okhttp3.ConnectionPool;
 import okhttp3.ConnectionSpec;
 import okhttp3.EventListener;
 import okhttp3.Handshake;
@@ -54,20 +52,20 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
-import okhttp3.internal.http.HttpCodec;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http1.Http1Codec;
+import okhttp3.internal.http.ExchangeCodec;
+import okhttp3.internal.http1.Http1ExchangeCodec;
+import okhttp3.internal.http2.ConnectionShutdownException;
 import okhttp3.internal.http2.ErrorCode;
-import okhttp3.internal.http2.Http2Codec;
 import okhttp3.internal.http2.Http2Connection;
+import okhttp3.internal.http2.Http2ExchangeCodec;
 import okhttp3.internal.http2.Http2Stream;
+import okhttp3.internal.http2.StreamResetException;
 import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.OkHostnameVerifier;
 import okhttp3.internal.ws.RealWebSocket;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.Okio;
-import okio.Source;
 
 import static java.net.HttpURLConnection.HTTP_OK;
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
@@ -78,7 +76,7 @@
   private static final String NPE_THROW_WITH_NULL = "throw with null exception";
   private static final int MAX_TUNNEL_ATTEMPTS = 21;
 
-  private final ConnectionPool connectionPool;
+  public final RealConnectionPool connectionPool;
   private final Route route;
 
   // The fields below are initialized by connect() and never reassigned.
@@ -99,30 +97,48 @@
 
   // The fields below track connection state and are guarded by connectionPool.
 
-  /** If true, no new streams can be created on this connection. Once true this is always true. */
-  public boolean noNewStreams;
+  /**
+   * If true, no new exchanges can be created on this connection. Once true this is always true.
+   * Guarded by {@link #connectionPool}.
+   */
+  boolean noNewExchanges;
 
-  public int successCount;
+  /**
+   * The number of times there was a problem establishing a stream that could be due to route
+   * chosen. Guarded by {@link #connectionPool}.
+   */
+  int routeFailureCount;
+
+  int successCount;
+  private int refusedStreamCount;
 
   /**
    * The maximum number of concurrent streams that can be carried by this connection. If {@code
    * allocations.size() < allocationLimit} then new streams can be created on this connection.
    */
-  public int allocationLimit = 1;
+  private int allocationLimit = 1;
 
-  /** Current streams carried by this connection. */
-  public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();
+  /** Current calls carried by this connection. */
+  final List<Reference<Transmitter>> transmitters = new ArrayList<>();
 
   /** Nanotime timestamp when {@code allocations.size()} reached zero. */
-  public long idleAtNanos = Long.MAX_VALUE;
+  long idleAtNanos = Long.MAX_VALUE;
 
-  public RealConnection(ConnectionPool connectionPool, Route route) {
+  public RealConnection(RealConnectionPool connectionPool, Route route) {
     this.connectionPool = connectionPool;
     this.route = route;
   }
 
-  public static RealConnection testConnection(
-      ConnectionPool connectionPool, Route route, Socket socket, long idleAtNanos) {
+  /** Prevent further exchanges from being created on this connection. */
+  public void noNewExchanges() {
+    assert (!Thread.holdsLock(connectionPool));
+    synchronized (connectionPool) {
+      noNewExchanges = true;
+    }
+  }
+
+  static RealConnection testConnection(
+      RealConnectionPool connectionPool, Route route, Socket socket, long idleAtNanos) {
     RealConnection result = new RealConnection(connectionPool, route);
     result.socket = socket;
     result.idleAtNanos = idleAtNanos;
@@ -331,7 +347,8 @@ private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IO
               "Hostname " + address.url().host() + " not verified:"
                   + "\n    certificate: " + CertificatePinner.pin(cert)
                   + "\n    DN: " + cert.getSubjectDN().getName()
-                  + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
+                  + "\n    subjectAltNames: "
+                  + OkHostnameVerifier.INSTANCE.allSubjectAltNames(cert));
         } else {
           throw new SSLPeerUnverifiedException(
               "Hostname " + address.url().host() + " not verified (no certificates)");
@@ -376,23 +393,15 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
     // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
     String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
     while (true) {
-      Http1Codec tunnelConnection = new Http1Codec(null, null, source, sink);
+      Http1ExchangeCodec tunnelCodec = new Http1ExchangeCodec(null, null, source, sink);
       source.timeout().timeout(readTimeout, MILLISECONDS);
       sink.timeout().timeout(writeTimeout, MILLISECONDS);
-      tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
-      tunnelConnection.finishRequest();
-      Response response = tunnelConnection.readResponseHeaders(false)
+      tunnelCodec.writeRequest(tunnelRequest.headers(), requestLine);
+      tunnelCodec.finishRequest();
+      Response response = tunnelCodec.readResponseHeaders(false)
           .request(tunnelRequest)
           .build();
-      // The response body from a CONNECT should be empty, but if it is not then we should consume
-      // it before proceeding.
-      long contentLength = HttpHeaders.contentLength(response);
-      if (contentLength == -1L) {
-        contentLength = 0L;
-      }
-      Source body = tunnelConnection.newFixedLengthSource(contentLength);
-      Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
-      body.close();
+      tunnelCodec.skipConnectBody(response);
 
       switch (response.code()) {
         case HTTP_OK:
@@ -436,7 +445,7 @@ private Request createTunnelRequest() throws IOException {
         .method("CONNECT", null)
         .header("Host", Util.hostHeader(route.address().url(), true))
         .header("Proxy-Connection", "Keep-Alive") // For HTTP/1.0 proxies like Squid.
-        .header("User-Agent", Version.userAgent())
+        .header("User-Agent", Version.userAgent)
         .build();
 
     Response fakeAuthChallengeResponse = new Response.Builder()
@@ -462,9 +471,9 @@ private Request createTunnelRequest() throws IOException {
    * Returns true if this connection can carry a stream allocation to {@code address}. If non-null
    * {@code route} is the resolved route for a connection.
    */
-  public boolean isEligible(Address address, @Nullable Route route) {
-    // If this connection is not accepting new streams, we're done.
-    if (allocations.size() >= allocationLimit || noNewStreams) return false;
+  boolean isEligible(Address address, @Nullable List<Route> routes) {
+    // If this connection is not accepting new exchanges, we're done.
+    if (transmitters.size() >= allocationLimit || noNewExchanges) return false;
 
     // If the non-host fields of the address don't overlap, we're done.
     if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false;
@@ -482,16 +491,11 @@ public boolean isEligible(Address address, @Nullable Route route) {
     // 1. This connection must be HTTP/2.
     if (http2Connection == null) return false;
 
-    // 2. The routes must share an IP address. This requires us to have a DNS address for both
-    // hosts, which only happens after route planning. We can't coalesce connections that use a
-    // proxy, since proxies don't tell us the origin server's IP address.
-    if (route == null) return false;
-    if (route.proxy().type() != Proxy.Type.DIRECT) return false;
-    if (this.route.proxy().type() != Proxy.Type.DIRECT) return false;
-    if (!this.route.socketAddress().equals(route.socketAddress())) return false;
+    // 2. The routes must share an IP address.
+    if (routes == null || !routeMatchesAny(routes)) return false;
 
     // 3. This connection's server certificate's must cover the new host.
-    if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;
+    if (address.hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;
     if (!supportsUrl(address.url())) return false;
 
     // 4. Certificate pinning must match the host.
@@ -504,6 +508,24 @@ public boolean isEligible(Address address, @Nullable Route route) {
     return true; // The caller's address can be carried by this connection.
   }
 
+  /**
+   * Returns true if this connection's route has the same address as any of {@code routes}. This
+   * requires us to have a DNS address for both hosts, which only happens after route planning. We
+   * can't coalesce connections that use a proxy, since proxies don't tell us the origin server's IP
+   * address.
+   */
+  private boolean routeMatchesAny(List<Route> candidates) {
+    for (int i = 0, size = candidates.size(); i < size; i++) {
+      Route candidate = candidates.get(i);
+      if (candidate.proxy().type() == Proxy.Type.DIRECT
+          && route.proxy().type() == Proxy.Type.DIRECT
+          && route.socketAddress().equals(candidate.socketAddress())) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   public boolean supportsUrl(HttpUrl url) {
     if (url.port() != route.address().url().port()) {
       return false; // Port mismatch.
@@ -518,22 +540,23 @@ public boolean supportsUrl(HttpUrl url) {
     return true; // Success. The URL is supported.
   }
 
-  public HttpCodec newCodec(OkHttpClient client, Interceptor.Chain chain,
-      StreamAllocation streamAllocation) throws SocketException {
+  ExchangeCodec newCodec(OkHttpClient client, Interceptor.Chain chain) throws SocketException {
     if (http2Connection != null) {
-      return new Http2Codec(client, chain, streamAllocation, http2Connection);
+      return new Http2ExchangeCodec(client, this, chain, http2Connection);
     } else {
       socket.setSoTimeout(chain.readTimeoutMillis());
       source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);
       sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);
-      return new Http1Codec(client, streamAllocation, source, sink);
+      return new Http1ExchangeCodec(client, this, source, sink);
     }
   }
 
-  public RealWebSocket.Streams newWebSocketStreams(final StreamAllocation streamAllocation) {
+  RealWebSocket.Streams newWebSocketStreams(Exchange exchange) throws SocketException {
+    socket.setSoTimeout(0);
+    noNewExchanges();
     return new RealWebSocket.Streams(true, source, sink) {
       @Override public void close() throws IOException {
-        streamAllocation.streamFinished(true, streamAllocation.codec(), -1L, null);
+        exchange.bodyComplete(-1L, true, true, null);
       }
     };
   }
@@ -585,7 +608,7 @@ public boolean isHealthy(boolean doExtensiveChecks) {
 
   /** Refuse incoming streams. */
   @Override public void onStream(Http2Stream stream) throws IOException {
-    stream.close(ErrorCode.REFUSED_STREAM);
+    stream.close(ErrorCode.REFUSED_STREAM, null);
   }
 
   /** When settings are received, adjust the allocation limit. */
@@ -607,6 +630,41 @@ public boolean isMultiplexed() {
     return http2Connection != null;
   }
 
+  /**
+   * Track a failure using this connection. This may prevent both the connection and its route from
+   * being used for future exchanges.
+   */
+  void trackFailure(@Nullable IOException e) {
+    assert (!Thread.holdsLock(connectionPool));
+    synchronized (connectionPool) {
+      if (e instanceof StreamResetException) {
+        ErrorCode errorCode = ((StreamResetException) e).errorCode;
+        if (errorCode == ErrorCode.REFUSED_STREAM) {
+          // Retry REFUSED_STREAM errors once on the same connection.
+          refusedStreamCount++;
+          if (refusedStreamCount > 1) {
+            noNewExchanges = true;
+            routeFailureCount++;
+          }
+        } else if (errorCode != ErrorCode.CANCEL) {
+          // Keep the connection for CANCEL errors. Everything else wants a fresh connection.
+          noNewExchanges = true;
+          routeFailureCount++;
+        }
+      } else if (!isMultiplexed() || e instanceof ConnectionShutdownException) {
+        noNewExchanges = true;
+
+        // If this route hasn't completed a call, avoid it for new connections.
+        if (successCount == 0) {
+          if (e != null) {
+            connectionPool.connectFailed(route, e);
+          }
+          routeFailureCount++;
+        }
+      }
+    }
+  }
+
   @Override public Protocol protocol() {
     return protocol;
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
new file mode 100644
index 0000000000..df0d9dadb3
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.kt
@@ -0,0 +1,275 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.connection
+
+import okhttp3.Address
+import okhttp3.Route
+import okhttp3.internal.Util
+import okhttp3.internal.Util.closeQuietly
+import okhttp3.internal.connection.Transmitter.TransmitterReference
+import okhttp3.internal.platform.Platform
+import java.io.IOException
+import java.net.Proxy
+import java.util.ArrayDeque
+import java.util.concurrent.SynchronousQueue
+import java.util.concurrent.ThreadPoolExecutor
+import java.util.concurrent.TimeUnit
+
+class RealConnectionPool(
+  /** The maximum number of idle connections for each address.  */
+  private val maxIdleConnections: Int,
+  keepAliveDuration: Long,
+  timeUnit: TimeUnit
+) {
+  private val keepAliveDurationNs: Long = timeUnit.toNanos(keepAliveDuration)
+
+  private val cleanupRunnable = object : Runnable {
+    override fun run() {
+      while (true) {
+        val waitNanos = cleanup(System.nanoTime())
+        if (waitNanos == -1L) return
+        try {
+          this@RealConnectionPool.waitNanos(waitNanos)
+        } catch (_: InterruptedException) {
+        }
+      }
+    }
+  }
+
+  private val connections = ArrayDeque<RealConnection>()
+  val routeDatabase = RouteDatabase()
+  var cleanupRunning: Boolean = false
+
+  init {
+    // Put a floor on the keep alive duration, otherwise cleanup will spin loop.
+    require(keepAliveDuration > 0) { "keepAliveDuration <= 0: $keepAliveDuration" }
+  }
+
+  @Synchronized fun idleConnectionCount(): Int {
+    return connections.count { it.transmitters.isEmpty() }
+  }
+
+  @Synchronized fun connectionCount(): Int {
+    return connections.size
+  }
+
+  /**
+   * Attempts to acquire a recycled connection to `address` for `transmitter`. Returns true if a
+   * connection was acquired.
+   *
+   * If `routes` is non-null these are the resolved routes (ie. IP addresses) for the connection.
+   * This is used to coalesce related domains to the same HTTP/2 connection, such as `square.com`
+   * and `square.ca`.
+   */
+  fun transmitterAcquirePooledConnection(
+    address: Address,
+    transmitter: Transmitter,
+    routes: List<Route>?,
+    requireMultiplexed: Boolean
+  ): Boolean {
+    assert(Thread.holdsLock(this))
+    for (connection in connections) {
+      if (requireMultiplexed && !connection.isMultiplexed) continue
+      if (!connection.isEligible(address, routes)) continue
+      transmitter.acquireConnectionNoEvents(connection)
+      return true
+    }
+    return false
+  }
+
+  fun put(connection: RealConnection) {
+    assert(Thread.holdsLock(this))
+    if (!cleanupRunning) {
+      cleanupRunning = true
+      executor.execute(cleanupRunnable)
+    }
+    connections.add(connection)
+  }
+
+  /**
+   * Notify this pool that `connection` has become idle. Returns true if the connection has
+   * been removed from the pool and should be closed.
+   */
+  fun connectionBecameIdle(connection: RealConnection): Boolean {
+    assert(Thread.holdsLock(this))
+    if (connection.noNewExchanges || maxIdleConnections == 0) {
+      connections.remove(connection)
+      return true
+    } else {
+      // Awake the cleanup thread: we may have exceeded the idle connection limit.
+      (this as java.lang.Object).notifyAll()
+      return false
+    }
+  }
+
+  fun evictAll() {
+    val evictedConnections = mutableListOf<RealConnection>()
+    synchronized(this) {
+      val i = connections.iterator()
+      while (i.hasNext()) {
+        val connection = i.next()
+        if (connection.transmitters.isEmpty()) {
+          connection.noNewExchanges = true
+          evictedConnections.add(connection)
+          i.remove()
+        }
+      }
+    }
+
+    for (connection in evictedConnections) {
+      closeQuietly(connection.socket())
+    }
+  }
+
+  /**
+   * Performs maintenance on this pool, evicting the connection that has been idle the longest if
+   * either it has exceeded the keep alive limit or the idle connections limit.
+   *
+   * Returns the duration in nanos to sleep until the next scheduled call to this method. Returns
+   * -1 if no further cleanups are required.
+   */
+  fun cleanup(now: Long): Long {
+    var inUseConnectionCount = 0
+    var idleConnectionCount = 0
+    var longestIdleConnection: RealConnection? = null
+    var longestIdleDurationNs = Long.MIN_VALUE
+
+    // Find either a connection to evict, or the time that the next eviction is due.
+    synchronized(this) {
+      for (connection in connections) {
+        // If the connection is in use, keep searching.
+        if (pruneAndGetAllocationCount(connection, now) > 0) {
+          inUseConnectionCount++
+          continue
+        }
+
+        idleConnectionCount++
+
+        // If the connection is ready to be evicted, we're done.
+        val idleDurationNs = now - connection.idleAtNanos
+        if (idleDurationNs > longestIdleDurationNs) {
+          longestIdleDurationNs = idleDurationNs
+          longestIdleConnection = connection
+        }
+      }
+
+      when {
+        longestIdleDurationNs >= this.keepAliveDurationNs
+            || idleConnectionCount > this.maxIdleConnections -> {
+          // We've found a connection to evict. Remove it from the list, then close it below
+          // (outside of the synchronized block).
+          connections.remove(longestIdleConnection)
+        }
+        idleConnectionCount > 0 -> {
+          // A connection will be ready to evict soon.
+          return keepAliveDurationNs - longestIdleDurationNs
+        }
+        inUseConnectionCount > 0 -> {
+          // All connections are in use. It'll be at least the keep alive duration 'til we run
+          // again.
+          return keepAliveDurationNs
+        }
+        else -> {
+          // No connections, idle or in use.
+          cleanupRunning = false
+          return -1
+        }
+      }
+    }
+
+    closeQuietly(longestIdleConnection!!.socket())
+
+    // Cleanup again immediately.
+    return 0
+  }
+
+  /**
+   * Prunes any leaked transmitters and then returns the number of remaining live transmitters on
+   * `connection`. Transmitters are leaked if the connection is tracking them but the application
+   * code has abandoned them. Leak detection is imprecise and relies on garbage collection.
+   */
+  private fun pruneAndGetAllocationCount(connection: RealConnection, now: Long): Int {
+    val references = connection.transmitters
+    var i = 0
+    while (i < references.size) {
+      val reference = references[i]
+
+      if (reference.get() != null) {
+        i++
+        continue
+      }
+
+      // We've discovered a leaked transmitter. This is an application bug.
+      val transmitterRef = reference as TransmitterReference
+      val message = "A connection to ${connection.route().address().url()} was leaked. " +
+          "Did you forget to close a response body?"
+      Platform.get().logCloseableLeak(message, transmitterRef.callStackTrace)
+
+      references.removeAt(i)
+      connection.noNewExchanges = true
+
+      // If this was the last allocation, the connection is eligible for immediate eviction.
+      if (references.isEmpty()) {
+        connection.idleAtNanos = now - keepAliveDurationNs
+        return 0
+      }
+    }
+
+    return references.size
+  }
+
+  /** Track a bad route in the route database. Other routes will be attempted first.  */
+  fun connectFailed(failedRoute: Route, failure: IOException) {
+    // Tell the proxy selector when we fail to connect on a fresh connection.
+    if (failedRoute.proxy().type() != Proxy.Type.DIRECT) {
+      val address = failedRoute.address()
+      address.proxySelector().connectFailed(
+          address.url().uri(), failedRoute.proxy().address(), failure)
+    }
+
+    routeDatabase.failed(failedRoute)
+  }
+
+  companion object {
+    /**
+     * Background threads are used to cleanup expired connections. There will be at most a single
+     * thread running per connection pool. The thread pool executor permits the pool itself to be
+     * garbage collected.
+     */
+    private val executor = ThreadPoolExecutor(
+        0, // corePoolSize.
+        Int.MAX_VALUE, // maximumPoolSize.
+        60L, TimeUnit.SECONDS, // keepAliveTime.
+        SynchronousQueue(),
+        Util.threadFactory("OkHttp ConnectionPool", true)
+    )
+  }
+}
+
+/**
+ * Lock and wait a duration in nanoseconds. Unlike [java.lang.Object.wait] this interprets 0 as
+ * "don't wait" instead of "wait forever".
+ */
+@Throws(InterruptedException::class)
+private fun Any.waitNanos(nanos: Long) {
+  if (nanos == 0L) return
+  val ms = nanos / 1_000_000L
+  val ns = nanos - (ms * 1_000_000L)
+  synchronized(this) {
+    (this as Object).wait(ms, ns.toInt())
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.kt
similarity index 57%
rename from okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
rename to okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.kt
index d0c1a9d79e..de36fc97b4 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.kt
@@ -13,11 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.connection;
+package okhttp3.internal.connection
 
-import java.util.LinkedHashSet;
-import java.util.Set;
-import okhttp3.Route;
+import okhttp3.Route
 
 /**
  * A blacklist of failed routes to avoid when creating a new connection to a target address. This is
@@ -25,21 +23,19 @@
  * a specific IP address or proxy server, that failure is remembered and alternate routes are
  * preferred.
  */
-public final class RouteDatabase {
-  private final Set<Route> failedRoutes = new LinkedHashSet<>();
+class RouteDatabase {
+  private val failedRoutes = mutableSetOf<Route>()
 
-  /** Records a failure connecting to {@code failedRoute}. */
-  public synchronized void failed(Route failedRoute) {
-    failedRoutes.add(failedRoute);
+  /** Records a failure connecting to [failedRoute]. */
+  @Synchronized fun failed(failedRoute: Route) {
+    failedRoutes.add(failedRoute)
   }
 
-  /** Records success connecting to {@code route}. */
-  public synchronized void connected(Route route) {
-    failedRoutes.remove(route);
+  /** Records success connecting to [route]. */
+  @Synchronized fun connected(route: Route) {
+    failedRoutes.remove(route)
   }
 
-  /** Returns true if {@code route} has failed recently and should be avoided. */
-  public synchronized boolean shouldPostpone(Route route) {
-    return failedRoutes.contains(route);
-  }
+  /** Returns true if [route] has failed recently and should be avoided. */
+  @Synchronized fun shouldPostpone(route: Route): Boolean = failedRoutes.contains(route)
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.kt
similarity index 54%
rename from okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
rename to okhttp/src/main/java/okhttp3/internal/connection/RouteException.kt
index 4ba0168621..d10c76c5a8 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.kt
@@ -13,36 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.connection;
+package okhttp3.internal.connection
 
-import java.io.IOException;
-
-import static okhttp3.internal.Util.addSuppressedIfPossible;
+import java.io.IOException
 
 /**
  * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
  * have been made with alternative protocols, none of which were successful.
  */
-public final class RouteException extends RuntimeException {
-  private IOException firstException;
-  private IOException lastException;
-
-  public RouteException(IOException cause) {
-    super(cause);
-    firstException = cause;
-    lastException = cause;
-  }
-
-  public IOException getFirstConnectException() {
-    return firstException;
-  }
-
-  public IOException getLastConnectException() {
-    return lastException;
-  }
+class RouteException internal constructor(val firstConnectException: IOException) :
+    RuntimeException(firstConnectException) {
+  var lastConnectException: IOException = firstConnectException
+    private set
 
-  public void addConnectException(IOException e) {
-    addSuppressedIfPossible(firstException, e);
-    lastException = e;
+  fun addConnectException(e: IOException) {
+    firstConnectException.addSuppressed(e)
+    lastConnectException = e
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
index 40752ce23d..dde5cafc4d 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
@@ -37,7 +37,7 @@
  * Selects routes to connect to an origin server. Each connection requires a choice of proxy server,
  * IP address, and TLS mode. Connections may also be recycled.
  */
-public final class RouteSelector {
+final class RouteSelector {
   private final Address address;
   private final RouteDatabase routeDatabase;
   private final Call call;
@@ -53,7 +53,7 @@
   /* State for negotiating failed routes */
   private final List<Route> postponedRoutes = new ArrayList<>();
 
-  public RouteSelector(Address address, RouteDatabase routeDatabase, Call call,
+  RouteSelector(Address address, RouteDatabase routeDatabase, Call call,
       EventListener eventListener) {
     this.address = address;
     this.routeDatabase = routeDatabase;
@@ -105,20 +105,6 @@ public Selection next() throws IOException {
     return new Selection(routes);
   }
 
-  /**
-   * Clients should invoke this method when they encounter a connectivity failure on a connection
-   * returned by this route selector.
-   */
-  public void connectFailed(Route failedRoute, IOException failure) {
-    if (failedRoute.proxy().type() != Proxy.Type.DIRECT && address.proxySelector() != null) {
-      // Tell the proxy selector when we fail to connect on a fresh connection.
-      address.proxySelector().connectFailed(
-          address.url().uri(), failedRoute.proxy().address(), failure);
-    }
-
-    routeDatabase.failed(failedRoute);
-  }
-
   /** Prepares the proxy servers to try. */
   private void resetNextProxy(HttpUrl url, Proxy proxy) {
     if (proxy != null) {
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
deleted file mode 100644
index b362192907..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ /dev/null
@@ -1,545 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.lang.ref.Reference;
-import java.lang.ref.WeakReference;
-import java.net.Socket;
-import java.util.List;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.Connection;
-import okhttp3.ConnectionPool;
-import okhttp3.EventListener;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Route;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpCodec;
-import okhttp3.internal.http2.ConnectionShutdownException;
-import okhttp3.internal.http2.ErrorCode;
-import okhttp3.internal.http2.StreamResetException;
-
-import static okhttp3.internal.Util.closeQuietly;
-
-/**
- * This class coordinates the relationship between three entities:
- *
- * <ul>
- *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are
- *         potentially slow to establish so it is necessary to be able to cancel a connection
- *         currently being connected.
- *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
- *         connections. Each connection has its own allocation limit, which defines how many
- *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
- *         at a time, HTTP/2 typically carry multiple.
- *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
- *         its follow up requests. We prefer to keep all streams of a single call on the same
- *         connection for better behavior and locality.
- * </ul>
- *
- * <p>Instances of this class act on behalf of the call, using one or more streams over one or more
- * connections. This class has APIs to release each of the above resources:
- *
- * <ul>
- *     <li>{@link #noNewStreams} prevents the connection from being used for new streams in the
- *         future. Use this after a {@code Connection: close} header, or when the connection may be
- *         inconsistent.
- *     <li>{@link #streamFinished streamFinished} releases the active stream from this allocation.
- *         Note that only one stream may be active at a given time, so it is necessary to call
- *         {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
- *         #newStream newStream()}.
- *     <li>{@link #release} removes the call's hold on the connection. Note that this won't
- *         immediately free the connection if there is a stream still lingering. That happens when a
- *         call is complete but its response body has yet to be fully consumed.
- * </ul>
- *
- * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
- * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
- * but not the other streams sharing its connection. But if the TLS handshake is still in progress
- * then canceling may break the entire connection.
- */
-public final class StreamAllocation {
-  public final Address address;
-  private RouteSelector.Selection routeSelection;
-  private Route route;
-  private final ConnectionPool connectionPool;
-  public final Call call;
-  public final EventListener eventListener;
-  private final Object callStackTrace;
-
-  // State guarded by connectionPool.
-  private final RouteSelector routeSelector;
-  private int refusedStreamCount;
-  private RealConnection connection;
-  private boolean reportedAcquired;
-  private boolean released;
-  private boolean canceled;
-  private HttpCodec codec;
-
-  public StreamAllocation(ConnectionPool connectionPool, Address address, Call call,
-      EventListener eventListener, Object callStackTrace) {
-    this.connectionPool = connectionPool;
-    this.address = address;
-    this.call = call;
-    this.eventListener = eventListener;
-    this.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener);
-    this.callStackTrace = callStackTrace;
-  }
-
-  public HttpCodec newStream(
-      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
-    int connectTimeout = chain.connectTimeoutMillis();
-    int readTimeout = chain.readTimeoutMillis();
-    int writeTimeout = chain.writeTimeoutMillis();
-    int pingIntervalMillis = client.pingIntervalMillis();
-    boolean connectionRetryEnabled = client.retryOnConnectionFailure();
-
-    try {
-      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
-          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
-      HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);
-
-      synchronized (connectionPool) {
-        codec = resultCodec;
-        return resultCodec;
-      }
-    } catch (IOException e) {
-      throw new RouteException(e);
-    }
-  }
-
-  /**
-   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
-   * until a healthy connection is found.
-   */
-  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
-      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
-      boolean doExtensiveHealthChecks) throws IOException {
-    while (true) {
-      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
-          pingIntervalMillis, connectionRetryEnabled);
-
-      // If this is a brand new connection, we can skip the extensive health checks.
-      synchronized (connectionPool) {
-        if (candidate.successCount == 0) {
-          return candidate;
-        }
-      }
-
-      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
-      // isn't, take it out of the pool and start again.
-      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
-        noNewStreams();
-        continue;
-      }
-
-      return candidate;
-    }
-  }
-
-  /**
-   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
-   * then the pool, finally building a new connection.
-   */
-  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
-    boolean foundPooledConnection = false;
-    RealConnection result = null;
-    Route selectedRoute = null;
-    Connection releasedConnection;
-    Socket toClose;
-    synchronized (connectionPool) {
-      if (released) throw new IllegalStateException("released");
-      if (codec != null) throw new IllegalStateException("codec != null");
-      if (canceled) throw new IOException("Canceled");
-
-      // Attempt to use an already-allocated connection. We need to be careful here because our
-      // already-allocated connection may have been restricted from creating new streams.
-      releasedConnection = this.connection;
-      toClose = releaseIfNoNewStreams();
-      if (this.connection != null) {
-        // We had an already-allocated connection and it's good.
-        result = this.connection;
-        releasedConnection = null;
-      }
-      if (!reportedAcquired) {
-        // If the connection was never reported acquired, don't report it as released!
-        releasedConnection = null;
-      }
-
-      if (result == null) {
-        // Attempt to get a connection from the pool.
-        Internal.instance.acquire(connectionPool, address, this, null);
-        if (connection != null) {
-          foundPooledConnection = true;
-          result = connection;
-        } else {
-          selectedRoute = route;
-        }
-      }
-    }
-    closeQuietly(toClose);
-
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-    if (foundPooledConnection) {
-      eventListener.connectionAcquired(call, result);
-    }
-    if (result != null) {
-      // If we found an already-allocated or pooled connection, we're done.
-      return result;
-    }
-
-    // If we need a route selection, make one. This is a blocking operation.
-    boolean newRouteSelection = false;
-    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
-      newRouteSelection = true;
-      routeSelection = routeSelector.next();
-    }
-
-    synchronized (connectionPool) {
-      if (canceled) throw new IOException("Canceled");
-
-      if (newRouteSelection) {
-        // Now that we have a set of IP addresses, make another attempt at getting a connection from
-        // the pool. This could match due to connection coalescing.
-        List<Route> routes = routeSelection.getAll();
-        for (int i = 0, size = routes.size(); i < size; i++) {
-          Route route = routes.get(i);
-          Internal.instance.acquire(connectionPool, address, this, route);
-          if (connection != null) {
-            foundPooledConnection = true;
-            result = connection;
-            this.route = route;
-            break;
-          }
-        }
-      }
-
-      if (!foundPooledConnection) {
-        if (selectedRoute == null) {
-          selectedRoute = routeSelection.next();
-        }
-
-        // Create a connection and assign it to this allocation immediately. This makes it possible
-        // for an asynchronous cancel() to interrupt the handshake we're about to do.
-        route = selectedRoute;
-        refusedStreamCount = 0;
-        result = new RealConnection(connectionPool, selectedRoute);
-        acquire(result, false);
-      }
-    }
-
-    // If we found a pooled connection on the 2nd time around, we're done.
-    if (foundPooledConnection) {
-      eventListener.connectionAcquired(call, result);
-      return result;
-    }
-
-    // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
-        connectionRetryEnabled, call, eventListener);
-    routeDatabase().connected(result.route());
-
-    Socket socket = null;
-    synchronized (connectionPool) {
-      reportedAcquired = true;
-
-      // Pool the connection.
-      Internal.instance.put(connectionPool, result);
-
-      // If another multiplexed connection to the same address was created concurrently, then
-      // release this connection and acquire that one.
-      if (result.isMultiplexed()) {
-        socket = Internal.instance.deduplicate(connectionPool, address, this);
-        result = connection;
-      }
-    }
-    closeQuietly(socket);
-
-    eventListener.connectionAcquired(call, result);
-    return result;
-  }
-
-  /**
-   * Releases the currently held connection and returns a socket to close if the held connection
-   * restricts new streams from being created. With HTTP/2 multiple requests share the same
-   * connection so it's possible that our connection is restricted from creating new streams during
-   * a follow-up request.
-   */
-  private Socket releaseIfNoNewStreams() {
-    assert (Thread.holdsLock(connectionPool));
-    RealConnection allocatedConnection = this.connection;
-    if (allocatedConnection != null && allocatedConnection.noNewStreams) {
-      return deallocate(false, false, true);
-    }
-    return null;
-  }
-
-  public void streamFinished(boolean noNewStreams, HttpCodec codec, long bytesRead, IOException e) {
-    eventListener.responseBodyEnd(call, bytesRead);
-
-    Socket socket;
-    Connection releasedConnection;
-    boolean callEnd;
-    synchronized (connectionPool) {
-      if (codec == null || codec != this.codec) {
-        throw new IllegalStateException("expected " + this.codec + " but was " + codec);
-      }
-      if (!noNewStreams) {
-        connection.successCount++;
-      }
-      releasedConnection = connection;
-      socket = deallocate(noNewStreams, false, true);
-      if (connection != null) releasedConnection = null;
-      callEnd = this.released;
-    }
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-
-    if (e != null) {
-      e = Internal.instance.timeoutExit(call, e);
-      eventListener.callFailed(call, e);
-    } else if (callEnd) {
-      Internal.instance.timeoutExit(call, null);
-      eventListener.callEnd(call);
-    }
-  }
-
-  public HttpCodec codec() {
-    synchronized (connectionPool) {
-      return codec;
-    }
-  }
-
-  private RouteDatabase routeDatabase() {
-    return Internal.instance.routeDatabase(connectionPool);
-  }
-
-  public Route route() {
-    return route;
-  }
-
-  public synchronized RealConnection connection() {
-    return connection;
-  }
-
-  public void release(boolean callEnd) {
-    Socket socket;
-    Connection releasedConnection;
-    synchronized (connectionPool) {
-      releasedConnection = connection;
-      socket = deallocate(false, true, false);
-      if (connection != null) releasedConnection = null;
-    }
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      if (callEnd) {
-        Internal.instance.timeoutExit(call, null);
-      }
-      eventListener.connectionReleased(call, releasedConnection);
-      if (callEnd) {
-        eventListener.callEnd(call);
-      }
-    }
-  }
-
-  /** Forbid new streams from being created on the connection that hosts this allocation. */
-  public void noNewStreams() {
-    Socket socket;
-    Connection releasedConnection;
-    synchronized (connectionPool) {
-      releasedConnection = connection;
-      socket = deallocate(true, false, false);
-      if (connection != null) releasedConnection = null;
-    }
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-  }
-
-  /**
-   * Releases resources held by this allocation. If sufficient resources are allocated, the
-   * connection will be detached or closed. Callers must be synchronized on the connection pool.
-   *
-   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
-   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
-   */
-  private Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
-    assert (Thread.holdsLock(connectionPool));
-
-    if (streamFinished) {
-      this.codec = null;
-    }
-    if (released) {
-      this.released = true;
-    }
-    Socket socket = null;
-    if (connection != null) {
-      if (noNewStreams) {
-        connection.noNewStreams = true;
-      }
-      if (this.codec == null && (this.released || connection.noNewStreams)) {
-        release(connection);
-        if (connection.allocations.isEmpty()) {
-          connection.idleAtNanos = System.nanoTime();
-          if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
-            socket = connection.socket();
-          }
-        }
-        connection = null;
-      }
-    }
-    return socket;
-  }
-
-  public void cancel() {
-    HttpCodec codecToCancel;
-    RealConnection connectionToCancel;
-    synchronized (connectionPool) {
-      canceled = true;
-      codecToCancel = codec;
-      connectionToCancel = connection;
-    }
-    if (codecToCancel != null) {
-      codecToCancel.cancel();
-    } else if (connectionToCancel != null) {
-      connectionToCancel.cancel();
-    }
-  }
-
-  public void streamFailed(IOException e) {
-    Socket socket;
-    Connection releasedConnection;
-    boolean noNewStreams = false;
-
-    synchronized (connectionPool) {
-      if (e instanceof StreamResetException) {
-        ErrorCode errorCode = ((StreamResetException) e).errorCode;
-        if (errorCode == ErrorCode.REFUSED_STREAM) {
-          // Retry REFUSED_STREAM errors once on the same connection.
-          refusedStreamCount++;
-          if (refusedStreamCount > 1) {
-            noNewStreams = true;
-            route = null;
-          }
-        } else if (errorCode != ErrorCode.CANCEL) {
-          // Keep the connection for CANCEL errors. Everything else wants a fresh connection.
-          noNewStreams = true;
-          route = null;
-        }
-      } else if (connection != null
-          && (!connection.isMultiplexed() || e instanceof ConnectionShutdownException)) {
-        noNewStreams = true;
-
-        // If this route hasn't completed a call, avoid it for new connections.
-        if (connection.successCount == 0) {
-          if (route != null && e != null) {
-            routeSelector.connectFailed(route, e);
-          }
-          route = null;
-        }
-      }
-      releasedConnection = connection;
-      socket = deallocate(noNewStreams, false, true);
-      if (connection != null || !reportedAcquired) releasedConnection = null;
-    }
-
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-  }
-
-  /**
-   * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
-   * {@link #release} on the same connection.
-   */
-  public void acquire(RealConnection connection, boolean reportedAcquired) {
-    assert (Thread.holdsLock(connectionPool));
-    if (this.connection != null) throw new IllegalStateException();
-
-    this.connection = connection;
-    this.reportedAcquired = reportedAcquired;
-    connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
-  }
-
-  /** Remove this allocation from the connection's list of allocations. */
-  private void release(RealConnection connection) {
-    for (int i = 0, size = connection.allocations.size(); i < size; i++) {
-      Reference<StreamAllocation> reference = connection.allocations.get(i);
-      if (reference.get() == this) {
-        connection.allocations.remove(i);
-        return;
-      }
-    }
-    throw new IllegalStateException();
-  }
-
-  /**
-   * Release the connection held by this connection and acquire {@code newConnection} instead. It is
-   * only safe to call this if the held connection is newly connected but duplicated by {@code
-   * newConnection}. Typically this occurs when concurrently connecting to an HTTP/2 webserver.
-   *
-   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
-   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
-   */
-  public Socket releaseAndAcquire(RealConnection newConnection) {
-    assert (Thread.holdsLock(connectionPool));
-    if (codec != null || connection.allocations.size() != 1) throw new IllegalStateException();
-
-    // Release the old connection.
-    Reference<StreamAllocation> onlyAllocation = connection.allocations.get(0);
-    Socket socket = deallocate(true, false, false);
-
-    // Acquire the new connection.
-    this.connection = newConnection;
-    newConnection.allocations.add(onlyAllocation);
-
-    return socket;
-  }
-
-  public boolean hasMoreRoutes() {
-    return route != null
-        || (routeSelection != null && routeSelection.hasNext())
-        || routeSelector.hasNext();
-  }
-
-  @Override public String toString() {
-    RealConnection connection = connection();
-    return connection != null ? connection.toString() : address.toString();
-  }
-
-  public static final class StreamAllocationReference extends WeakReference<StreamAllocation> {
-    /**
-     * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
-     * identifying the origin of connection leaks.
-     */
-    public final Object callStackTrace;
-
-    StreamAllocationReference(StreamAllocation referent, Object callStackTrace) {
-      super(referent);
-      this.callStackTrace = callStackTrace;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java b/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java
new file mode 100644
index 0000000000..59439c78ef
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java
@@ -0,0 +1,366 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.lang.ref.Reference;
+import java.lang.ref.WeakReference;
+import java.net.Socket;
+import javax.annotation.Nullable;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.CertificatePinner;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.internal.Internal;
+import okhttp3.internal.http.ExchangeCodec;
+import okhttp3.internal.platform.Platform;
+import okio.AsyncTimeout;
+import okio.Timeout;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.internal.Util.sameConnection;
+
+/**
+ * Bridge between OkHttp's application and network layers. This class exposes high-level application
+ * layer primitives: connections, requests, responses, and streams.
+ *
+ * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
+ * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
+ * but not the other streams sharing its connection. But if the TLS handshake is still in progress
+ * then canceling may break the entire connection.
+ */
+public final class Transmitter {
+  private final OkHttpClient client;
+  private final RealConnectionPool connectionPool;
+  private final Call call;
+  private final EventListener eventListener;
+  private final AsyncTimeout timeout = new AsyncTimeout() {
+    @Override protected void timedOut() {
+      cancel();
+    }
+  };
+
+  private @Nullable Object callStackTrace;
+
+  private Request request;
+  private ExchangeFinder exchangeFinder;
+
+  // Guarded by connectionPool.
+  public RealConnection connection;
+  private @Nullable Exchange exchange;
+  private boolean exchangeRequestDone;
+  private boolean exchangeResponseDone;
+  private boolean canceled;
+  private boolean timeoutEarlyExit;
+  private boolean noMoreExchanges;
+
+  public Transmitter(OkHttpClient client, Call call) {
+    this.client = client;
+    this.connectionPool = Internal.instance.realConnectionPool(client.connectionPool());
+    this.call = call;
+    this.eventListener = client.eventListenerFactory().create(call);
+    this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);
+  }
+
+  public Timeout timeout() {
+    return timeout;
+  }
+
+  public void timeoutEnter() {
+    timeout.enter();
+  }
+
+  /**
+   * Stops applying the timeout before the call is entirely complete. This is used for WebSockets
+   * and duplex calls where the timeout only applies to the initial setup.
+   */
+  public void timeoutEarlyExit() {
+    if (timeoutEarlyExit) throw new IllegalStateException();
+    timeoutEarlyExit = true;
+    timeout.exit();
+  }
+
+  private @Nullable IOException timeoutExit(@Nullable IOException cause) {
+    if (timeoutEarlyExit) return cause;
+    if (!timeout.exit()) return cause;
+
+    InterruptedIOException e = new InterruptedIOException("timeout");
+    if (cause != null) e.initCause(cause);
+
+    return e;
+  }
+
+  public void callStart() {
+    this.callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
+    eventListener.callStart(call);
+  }
+
+  /**
+   * Prepare to create a stream to carry {@code request}. This prefers to use the existing
+   * connection if it exists.
+   */
+  public void prepareToConnect(Request request) {
+    if (this.request != null) {
+      if (sameConnection(this.request.url(), request.url()) && exchangeFinder.hasRouteToTry()) {
+        return; // Already ready.
+      }
+      if (exchange != null) throw new IllegalStateException();
+
+      if (exchangeFinder != null) {
+        maybeReleaseConnection(null, true);
+        exchangeFinder = null;
+      }
+    }
+
+    this.request = request;
+    this.exchangeFinder = new ExchangeFinder(this, connectionPool, createAddress(request.url()),
+        call, eventListener);
+  }
+
+  private Address createAddress(HttpUrl url) {
+    SSLSocketFactory sslSocketFactory = null;
+    HostnameVerifier hostnameVerifier = null;
+    CertificatePinner certificatePinner = null;
+    if (url.isHttps()) {
+      sslSocketFactory = client.sslSocketFactory();
+      hostnameVerifier = client.hostnameVerifier();
+      certificatePinner = client.certificatePinner();
+    }
+
+    return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
+        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
+        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
+  }
+
+  /** Returns a new exchange to carry a new request and response. */
+  Exchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
+    synchronized (connectionPool) {
+      if (noMoreExchanges) {
+        throw new IllegalStateException("released");
+      }
+      if (exchange != null) {
+        throw new IllegalStateException("cannot make a new request because the previous response "
+            + "is still open: please call response.close()");
+      }
+    }
+
+    ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);
+    Exchange result = new Exchange(this, call, eventListener, exchangeFinder, codec);
+
+    synchronized (connectionPool) {
+      this.exchange = result;
+      this.exchangeRequestDone = false;
+      this.exchangeResponseDone = false;
+      return result;
+    }
+  }
+
+  void acquireConnectionNoEvents(RealConnection connection) {
+    assert (Thread.holdsLock(connectionPool));
+
+    if (this.connection != null) throw new IllegalStateException();
+    this.connection = connection;
+    connection.transmitters.add(new TransmitterReference(this, callStackTrace));
+  }
+
+  /**
+   * Remove the transmitter from the connection's list of allocations. Returns a socket that the
+   * caller should close.
+   */
+  @Nullable Socket releaseConnectionNoEvents() {
+    assert (Thread.holdsLock(connectionPool));
+
+    int index = -1;
+    for (int i = 0, size = this.connection.transmitters.size(); i < size; i++) {
+      Reference<Transmitter> reference = this.connection.transmitters.get(i);
+      if (reference.get() == this) {
+        index = i;
+        break;
+      }
+    }
+
+    if (index == -1) throw new IllegalStateException();
+
+    RealConnection released = this.connection;
+    released.transmitters.remove(index);
+    this.connection = null;
+
+    if (released.transmitters.isEmpty()) {
+      released.idleAtNanos = System.nanoTime();
+      if (connectionPool.connectionBecameIdle(released)) {
+        return released.socket();
+      }
+    }
+
+    return null;
+  }
+
+  public void exchangeDoneDueToException() {
+    synchronized (connectionPool) {
+      if (noMoreExchanges) throw new IllegalStateException();
+      exchange = null;
+    }
+  }
+
+  /**
+   * Releases resources held with the request or response of {@code exchange}. This should be called
+   * when the request completes normally or when it fails due to an exception, in which case {@code
+   * e} should be non-null.
+   *
+   * <p>If the exchange was canceled or timed out, this will wrap {@code e} in an exception that
+   * provides that additional context. Otherwise {@code e} is returned as-is.
+   */
+  @Nullable IOException exchangeMessageDone(
+      Exchange exchange, boolean requestDone, boolean responseDone, @Nullable IOException e) {
+    boolean exchangeDone = false;
+    synchronized (connectionPool) {
+      if (exchange != this.exchange) {
+        return e; // This exchange was detached violently!
+      }
+      boolean changed = false;
+      if (requestDone) {
+        if (!exchangeRequestDone) changed = true;
+        this.exchangeRequestDone = true;
+      }
+      if (responseDone) {
+        if (!exchangeResponseDone) changed = true;
+        this.exchangeResponseDone = true;
+      }
+      if (exchangeRequestDone && exchangeResponseDone && changed) {
+        exchangeDone = true;
+        this.exchange.connection().successCount++;
+        this.exchange = null;
+      }
+    }
+    if (exchangeDone) {
+      e = maybeReleaseConnection(e, false);
+    }
+    return e;
+  }
+
+  public @Nullable IOException noMoreExchanges(@Nullable IOException e) {
+    synchronized (connectionPool) {
+      noMoreExchanges = true;
+    }
+    return maybeReleaseConnection(e, false);
+  }
+
+  /**
+   * Release the connection if it is no longer needed. This is called after each exchange completes
+   * and after the call signals that no more exchanges are expected.
+   *
+   * <p>If the transmitter was canceled or timed out, this will wrap {@code e} in an exception that
+   * provides that additional context. Otherwise {@code e} is returned as-is.
+   *
+   * @param force true to release the connection even if more exchanges are expected for the call.
+   */
+  private @Nullable IOException maybeReleaseConnection(@Nullable IOException e, boolean force) {
+    Socket socket;
+    Connection releasedConnection;
+    boolean callEnd;
+    synchronized (connectionPool) {
+      if (force && exchange != null) {
+        throw new IllegalStateException("cannot release connection while it is in use");
+      }
+      releasedConnection = this.connection;
+      socket = this.connection != null && exchange == null && (force || noMoreExchanges)
+          ? releaseConnectionNoEvents()
+          : null;
+      if (this.connection != null) releasedConnection = null;
+      callEnd = noMoreExchanges && exchange == null;
+    }
+    closeQuietly(socket);
+
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+
+    if (callEnd) {
+      boolean callFailed = (e != null);
+      e = timeoutExit(e);
+      if (callFailed) {
+        eventListener.callFailed(call, e);
+      } else {
+        eventListener.callEnd(call);
+      }
+    }
+    return e;
+  }
+
+  public boolean canRetry() {
+    return exchangeFinder.hasStreamFailure() && exchangeFinder.hasRouteToTry();
+  }
+
+  public boolean hasExchange() {
+    synchronized (connectionPool) {
+      return exchange != null;
+    }
+  }
+
+  /**
+   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
+   * in-flight request from any thread. It's the caller's responsibility to close the request body
+   * and response body streams; otherwise resources may be leaked.
+   *
+   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
+   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
+   * Otherwise if a socket connection is being established, that is terminated.
+   */
+  public void cancel() {
+    Exchange exchangeToCancel;
+    RealConnection connectionToCancel;
+    synchronized (connectionPool) {
+      canceled = true;
+      exchangeToCancel = exchange;
+      connectionToCancel = exchangeFinder != null && exchangeFinder.connectingConnection() != null
+          ? exchangeFinder.connectingConnection()
+          : connection;
+    }
+    if (exchangeToCancel != null) {
+      exchangeToCancel.cancel();
+    } else if (connectionToCancel != null) {
+      connectionToCancel.cancel();
+    }
+  }
+
+  public boolean isCanceled() {
+    synchronized (connectionPool) {
+      return canceled;
+    }
+  }
+
+  static final class TransmitterReference extends WeakReference<Transmitter> {
+    /**
+     * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
+     * identifying the origin of connection leaks.
+     */
+    final Object callStackTrace;
+
+    TransmitterReference(Transmitter referent, Object callStackTrace) {
+      super(referent);
+      this.callStackTrace = callStackTrace;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/duplex/DuplexRequestBody.java b/okhttp/src/main/java/okhttp3/internal/duplex/DuplexRequestBody.java
deleted file mode 100644
index 6afbf86e66..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/duplex/DuplexRequestBody.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.duplex;
-
-import java.io.IOException;
-import javax.annotation.Nullable;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okio.BufferedSink;
-import okio.Okio;
-import okio.Pipe;
-import okio.Sink;
-
-/**
- * Duplex request bodies are special. They are called differently and they yield different
- * interaction patterns over the network.
- *
- * <p>Rather than writing the body contents via the {@link #writeTo} callback, callers stream
- * request bodies by writing to the {@link #createSink sink}. Callers stream out the entire request
- * body and then {@link Sink#close close} it to signal the end of the request stream. The {@code
- * maxBufferSize} controls how many outbound bytes may be enqueued without blocking: large values
- * allow writing without blocking; small values limit a calls memory consumption. 64 KiB is a
- * reasonable size for most applications.
- *
- * <p>Calls with duplex bodies may receive HTTP responses before the HTTP request body has
- * completed streaming. Interleaving of request and response data is why this mechanism is called
- * duplex. Though any call may be initiated as a duplex call, only web servers that are specially
- * designed for this nonstandard interaction will use it. As of 2019-01, the only widely-used
- * implementation of this pattern is gRPC.
- *
- * <p>Duplex calls are only supported for HTTP/2 connections. Calls to HTTP/1 servers will fail
- * before the HTTP request is transmitted.
- *
- * <p>Duplex calls may not be used with OkHttp interceptors that log, compress, encrypt, or
- * otherwise access the request body. This includes OkHttps
- * {@code okhttp3.logging.HttpLoggingInterceptor logging interceptor}.
- */
-public final class DuplexRequestBody extends RequestBody {
-  private final Pipe pipe;
-  private final @Nullable MediaType contentType;
-
-  // TODO(jwilson/oldergod): include content-length? Callers might know it!
-  public DuplexRequestBody(@Nullable MediaType contentType, long pipeMaxBufferSize) {
-    this.pipe = new Pipe(pipeMaxBufferSize);
-    this.contentType = contentType;
-  }
-
-  public BufferedSink createSink() {
-    return Okio.buffer(pipe.sink());
-  }
-
-  public void foldSink(Sink requestBodyOut) throws IOException {
-    pipe.fold(requestBodyOut);
-  }
-
-  @Override public @Nullable MediaType contentType() {
-    return contentType;
-  }
-
-  @Override public void writeTo(BufferedSink sink) {
-    throw new UnsupportedOperationException();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
deleted file mode 100644
index c10dc34cdc..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.util.List;
-import okhttp3.Cookie;
-import okhttp3.CookieJar;
-import okhttp3.Headers;
-import okhttp3.Interceptor;
-import okhttp3.MediaType;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.internal.Version;
-import okio.GzipSource;
-import okio.Okio;
-
-import static okhttp3.internal.Util.hostHeader;
-
-/**
- * Bridges from application code to network code. First it builds a network request from a user
- * request. Then it proceeds to call the network. Finally it builds a user response from the network
- * response.
- */
-public final class BridgeInterceptor implements Interceptor {
-  private final CookieJar cookieJar;
-
-  public BridgeInterceptor(CookieJar cookieJar) {
-    this.cookieJar = cookieJar;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Request userRequest = chain.request();
-    Request.Builder requestBuilder = userRequest.newBuilder();
-
-    RequestBody body = userRequest.body();
-    if (body != null) {
-      MediaType contentType = body.contentType();
-      if (contentType != null) {
-        requestBuilder.header("Content-Type", contentType.toString());
-      }
-
-      long contentLength = body.contentLength();
-      if (contentLength != -1) {
-        requestBuilder.header("Content-Length", Long.toString(contentLength));
-        requestBuilder.removeHeader("Transfer-Encoding");
-      } else {
-        requestBuilder.header("Transfer-Encoding", "chunked");
-        requestBuilder.removeHeader("Content-Length");
-      }
-    }
-
-    if (userRequest.header("Host") == null) {
-      requestBuilder.header("Host", hostHeader(userRequest.url(), false));
-    }
-
-    if (userRequest.header("Connection") == null) {
-      requestBuilder.header("Connection", "Keep-Alive");
-    }
-
-    // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
-    // the transfer stream.
-    boolean transparentGzip = false;
-    if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
-      transparentGzip = true;
-      requestBuilder.header("Accept-Encoding", "gzip");
-    }
-
-    List<Cookie> cookies = cookieJar.loadForRequest(userRequest.url());
-    if (!cookies.isEmpty()) {
-      requestBuilder.header("Cookie", cookieHeader(cookies));
-    }
-
-    if (userRequest.header("User-Agent") == null) {
-      requestBuilder.header("User-Agent", Version.userAgent());
-    }
-
-    Response networkResponse = chain.proceed(requestBuilder.build());
-
-    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());
-
-    Response.Builder responseBuilder = networkResponse.newBuilder()
-        .request(userRequest);
-
-    if (transparentGzip
-        && "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding"))
-        && HttpHeaders.hasBody(networkResponse)) {
-      GzipSource responseBody = new GzipSource(networkResponse.body().source());
-      Headers strippedHeaders = networkResponse.headers().newBuilder()
-          .removeAll("Content-Encoding")
-          .removeAll("Content-Length")
-          .build();
-      responseBuilder.headers(strippedHeaders);
-      String contentType = networkResponse.header("Content-Type");
-      responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));
-    }
-
-    return responseBuilder.build();
-  }
-
-  /** Returns a 'Cookie' HTTP request header with all cookies, like {@code a=b; c=d}. */
-  private String cookieHeader(List<Cookie> cookies) {
-    StringBuilder cookieHeader = new StringBuilder();
-    for (int i = 0, size = cookies.size(); i < size; i++) {
-      if (i > 0) {
-        cookieHeader.append("; ");
-      }
-      Cookie cookie = cookies.get(i);
-      cookieHeader.append(cookie.name()).append('=').append(cookie.value());
-    }
-    return cookieHeader.toString();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.kt b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.kt
new file mode 100644
index 0000000000..cf9abd8524
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.kt
@@ -0,0 +1,117 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.http
+
+import java.io.IOException
+import okhttp3.Cookie
+import okhttp3.CookieJar
+import okhttp3.Interceptor
+import okhttp3.Response
+import okhttp3.internal.userAgent
+import okio.GzipSource
+
+import okhttp3.internal.Util.hostHeader
+import okio.buffer
+
+/**
+ * Bridges from application code to network code. First it builds a network request from a user
+ * request. Then it proceeds to call the network. Finally it builds a user response from the network
+ * response.
+ */
+class BridgeInterceptor(private val cookieJar: CookieJar) : Interceptor {
+
+  @Throws(IOException::class)
+  override fun intercept(chain: Interceptor.Chain): Response {
+    val userRequest = chain.request()
+    val requestBuilder = userRequest.newBuilder()
+
+    val body = userRequest.body()
+    if (body != null) {
+      val contentType = body.contentType()
+      if (contentType != null) {
+        requestBuilder.header("Content-Type", contentType.toString())
+      }
+
+      val contentLength = body.contentLength()
+      if (contentLength != -1L) {
+        requestBuilder.header("Content-Length", contentLength.toString())
+        requestBuilder.removeHeader("Transfer-Encoding")
+      } else {
+        requestBuilder.header("Transfer-Encoding", "chunked")
+        requestBuilder.removeHeader("Content-Length")
+      }
+    }
+
+    if (userRequest.header("Host") == null) {
+      requestBuilder.header("Host", hostHeader(userRequest.url(), false))
+    }
+
+    if (userRequest.header("Connection") == null) {
+      requestBuilder.header("Connection", "Keep-Alive")
+    }
+
+    // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing
+    // the transfer stream.
+    var transparentGzip = false
+    if (userRequest.header("Accept-Encoding") == null && userRequest.header("Range") == null) {
+      transparentGzip = true
+      requestBuilder.header("Accept-Encoding", "gzip")
+    }
+
+    val cookies = cookieJar.loadForRequest(userRequest.url())
+    if (cookies.isNotEmpty()) {
+      requestBuilder.header("Cookie", cookieHeader(cookies))
+    }
+
+    if (userRequest.header("User-Agent") == null) {
+      requestBuilder.header("User-Agent", userAgent)
+    }
+
+    val networkResponse = chain.proceed(requestBuilder.build())
+
+    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers())
+
+    val responseBuilder = networkResponse.newBuilder()
+        .request(userRequest)
+
+    if (transparentGzip &&
+        "gzip".equals(networkResponse.header("Content-Encoding"), ignoreCase = true) &&
+        HttpHeaders.hasBody(networkResponse)) {
+      val responseBody = networkResponse.body()
+      if (responseBody != null) {
+        val gzipSource = GzipSource(responseBody.source())
+        val strippedHeaders = networkResponse.headers().newBuilder()
+            .removeAll("Content-Encoding")
+            .removeAll("Content-Length")
+            .build()
+        responseBuilder.headers(strippedHeaders)
+        val contentType = networkResponse.header("Content-Type")
+        responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer()))
+      }
+    }
+
+    return responseBuilder.build()
+  }
+
+  /** Returns a 'Cookie' HTTP request header with all cookies, like `a=b; c=d`.  */
+  private fun cookieHeader(cookies: List<Cookie>): String = buildString {
+    cookies.forEachIndexed { index, cookie ->
+      if (index > 0) append("; ")
+      append(cookie.name()).append('=').append(cookie.value())
+    }
+  }
+}
\ No newline at end of file
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index dbf57cb973..c3d21611fb 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -17,20 +17,13 @@
 
 import java.io.IOException;
 import java.net.ProtocolException;
-import okhttp3.Call;
 import okhttp3.Interceptor;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.connection.StreamAllocation;
-import okhttp3.internal.duplex.DuplexRequestBody;
-import okio.Buffer;
+import okhttp3.internal.connection.Exchange;
 import okio.BufferedSink;
-import okio.ForwardingSink;
 import okio.Okio;
-import okio.Sink;
 
 /** This is the last interceptor in the chain. It makes a network call to the server. */
 public final class CallServerInterceptor implements Interceptor {
@@ -41,91 +34,88 @@ public CallServerInterceptor(boolean forWebSocket) {
   }
 
   @Override public Response intercept(Chain chain) throws IOException {
-    final RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    Call call = realChain.call();
-    final HttpCodec httpCodec = realChain.httpStream();
-    StreamAllocation streamAllocation = realChain.streamAllocation();
-    RealConnection connection = (RealConnection) realChain.connection();
+    RealInterceptorChain realChain = (RealInterceptorChain) chain;
+    Exchange exchange = realChain.exchange();
     Request request = realChain.request();
 
     long sentRequestMillis = System.currentTimeMillis();
 
-    realChain.eventListener().requestHeadersStart(call);
-    httpCodec.writeRequestHeaders(request);
-    realChain.eventListener().requestHeadersEnd(call, request);
+    exchange.writeRequestHeaders(request);
 
+    boolean responseHeadersStarted = false;
     Response.Builder responseBuilder = null;
     if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
       // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
       // Continue" response before transmitting the request body. If we don't get that, return
       // what we did get (such as a 4xx response) without ever transmitting the request body.
       if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
-        httpCodec.flushRequest();
-        realChain.eventListener().responseHeadersStart(call);
-        responseBuilder = httpCodec.readResponseHeaders(true);
+        exchange.flushRequest();
+        responseHeadersStarted = true;
+        exchange.responseHeadersStart();
+        responseBuilder = exchange.readResponseHeaders(true);
       }
 
       if (responseBuilder == null) {
-        if (request.body() instanceof DuplexRequestBody) {
+        if (request.body().isDuplex()) {
           // Prepare a duplex body so that the application can send a request body later.
-          httpCodec.flushRequest();
-          CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, -1L));
-          ((DuplexRequestBody) request.body()).foldSink(requestBodyOut);
+          exchange.flushRequest();
+          BufferedSink bufferedRequestBody = Okio.buffer(
+              exchange.createRequestBody(request, true));
+          request.body().writeTo(bufferedRequestBody);
         } else {
           // Write the request body if the "Expect: 100-continue" expectation was met.
-          realChain.eventListener().requestBodyStart(call);
-          long contentLength = request.body().contentLength();
-          CountingSink requestBodyOut =
-              new CountingSink(httpCodec.createRequestBody(request, contentLength));
-          BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
-
+          BufferedSink bufferedRequestBody = Okio.buffer(
+              exchange.createRequestBody(request, false));
           request.body().writeTo(bufferedRequestBody);
           bufferedRequestBody.close();
-          realChain.eventListener().requestBodyEnd(call, requestBodyOut.successfulCount);
         }
-      } else if (!connection.isMultiplexed()) {
-        // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
-        // from being reused. Otherwise we're still obligated to transmit the request body to
-        // leave the connection in a consistent state.
-        streamAllocation.noNewStreams();
+      } else {
+        exchange.noRequestBody();
+        if (!exchange.connection().isMultiplexed()) {
+          // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
+          // from being reused. Otherwise we're still obligated to transmit the request body to
+          // leave the connection in a consistent state.
+          exchange.noNewExchangesOnConnection();
+        }
       }
+    } else {
+      exchange.noRequestBody();
     }
 
-    if (!(request.body() instanceof DuplexRequestBody)) {
-      httpCodec.finishRequest();
+    if (request.body() == null || !request.body().isDuplex()) {
+      exchange.finishRequest();
+    }
+
+    if (!responseHeadersStarted) {
+      exchange.responseHeadersStart();
     }
 
     if (responseBuilder == null) {
-      realChain.eventListener().responseHeadersStart(call);
-      responseBuilder = httpCodec.readResponseHeaders(false);
+      responseBuilder = exchange.readResponseHeaders(false);
     }
 
-    responseBuilder
+    Response response = responseBuilder
         .request(request)
-        .handshake(streamAllocation.connection().handshake())
+        .handshake(exchange.connection().handshake())
         .sentRequestAtMillis(sentRequestMillis)
-        .receivedResponseAtMillis(System.currentTimeMillis());
-    Internal.instance.initCodec(responseBuilder, httpCodec);
-    Response response = responseBuilder.build();
+        .receivedResponseAtMillis(System.currentTimeMillis())
+        .build();
 
     int code = response.code();
     if (code == 100) {
       // server sent a 100-continue even though we did not request one.
       // try again to read the actual response
-      responseBuilder = httpCodec.readResponseHeaders(false);
-
-      responseBuilder
+      response = exchange.readResponseHeaders(false)
           .request(request)
-          .handshake(streamAllocation.connection().handshake())
+          .handshake(exchange.connection().handshake())
           .sentRequestAtMillis(sentRequestMillis)
-          .receivedResponseAtMillis(System.currentTimeMillis());
-      Internal.instance.initCodec(responseBuilder, httpCodec);
-      response = responseBuilder.build();
+          .receivedResponseAtMillis(System.currentTimeMillis())
+          .build();
 
       code = response.code();
     }
 
-    realChain.eventListener().responseHeadersEnd(call, response);
+    exchange.responseHeadersEnd(response);
 
     if (forWebSocket && code == 101) {
       // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
@@ -134,13 +124,13 @@ public CallServerInterceptor(boolean forWebSocket) {
           .build();
     } else {
       response = response.newBuilder()
-          .body(httpCodec.openResponseBody(response))
+          .body(exchange.openResponseBody(response))
           .build();
     }
 
     if ("close".equalsIgnoreCase(response.request().header("Connection"))
         || "close".equalsIgnoreCase(response.header("Connection"))) {
-      streamAllocation.noNewStreams();
+      exchange.noNewExchangesOnConnection();
     }
 
     if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
@@ -150,17 +140,4 @@ public CallServerInterceptor(boolean forWebSocket) {
 
     return response;
   }
-
-  static final class CountingSink extends ForwardingSink {
-    long successfulCount;
-
-    CountingSink(Sink delegate) {
-      super(delegate);
-    }
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      super.write(source, byteCount);
-      successfulCount += byteCount;
-    }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/ExchangeCode.kt b/okhttp/src/main/java/okhttp3/internal/http/ExchangeCode.kt
new file mode 100644
index 0000000000..b0c3e2e77a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/ExchangeCode.kt
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http
+
+import java.io.IOException
+import okhttp3.Headers
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.internal.connection.RealConnection
+import okio.Sink
+import okio.Source
+
+/** Encodes HTTP requests and decodes HTTP responses.  */
+interface ExchangeCodec {
+
+  /** Returns the connection that carries this codec.  */
+  fun connection(): RealConnection?
+
+  /** Returns an output stream where the request body can be streamed.  */
+  @Throws(IOException::class)
+  fun createRequestBody(request: Request, contentLength: Long): Sink
+
+  /** This should update the HTTP engine's sentRequestMillis field.  */
+  @Throws(IOException::class)
+  fun writeRequestHeaders(request: Request)
+
+  /** Flush the request to the underlying socket.  */
+  @Throws(IOException::class)
+  fun flushRequest()
+
+  /** Flush the request to the underlying socket and signal no more bytes will be transmitted.  */
+  @Throws(IOException::class)
+  fun finishRequest()
+
+  /**
+   * Parses bytes of a response header from an HTTP transport.
+   *
+   * @param expectContinue true to return null if this is an intermediate response with a "100"
+   * response code. Otherwise this method never returns null.
+   */
+  @Throws(IOException::class)
+  fun readResponseHeaders(expectContinue: Boolean): Response.Builder?
+
+  @Throws(IOException::class)
+  fun reportedContentLength(response: Response): Long
+
+  @Throws(IOException::class)
+  fun openResponseBodySource(response: Response): Source
+
+  /** Returns the trailers after the HTTP response. May be empty.  */
+  @Throws(IOException::class)
+  fun trailers(): Headers
+
+  /**
+   * Cancel this stream. Resources held by this stream will be cleaned up, though not synchronously.
+   * That may happen later by the connection pool thread.
+   */
+  fun cancel()
+
+  companion object {
+    /**
+     * The timeout to use while discarding a stream of input data. Since this is used for connection
+     * reuse, this timeout should be significantly less than the time it takes to establish a new
+     * connection.
+     */
+    const val DISCARD_STREAM_TIMEOUT_MILLIS = 100
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
deleted file mode 100644
index 103fce6662..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import okhttp3.Headers;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okio.Sink;
-
-/** Encodes HTTP requests and decodes HTTP responses. */
-public interface HttpCodec {
-  /**
-   * The timeout to use while discarding a stream of input data. Since this is used for connection
-   * reuse, this timeout should be significantly less than the time it takes to establish a new
-   * connection.
-   */
-  int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
-
-  /** Returns an output stream where the request body can be streamed. */
-  Sink createRequestBody(Request request, long contentLength);
-
-  /** This should update the HTTP engine's sentRequestMillis field. */
-  void writeRequestHeaders(Request request) throws IOException;
-
-  /** Flush the request to the underlying socket. */
-  void flushRequest() throws IOException;
-
-  /** Flush the request to the underlying socket and signal no more bytes will be transmitted. */
-  void finishRequest() throws IOException;
-
-  /**
-   * Parses bytes of a response header from an HTTP transport.
-   *
-   * @param expectContinue true to return null if this is an intermediate response with a "100"
-   *     response code. Otherwise this method never returns null.
-   */
-  Response.Builder readResponseHeaders(boolean expectContinue) throws IOException;
-
-  /** Returns a stream that reads the response body. */
-  ResponseBody openResponseBody(Response response) throws IOException;
-
-  /** Returns the trailers after the HTTP response. May be empty. */
-  Headers trailers() throws IOException;
-
-  /**
-   * Cancel this stream. Resources held by this stream will be cleaned up, though not synchronously.
-   * That may happen later by the connection pool thread.
-   */
-  void cancel();
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
index 8823d202bc..5e82d187a3 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
@@ -32,11 +32,13 @@
 import okhttp3.HttpUrl;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.platform.Platform;
 import okio.Buffer;
 import okio.ByteString;
 
 import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
 import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
+import static okhttp3.internal.Util.EMPTY_HEADERS;
 import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
 
 /** Headers and utilities for internal use by OkHttp. */
@@ -132,7 +134,7 @@ public static Headers varyHeaders(Response response) {
    */
   public static Headers varyHeaders(Headers requestHeaders, Headers responseHeaders) {
     Set<String> varyFields = varyFields(responseHeaders);
-    if (varyFields.isEmpty()) return new Headers.Builder().build();
+    if (varyFields.isEmpty()) return EMPTY_HEADERS;
 
     Headers.Builder result = new Headers.Builder();
     for (int i = 0, size = requestHeaders.size(); i < size; i++) {
@@ -170,13 +172,18 @@ public static Headers varyHeaders(Headers requestHeaders, Headers responseHeader
     for (int h = 0; h < responseHeaders.size(); h++) {
       if (headerName.equalsIgnoreCase(responseHeaders.name(h))) {
         Buffer header = new Buffer().writeUtf8(responseHeaders.value(h));
-        parseChallengeHeader(result, header);
+        try {
+          parseChallengeHeader(result, header);
+        } catch (EOFException e) {
+          Platform.get().log(Platform.WARN, "Unable to parse challenge", e);
+        }
       }
     }
     return result;
   }
 
-  private static void parseChallengeHeader(List<Challenge> result, Buffer header) {
+  private static void parseChallengeHeader(List<Challenge> result, Buffer header)
+      throws EOFException {
     String peek = null;
 
     while (true) {
@@ -236,15 +243,17 @@ private static void parseChallengeHeader(List<Challenge> result, Buffer header)
   }
 
   /** Returns true if any commas were skipped. */
-  private static boolean skipWhitespaceAndCommas(Buffer buffer) {
+  private static boolean skipWhitespaceAndCommas(Buffer buffer) throws EOFException {
     boolean commaFound = false;
     while (!buffer.exhausted()) {
       byte b = buffer.getByte(0);
       if (b == ',') {
-        buffer.readByte(); // Consume ','.
+        // Consume ','.
+        buffer.readByte();
         commaFound = true;
       } else if (b == ' ' || b == '\t') {
-        buffer.readByte(); // Consume space or tab.
+        // Consume space or tab.
+        buffer.readByte();
       } else {
         break;
       }
@@ -252,7 +261,7 @@ private static boolean skipWhitespaceAndCommas(Buffer buffer) {
     return commaFound;
   }
 
-  private static int skipAll(Buffer buffer, byte b) {
+  private static int skipAll(Buffer buffer, byte b) throws EOFException {
     int count = 0;
     while (!buffer.exhausted() && buffer.getByte(0) == b) {
       count++;
@@ -266,7 +275,7 @@ private static int skipAll(Buffer buffer, byte b) {
    * each sequence. Returns the unescaped string, or null if the buffer isn't prefixed with a
    * double-quoted string.
    */
-  private static String readQuotedString(Buffer buffer) {
+  private static String readQuotedString(Buffer buffer) throws EOFException {
     if (buffer.readByte() != '\"') throw new IllegalArgumentException();
     Buffer result = new Buffer();
     while (true) {
@@ -275,13 +284,15 @@ private static String readQuotedString(Buffer buffer) {
 
       if (buffer.getByte(i) == '"') {
         result.write(buffer, i);
-        buffer.readByte(); // Consume '"'.
+        // Consume '"'.
+        buffer.readByte();
         return result.readUtf8();
       }
 
       if (buffer.size() == i + 1L) return null; // Dangling escape.
       result.write(buffer, i);
-      buffer.readByte(); // Consume '\'.
+      // Consume '\'.
+      buffer.readByte();
       result.write(buffer, 1L); // The escaped character.
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
deleted file mode 100644
index da45901512..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-public final class HttpMethod {
-  public static boolean invalidatesCache(String method) {
-    return method.equals("POST")
-        || method.equals("PATCH")
-        || method.equals("PUT")
-        || method.equals("DELETE")
-        || method.equals("MOVE");     // WebDAV
-  }
-
-  public static boolean requiresRequestBody(String method) {
-    return method.equals("POST")
-        || method.equals("PUT")
-        || method.equals("PATCH")
-        || method.equals("PROPPATCH") // WebDAV
-        || method.equals("REPORT");   // CalDAV/CardDAV (defined in WebDAV Versioning)
-  }
-
-  public static boolean permitsRequestBody(String method) {
-    return !(method.equals("GET") || method.equals("HEAD"));
-  }
-
-  public static boolean redirectsWithBody(String method) {
-    return method.equals("PROPFIND"); // (WebDAV) redirects should also maintain the request body
-  }
-
-  public static boolean redirectsToGet(String method) {
-    // All requests but PROPFIND should redirect to a GET request.
-    return !method.equals("PROPFIND");
-  }
-
-  private HttpMethod() {
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.kt b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.kt
new file mode 100644
index 0000000000..b4516822fd
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.kt
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http
+
+object HttpMethod {
+  @JvmStatic
+  fun invalidatesCache(method: String): Boolean = (method == "POST" ||
+      method == "PATCH" ||
+      method == "PUT" ||
+      method == "DELETE" ||
+      method == "MOVE") // WebDAV
+
+  @JvmStatic
+  fun requiresRequestBody(method: String): Boolean = (method == "POST" ||
+      method == "PUT" ||
+      method == "PATCH" ||
+      method == "PROPPATCH" || // WebDAV
+      method == "REPORT") // CalDAV/CardDAV (defined in WebDAV Versioning)
+
+  @JvmStatic
+  fun permitsRequestBody(method: String): Boolean = !(method == "GET" || method == "HEAD")
+
+  @JvmStatic
+  fun redirectsWithBody(method: String): Boolean =
+      // (WebDAV) redirects should also maintain the request body
+      method == "PROPFIND"
+
+  @JvmStatic
+  fun redirectsToGet(method: String): Boolean =
+      // All requests but PROPFIND should redirect to a GET request.
+      method != "PROPFIND"
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
deleted file mode 100644
index 52f9880892..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Call;
-import okhttp3.Connection;
-import okhttp3.EventListener;
-import okhttp3.Interceptor;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.connection.StreamAllocation;
-
-import static okhttp3.internal.Util.checkDuration;
-
-/**
- * A concrete interceptor chain that carries the entire interceptor chain: all application
- * interceptors, the OkHttp core, all network interceptors, and finally the network caller.
- */
-public final class RealInterceptorChain implements Interceptor.Chain {
-  private final List<Interceptor> interceptors;
-  private final StreamAllocation streamAllocation;
-  private final HttpCodec httpCodec;
-  private final RealConnection connection;
-  private final int index;
-  private final Request request;
-  private final Call call;
-  private final EventListener eventListener;
-  private final int connectTimeout;
-  private final int readTimeout;
-  private final int writeTimeout;
-  private int calls;
-
-  public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,
-      HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,
-      EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) {
-    this.interceptors = interceptors;
-    this.connection = connection;
-    this.streamAllocation = streamAllocation;
-    this.httpCodec = httpCodec;
-    this.index = index;
-    this.request = request;
-    this.call = call;
-    this.eventListener = eventListener;
-    this.connectTimeout = connectTimeout;
-    this.readTimeout = readTimeout;
-    this.writeTimeout = writeTimeout;
-  }
-
-  @Override public Connection connection() {
-    return connection;
-  }
-
-  @Override public int connectTimeoutMillis() {
-    return connectTimeout;
-  }
-
-  @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) {
-    int millis = checkDuration("timeout", timeout, unit);
-    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
-        request, call, eventListener, millis, readTimeout, writeTimeout);
-  }
-
-  @Override public int readTimeoutMillis() {
-    return readTimeout;
-  }
-
-  @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) {
-    int millis = checkDuration("timeout", timeout, unit);
-    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
-        request, call, eventListener, connectTimeout, millis, writeTimeout);
-  }
-
-  @Override public int writeTimeoutMillis() {
-    return writeTimeout;
-  }
-
-  @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) {
-    int millis = checkDuration("timeout", timeout, unit);
-    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
-        request, call, eventListener, connectTimeout, readTimeout, millis);
-  }
-
-  public StreamAllocation streamAllocation() {
-    return streamAllocation;
-  }
-
-  public HttpCodec httpStream() {
-    return httpCodec;
-  }
-
-  @Override public Call call() {
-    return call;
-  }
-
-  public EventListener eventListener() {
-    return eventListener;
-  }
-
-  @Override public Request request() {
-    return request;
-  }
-
-  @Override public Response proceed(Request request) throws IOException {
-    return proceed(request, streamAllocation, httpCodec, connection);
-  }
-
-  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
-      RealConnection connection) throws IOException {
-    if (index >= interceptors.size()) throw new AssertionError();
-
-    calls++;
-
-    // If we already have a stream, confirm that the incoming request will use it.
-    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {
-      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
-          + " must retain the same host and port");
-    }
-
-    // If we already have a stream, confirm that this is the only call to chain.proceed().
-    if (this.httpCodec != null && calls > 1) {
-      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
-          + " must call proceed() exactly once");
-    }
-
-    // Call the next interceptor in the chain.
-    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
-        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
-        writeTimeout);
-    Interceptor interceptor = interceptors.get(index);
-    Response response = interceptor.intercept(next);
-
-    // Confirm that the next interceptor made its required call to chain.proceed().
-    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {
-      throw new IllegalStateException("network interceptor " + interceptor
-          + " must call proceed() exactly once");
-    }
-
-    // Confirm that the intercepted response isn't null.
-    if (response == null) {
-      throw new NullPointerException("interceptor " + interceptor + " returned null");
-    }
-
-    if (response.body() == null) {
-      throw new IllegalStateException(
-          "interceptor " + interceptor + " returned a response with no body");
-    }
-
-    return response;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.kt b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.kt
new file mode 100644
index 0000000000..825da58589
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.kt
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http
+
+import okhttp3.Interceptor
+import okhttp3.Request
+import okhttp3.Call
+import okhttp3.Connection
+import okhttp3.Response
+import okhttp3.internal.Util.checkDuration
+import okhttp3.internal.connection.Exchange
+import okhttp3.internal.connection.Transmitter
+import java.io.IOException
+import java.util.concurrent.TimeUnit
+
+/**
+ * A concrete interceptor chain that carries the entire interceptor chain: all application
+ * interceptors, the OkHttp core, all network interceptors, and finally the network caller.
+ *
+ * If the chain is for an application interceptor then [connection] must be null.
+ * Otherwise it is for a network interceptor and [connection] must be non-null.
+ */
+class RealInterceptorChain(
+  private val interceptors: List<Interceptor>,
+  private val transmitter: Transmitter,
+  private val exchange: Exchange?,
+  private val index: Int,
+  private val request: Request,
+  private val call: Call,
+  private val connectTimeout: Int,
+  private val readTimeout: Int,
+  private val writeTimeout: Int
+) : Interceptor.Chain {
+
+  private var calls: Int = 0
+
+  override fun connection(): Connection? {
+    return exchange?.connection()
+  }
+
+  override fun connectTimeoutMillis(): Int = connectTimeout
+
+  override fun withConnectTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain {
+    val millis = checkDuration("timeout", timeout.toLong(), unit)
+    return RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
+        millis, readTimeout, writeTimeout)
+  }
+
+  override fun readTimeoutMillis(): Int = readTimeout
+
+  override fun withReadTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain {
+    val millis = checkDuration("timeout", timeout.toLong(), unit)
+    return RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
+        connectTimeout, millis, writeTimeout)
+  }
+
+  override fun writeTimeoutMillis(): Int = writeTimeout
+
+  override fun withWriteTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain {
+    val millis = checkDuration("timeout", timeout.toLong(), unit)
+    return RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
+        connectTimeout, readTimeout, millis)
+  }
+
+  fun transmitter(): Transmitter = transmitter
+
+  fun exchange(): Exchange {
+    if (exchange == null) throw IllegalStateException()
+    return exchange
+  }
+
+  override fun call(): Call = call
+
+  override fun request(): Request = request
+
+  override fun proceed(request: Request): Response {
+    return proceed(request, transmitter, exchange)
+  }
+
+  @Throws(IOException::class)
+  fun proceed(request: Request, transmitter: Transmitter, exchange: Exchange?): Response {
+    if (index >= interceptors.size) throw AssertionError()
+
+    calls++
+
+    // If we already have a stream, confirm that the incoming request will use it.
+    if (this.exchange != null && !this.exchange.connection().supportsUrl(request.url())) {
+      throw IllegalStateException("network interceptor " + interceptors[index - 1] +
+          " must retain the same host and port")
+    }
+
+    // If we already have a stream, confirm that this is the only call to chain.proceed().
+    if (this.exchange != null && calls > 1) {
+      throw IllegalStateException("network interceptor " + interceptors[index - 1] +
+          " must call proceed() exactly once")
+    }
+
+    // Call the next interceptor in the chain.
+    val next = RealInterceptorChain(interceptors, transmitter, exchange,
+        index + 1, request, call, connectTimeout, readTimeout, writeTimeout)
+    val interceptor = interceptors[index]
+    val response = interceptor.intercept(next)
+
+    // Confirm that the next interceptor made its required call to chain.proceed().
+    if (exchange != null && index + 1 < interceptors.size && next.calls != 1) {
+      throw IllegalStateException("network interceptor " + interceptor +
+          " must call proceed() exactly once")
+    }
+
+    // Confirm that the intercepted response isn't null.
+    if (response == null) {
+      throw NullPointerException("interceptor $interceptor returned null")
+    }
+
+    if (response.body() == null) {
+      throw IllegalStateException(
+          "interceptor $interceptor returned a response with no body")
+    }
+
+    return response
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
deleted file mode 100644
index 970d7ca949..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import javax.annotation.Nullable;
-import okhttp3.MediaType;
-import okhttp3.ResponseBody;
-import okio.BufferedSource;
-
-public final class RealResponseBody extends ResponseBody {
-  /**
-   * Use a string to avoid parsing the content type until needed. This also defers problems caused
-   * by malformed content types.
-   */
-  private final @Nullable String contentTypeString;
-  private final long contentLength;
-  private final BufferedSource source;
-
-  public RealResponseBody(
-      @Nullable String contentTypeString, long contentLength, BufferedSource source) {
-    this.contentTypeString = contentTypeString;
-    this.contentLength = contentLength;
-    this.source = source;
-  }
-
-  @Override public MediaType contentType() {
-    return contentTypeString != null ? MediaType.parse(contentTypeString) : null;
-  }
-
-  @Override public long contentLength() {
-    return contentLength;
-  }
-
-  @Override public BufferedSource source() {
-    return source;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.kt b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.kt
new file mode 100644
index 0000000000..f27f56be66
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.kt
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http
+
+import okhttp3.MediaType
+import okhttp3.ResponseBody
+import okio.BufferedSource
+
+class RealResponseBody(
+  /**
+   * Use a string to avoid parsing the content type until needed. This also defers problems caused
+   * by malformed content types.
+   */
+  private val contentTypeString: String?,
+  private val contentLength: Long,
+  private val source: BufferedSource
+) : ResponseBody() {
+
+  override fun contentLength(): Long = contentLength
+
+  override fun contentType(): MediaType? {
+    return if (contentTypeString != null) {
+      MediaType.parse(contentTypeString)
+    } else {
+      null
+    }
+  }
+
+  override fun source(): BufferedSource = source
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.kt
similarity index 55%
rename from okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
rename to okhttp/src/main/java/okhttp3/internal/http/RequestLine.kt
index 3e09098097..6b18e2bb90 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.kt
@@ -13,52 +13,53 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.http
 
-import java.net.HttpURLConnection;
-import java.net.Proxy;
-import okhttp3.HttpUrl;
-import okhttp3.Request;
+import java.net.HttpURLConnection
+import java.net.Proxy
+import okhttp3.HttpUrl
+import okhttp3.Request
 
-public final class RequestLine {
-  private RequestLine() {
-  }
+object RequestLine {
 
   /**
    * Returns the request status line, like "GET / HTTP/1.1". This is exposed to the application by
-   * {@link HttpURLConnection#getHeaderFields}, so it needs to be set even if the transport is
+   * [HttpURLConnection.getHeaderFields], so it needs to be set even if the transport is
    * HTTP/2.
    */
-  public static String get(Request request, Proxy.Type proxyType) {
-    StringBuilder result = new StringBuilder();
-    result.append(request.method());
-    result.append(' ');
+  @JvmStatic
+  fun get(request: Request, proxyType: Proxy.Type): String {
+    val result = StringBuilder()
+    result.append(request.method())
+    result.append(' ')
 
     if (includeAuthorityInRequestLine(request, proxyType)) {
-      result.append(request.url());
+      result.append(request.url())
     } else {
-      result.append(requestPath(request.url()));
+      result.append(requestPath(request.url()))
     }
 
-    result.append(" HTTP/1.1");
-    return result.toString();
+    result.append(" HTTP/1.1")
+    return result.toString()
   }
 
   /**
    * Returns true if the request line should contain the full URL with host and port (like "GET
    * http://android.com/foo HTTP/1.1") or only the path (like "GET /foo HTTP/1.1").
    */
-  private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type proxyType) {
-    return !request.isHttps() && proxyType == Proxy.Type.HTTP;
+  @JvmStatic
+  private fun includeAuthorityInRequestLine(request: Request, proxyType: Proxy.Type): Boolean {
+    return !request.isHttps && proxyType == Proxy.Type.HTTP
   }
 
   /**
    * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty, even if the request
    * URL is. Includes the query component if it exists.
    */
-  public static String requestPath(HttpUrl url) {
-    String path = url.encodedPath();
-    String query = url.encodedQuery();
-    return query != null ? (path + '?' + query) : path;
+  @JvmStatic
+  fun requestPath(url: HttpUrl): String {
+    val path = url.encodedPath()
+    val query = url.encodedQuery()
+    return if (query != null) "$path?$query" else path
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index fa72df373b..65da93ce23 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -18,19 +18,13 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InterruptedIOException;
-import java.net.HttpRetryException;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.SocketTimeoutException;
 import java.security.cert.CertificateException;
-import javax.net.ssl.HostnameVerifier;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.CertificatePinner;
-import okhttp3.EventListener;
 import okhttp3.HttpUrl;
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
@@ -38,8 +32,10 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.Route;
+import okhttp3.internal.Internal;
+import okhttp3.internal.connection.Exchange;
 import okhttp3.internal.connection.RouteException;
-import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.connection.Transmitter;
 import okhttp3.internal.http2.ConnectionShutdownException;
 
 import static java.net.HttpURLConnection.HTTP_CLIENT_TIMEOUT;
@@ -51,6 +47,7 @@
 import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
 import static java.net.HttpURLConnection.HTTP_UNAVAILABLE;
 import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.internal.Util.sameConnection;
 import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
 import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
@@ -66,82 +63,45 @@
   private static final int MAX_FOLLOW_UPS = 20;
 
   private final OkHttpClient client;
-  private volatile StreamAllocation streamAllocation;
-  private Object callStackTrace;
-  private volatile boolean canceled;
 
   public RetryAndFollowUpInterceptor(OkHttpClient client) {
     this.client = client;
   }
 
-  /**
-   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
-   * in-flight request from any thread. It's the caller's responsibility to close the request body
-   * and response body streams; otherwise resources may be leaked.
-   *
-   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
-   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
-   * Otherwise if a socket connection is being established, that is terminated.
-   */
-  public void cancel() {
-    canceled = true;
-    StreamAllocation streamAllocation = this.streamAllocation;
-    if (streamAllocation != null) streamAllocation.cancel();
-  }
-
-  public boolean isCanceled() {
-    return canceled;
-  }
-
-  public void setCallStackTrace(Object callStackTrace) {
-    this.callStackTrace = callStackTrace;
-  }
-
-  public StreamAllocation streamAllocation() {
-    return streamAllocation;
-  }
-
   @Override public Response intercept(Chain chain) throws IOException {
     Request request = chain.request();
     RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    Call call = realChain.call();
-    EventListener eventListener = realChain.eventListener();
-
-    StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),
-        createAddress(request.url()), call, eventListener, callStackTrace);
-    this.streamAllocation = streamAllocation;
+    Transmitter transmitter = realChain.transmitter();
 
     int followUpCount = 0;
     Response priorResponse = null;
     while (true) {
-      if (canceled) {
-        streamAllocation.release(true);
+      transmitter.prepareToConnect(request);
+
+      if (transmitter.isCanceled()) {
         throw new IOException("Canceled");
       }
 
       Response response;
-      boolean releaseConnection = true;
+      boolean success = false;
       try {
-        response = realChain.proceed(request, streamAllocation, null, null);
-        releaseConnection = false;
+        response = realChain.proceed(request, transmitter, null);
+        success = true;
       } catch (RouteException e) {
         // The attempt to connect via a route failed. The request will not have been sent.
-        if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {
+        if (!recover(e.getLastConnectException(), transmitter, false, request)) {
           throw e.getFirstConnectException();
         }
-        releaseConnection = false;
         continue;
       } catch (IOException e) {
         // An attempt to communicate with a server failed. The request may have been sent.
         boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
-        if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;
-        releaseConnection = false;
+        if (!recover(e, transmitter, requestSendStarted, request)) throw e;
         continue;
       } finally {
-        // We're throwing an unchecked exception. Release any resources.
-        if (releaseConnection) {
-          streamAllocation.streamFailed(null);
-          streamAllocation.release(true);
+        // The network call threw an exception. Release any resources.
+        if (!success) {
+          transmitter.exchangeDoneDueToException();
         }
       }
 
@@ -154,39 +114,29 @@ public StreamAllocation streamAllocation() {
             .build();
       }
 
-      Request followUp;
-      try {
-        followUp = followUpRequest(response, streamAllocation.route());
-      } catch (IOException e) {
-        streamAllocation.release(true);
-        throw e;
-      }
+      Exchange exchange = Internal.instance.exchange(response);
+      Route route = exchange != null ? exchange.connection().route() : null;
+      Request followUp = followUpRequest(response, route);
 
       if (followUp == null) {
-        streamAllocation.release(true);
+        if (exchange != null && exchange.isDuplex()) {
+          transmitter.timeoutEarlyExit();
+        }
         return response;
       }
 
-      closeQuietly(response.body());
-
-      if (++followUpCount > MAX_FOLLOW_UPS) {
-        streamAllocation.release(true);
-        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
+      RequestBody followUpBody = followUp.body();
+      if (followUpBody != null && followUpBody.isOneShot()) {
+        return response;
       }
 
-      if (followUp.body() instanceof UnrepeatableRequestBody) {
-        streamAllocation.release(true);
-        throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
+      closeQuietly(response.body());
+      if (transmitter.hasExchange()) {
+        exchange.detachWithViolence();
       }
 
-      if (!sameConnection(response, followUp.url())) {
-        streamAllocation.release(false);
-        streamAllocation = new StreamAllocation(client.connectionPool(),
-            createAddress(followUp.url()), call, eventListener, callStackTrace);
-        this.streamAllocation = streamAllocation;
-      } else if (streamAllocation.codec() != null) {
-        throw new IllegalStateException("Closing the body of " + response
-            + " didn't close its backing stream. Bad interceptor?");
+      if (++followUpCount > MAX_FOLLOW_UPS) {
+        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
       }
 
       request = followUp;
@@ -194,49 +144,33 @@ public StreamAllocation streamAllocation() {
     }
   }
 
-  private Address createAddress(HttpUrl url) {
-    SSLSocketFactory sslSocketFactory = null;
-    HostnameVerifier hostnameVerifier = null;
-    CertificatePinner certificatePinner = null;
-    if (url.isHttps()) {
-      sslSocketFactory = client.sslSocketFactory();
-      hostnameVerifier = client.hostnameVerifier();
-      certificatePinner = client.certificatePinner();
-    }
-
-    return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
-        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
-        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
-  }
-
   /**
    * Report and attempt to recover from a failure to communicate with a server. Returns true if
    * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only
    * be recovered if the body is buffered or if the failure occurred before the request has been
    * sent.
    */
-  private boolean recover(IOException e, StreamAllocation streamAllocation,
+  private boolean recover(IOException e, Transmitter transmitter,
       boolean requestSendStarted, Request userRequest) {
-    streamAllocation.streamFailed(e);
-
     // The application layer has forbidden retries.
     if (!client.retryOnConnectionFailure()) return false;
 
     // We can't send the request body again.
-    if (requestSendStarted && requestIsUnrepeatable(e, userRequest)) return false;
+    if (requestSendStarted && requestIsOneShot(e, userRequest)) return false;
 
     // This exception is fatal.
     if (!isRecoverable(e, requestSendStarted)) return false;
 
     // No more routes to attempt.
-    if (!streamAllocation.hasMoreRoutes()) return false;
+    if (!transmitter.canRetry()) return false;
 
     // For failure recovery, use the same route selector with a new connection.
     return true;
   }
 
-  private boolean requestIsUnrepeatable(IOException e, Request userRequest) {
-    return userRequest.body() instanceof UnrepeatableRequestBody
+  private boolean requestIsOneShot(IOException e, Request userRequest) {
+    RequestBody requestBody = userRequest.body();
+    return (requestBody != null && requestBody.isOneShot())
         || e instanceof FileNotFoundException;
   }
 
@@ -277,7 +211,7 @@ private boolean isRecoverable(IOException e, boolean requestSendStarted) {
    * either add authentication headers, follow redirects or handle a client request timeout. If a
    * follow-up is either unnecessary or not applicable, this returns null.
    */
-  private Request followUpRequest(Response userResponse, Route route) throws IOException {
+  private Request followUpRequest(Response userResponse, @Nullable Route route) throws IOException {
     if (userResponse == null) throw new IllegalStateException();
     int responseCode = userResponse.code();
 
@@ -341,7 +275,7 @@ private Request followUpRequest(Response userResponse, Route route) throws IOExc
         // When redirecting across hosts, drop all authentication headers. This
         // is potentially annoying to the application layer since they have no
         // way to retain them.
-        if (!sameConnection(userResponse, url)) {
+        if (!sameConnection(userResponse.request().url(), url)) {
           requestBuilder.removeHeader("Authorization");
         }
 
@@ -356,7 +290,8 @@ private Request followUpRequest(Response userResponse, Route route) throws IOExc
           return null;
         }
 
-        if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
+        RequestBody requestBody = userResponse.request().body();
+        if (requestBody != null && requestBody.isOneShot()) {
           return null;
         }
 
@@ -406,15 +341,4 @@ private int retryAfter(Response userResponse, int defaultDelay) {
 
     return Integer.MAX_VALUE;
   }
-
-  /**
-   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
-   * engine.
-   */
-  private boolean sameConnection(Response response, HttpUrl followUp) {
-    HttpUrl url = response.request().url();
-    return url.host().equals(followUp.host())
-        && url.port() == followUp.port()
-        && url.scheme().equals(followUp.scheme());
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java b/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java
deleted file mode 100644
index f3591a6bf9..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/StatusLine.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import okhttp3.Protocol;
-import okhttp3.Response;
-
-/** An HTTP response status line like "HTTP/1.1 200 OK". */
-public final class StatusLine {
-  /** Numeric status code, 307: Temporary Redirect. */
-  public static final int HTTP_TEMP_REDIRECT = 307;
-  public static final int HTTP_PERM_REDIRECT = 308;
-  public static final int HTTP_CONTINUE = 100;
-
-  public final Protocol protocol;
-  public final int code;
-  public final String message;
-
-  public StatusLine(Protocol protocol, int code, String message) {
-    this.protocol = protocol;
-    this.code = code;
-    this.message = message;
-  }
-
-  public static StatusLine get(Response response) {
-    return new StatusLine(response.protocol(), response.code(), response.message());
-  }
-
-  public static StatusLine parse(String statusLine) throws IOException {
-    // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
-    // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
-
-    // Parse protocol like "HTTP/1.1" followed by a space.
-    int codeStart;
-    Protocol protocol;
-    if (statusLine.startsWith("HTTP/1.")) {
-      if (statusLine.length() < 9 || statusLine.charAt(8) != ' ') {
-        throw new ProtocolException("Unexpected status line: " + statusLine);
-      }
-      int httpMinorVersion = statusLine.charAt(7) - '0';
-      codeStart = 9;
-      if (httpMinorVersion == 0) {
-        protocol = Protocol.HTTP_1_0;
-      } else if (httpMinorVersion == 1) {
-        protocol = Protocol.HTTP_1_1;
-      } else {
-        throw new ProtocolException("Unexpected status line: " + statusLine);
-      }
-    } else if (statusLine.startsWith("ICY ")) {
-      // Shoutcast uses ICY instead of "HTTP/1.0".
-      protocol = Protocol.HTTP_1_0;
-      codeStart = 4;
-    } else {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
-
-    // Parse response code like "200". Always 3 digits.
-    if (statusLine.length() < codeStart + 3) {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
-    int code;
-    try {
-      code = Integer.parseInt(statusLine.substring(codeStart, codeStart + 3));
-    } catch (NumberFormatException e) {
-      throw new ProtocolException("Unexpected status line: " + statusLine);
-    }
-
-    // Parse an optional response message like "OK" or "Not Modified". If it
-    // exists, it is separated from the response code by a space.
-    String message = "";
-    if (statusLine.length() > codeStart + 3) {
-      if (statusLine.charAt(codeStart + 3) != ' ') {
-        throw new ProtocolException("Unexpected status line: " + statusLine);
-      }
-      message = statusLine.substring(codeStart + 4);
-    }
-
-    return new StatusLine(protocol, code, message);
-  }
-
-  @Override public String toString() {
-    StringBuilder result = new StringBuilder();
-    result.append(protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1");
-    result.append(' ').append(code);
-    if (message != null) {
-      result.append(' ').append(message);
-    }
-    return result.toString();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/StatusLine.kt b/okhttp/src/main/java/okhttp3/internal/http/StatusLine.kt
new file mode 100644
index 0000000000..0006a2ff70
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/StatusLine.kt
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http
+
+import okhttp3.Protocol
+import okhttp3.Response
+import java.io.IOException
+import java.net.ProtocolException
+
+/** An HTTP response status line like "HTTP/1.1 200 OK". */
+class StatusLine(
+  @JvmField val protocol: Protocol,
+  @JvmField val code: Int,
+  @JvmField val message: String
+) {
+
+  override fun toString(): String {
+    return buildString {
+      if (protocol == Protocol.HTTP_1_0) {
+        append("HTTP/1.0")
+      } else {
+        append("HTTP/1.1")
+      }
+      append(' ').append(code)
+      append(' ').append(message)
+    }
+  }
+
+  companion object {
+    /** Numeric status code, 307: Temporary Redirect. */
+    const val HTTP_TEMP_REDIRECT = 307
+    const val HTTP_PERM_REDIRECT = 308
+    const val HTTP_CONTINUE = 100
+
+    @JvmStatic
+    fun get(response: Response): StatusLine {
+      return StatusLine(response.protocol(), response.code(), response.message())
+    }
+
+    @JvmStatic
+    @Throws(IOException::class)
+    fun parse(statusLine: String): StatusLine {
+      // H T T P / 1 . 1   2 0 0   T e m p o r a r y   R e d i r e c t
+      // 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
+
+      // Parse protocol like "HTTP/1.1" followed by a space.
+      val codeStart: Int
+      val protocol: Protocol
+      if (statusLine.startsWith("HTTP/1.")) {
+        if (statusLine.length < 9 || statusLine[8] != ' ') {
+          throw ProtocolException("Unexpected status line: $statusLine")
+        }
+        val httpMinorVersion = statusLine[7] - '0'
+        codeStart = 9
+        if (httpMinorVersion == 0) {
+          protocol = Protocol.HTTP_1_0
+        } else if (httpMinorVersion == 1) {
+          protocol = Protocol.HTTP_1_1
+        } else {
+          throw ProtocolException("Unexpected status line: $statusLine")
+        }
+      } else if (statusLine.startsWith("ICY ")) {
+        // Shoutcast uses ICY instead of "HTTP/1.0".
+        protocol = Protocol.HTTP_1_0
+        codeStart = 4
+      } else {
+        throw ProtocolException("Unexpected status line: $statusLine")
+      }
+
+      // Parse response code like "200". Always 3 digits.
+      if (statusLine.length < codeStart + 3) {
+        throw ProtocolException("Unexpected status line: $statusLine")
+      }
+      val code = try {
+        Integer.parseInt(statusLine.substring(codeStart, codeStart + 3))
+      } catch (_: NumberFormatException) {
+        throw ProtocolException("Unexpected status line: $statusLine")
+      }
+
+      // Parse an optional response message like "OK" or "Not Modified". If it
+      // exists, it is separated from the response code by a space.
+      var message = ""
+      if (statusLine.length > codeStart + 3) {
+        if (statusLine[codeStart + 3] != ' ') {
+          throw ProtocolException("Unexpected status line: $statusLine")
+        }
+        message = statusLine.substring(codeStart + 4)
+      }
+
+      return StatusLine(protocol, code, message)
+    }
+  }
+}
\ No newline at end of file
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
deleted file mode 100644
index 6dc70c4865..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ /dev/null
@@ -1,536 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http1;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.net.ProtocolException;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.connection.StreamAllocation;
-import okhttp3.internal.http.HttpCodec;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.RealResponseBody;
-import okhttp3.internal.http.RequestLine;
-import okhttp3.internal.http.StatusLine;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ForwardingTimeout;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-import okio.Timeout;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static okhttp3.internal.Util.checkOffsetAndCount;
-import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
-
-/**
- * A socket connection that can be used to send HTTP/1.1 messages. This class strictly enforces the
- * following lifecycle:
- *
- * <ol>
- *     <li>{@linkplain #writeRequest Send request headers}.
- *     <li>Open a sink to write the request body. Either {@linkplain #newFixedLengthSink
- *         fixed-length} or {@link #newChunkedSink chunked}.
- *     <li>Write to and then close that sink.
- *     <li>{@linkplain #readResponseHeaders Read response headers}.
- *     <li>Open a source to read the response body. Either {@linkplain #newFixedLengthSource
- *         fixed-length}, {@linkplain #newChunkedSource chunked} or {@linkplain
- *         #newUnknownLengthSource unknown length}.
- *     <li>Read from and close that source.
- * </ol>
- *
- * <p>Exchanges that do not have a request body may skip creating and closing the request body.
- * Exchanges that do not have a response body can call {@link #newFixedLengthSource(long)
- * newFixedLengthSource(0)} and may skip reading and closing that source.
- */
-public final class Http1Codec implements HttpCodec {
-  private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
-  private static final int STATE_OPEN_REQUEST_BODY = 1;
-  private static final int STATE_WRITING_REQUEST_BODY = 2;
-  private static final int STATE_READ_RESPONSE_HEADERS = 3;
-  private static final int STATE_OPEN_RESPONSE_BODY = 4;
-  private static final int STATE_READING_RESPONSE_BODY = 5;
-  private static final int STATE_CLOSED = 6;
-  private static final int HEADER_LIMIT = 256 * 1024;
-
-  /** The client that configures this stream. May be null for HTTPS proxy tunnels. */
-  final OkHttpClient client;
-  /** The stream allocation that owns this stream. May be null for HTTPS proxy tunnels. */
-  final StreamAllocation streamAllocation;
-
-  final BufferedSource source;
-  final BufferedSink sink;
-  int state = STATE_IDLE;
-  private long headerLimit = HEADER_LIMIT;
-
-  /**
-   * Received trailers. Null unless the response body uses chunked transfer-encoding and includes
-   * trailers. Undefined until the end of the response body.
-   */
-  private Headers trailers;
-
-  public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
-      BufferedSink sink) {
-    this.client = client;
-    this.streamAllocation = streamAllocation;
-    this.source = source;
-    this.sink = sink;
-  }
-
-  @Override public Sink createRequestBody(Request request, long contentLength) {
-    if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
-      // Stream a request body of unknown length.
-      return newChunkedSink();
-    }
-
-    if (contentLength != -1) {
-      // Stream a request body of a known length.
-      return newFixedLengthSink(contentLength);
-    }
-
-    throw new IllegalStateException(
-        "Cannot stream a request body without chunked encoding or a known content length!");
-  }
-
-  @Override public void cancel() {
-    RealConnection connection = streamAllocation.connection();
-    if (connection != null) connection.cancel();
-  }
-
-  /**
-   * Prepares the HTTP headers and sends them to the server.
-   *
-   * <p>For streaming requests with a body, headers must be prepared <strong>before</strong> the
-   * output stream has been written to. Otherwise the body would need to be buffered!
-   *
-   * <p>For non-streaming requests with a body, headers must be prepared <strong>after</strong> the
-   * output stream has been written to and closed. This ensures that the {@code Content-Length}
-   * header field receives the proper value.
-   */
-  @Override public void writeRequestHeaders(Request request) throws IOException {
-    String requestLine = RequestLine.get(
-        request, streamAllocation.connection().route().proxy().type());
-    writeRequest(request.headers(), requestLine);
-  }
-
-  @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
-    String contentType = response.header("Content-Type");
-
-    if (!HttpHeaders.hasBody(response)) {
-      Source source = newFixedLengthSource(0);
-      return new RealResponseBody(contentType, 0, Okio.buffer(source));
-    }
-
-    if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      Source source = newChunkedSource(response.request().url());
-      return new RealResponseBody(contentType, -1L, Okio.buffer(source));
-    }
-
-    long contentLength = HttpHeaders.contentLength(response);
-    if (contentLength != -1) {
-      Source source = newFixedLengthSource(contentLength);
-      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
-    }
-
-    return new RealResponseBody(contentType, -1L, Okio.buffer(newUnknownLengthSource()));
-  }
-
-  @Override public Headers trailers() throws IOException {
-    if (state != STATE_CLOSED) {
-      throw new IllegalStateException("too early; can't read the trailers yet");
-    }
-    return trailers != null ? trailers : Util.EMPTY_HEADERS;
-  }
-
-  /** Returns true if this connection is closed. */
-  public boolean isClosed() {
-    return state == STATE_CLOSED;
-  }
-
-  @Override public void flushRequest() throws IOException {
-    sink.flush();
-  }
-
-  @Override public void finishRequest() throws IOException {
-    sink.flush();
-  }
-
-  /** Returns bytes of a request header for sending on an HTTP transport. */
-  public void writeRequest(Headers headers, String requestLine) throws IOException {
-    if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
-    sink.writeUtf8(requestLine).writeUtf8("\r\n");
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      sink.writeUtf8(headers.name(i))
-          .writeUtf8(": ")
-          .writeUtf8(headers.value(i))
-          .writeUtf8("\r\n");
-    }
-    sink.writeUtf8("\r\n");
-    state = STATE_OPEN_REQUEST_BODY;
-  }
-
-  @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
-    if (state != STATE_OPEN_REQUEST_BODY && state != STATE_READ_RESPONSE_HEADERS) {
-      throw new IllegalStateException("state: " + state);
-    }
-
-    try {
-      StatusLine statusLine = StatusLine.parse(readHeaderLine());
-
-      Response.Builder responseBuilder = new Response.Builder()
-          .protocol(statusLine.protocol)
-          .code(statusLine.code)
-          .message(statusLine.message)
-          .headers(readHeaders());
-
-      if (expectContinue && statusLine.code == HTTP_CONTINUE) {
-        return null;
-      } else if (statusLine.code == HTTP_CONTINUE) {
-        state = STATE_READ_RESPONSE_HEADERS;
-        return responseBuilder;
-      }
-
-      state = STATE_OPEN_RESPONSE_BODY;
-      return responseBuilder;
-    } catch (EOFException e) {
-      // Provide more context if the server ends the stream before sending a response.
-      throw new IOException("unexpected end of stream on " + streamAllocation, e);
-    }
-  }
-
-  private String readHeaderLine() throws IOException {
-    String line = source.readUtf8LineStrict(headerLimit);
-    headerLimit -= line.length();
-    return line;
-  }
-
-  /** Reads headers or trailers. */
-  public Headers readHeaders() throws IOException {
-    Headers.Builder headers = new Headers.Builder();
-    // parse the result headers until the first blank line
-    for (String line; (line = readHeaderLine()).length() != 0; ) {
-      Internal.instance.addLenient(headers, line);
-    }
-    return headers.build();
-  }
-
-  public Sink newChunkedSink() {
-    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_WRITING_REQUEST_BODY;
-    return new ChunkedSink();
-  }
-
-  public Sink newFixedLengthSink(long contentLength) {
-    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_WRITING_REQUEST_BODY;
-    return new FixedLengthSink(contentLength);
-  }
-
-  public Source newFixedLengthSource(long length) throws IOException {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READING_RESPONSE_BODY;
-    return new FixedLengthSource(length);
-  }
-
-  public Source newChunkedSource(HttpUrl url) throws IOException {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    state = STATE_READING_RESPONSE_BODY;
-    return new ChunkedSource(url);
-  }
-
-  public Source newUnknownLengthSource() throws IOException {
-    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    if (streamAllocation == null) throw new IllegalStateException("streamAllocation == null");
-    state = STATE_READING_RESPONSE_BODY;
-    streamAllocation.noNewStreams();
-    return new UnknownLengthSource();
-  }
-
-  /**
-   * Sets the delegate of {@code timeout} to {@link Timeout#NONE} and resets its underlying timeout
-   * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
-   * connections.
-   */
-  void detachTimeout(ForwardingTimeout timeout) {
-    Timeout oldDelegate = timeout.delegate();
-    timeout.setDelegate(Timeout.NONE);
-    oldDelegate.clearDeadline();
-    oldDelegate.clearTimeout();
-  }
-
-  /** An HTTP body with a fixed length known in advance. */
-  private final class FixedLengthSink implements Sink {
-    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
-    private boolean closed;
-    private long bytesRemaining;
-
-    FixedLengthSink(long bytesRemaining) {
-      this.bytesRemaining = bytesRemaining;
-    }
-
-    @Override public Timeout timeout() {
-      return timeout;
-    }
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException("closed");
-      checkOffsetAndCount(source.size(), 0, byteCount);
-      if (byteCount > bytesRemaining) {
-        throw new ProtocolException("expected " + bytesRemaining
-            + " bytes but received " + byteCount);
-      }
-      sink.write(source, byteCount);
-      bytesRemaining -= byteCount;
-    }
-
-    @Override public void flush() throws IOException {
-      if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
-      sink.flush();
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      if (bytesRemaining > 0) throw new ProtocolException("unexpected end of stream");
-      detachTimeout(timeout);
-      state = STATE_READ_RESPONSE_HEADERS;
-    }
-  }
-
-  /**
-   * An HTTP body with alternating chunk sizes and chunk bodies. It is the caller's responsibility
-   * to buffer chunks; typically by using a buffered sink with this sink.
-   */
-  private final class ChunkedSink implements Sink {
-    private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
-    private boolean closed;
-
-    ChunkedSink() {
-    }
-
-    @Override public Timeout timeout() {
-      return timeout;
-    }
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (closed) throw new IllegalStateException("closed");
-      if (byteCount == 0) return;
-
-      sink.writeHexadecimalUnsignedLong(byteCount);
-      sink.writeUtf8("\r\n");
-      sink.write(source, byteCount);
-      sink.writeUtf8("\r\n");
-    }
-
-    @Override public synchronized void flush() throws IOException {
-      if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
-      sink.flush();
-    }
-
-    @Override public synchronized void close() throws IOException {
-      if (closed) return;
-      closed = true;
-      sink.writeUtf8("0\r\n\r\n");
-      detachTimeout(timeout);
-      state = STATE_READ_RESPONSE_HEADERS;
-    }
-  }
-
-  private abstract class AbstractSource implements Source {
-    protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
-    protected boolean closed;
-    protected long bytesRead = 0;
-
-    @Override public Timeout timeout() {
-      return timeout;
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      try {
-        long read = source.read(sink, byteCount);
-        if (read > 0) {
-          bytesRead += read;
-        }
-        return read;
-      } catch (IOException e) {
-        endOfInput(false, e);
-        throw e;
-      }
-    }
-
-    /**
-     * Closes the cache entry and makes the socket available for reuse. This should be invoked when
-     * the end of the body has been reached.
-     */
-    protected final void endOfInput(boolean reuseConnection, IOException e) throws IOException {
-      if (state == STATE_CLOSED) return;
-      if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-
-      detachTimeout(timeout);
-
-      state = STATE_CLOSED;
-      if (streamAllocation != null) {
-        streamAllocation.streamFinished(!reuseConnection, Http1Codec.this, bytesRead, e);
-      }
-    }
-  }
-
-  /** An HTTP body with a fixed length specified in advance. */
-  private class FixedLengthSource extends AbstractSource {
-    private long bytesRemaining;
-
-    FixedLengthSource(long length) throws IOException {
-      bytesRemaining = length;
-      if (bytesRemaining == 0) {
-        endOfInput(true, null);
-      }
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-      if (closed) throw new IllegalStateException("closed");
-      if (bytesRemaining == 0) return -1;
-
-      long read = super.read(sink, Math.min(bytesRemaining, byteCount));
-      if (read == -1) {
-        ProtocolException e = new ProtocolException("unexpected end of stream");
-        endOfInput(false, e); // The server didn't supply the promised content length.
-        throw e;
-      }
-
-      bytesRemaining -= read;
-      if (bytesRemaining == 0) {
-        endOfInput(true, null);
-      }
-      return read;
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-
-      if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        endOfInput(false, null);
-      }
-
-      closed = true;
-    }
-  }
-
-  /** An HTTP body with alternating chunk sizes and chunk bodies. */
-  private class ChunkedSource extends AbstractSource {
-    private static final long NO_CHUNK_YET = -1L;
-    private final HttpUrl url;
-    private long bytesRemainingInChunk = NO_CHUNK_YET;
-    private boolean hasMoreChunks = true;
-
-    ChunkedSource(HttpUrl url) {
-      this.url = url;
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-      if (closed) throw new IllegalStateException("closed");
-      if (!hasMoreChunks) return -1;
-
-      if (bytesRemainingInChunk == 0 || bytesRemainingInChunk == NO_CHUNK_YET) {
-        readChunkSize();
-        if (!hasMoreChunks) return -1;
-      }
-
-      long read = super.read(sink, Math.min(byteCount, bytesRemainingInChunk));
-      if (read == -1) {
-        ProtocolException e = new ProtocolException("unexpected end of stream");
-        endOfInput(false, e); // The server didn't supply the promised chunk length.
-        throw e;
-      }
-      bytesRemainingInChunk -= read;
-      return read;
-    }
-
-    private void readChunkSize() throws IOException {
-      // Read the suffix of the previous chunk.
-      if (bytesRemainingInChunk != NO_CHUNK_YET) {
-        source.readUtf8LineStrict();
-      }
-      try {
-        bytesRemainingInChunk = source.readHexadecimalUnsignedLong();
-        String extensions = source.readUtf8LineStrict().trim();
-        if (bytesRemainingInChunk < 0 || (!extensions.isEmpty() && !extensions.startsWith(";"))) {
-          throw new ProtocolException("expected chunk size and optional extensions but was \""
-              + bytesRemainingInChunk + extensions + "\"");
-        }
-      } catch (NumberFormatException e) {
-        throw new ProtocolException(e.getMessage());
-      }
-      if (bytesRemainingInChunk == 0L) {
-        hasMoreChunks = false;
-        trailers = readHeaders();
-        HttpHeaders.receiveHeaders(client.cookieJar(), url, trailers);
-        endOfInput(true, null);
-      }
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-      if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        endOfInput(false, null);
-      }
-      closed = true;
-    }
-  }
-
-  /** An HTTP message body terminated by the end of the underlying stream. */
-  private class UnknownLengthSource extends AbstractSource {
-    private boolean inputExhausted;
-
-    UnknownLengthSource() {
-    }
-
-    @Override public long read(Buffer sink, long byteCount)
-        throws IOException {
-      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
-      if (closed) throw new IllegalStateException("closed");
-      if (inputExhausted) return -1;
-
-      long read = super.read(sink, byteCount);
-      if (read == -1) {
-        inputExhausted = true;
-        endOfInput(true, null);
-        return -1;
-      }
-      return read;
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) return;
-      if (!inputExhausted) {
-        endOfInput(false, null);
-      }
-      closed = true;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1ExchangeCodec.kt b/okhttp/src/main/java/okhttp3/internal/http1/Http1ExchangeCodec.kt
new file mode 100644
index 0000000000..d76f779ec3
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1ExchangeCodec.kt
@@ -0,0 +1,513 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http1
+
+import okhttp3.Headers
+import okhttp3.HttpUrl
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.internal.Util
+import okhttp3.internal.Util.checkOffsetAndCount
+import okhttp3.internal.addHeaderLenient
+import okhttp3.internal.connection.RealConnection
+import okhttp3.internal.http.ExchangeCodec
+import okhttp3.internal.http.HttpHeaders
+import okhttp3.internal.http.RequestLine
+import okhttp3.internal.http.StatusLine
+import okhttp3.internal.http.StatusLine.Companion.HTTP_CONTINUE
+import okio.Buffer
+import okio.BufferedSink
+import okio.BufferedSource
+import okio.ForwardingTimeout
+import okio.Sink
+import okio.Source
+import okio.Timeout
+import java.io.EOFException
+import java.io.IOException
+import java.net.ProtocolException
+import java.util.concurrent.TimeUnit.MILLISECONDS
+
+/**
+ * A socket connection that can be used to send HTTP/1.1 messages. This class strictly enforces the
+ * following lifecycle:
+ *
+ *  1. [Send request headers][writeRequest].
+ *  2. Open a sink to write the request body. Either [known][newKnownLengthSink] or
+ *     [chunked][newChunkedSink].
+ *  3. Write to and then close that sink.
+ *  4. [Read response headers][readResponseHeaders].
+ *  5. Open a source to read the response body. Either [fixed-length][newFixedLengthSource],
+ *     [chunked][newChunkedSource] or [unknown][newUnknownLengthSource].
+ *  6. Read from and close that source.
+ *
+ * Exchanges that do not have a request body may skip creating and closing the request body.
+ * Exchanges that do not have a response body can call
+ * [newFixedLengthSource(0)][newFixedLengthSource] and may skip reading and closing that source.
+ */
+class Http1ExchangeCodec(
+  /** The client that configures this stream. May be null for HTTPS proxy tunnels.  */
+  private val client: OkHttpClient?,
+  /** The connection that carries this stream.  */
+  private val realConnection: RealConnection?,
+  private val source: BufferedSource,
+  private val sink: BufferedSink
+) : ExchangeCodec {
+  private var state = STATE_IDLE
+  private var headerLimit = HEADER_LIMIT.toLong()
+
+  private fun Response.isChunked() =
+      "chunked".equals(header("Transfer-Encoding"), ignoreCase = true)
+
+  private fun Request.isChunked() =
+      "chunked".equals(header("Transfer-Encoding"), ignoreCase = true)
+
+  /**
+   * Received trailers. Null unless the response body uses chunked transfer-encoding and includes
+   * trailers. Undefined until the end of the response body.
+   */
+  private var trailers: Headers? = null
+
+  /** Returns true if this connection is closed.  */
+  val isClosed: Boolean
+    get() = state == STATE_CLOSED
+
+  override fun connection(): RealConnection? {
+    return realConnection
+  }
+
+  override fun createRequestBody(request: Request, contentLength: Long): Sink {
+    return when {
+      request.body() != null && request.body()!!.isDuplex() -> throw ProtocolException(
+          "Duplex connections are not supported for HTTP/1")
+      request.isChunked() -> newChunkedSink() // Stream a request body of unknown length.
+      contentLength != -1L -> newKnownLengthSink() // Stream a request body of a known length.
+      else -> // Stream a request body of a known length.
+        throw IllegalStateException(
+            "Cannot stream a request body without chunked encoding or a known content length!")
+    }
+  }
+
+  override fun cancel() {
+    realConnection?.cancel()
+  }
+
+  /**
+   * Prepares the HTTP headers and sends them to the server.
+   *
+   * For streaming requests with a body, headers must be prepared **before** the
+   * output stream has been written to. Otherwise the body would need to be buffered!
+   *
+   * For non-streaming requests with a body, headers must be prepared **after** the
+   * output stream has been written to and closed. This ensures that the `Content-Length`
+   * header field receives the proper value.
+   */
+  override fun writeRequestHeaders(request: Request) {
+    val requestLine = RequestLine.get(
+        request, realConnection!!.route().proxy().type())
+    writeRequest(request.headers(), requestLine)
+  }
+
+  override fun reportedContentLength(response: Response): Long {
+    return when {
+      !HttpHeaders.hasBody(response) -> 0L
+      response.isChunked() -> -1L
+      else -> HttpHeaders.contentLength(response)
+    }
+  }
+
+  override fun openResponseBodySource(response: Response): Source {
+    return when {
+      !HttpHeaders.hasBody(response) -> newFixedLengthSource(0)
+      response.isChunked() -> newChunkedSource(response.request().url())
+      else -> {
+        val contentLength = HttpHeaders.contentLength(response)
+        if (contentLength != -1L) {
+          newFixedLengthSource(contentLength)
+        } else {
+          newUnknownLengthSource()
+        }
+      }
+    }
+  }
+
+  override fun trailers(): Headers {
+    check(state == STATE_CLOSED) { "too early; can't read the trailers yet" }
+    return trailers ?: Util.EMPTY_HEADERS
+  }
+
+  override fun flushRequest() {
+    sink.flush()
+  }
+
+  override fun finishRequest() {
+    sink.flush()
+  }
+
+  /** Returns bytes of a request header for sending on an HTTP transport.  */
+  fun writeRequest(headers: Headers, requestLine: String) {
+    check(state == STATE_IDLE) { "state: $state" }
+    sink.writeUtf8(requestLine).writeUtf8("\r\n")
+    for (i in 0 until headers.size()) {
+      sink.writeUtf8(headers.name(i))
+          .writeUtf8(": ")
+          .writeUtf8(headers.value(i))
+          .writeUtf8("\r\n")
+    }
+    sink.writeUtf8("\r\n")
+    state = STATE_OPEN_REQUEST_BODY
+  }
+
+  override fun readResponseHeaders(expectContinue: Boolean): Response.Builder? {
+    check(state == STATE_OPEN_REQUEST_BODY || state == STATE_READ_RESPONSE_HEADERS) { "state: $state" }
+
+    try {
+      val statusLine = StatusLine.parse(readHeaderLine())
+
+      val responseBuilder = Response.Builder()
+          .protocol(statusLine.protocol)
+          .code(statusLine.code)
+          .message(statusLine.message)
+          .headers(readHeaders())
+
+      return when {
+        expectContinue && statusLine.code == HTTP_CONTINUE -> null
+        statusLine.code == HTTP_CONTINUE -> {
+          state = STATE_READ_RESPONSE_HEADERS
+          responseBuilder
+        }
+        else -> {
+          state = STATE_OPEN_RESPONSE_BODY
+          responseBuilder
+        }
+      }
+    } catch (e: EOFException) {
+      // Provide more context if the server ends the stream before sending a response.
+      val address = if (realConnection != null) realConnection.route().address().url().redact() else "unknown"
+      throw IOException("unexpected end of stream on $address", e)
+    }
+  }
+
+  private fun readHeaderLine(): String {
+    val line = source.readUtf8LineStrict(headerLimit)
+    headerLimit -= line.length.toLong()
+    return line
+  }
+
+  /** Reads headers or trailers.  */
+  private fun readHeaders(): Headers {
+    val headers = Headers.Builder()
+    // parse the result headers until the first blank line
+    var line = readHeaderLine()
+    while (line.isNotEmpty()) {
+      addHeaderLenient(headers, line)
+      line = readHeaderLine()
+    }
+    return headers.build()
+  }
+
+  private fun newChunkedSink(): Sink {
+    check(state == STATE_OPEN_REQUEST_BODY) { "state: $state" }
+    state = STATE_WRITING_REQUEST_BODY
+    return ChunkedSink()
+  }
+
+  private fun newKnownLengthSink(): Sink {
+    check(state == STATE_OPEN_REQUEST_BODY) { "state: $state" }
+    state = STATE_WRITING_REQUEST_BODY
+    return KnownLengthSink()
+  }
+
+  private fun newFixedLengthSource(length: Long): Source {
+    check(state == STATE_OPEN_RESPONSE_BODY) { "state: $state" }
+    state = STATE_READING_RESPONSE_BODY
+    return FixedLengthSource(length)
+  }
+
+  private fun newChunkedSource(url: HttpUrl): Source {
+    check(state == STATE_OPEN_RESPONSE_BODY) { "state: $state" }
+    state = STATE_READING_RESPONSE_BODY
+    return ChunkedSource(url)
+  }
+
+  private fun newUnknownLengthSource(): Source {
+    check(state == STATE_OPEN_RESPONSE_BODY) { "state: $state" }
+    state = STATE_READING_RESPONSE_BODY
+    realConnection!!.noNewExchanges()
+    return UnknownLengthSource()
+  }
+
+  /**
+   * Sets the delegate of `timeout` to [Timeout.NONE] and resets its underlying timeout
+   * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
+   * connections.
+   */
+  private fun detachTimeout(timeout: ForwardingTimeout) {
+    val oldDelegate = timeout.delegate
+    timeout.setDelegate(Timeout.NONE)
+    oldDelegate.clearDeadline()
+    oldDelegate.clearTimeout()
+  }
+
+  /**
+   * The response body from a CONNECT should be empty, but if it is not then we should consume it
+   * before proceeding.
+   */
+  fun skipConnectBody(response: Response) {
+    val contentLength = HttpHeaders.contentLength(response)
+    if (contentLength == -1L) return
+    val body = newFixedLengthSource(contentLength)
+    Util.skipAll(body, Int.MAX_VALUE, MILLISECONDS)
+    body.close()
+  }
+
+  /** An HTTP request body.  */
+  private inner class KnownLengthSink : Sink {
+    private val timeout = ForwardingTimeout(sink.timeout())
+    private var closed: Boolean = false
+
+    override fun timeout(): Timeout = timeout
+
+    override fun write(source: Buffer, byteCount: Long) {
+      check(!closed) { "closed" }
+      checkOffsetAndCount(source.size, 0, byteCount)
+      sink.write(source, byteCount)
+    }
+
+    override fun flush() {
+      if (closed) return // Don't throw; this stream might have been closed on the caller's behalf.
+      sink.flush()
+    }
+
+    override fun close() {
+      if (closed) return
+      closed = true
+      detachTimeout(timeout)
+      state = STATE_READ_RESPONSE_HEADERS
+    }
+  }
+
+  /**
+   * An HTTP body with alternating chunk sizes and chunk bodies. It is the caller's responsibility
+   * to buffer chunks; typically by using a buffered sink with this sink.
+   */
+  private inner class ChunkedSink : Sink {
+    private val timeout = ForwardingTimeout(sink.timeout())
+    private var closed: Boolean = false
+
+    override fun timeout(): Timeout = timeout
+
+    override fun write(source: Buffer, byteCount: Long) {
+      check(!closed) { "closed" }
+      if (byteCount == 0L) return
+
+      sink.writeHexadecimalUnsignedLong(byteCount)
+      sink.writeUtf8("\r\n")
+      sink.write(source, byteCount)
+      sink.writeUtf8("\r\n")
+    }
+
+    @Synchronized
+    override fun flush() {
+      if (closed) return // Don't throw; this stream might have been closed on the caller's behalf.
+      sink.flush()
+    }
+
+    @Synchronized
+    override fun close() {
+      if (closed) return
+      closed = true
+      sink.writeUtf8("0\r\n\r\n")
+      detachTimeout(timeout)
+      state = STATE_READ_RESPONSE_HEADERS
+    }
+  }
+
+  private abstract inner class AbstractSource : Source {
+    protected val timeout = ForwardingTimeout(source.timeout())
+    protected var closed: Boolean = false
+
+    override fun timeout(): Timeout = timeout
+
+    override fun read(sink: Buffer, byteCount: Long): Long {
+      return try {
+        source.read(sink, byteCount)
+      } catch (e: IOException) {
+        realConnection!!.noNewExchanges()
+        responseBodyComplete()
+        throw e
+      }
+    }
+
+    /**
+     * Closes the cache entry and makes the socket available for reuse. This should be invoked when
+     * the end of the body has been reached.
+     */
+    internal fun responseBodyComplete() {
+      if (state == STATE_CLOSED) return
+      if (state != STATE_READING_RESPONSE_BODY) throw IllegalStateException("state: $state")
+
+      detachTimeout(timeout)
+
+      state = STATE_CLOSED
+    }
+  }
+
+  /** An HTTP body with a fixed length specified in advance.  */
+  private inner class FixedLengthSource internal constructor(private var bytesRemaining: Long) :
+      AbstractSource() {
+
+    init {
+      if (bytesRemaining == 0L) {
+        responseBodyComplete()
+      }
+    }
+
+    override fun read(sink: Buffer, byteCount: Long): Long {
+      if (byteCount < 0) throw IllegalArgumentException("byteCount < 0: $byteCount")
+      if (closed) throw IllegalStateException("closed")
+      if (bytesRemaining == 0L) return -1
+
+      val read = super.read(sink, minOf(bytesRemaining, byteCount))
+      if (read == -1L) {
+        realConnection!!.noNewExchanges() // The server didn't supply the promised content length.
+        val e = ProtocolException("unexpected end of stream")
+        responseBodyComplete()
+        throw e
+      }
+
+      bytesRemaining -= read
+      if (bytesRemaining == 0L) {
+        responseBodyComplete()
+      }
+      return read
+    }
+
+    override fun close() {
+      if (closed) return
+
+      if (bytesRemaining != 0L && !Util.discard(this,
+              ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+        realConnection!!.noNewExchanges() // Unread bytes remain on the stream.
+        responseBodyComplete()
+      }
+
+      closed = true
+    }
+  }
+
+  /** An HTTP body with alternating chunk sizes and chunk bodies.  */
+  private inner class ChunkedSource internal constructor(private val url: HttpUrl) :
+      AbstractSource() {
+    private var bytesRemainingInChunk = NO_CHUNK_YET
+    private var hasMoreChunks = true
+
+    override fun read(sink: Buffer, byteCount: Long): Long {
+      require(byteCount >= 0) { "byteCount < 0: $byteCount" }
+      check(!closed) { "closed" }
+      if (!hasMoreChunks) return -1
+
+      if (bytesRemainingInChunk == 0L || bytesRemainingInChunk == NO_CHUNK_YET) {
+        readChunkSize()
+        if (!hasMoreChunks) return -1
+      }
+
+      val read = super.read(sink, minOf(byteCount, bytesRemainingInChunk))
+      if (read == -1L) {
+        realConnection!!.noNewExchanges() // The server didn't supply the promised chunk length.
+        val e = ProtocolException("unexpected end of stream")
+        responseBodyComplete()
+        throw e
+      }
+      bytesRemainingInChunk -= read
+      return read
+    }
+
+    private fun readChunkSize() {
+      // Read the suffix of the previous chunk.
+      if (bytesRemainingInChunk != NO_CHUNK_YET) {
+        source.readUtf8LineStrict()
+      }
+      try {
+        bytesRemainingInChunk = source.readHexadecimalUnsignedLong()
+        val extensions = source.readUtf8LineStrict().trim { it <= ' ' }
+        if (bytesRemainingInChunk < 0 || extensions.isNotEmpty() && !extensions.startsWith(";")) {
+          throw ProtocolException(
+              "expected chunk size and optional extensions but was \"$bytesRemainingInChunk$extensions\"")
+        }
+      } catch (e: NumberFormatException) {
+        throw ProtocolException(e.message)
+      }
+
+      if (bytesRemainingInChunk == 0L) {
+        hasMoreChunks = false
+        trailers = readHeaders()
+        HttpHeaders.receiveHeaders(client!!.cookieJar(), url, trailers)
+        responseBodyComplete()
+      }
+    }
+
+    override fun close() {
+      if (closed) return
+      if (hasMoreChunks && !Util.discard(this, ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS,
+              MILLISECONDS)) {
+        realConnection!!.noNewExchanges() // Unread bytes remain on the stream.
+        responseBodyComplete()
+      }
+      closed = true
+    }
+  }
+
+  /** An HTTP message body terminated by the end of the underlying stream.  */
+  private inner class UnknownLengthSource : AbstractSource() {
+    private var inputExhausted: Boolean = false
+
+    override fun read(sink: Buffer, byteCount: Long): Long {
+      require(byteCount >= 0) { "byteCount < 0: $byteCount" }
+      check(!closed) { "closed" }
+      if (inputExhausted) return -1
+
+      val read = super.read(sink, byteCount)
+      if (read == -1L) {
+        inputExhausted = true
+        responseBodyComplete()
+        return -1
+      }
+      return read
+    }
+
+    override fun close() {
+      if (closed) return
+      if (!inputExhausted) {
+        responseBodyComplete()
+      }
+      closed = true
+    }
+  }
+
+  companion object {
+    private const val NO_CHUNK_YET = -1L
+
+    private const val STATE_IDLE = 0 // Idle connections are ready to write request headers.
+    private const val STATE_OPEN_REQUEST_BODY = 1
+    private const val STATE_WRITING_REQUEST_BODY = 2
+    private const val STATE_READ_RESPONSE_HEADERS = 3
+    private const val STATE_OPEN_RESPONSE_BODY = 4
+    private const val STATE_READING_RESPONSE_BODY = 5
+    private const val STATE_CLOSED = 6
+    private const val HEADER_LIMIT = 256 * 1024
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java b/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.kt
similarity index 85%
rename from okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java
rename to okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.kt
index 00c4f2441c..ceeea4f1c3 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.kt
@@ -13,13 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http2;
+package okhttp3.internal.http2
 
-import java.io.IOException;
+import java.io.IOException
 
 /**
  * Thrown when an HTTP/2 connection is shutdown (either explicitly or if the peer has sent a GOAWAY
  * frame) and an attempt is made to use the connection.
  */
-public final class ConnectionShutdownException extends IOException {
-}
+class ConnectionShutdownException : IOException()
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Header.java b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
deleted file mode 100644
index a306ac4622..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Header.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import okhttp3.internal.Util;
-import okio.ByteString;
-
-/** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
-public final class Header {
-  // Special header names defined in HTTP/2 spec.
-  public static final ByteString PSEUDO_PREFIX = ByteString.encodeUtf8(":");
-
-  public static final String RESPONSE_STATUS_UTF8 = ":status";
-  public static final String TARGET_METHOD_UTF8 = ":method";
-  public static final String TARGET_PATH_UTF8 = ":path";
-  public static final String TARGET_SCHEME_UTF8 = ":scheme";
-  public static final String TARGET_AUTHORITY_UTF8 = ":authority";
-
-  public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(RESPONSE_STATUS_UTF8);
-  public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(TARGET_METHOD_UTF8);
-  public static final ByteString TARGET_PATH = ByteString.encodeUtf8(TARGET_PATH_UTF8);
-  public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(TARGET_SCHEME_UTF8);
-  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(TARGET_AUTHORITY_UTF8);
-
-
-  /** Name in case-insensitive ASCII encoding. */
-  public final ByteString name;
-  /** Value in UTF-8 encoding. */
-  public final ByteString value;
-  final int hpackSize;
-
-  // TODO: search for toLowerCase and consider moving logic here.
-  public Header(String name, String value) {
-    this(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value));
-  }
-
-  public Header(ByteString name, String value) {
-    this(name, ByteString.encodeUtf8(value));
-  }
-
-  public Header(ByteString name, ByteString value) {
-    this.name = name;
-    this.value = value;
-    this.hpackSize = 32 + name.size() + value.size();
-  }
-
-  @Override public boolean equals(Object other) {
-    if (other instanceof Header) {
-      Header that = (Header) other;
-      return this.name.equals(that.name)
-          && this.value.equals(that.value);
-    }
-    return false;
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + name.hashCode();
-    result = 31 * result + value.hashCode();
-    return result;
-  }
-
-  @Override public String toString() {
-    return Util.format("%s: %s", name.utf8(), value.utf8());
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Header.kt b/okhttp/src/main/java/okhttp3/internal/http2/Header.kt
new file mode 100644
index 0000000000..fcf0225938
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Header.kt
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2
+
+import okhttp3.internal.Util
+import okio.ByteString
+import okio.ByteString.Companion.encodeUtf8
+
+/** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
+data class Header(
+  /** Name in case-insensitive ASCII encoding. */
+  @JvmField val name: ByteString,
+  /** Value in UTF-8 encoding. */
+  @JvmField val value: ByteString
+) {
+  @JvmField internal val hpackSize = 32 + name.size + value.size
+
+  // TODO: search for toLowerCase and consider moving logic here.
+  constructor(name: String, value: String) : this(name.encodeUtf8(), value.encodeUtf8())
+
+  constructor(name: ByteString, value: String) : this(name, value.encodeUtf8())
+
+  override fun toString(): String {
+    return Util.format("%s: %s", name.utf8(), value.utf8())
+  }
+
+  companion object {
+    // Special header names defined in HTTP/2 spec.
+    @JvmField val PSEUDO_PREFIX: ByteString = ":".encodeUtf8()
+
+    const val RESPONSE_STATUS_UTF8 = ":status"
+    const val TARGET_METHOD_UTF8 = ":method"
+    const val TARGET_PATH_UTF8 = ":path"
+    const val TARGET_SCHEME_UTF8 = ":scheme"
+    const val TARGET_AUTHORITY_UTF8 = ":authority"
+
+    @JvmField val RESPONSE_STATUS: ByteString = RESPONSE_STATUS_UTF8.encodeUtf8()
+    @JvmField val TARGET_METHOD: ByteString = TARGET_METHOD_UTF8.encodeUtf8()
+    @JvmField val TARGET_PATH: ByteString = TARGET_PATH_UTF8.encodeUtf8()
+    @JvmField val TARGET_SCHEME: ByteString = TARGET_SCHEME_UTF8.encodeUtf8()
+    @JvmField val TARGET_AUTHORITY: ByteString = TARGET_AUTHORITY_UTF8.encodeUtf8()
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
deleted file mode 100644
index 9200e6ef1a..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Locale;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Headers;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.connection.StreamAllocation;
-import okhttp3.internal.http.HttpCodec;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.RealResponseBody;
-import okhttp3.internal.http.RequestLine;
-import okhttp3.internal.http.StatusLine;
-import okio.Buffer;
-import okio.ForwardingSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-
-import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
-import static okhttp3.internal.http2.Header.RESPONSE_STATUS_UTF8;
-import static okhttp3.internal.http2.Header.TARGET_AUTHORITY;
-import static okhttp3.internal.http2.Header.TARGET_AUTHORITY_UTF8;
-import static okhttp3.internal.http2.Header.TARGET_METHOD;
-import static okhttp3.internal.http2.Header.TARGET_METHOD_UTF8;
-import static okhttp3.internal.http2.Header.TARGET_PATH;
-import static okhttp3.internal.http2.Header.TARGET_PATH_UTF8;
-import static okhttp3.internal.http2.Header.TARGET_SCHEME;
-import static okhttp3.internal.http2.Header.TARGET_SCHEME_UTF8;
-
-/** Encode requests and responses using HTTP/2 frames. */
-public final class Http2Codec implements HttpCodec {
-  private static final String CONNECTION = "connection";
-  private static final String HOST = "host";
-  private static final String KEEP_ALIVE = "keep-alive";
-  private static final String PROXY_CONNECTION = "proxy-connection";
-  private static final String TRANSFER_ENCODING = "transfer-encoding";
-  private static final String TE = "te";
-  private static final String ENCODING = "encoding";
-  private static final String UPGRADE = "upgrade";
-
-  /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
-  private static final List<String> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
-      CONNECTION,
-      HOST,
-      KEEP_ALIVE,
-      PROXY_CONNECTION,
-      TE,
-      TRANSFER_ENCODING,
-      ENCODING,
-      UPGRADE,
-      TARGET_METHOD_UTF8,
-      TARGET_PATH_UTF8,
-      TARGET_SCHEME_UTF8,
-      TARGET_AUTHORITY_UTF8);
-  private static final List<String> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
-      CONNECTION,
-      HOST,
-      KEEP_ALIVE,
-      PROXY_CONNECTION,
-      TE,
-      TRANSFER_ENCODING,
-      ENCODING,
-      UPGRADE);
-
-  private final Interceptor.Chain chain;
-  final StreamAllocation streamAllocation;
-  private final Http2Connection connection;
-  private volatile Http2Stream stream;
-  private final Protocol protocol;
-  private volatile boolean canceled;
-
-  public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation streamAllocation,
-      Http2Connection connection) {
-    this.chain = chain;
-    this.streamAllocation = streamAllocation;
-    this.connection = connection;
-    this.protocol = client.protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)
-        ? Protocol.H2_PRIOR_KNOWLEDGE
-        : Protocol.HTTP_2;
-  }
-
-  @Override public Sink createRequestBody(Request request, long contentLength) {
-    return stream.getSink();
-  }
-
-  @Override public void writeRequestHeaders(Request request) throws IOException {
-    if (stream != null) return;
-
-    boolean hasRequestBody = request.body() != null;
-    List<Header> requestHeaders = http2HeadersList(request);
-    stream = connection.newStream(requestHeaders, hasRequestBody);
-    // We may have been asked to cancel while creating the new stream and sending the request
-    // headers, but there was still no stream to close.
-    if (canceled) {
-      stream.closeLater(ErrorCode.CANCEL);
-      throw new IOException("Canceled");
-    }
-    stream.readTimeout().timeout(chain.readTimeoutMillis(), TimeUnit.MILLISECONDS);
-    stream.writeTimeout().timeout(chain.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
-  }
-
-  @Override public void flushRequest() throws IOException {
-    connection.flush();
-  }
-
-  @Override public void finishRequest() throws IOException {
-    stream.getSink().close();
-  }
-
-  @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
-    Headers headers = stream.takeHeaders();
-    Response.Builder responseBuilder = readHttp2HeadersList(headers, protocol);
-    if (expectContinue && Internal.instance.code(responseBuilder) == HTTP_CONTINUE) {
-      return null;
-    }
-    return responseBuilder;
-  }
-
-  public static List<Header> http2HeadersList(Request request) {
-    Headers headers = request.headers();
-    List<Header> result = new ArrayList<>(headers.size() + 4);
-    result.add(new Header(TARGET_METHOD, request.method()));
-    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
-    String host = request.header("Host");
-    if (host != null) {
-      result.add(new Header(TARGET_AUTHORITY, host)); // Optional.
-    }
-    result.add(new Header(TARGET_SCHEME, request.url().scheme()));
-
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      // header names must be lowercase.
-      String name = headers.name(i).toLowerCase(Locale.US);
-      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name)
-          || name.equals(TE) && headers.value(i).equals("trailers")) {
-        result.add(new Header(name, headers.value(i)));
-      }
-    }
-    return result;
-  }
-
-  /** Returns headers for a name value block containing an HTTP/2 response. */
-  public static Response.Builder readHttp2HeadersList(Headers headerBlock,
-      Protocol protocol) throws IOException {
-    StatusLine statusLine = null;
-    Headers.Builder headersBuilder = new Headers.Builder();
-    for (int i = 0, size = headerBlock.size(); i < size; i++) {
-      String name = headerBlock.name(i);
-      String value = headerBlock.value(i);
-      if (name.equals(RESPONSE_STATUS_UTF8)) {
-        statusLine = StatusLine.parse("HTTP/1.1 " + value);
-      } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
-        Internal.instance.addLenient(headersBuilder, name, value);
-      }
-    }
-    if (statusLine == null) throw new ProtocolException("Expected ':status' header not present");
-
-    return new Response.Builder()
-        .protocol(protocol)
-        .code(statusLine.code)
-        .message(statusLine.message)
-        .headers(headersBuilder.build());
-  }
-
-  @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
-    String contentType = response.header("Content-Type");
-    long contentLength = HttpHeaders.contentLength(response);
-    Source source = new StreamFinishingSource(stream.getSource());
-    return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
-  }
-
-  @Override public Headers trailers() throws IOException {
-    return stream.trailers();
-  }
-
-  @Override public void cancel() {
-    canceled = true;
-    if (stream != null) stream.closeLater(ErrorCode.CANCEL);
-  }
-
-  class StreamFinishingSource extends ForwardingSource {
-    boolean completed = false;
-    long bytesRead = 0;
-
-    StreamFinishingSource(Source delegate) {
-      super(delegate);
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      try {
-        long read = delegate().read(sink, byteCount);
-        if (read > 0) {
-          bytesRead += read;
-        }
-        return read;
-      } catch (IOException e) {
-        endOfInput(e);
-        throw e;
-      }
-    }
-
-    @Override public void close() throws IOException {
-      super.close();
-      endOfInput(null);
-    }
-
-    private void endOfInput(IOException e) {
-      if (completed) return;
-      completed = true;
-      streamAllocation.streamFinished(false, Http2Codec.this, bytesRead, e);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index cf1413f886..69a47eca3d 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -34,6 +34,7 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import okhttp3.Headers;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Util;
@@ -323,7 +324,7 @@ void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
           try {
             writeSynReset(streamId, errorCode);
           } catch (IOException e) {
-            failConnection();
+            failConnection(e);
           }
         }
       });
@@ -344,7 +345,7 @@ void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRe
               try {
                 writer.windowUpdate(streamId, unacknowledgedBytesRead);
               } catch (IOException e) {
-                failConnection();
+                failConnection(e);
               }
             }
           });
@@ -378,7 +379,7 @@ void writePing(boolean reply, int payload1, int payload2) {
         awaitingPong = true;
       }
       if (failedDueToMissingPong) {
-        failConnection();
+        failConnection(null);
         return;
       }
     }
@@ -386,7 +387,7 @@ void writePing(boolean reply, int payload1, int payload2) {
     try {
       writer.ping(reply, payload1, payload2);
     } catch (IOException e) {
-      failConnection();
+      failConnection(e);
     }
   }
 
@@ -432,23 +433,21 @@ public void shutdown(ErrorCode statusCode) throws IOException {
    * Closes this connection. This cancels all open streams and unanswered pings. It closes the
    * underlying input and output streams and shuts down internal executor services.
    */
-  @Override public void close() throws IOException {
-    close(ErrorCode.NO_ERROR, ErrorCode.CANCEL);
+  @Override public void close() {
+    close(ErrorCode.NO_ERROR, ErrorCode.CANCEL, null);
   }
 
-  void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
+  void close(ErrorCode connectionCode, ErrorCode streamCode, @Nullable IOException cause) {
     assert (!Thread.holdsLock(this));
-    IOException thrown = null;
     try {
       shutdown(connectionCode);
-    } catch (IOException e) {
-      thrown = e;
+    } catch (IOException ignored) {
     }
 
     Http2Stream[] streamsToClose = null;
     synchronized (this) {
       if (!streams.isEmpty()) {
-        streamsToClose = streams.values().toArray(new Http2Stream[streams.size()]);
+        streamsToClose = streams.values().toArray(new Http2Stream[0]);
         streams.clear();
       }
     }
@@ -456,9 +455,8 @@ void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
     if (streamsToClose != null) {
       for (Http2Stream stream : streamsToClose) {
         try {
-          stream.close(streamCode);
-        } catch (IOException e) {
-          if (thrown != null) thrown = e;
+          stream.close(streamCode, cause);
+        } catch (IOException ignored) {
         }
       }
     }
@@ -466,29 +464,22 @@ void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
     // Close the writer to release its resources (such as deflaters).
     try {
       writer.close();
-    } catch (IOException e) {
-      if (thrown == null) thrown = e;
+    } catch (IOException ignored) {
     }
 
     // Close the socket to break out the reader thread, which will clean up after itself.
     try {
       socket.close();
-    } catch (IOException e) {
-      thrown = e;
+    } catch (IOException ignored) {
     }
 
     // Release the threads.
     writerExecutor.shutdown();
     pushExecutor.shutdown();
-
-    if (thrown != null) throw thrown;
   }
 
-  private void failConnection() {
-    try {
-      close(ErrorCode.PROTOCOL_ERROR, ErrorCode.PROTOCOL_ERROR);
-    } catch (IOException ignored) {
-    }
+  private void failConnection(@Nullable IOException e) {
+    close(ErrorCode.PROTOCOL_ERROR, ErrorCode.PROTOCOL_ERROR, e);
   }
 
   /**
@@ -603,6 +594,7 @@ public Http2Connection build() {
     @Override protected void execute() {
       ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
       ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
+      IOException errorException = null;
       try {
         reader.readConnectionPreface(this);
         while (reader.nextFrame(false, this)) {
@@ -610,13 +602,11 @@ public Http2Connection build() {
         connectionErrorCode = ErrorCode.NO_ERROR;
         streamErrorCode = ErrorCode.CANCEL;
       } catch (IOException e) {
+        errorException = e;
         connectionErrorCode = ErrorCode.PROTOCOL_ERROR;
         streamErrorCode = ErrorCode.PROTOCOL_ERROR;
       } finally {
-        try {
-          close(connectionErrorCode, streamErrorCode);
-        } catch (IOException ignored) {
-        }
+        close(connectionErrorCode, streamErrorCode, errorException);
         Util.closeQuietly(reader);
       }
     }
@@ -675,7 +665,7 @@ public Http2Connection build() {
                 Platform.get().log(
                     INFO, "Http2Connection.Listener failure for " + connectionName, e);
                 try {
-                  newStream.close(ErrorCode.PROTOCOL_ERROR);
+                  newStream.close(ErrorCode.PROTOCOL_ERROR, e);
                 } catch (IOException ignored) {
                 }
               }
@@ -715,7 +705,7 @@ public Http2Connection build() {
             receivedInitialPeerSettings = true;
           }
           if (!streams.isEmpty()) {
-            streamsToNotify = streams.values().toArray(new Http2Stream[streams.size()]);
+            streamsToNotify = streams.values().toArray(new Http2Stream[0]);
           }
         }
         listenerExecutor.execute(new NamedRunnable("OkHttp %s settings", connectionName) {
@@ -740,7 +730,7 @@ private void applyAndAckSettings(final Settings peerSettings) {
             try {
               writer.applyAndAckSettings(peerSettings);
             } catch (IOException e) {
-              failConnection();
+              failConnection(e);
             }
           }
         });
@@ -776,7 +766,7 @@ private void applyAndAckSettings(final Settings peerSettings) {
       // Copy the streams first. We don't want to hold a lock when we call receiveRstStream().
       Http2Stream[] streamsCopy;
       synchronized (Http2Connection.this) {
-        streamsCopy = streams.values().toArray(new Http2Stream[streams.size()]);
+        streamsCopy = streams.values().toArray(new Http2Stream[0]);
         shutdown = true;
       }
 
@@ -928,7 +918,7 @@ private synchronized void pushExecutorExecute(NamedRunnable namedRunnable) {
   public abstract static class Listener {
     public static final Listener REFUSE_INCOMING_STREAMS = new Listener() {
       @Override public void onStream(Http2Stream stream) throws IOException {
-        stream.close(REFUSED_STREAM);
+        stream.close(REFUSED_STREAM, null);
       }
     };
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2ExchangeCodec.kt b/okhttp/src/main/java/okhttp3/internal/http2/Http2ExchangeCodec.kt
new file mode 100644
index 0000000000..8b38796d40
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2ExchangeCodec.kt
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2
+
+import okhttp3.Headers
+import okhttp3.Interceptor
+import okhttp3.OkHttpClient
+import okhttp3.Protocol
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.internal.Internal
+import okhttp3.internal.Util
+import okhttp3.internal.addHeaderLenient
+import okhttp3.internal.connection.RealConnection
+import okhttp3.internal.http.ExchangeCodec
+import okhttp3.internal.http.HttpHeaders
+import okhttp3.internal.http.RequestLine
+import okhttp3.internal.http.StatusLine
+import okhttp3.internal.http.StatusLine.Companion.HTTP_CONTINUE
+import okhttp3.internal.http2.Header.Companion.RESPONSE_STATUS_UTF8
+import okhttp3.internal.http2.Header.Companion.TARGET_AUTHORITY
+import okhttp3.internal.http2.Header.Companion.TARGET_AUTHORITY_UTF8
+import okhttp3.internal.http2.Header.Companion.TARGET_METHOD
+import okhttp3.internal.http2.Header.Companion.TARGET_METHOD_UTF8
+import okhttp3.internal.http2.Header.Companion.TARGET_PATH
+import okhttp3.internal.http2.Header.Companion.TARGET_PATH_UTF8
+import okhttp3.internal.http2.Header.Companion.TARGET_SCHEME
+import okhttp3.internal.http2.Header.Companion.TARGET_SCHEME_UTF8
+import okio.Sink
+import okio.Source
+import java.io.IOException
+import java.net.ProtocolException
+import java.util.ArrayList
+import java.util.Locale
+import java.util.concurrent.TimeUnit
+
+/** Encode requests and responses using HTTP/2 frames.  */
+class Http2ExchangeCodec(
+  client: OkHttpClient,
+  private val realConnection: RealConnection,
+  private val chain: Interceptor.Chain,
+  private val connection: Http2Connection
+) : ExchangeCodec {
+  @Volatile private var stream: Http2Stream? = null
+
+  private val protocol: Protocol = if (Protocol.H2_PRIOR_KNOWLEDGE in client.protocols()) {
+    Protocol.H2_PRIOR_KNOWLEDGE
+  } else {
+    Protocol.HTTP_2
+  }
+
+  @Volatile
+  private var canceled: Boolean = false
+
+  override fun connection(): RealConnection {
+    return realConnection
+  }
+
+  override fun createRequestBody(request: Request, contentLength: Long): Sink {
+    return stream!!.getSink()
+  }
+
+  override fun writeRequestHeaders(request: Request) {
+    if (stream != null) return
+
+    val hasRequestBody = request.body() != null
+    val requestHeaders = http2HeadersList(request)
+    stream = connection.newStream(requestHeaders, hasRequestBody)
+    // We may have been asked to cancel while creating the new stream and sending the request
+    // headers, but there was still no stream to close.
+    if (canceled) {
+      stream!!.closeLater(ErrorCode.CANCEL)
+      throw IOException("Canceled")
+    }
+    stream!!.readTimeout().timeout(chain.readTimeoutMillis().toLong(), TimeUnit.MILLISECONDS)
+    stream!!.writeTimeout().timeout(chain.writeTimeoutMillis().toLong(), TimeUnit.MILLISECONDS)
+  }
+
+  override fun flushRequest() {
+    connection.flush()
+  }
+
+  override fun finishRequest() {
+    stream!!.getSink().close()
+  }
+
+  override fun readResponseHeaders(expectContinue: Boolean): Response.Builder? {
+    val headers = stream!!.takeHeaders()
+    val responseBuilder = readHttp2HeadersList(headers, protocol)
+    return if (expectContinue && Internal.instance.code(responseBuilder) == HTTP_CONTINUE) {
+      null
+    } else {
+      responseBuilder
+    }
+  }
+
+  override fun reportedContentLength(response: Response): Long {
+    return HttpHeaders.contentLength(response)
+  }
+
+  override fun openResponseBodySource(response: Response): Source {
+    return stream!!.source
+  }
+
+  override fun trailers(): Headers {
+    return stream!!.trailers()
+  }
+
+  override fun cancel() {
+    canceled = true
+    stream?.closeLater(ErrorCode.CANCEL)
+  }
+
+  companion object {
+    private const val CONNECTION = "connection"
+    private const val HOST = "host"
+    private const val KEEP_ALIVE = "keep-alive"
+    private const val PROXY_CONNECTION = "proxy-connection"
+    private const val TRANSFER_ENCODING = "transfer-encoding"
+    private const val TE = "te"
+    private const val ENCODING = "encoding"
+    private const val UPGRADE = "upgrade"
+
+    /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3.  */
+    private val HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
+        CONNECTION,
+        HOST,
+        KEEP_ALIVE,
+        PROXY_CONNECTION,
+        TE,
+        TRANSFER_ENCODING,
+        ENCODING,
+        UPGRADE,
+        TARGET_METHOD_UTF8,
+        TARGET_PATH_UTF8,
+        TARGET_SCHEME_UTF8,
+        TARGET_AUTHORITY_UTF8)
+    private val HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
+        CONNECTION,
+        HOST,
+        KEEP_ALIVE,
+        PROXY_CONNECTION,
+        TE,
+        TRANSFER_ENCODING,
+        ENCODING,
+        UPGRADE)
+
+    fun http2HeadersList(request: Request): List<Header> {
+      val headers = request.headers()
+      val result = ArrayList<Header>(headers.size() + 4)
+      result.add(Header(TARGET_METHOD, request.method()))
+      result.add(Header(TARGET_PATH, RequestLine.requestPath(request.url())))
+      val host = request.header("Host")
+      if (host != null) {
+        result.add(Header(TARGET_AUTHORITY, host)) // Optional.
+      }
+      result.add(Header(TARGET_SCHEME, request.url().scheme()))
+
+      for (i in 0 until headers.size()) {
+        // header names must be lowercase.
+        val name = headers.name(i).toLowerCase(Locale.US)
+        if (name !in HTTP_2_SKIPPED_REQUEST_HEADERS ||
+            name == TE && headers.value(i) == "trailers") {
+          result.add(Header(name, headers.value(i)))
+        }
+      }
+      return result
+    }
+
+    /** Returns headers for a name value block containing an HTTP/2 response.  */
+    fun readHttp2HeadersList(headerBlock: Headers, protocol: Protocol): Response.Builder {
+      var statusLine: StatusLine? = null
+      val headersBuilder = Headers.Builder()
+      for (i in 0 until headerBlock.size()) {
+        val name = headerBlock.name(i)
+        val value = headerBlock.value(i)
+        if (name == RESPONSE_STATUS_UTF8) {
+          statusLine = StatusLine.parse("HTTP/1.1 $value")
+        } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
+          addHeaderLenient(headersBuilder, name, value)
+        }
+      }
+      if (statusLine == null) throw ProtocolException("Expected ':status' header not present")
+
+      return Response.Builder()
+          .protocol(protocol)
+          .code(statusLine.code)
+          .message(statusLine.message)
+          .headers(headersBuilder.build())
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
index 1484a269eb..3137131126 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
@@ -16,6 +16,7 @@
 package okhttp3.internal.http2;
 
 import java.io.Closeable;
+import java.io.EOFException;
 import java.io.IOException;
 import java.util.List;
 import java.util.logging.Logger;
@@ -93,7 +94,7 @@ public void readConnectionPreface(Handler handler) throws IOException {
   public boolean nextFrame(boolean requireSettings, Handler handler) throws IOException {
     try {
       source.require(9); // Frame header size
-    } catch (IOException e) {
+    } catch (EOFException e) {
       return false; // This might be a normal socket close.
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
index 3431901fa5..c8049e9ace 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -74,7 +74,10 @@
    * close this stream (such as both peers closing it near-simultaneously) then this is the first
    * reason known to this peer.
    */
-  ErrorCode errorCode = null;
+  @Nullable ErrorCode errorCode;
+
+  /** The exception that explains {@code errorCode}. Null if no exception was provided. */
+  @Nullable IOException errorException;
 
   Http2Stream(int id, Http2Connection connection, boolean outFinished, boolean inFinished,
       @Nullable Headers headers) {
@@ -153,7 +156,7 @@ public synchronized Headers takeHeaders() throws IOException {
     if (!headersQueue.isEmpty()) {
       return headersQueue.removeFirst();
     }
-    throw new StreamResetException(errorCode);
+    throw errorException != null ? errorException : new StreamResetException(errorCode);
   }
 
   /**
@@ -162,7 +165,7 @@ public synchronized Headers takeHeaders() throws IOException {
    */
   public synchronized Headers trailers() throws IOException {
     if (errorCode != null) {
-      throw new StreamResetException(errorCode);
+      throw errorException != null ? errorException : new StreamResetException(errorCode);
     }
     if (!source.finished || !source.receiveBuffer.exhausted() || !source.readBuffer.exhausted()) {
       throw new IllegalStateException("too early; can't read the trailers yet");
@@ -254,8 +257,9 @@ public Sink getSink() {
    * Abnormally terminate this stream. This blocks until the {@code RST_STREAM} frame has been
    * transmitted.
    */
-  public void close(ErrorCode rstStatusCode) throws IOException {
-    if (!closeInternal(rstStatusCode)) {
+  public void close(ErrorCode rstStatusCode, @Nullable IOException errorException)
+      throws IOException {
+    if (!closeInternal(rstStatusCode, errorException)) {
       return; // Already closed.
     }
     connection.writeSynReset(id, rstStatusCode);
@@ -266,14 +270,14 @@ public void close(ErrorCode rstStatusCode) throws IOException {
    * immediately.
    */
   public void closeLater(ErrorCode errorCode) {
-    if (!closeInternal(errorCode)) {
+    if (!closeInternal(errorCode, null)) {
       return; // Already closed.
     }
     connection.writeSynResetLater(id, errorCode);
   }
 
   /** Returns true if this stream was closed. */
-  private boolean closeInternal(ErrorCode errorCode) {
+  private boolean closeInternal(ErrorCode errorCode, @Nullable IOException errorException) {
     assert (!Thread.holdsLock(this));
     synchronized (this) {
       if (this.errorCode != null) {
@@ -283,6 +287,7 @@ private boolean closeInternal(ErrorCode errorCode) {
         return false;
       }
       this.errorCode = errorCode;
+      this.errorException = errorException;
       notifyAll();
     }
     connection.removeStream(id);
@@ -365,7 +370,7 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
 
       while (true) {
         long readBytesDelivered = -1;
-        ErrorCode errorCodeToDeliver = null;
+        IOException errorExceptionToDeliver = null;
 
         // 1. Decide what to do in a synchronized block.
 
@@ -374,7 +379,9 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
           try {
             if (errorCode != null) {
               // Prepare to deliver an error.
-              errorCodeToDeliver = errorCode;
+              errorExceptionToDeliver = errorException != null
+                  ? errorException
+                  : new StreamResetException(errorCode);
             }
 
             if (closed) {
@@ -385,7 +392,7 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
               readBytesDelivered = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
               unacknowledgedBytesRead += readBytesDelivered;
 
-              if (errorCodeToDeliver == null
+              if (errorExceptionToDeliver == null
                   && unacknowledgedBytesRead
                   >= connection.okHttpSettings.getInitialWindowSize() / 2) {
                 // Flow control: notify the peer that we're ready for more data! Only send a
@@ -393,7 +400,7 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
                 connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
                 unacknowledgedBytesRead = 0;
               }
-            } else if (!finished && errorCodeToDeliver == null) {
+            } else if (!finished && errorExceptionToDeliver == null) {
               // Nothing to do. Wait until that changes then try again.
               waitForIo();
               continue;
@@ -411,12 +418,12 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
           return readBytesDelivered;
         }
 
-        if (errorCodeToDeliver != null) {
+        if (errorExceptionToDeliver != null) {
           // We defer throwing the exception until now so that we can refill the connection
           // flow-control window. This is necessary because we don't transmit window updates until
           // the application reads the data. If we throw this prior to updating the connection
           // flow-control window, we risk having it go to 0 preventing the server from sending data.
-          throw new StreamResetException(errorCodeToDeliver);
+          throw errorExceptionToDeliver;
         }
 
         return -1; // This source is exhausted.
@@ -500,7 +507,7 @@ void cancelStreamIfNecessary() throws IOException {
       // is safe because the input stream is closed (we won't use any
       // further bytes) and the output stream is either finished or closed
       // (so RSTing both streams doesn't cause harm).
-      Http2Stream.this.close(ErrorCode.CANCEL);
+      Http2Stream.this.close(ErrorCode.CANCEL, null);
     } else if (!open) {
       connection.removeStream(id);
     }
@@ -625,7 +632,7 @@ void checkOutNotClosed() throws IOException {
     } else if (sink.finished) {
       throw new IOException("stream finished");
     } else if (errorCode != null) {
-      throw new StreamResetException(errorCode);
+      throw errorException != null ? errorException : new StreamResetException(errorCode);
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java b/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java
deleted file mode 100644
index 8c08ddb56a..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import java.util.List;
-import okhttp3.Protocol;
-import okio.BufferedSource;
-
-/**
- * {@link Protocol#HTTP_2 HTTP/2} only. Processes server-initiated HTTP requests on the client.
- * Implementations must quickly dispatch callbacks to avoid creating a bottleneck.
- *
- * <p>While {@link #onReset} may occur at any time, the following callbacks are expected in order,
- * correlated by stream ID.
- *
- * <ul>
- *     <li>{@link #onRequest}</li> <li>{@link #onHeaders} (unless canceled)
- *     <li>{@link #onData} (optional sequence of data frames)
- * </ul>
- *
- * <p>As a stream ID is scoped to a single HTTP/2 connection, implementations which target multiple
- * connections should expect repetition of stream IDs.
- *
- * <p>Return true to request cancellation of a pushed stream.  Note that this does not guarantee
- * future frames won't arrive on the stream ID.
- */
-public interface PushObserver {
-  /**
-   * Describes the request that the server intends to push a response for.
-   *
-   * @param streamId server-initiated stream ID: an even number.
-   * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
-   * and {@code :path}.
-   */
-  boolean onRequest(int streamId, List<Header> requestHeaders);
-
-  /**
-   * The response headers corresponding to a pushed request.  When {@code last} is true, there are
-   * no data frames to follow.
-   *
-   * @param streamId server-initiated stream ID: an even number.
-   * @param responseHeaders minimally includes {@code :status}.
-   * @param last when true, there is no response data.
-   */
-  boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last);
-
-  /**
-   * A chunk of response data corresponding to a pushed request.  This data must either be read or
-   * skipped.
-   *
-   * @param streamId server-initiated stream ID: an even number.
-   * @param source location of data corresponding with this stream ID.
-   * @param byteCount number of bytes to read or skip from the source.
-   * @param last when true, there are no data frames to follow.
-   */
-  boolean onData(int streamId, BufferedSource source, int byteCount, boolean last)
-      throws IOException;
-
-  /** Indicates the reason why this stream was canceled. */
-  void onReset(int streamId, ErrorCode errorCode);
-
-  PushObserver CANCEL = new PushObserver() {
-
-    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
-      return true;
-    }
-
-    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
-      return true;
-    }
-
-    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
-        boolean last) throws IOException {
-      source.skip(byteCount);
-      return true;
-    }
-
-    @Override public void onReset(int streamId, ErrorCode errorCode) {
-    }
-  };
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.kt b/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.kt
new file mode 100644
index 0000000000..ff7cff2757
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.kt
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2
+
+import java.io.IOException
+import okhttp3.Protocol
+import okio.BufferedSource
+
+/**
+ * [HTTP/2][Protocol.HTTP_2] only. Processes server-initiated HTTP requests on the client.
+ * Implementations must quickly dispatch callbacks to avoid creating a bottleneck.
+ *
+ * While [onReset] may occur at any time, the following callbacks are expected in order,
+ * correlated by stream ID.
+ *
+ *  * [onRequest]
+ *  * [onHeaders] (unless canceled)
+ *  * [onData] (optional sequence of data frames)
+ *
+ * As a stream ID is scoped to a single HTTP/2 connection, implementations which target multiple
+ * connections should expect repetition of stream IDs.
+ *
+ * Return true to request cancellation of a pushed stream.  Note that this does not guarantee
+ * future frames won't arrive on the stream ID.
+ */
+interface PushObserver {
+  /**
+   * Describes the request that the server intends to push a response for.
+   *
+   * @param streamId server-initiated stream ID: an even number.
+   * @param requestHeaders minimally includes `:method`, `:scheme`, `:authority`,
+   * and `:path`.
+   */
+  fun onRequest(streamId: Int, requestHeaders: List<Header>): Boolean
+
+  /**
+   * The response headers corresponding to a pushed request.  When [last] is true, there are
+   * no data frames to follow.
+   *
+   * @param streamId server-initiated stream ID: an even number.
+   * @param responseHeaders minimally includes `:status`.
+   * @param last when true, there is no response data.
+   */
+  fun onHeaders(streamId: Int, responseHeaders: List<Header>, last: Boolean): Boolean
+
+  /**
+   * A chunk of response data corresponding to a pushed request.  This data must either be read or
+   * skipped.
+   *
+   * @param streamId server-initiated stream ID: an even number.
+   * @param source location of data corresponding with this stream ID.
+   * @param byteCount number of bytes to read or skip from the source.
+   * @param last when true, there are no data frames to follow.
+   */
+  @Throws(IOException::class)
+  fun onData(streamId: Int, source: BufferedSource, byteCount: Int, last: Boolean): Boolean
+
+  /** Indicates the reason why this stream was canceled.  */
+  fun onReset(streamId: Int, errorCode: ErrorCode)
+
+  companion object {
+    @JvmField val CANCEL: PushObserver = object : PushObserver {
+
+      override fun onRequest(streamId: Int, requestHeaders: List<Header>): Boolean {
+        return true
+      }
+
+      override fun onHeaders(streamId: Int, responseHeaders: List<Header>, last: Boolean): Boolean {
+        return true
+      }
+
+      @Throws(IOException::class)
+      override fun onData(streamId: Int, source: BufferedSource, byteCount: Int, last: Boolean): Boolean {
+        source.skip(byteCount.toLong())
+        return true
+      }
+
+      override fun onReset(streamId: Int, errorCode: ErrorCode) {
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java b/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.kt
similarity index 67%
rename from okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java
rename to okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.kt
index 299f81e1b9..814c2add07 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.kt
@@ -13,16 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http2;
+package okhttp3.internal.http2
 
-import java.io.IOException;
+import java.io.IOException
 
-/** Thrown when an HTTP/2 stream is canceled without damage to the socket that carries it. */
-public final class StreamResetException extends IOException {
-  public final ErrorCode errorCode;
-
-  public StreamResetException(ErrorCode errorCode) {
-    super("stream was reset: " + errorCode);
-    this.errorCode = errorCode;
-  }
-}
+/** Thrown when an HTTP/2 stream is canceled without damage to the socket that carries it.  */
+class StreamResetException(@JvmField val errorCode: ErrorCode) : IOException("stream was reset: $errorCode")
diff --git a/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
deleted file mode 100644
index 0b1b1cfbc4..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/io/FileSystem.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.io;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-
-/**
- * Access to read and write files on a hierarchical data store. Most callers should use the {@link
- * #SYSTEM} implementation, which uses the host machine's local file system. Alternate
- * implementations may be used to inject faults (for testing) or to transform stored data (to add
- * encryption, for example).
- *
- * <p>All operations on a file system are racy. For example, guarding a call to {@link #source} with
- * {@link #exists} does not guarantee that {@link FileNotFoundException} will not be thrown. The
- * file may be moved between the two calls!
- *
- * <p>This interface is less ambitious than {@link java.nio.file.FileSystem} introduced in Java 7.
- * It lacks important features like file watching, metadata, permissions, and disk space
- * information. In exchange for these limitations, this interface is easier to implement and works
- * on all versions of Java and Android.
- */
-public interface FileSystem {
-  /** The host machine's local file system. */
-  FileSystem SYSTEM = new FileSystem() {
-    @Override public Source source(File file) throws FileNotFoundException {
-      return Okio.source(file);
-    }
-
-    @Override public Sink sink(File file) throws FileNotFoundException {
-      try {
-        return Okio.sink(file);
-      } catch (FileNotFoundException e) {
-        // Maybe the parent directory doesn't exist? Try creating it first.
-        file.getParentFile().mkdirs();
-        return Okio.sink(file);
-      }
-    }
-
-    @Override public Sink appendingSink(File file) throws FileNotFoundException {
-      try {
-        return Okio.appendingSink(file);
-      } catch (FileNotFoundException e) {
-        // Maybe the parent directory doesn't exist? Try creating it first.
-        file.getParentFile().mkdirs();
-        return Okio.appendingSink(file);
-      }
-    }
-
-    @Override public void delete(File file) throws IOException {
-      // If delete() fails, make sure it's because the file didn't exist!
-      if (!file.delete() && file.exists()) {
-        throw new IOException("failed to delete " + file);
-      }
-    }
-
-    @Override public boolean exists(File file) {
-      return file.exists();
-    }
-
-    @Override public long size(File file) {
-      return file.length();
-    }
-
-    @Override public void rename(File from, File to) throws IOException {
-      delete(to);
-      if (!from.renameTo(to)) {
-        throw new IOException("failed to rename " + from + " to " + to);
-      }
-    }
-
-    @Override public void deleteContents(File directory) throws IOException {
-      File[] files = directory.listFiles();
-      if (files == null) {
-        throw new IOException("not a readable directory: " + directory);
-      }
-      for (File file : files) {
-        if (file.isDirectory()) {
-          deleteContents(file);
-        }
-        if (!file.delete()) {
-          throw new IOException("failed to delete " + file);
-        }
-      }
-    }
-  };
-
-  /** Reads from {@code file}. */
-  Source source(File file) throws FileNotFoundException;
-
-  /**
-   * Writes to {@code file}, discarding any data already present. Creates parent directories if
-   * necessary.
-   */
-  Sink sink(File file) throws FileNotFoundException;
-
-  /**
-   * Writes to {@code file}, appending if data is already present. Creates parent directories if
-   * necessary.
-   */
-  Sink appendingSink(File file) throws FileNotFoundException;
-
-  /** Deletes {@code file} if it exists. Throws if the file exists and cannot be deleted. */
-  void delete(File file) throws IOException;
-
-  /** Returns true if {@code file} exists on the file system. */
-  boolean exists(File file);
-
-  /** Returns the number of bytes stored in {@code file}, or 0 if it does not exist. */
-  long size(File file);
-
-  /** Renames {@code from} to {@code to}. Throws if the file cannot be renamed. */
-  void rename(File from, File to) throws IOException;
-
-  /**
-   * Recursively delete the contents of {@code directory}. Throws an IOException if any file could
-   * not be deleted, or if {@code dir} is not a readable directory.
-   */
-  void deleteContents(File directory) throws IOException;
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/io/FileSystem.kt b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.kt
new file mode 100644
index 0000000000..830e93c111
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/io/FileSystem.kt
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.io
+
+import okio.Source
+import okio.source
+import okio.Sink
+import okio.sink
+import okio.appendingSink
+import java.io.File
+import java.io.FileNotFoundException
+import java.io.IOException
+
+/**
+ * Access to read and write files on a hierarchical data store. Most callers should use the
+ * [SYSTEM] implementation, which uses the host machine's local file system. Alternate
+ * implementations may be used to inject faults (for testing) or to transform stored data (to add
+ * encryption, for example).
+ *
+ * All operations on a file system are racy. For example, guarding a call to [source] with
+ * [exists] does not guarantee that [FileNotFoundException] will not be thrown. The
+ * file may be moved between the two calls!
+ *
+ * This interface is less ambitious than [java.nio.file.FileSystem] introduced in Java 7.
+ * It lacks important features like file watching, metadata, permissions, and disk space
+ * information. In exchange for these limitations, this interface is easier to implement and works
+ * on all versions of Java and Android.
+ */
+interface FileSystem {
+
+  companion object {
+    /** The host machine's local file system.  */
+    @JvmField
+    val SYSTEM: FileSystem = object : FileSystem {
+      @Throws(FileNotFoundException::class)
+      override fun source(file: File): Source = file.source()
+
+      @Throws(FileNotFoundException::class)
+      override fun sink(file: File): Sink {
+          try {
+              return file.sink()
+          } catch (_: FileNotFoundException) {
+              // Maybe the parent directory doesn't exist? Try creating it first.
+              file.parentFile.mkdirs()
+              return file.sink()
+          }
+      }
+
+      @Throws(FileNotFoundException::class)
+      override fun appendingSink(file: File): Sink {
+          return try {
+              file.appendingSink()
+          } catch (_: FileNotFoundException) {
+              // Maybe the parent directory doesn't exist? Try creating it first.
+              file.parentFile.mkdirs()
+              file.appendingSink()
+          }
+      }
+
+      @Throws(IOException::class)
+      override fun delete(file: File) {
+        // If delete() fails, make sure it's because the file didn't exist!
+        if (!file.delete() && file.exists()) {
+          throw IOException("failed to delete $file")
+        }
+      }
+
+      override fun exists(file: File): Boolean = file.exists()
+
+      override fun size(file: File): Long = file.length()
+
+      @Throws(IOException::class)
+      override fun rename(from: File, to: File) {
+        delete(to)
+        if (!from.renameTo(to)) {
+          throw IOException("failed to rename $from to $to")
+        }
+      }
+
+      @Throws(IOException::class)
+      override fun deleteContents(directory: File) {
+        val files = directory.listFiles() ?: throw IOException("not a readable directory: $directory")
+        for (file in files) {
+          if (file.isDirectory) {
+            deleteContents(file)
+          }
+          if (!file.delete()) {
+            throw IOException("failed to delete $file")
+          }
+        }
+      }
+    }
+  }
+
+  /** Reads from [file].  */
+  @Throws(FileNotFoundException::class)
+  fun source(file: File): Source
+
+  /**
+   * Writes to [file], discarding any data already present. Creates parent directories if
+   * necessary.
+   */
+  @Throws(FileNotFoundException::class)
+  fun sink(file: File): Sink
+
+  /**
+   * Writes to [file], appending if data is already present. Creates parent directories if
+   * necessary.
+   */
+  @Throws(FileNotFoundException::class)
+  fun appendingSink(file: File): Sink
+
+  /** Deletes [file] if it exists. Throws if the file exists and cannot be deleted.  */
+  @Throws(IOException::class)
+  fun delete(file: File)
+
+  /** Returns true if [file] exists on the file system.  */
+  fun exists(file: File): Boolean
+
+  /** Returns the number of bytes stored in [file], or 0 if it does not exist.  */
+  fun size(file: File): Long
+
+  /** Renames [from] to [to]. Throws if the file cannot be renamed.  */
+  @Throws(IOException::class)
+  fun rename(from: File, to: File)
+
+  /**
+   * Recursively delete the contents of [directory]. Throws an IOException if any file could
+   * not be deleted, or if `dir` is not a readable directory.
+   */
+  @Throws(IOException::class)
+  fun deleteContents(directory: File)
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
deleted file mode 100644
index 9cbae145d5..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
+++ /dev/null
@@ -1,353 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import android.os.Build;
-import android.util.Log;
-import java.io.IOException;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.security.NoSuchAlgorithmException;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Protocol;
-import okhttp3.internal.Util;
-import okhttp3.internal.tls.CertificateChainCleaner;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-
-/** Android 5+. */
-class AndroidPlatform extends Platform {
-  private static final int MAX_LOG_LENGTH = 4000;
-
-  private final Class<?> sslParametersClass;
-  private final Method setUseSessionTickets;
-  private final Method setHostname;
-  private final Method getAlpnSelectedProtocol;
-  private final Method setAlpnProtocols;
-
-  private final CloseGuard closeGuard = CloseGuard.get();
-
-  AndroidPlatform(Class<?> sslParametersClass, Method setUseSessionTickets, Method setHostname,
-      Method getAlpnSelectedProtocol, Method setAlpnProtocols) {
-    this.sslParametersClass = sslParametersClass;
-    this.setUseSessionTickets = setUseSessionTickets;
-    this.setHostname = setHostname;
-    this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
-    this.setAlpnProtocols = setAlpnProtocols;
-  }
-
-  @Override public void connectSocket(Socket socket, InetSocketAddress address,
-      int connectTimeout) throws IOException {
-    try {
-      socket.connect(address, connectTimeout);
-    } catch (AssertionError e) {
-      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
-      throw e;
-    } catch (ClassCastException e) {
-      // On android 8.0, socket.connect throws a ClassCastException due to a bug
-      // see https://issuetracker.google.com/issues/63649622
-      if (Build.VERSION.SDK_INT == 26) {
-        throw new IOException("Exception in connect", e);
-      } else {
-        throw e;
-      }
-    }
-  }
-
-  @Override protected @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
-    Object context = readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters");
-    if (context == null) {
-      // If that didn't work, try the Google Play Services SSL provider before giving up. This
-      // must be loaded by the SSLSocketFactory's class loader.
-      try {
-        Class<?> gmsSslParametersClass = Class.forName(
-            "com.google.android.gms.org.conscrypt.SSLParametersImpl", false,
-            sslSocketFactory.getClass().getClassLoader());
-        context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass, "sslParameters");
-      } catch (ClassNotFoundException e) {
-        return super.trustManager(sslSocketFactory);
-      }
-    }
-
-    X509TrustManager x509TrustManager = readFieldOrNull(
-        context, X509TrustManager.class, "x509TrustManager");
-    if (x509TrustManager != null) return x509TrustManager;
-
-    return readFieldOrNull(context, X509TrustManager.class, "trustManager");
-  }
-
-  @Override public void configureTlsExtensions(
-      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-    try {
-      // Enable SNI and session tickets.
-      if (hostname != null) {
-        setUseSessionTickets.invoke(sslSocket, true);
-        // This is SSLParameters.setServerNames() in API 24+.
-        setHostname.invoke(sslSocket, hostname);
-      }
-
-      // Enable ALPN.
-      setAlpnProtocols.invoke(sslSocket, concatLengthPrefixed(protocols));
-    } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  @Override public @Nullable String getSelectedProtocol(SSLSocket socket) {
-    try {
-      byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invoke(socket);
-      return alpnResult != null ? new String(alpnResult, UTF_8) : null;
-    } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  @Override public void log(int level, String message, @Nullable Throwable t) {
-    int logLevel = level == WARN ? Log.WARN : Log.DEBUG;
-    if (t != null) message = message + '\n' + Log.getStackTraceString(t);
-
-    // Split by line, then ensure each line can fit into Log's maximum length.
-    for (int i = 0, length = message.length(); i < length; i++) {
-      int newline = message.indexOf('\n', i);
-      newline = newline != -1 ? newline : length;
-      do {
-        int end = Math.min(newline, i + MAX_LOG_LENGTH);
-        Log.println(logLevel, "OkHttp", message.substring(i, end));
-        i = end;
-      } while (i < newline);
-    }
-  }
-
-  @Override public Object getStackTraceForCloseable(String closer) {
-    return closeGuard.createAndOpen(closer);
-  }
-
-  @Override public void logCloseableLeak(String message, Object stackTrace) {
-    boolean reported = closeGuard.warnIfOpen(stackTrace);
-    if (!reported) {
-      // Unable to report via CloseGuard. As a last-ditch effort, send it to the logger.
-      log(WARN, message, null);
-    }
-  }
-
-  @Override public boolean isCleartextTrafficPermitted(String hostname) {
-    try {
-      Class<?> networkPolicyClass = Class.forName("android.security.NetworkSecurityPolicy");
-      Method getInstanceMethod = networkPolicyClass.getMethod("getInstance");
-      Object networkSecurityPolicy = getInstanceMethod.invoke(null);
-      return api24IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
-    } catch (ClassNotFoundException | NoSuchMethodException e) {
-      return super.isCleartextTrafficPermitted(hostname);
-    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
-      throw new AssertionError("unable to determine cleartext support", e);
-    }
-  }
-
-  private boolean api24IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
-      Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
-    try {
-      Method isCleartextTrafficPermittedMethod = networkPolicyClass
-          .getMethod("isCleartextTrafficPermitted", String.class);
-      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy, hostname);
-    } catch (NoSuchMethodException e) {
-      return api23IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
-    }
-  }
-
-  private boolean api23IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
-      Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
-    try {
-      Method isCleartextTrafficPermittedMethod = networkPolicyClass
-          .getMethod("isCleartextTrafficPermitted");
-      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy);
-    } catch (NoSuchMethodException e) {
-      return super.isCleartextTrafficPermitted(hostname);
-    }
-  }
-
-  public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
-    try {
-      Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");
-      Constructor<?> constructor = extensionsClass.getConstructor(X509TrustManager.class);
-      Object extensions = constructor.newInstance(trustManager);
-      Method checkServerTrusted = extensionsClass.getMethod(
-          "checkServerTrusted", X509Certificate[].class, String.class, String.class);
-      return new AndroidCertificateChainCleaner(extensions, checkServerTrusted);
-    } catch (Exception e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  public static @Nullable Platform buildIfSupported() {
-    // Attempt to find Android 5+ APIs.
-    Class<?> sslParametersClass;
-    Class<?> sslSocketClass;
-    try {
-      sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl");
-      sslSocketClass = Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl");
-    } catch (ClassNotFoundException ignored) {
-      return null; // Not an Android runtime.
-    }
-    if (Build.VERSION.SDK_INT >= 21) {
-      try {
-        Method setUseSessionTickets = sslSocketClass.getDeclaredMethod(
-            "setUseSessionTickets", boolean.class);
-        Method setHostname = sslSocketClass.getMethod("setHostname", String.class);
-        Method getAlpnSelectedProtocol = sslSocketClass.getMethod("getAlpnSelectedProtocol");
-        Method setAlpnProtocols = sslSocketClass.getMethod("setAlpnProtocols", byte[].class);
-        return new AndroidPlatform(sslParametersClass, setUseSessionTickets, setHostname,
-            getAlpnSelectedProtocol, setAlpnProtocols);
-      } catch (NoSuchMethodException ignored) {
-      }
-    }
-    throw new IllegalStateException(
-        "Expected Android API level 21+ but was " + Build.VERSION.SDK_INT);
-  }
-
-  /**
-   * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
-   * This is the best way to get a clean chain on Android because it uses the same code as the TLS
-   * handshake.
-   */
-  static final class AndroidCertificateChainCleaner extends CertificateChainCleaner {
-    private final Object x509TrustManagerExtensions;
-    private final Method checkServerTrusted;
-
-    AndroidCertificateChainCleaner(Object x509TrustManagerExtensions, Method checkServerTrusted) {
-      this.x509TrustManagerExtensions = x509TrustManagerExtensions;
-      this.checkServerTrusted = checkServerTrusted;
-    }
-
-    @SuppressWarnings({"unchecked", "SuspiciousToArrayCall"}) // Reflection on List<Certificate>.
-    @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
-        throws SSLPeerUnverifiedException {
-      try {
-        X509Certificate[] certificates = chain.toArray(new X509Certificate[chain.size()]);
-        return (List<Certificate>) checkServerTrusted.invoke(
-            x509TrustManagerExtensions, certificates, "RSA", hostname);
-      } catch (InvocationTargetException e) {
-        SSLPeerUnverifiedException exception = new SSLPeerUnverifiedException(e.getMessage());
-        exception.initCause(e);
-        throw exception;
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      }
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof AndroidCertificateChainCleaner; // All instances are equivalent.
-    }
-
-    @Override public int hashCode() {
-      return 0;
-    }
-  }
-
-  /**
-   * Provides access to the internal dalvik.system.CloseGuard class. Android uses this in
-   * combination with android.os.StrictMode to report on leaked java.io.Closeable's. Available since
-   * Android API 11.
-   */
-  static final class CloseGuard {
-    private final Method getMethod;
-    private final Method openMethod;
-    private final Method warnIfOpenMethod;
-
-    CloseGuard(Method getMethod, Method openMethod, Method warnIfOpenMethod) {
-      this.getMethod = getMethod;
-      this.openMethod = openMethod;
-      this.warnIfOpenMethod = warnIfOpenMethod;
-    }
-
-    Object createAndOpen(String closer) {
-      if (getMethod != null) {
-        try {
-          Object closeGuardInstance = getMethod.invoke(null);
-          openMethod.invoke(closeGuardInstance, closer);
-          return closeGuardInstance;
-        } catch (Exception ignored) {
-        }
-      }
-      return null;
-    }
-
-    boolean warnIfOpen(Object closeGuardInstance) {
-      boolean reported = false;
-      if (closeGuardInstance != null) {
-        try {
-          warnIfOpenMethod.invoke(closeGuardInstance);
-          reported = true;
-        } catch (Exception ignored) {
-        }
-      }
-      return reported;
-    }
-
-    static CloseGuard get() {
-      Method getMethod;
-      Method openMethod;
-      Method warnIfOpenMethod;
-
-      try {
-        Class<?> closeGuardClass = Class.forName("dalvik.system.CloseGuard");
-        getMethod = closeGuardClass.getMethod("get");
-        openMethod = closeGuardClass.getMethod("open", String.class);
-        warnIfOpenMethod = closeGuardClass.getMethod("warnIfOpen");
-      } catch (Exception ignored) {
-        getMethod = null;
-        openMethod = null;
-        warnIfOpenMethod = null;
-      }
-      return new CloseGuard(getMethod, openMethod, warnIfOpenMethod);
-    }
-  }
-
-  @Override public SSLContext getSSLContext() {
-    boolean tryTls12;
-    try {
-      tryTls12 = (Build.VERSION.SDK_INT >= 16 && Build.VERSION.SDK_INT < 22);
-    } catch (NoClassDefFoundError e) {
-      // Not a real Android runtime; probably RoboVM or MoE
-      // Try to load TLS 1.2 explicitly.
-      tryTls12 = true;
-    }
-
-    if (tryTls12) {
-      try {
-        return SSLContext.getInstance("TLSv1.2");
-      } catch (NoSuchAlgorithmException e) {
-        // fallback to TLS
-      }
-    }
-
-    try {
-      return SSLContext.getInstance("TLS");
-    } catch (NoSuchAlgorithmException e) {
-      throw new IllegalStateException("No TLS provider", e);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
new file mode 100644
index 0000000000..7898227973
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
@@ -0,0 +1,404 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform
+
+import android.os.Build
+import android.util.Log
+import okhttp3.Protocol
+import okhttp3.internal.Util
+import okhttp3.internal.tls.BasicTrustRootIndex
+import okhttp3.internal.tls.CertificateChainCleaner
+import okhttp3.internal.tls.TrustRootIndex
+import java.io.IOException
+import java.lang.reflect.InvocationTargetException
+import java.lang.reflect.Method
+import java.net.InetSocketAddress
+import java.net.Socket
+import java.nio.charset.StandardCharsets.UTF_8
+import java.security.NoSuchAlgorithmException
+import java.security.cert.Certificate
+import java.security.cert.TrustAnchor
+import java.security.cert.X509Certificate
+import javax.net.ssl.SSLContext
+import javax.net.ssl.SSLPeerUnverifiedException
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/** Android 5+.  */
+class AndroidPlatform(
+  private val sslParametersClass: Class<*>,
+  private val sslSocketClass: Class<*>,
+  private val setUseSessionTickets: Method,
+  private val setHostname: Method,
+  private val getAlpnSelectedProtocol: Method,
+  private val setAlpnProtocols: Method
+) : Platform() {
+  private val closeGuard = CloseGuard.get()
+
+  // Not a real Android runtime; probably RoboVM or MoE
+  // Try to load TLS 1.2 explicitly.
+  // fallback to TLS
+  override fun newSSLContext(): SSLContext {
+    val tryTls12: Boolean = try {
+      Build.VERSION.SDK_INT in 16..21
+    } catch (e: NoClassDefFoundError) {
+      true
+    }
+
+    if (tryTls12) {
+      try {
+        return SSLContext.getInstance("TLSv1.2")
+      } catch (e: NoSuchAlgorithmException) {
+      }
+    }
+
+    try {
+      return SSLContext.getInstance("TLS")
+    } catch (e: NoSuchAlgorithmException) {
+      throw IllegalStateException("No TLS provider", e)
+    }
+  }
+
+  @Throws(IOException::class)
+  override fun connectSocket(
+    socket: Socket,
+    address: InetSocketAddress,
+    connectTimeout: Int
+  ) {
+    try {
+      socket.connect(address, connectTimeout)
+    } catch (e: AssertionError) {
+      if (Util.isAndroidGetsocknameError(e)) throw IOException(e)
+      throw e
+    } catch (e: ClassCastException) {
+      // On android 8.0, socket.connect throws a ClassCastException due to a bug
+      // see https://issuetracker.google.com/issues/63649622
+      if (Build.VERSION.SDK_INT == 26) {
+        throw IOException("Exception in connect", e)
+      } else {
+        throw e
+      }
+    }
+  }
+
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {
+    var context: Any? =
+        readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters")
+    if (context == null) {
+      // If that didn't work, try the Google Play Services SSL provider before giving up. This
+      // must be loaded by the SSLSocketFactory's class loader.
+      try {
+        val gmsSslParametersClass = Class.forName(
+            "com.google.android.gms.org.conscrypt.SSLParametersImpl", false,
+            sslSocketFactory.javaClass.classLoader)
+        context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass,
+            "sslParameters")
+      } catch (e: ClassNotFoundException) {
+        return super.trustManager(sslSocketFactory)
+      }
+    }
+
+    val x509TrustManager = readFieldOrNull(
+        context!!, X509TrustManager::class.java, "x509TrustManager")
+    return x509TrustManager ?: readFieldOrNull(context, X509TrustManager::class.java,
+        "trustManager")
+  }
+
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  ) {
+    if (!sslSocketClass.isInstance(sslSocket)) {
+      return // No TLS extensions if the socket class is custom.
+    }
+    try {
+      // Enable SNI and session tickets.
+      if (hostname != null) {
+        setUseSessionTickets.invoke(sslSocket, true)
+        // This is SSLParameters.setServerNames() in API 24+.
+        setHostname.invoke(sslSocket, hostname)
+      }
+
+      // Enable ALPN.
+      setAlpnProtocols.invoke(sslSocket, concatLengthPrefixed(protocols))
+    } catch (e: IllegalAccessException) {
+      throw AssertionError(e)
+    } catch (e: InvocationTargetException) {
+      throw AssertionError(e)
+    }
+  }
+
+  override fun getSelectedProtocol(socket: SSLSocket): String? {
+    return if (sslSocketClass.isInstance(socket))
+      try {
+        val alpnResult = getAlpnSelectedProtocol.invoke(socket) as ByteArray?
+        if (alpnResult != null) String(alpnResult, UTF_8) else null
+      } catch (e: IllegalAccessException) {
+        throw AssertionError(e)
+      } catch (e: InvocationTargetException) {
+        throw AssertionError(e)
+      }
+    else {
+      null // No TLS extensions if the socket class is custom.
+    }
+  }
+
+  override fun log(level: Int, message: String, t: Throwable?) {
+    var logMessage = message
+    val logLevel = if (level == WARN) Log.WARN else Log.DEBUG
+    if (t != null) logMessage = logMessage + '\n'.toString() + Log.getStackTraceString(t)
+
+    // Split by line, then ensure each line can fit into Log's maximum length.
+    var i = 0
+    val length = logMessage.length
+    while (i < length) {
+      var newline = logMessage.indexOf('\n', i)
+      newline = if (newline != -1) newline else length
+      do {
+        val end = Math.min(newline, i + MAX_LOG_LENGTH)
+        Log.println(logLevel, "OkHttp", logMessage.substring(i, end))
+        i = end
+      } while (i < newline)
+      i++
+    }
+  }
+
+  override fun getStackTraceForCloseable(closer: String): Any? = closeGuard.createAndOpen(closer)
+
+  override fun logCloseableLeak(message: String, stackTrace: Any?) {
+    val reported = closeGuard.warnIfOpen(stackTrace)
+    if (!reported) {
+      // Unable to report via CloseGuard. As a last-ditch effort, send it to the logger.
+      log(WARN, message, null)
+    }
+  }
+
+  override fun isCleartextTrafficPermitted(hostname: String): Boolean {
+    return try {
+      val networkPolicyClass = Class.forName("android.security.NetworkSecurityPolicy")
+      val getInstanceMethod = networkPolicyClass.getMethod("getInstance")
+      val networkSecurityPolicy = getInstanceMethod.invoke(null)
+      api24IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy)
+    } catch (e: ClassNotFoundException) {
+      super.isCleartextTrafficPermitted(hostname)
+    } catch (e: NoSuchMethodException) {
+      super.isCleartextTrafficPermitted(hostname)
+    } catch (e: IllegalAccessException) {
+      throw AssertionError("unable to determine cleartext support", e)
+    } catch (e: IllegalArgumentException) {
+      throw AssertionError("unable to determine cleartext support", e)
+    } catch (e: InvocationTargetException) {
+      throw AssertionError("unable to determine cleartext support", e)
+    }
+  }
+
+  @Throws(InvocationTargetException::class, IllegalAccessException::class)
+  private fun api24IsCleartextTrafficPermitted(
+    hostname: String,
+    networkPolicyClass: Class<*>,
+    networkSecurityPolicy: Any
+  ): Boolean = try {
+    val isCleartextTrafficPermittedMethod = networkPolicyClass
+        .getMethod("isCleartextTrafficPermitted", String::class.java)
+    isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy, hostname) as Boolean
+  } catch (e: NoSuchMethodException) {
+    api23IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy)
+  }
+
+  @Throws(InvocationTargetException::class, IllegalAccessException::class)
+  private fun api23IsCleartextTrafficPermitted(
+    hostname: String,
+    networkPolicyClass: Class<*>,
+    networkSecurityPolicy: Any
+  ): Boolean = try {
+    val isCleartextTrafficPermittedMethod = networkPolicyClass
+        .getMethod("isCleartextTrafficPermitted")
+    isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy) as Boolean
+  } catch (e: NoSuchMethodException) {
+    super.isCleartextTrafficPermitted(hostname)
+  }
+
+  override fun buildCertificateChainCleaner(trustManager: X509TrustManager): CertificateChainCleaner =
+      try {
+        val extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions")
+        val constructor = extensionsClass.getConstructor(X509TrustManager::class.java)
+        val extensions = constructor.newInstance(trustManager)
+        val checkServerTrusted = extensionsClass.getMethod(
+            "checkServerTrusted", Array<X509Certificate>::class.java, String::class.java,
+            String::class.java)
+        AndroidCertificateChainCleaner(extensions, checkServerTrusted)
+      } catch (e: Exception) {
+        super.buildCertificateChainCleaner(trustManager)
+      }
+
+  override fun buildTrustRootIndex(trustManager: X509TrustManager): TrustRootIndex = try {
+    // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
+    // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
+    val method = trustManager.javaClass.getDeclaredMethod(
+        "findTrustAnchorByIssuerAndSignature", X509Certificate::class.java)
+    method.isAccessible = true
+    CustomTrustRootIndex(trustManager, method)
+  } catch (e: NoSuchMethodException) {
+    super.buildTrustRootIndex(trustManager)
+  }
+
+  /**
+   * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
+   * This is the best way to get a clean chain on Android because it uses the same code as the TLS
+   * handshake.
+   */
+  internal class AndroidCertificateChainCleaner(
+    private val x509TrustManagerExtensions: Any,
+    private val checkServerTrusted: Method
+  ) : CertificateChainCleaner() {
+
+    @Suppress("UNCHECKED_CAST")
+    @Throws(SSLPeerUnverifiedException::class)
+    override // Reflection on List<Certificate>.
+    fun clean(chain: List<Certificate>, hostname: String): List<Certificate> = try {
+      val certificates = (chain as List<X509Certificate>).toTypedArray()
+      checkServerTrusted.invoke(
+          x509TrustManagerExtensions, certificates, "RSA", hostname) as List<Certificate>
+    } catch (e: InvocationTargetException) {
+      val exception = SSLPeerUnverifiedException(e.message)
+      exception.initCause(e)
+      throw exception
+    } catch (e: IllegalAccessException) {
+      throw AssertionError(e)
+    }
+
+    override fun equals(other: Any?): Boolean =
+        other is AndroidCertificateChainCleaner // All instances are equivalent.
+
+    override fun hashCode(): Int = 0
+  }
+
+  /**
+   * Provides access to the internal dalvik.system.CloseGuard class. Android uses this in
+   * combination with android.os.StrictMode to report on leaked java.io.Closeable's. Available since
+   * Android API 11.
+   */
+  internal class CloseGuard(
+    private val getMethod: Method?,
+    private val openMethod: Method?,
+    private val warnIfOpenMethod: Method?
+  ) {
+
+    fun createAndOpen(closer: String): Any? {
+      if (getMethod != null) {
+        try {
+          val closeGuardInstance = getMethod.invoke(null)
+          openMethod!!.invoke(closeGuardInstance, closer)
+          return closeGuardInstance
+        } catch (ignored: Exception) {
+        }
+      }
+      return null
+    }
+
+    fun warnIfOpen(closeGuardInstance: Any?): Boolean {
+      var reported = false
+      if (closeGuardInstance != null) {
+        try {
+          warnIfOpenMethod!!.invoke(closeGuardInstance)
+          reported = true
+        } catch (ignored: Exception) {
+        }
+      }
+      return reported
+    }
+
+    companion object {
+      fun get(): CloseGuard {
+        var getMethod: Method?
+        var openMethod: Method?
+        var warnIfOpenMethod: Method?
+
+        try {
+          val closeGuardClass = Class.forName("dalvik.system.CloseGuard")
+          getMethod = closeGuardClass.getMethod("get")
+          openMethod = closeGuardClass.getMethod("open", String::class.java)
+          warnIfOpenMethod = closeGuardClass.getMethod("warnIfOpen")
+        } catch (ignored: Exception) {
+          getMethod = null
+          openMethod = null
+          warnIfOpenMethod = null
+        }
+
+        return CloseGuard(getMethod, openMethod, warnIfOpenMethod)
+      }
+    }
+  }
+
+  /**
+   * A trust manager for Android applications that customize the trust manager.
+   *
+   *
+   * This class exploits knowledge of Android implementation details. This class is potentially
+   * much faster to initialize than [BasicTrustRootIndex] because it doesn't need to load and
+   * index trusted CA certificates.
+   */
+  internal data class CustomTrustRootIndex(
+    private val trustManager: X509TrustManager,
+    private val findByIssuerAndSignatureMethod: Method
+  ) : TrustRootIndex {
+
+    override fun findByIssuerAndSignature(cert: X509Certificate): X509Certificate? {
+      return try {
+        val trustAnchor = findByIssuerAndSignatureMethod.invoke(
+            trustManager, cert) as TrustAnchor
+        trustAnchor.trustedCert
+      } catch (e: IllegalAccessException) {
+        throw AssertionError("unable to get issues and signature", e)
+      } catch (e: InvocationTargetException) {
+        null
+      }
+    }
+  }
+
+  companion object {
+    private const val MAX_LOG_LENGTH = 4000
+
+    fun buildIfSupported(): Platform? {
+      // Attempt to find Android 5+ APIs.
+      val sslParametersClass: Class<*>
+      val sslSocketClass: Class<*>
+      try {
+        sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl")
+        sslSocketClass = Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl")
+      } catch (ignored: ClassNotFoundException) {
+        return null // Not an Android runtime.
+      }
+
+      if (Build.VERSION.SDK_INT >= 21) {
+        try {
+          val setUseSessionTickets = sslSocketClass.getDeclaredMethod(
+              "setUseSessionTickets", Boolean::class.javaPrimitiveType)
+          val setHostname = sslSocketClass.getMethod("setHostname", String::class.java)
+          val getAlpnSelectedProtocol = sslSocketClass.getMethod("getAlpnSelectedProtocol")
+          val setAlpnProtocols = sslSocketClass.getMethod("setAlpnProtocols", ByteArray::class.java)
+          return AndroidPlatform(sslParametersClass, sslSocketClass, setUseSessionTickets,
+              setHostname, getAlpnSelectedProtocol, setAlpnProtocols)
+        } catch (ignored: NoSuchMethodException) {
+        }
+      }
+      throw IllegalStateException(
+          "Expected Android API level 21+ but was " + Build.VERSION.SDK_INT)
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java
deleted file mode 100644
index e460595329..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import java.security.NoSuchAlgorithmException;
-import java.security.Provider;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Protocol;
-import org.conscrypt.Conscrypt;
-
-/**
- * Platform using Conscrypt (conscrypt.org) if installed as the first Security Provider.
- *
- * Requires org.conscrypt:conscrypt-openjdk-uber on the classpath.
- */
-public class ConscryptPlatform extends Platform {
-  private ConscryptPlatform() {
-  }
-
-  private Provider getProvider() {
-    return Conscrypt.newProviderBuilder().provideTrustManager().build();
-  }
-
-  @Override public @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
-    if (!Conscrypt.isConscrypt(sslSocketFactory)) {
-      return super.trustManager(sslSocketFactory);
-    }
-
-    try {
-      // org.conscrypt.SSLParametersImpl
-      Object sp =
-          readFieldOrNull(sslSocketFactory, Object.class, "sslParameters");
-
-      if (sp != null) {
-        return readFieldOrNull(sp, X509TrustManager.class, "x509TrustManager");
-      }
-
-      return null;
-    } catch (Exception e) {
-      throw new UnsupportedOperationException(
-          "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on Conscrypt", e);
-    }
-  }
-
-  @Override public void configureTlsExtensions(
-      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-    if (Conscrypt.isConscrypt(sslSocket)) {
-      // Enable SNI and session tickets.
-      if (hostname != null) {
-        Conscrypt.setUseSessionTickets(sslSocket, true);
-        Conscrypt.setHostname(sslSocket, hostname);
-      }
-
-      // Enable ALPN.
-      List<String> names = Platform.alpnProtocolNames(protocols);
-      Conscrypt.setApplicationProtocols(sslSocket, names.toArray(new String[0]));
-    } else {
-      super.configureTlsExtensions(sslSocket, hostname, protocols);
-    }
-  }
-
-  @Override public @Nullable String getSelectedProtocol(SSLSocket sslSocket) {
-    if (Conscrypt.isConscrypt(sslSocket)) {
-      return Conscrypt.getApplicationProtocol(sslSocket);
-    } else {
-      return super.getSelectedProtocol(sslSocket);
-    }
-  }
-
-  @Override public SSLContext getSSLContext() {
-    try {
-      return SSLContext.getInstance("TLSv1.3", getProvider());
-    } catch (NoSuchAlgorithmException e) {
-      try {
-        // Allow for Conscrypt 1.2
-        return SSLContext.getInstance("TLS", getProvider());
-      } catch (NoSuchAlgorithmException e2) {
-        throw new IllegalStateException("No TLS provider", e);
-      }
-    }
-  }
-
-  public static ConscryptPlatform buildIfSupported() {
-    try {
-      // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
-      Class.forName("org.conscrypt.Conscrypt");
-
-      if (!Conscrypt.isAvailable()) {
-        return null;
-      }
-
-      return new ConscryptPlatform();
-    } catch (ClassNotFoundException e) {
-      return null;
-    }
-  }
-
-  @Override
-  public void configureSslSocketFactory(SSLSocketFactory socketFactory) {
-    if (Conscrypt.isConscrypt(socketFactory)) {
-      Conscrypt.setUseEngineSocket(socketFactory, true);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt
new file mode 100644
index 0000000000..6442c90d4d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform
+
+import okhttp3.Protocol
+import org.conscrypt.Conscrypt
+import java.security.Provider
+import javax.net.ssl.SSLContext
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Platform using Conscrypt (conscrypt.org) if installed as the first Security Provider.
+ *
+ * Requires org.conscrypt:conscrypt-openjdk-uber >= 2.1.0 on the classpath.
+ */
+class ConscryptPlatform private constructor() : Platform() {
+  private val provider: Provider
+    get() {
+      // n.b. We should consider defaulting to OpenJDK 11 trust manager
+      // https://groups.google.com/forum/#!topic/conscrypt/3vYzbesjOb4
+
+      return Conscrypt.newProviderBuilder().provideTrustManager(true).build()
+    }
+
+  // See release notes https://groups.google.com/forum/#!forum/conscrypt
+  // for version differences
+  override fun newSSLContext(): SSLContext =
+      // supports TLSv1.3 by default (version api is >= 1.4.0)
+      SSLContext.getInstance("TLS", provider)
+
+  override fun platformTrustManager(): X509TrustManager {
+    return Conscrypt.getDefaultX509TrustManager()
+  }
+
+  public override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? =
+      if (!Conscrypt.isConscrypt(sslSocketFactory)) {
+        super.trustManager(sslSocketFactory)
+      } else {
+        try {
+          // org.conscrypt.SSLParametersImpl
+          val sp = readFieldOrNull(sslSocketFactory, Any::class.java, "sslParameters")
+
+          when {
+            sp != null -> readFieldOrNull(sp, X509TrustManager::class.java, "x509TrustManager")
+            else -> null
+          }
+        } catch (e: Exception) {
+          throw UnsupportedOperationException(
+              "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on Conscrypt", e)
+        }
+      }
+
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  ) {
+    if (Conscrypt.isConscrypt(sslSocket)) {
+      // Enable SNI and session tickets.
+      if (hostname != null) {
+        Conscrypt.setUseSessionTickets(sslSocket, true)
+        Conscrypt.setHostname(sslSocket, hostname)
+      }
+
+      // Enable ALPN.
+      val names = alpnProtocolNames(protocols)
+      Conscrypt.setApplicationProtocols(sslSocket, names.toTypedArray())
+    } else {
+      super.configureTlsExtensions(sslSocket, hostname, protocols)
+    }
+  }
+
+  override fun getSelectedProtocol(socket: SSLSocket): String? =
+      if (Conscrypt.isConscrypt(socket)) {
+        Conscrypt.getApplicationProtocol(socket)
+      } else {
+        super.getSelectedProtocol(socket)
+      }
+
+  override fun configureSslSocketFactory(socketFactory: SSLSocketFactory) {
+    if (Conscrypt.isConscrypt(socketFactory)) {
+      Conscrypt.setUseEngineSocket(socketFactory, true)
+    }
+  }
+
+  override fun configureTrustManager(trustManager: X509TrustManager?) {
+    if (Conscrypt.isConscrypt(trustManager)) {
+      // OkHttp will verify
+      Conscrypt.setHostnameVerifier(trustManager) { hostname, session -> true }
+    }
+  }
+
+  companion object {
+    @JvmStatic
+    fun buildIfSupported(): ConscryptPlatform? = try {
+      // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
+      Class.forName("org.conscrypt.Conscrypt\$Version")
+
+      when {
+        Conscrypt.isAvailable() && atLeastVersion(2, 1, 0) -> ConscryptPlatform()
+        else -> null
+      }
+    } catch (e: ClassNotFoundException) {
+      null
+    }
+
+    @JvmStatic @JvmOverloads
+    fun atLeastVersion(major: Int, minor: Int = 0, patch: Int = 0): Boolean {
+      val conscryptVersion = Conscrypt.version()
+
+      if (conscryptVersion.major() != major) {
+        return conscryptVersion.major() > major
+      }
+
+      if (conscryptVersion.minor() != minor) {
+        return conscryptVersion.minor() > minor
+      }
+
+      return conscryptVersion.patch() >= patch
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.java
deleted file mode 100644
index 64d5096e66..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.java
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLSocket;
-import okhttp3.Protocol;
-import okhttp3.internal.Util;
-
-/** OpenJDK 8 with {@code org.mortbay.jetty.alpn:alpn-boot} in the boot class path. */
-class Jdk8WithJettyBootPlatform extends Platform {
-  private final Method putMethod;
-  private final Method getMethod;
-  private final Method removeMethod;
-  private final Class<?> clientProviderClass;
-  private final Class<?> serverProviderClass;
-
-  Jdk8WithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
-      Class<?> clientProviderClass, Class<?> serverProviderClass) {
-    this.putMethod = putMethod;
-    this.getMethod = getMethod;
-    this.removeMethod = removeMethod;
-    this.clientProviderClass = clientProviderClass;
-    this.serverProviderClass = serverProviderClass;
-  }
-
-  @Override public void configureTlsExtensions(
-      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-    List<String> names = alpnProtocolNames(protocols);
-
-    try {
-      Object alpnProvider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
-          new Class[] {clientProviderClass, serverProviderClass}, new AlpnProvider(names));
-      putMethod.invoke(null, sslSocket, alpnProvider);
-    } catch (InvocationTargetException | IllegalAccessException e) {
-      throw new AssertionError("failed to set ALPN", e);
-    }
-  }
-
-  @Override public void afterHandshake(SSLSocket sslSocket) {
-    try {
-      removeMethod.invoke(null, sslSocket);
-    } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError("failed to remove ALPN", e);
-    }
-  }
-
-  @Override public @Nullable String getSelectedProtocol(SSLSocket socket) {
-    try {
-      AlpnProvider provider =
-          (AlpnProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
-      if (!provider.unsupported && provider.selected == null) {
-        Platform.get().log(INFO, "ALPN callback dropped: HTTP/2 is disabled. "
-            + "Is alpn-boot on the boot class path?", null);
-        return null;
-      }
-      return provider.unsupported ? null : provider.selected;
-    } catch (InvocationTargetException | IllegalAccessException e) {
-      throw new AssertionError("failed to get ALPN selected protocol", e);
-    }
-  }
-
-  public static Platform buildIfSupported() {
-    // Find Jetty's ALPN extension for OpenJDK.
-    try {
-      String alpnClassName = "org.eclipse.jetty.alpn.ALPN";
-      Class<?> alpnClass = Class.forName(alpnClassName);
-      Class<?> providerClass = Class.forName(alpnClassName + "$Provider");
-      Class<?> clientProviderClass = Class.forName(alpnClassName + "$ClientProvider");
-      Class<?> serverProviderClass = Class.forName(alpnClassName + "$ServerProvider");
-      Method putMethod = alpnClass.getMethod("put", SSLSocket.class, providerClass);
-      Method getMethod = alpnClass.getMethod("get", SSLSocket.class);
-      Method removeMethod = alpnClass.getMethod("remove", SSLSocket.class);
-      return new Jdk8WithJettyBootPlatform(
-          putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
-    } catch (ClassNotFoundException | NoSuchMethodException ignored) {
-    }
-
-    return null;
-  }
-
-  /**
-   * Handle the methods of ALPN's ClientProvider and ServerProvider without a compile-time
-   * dependency on those interfaces.
-   */
-  private static class AlpnProvider implements InvocationHandler {
-    /** This peer's supported protocols. */
-    private final List<String> protocols;
-    /** Set when remote peer notifies ALPN is unsupported. */
-    boolean unsupported;
-    /** The protocol the server selected. */
-    String selected;
-
-    AlpnProvider(List<String> protocols) {
-      this.protocols = protocols;
-    }
-
-    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-      String methodName = method.getName();
-      Class<?> returnType = method.getReturnType();
-      if (args == null) {
-        args = Util.EMPTY_STRING_ARRAY;
-      }
-      if (methodName.equals("supports") && boolean.class == returnType) {
-        return true; // ALPN is supported.
-      } else if (methodName.equals("unsupported") && void.class == returnType) {
-        this.unsupported = true; // Peer doesn't support ALPN.
-        return null;
-      } else if (methodName.equals("protocols") && args.length == 0) {
-        return protocols; // Client advertises these protocols.
-      } else if ((methodName.equals("selectProtocol") || methodName.equals("select"))
-          && String.class == returnType && args.length == 1 && args[0] instanceof List) {
-        List<?> peerProtocols = (List) args[0];
-        // Pick the first known protocol the peer advertises.
-        for (int i = 0, size = peerProtocols.size(); i < size; i++) {
-          String protocol = (String) peerProtocols.get(i);
-          if (protocols.contains(protocol)) {
-            return selected = protocol;
-          }
-        }
-        return selected = protocols.get(0); // On no intersection, try peer's first protocol.
-      } else if ((methodName.equals("protocolSelected") || methodName.equals("selected"))
-          && args.length == 1) {
-        this.selected = (String) args[0]; // Server selected this protocol.
-        return null;
-      } else {
-        return method.invoke(this, args);
-      }
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt
new file mode 100644
index 0000000000..249f8b80df
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform
+
+import okhttp3.Protocol
+import java.lang.reflect.InvocationHandler
+import java.lang.reflect.InvocationTargetException
+import java.lang.reflect.Method
+import java.lang.reflect.Proxy
+import javax.net.ssl.SSLSocket
+
+/** OpenJDK 8 with `org.mortbay.jetty.alpn:alpn-boot` in the boot class path.  */
+class Jdk8WithJettyBootPlatform(
+  private val putMethod: Method,
+  private val getMethod: Method,
+  private val removeMethod: Method,
+  private val clientProviderClass: Class<*>,
+  private val serverProviderClass: Class<*>
+) : Platform() {
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  ) {
+    val names = alpnProtocolNames(protocols)
+
+    try {
+      val alpnProvider = Proxy.newProxyInstance(Platform::class.java.classLoader,
+          arrayOf(clientProviderClass, serverProviderClass), AlpnProvider(names))
+      putMethod.invoke(null, sslSocket, alpnProvider)
+    } catch (e: InvocationTargetException) {
+      throw AssertionError("failed to set ALPN", e)
+    } catch (e: IllegalAccessException) {
+      throw AssertionError("failed to set ALPN", e)
+    }
+  }
+
+  override fun afterHandshake(sslSocket: SSLSocket) {
+    try {
+      removeMethod.invoke(null, sslSocket)
+    } catch (e: IllegalAccessException) {
+      throw AssertionError("failed to remove ALPN", e)
+    } catch (e: InvocationTargetException) {
+      throw AssertionError("failed to remove ALPN", e)
+    }
+  }
+
+  override fun getSelectedProtocol(socket: SSLSocket): String? {
+    try {
+      val provider = Proxy.getInvocationHandler(getMethod.invoke(null, socket)) as AlpnProvider
+      if (!provider.unsupported && provider.selected == null) {
+        Platform.get().log(INFO,
+            "ALPN callback dropped: HTTP/2 is disabled. " + "Is alpn-boot on the boot class path?",
+            null)
+        return null
+      }
+      return if (provider.unsupported) null else provider.selected
+    } catch (e: InvocationTargetException) {
+      throw AssertionError("failed to get ALPN selected protocol", e)
+    } catch (e: IllegalAccessException) {
+      throw AssertionError("failed to get ALPN selected protocol", e)
+    }
+  }
+
+  /**
+   * Handle the methods of ALPN's ClientProvider and ServerProvider without a compile-time
+   * dependency on those interfaces.
+   */
+  private class AlpnProvider internal constructor(
+    /** This peer's supported protocols.  */
+    private val protocols: List<String>
+  ) : InvocationHandler {
+    /** Set when remote peer notifies ALPN is unsupported.  */
+    internal var unsupported: Boolean = false
+    /** The protocol the server selected.  */
+    internal var selected: String? = null
+
+    @Throws(Throwable::class)
+    override fun invoke(proxy: Any, method: Method, args: Array<Any>?): Any? {
+      val callArgs = args ?: arrayOf<Any?>()
+      val methodName = method.name
+      val returnType = method.returnType
+      if (methodName == "supports" && Boolean::class.javaPrimitiveType == returnType) {
+        return true // ALPN is supported.
+      } else if (methodName == "unsupported" && Void.TYPE == returnType) {
+        this.unsupported = true // Peer doesn't support ALPN.
+        return null
+      } else if (methodName == "protocols" && callArgs.isEmpty()) {
+        return protocols // Client advertises these protocols.
+      } else if ((methodName == "selectProtocol" || methodName == "select") &&
+          String::class.java == returnType && callArgs.size == 1 && callArgs[0] is List<*>) {
+        val peerProtocols = callArgs[0] as List<*>
+        // Pick the first known protocol the peer advertises.
+        for (i in 0..peerProtocols.size) {
+          val protocol = peerProtocols[i] as String
+          if (protocols.contains(protocol)) {
+            selected = protocol
+            return selected
+          }
+        }
+        selected = protocols[0] // On no intersection, try peer's first protocol.
+        return selected
+      } else if ((methodName == "protocolSelected" || methodName == "selected") && callArgs.size == 1) {
+        this.selected = callArgs[0] as String // Server selected this protocol.
+        return null
+      } else {
+        return method.invoke(this, *callArgs)
+      }
+    }
+  }
+
+  companion object {
+    @JvmStatic
+    fun buildIfSupported(): Platform? {
+      val jvmVersion = System.getProperty("java.specification.version", "unknown")
+      try {
+        // 1.8, 9, 10, 11, 12 etc
+        val version = jvmVersion.toInt()
+        if (version >= 9) return null
+      } catch (nfe: NumberFormatException) {
+        // expected on >= JDK 9
+      }
+
+      // Find Jetty's ALPN extension for OpenJDK.
+      try {
+        val alpnClassName = "org.eclipse.jetty.alpn.ALPN"
+        val alpnClass = Class.forName(alpnClassName, true, null)
+        val providerClass = Class.forName("$alpnClassName\$Provider", true, null)
+        val clientProviderClass = Class.forName("$alpnClassName\$ClientProvider", true, null)
+        val serverProviderClass = Class.forName("$alpnClassName\$ServerProvider", true, null)
+        val putMethod = alpnClass.getMethod("put", SSLSocket::class.java, providerClass)
+        val getMethod = alpnClass.getMethod("get", SSLSocket::class.java)
+        val removeMethod = alpnClass.getMethod("remove", SSLSocket::class.java)
+        return Jdk8WithJettyBootPlatform(
+            putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass)
+      } catch (ignored: ClassNotFoundException) {
+      } catch (ignored: NoSuchMethodException) {
+      }
+
+      return null
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
deleted file mode 100644
index 07cb67c885..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLParameters;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Protocol;
-
-/** OpenJDK 9+. */
-final class Jdk9Platform extends Platform {
-  final Method setProtocolMethod;
-  final Method getProtocolMethod;
-
-  Jdk9Platform(Method setProtocolMethod, Method getProtocolMethod) {
-    this.setProtocolMethod = setProtocolMethod;
-    this.getProtocolMethod = getProtocolMethod;
-  }
-
-  @Override
-  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
-      List<Protocol> protocols) {
-    try {
-      SSLParameters sslParameters = sslSocket.getSSLParameters();
-
-      List<String> names = alpnProtocolNames(protocols);
-
-      setProtocolMethod.invoke(sslParameters,
-          new Object[] {names.toArray(new String[names.size()])});
-
-      sslSocket.setSSLParameters(sslParameters);
-    } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError("failed to set SSL parameters", e);
-    }
-  }
-
-  @Override
-  public @Nullable String getSelectedProtocol(SSLSocket socket) {
-    try {
-      String protocol = (String) getProtocolMethod.invoke(socket);
-
-      // SSLSocket.getApplicationProtocol returns "" if application protocols values will not
-      // be used. Observed if you didn't specify SSLParameters.setApplicationProtocols
-      if (protocol == null || protocol.equals("")) {
-        return null;
-      }
-
-      return protocol;
-    } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError("failed to get ALPN selected protocol", e);
-    }
-  }
-
-  @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
-    // Not supported due to access checks on JDK 9+:
-    // java.lang.reflect.InaccessibleObjectException: Unable to make member of class
-    // sun.security.ssl.SSLSocketFactoryImpl accessible:  module java.base does not export
-    // sun.security.ssl to unnamed module @xxx
-    throw new UnsupportedOperationException(
-        "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on JDK 9+");
-  }
-
-  public static Jdk9Platform buildIfSupported() {
-    // Find JDK 9 new methods
-    try {
-      Method setProtocolMethod =
-          SSLParameters.class.getMethod("setApplicationProtocols", String[].class);
-      Method getProtocolMethod = SSLSocket.class.getMethod("getApplicationProtocol");
-
-      return new Jdk9Platform(setProtocolMethod, getProtocolMethod);
-    } catch (NoSuchMethodException ignored) {
-      // pre JDK 9
-    }
-
-    return null;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.kt
new file mode 100644
index 0000000000..7305b90fb4
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.kt
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform
+
+import java.lang.reflect.InvocationTargetException
+import java.lang.reflect.Method
+import javax.net.ssl.SSLParameters
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+import okhttp3.Protocol
+
+/** OpenJDK 9+.  */
+class Jdk9Platform(
+  @JvmField val setProtocolMethod: Method,
+  @JvmField val getProtocolMethod: Method
+) : Platform() {
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<Protocol>
+  ) {
+    try {
+      val sslParameters = sslSocket.sslParameters
+
+      val names = alpnProtocolNames(protocols)
+
+      setProtocolMethod.invoke(sslParameters, names.toTypedArray())
+
+      sslSocket.sslParameters = sslParameters
+    } catch (e: IllegalAccessException) {
+      throw AssertionError("failed to set SSL parameters", e)
+    } catch (e: InvocationTargetException) {
+      throw AssertionError("failed to set SSL parameters", e)
+    }
+  }
+
+  override fun getSelectedProtocol(socket: SSLSocket): String? = try {
+    val protocol = getProtocolMethod.invoke(socket) as String?
+
+    // SSLSocket.getApplicationProtocol returns "" if application protocols values will not
+    // be used. Observed if you didn't specify SSLParameters.setApplicationProtocols
+    when (protocol) {
+      null, "" -> null
+      else -> protocol
+    }
+  } catch (e: IllegalAccessException) {
+    throw AssertionError("failed to get ALPN selected protocol", e)
+  } catch (e: InvocationTargetException) {
+    throw AssertionError("failed to get ALPN selected protocol", e)
+  }
+
+  public override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {
+    // Not supported due to access checks on JDK 9+:
+    // java.lang.reflect.InaccessibleObjectException: Unable to make member of class
+    // sun.security.ssl.SSLSocketFactoryImpl accessible:  module java.base does not export
+    // sun.security.ssl to unnamed module @xxx
+    throw UnsupportedOperationException(
+        "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on JDK 9+")
+  }
+
+  companion object {
+    @JvmStatic
+    fun buildIfSupported(): Jdk9Platform? =
+        try {
+          // Find JDK 9 methods
+          val setProtocolMethod = SSLParameters::class.java.getMethod("setApplicationProtocols",
+              Array<String>::class.java)
+          val getProtocolMethod = SSLSocket::class.java.getMethod("getApplicationProtocol")
+
+          Jdk9Platform(setProtocolMethod, getProtocolMethod)
+        } catch (ignored: NoSuchMethodException) {
+          // pre JDK 9
+          null
+        }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
deleted file mode 100644
index 3d3b00be2d..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
+++ /dev/null
@@ -1,282 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import java.io.IOException;
-import java.lang.reflect.Field;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.security.NoSuchAlgorithmException;
-import java.security.Security;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.internal.Util;
-import okhttp3.internal.tls.BasicCertificateChainCleaner;
-import okhttp3.internal.tls.CertificateChainCleaner;
-import okio.Buffer;
-
-/**
- * Access to platform-specific features.
- *
- * <h3>Server name indication (SNI)</h3>
- *
- * <p>Supported on Android 2.3+.
- *
- * <p>Supported on OpenJDK 7+
- *
- * <h3>Session Tickets</h3>
- *
- * <p>Supported on Android 2.3+.
- *
- * <h3>Android Traffic Stats (Socket Tagging)</h3>
- *
- * <p>Supported on Android 4.0+.
- *
- * <h3>ALPN (Application Layer Protocol Negotiation)</h3>
- *
- * <p>Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
- * unstable.
- *
- * <p>Supported on OpenJDK 8 via the JettyALPN-boot library.
- *
- * <p>Supported on OpenJDK 9+ via SSLParameters and SSLSocket features.
- *
- * <h3>Trust Manager Extraction</h3>
- *
- * <p>Supported on Android 2.3+ and OpenJDK 7+. There are no public APIs to recover the trust
- * manager that was used to create an {@link SSLSocketFactory}.
- *
- * <h3>Android Cleartext Permit Detection</h3>
- *
- * <p>Supported on Android 6.0+ via {@code NetworkSecurityPolicy}.
- */
-public class Platform {
-  private static final Platform PLATFORM = findPlatform();
-  public static final int INFO = 4;
-  public static final int WARN = 5;
-  private static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
-
-  public static Platform get() {
-    return PLATFORM;
-  }
-
-  /** Prefix used on custom headers. */
-  public String getPrefix() {
-    return "OkHttp";
-  }
-
-  protected @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
-    // Attempt to get the trust manager from an OpenJDK socket factory. We attempt this on all
-    // platforms in order to support Robolectric, which mixes classes from both Android and the
-    // Oracle JDK. Note that we don't support HTTP/2 or other nice features on Robolectric.
-    try {
-      Class<?> sslContextClass = Class.forName("sun.security.ssl.SSLContextImpl");
-      Object context = readFieldOrNull(sslSocketFactory, sslContextClass, "context");
-      if (context == null) return null;
-      return readFieldOrNull(context, X509TrustManager.class, "trustManager");
-    } catch (ClassNotFoundException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Configure TLS extensions on {@code sslSocket} for {@code route}.
-   *
-   * @param hostname non-null for client-side handshakes; null for server-side handshakes.
-   */
-  public void configureTlsExtensions(SSLSocket sslSocket, @Nullable String hostname,
-      List<Protocol> protocols) {
-  }
-
-  /**
-   * Called after the TLS handshake to release resources allocated by {@link
-   * #configureTlsExtensions}.
-   */
-  public void afterHandshake(SSLSocket sslSocket) {
-  }
-
-  /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  public @Nullable String getSelectedProtocol(SSLSocket socket) {
-    return null;
-  }
-
-  public void connectSocket(Socket socket, InetSocketAddress address, int connectTimeout)
-      throws IOException {
-    socket.connect(address, connectTimeout);
-  }
-
-  public void log(int level, String message, @Nullable Throwable t) {
-    Level logLevel = level == WARN ? Level.WARNING : Level.INFO;
-    logger.log(logLevel, message, t);
-  }
-
-  public boolean isCleartextTrafficPermitted(String hostname) {
-    return true;
-  }
-
-  /**
-   * Returns an object that holds a stack trace created at the moment this method is executed. This
-   * should be used specifically for {@link java.io.Closeable} objects and in conjunction with
-   * {@link #logCloseableLeak(String, Object)}.
-   */
-  public Object getStackTraceForCloseable(String closer) {
-    if (logger.isLoggable(Level.FINE)) {
-      return new Throwable(closer); // These are expensive to allocate.
-    }
-    return null;
-  }
-
-  public void logCloseableLeak(String message, Object stackTrace) {
-    if (stackTrace == null) {
-      message += " To see where this was allocated, set the OkHttpClient logger level to FINE: "
-          + "Logger.getLogger(OkHttpClient.class.getName()).setLevel(Level.FINE);";
-    }
-    log(WARN, message, (Throwable) stackTrace);
-  }
-
-  public static List<String> alpnProtocolNames(List<Protocol> protocols) {
-    List<String> names = new ArrayList<>(protocols.size());
-    for (int i = 0, size = protocols.size(); i < size; i++) {
-      Protocol protocol = protocols.get(i);
-      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
-      names.add(protocol.toString());
-    }
-    return names;
-  }
-
-  public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
-    return new BasicCertificateChainCleaner(trustManager.getAcceptedIssuers());
-  }
-
-  public CertificateChainCleaner buildCertificateChainCleaner(SSLSocketFactory sslSocketFactory) {
-    X509TrustManager trustManager = trustManager(sslSocketFactory);
-
-    if (trustManager == null) {
-      throw new IllegalStateException("Unable to extract the trust manager on "
-          + Platform.get()
-          + ", sslSocketFactory is "
-          + sslSocketFactory.getClass());
-    }
-
-    return buildCertificateChainCleaner(trustManager);
-  }
-
-  public static boolean isConscryptPreferred() {
-    // mainly to allow tests to run cleanly
-    if ("conscrypt".equals(Util.getSystemProperty("okhttp.platform", null))) {
-      return true;
-    }
-
-    // check if Provider manually installed
-    String preferredProvider = Security.getProviders()[0].getName();
-    return "Conscrypt".equals(preferredProvider);
-  }
-
-  /** Attempt to match the host runtime to a capable Platform implementation. */
-  private static Platform findPlatform() {
-    Platform android = AndroidPlatform.buildIfSupported();
-
-    if (android != null) {
-      return android;
-    }
-
-    if (isConscryptPreferred()) {
-      Platform conscrypt = ConscryptPlatform.buildIfSupported();
-
-      if (conscrypt != null) {
-        return conscrypt;
-      }
-    }
-
-    Platform jdk9 = Jdk9Platform.buildIfSupported();
-
-    if (jdk9 != null) {
-      return jdk9;
-    }
-
-    Platform jdkWithJettyBoot = Jdk8WithJettyBootPlatform.buildIfSupported();
-
-    if (jdkWithJettyBoot != null) {
-      return jdkWithJettyBoot;
-    }
-
-    // Probably an Oracle JDK like OpenJDK.
-    return new Platform();
-  }
-
-  /**
-   * Returns the concatenation of 8-bit, length prefixed protocol names.
-   * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
-   */
-  static byte[] concatLengthPrefixed(List<Protocol> protocols) {
-    Buffer result = new Buffer();
-    for (int i = 0, size = protocols.size(); i < size; i++) {
-      Protocol protocol = protocols.get(i);
-      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
-      result.writeByte(protocol.toString().length());
-      result.writeUtf8(protocol.toString());
-    }
-    return result.readByteArray();
-  }
-
-  static @Nullable <T> T readFieldOrNull(Object instance, Class<T> fieldType, String fieldName) {
-    for (Class<?> c = instance.getClass(); c != Object.class; c = c.getSuperclass()) {
-      try {
-        Field field = c.getDeclaredField(fieldName);
-        field.setAccessible(true);
-        Object value = field.get(instance);
-        if (!fieldType.isInstance(value)) return null;
-        return fieldType.cast(value);
-      } catch (NoSuchFieldException ignored) {
-      } catch (IllegalAccessException e) {
-        throw new AssertionError();
-      }
-    }
-
-    // Didn't find the field we wanted. As a last gasp attempt, try to find the value on a delegate.
-    if (!fieldName.equals("delegate")) {
-      Object delegate = readFieldOrNull(instance, Object.class, "delegate");
-      if (delegate != null) return readFieldOrNull(delegate, fieldType, fieldName);
-    }
-
-    return null;
-  }
-
-  public SSLContext getSSLContext() {
-    try {
-      return SSLContext.getInstance("TLS");
-    } catch (NoSuchAlgorithmException e) {
-      throw new IllegalStateException("No TLS provider", e);
-    }
-  }
-
-  public void configureSslSocketFactory(SSLSocketFactory socketFactory) {
-  }
-
-  @Override public String toString() {
-    return getClass().getSimpleName();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
new file mode 100644
index 0000000000..f99405ba56
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
@@ -0,0 +1,271 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform
+
+import okhttp3.OkHttpClient
+import okhttp3.Protocol
+import okhttp3.internal.tls.BasicCertificateChainCleaner
+import okhttp3.internal.tls.BasicTrustRootIndex
+import okhttp3.internal.tls.CertificateChainCleaner
+import okhttp3.internal.tls.TrustRootIndex
+import okio.Buffer
+import java.io.IOException
+import java.net.InetSocketAddress
+import java.net.Socket
+import java.security.KeyStore
+import java.security.Security
+import java.util.logging.Level
+import java.util.logging.Logger
+import javax.net.ssl.SSLContext
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.TrustManagerFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Access to platform-specific features.
+ *
+ * ### Server name indication (SNI)
+ *
+ * Supported on Android 2.3+.
+ *
+ * Supported on OpenJDK 7+
+ *
+ * ### Session Tickets
+ *
+ * Supported on Android 2.3+.
+ *
+ * ### Android Traffic Stats (Socket Tagging)
+ *
+ * Supported on Android 4.0+.
+ *
+ * ### ALPN (Application Layer Protocol Negotiation)
+ *
+ * Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
+ * unstable.
+ *
+ * Supported on OpenJDK 8 via the JettyALPN-boot library.
+ *
+ * Supported on OpenJDK 9+ via SSLParameters and SSLSocket features.
+ *
+ * ### Trust Manager Extraction
+ *
+ * Supported on Android 2.3+ and OpenJDK 7+. There are no public APIs to recover the trust
+ * manager that was used to create an [SSLSocketFactory].
+ *
+ * ### Android Cleartext Permit Detection
+ *
+ * Supported on Android 6.0+ via `NetworkSecurityPolicy`.
+ */
+open class Platform {
+
+  /** Prefix used on custom headers.  */
+  fun getPrefix() = "OkHttp"
+
+  open fun newSSLContext(): SSLContext = SSLContext.getInstance("TLS")
+
+  open fun platformTrustManager(): X509TrustManager {
+    val factory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm())
+    factory.init(null as KeyStore?)
+    val trustManagers = factory.trustManagers!!
+    check(trustManagers.size == 1 && trustManagers[0] is X509TrustManager) {
+      "Unexpected default trust managers: ${trustManagers.contentToString()}"
+    }
+    return trustManagers[0] as X509TrustManager
+  }
+
+  protected open fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {
+    return try {
+      // Attempt to get the trust manager from an OpenJDK socket factory. We attempt this on all
+      // platforms in order to support Robolectric, which mixes classes from both Android and the
+      // Oracle JDK. Note that we don't support HTTP/2 or other nice features on Robolectric.
+      val sslContextClass = Class.forName("sun.security.ssl.SSLContextImpl")
+      val context = readFieldOrNull(sslSocketFactory, sslContextClass, "context") ?: return null
+      readFieldOrNull(context, X509TrustManager::class.java, "trustManager")
+    } catch (e: ClassNotFoundException) {
+      null
+    }
+  }
+
+  /**
+   * Configure TLS extensions on `sslSocket` for `route`.
+   *
+   * @param hostname non-null for client-side handshakes; null for server-side handshakes.
+   */
+  open fun configureTlsExtensions(
+    sslSocket: SSLSocket,
+    hostname: String?,
+    protocols: List<@JvmSuppressWildcards Protocol>
+  ) {
+  }
+
+  /** Called after the TLS handshake to release resources allocated by [configureTlsExtensions]. */
+  open fun afterHandshake(sslSocket: SSLSocket) {
+  }
+
+  /** Returns the negotiated protocol, or null if no protocol was negotiated.  */
+  open fun getSelectedProtocol(socket: SSLSocket): String? = null
+
+  @Throws(IOException::class)
+  open fun connectSocket(socket: Socket, address: InetSocketAddress, connectTimeout: Int) {
+    socket.connect(address, connectTimeout)
+  }
+
+  open fun log(level: Int, message: String, t: Throwable?) {
+    val logLevel = if (level == WARN) Level.WARNING else Level.INFO
+    logger.log(logLevel, message, t)
+  }
+
+  open fun isCleartextTrafficPermitted(hostname: String): Boolean = true
+
+  /**
+   * Returns an object that holds a stack trace created at the moment this method is executed. This
+   * should be used specifically for [java.io.Closeable] objects and in conjunction with
+   * [logCloseableLeak].
+   */
+  open fun getStackTraceForCloseable(closer: String): Any? {
+    return when {
+      logger.isLoggable(Level.FINE) -> Throwable(closer) // These are expensive to allocate.
+      else -> null
+    }
+  }
+
+  open fun logCloseableLeak(message: String, stackTrace: Any?) {
+    var logMessage = message
+    if (stackTrace == null) {
+      logMessage += " To see where this was allocated, set the OkHttpClient logger level to " +
+          "FINE: Logger.getLogger(OkHttpClient.class.getName()).setLevel(Level.FINE);"
+    }
+    log(WARN, logMessage, stackTrace as Throwable?)
+  }
+
+  open fun buildCertificateChainCleaner(trustManager: X509TrustManager): CertificateChainCleaner =
+      BasicCertificateChainCleaner(buildTrustRootIndex(trustManager))
+
+  fun buildCertificateChainCleaner(sslSocketFactory: SSLSocketFactory): CertificateChainCleaner {
+    val trustManager = trustManager(sslSocketFactory) ?: throw IllegalStateException(
+        "Unable to extract the trust manager on ${get()}, " +
+            "sslSocketFactory is ${sslSocketFactory.javaClass}")
+    return buildCertificateChainCleaner(trustManager)
+  }
+
+  open fun buildTrustRootIndex(trustManager: X509TrustManager): TrustRootIndex =
+      BasicTrustRootIndex(*trustManager.acceptedIssuers)
+
+  open fun configureSslSocketFactory(socketFactory: SSLSocketFactory) {
+  }
+
+  open fun configureTrustManager(trustManager: X509TrustManager?) {
+  }
+
+  override fun toString(): String = javaClass.simpleName
+
+  companion object {
+    @Volatile private var platform = findPlatform()
+
+    const val INFO = 4
+    const val WARN = 5
+
+    private val logger = Logger.getLogger(OkHttpClient::class.java.name)
+
+    @JvmStatic
+    fun get(): Platform = platform
+
+    fun resetForTests(platform: Platform = findPlatform()) {
+      this.platform = platform
+    }
+
+    fun alpnProtocolNames(protocols: List<Protocol>) =
+        protocols.filter { it != Protocol.HTTP_1_0 }.map { it.toString() }
+
+    @JvmStatic
+    val isConscryptPreferred: Boolean
+      get() {
+        val preferredProvider = Security.getProviders()[0].name
+        return "Conscrypt" == preferredProvider
+      }
+
+    /** Attempt to match the host runtime to a capable Platform implementation.  */
+    @JvmStatic
+    private fun findPlatform(): Platform {
+      val android = AndroidPlatform.buildIfSupported()
+
+      if (android != null) {
+        return android
+      }
+
+      if (isConscryptPreferred) {
+        val conscrypt = ConscryptPlatform.buildIfSupported()
+
+        if (conscrypt != null) {
+          return conscrypt
+        }
+      }
+
+      val jdk9 = Jdk9Platform.buildIfSupported()
+
+      if (jdk9 != null) {
+        return jdk9
+      }
+
+      // An Oracle JDK 8 like OpenJDK.
+      val jdkWithJettyBoot = Jdk8WithJettyBootPlatform.buildIfSupported()
+
+      return jdkWithJettyBoot ?: Platform()
+    }
+
+    /**
+     * Returns the concatenation of 8-bit, length prefixed protocol names.
+     * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
+     */
+    @JvmStatic
+    fun concatLengthPrefixed(protocols: List<Protocol>): ByteArray {
+      val result = Buffer()
+      for (protocol in alpnProtocolNames(protocols)) {
+        result.writeByte(protocol.length)
+        result.writeUtf8(protocol)
+      }
+      return result.readByteArray()
+    }
+
+    @JvmStatic
+    fun <T> readFieldOrNull(instance: Any, fieldType: Class<T>, fieldName: String): T? {
+      var c: Class<*> = instance.javaClass
+      while (c != Any::class.java) {
+        try {
+          val field = c.getDeclaredField(fieldName)
+          field.isAccessible = true
+          val value = field.get(instance)
+          return if (!fieldType.isInstance(value)) null else fieldType.cast(value)
+        } catch (ignored: NoSuchFieldException) {
+        }
+
+        c = c.superclass
+      }
+
+      // Didn't find the field we wanted. As a last gasp attempt,
+      // try to find the value on a delegate.
+      if (fieldName != "delegate") {
+        val delegate = readFieldOrNull(instance, Any::class.java, "delegate")
+        if (delegate != null) return readFieldOrNull(delegate, fieldType, fieldName)
+      }
+
+      return null
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java b/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java
deleted file mode 100644
index d18b6335f1..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.proxy;
-
-import java.io.IOException;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * A proxy selector that always returns the {@link Proxy#NO_PROXY}.
- */
-public class NullProxySelector extends ProxySelector {
-  @Override public List<Proxy> select(URI uri) {
-    if (uri == null) {
-      throw new IllegalArgumentException("uri must not be null");
-    }
-    return Collections.singletonList(Proxy.NO_PROXY);
-  }
-
-  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java b/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.kt
similarity index 52%
rename from okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java
rename to okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.kt
index 3b077f8bc4..d18d2eca31 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java
+++ b/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Square, Inc.
+ * Copyright (C) 2018 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,20 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
-import java.io.IOException;
-import java.net.URL;
+package okhttp3.internal.proxy
+
+import java.io.IOException
+import java.net.Proxy
+import java.net.ProxySelector
+import java.net.SocketAddress
+import java.net.URI
 
 /**
- * Request filter based on the request's URL.
- *
- * @deprecated use {@link okhttp3.Interceptor} for non-HttpURLConnection filtering.
+ * A proxy selector that always returns the [Proxy.NO_PROXY].
  */
-public interface URLFilter {
-  /**
-   * Check whether request to the provided URL is permitted to be issued.
-   *
-   * @throws IOException if the request to the provided URL is not permitted.
-   */
-  void checkURLPermitted(URL url) throws IOException;
+open class NullProxySelector : ProxySelector() {
+  override fun select(uri: URI?): List<Proxy> {
+    requireNotNull(uri) { "uri must not be null" }
+    return listOf(Proxy.NO_PROXY)
+  }
+
+  override fun connectFailed(uri: URI?, sa: SocketAddress?, ioe: IOException?) {
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java
deleted file mode 100644
index 81e1c0adc7..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.java
+++ /dev/null
@@ -1,158 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.security.GeneralSecurityException;
-import java.security.PublicKey;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Deque;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.security.auth.x500.X500Principal;
-
-/**
- * A certificate chain cleaner that uses a set of trusted root certificates to build the trusted
- * chain. This class duplicates the clean chain building performed during the TLS handshake. We
- * prefer other mechanisms where they exist, such as with
- * {@code okhttp3.internal.platform.AndroidPlatform.AndroidCertificateChainCleaner}.
- *
- * <p>This class includes code from <a href="https://conscrypt.org/">Conscrypt's</a> {@code
- * TrustManagerImpl} and {@code TrustedCertificateIndex}.
- */
-public final class BasicCertificateChainCleaner extends CertificateChainCleaner {
-  /** The maximum number of signers in a chain. We use 9 for consistency with OpenSSL. */
-  private static final int MAX_SIGNERS = 9;
-
-  /** A simple index that of trusted root certificates that have been loaded into memory. */
-  private final Map<X500Principal, Set<X509Certificate>> subjectToCaCerts;
-
-  public BasicCertificateChainCleaner(X509Certificate... caCerts) {
-    subjectToCaCerts = new LinkedHashMap<>();
-    for (X509Certificate caCert : caCerts) {
-      X500Principal subject = caCert.getSubjectX500Principal();
-      Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
-      if (subjectCaCerts == null) {
-        subjectCaCerts = new LinkedHashSet<>(1);
-        subjectToCaCerts.put(subject, subjectCaCerts);
-      }
-      subjectCaCerts.add(caCert);
-    }
-  }
-
-  /**
-   * Returns a cleaned chain for {@code chain}.
-   *
-   * <p>This method throws if the complete chain to a trusted CA certificate cannot be constructed.
-   * This is unexpected unless the trust root index in this class has a different trust manager than
-   * what was used to establish {@code chain}.
-   */
-  @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
-      throws SSLPeerUnverifiedException {
-    Deque<Certificate> queue = new ArrayDeque<>(chain);
-    List<Certificate> result = new ArrayList<>();
-    result.add(queue.removeFirst());
-    boolean foundTrustedCertificate = false;
-
-    followIssuerChain:
-    for (int c = 0; c < MAX_SIGNERS; c++) {
-      X509Certificate toVerify = (X509Certificate) result.get(result.size() - 1);
-
-      // If this cert has been signed by a trusted cert, use that. Add the trusted certificate to
-      // the end of the chain unless it's already present. (That would happen if the first
-      // certificate in the chain is itself a self-signed and trusted CA certificate.)
-      X509Certificate trustedCert = findByIssuerAndSignature(toVerify);
-      if (trustedCert != null) {
-        if (result.size() > 1 || !toVerify.equals(trustedCert)) {
-          result.add(trustedCert);
-        }
-        if (verifySignature(trustedCert, trustedCert)) {
-          return result; // The self-signed cert is a root CA. We're done.
-        }
-        foundTrustedCertificate = true;
-        continue;
-      }
-
-      // Search for the certificate in the chain that signed this certificate. This is typically
-      // the next element in the chain, but it could be any element.
-      for (Iterator<Certificate> i = queue.iterator(); i.hasNext(); ) {
-        X509Certificate signingCert = (X509Certificate) i.next();
-        if (verifySignature(toVerify, signingCert)) {
-          i.remove();
-          result.add(signingCert);
-          continue followIssuerChain;
-        }
-      }
-
-      // We've reached the end of the chain. If any cert in the chain is trusted, we're done.
-      if (foundTrustedCertificate) {
-        return result;
-      }
-
-      // The last link isn't trusted. Fail.
-      throw new SSLPeerUnverifiedException(
-          "Failed to find a trusted cert that signed " + toVerify);
-    }
-
-    throw new SSLPeerUnverifiedException("Certificate chain too long: " + result);
-  }
-
-  /** Returns true if {@code toVerify} was signed by {@code signingCert}'s public key. */
-  private boolean verifySignature(X509Certificate toVerify, X509Certificate signingCert) {
-    if (!toVerify.getIssuerDN().equals(signingCert.getSubjectDN())) return false;
-    try {
-      toVerify.verify(signingCert.getPublicKey());
-      return true;
-    } catch (GeneralSecurityException verifyFailed) {
-      return false;
-    }
-  }
-
-  /** Returns the trusted CA certificate that signed {@code cert}. */
-  private X509Certificate findByIssuerAndSignature(X509Certificate cert) {
-    X500Principal issuer = cert.getIssuerX500Principal();
-    Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
-    if (subjectCaCerts == null) return null;
-
-    for (X509Certificate caCert : subjectCaCerts) {
-      PublicKey publicKey = caCert.getPublicKey();
-      try {
-        cert.verify(publicKey);
-        return caCert;
-      } catch (Exception ignored) {
-      }
-    }
-
-    return null;
-  }
-
-  @Override public int hashCode() {
-    return subjectToCaCerts.hashCode();
-  }
-
-  @Override public boolean equals(Object other) {
-    if (other == this) return true;
-    return other instanceof BasicCertificateChainCleaner
-        && ((BasicCertificateChainCleaner) other).subjectToCaCerts.equals(subjectToCaCerts);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.kt b/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.kt
new file mode 100644
index 0000000000..3ebe3551f4
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/BasicCertificateChainCleaner.kt
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls
+
+import java.security.GeneralSecurityException
+import java.security.cert.Certificate
+import java.security.cert.X509Certificate
+import java.util.Deque
+import java.util.ArrayDeque
+import javax.net.ssl.SSLPeerUnverifiedException
+
+/**
+ * A certificate chain cleaner that uses a set of trusted root certificates to build the trusted
+ * chain. This class duplicates the clean chain building performed during the TLS handshake. We
+ * prefer other mechanisms where they exist, such as with
+ * [okhttp3.internal.platform.AndroidPlatform.AndroidCertificateChainCleaner].
+ *
+ * This class includes code from <a href="https://conscrypt.org/">Conscrypt's</a> [TrustManagerImpl]
+ * and [TrustedCertificateIndex].
+ */
+class BasicCertificateChainCleaner(
+  private val trustRootIndex: TrustRootIndex
+) : CertificateChainCleaner() {
+
+  /**
+   * Returns a cleaned chain for [chain].
+   *
+   * This method throws if the complete chain to a trusted CA certificate cannot be constructed.
+   * This is unexpected unless the trust root index in this class has a different trust manager than
+   * what was used to establish [chain].
+   */
+  @Throws(SSLPeerUnverifiedException::class)
+  override fun clean(chain: List<Certificate>, hostname: String): List<Certificate> {
+    val queue: Deque<Certificate> = ArrayDeque<Certificate>(chain)
+    val result = ArrayList<Certificate>()
+    result.add(queue.removeFirst())
+    var foundTrustedCertificate = false
+
+    followIssuerChain@
+    for (c in 0 until MAX_SIGNERS) {
+      val toVerify = result[result.size - 1] as X509Certificate
+
+      // If this cert has been signed by a trusted cert, use that. Add the trusted certificate to
+      // the end of the chain unless it's already present. (That would happen if the first
+      // certificate in the chain is itself a self-signed and trusted CA certificate.)
+      val trustedCert = trustRootIndex.findByIssuerAndSignature(toVerify)
+      if (trustedCert != null) {
+        if (result.size > 1 || toVerify != trustedCert) {
+          result.add(trustedCert)
+        }
+        if (verifySignature(trustedCert, trustedCert)) {
+          return result // The self-signed cert is a root CA. We're done.
+        }
+        foundTrustedCertificate = true
+        continue
+      }
+
+      // Search for the certificate in the chain that signed this certificate. This is typically
+      // the next element in the chain, but it could be any element.
+      val i = queue.iterator()
+      while (i.hasNext()) {
+        val signingCert = i.next() as X509Certificate
+        if (verifySignature(toVerify, signingCert)) {
+          i.remove()
+          result.add(signingCert)
+          continue@followIssuerChain
+        }
+      }
+
+      // We've reached the end of the chain. If any cert in the chain is trusted, we're done.
+      if (foundTrustedCertificate) {
+        return result
+      }
+
+      // The last link isn't trusted. Fail.
+      throw SSLPeerUnverifiedException(
+          "Failed to find a trusted cert that signed $toVerify")
+    }
+
+    throw SSLPeerUnverifiedException("Certificate chain too long: $result")
+  }
+
+  /** Returns true if [toVerify] was signed by [signingCert]'s public key.  */
+  private fun verifySignature(toVerify: X509Certificate, signingCert: X509Certificate): Boolean {
+    if (toVerify.issuerDN != signingCert.subjectDN) {
+      return false
+    }
+    return try {
+      toVerify.verify(signingCert.publicKey)
+      true
+    } catch (verifyFailed: GeneralSecurityException) {
+      false
+    }
+  }
+
+  override fun hashCode(): Int {
+    return trustRootIndex.hashCode()
+  }
+
+  override fun equals(other: Any?): Boolean {
+    return if (other === this) {
+      true
+    } else {
+      other is BasicCertificateChainCleaner && other.trustRootIndex == trustRootIndex
+    }
+  }
+
+  companion object {
+    private const val MAX_SIGNERS = 9
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.kt b/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.kt
new file mode 100644
index 0000000000..2b93613b87
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.kt
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls
+
+import java.security.cert.X509Certificate
+import javax.security.auth.x500.X500Principal
+
+/** A simple index that of trusted root certificates that have been loaded into memory.  */
+class BasicTrustRootIndex(vararg caCerts: X509Certificate) : TrustRootIndex {
+  private val subjectToCaCerts: Map<X500Principal, Set<X509Certificate>>
+
+  init {
+    val map = mutableMapOf<X500Principal, MutableSet<X509Certificate>>()
+    for (caCert in caCerts) {
+      map.getOrPut(caCert.subjectX500Principal) { mutableSetOf() }.add(caCert)
+    }
+    this.subjectToCaCerts = map
+  }
+
+  override fun findByIssuerAndSignature(cert: X509Certificate): X509Certificate? {
+    val issuer = cert.issuerX500Principal
+    val subjectCaCerts = subjectToCaCerts[issuer] ?: return null
+
+    return subjectCaCerts.firstOrNull {
+      try {
+        cert.verify(it.publicKey)
+        return@firstOrNull true
+      } catch (_: Exception) {
+        return@firstOrNull false
+      }
+    }
+  }
+
+  override fun equals(other: Any?): Boolean {
+    return other === this ||
+        (other is BasicTrustRootIndex && other.subjectToCaCerts == subjectToCaCerts)
+  }
+
+  override fun hashCode(): Int {
+    return subjectToCaCerts.hashCode()
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.kt
similarity index 57%
rename from okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
rename to okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.kt
index 94903e4b7d..7296afa1a5 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.kt
@@ -14,34 +14,38 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package okhttp3.internal.tls;
+package okhttp3.internal.tls
 
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.List;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.platform.Platform;
+import okhttp3.internal.platform.Platform
+import java.security.cert.Certificate
+import java.security.cert.X509Certificate
+import javax.net.ssl.SSLPeerUnverifiedException
+import javax.net.ssl.X509TrustManager
 
 /**
  * Computes the effective certificate chain from the raw array returned by Java's built in TLS APIs.
- * Cleaning a chain returns a list of certificates where the first element is {@code chain[0]}, each
+ * Cleaning a chain returns a list of certificates where the first element is `chain[0]`, each
  * certificate is signed by the certificate that follows, and the last certificate is a trusted CA
  * certificate.
  *
- * <p>Use of the chain cleaner is necessary to omit unexpected certificates that aren't relevant to
+ * Use of the chain cleaner is necessary to omit unexpected certificates that aren't relevant to
  * the TLS handshake and to extract the trusted CA certificate for the benefit of certificate
  * pinning.
  */
-public abstract class CertificateChainCleaner {
-  public abstract List<Certificate> clean(List<Certificate> chain, String hostname)
-      throws SSLPeerUnverifiedException;
+abstract class CertificateChainCleaner {
 
-  public static CertificateChainCleaner get(X509TrustManager trustManager) {
-    return Platform.get().buildCertificateChainCleaner(trustManager);
-  }
+  @Throws(SSLPeerUnverifiedException::class)
+  abstract fun clean(chain: List<Certificate>, hostname: String): List<Certificate>
+
+  companion object {
+    @JvmStatic
+    fun get(trustManager: X509TrustManager): CertificateChainCleaner {
+      return Platform.get().buildCertificateChainCleaner(trustManager)
+    }
 
-  public static CertificateChainCleaner get(X509Certificate... caCerts) {
-    return new BasicCertificateChainCleaner(caCerts);
+    @JvmStatic
+    fun get(vararg caCerts: X509Certificate): CertificateChainCleaner {
+      return BasicCertificateChainCleaner(BasicTrustRootIndex(*caCerts))
+    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
deleted file mode 100644
index 36ac5b3813..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
+++ /dev/null
@@ -1,216 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.security.cert.Certificate;
-import java.security.cert.CertificateParsingException;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.Locale;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLSession;
-
-import static okhttp3.internal.Util.verifyAsIpAddress;
-
-/**
- * A HostnameVerifier consistent with <a href="http://www.ietf.org/rfc/rfc2818.txt">RFC 2818</a>.
- */
-public final class OkHostnameVerifier implements HostnameVerifier {
-  public static final OkHostnameVerifier INSTANCE = new OkHostnameVerifier();
-
-  private static final int ALT_DNS_NAME = 2;
-  private static final int ALT_IPA_NAME = 7;
-
-  private OkHostnameVerifier() {
-  }
-
-  @Override
-  public boolean verify(String host, SSLSession session) {
-    try {
-      Certificate[] certificates = session.getPeerCertificates();
-      return verify(host, (X509Certificate) certificates[0]);
-    } catch (SSLException e) {
-      return false;
-    }
-  }
-
-  public boolean verify(String host, X509Certificate certificate) {
-    return verifyAsIpAddress(host)
-        ? verifyIpAddress(host, certificate)
-        : verifyHostname(host, certificate);
-  }
-
-  /** Returns true if {@code certificate} matches {@code ipAddress}. */
-  private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
-    List<String> altNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
-    for (int i = 0, size = altNames.size(); i < size; i++) {
-      if (ipAddress.equalsIgnoreCase(altNames.get(i))) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  /** Returns true if {@code certificate} matches {@code hostname}. */
-  private boolean verifyHostname(String hostname, X509Certificate certificate) {
-    hostname = hostname.toLowerCase(Locale.US);
-    List<String> altNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
-    for (String altName : altNames) {
-      if (verifyHostname(hostname, altName)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  public static List<String> allSubjectAltNames(X509Certificate certificate) {
-    List<String> altIpaNames = getSubjectAltNames(certificate, ALT_IPA_NAME);
-    List<String> altDnsNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
-    List<String> result = new ArrayList<>(altIpaNames.size() + altDnsNames.size());
-    result.addAll(altIpaNames);
-    result.addAll(altDnsNames);
-    return result;
-  }
-
-  private static List<String> getSubjectAltNames(X509Certificate certificate, int type) {
-    List<String> result = new ArrayList<>();
-    try {
-      Collection<?> subjectAltNames = certificate.getSubjectAlternativeNames();
-      if (subjectAltNames == null) {
-        return Collections.emptyList();
-      }
-      for (Object subjectAltName : subjectAltNames) {
-        List<?> entry = (List<?>) subjectAltName;
-        if (entry == null || entry.size() < 2) {
-          continue;
-        }
-        Integer altNameType = (Integer) entry.get(0);
-        if (altNameType == null) {
-          continue;
-        }
-        if (altNameType == type) {
-          String altName = (String) entry.get(1);
-          if (altName != null) {
-            result.add(altName);
-          }
-        }
-      }
-      return result;
-    } catch (CertificateParsingException e) {
-      return Collections.emptyList();
-    }
-  }
-
-  /**
-   * Returns {@code true} iff {@code hostname} matches the domain name {@code pattern}.
-   *
-   * @param hostname lower-case host name.
-   * @param pattern domain name pattern from certificate. May be a wildcard pattern such as {@code
-   * *.android.com}.
-   */
-  public boolean verifyHostname(String hostname, String pattern) {
-    // Basic sanity checks
-    // Check length == 0 instead of .isEmpty() to support Java 5.
-    if ((hostname == null) || (hostname.length() == 0) || (hostname.startsWith("."))
-        || (hostname.endsWith(".."))) {
-      // Invalid domain name
-      return false;
-    }
-    if ((pattern == null) || (pattern.length() == 0) || (pattern.startsWith("."))
-        || (pattern.endsWith(".."))) {
-      // Invalid pattern/domain name
-      return false;
-    }
-
-    // Normalize hostname and pattern by turning them into absolute domain names if they are not
-    // yet absolute. This is needed because server certificates do not normally contain absolute
-    // names or patterns, but they should be treated as absolute. At the same time, any hostname
-    // presented to this method should also be treated as absolute for the purposes of matching
-    // to the server certificate.
-    //   www.android.com  matches www.android.com
-    //   www.android.com  matches www.android.com.
-    //   www.android.com. matches www.android.com.
-    //   www.android.com. matches www.android.com
-    if (!hostname.endsWith(".")) {
-      hostname += '.';
-    }
-    if (!pattern.endsWith(".")) {
-      pattern += '.';
-    }
-    // hostname and pattern are now absolute domain names.
-
-    pattern = pattern.toLowerCase(Locale.US);
-    // hostname and pattern are now in lower case -- domain names are case-insensitive.
-
-    if (!pattern.contains("*")) {
-      // Not a wildcard pattern -- hostname and pattern must match exactly.
-      return hostname.equals(pattern);
-    }
-    // Wildcard pattern
-
-    // WILDCARD PATTERN RULES:
-    // 1. Asterisk (*) is only permitted in the left-most domain name label and must be the
-    //    only character in that label (i.e., must match the whole left-most label).
-    //    For example, *.example.com is permitted, while *a.example.com, a*.example.com,
-    //    a*b.example.com, a.*.example.com are not permitted.
-    // 2. Asterisk (*) cannot match across domain name labels.
-    //    For example, *.example.com matches test.example.com but does not match
-    //    sub.test.example.com.
-    // 3. Wildcard patterns for single-label domain names are not permitted.
-
-    if ((!pattern.startsWith("*.")) || (pattern.indexOf('*', 1) != -1)) {
-      // Asterisk (*) is only permitted in the left-most domain name label and must be the only
-      // character in that label
-      return false;
-    }
-
-    // Optimization: check whether hostname is too short to match the pattern. hostName must be at
-    // least as long as the pattern because asterisk must match the whole left-most label and
-    // hostname starts with a non-empty label. Thus, asterisk has to match one or more characters.
-    if (hostname.length() < pattern.length()) {
-      // hostname too short to match the pattern.
-      return false;
-    }
-
-    if ("*.".equals(pattern)) {
-      // Wildcard pattern for single-label domain name -- not permitted.
-      return false;
-    }
-
-    // hostname must end with the region of pattern following the asterisk.
-    String suffix = pattern.substring(1);
-    if (!hostname.endsWith(suffix)) {
-      // hostname does not end with the suffix
-      return false;
-    }
-
-    // Check that asterisk did not match across domain name labels.
-    int suffixStartIndexInHostname = hostname.length() - suffix.length();
-    if ((suffixStartIndexInHostname > 0)
-        && (hostname.lastIndexOf('.', suffixStartIndexInHostname - 1) != -1)) {
-      // Asterisk is matching across domain name labels -- not permitted.
-      return false;
-    }
-
-    // hostname matches pattern
-    return true;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.kt b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.kt
new file mode 100644
index 0000000000..0ca5172837
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.kt
@@ -0,0 +1,182 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3.internal.tls
+
+import okhttp3.internal.Util.verifyAsIpAddress
+import java.security.cert.CertificateParsingException
+import java.security.cert.X509Certificate
+import java.util.Locale
+import javax.net.ssl.HostnameVerifier
+import javax.net.ssl.SSLException
+import javax.net.ssl.SSLSession
+
+/**
+ * A HostnameVerifier consistent with [RFC 2818][rfc_2818].
+ *
+ * [rfc_2818]: http://www.ietf.org/rfc/rfc2818.txt
+ */
+object OkHostnameVerifier : HostnameVerifier {
+  private const val ALT_DNS_NAME = 2
+  private const val ALT_IPA_NAME = 7
+
+  override fun verify(host: String, session: SSLSession): Boolean {
+    return try {
+      verify(host, session.peerCertificates[0] as X509Certificate)
+    } catch (_: SSLException) {
+      false
+    }
+  }
+
+  fun verify(host: String, certificate: X509Certificate): Boolean {
+    return when {
+      verifyAsIpAddress(host) -> verifyIpAddress(host, certificate)
+      else -> verifyHostname(host, certificate)
+    }
+  }
+
+  /** Returns true if `certificate` matches `ipAddress`.  */
+  private fun verifyIpAddress(ipAddress: String, certificate: X509Certificate): Boolean {
+    return getSubjectAltNames(certificate, ALT_IPA_NAME).any {
+      ipAddress.equals(it, ignoreCase = true)
+    }
+  }
+
+  /** Returns true if `certificate` matches `hostname`.  */
+  private fun verifyHostname(hostname: String, certificate: X509Certificate): Boolean {
+    val hostname = hostname.toLowerCase(Locale.US)
+    return getSubjectAltNames(certificate, ALT_DNS_NAME).any {
+      verifyHostname(hostname, it)
+    }
+  }
+
+  /**
+   * Returns true if [hostname] matches the domain name [pattern].
+   *
+   * @param hostname lower-case host name.
+   * @param pattern domain name pattern from certificate. May be a wildcard pattern such as
+   *     `*.android.com`.
+   */
+  fun verifyHostname(hostname: String?, pattern: String?): Boolean {
+    var hostname = hostname
+    var pattern = pattern
+    // Basic sanity checks
+    if (hostname.isNullOrEmpty() ||
+        hostname.startsWith(".") ||
+        hostname.endsWith("..")) {
+      // Invalid domain name
+      return false
+    }
+    if (pattern.isNullOrEmpty() ||
+        pattern.startsWith(".") ||
+        pattern.endsWith("..")) {
+      // Invalid pattern/domain name
+      return false
+    }
+
+    // Normalize hostname and pattern by turning them into absolute domain names if they are not
+    // yet absolute. This is needed because server certificates do not normally contain absolute
+    // names or patterns, but they should be treated as absolute. At the same time, any hostname
+    // presented to this method should also be treated as absolute for the purposes of matching
+    // to the server certificate.
+    //   www.android.com  matches www.android.com
+    //   www.android.com  matches www.android.com.
+    //   www.android.com. matches www.android.com.
+    //   www.android.com. matches www.android.com
+    if (!hostname.endsWith(".")) {
+      hostname += "."
+    }
+    if (!pattern.endsWith(".")) {
+      pattern += "."
+    }
+    // Hostname and pattern are now absolute domain names.
+
+    pattern = pattern.toLowerCase(Locale.US)
+    // Hostname and pattern are now in lower case -- domain names are case-insensitive.
+
+    if ("*" !in pattern) {
+      // Not a wildcard pattern -- hostname and pattern must match exactly.
+      return hostname == pattern
+    }
+
+    // Wildcard pattern
+
+    // WILDCARD PATTERN RULES:
+    // 1. Asterisk (*) is only permitted in the left-most domain name label and must be the
+    //    only character in that label (i.e., must match the whole left-most label).
+    //    For example, *.example.com is permitted, while *a.example.com, a*.example.com,
+    //    a*b.example.com, a.*.example.com are not permitted.
+    // 2. Asterisk (*) cannot match across domain name labels.
+    //    For example, *.example.com matches test.example.com but does not match
+    //    sub.test.example.com.
+    // 3. Wildcard patterns for single-label domain names are not permitted.
+
+    if (!pattern.startsWith("*.") || pattern.indexOf('*', 1) != -1) {
+      // Asterisk (*) is only permitted in the left-most domain name label and must be the only
+      // character in that label
+      return false
+    }
+
+    // Optimization: check whether hostname is too short to match the pattern. hostName must be at
+    // least as long as the pattern because asterisk must match the whole left-most label and
+    // hostname starts with a non-empty label. Thus, asterisk has to match one or more characters.
+    if (hostname.length < pattern.length) {
+      return false // Hostname too short to match the pattern.
+    }
+
+    if ("*." == pattern) {
+      return false // Wildcard pattern for single-label domain name -- not permitted.
+    }
+
+    // Hostname must end with the region of pattern following the asterisk.
+    val suffix = pattern.substring(1)
+    if (!hostname.endsWith(suffix)) {
+      return false // Hostname does not end with the suffix.
+    }
+
+    // Check that asterisk did not match across domain name labels.
+    val suffixStartIndexInHostname = hostname.length - suffix.length
+    if (suffixStartIndexInHostname > 0 &&
+        hostname.lastIndexOf('.', suffixStartIndexInHostname - 1) != -1) {
+      return false // Asterisk is matching across domain name labels -- not permitted.
+    }
+
+    // Hostname matches pattern.
+    return true
+  }
+
+  fun allSubjectAltNames(certificate: X509Certificate): List<String> {
+    val altIpaNames = getSubjectAltNames(certificate, OkHostnameVerifier.ALT_IPA_NAME)
+    val altDnsNames = getSubjectAltNames(certificate, OkHostnameVerifier.ALT_DNS_NAME)
+    return altIpaNames + altDnsNames
+  }
+
+  private fun getSubjectAltNames(certificate: X509Certificate, type: Int): List<String> {
+    try {
+      val subjectAltNames = certificate.subjectAlternativeNames ?: return emptyList()
+      val result = mutableListOf<String>()
+      for (subjectAltName in subjectAltNames) {
+        if (subjectAltName == null || subjectAltName.size < 2) continue
+        if (subjectAltName[0] != type) continue
+        val altName = subjectAltName[1] ?: continue
+        result.add(altName as String)
+      }
+      return result
+    } catch (_: CertificateParsingException) {
+      return emptyList()
+    }
+  }
+}
diff --git a/okhttp/src/main/java-templates/okhttp3/internal/Version.java b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.kt
similarity index 67%
rename from okhttp/src/main/java-templates/okhttp3/internal/Version.java
rename to okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.kt
index fce1c067c0..3586029bb4 100644
--- a/okhttp/src/main/java-templates/okhttp3/internal/Version.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
+ * Copyright (C) 2016 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.tls
 
-public final class Version {
-  public static String userAgent() {
-    return "okhttp/${project.version}";
-  }
+import java.security.cert.X509Certificate
 
-  private Version() {
-  }
+interface TrustRootIndex {
+  /** Returns the trusted CA certificate that signed [cert].  */
+  fun findByIssuerAndSignature(cert: X509Certificate): X509Certificate?
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
index 61a0d27e5e..d056ad67e2 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -39,7 +39,7 @@
 import okhttp3.WebSocketListener;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
-import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.connection.Exchange;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -187,30 +187,25 @@ public void connect(OkHttpClient client) {
         .header("Sec-WebSocket-Version", "13")
         .build();
     call = Internal.instance.newWebSocketCall(client, request);
-    call.timeout().clearTimeout();
     call.enqueue(new Callback() {
       @Override public void onResponse(Call call, Response response) {
-        StreamAllocation streamAllocation = Internal.instance.streamAllocation(call);
-
+        Exchange exchange = Internal.instance.exchange(response);
+        Streams streams;
         try {
-          checkResponse(response);
-        } catch (ProtocolException e) {
+          checkUpgradeSuccess(response, exchange);
+          streams = exchange.newWebSocketStreams();
+        } catch (IOException e) {
+          if (exchange != null) exchange.webSocketUpgradeFailed();
           failWebSocket(e, response);
           closeQuietly(response);
-          streamAllocation.streamFailed(e);
           return;
         }
 
-        // Promote the HTTP streams into web socket streams.
-        streamAllocation.noNewStreams(); // Prevent connection pooling!
-        Streams streams = streamAllocation.connection().newWebSocketStreams(streamAllocation);
-
         // Process all web socket messages.
         try {
           String name = "OkHttp WebSocket " + request.url().redact();
           initReaderAndWriter(name, streams);
           listener.onOpen(RealWebSocket.this, response);
-          streamAllocation.connection().socket().setSoTimeout(0);
           loopReader();
         } catch (Exception e) {
           failWebSocket(e, null);
@@ -223,7 +218,7 @@ public void connect(OkHttpClient client) {
     });
   }
 
-  void checkResponse(Response response) throws ProtocolException {
+  void checkUpgradeSuccess(Response response, @Nullable Exchange exchange) throws IOException {
     if (response.code() != 101) {
       throw new ProtocolException("Expected HTTP 101 response but was '"
           + response.code() + " " + response.message() + "'");
@@ -248,6 +243,10 @@ void checkResponse(Response response) throws ProtocolException {
       throw new ProtocolException("Expected 'Sec-WebSocket-Accept' header value '"
           + acceptExpected + "' but was '" + headerAccept + "'");
     }
+
+    if (exchange == null) {
+      throw new ProtocolException("Web Socket exchange missing: bad interceptor?");
+    }
   }
 
   public void initReaderAndWriter(String name, Streams streams) throws IOException {
diff --git a/okhttp/src/main/resources/okhttp3/internal/publicsuffix/NOTICE b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/NOTICE
new file mode 100644
index 0000000000..94973fde8a
--- /dev/null
+++ b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/NOTICE
@@ -0,0 +1,5 @@
+Note that publicsuffixes.gz is compiled from The Public Suffix List:
+https://publicsuffix.org/list/public_suffix_list.dat
+
+It is subject to the terms of the Mozilla Public License, v. 2.0:
+https://mozilla.org/MPL/2.0/
diff --git a/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz
index 3d9b2c9ccf..795e941ae6 100644
Binary files a/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz and b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz differ
diff --git a/okhttp-tests/src/test/java/okhttp3/AddressTest.java b/okhttp/src/test/java/okhttp3/AddressTest.java
similarity index 86%
rename from okhttp-tests/src/test/java/okhttp3/AddressTest.java
rename to okhttp/src/test/java/okhttp3/AddressTest.java
index 7a1b7f1bd1..9d3bf4165b 100644
--- a/okhttp-tests/src/test/java/okhttp3/AddressTest.java
+++ b/okhttp/src/test/java/okhttp3/AddressTest.java
@@ -22,8 +22,7 @@
 import okhttp3.internal.http.RecordingProxySelector;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class AddressTest {
   private Dns dns = Dns.SYSTEM;
@@ -38,8 +37,8 @@
         authenticator, null, protocols, connectionSpecs, proxySelector);
     Address b = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, proxySelector);
-    assertEquals(a, b);
-    assertEquals(a.hashCode(), b.hashCode());
+    assertThat(b).isEqualTo(a);
+    assertThat(b.hashCode()).isEqualTo(a.hashCode());
   }
 
   @Test public void differentProxySelectorsAreDifferent() throws Exception {
@@ -47,19 +46,20 @@
         authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
     Address b = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
-    assertNotEquals(a, b);
+    assertThat(b).isNotEqualTo(a);
   }
 
   @Test public void addressToString() throws Exception {
     Address address = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, proxySelector);
-    assertEquals("Address{square.com:80, proxySelector=RecordingProxySelector}",
-        address.toString());
+    assertThat(address.toString()).isEqualTo(
+        "Address{square.com:80, proxySelector=RecordingProxySelector}");
   }
 
   @Test public void addressWithProxyToString() throws Exception {
     Address address = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, Proxy.NO_PROXY, protocols, connectionSpecs, proxySelector);
-    assertEquals("Address{square.com:80, proxy=" + Proxy.NO_PROXY + "}", address.toString());
+    assertThat(address.toString()).isEqualTo(
+        "Address{square.com:80, proxy=" + Proxy.NO_PROXY + "}");
   }
 }
diff --git a/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java b/okhttp/src/test/java/okhttp3/AutobahnTester.java
similarity index 98%
rename from okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
rename to okhttp/src/test/java/okhttp3/AutobahnTester.java
index ab7b9c771d..fa9763ce9a 100644
--- a/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
+++ b/okhttp/src/test/java/okhttp3/AutobahnTester.java
@@ -131,7 +131,7 @@ private long getTestCount() throws IOException {
 
   private void updateReports() {
     final CountDownLatch latch = new CountDownLatch(1);
-    newWebSocket("/updateReports?agent=" + Version.userAgent(), new WebSocketListener() {
+    newWebSocket("/updateReports?agent=" + Version.userAgent, new WebSocketListener() {
       @Override public void onClosing(WebSocket webSocket, int code, String reason) {
         webSocket.close(1000, null);
         latch.countDown();
diff --git a/okhttp/src/test/java/okhttp3/CacheControlTest.java b/okhttp/src/test/java/okhttp3/CacheControlTest.java
new file mode 100644
index 0000000000..e0f37e952b
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/CacheControlTest.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.concurrent.TimeUnit;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CacheControlTest {
+  @Test public void emptyBuilderIsEmpty() throws Exception {
+    CacheControl cacheControl = new CacheControl.Builder().build();
+    assertThat(cacheControl.toString()).isEqualTo("");
+    assertThat(cacheControl.noCache()).isFalse();
+    assertThat(cacheControl.noStore()).isFalse();
+    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.isPrivate()).isFalse();
+    assertThat(cacheControl.isPublic()).isFalse();
+    assertThat(cacheControl.mustRevalidate()).isFalse();
+    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.minFreshSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.onlyIfCached()).isFalse();
+    assertThat(cacheControl.mustRevalidate()).isFalse();
+  }
+
+  @Test public void completeBuilder() throws Exception {
+    CacheControl cacheControl = new CacheControl.Builder()
+        .noCache()
+        .noStore()
+        .maxAge(1, TimeUnit.SECONDS)
+        .maxStale(2, TimeUnit.SECONDS)
+        .minFresh(3, TimeUnit.SECONDS)
+        .onlyIfCached()
+        .noTransform()
+        .immutable()
+        .build();
+    assertThat(cacheControl.toString()).isEqualTo(
+        ("no-cache, no-store, max-age=1, max-stale=2, min-fresh=3, only-if-cached, "
+        + "no-transform, immutable"));
+    assertThat(cacheControl.noCache()).isTrue();
+    assertThat(cacheControl.noStore()).isTrue();
+    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(1);
+    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(2);
+    assertThat(cacheControl.minFreshSeconds()).isEqualTo(3);
+    assertThat(cacheControl.onlyIfCached()).isTrue();
+    assertThat(cacheControl.noTransform()).isTrue();
+    assertThat(cacheControl.immutable()).isTrue();
+
+    // These members are accessible to response headers only.
+    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.isPrivate()).isFalse();
+    assertThat(cacheControl.isPublic()).isFalse();
+    assertThat(cacheControl.mustRevalidate()).isFalse();
+  }
+
+  @Test public void parseEmpty() throws Exception {
+    CacheControl cacheControl = CacheControl.parse(
+        new Headers.Builder().set("Cache-Control", "").build());
+    assertThat(cacheControl.toString()).isEqualTo("");
+    assertThat(cacheControl.noCache()).isFalse();
+    assertThat(cacheControl.noStore()).isFalse();
+    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.isPublic()).isFalse();
+    assertThat(cacheControl.mustRevalidate()).isFalse();
+    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.minFreshSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.onlyIfCached()).isFalse();
+    assertThat(cacheControl.mustRevalidate()).isFalse();
+  }
+
+  @Test public void parse() throws Exception {
+    String header = "no-cache, no-store, max-age=1, s-maxage=2, private, public, must-revalidate, "
+        + "max-stale=3, min-fresh=4, only-if-cached, no-transform";
+    CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
+        .set("Cache-Control", header)
+        .build());
+    assertThat(cacheControl.noCache()).isTrue();
+    assertThat(cacheControl.noStore()).isTrue();
+    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(1);
+    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(2);
+    assertThat(cacheControl.isPrivate()).isTrue();
+    assertThat(cacheControl.isPublic()).isTrue();
+    assertThat(cacheControl.mustRevalidate()).isTrue();
+    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(3);
+    assertThat(cacheControl.minFreshSeconds()).isEqualTo(4);
+    assertThat(cacheControl.onlyIfCached()).isTrue();
+    assertThat(cacheControl.noTransform()).isTrue();
+    assertThat(cacheControl.toString()).isEqualTo(header);
+  }
+
+  @Test public void parseIgnoreCacheControlExtensions() throws Exception {
+    // Example from http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.6
+    String header = "private, community=\"UCI\"";
+    CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
+        .set("Cache-Control", header)
+        .build());
+    assertThat(cacheControl.noCache()).isFalse();
+    assertThat(cacheControl.noStore()).isFalse();
+    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.isPrivate()).isTrue();
+    assertThat(cacheControl.isPublic()).isFalse();
+    assertThat(cacheControl.mustRevalidate()).isFalse();
+    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.minFreshSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.onlyIfCached()).isFalse();
+    assertThat(cacheControl.noTransform()).isFalse();
+    assertThat(cacheControl.immutable()).isFalse();
+    assertThat(cacheControl.toString()).isEqualTo(header);
+  }
+
+  @Test public void parseCacheControlAndPragmaAreCombined() {
+    Headers headers =
+        Headers.of("Cache-Control", "max-age=12", "Pragma", "must-revalidate", "Pragma", "public");
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertThat(cacheControl.toString()).isEqualTo("max-age=12, public, must-revalidate");
+  }
+
+  @SuppressWarnings("RedundantStringConstructorCall") // Testing instance equality.
+  @Test public void parseCacheControlHeaderValueIsRetained() {
+    String value = new String("max-age=12");
+    Headers headers = Headers.of("Cache-Control", value);
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertThat(cacheControl.toString()).isSameAs(value);
+  }
+
+  @Test public void parseCacheControlHeaderValueInvalidatedByPragma() {
+    Headers headers = Headers.of(
+        "Cache-Control", "max-age=12",
+        "Pragma", "must-revalidate"
+    );
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertThat(cacheControl.toString()).isEqualTo("max-age=12, must-revalidate");
+  }
+
+  @Test public void parseCacheControlHeaderValueInvalidatedByTwoValues() {
+    Headers headers = Headers.of(
+        "Cache-Control", "max-age=12",
+        "Cache-Control", "must-revalidate"
+    );
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertThat(cacheControl.toString()).isEqualTo("max-age=12, must-revalidate");
+  }
+
+  @Test public void parsePragmaHeaderValueIsNotRetained() {
+    Headers headers = Headers.of("Pragma", "must-revalidate");
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertThat(cacheControl.toString()).isEqualTo("must-revalidate");
+  }
+
+  @Test public void computedHeaderValueIsCached() {
+    CacheControl cacheControl = new CacheControl.Builder()
+        .maxAge(2, TimeUnit.DAYS)
+        .build();
+    assertThat(cacheControl.toString()).isEqualTo("max-age=172800");
+    assertThat(cacheControl.toString()).isSameAs(cacheControl.toString());
+  }
+
+  @Test public void timeDurationTruncatedToMaxValue() throws Exception {
+    CacheControl cacheControl = new CacheControl.Builder()
+        .maxAge(365 * 100, TimeUnit.DAYS) // Longer than Integer.MAX_VALUE seconds.
+        .build();
+    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(Integer.MAX_VALUE);
+  }
+
+  @Test public void secondsMustBeNonNegative() throws Exception {
+    CacheControl.Builder builder = new CacheControl.Builder();
+    try {
+      builder.maxAge(-1, TimeUnit.SECONDS);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void timePrecisionIsTruncatedToSeconds() throws Exception {
+    CacheControl cacheControl = new CacheControl.Builder()
+        .maxAge(4999, TimeUnit.MILLISECONDS)
+        .build();
+    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(4);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp/src/test/java/okhttp3/CacheTest.java
similarity index 78%
rename from okhttp-tests/src/test/java/okhttp3/CacheTest.java
rename to okhttp/src/test/java/okhttp3/CacheTest.java
index c75d5b4163..e39fb55e1a 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ b/okhttp/src/test/java/okhttp3/CacheTest.java
@@ -34,7 +34,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.HostnameVerifier;
-import okhttp3.internal.Internal;
+import okhttp3.internal.InternalKtKt;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.internal.platform.Platform;
 import okhttp3.mockwebserver.MockResponse;
@@ -51,14 +51,11 @@
 import org.junit.Rule;
 import org.junit.Test;
 
-import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.internal.InternalKtKt.cacheGet;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 import static org.junit.Assert.fail;
 
 public final class CacheTest {
@@ -67,6 +64,7 @@
   @Rule public MockWebServer server = new MockWebServer();
   @Rule public MockWebServer server2 = new MockWebServer();
   @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   private final HandshakeCertificates handshakeCertificates = localhost();
   private OkHttpClient client;
@@ -76,7 +74,7 @@
   @Before public void setUp() throws Exception {
     server.setProtocolNegotiationEnabled(false);
     cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-    client = defaultClient().newBuilder()
+    client = clientTestRule.client.newBuilder()
         .cache(cache)
         .cookieJar(new JavaNetCookieJar(cookieManager))
         .build();
@@ -181,17 +179,17 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
         .url(server.url("/"))
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals(expectedResponseCode, response.code());
+    assertThat(response.code()).isEqualTo(expectedResponseCode);
 
     // Exhaust the content stream.
     response.body().string();
 
-    Response cached = cache.get(request);
+    Response cached = cacheGet(cache, request);
     if (shouldPut) {
-      assertNotNull(Integer.toString(responseCode), cached);
+      assertThat(cached).isNotNull();
       cached.body().close();
     } else {
-      assertNull(Integer.toString(responseCode), cached);
+      assertThat(cached).isNull();
     }
     server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
   }
@@ -225,27 +223,27 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Response response1 = client.newCall(request).execute();
 
     BufferedSource in1 = response1.body().source();
-    assertEquals("I love ", in1.readUtf8("I love ".length()));
+    assertThat(in1.readUtf8("I love ".length())).isEqualTo("I love ");
     in1.skip("puppies but hate ".length());
-    assertEquals("spiders", in1.readUtf8("spiders".length()));
-    assertTrue(in1.exhausted());
+    assertThat(in1.readUtf8("spiders".length())).isEqualTo("spiders");
+    assertThat(in1.exhausted()).isTrue();
     in1.close();
-    assertEquals(1, cache.writeSuccessCount());
-    assertEquals(0, cache.writeAbortCount());
+    assertThat(cache.writeSuccessCount()).isEqualTo(1);
+    assertThat(cache.writeAbortCount()).isEqualTo(0);
 
     Response response2 = client.newCall(request).execute();
     BufferedSource in2 = response2.body().source();
-    assertEquals("I love puppies but hate spiders",
-        in2.readUtf8("I love puppies but hate spiders".length()));
-    assertEquals(200, response2.code());
-    assertEquals("Fantastic", response2.message());
+    assertThat(in2.readUtf8("I love puppies but hate spiders".length())).isEqualTo(
+        "I love puppies but hate spiders");
+    assertThat(response2.code()).isEqualTo(200);
+    assertThat(response2.message()).isEqualTo("Fantastic");
 
-    assertTrue(in2.exhausted());
+    assertThat(in2.exhausted()).isTrue();
     in2.close();
-    assertEquals(1, cache.writeSuccessCount());
-    assertEquals(0, cache.writeAbortCount());
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.hitCount());
+    assertThat(cache.writeSuccessCount()).isEqualTo(1);
+    assertThat(cache.writeAbortCount()).isEqualTo(0);
+    assertThat(cache.requestCount()).isEqualTo(2);
+    assertThat(cache.hitCount()).isEqualTo(1);
   }
 
   @Test public void secureResponseCaching() throws IOException {
@@ -264,7 +262,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Request request = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request).execute();
     BufferedSource in = response1.body().source();
-    assertEquals("ABC", in.readUtf8());
+    assertThat(in.readUtf8()).isEqualTo("ABC");
 
     // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
     CipherSuite cipherSuite = response1.handshake().cipherSuite();
@@ -274,17 +272,17 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Principal localPrincipal = response1.handshake().localPrincipal();
 
     Response response2 = client.newCall(request).execute(); // Cached!
-    assertEquals("ABC", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("ABC");
 
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(1, cache.hitCount());
+    assertThat(cache.requestCount()).isEqualTo(2);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(1);
 
-    assertEquals(cipherSuite, response2.handshake().cipherSuite());
-    assertEquals(localCerts, response2.handshake().localCertificates());
-    assertEquals(serverCerts, response2.handshake().peerCertificates());
-    assertEquals(peerPrincipal, response2.handshake().peerPrincipal());
-    assertEquals(localPrincipal, response2.handshake().localPrincipal());
+    assertThat(response2.handshake().cipherSuite()).isEqualTo(cipherSuite);
+    assertThat(response2.handshake().localCertificates()).isEqualTo(localCerts);
+    assertThat(response2.handshake().peerCertificates()).isEqualTo(serverCerts);
+    assertThat(response2.handshake().peerPrincipal()).isEqualTo(peerPrincipal);
+    assertThat(response2.handshake().localPrincipal()).isEqualTo(localPrincipal);
   }
 
   @Test public void responseCachingAndRedirects() throws Exception {
@@ -302,14 +300,15 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
     Request request = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request).execute();
-    assertEquals("ABC", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("ABC");
 
     Response response2 = client.newCall(request).execute(); // Cached!
-    assertEquals("ABC", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("ABC");
 
-    assertEquals(4, cache.requestCount()); // 2 requests + 2 redirects
-    assertEquals(2, cache.networkCount());
-    assertEquals(2, cache.hitCount());
+    // 2 requests + 2 redirects
+    assertThat(cache.requestCount()).isEqualTo(4);
+    assertThat(cache.networkCount()).isEqualTo(2);
+    assertThat(cache.hitCount()).isEqualTo(2);
   }
 
   @Test public void redirectToCachedResult() throws Exception {
@@ -324,25 +323,25 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
     Request request1 = new Request.Builder().url(server.url("/foo")).build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals("ABC", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("ABC");
     RecordedRequest recordedRequest1 = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", recordedRequest1.getRequestLine());
-    assertEquals(0, recordedRequest1.getSequenceNumber());
+    assertThat(recordedRequest1.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(recordedRequest1.getSequenceNumber()).isEqualTo(0);
 
     Request request2 = new Request.Builder().url(server.url("/bar")).build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals("ABC", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("ABC");
     RecordedRequest recordedRequest2 = server.takeRequest();
-    assertEquals("GET /bar HTTP/1.1", recordedRequest2.getRequestLine());
-    assertEquals(1, recordedRequest2.getSequenceNumber());
+    assertThat(recordedRequest2.getRequestLine()).isEqualTo("GET /bar HTTP/1.1");
+    assertThat(recordedRequest2.getSequenceNumber()).isEqualTo(1);
 
     // an unrelated request should reuse the pooled connection
     Request request3 = new Request.Builder().url(server.url("/baz")).build();
     Response response3 = client.newCall(request3).execute();
-    assertEquals("DEF", response3.body().string());
+    assertThat(response3.body().string()).isEqualTo("DEF");
     RecordedRequest recordedRequest3 = server.takeRequest();
-    assertEquals("GET /baz HTTP/1.1", recordedRequest3.getRequestLine());
-    assertEquals(2, recordedRequest3.getSequenceNumber());
+    assertThat(recordedRequest3.getRequestLine()).isEqualTo("GET /baz HTTP/1.1");
+    assertThat(recordedRequest3.getSequenceNumber()).isEqualTo(2);
   }
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
@@ -366,17 +365,19 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .build();
 
     Response response1 = get(server.url("/"));
-    assertEquals("ABC", response1.body().string());
-    assertNotNull(response1.handshake().cipherSuite());
+    assertThat(response1.body().string()).isEqualTo("ABC");
+    assertThat(response1.handshake().cipherSuite()).isNotNull();
 
     // Cached!
     Response response2 = get(server.url("/"));
-    assertEquals("ABC", response2.body().string());
-    assertNotNull(response2.handshake().cipherSuite());
+    assertThat(response2.body().string()).isEqualTo("ABC");
+    assertThat(response2.handshake().cipherSuite()).isNotNull();
 
-    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.hitCount());
-    assertEquals(response1.handshake().cipherSuite(), response2.handshake().cipherSuite());
+    // 2 direct + 2 redirect = 4
+    assertThat(cache.requestCount()).isEqualTo(4);
+    assertThat(cache.hitCount()).isEqualTo(2);
+    assertThat(response2.handshake().cipherSuite()).isEqualTo(
+        response1.handshake().cipherSuite());
   }
 
   /**
@@ -408,14 +409,15 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .build();
 
     Response response1 = get(server.url("/"));
-    assertEquals("ABC", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("ABC");
 
     // Cached!
     Response response2 = get(server.url("/"));
-    assertEquals("ABC", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("ABC");
 
-    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.hitCount());
+    // 2 direct + 2 redirect = 4
+    assertThat(cache.requestCount()).isEqualTo(4);
+    assertThat(cache.hitCount()).isEqualTo(2);
   }
 
   @Test public void foundCachedWithExpiresHeader() throws Exception {
@@ -457,8 +459,8 @@ private void temporaryRedirectCachedWithCachingHeader(
         .setBody("c"));
 
     HttpUrl url = server.url("/");
-    assertEquals("a", get(url).body().string());
-    assertEquals("a", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("a");
+    assertThat(get(url).body().string()).isEqualTo("a");
   }
 
   private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) throws Exception {
@@ -471,8 +473,8 @@ private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) th
         .setBody("b"));
 
     HttpUrl url = server.url("/");
-    assertEquals("a", get(url).body().string());
-    assertEquals("b", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("a");
+    assertThat(get(url).body().string()).isEqualTo("b");
   }
 
   /** https://github.com/square/okhttp/issues/2198 */
@@ -488,11 +490,11 @@ private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) th
 
     Request request1 = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals("ABC", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("ABC");
 
     Request request2 = new Request.Builder().url(server.url("/")).build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals("ABC", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("ABC");
   }
 
   @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
@@ -517,7 +519,7 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
         .setBody("Request #2"));
 
     BufferedSource bodySource = get(server.url("/")).body().source();
-    assertEquals("ABCDE", bodySource.readUtf8Line());
+    assertThat(bodySource.readUtf8Line()).isEqualTo("ABCDE");
     try {
       bodySource.readUtf8(21);
       fail("This implementation silently ignored a truncated HTTP body.");
@@ -526,12 +528,12 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
       bodySource.close();
     }
 
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(0, cache.writeSuccessCount());
+    assertThat(cache.writeAbortCount()).isEqualTo(1);
+    assertThat(cache.writeSuccessCount()).isEqualTo(0);
     Response response = get(server.url("/"));
-    assertEquals("Request #2", response.body().string());
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(1, cache.writeSuccessCount());
+    assertThat(response.body().string()).isEqualTo("Request #2");
+    assertThat(cache.writeAbortCount()).isEqualTo(1);
+    assertThat(cache.writeSuccessCount()).isEqualTo(1);
   }
 
   @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
@@ -557,7 +559,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
 
     Response response1 = get(server.url("/"));
     BufferedSource in = response1.body().source();
-    assertEquals("ABCDE", in.readUtf8(5));
+    assertThat(in.readUtf8(5)).isEqualTo("ABCDE");
     in.close();
     try {
       in.readByte();
@@ -565,12 +567,12 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     } catch (IllegalStateException expected) {
     }
 
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(0, cache.writeSuccessCount());
+    assertThat(cache.writeAbortCount()).isEqualTo(1);
+    assertThat(cache.writeSuccessCount()).isEqualTo(0);
     Response response2 = get(server.url("/"));
-    assertEquals("Request #2", response2.body().string());
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(1, cache.writeSuccessCount());
+    assertThat(response2.body().string()).isEqualTo("Request #2");
+    assertThat(cache.writeAbortCount()).isEqualTo(1);
+    assertThat(cache.writeSuccessCount()).isEqualTo(1);
   }
 
   @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
@@ -585,11 +587,11 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
 
     HttpUrl url = server.url("/");
     Response response1 = get(url);
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
 
     Response response2 = get(url);
-    assertEquals("A", response2.body().string());
-    assertNull(response2.header("Warning"));
+    assertThat(response2.body().string()).isEqualTo("A");
+    assertThat(response2.header("Warning")).isNull();
   }
 
   @Test public void defaultExpirationDateConditionallyCached() throws Exception {
@@ -601,7 +603,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
+        lastModifiedDate);
   }
 
   @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
@@ -614,10 +617,11 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
         .setBody("A"));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
     Response response = get(server.url("/"));
-    assertEquals("A", response.body().string());
-    assertEquals("113 HttpURLConnection \"Heuristic expiration\"", response.header("Warning"));
+    assertThat(response.body().string()).isEqualTo("A");
+    assertThat(response.header("Warning")).isEqualTo(
+        "113 HttpURLConnection \"Heuristic expiration\"");
   }
 
   @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
@@ -629,8 +633,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .setBody("B"));
 
     HttpUrl url = server.url("/").newBuilder().addQueryParameter("foo", "bar").build();
-    assertEquals("A", get(url).body().string());
-    assertEquals("B", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("B");
   }
 
   @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
@@ -638,7 +642,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
+        lastModifiedDate);
   }
 
   @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
@@ -664,7 +669,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Cache-Control: max-age=60"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
+        lastModifiedDate);
   }
 
   @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
@@ -760,14 +766,14 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
         .build();
     Response response1 = client.newCall(request).execute();
     response1.body().close();
-    assertEquals("1", response1.header("X-Response-ID"));
+    assertThat(response1.header("X-Response-ID")).isEqualTo("1");
 
     Response response2 = get(url);
     response2.body().close();
     if (expectCached) {
-      assertEquals("1", response2.header("X-Response-ID"));
+      assertThat(response2.header("X-Response-ID")).isEqualTo("1");
     } else {
-      assertEquals("2", response2.header("X-Response-ID"));
+      assertThat(response2.header("X-Response-ID")).isEqualTo("2");
     }
   }
 
@@ -803,16 +809,16 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
     HttpUrl url = server.url("/");
 
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
 
     Request request = new Request.Builder()
         .url(url)
         .method(requestMethod, requestBodyOrNull(requestMethod))
         .build();
     Response invalidate = client.newCall(request).execute();
-    assertEquals("B", invalidate.body().string());
+    assertThat(invalidate.body().string()).isEqualTo("B");
 
-    assertEquals("C", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("C");
   }
 
   @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
@@ -830,16 +836,16 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
     HttpUrl url = server.url("/");
 
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
 
     Request request = new Request.Builder()
         .url(url)
         .method("POST", requestBodyOrNull("POST"))
         .build();
     Response invalidate = client.newCall(request).execute();
-    assertEquals("B", invalidate.body().string());
+    assertThat(invalidate.body().string()).isEqualTo("B");
 
-    assertEquals("C", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("C");
   }
 
   @Test public void putInvalidatesWithNoContentResponse() throws Exception {
@@ -857,22 +863,22 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
     HttpUrl url = server.url("/");
 
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
 
     Request request = new Request.Builder()
         .url(url)
         .put(RequestBody.create(MediaType.get("text/plain"), "foo"))
         .build();
     Response invalidate = client.newCall(request).execute();
-    assertEquals("", invalidate.body().string());
+    assertThat(invalidate.body().string()).isEqualTo("");
 
-    assertEquals("C", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("C");
   }
 
   @Test public void etag() throws Exception {
     RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
         .addHeader("ETag: v1"));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
+    assertThat(conditionalRequest.getHeader("If-None-Match")).isEqualTo("v1");
   }
 
   /** If both If-Modified-Since and If-None-Match conditions apply, send only If-None-Match. */
@@ -882,8 +888,8 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .addHeader("ETag: v1")
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
+    assertThat(conditionalRequest.getHeader("If-None-Match")).isEqualTo("v1");
+    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isNull();
   }
 
   @Test public void etagAndExpirationDateInTheFuture() throws Exception {
@@ -904,7 +910,8 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("Cache-Control: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
+        lastModifiedDate);
   }
 
   @Test public void pragmaNoCache() throws Exception {
@@ -918,7 +925,8 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("Pragma: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
+        lastModifiedDate);
   }
 
   @Test public void cacheControlNoStore() throws Exception {
@@ -951,9 +959,9 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .header("Range", "bytes=1000-1001")
         .build();
     Response range = client.newCall(request).execute();
-    assertEquals("AA", range.body().string());
+    assertThat(range.body().string()).isEqualTo("AA");
 
-    assertEquals("BB", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("BB");
   }
 
   /**
@@ -976,9 +984,9 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
     HttpUrl url = server.url("/");
 
-    assertEquals("A", get(url).body().string());
-    assertEquals("B", get(url).body().string());
-    assertEquals("B", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("B");
+    assertThat(get(url).body().string()).isEqualTo("B");
   }
 
   @Test public void clientSideNoStore() throws Exception {
@@ -994,13 +1002,13 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .cacheControl(new CacheControl.Builder().noStore().build())
         .build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
 
     Request request2 = new Request.Builder()
         .url(server.url("/"))
         .build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals("B", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("B");
   }
 
   @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
@@ -1027,9 +1035,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     // At least three request/response pairs are required because after the first request is cached
     // a different execution path might be taken. Thus modifications to the cache applied during
     // the second request might not be visible until another request is performed.
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
   }
 
   @Test public void previouslyNotGzippedContentIsNotModifiedAndSpecifiesGzipEncoding() throws Exception {
@@ -1045,9 +1053,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
             .setBody("DEFDEFDEF"));
 
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("DEFDEFDEF", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("DEFDEFDEF");
   }
 
   @Test public void changedGzippedContentIsNotModifiedAndSpecifiesNewEncoding() throws Exception {
@@ -1064,9 +1072,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
             .setBody("DEFDEFDEF"));
 
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("DEFDEFDEF", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("DEFDEFDEF");
   }
 
   @Test public void notModifiedSpecifiesEncoding() throws Exception {
@@ -1081,9 +1089,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("DEFDEFDEF"));
 
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("DEFDEFDEF", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("DEFDEFDEF");
   }
 
   /** https://github.com/square/okhttp/issues/947 */
@@ -1096,14 +1104,12 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("FAIL"));
 
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
   }
 
   @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
-    // Ensure that the (shared) connection pool is in a consistent state.
-    client.connectionPool().evictAll();
-    assertEquals(0, client.connectionPool().idleConnectionCount());
+    TestUtil.ensureAllConnectionsReleased(client);
 
     server.enqueue(new MockResponse()
         .addHeader("ETag: v1")
@@ -1112,9 +1118,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, client.connectionPool().idleConnectionCount());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(1);
   }
 
   @Test public void expiresDateBeforeModifiedDate() throws Exception {
@@ -1132,14 +1138,14 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
 
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Cache-Control", "max-age=30")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
+    assertThat(response.body().string()).isEqualTo("B");
   }
 
   @Test public void requestMinFresh() throws IOException {
@@ -1150,14 +1156,14 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
 
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Cache-Control", "min-fresh=120")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
+    assertThat(response.body().string()).isEqualTo("B");
   }
 
   @Test public void requestMaxStale() throws IOException {
@@ -1168,15 +1174,16 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
 
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Cache-Control", "max-stale=180")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("A", response.body().string());
-    assertEquals("110 HttpURLConnection \"Response is stale\"", response.header("Warning"));
+    assertThat(response.body().string()).isEqualTo("A");
+    assertThat(response.header("Warning")).isEqualTo(
+        "110 HttpURLConnection \"Response is stale\"");
   }
 
   @Test public void requestMaxStaleDirectiveWithNoValue() throws IOException {
@@ -1188,7 +1195,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
 
     // With max-stale, we'll return that stale response.
     Request request = new Request.Builder()
@@ -1196,8 +1203,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .header("Cache-Control", "max-stale")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("A", response.body().string());
-    assertEquals("110 HttpURLConnection \"Response is stale\"", response.header("Warning"));
+    assertThat(response.body().string()).isEqualTo("A");
+    assertThat(response.header("Warning")).isEqualTo(
+        "110 HttpURLConnection \"Response is stale\"");
   }
 
   @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
@@ -1208,14 +1216,14 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
 
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Cache-Control", "max-stale=180")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
+    assertThat(response.body().string()).isEqualTo("B");
   }
 
   @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
@@ -1226,11 +1234,11 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
-    assertTrue(response.body().source().exhausted());
-    assertEquals(504, response.code());
-    assertEquals(1, cache.requestCount());
-    assertEquals(0, cache.networkCount());
-    assertEquals(0, cache.hitCount());
+    assertThat(response.body().source().exhausted()).isTrue();
+    assertThat(response.code()).isEqualTo(504);
+    assertThat(cache.requestCount()).isEqualTo(1);
+    assertThat(cache.networkCount()).isEqualTo(0);
+    assertThat(cache.hitCount()).isEqualTo(0);
   }
 
   @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
@@ -1239,16 +1247,16 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("A", response.body().string());
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(1, cache.hitCount());
+    assertThat(response.body().string()).isEqualTo("A");
+    assertThat(cache.requestCount()).isEqualTo(2);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(1);
   }
 
   @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
@@ -1257,34 +1265,34 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
-    assertTrue(response.body().source().exhausted());
-    assertEquals(504, response.code());
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
+    assertThat(response.body().source().exhausted()).isTrue();
+    assertThat(response.code()).isEqualTo(504);
+    assertThat(cache.requestCount()).isEqualTo(2);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(0);
   }
 
   @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("A"));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
-    assertTrue(response.body().source().exhausted());
-    assertEquals(504, response.code());
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
+    assertThat(response.body().source().exhausted()).isTrue();
+    assertThat(response.code()).isEqualTo(504);
+    assertThat(cache.requestCount()).isEqualTo(2);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(0);
   }
 
   @Test public void requestCacheControlNoCache() throws Exception {
@@ -1297,13 +1305,13 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .setBody("B"));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
     Request request = new Request.Builder()
         .url(url)
         .header("Cache-Control", "no-cache")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
+    assertThat(response.body().string()).isEqualTo("B");
   }
 
   @Test public void requestPragmaNoCache() throws Exception {
@@ -1316,13 +1324,13 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .setBody("B"));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
     Request request = new Request.Builder()
         .url(url)
         .header("Pragma", "no-cache")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
+    assertThat(response.body().string()).isEqualTo("B");
   }
 
   @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
@@ -1332,8 +1340,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
     RecordedRequest request =
         assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
-    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
-    assertNull(request.getHeader("If-None-Match"));
+    assertThat(request.getHeader("If-Modified-Since")).isEqualTo(ifModifiedSinceDate);
+    assertThat(request.getHeader("If-None-Match")).isNull();
   }
 
   @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
@@ -1343,8 +1351,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
         .addHeader("Cache-Control: max-age=0");
     RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
-    assertEquals("v1", request.getHeader("If-None-Match"));
-    assertNull(request.getHeader("If-Modified-Since"));
+    assertThat(request.getHeader("If-None-Match")).isEqualTo("v1");
+    assertThat(request.getHeader("If-Modified-Since")).isNull();
   }
 
   private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
@@ -1354,15 +1362,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
 
     Request request = new Request.Builder()
         .url(url)
         .header(conditionName, conditionValue)
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, response.code());
-    assertEquals("", response.body().string());
+    assertThat(response.code()).isEqualTo(HttpURLConnection.HTTP_NOT_MODIFIED);
+    assertThat(response.body().string()).isEqualTo("");
 
     server.takeRequest(); // seed
     return server.takeRequest();
@@ -1389,16 +1397,16 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
 
     // The first request has no conditions.
     RecordedRequest request1 = server.takeRequest();
-    assertNull(request1.getHeader("If-Modified-Since"));
+    assertThat(request1.getHeader("If-Modified-Since")).isNull();
 
     // The 2nd request uses the server's date format.
     RecordedRequest request2 = server.takeRequest();
-    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
+    assertThat(request2.getHeader("If-Modified-Since")).isEqualTo(lastModifiedString);
   }
 
   @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
@@ -1410,8 +1418,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("If-Modified-Since", formatDate(-24, TimeUnit.HOURS))
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, response.code());
-    assertEquals("", response.body().string());
+    assertThat(response.code()).isEqualTo(HttpURLConnection.HTTP_NOT_MODIFIED);
+    assertThat(response.body().string()).isEqualTo("");
   }
 
   @Test public void authorizationRequestFullyCached() throws Exception {
@@ -1427,8 +1435,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Authorization", "password")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("A", response.body().string());
-    assertEquals("A", get(url).body().string());
+    assertThat(response.body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("A");
   }
 
   @Test public void contentLocationDoesNotPopulateCache() throws Exception {
@@ -1439,8 +1447,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/foo")).body().string());
-    assertEquals("B", get(server.url("/bar")).body().string());
+    assertThat(get(server.url("/foo")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/bar")).body().string()).isEqualTo("B");
   }
 
   @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
@@ -1453,13 +1461,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/a")).body().string());
-    assertEquals("A", get(server.url("/a")).body().string());
-    assertEquals("B", get(server.url("/b")).body().string());
+    assertThat(get(server.url("/a")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/a")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/b")).body().string()).isEqualTo("B");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
   }
 
   @Test public void statisticsConditionalCacheMiss() throws Exception {
@@ -1472,15 +1480,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("C"));
 
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("B", get(server.url("/")).body().string());
-    assertEquals("C", get(server.url("/")).body().string());
-    assertEquals(3, cache.requestCount());
-    assertEquals(3, cache.networkCount());
-    assertEquals(0, cache.hitCount());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(cache.requestCount()).isEqualTo(1);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(0);
+    assertThat(get(server.url("/")).body().string()).isEqualTo("B");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("C");
+    assertThat(cache.requestCount()).isEqualTo(3);
+    assertThat(cache.networkCount()).isEqualTo(3);
+    assertThat(cache.hitCount()).isEqualTo(0);
   }
 
   @Test public void statisticsConditionalCacheHit() throws Exception {
@@ -1493,15 +1501,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(3, cache.requestCount());
-    assertEquals(3, cache.networkCount());
-    assertEquals(2, cache.hitCount());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(cache.requestCount()).isEqualTo(1);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(0);
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(cache.requestCount()).isEqualTo(3);
+    assertThat(cache.networkCount()).isEqualTo(3);
+    assertThat(cache.hitCount()).isEqualTo(2);
   }
 
   @Test public void statisticsFullCacheHit() throws Exception {
@@ -1509,15 +1517,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Cache-Control: max-age=60")
         .setBody("A"));
 
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(3, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(2, cache.hitCount());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(cache.requestCount()).isEqualTo(1);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(0);
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(cache.requestCount()).isEqualTo(3);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(2);
   }
 
   @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
@@ -1534,14 +1542,14 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Accept-Language", "fr-CA")
         .build();
     Response frResponse = client.newCall(frRequest).execute();
-    assertEquals("A", frResponse.body().string());
+    assertThat(frResponse.body().string()).isEqualTo("A");
 
     Request enRequest = new Request.Builder()
         .url(url)
         .header("Accept-Language", "en-US")
         .build();
     Response enResponse = client.newCall(enRequest).execute();
-    assertEquals("B", enResponse.body().string());
+    assertThat(enResponse.body().string()).isEqualTo("B");
   }
 
   @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
@@ -1558,13 +1566,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Accept-Language", "fr-CA")
         .build();
     Response response1 = client.newCall(request).execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
     Request request1 = new Request.Builder()
         .url(url)
         .header("Accept-Language", "fr-CA")
         .build();
     Response response2 = client.newCall(request1).execute();
-    assertEquals("A", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("A");
   }
 
   @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
@@ -1575,8 +1583,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
   }
 
   @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
@@ -1587,12 +1595,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
     Request request = new Request.Builder()
         .url(server.url("/")).header("Foo", "bar")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
+    assertThat(response.body().string()).isEqualTo("B");
   }
 
   @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
@@ -1607,8 +1615,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .url(server.url("/")).header("Foo", "bar")
         .build();
     Response fooresponse = client.newCall(request).execute();
-    assertEquals("A", fooresponse.body().string());
-    assertEquals("B", get(server.url("/")).body().string());
+    assertThat(fooresponse.body().string()).isEqualTo("A");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("B");
   }
 
   @Test public void varyFieldsAreCaseInsensitive() throws Exception {
@@ -1625,13 +1633,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Accept-Language", "fr-CA")
         .build();
     Response response1 = client.newCall(request).execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
     Request request1 = new Request.Builder()
         .url(url)
         .header("accept-language", "fr-CA")
         .build();
     Response response2 = client.newCall(request1).execute();
-    assertEquals("A", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("A");
   }
 
   @Test public void varyMultipleFieldsWithMatch() throws Exception {
@@ -1651,7 +1659,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Accept-Encoding", "identity")
         .build();
     Response response1 = client.newCall(request).execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
     Request request1 = new Request.Builder()
         .url(url)
         .header("Accept-Language", "fr-CA")
@@ -1659,7 +1667,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Accept-Encoding", "identity")
         .build();
     Response response2 = client.newCall(request1).execute();
-    assertEquals("A", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("A");
   }
 
   @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
@@ -1679,7 +1687,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Accept-Encoding", "identity")
         .build();
     Response frResponse = client.newCall(frRequest).execute();
-    assertEquals("A", frResponse.body().string());
+    assertThat(frResponse.body().string()).isEqualTo("A");
     Request enRequest = new Request.Builder()
         .url(url)
         .header("Accept-Language", "en-CA")
@@ -1687,7 +1695,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Accept-Encoding", "identity")
         .build();
     Response enResponse = client.newCall(enRequest).execute();
-    assertEquals("B", enResponse.body().string());
+    assertThat(enResponse.body().string()).isEqualTo("B");
   }
 
   @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
@@ -1705,7 +1713,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Accept-Language", "en-US")
         .build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
 
     Request request2 = new Request.Builder()
         .url(url)
@@ -1713,7 +1721,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Accept-Language", "en-US")
         .build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals("A", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("A");
   }
 
   @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
@@ -1731,7 +1739,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Accept-Language", "en-US")
         .build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
 
     Request request2 = new Request.Builder()
         .url(url)
@@ -1739,7 +1747,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Accept-Language", "en-US")
         .build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals("B", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("B");
   }
 
   @Test public void varyAsterisk() throws Exception {
@@ -1750,8 +1758,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("B", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("B");
   }
 
   @Test public void varyAndHttps() throws Exception {
@@ -1775,14 +1783,14 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Accept-Language", "en-US")
         .build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
 
     Request request2 = new Request.Builder()
         .url(url)
         .header("Accept-Language", "en-US")
         .build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals("A", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("A");
   }
 
   @Test public void cachePlusCookies() throws Exception {
@@ -1801,9 +1809,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
     cookieJar.assertResponseCookies("a=FIRST; path=/");
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
     cookieJar.assertResponseCookies("a=SECOND; path=/");
   }
 
@@ -1818,12 +1826,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     Response response1 = get(server.url("/"));
-    assertEquals("A", response1.body().string());
-    assertEquals("GET, HEAD", response1.header("Allow"));
+    assertThat(response1.body().string()).isEqualTo("A");
+    assertThat(response1.header("Allow")).isEqualTo("GET, HEAD");
 
     Response response2 = get(server.url("/"));
-    assertEquals("A", response2.body().string());
-    assertEquals("GET, HEAD, PUT", response2.header("Allow"));
+    assertThat(response2.body().string()).isEqualTo("A");
+    assertThat(response2.header("Allow")).isEqualTo("GET, HEAD, PUT");
   }
 
   @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
@@ -1837,12 +1845,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     Response response1 = get(server.url("/"));
-    assertEquals("A", response1.body().string());
-    assertEquals("identity", response1.header("Transfer-Encoding"));
+    assertThat(response1.body().string()).isEqualTo("A");
+    assertThat(response1.header("Transfer-Encoding")).isEqualTo("identity");
 
     Response response2 = get(server.url("/"));
-    assertEquals("A", response2.body().string());
-    assertEquals("identity", response2.header("Transfer-Encoding"));
+    assertThat(response2.body().string()).isEqualTo("A");
+    assertThat(response2.header("Transfer-Encoding")).isEqualTo("identity");
   }
 
   @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
@@ -1855,12 +1863,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     Response response1 = get(server.url("/"));
-    assertEquals("A", response1.body().string());
-    assertEquals("199 test danger", response1.header("Warning"));
+    assertThat(response1.body().string()).isEqualTo("A");
+    assertThat(response1.header("Warning")).isEqualTo("199 test danger");
 
     Response response2 = get(server.url("/"));
-    assertEquals("A", response2.body().string());
-    assertNull(response2.header("Warning"));
+    assertThat(response2.body().string()).isEqualTo("A");
+    assertThat(response2.header("Warning")).isNull();
   }
 
   @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
@@ -1873,12 +1881,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     Response response1 = get(server.url("/"));
-    assertEquals("A", response1.body().string());
-    assertEquals("299 test danger", response1.header("Warning"));
+    assertThat(response1.body().string()).isEqualTo("A");
+    assertThat(response1.header("Warning")).isEqualTo("299 test danger");
 
     Response response2 = get(server.url("/"));
-    assertEquals("A", response2.body().string());
-    assertEquals("299 test danger", response2.header("Warning"));
+    assertThat(response2.body().string()).isEqualTo("A");
+    assertThat(response2.header("Warning")).isEqualTo("299 test danger");
   }
 
   @Test public void doNotCachePartialResponse() throws Exception {
@@ -1904,28 +1912,31 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     // A cache miss writes the cache.
     long t0 = System.currentTimeMillis();
     Response response1 = get(server.url("/a"));
-    assertEquals("A", response1.body().string());
-    assertNull(response1.header("Allow"));
-    assertEquals(0, response1.receivedResponseAtMillis() - t0, 250.0);
+    assertThat(response1.body().string()).isEqualTo("A");
+    assertThat(response1.header("Allow")).isNull();
+    assertThat((double) (response1.receivedResponseAtMillis() - t0)).isCloseTo(
+        (double) 0, offset(250.0));
 
     // A conditional cache hit updates the cache.
     Thread.sleep(500); // Make sure t0 and t1 are distinct.
     long t1 = System.currentTimeMillis();
     Response response2 = get(server.url("/a"));
-    assertEquals(HttpURLConnection.HTTP_OK, response2.code());
-    assertEquals("A", response2.body().string());
-    assertEquals("GET, HEAD", response2.header("Allow"));
-    assertEquals(0, response2.receivedResponseAtMillis() - t1, 250.0);
+    assertThat(response2.code()).isEqualTo(HttpURLConnection.HTTP_OK);
+    assertThat(response2.body().string()).isEqualTo("A");
+    assertThat(response2.header("Allow")).isEqualTo("GET, HEAD");
+    assertThat((double) (response2.receivedResponseAtMillis() - t1)).isCloseTo(
+        (double) 0, offset(250.0));
 
     // A full cache hit reads the cache.
     Thread.sleep(500); // Make sure t1 and t2 are distinct.
     long t2 = System.currentTimeMillis();
     Response response3 = get(server.url("/a"));
-    assertEquals("A", response3.body().string());
-    assertEquals("GET, HEAD", response3.header("Allow"));
-    assertEquals(0, response3.receivedResponseAtMillis() - t1, 250.0);
+    assertThat(response3.body().string()).isEqualTo("A");
+    assertThat(response3.header("Allow")).isEqualTo("GET, HEAD");
+    assertThat((double) (response3.receivedResponseAtMillis() - t1)).isCloseTo(
+        (double) 0, offset(250.0));
 
-    assertEquals(2, server.getRequestCount());
+    assertThat(server.getRequestCount()).isEqualTo(2);
   }
 
   @Test public void responseSourceHeaderCached() throws IOException {
@@ -1934,12 +1945,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
     Request request = new Request.Builder()
         .url(server.url("/")).header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("A", response.body().string());
+    assertThat(response.body().string()).isEqualTo("A");
   }
 
   @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
@@ -1952,9 +1963,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
     Response response = get(server.url("/"));
-    assertEquals("B", response.body().string());
+    assertThat(response.body().string()).isEqualTo("B");
   }
 
   @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
@@ -1965,9 +1976,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(304));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
     Response response = get(server.url("/"));
-    assertEquals("A", response.body().string());
+    assertThat(response.body().string()).isEqualTo("A");
   }
 
   @Test public void responseSourceHeaderFetched() throws IOException {
@@ -1975,20 +1986,20 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
 
     Response response = get(server.url("/"));
-    assertEquals("A", response.body().string());
+    assertThat(response.body().string()).isEqualTo("A");
   }
 
   @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
     Headers.Builder headers = new Headers.Builder()
         .add("Cache-Control: max-age=120");
-    Internal.instance.addLenient(headers, ": A");
+    InternalKtKt.addHeaderLenient(headers, ": A");
     server.enqueue(new MockResponse()
         .setHeaders(headers.build())
         .setBody("body"));
 
     Response response = get(server.url("/"));
-    assertEquals("A", response.header(""));
-    assertEquals("body", response.body().string());
+    assertThat(response.header("")).isEqualTo("A");
+    assertThat(response.body().string()).isEqualTo("body");
   }
 
   /**
@@ -2047,9 +2058,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .build();
 
     Response response = get(url);
-    assertEquals(entryBody, response.body().string());
-    assertEquals("3", response.header("Content-Length"));
-    assertEquals("foo", response.header("etag"));
+    assertThat(response.body().string()).isEqualTo(entryBody);
+    assertThat(response.header("Content-Length")).isEqualTo("3");
+    assertThat(response.header("etag")).isEqualTo("foo");
   }
 
   /** Exercise the cache format in OkHttp 2.7 and all earlier releases. */
@@ -2097,8 +2108,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .build();
 
     Response response = get(url);
-    assertEquals(entryBody, response.body().string());
-    assertEquals("3", response.header("Content-Length"));
+    assertThat(response.body().string()).isEqualTo(entryBody);
+    assertThat(response.header("Content-Length")).isEqualTo("3");
   }
 
   /** The TLS version is present in OkHttp 3.0 and beyond. */
@@ -2147,8 +2158,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .build();
 
     Response response = get(url);
-    assertEquals(entryBody, response.body().string());
-    assertEquals("3", response.header("Content-Length"));
+    assertThat(response.body().string()).isEqualTo(entryBody);
+    assertThat(response.header("Content-Length")).isEqualTo("3");
   }
 
   @Test public void testGoldenCacheHttpResponseOkHttp30() throws Exception {
@@ -2184,8 +2195,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .build();
 
     Response response = get(url);
-    assertEquals(entryBody, response.body().string());
-    assertEquals("3", response.header("Content-Length"));
+    assertThat(response.body().string()).isEqualTo(entryBody);
+    assertThat(response.header("Content-Length")).isEqualTo("3");
   }
 
   @Test public void evictAll() throws Exception {
@@ -2196,10 +2207,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("B"));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
     client.cache().evictAll();
-    assertEquals(0, client.cache().size());
-    assertEquals("B", get(url).body().string());
+    assertThat(client.cache().size()).isEqualTo(0);
+    assertThat(get(url).body().string()).isEqualTo("B");
   }
 
   @Test public void networkInterceptorInvokedForConditionalGet() throws Exception {
@@ -2211,7 +2222,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
 
     // Seed the cache.
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
 
     final AtomicReference<String> ifNoneMatch = new AtomicReference<>();
     client = client.newBuilder()
@@ -2222,8 +2233,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .build();
 
     // Confirm the value is cached and intercepted.
-    assertEquals("A", get(url).body().string());
-    assertEquals("v1", ifNoneMatch.get());
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(ifNoneMatch.get()).isEqualTo("v1");
   }
 
   @Test public void networkInterceptorNotInvokedForFullyCached() throws Exception {
@@ -2233,13 +2244,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
 
     // Seed the cache.
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
 
     // Confirm the interceptor isn't exercised.
     client = client.newBuilder()
         .addNetworkInterceptor(chain -> { throw new AssertionError(); })
         .build();
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
   }
 
   @Test public void iterateCache() throws Exception {
@@ -2247,29 +2258,29 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("a"));
     HttpUrl urlA = server.url("/a");
-    assertEquals("a", get(urlA).body().string());
+    assertThat(get(urlA).body().string()).isEqualTo("a");
 
     server.enqueue(new MockResponse()
         .setBody("b"));
     HttpUrl urlB = server.url("/b");
-    assertEquals("b", get(urlB).body().string());
+    assertThat(get(urlB).body().string()).isEqualTo("b");
 
     server.enqueue(new MockResponse()
         .setBody("c"));
     HttpUrl urlC = server.url("/c");
-    assertEquals("c", get(urlC).body().string());
+    assertThat(get(urlC).body().string()).isEqualTo("c");
 
     // Confirm the iterator returns those responses...
     Iterator<String> i = cache.urls();
-    assertTrue(i.hasNext());
-    assertEquals(urlA.toString(), i.next());
-    assertTrue(i.hasNext());
-    assertEquals(urlB.toString(), i.next());
-    assertTrue(i.hasNext());
-    assertEquals(urlC.toString(), i.next());
+    assertThat(i.hasNext()).isTrue();
+    assertThat(i.next()).isEqualTo(urlA.toString());
+    assertThat(i.hasNext()).isTrue();
+    assertThat(i.next()).isEqualTo(urlB.toString());
+    assertThat(i.hasNext()).isTrue();
+    assertThat(i.next()).isEqualTo(urlC.toString());
 
     // ... and nothing else.
-    assertFalse(i.hasNext());
+    assertThat(i.hasNext()).isFalse();
     try {
       i.next();
       fail();
@@ -2283,17 +2294,17 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Cache-Control: max-age=60")
         .setBody("a"));
     HttpUrl url = server.url("/a");
-    assertEquals("a", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("a");
 
     // Remove it with iteration.
     Iterator<String> i = cache.urls();
-    assertEquals(url.toString(), i.next());
+    assertThat(i.next()).isEqualTo(url.toString());
     i.remove();
 
     // Confirm that subsequent requests suffer a cache miss.
     server.enqueue(new MockResponse()
         .setBody("b"));
-    assertEquals("b", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("b");
   }
 
   @Test public void iteratorRemoveWithoutNextThrows() throws Exception {
@@ -2301,10 +2312,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("a"));
     HttpUrl url = server.url("/a");
-    assertEquals("a", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("a");
 
     Iterator<String> i = cache.urls();
-    assertTrue(i.hasNext());
+    assertThat(i.hasNext()).isTrue();
     try {
       i.remove();
       fail();
@@ -2317,10 +2328,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("a"));
     HttpUrl url = server.url("/a");
-    assertEquals("a", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("a");
 
     Iterator<String> i = cache.urls();
-    assertEquals(url.toString(), i.next());
+    assertThat(i.next()).isEqualTo(url.toString());
     i.remove();
 
     // Too many calls to remove().
@@ -2336,15 +2347,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("a"));
     HttpUrl url = server.url("/a");
-    assertEquals("a", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("a");
 
     // The URL will remain available if hasNext() returned true...
     Iterator<String> i = cache.urls();
-    assertTrue(i.hasNext());
+    assertThat(i.hasNext()).isTrue();
 
     // ...so even when we evict the element, we still get something back.
     cache.evictAll();
-    assertEquals(url.toString(), i.next());
+    assertThat(i.next()).isEqualTo(url.toString());
 
     // Remove does nothing. But most importantly, it doesn't throw!
     i.remove();
@@ -2355,13 +2366,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("a"));
     HttpUrl url = server.url("/a");
-    assertEquals("a", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("a");
 
     Iterator<String> i = cache.urls();
     cache.evictAll();
 
     // The URL was evicted before hasNext() made any promises.
-    assertFalse(i.hasNext());
+    assertThat(i.hasNext()).isFalse();
     try {
       i.next();
       fail();
@@ -2383,15 +2394,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    assertEquals("A", get(url).body().string());
-    assertEquals("B", get(url).body().string());
-    assertEquals("B", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("B");
+    assertThat(get(url).body().string()).isEqualTo("B");
 
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
-    assertEquals("v2", server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v2");
   }
 
   @Test public void combinedCacheHeadersCanBeNonAscii() throws Exception {
@@ -2408,16 +2419,16 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     Response response1 = get(server.url("/"));
-    assertEquals("", response1.header("Alpha"));
-    assertEquals("Beta", response1.header(""));
-    assertEquals("abcd", response1.body().string());
+    assertThat(response1.header("Alpha")).isEqualTo("");
+    assertThat(response1.header("")).isEqualTo("Beta");
+    assertThat(response1.body().string()).isEqualTo("abcd");
 
     Response response2 = get(server.url("/"));
-    assertEquals("", response2.header("Alpha"));
-    assertEquals("Beta", response2.header(""));
-    assertEquals("", response2.header("Gamma"));
-    assertEquals("Delta", response2.header(""));
-    assertEquals("abcd", response2.body().string());
+    assertThat(response2.header("Alpha")).isEqualTo("");
+    assertThat(response2.header("")).isEqualTo("Beta");
+    assertThat(response2.header("Gamma")).isEqualTo("");
+    assertThat(response2.header("")).isEqualTo("Delta");
+    assertThat(response2.body().string()).isEqualTo("abcd");
   }
 
   @Test public void etagConditionCanBeNonAscii() throws Exception {
@@ -2429,13 +2440,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     Response response1 = get(server.url("/"));
-    assertEquals("abcd", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("abcd");
 
     Response response2 = get(server.url("/"));
-    assertEquals("abcd", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("abcd");
 
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
-    assertEquals("", server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("");
   }
 
   private Response get(HttpUrl url) throws IOException {
@@ -2471,8 +2482,8 @@ private void assertNotCached(MockResponse response) throws Exception {
         .setBody("B"));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    assertEquals("B", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("B");
   }
 
   /** @return the request with the conditional get headers. */
@@ -2491,23 +2502,23 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
 
     HttpUrl valid = server.url("/valid");
     Response response1 = get(valid);
-    assertEquals("A", response1.body().string());
-    assertEquals(HttpURLConnection.HTTP_OK, response1.code());
-    assertEquals("A-OK", response1.message());
+    assertThat(response1.body().string()).isEqualTo("A");
+    assertThat(response1.code()).isEqualTo(HttpURLConnection.HTTP_OK);
+    assertThat(response1.message()).isEqualTo("A-OK");
     Response response2 = get(valid);
-    assertEquals("A", response2.body().string());
-    assertEquals(HttpURLConnection.HTTP_OK, response2.code());
-    assertEquals("A-OK", response2.message());
+    assertThat(response2.body().string()).isEqualTo("A");
+    assertThat(response2.code()).isEqualTo(HttpURLConnection.HTTP_OK);
+    assertThat(response2.message()).isEqualTo("A-OK");
 
     HttpUrl invalid = server.url("/invalid");
     Response response3 = get(invalid);
-    assertEquals("B", response3.body().string());
-    assertEquals(HttpURLConnection.HTTP_OK, response3.code());
-    assertEquals("B-OK", response3.message());
+    assertThat(response3.body().string()).isEqualTo("B");
+    assertThat(response3.code()).isEqualTo(HttpURLConnection.HTTP_OK);
+    assertThat(response3.message()).isEqualTo("B-OK");
     Response response4 = get(invalid);
-    assertEquals("C", response4.body().string());
-    assertEquals(HttpURLConnection.HTTP_OK, response4.code());
-    assertEquals("C-OK", response4.message());
+    assertThat(response4.body().string()).isEqualTo("C");
+    assertThat(response4.code()).isEqualTo(HttpURLConnection.HTTP_OK);
+    assertThat(response4.message()).isEqualTo("C-OK");
 
     server.takeRequest(); // regular get
     return server.takeRequest(); // conditional get
@@ -2521,8 +2532,8 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
         .setBody("B"));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("A");
   }
 
   @Test public void immutableIsCachedAfterMultipleCalls() throws Exception {
@@ -2535,9 +2546,9 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
         .setBody("C"));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    assertEquals("B", get(url).body().string());
-    assertEquals("B", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("B");
+    assertThat(get(url).body().string()).isEqualTo("B");
   }
 
   @Test public void immutableIsNotCachedBeyondFreshnessLifetime() throws Exception {
@@ -2550,7 +2561,8 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
         .addHeader("Cache-Control: immutable")
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
+        lastModifiedDate);
   }
 
   private void assertFullyCached(MockResponse response) throws Exception {
@@ -2558,8 +2570,8 @@ private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("B"));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("A");
   }
 
   /**
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp/src/test/java/okhttp3/CallTest.java
similarity index 78%
rename from okhttp-tests/src/test/java/okhttp3/CallTest.java
rename to okhttp/src/test/java/okhttp3/CallTest.java
index 88135fab44..0463d461f6 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp/src/test/java/okhttp3/CallTest.java
@@ -56,15 +56,19 @@
 import javax.net.ssl.SSLProtocolException;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.RecordingEventListener.CallEnd;
+import okhttp3.RecordingEventListener.ConnectionAcquired;
+import okhttp3.RecordingEventListener.ConnectionReleased;
+import okhttp3.RecordingEventListener.ResponseFailed;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.Util;
 import okhttp3.internal.Version;
 import okhttp3.internal.http.RecordingProxySelector;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.QueueDispatcher;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
 import okhttp3.tls.HandshakeCertificates;
@@ -72,6 +76,7 @@
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
+import okio.ForwardingSource;
 import okio.GzipSink;
 import okio.Okio;
 import org.junit.After;
@@ -83,27 +88,31 @@
 import org.junit.rules.Timeout;
 
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static java.util.Arrays.asList;
 import static okhttp3.CipherSuite.TLS_DH_anon_WITH_AES_128_GCM_SHA256;
 import static okhttp3.TestUtil.awaitGarbageCollection;
-import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.internal.InternalKtKt.addHeaderLenient;
+import static okhttp3.internal.platform.PlatformTest.getJvmSpecVersion;
 import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeFalse;
 
 public final class CallTest {
+  @Rule public final PlatformRule platform = new PlatformRule();
   @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
   @Rule public final MockWebServer server = new MockWebServer();
   @Rule public final MockWebServer server2 = new MockWebServer();
   @Rule public final InMemoryFileSystem fileSystem = new InMemoryFileSystem();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
+  private RecordingEventListener listener = new RecordingEventListener();
   private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client = defaultClient();
+  private OkHttpClient client = clientTestRule.client.newBuilder()
+      .eventListener(listener)
+      .build();
   private RecordingCallback callback = new RecordingCallback();
   private TestLogHandler logHandler = new TestLogHandler();
   private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
@@ -116,10 +125,6 @@
   @After public void tearDown() throws Exception {
     cache.delete();
     logger.removeHandler(logHandler);
-
-    // Ensure the test has released all connections.
-    client.connectionPool().evictAll();
-    assertEquals(0, client.connectionPool().connectionCount());
   }
 
   @Test public void get() throws Exception {
@@ -144,10 +149,10 @@
         .assertReceivedResponseAtMillis(sentAt, receivedAt);
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("GET", recordedRequest.getMethod());
-    assertEquals("SyncApiTest", recordedRequest.getHeader("User-Agent"));
-    assertEquals(0, recordedRequest.getBody().size());
-    assertNull(recordedRequest.getHeader("Content-Length"));
+    assertThat(recordedRequest.getMethod()).isEqualTo("GET");
+    assertThat(recordedRequest.getHeader("User-Agent")).isEqualTo("SyncApiTest");
+    assertThat(recordedRequest.getBody().size()).isEqualTo(0);
+    assertThat(recordedRequest.getHeader("Content-Length")).isNull();
   }
 
   @Test public void buildRequestUsingHttpUrl() throws Exception {
@@ -161,7 +166,8 @@
       requestBuilder.url("ftp://hostname/path");
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("Expected URL scheme 'http' or 'https' but was 'ftp'", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "Expected URL scheme 'http' or 'https' but was 'ftp'");
     }
   }
 
@@ -171,7 +177,7 @@
       requestBuilder.url("http://localhost:65536/");
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("Invalid URL port: \"65536\"", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("Invalid URL port: \"65536\"");
     }
   }
 
@@ -202,7 +208,7 @@
         .assertHeader("B", "123", "234");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(Arrays.asList("345", "456"), recordedRequest.getHeaders().values("A"));
+    assertThat(recordedRequest.getHeaders().values("A")).containsExactly("345", "456");
   }
 
   @Test public void repeatedHeaderNames_HTTP_2() throws Exception {
@@ -234,10 +240,10 @@
         .assertHeader("Content-Type", "text/plain");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("HEAD", recordedRequest.getMethod());
-    assertEquals("SyncApiTest", recordedRequest.getHeader("User-Agent"));
-    assertEquals(0, recordedRequest.getBody().size());
-    assertNull(recordedRequest.getHeader("Content-Length"));
+    assertThat(recordedRequest.getMethod()).isEqualTo("HEAD");
+    assertThat(recordedRequest.getHeader("User-Agent")).isEqualTo("SyncApiTest");
+    assertThat(recordedRequest.getBody().size()).isEqualTo(0);
+    assertThat(recordedRequest.getHeader("Content-Length")).isNull();
   }
 
   @Test public void headResponseContentLengthIsIgnored() throws Exception {
@@ -252,7 +258,7 @@
         .head()
         .build();
     Response response = client.newCall(headRequest).execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     assertArrayEquals(new byte[0], response.body().bytes());
 
     Request getRequest = new Request.Builder()
@@ -262,8 +268,8 @@
         .assertCode(200)
         .assertBody("abc");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void headResponseContentEncodingIsIgnored() throws Exception {
@@ -289,8 +295,8 @@
         .assertCode(200)
         .assertBody("abc");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void head_HTTPS() throws Exception {
@@ -316,10 +322,11 @@
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("POST", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getBody().readUtf8());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+    assertThat(recordedRequest.getMethod()).isEqualTo("POST");
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
+    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
+    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
+        "text/plain; charset=utf-8");
   }
 
   @Test public void post_HTTPS() throws Exception {
@@ -345,10 +352,10 @@
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("POST", recordedRequest.getMethod());
-    assertEquals(0, recordedRequest.getBody().size());
-    assertEquals("0", recordedRequest.getHeader("Content-Length"));
-    assertNull(recordedRequest.getHeader("Content-Type"));
+    assertThat(recordedRequest.getMethod()).isEqualTo("POST");
+    assertThat(recordedRequest.getBody().size()).isEqualTo(0);
+    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("0");
+    assertThat(recordedRequest.getHeader("Content-Type")).isNull();
   }
 
   @Test public void postZerolength_HTTPS() throws Exception {
@@ -405,18 +412,18 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
 
     Response response = client.newCall(request).execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     RecordedRequest recordedRequest1 = server.takeRequest();
-    assertEquals("POST", recordedRequest1.getMethod());
-    assertEquals(body, recordedRequest1.getBody().readUtf8());
-    assertNull(recordedRequest1.getHeader("Authorization"));
+    assertThat(recordedRequest1.getMethod()).isEqualTo("POST");
+    assertThat(recordedRequest1.getBody().readUtf8()).isEqualTo(body);
+    assertThat(recordedRequest1.getHeader("Authorization")).isNull();
 
     RecordedRequest recordedRequest2 = server.takeRequest();
-    assertEquals("POST", recordedRequest2.getMethod());
-    assertEquals(body, recordedRequest2.getBody().readUtf8());
-    assertEquals(credential, recordedRequest2.getHeader("Authorization"));
+    assertThat(recordedRequest2.getMethod()).isEqualTo("POST");
+    assertThat(recordedRequest2.getBody().readUtf8()).isEqualTo(body);
+    assertThat(recordedRequest2.getHeader("Authorization")).isEqualTo(credential);
   }
 
   @Test public void attemptAuthorization20Times() throws Exception {
@@ -449,7 +456,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
       fail();
     } catch (IOException expected) {
-      assertEquals("Too many follow-up requests: 21", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("Too many follow-up requests: 21");
     }
   }
 
@@ -472,7 +479,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously("/")
         .assertCode(401);
 
-    assertNotNull(authenticator.onlyRoute());
+    assertThat(authenticator.onlyRoute()).isNotNull();
   }
 
   @Test public void delete() throws Exception {
@@ -488,10 +495,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("DELETE", recordedRequest.getMethod());
-    assertEquals(0, recordedRequest.getBody().size());
-    assertEquals("0", recordedRequest.getHeader("Content-Length"));
-    assertNull(recordedRequest.getHeader("Content-Type"));
+    assertThat(recordedRequest.getMethod()).isEqualTo("DELETE");
+    assertThat(recordedRequest.getBody().size()).isEqualTo(0);
+    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("0");
+    assertThat(recordedRequest.getHeader("Content-Type")).isNull();
   }
 
   @Test public void delete_HTTPS() throws Exception {
@@ -517,8 +524,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("DELETE", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getBody().readUtf8());
+    assertThat(recordedRequest.getMethod()).isEqualTo("DELETE");
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
   }
 
   @Test public void put() throws Exception {
@@ -534,10 +541,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("PUT", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getBody().readUtf8());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+    assertThat(recordedRequest.getMethod()).isEqualTo("PUT");
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
+    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
+    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
+        "text/plain; charset=utf-8");
   }
 
   @Test public void put_HTTPS() throws Exception {
@@ -563,10 +571,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("PATCH", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getBody().readUtf8());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+    assertThat(recordedRequest.getMethod()).isEqualTo("PATCH");
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
+    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
+    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
+        "text/plain; charset=utf-8");
   }
 
   @Test public void patch_HTTP_2() throws Exception {
@@ -592,10 +601,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("CUSTOM", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getBody().readUtf8());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+    assertThat(recordedRequest.getMethod()).isEqualTo("CUSTOM");
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
+    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
+    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
+        "text/plain; charset=utf-8");
   }
 
   @Test public void unspecifiedRequestBodyContentTypeDoesNotGetDefault() throws Exception {
@@ -609,9 +619,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously(request).assertCode(200);
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertNull(recordedRequest.getHeader("Content-Type"));
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("abc", recordedRequest.getBody().readUtf8());
+    assertThat(recordedRequest.getHeader("Content-Type")).isNull();
+    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("abc");
   }
 
   @Test public void illegalToExecuteTwice() throws Exception {
@@ -632,17 +642,17 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       call.execute();
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Already Executed", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Already Executed");
     }
 
     try {
       call.enqueue(callback);
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Already Executed", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Already Executed");
     }
 
-    assertEquals("SyncApiTest", server.takeRequest().getHeader("User-Agent"));
+    assertThat(server.takeRequest().getHeader("User-Agent")).isEqualTo("SyncApiTest");
   }
 
   @Test public void illegalToExecuteTwice_Async() throws Exception {
@@ -662,17 +672,17 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       call.execute();
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Already Executed", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Already Executed");
     }
 
     try {
       call.enqueue(callback);
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Already Executed", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Already Executed");
     }
 
-    assertEquals("SyncApiTest", server.takeRequest().getHeader("User-Agent"));
+    assertThat(server.takeRequest().getHeader("User-Agent")).isEqualTo("SyncApiTest");
 
     callback.await(request.url()).assertSuccessful();
   }
@@ -691,8 +701,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     Call cloned = call.clone();
     Response response2 = cloned.execute();
 
-    assertEquals(response1.body().string(), "abc");
-    assertEquals(response2.body().string(), "def");
+    assertThat("abc").isEqualTo(response1.body().string());
+    assertThat("def").isEqualTo(response2.body().string());
   }
 
   @Test public void legalToExecuteTwiceCloning_Async() throws Exception {
@@ -716,8 +726,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     bodies.add(firstResponse.getBody());
     bodies.add(secondResponse.getBody());
 
-    assertTrue(bodies.contains("abc"));
-    assertTrue(bodies.contains("def"));
+    assertThat(bodies).contains("abc");
+    assertThat(bodies).contains("def");
   }
 
   @Test public void get_Async() throws Exception {
@@ -736,7 +746,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertHeader("Content-Type", "text/plain")
         .assertBody("abc");
 
-    assertEquals("AsyncApiTest", server.takeRequest().getHeader("User-Agent"));
+    assertThat(server.takeRequest().getHeader("User-Agent")).isEqualTo("AsyncApiTest");
   }
 
   @Test public void exceptionThrownByOnResponseIsRedactedAndLogged() throws Exception {
@@ -756,8 +766,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       }
     });
 
-    assertEquals("INFO: Callback failure for call to " + server.url("/") + "...",
-        logHandler.take());
+    assertThat(logHandler.take()).isEqualTo(
+        ("INFO: Callback failure for call to " + server.url("/") + "..."));
   }
 
   @Test public void connectionPooling() throws Exception {
@@ -769,9 +779,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously("/b").assertBody("def");
     executeSynchronously("/c").assertBody("ghi");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
   }
 
   @Test public void connectionPooling_Async() throws Exception {
@@ -788,9 +798,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client.newCall(new Request.Builder().url(server.url("/c")).build()).enqueue(callback);
     callback.await(server.url("/c")).assertBody("ghi");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
   }
 
   @Test public void connectionReuseWhenResponseBodyConsumed_Async() throws Exception {
@@ -805,9 +815,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
       @Override public void onResponse(Call call, Response response) throws IOException {
         InputStream bytes = response.body().byteStream();
-        assertEquals('a', bytes.read());
-        assertEquals('b', bytes.read());
-        assertEquals('c', bytes.read());
+        assertThat(bytes.read()).isEqualTo('a');
+        assertThat(bytes.read()).isEqualTo('b');
+        assertThat(bytes.read()).isEqualTo('c');
 
         // This request will share a connection with 'A' cause it's all done.
         client.newCall(new Request.Builder().url(server.url("/b")).build()).enqueue(callback);
@@ -815,8 +825,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     });
 
     callback.await(server.url("/b")).assertCode(200).assertBody("def");
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reuse!
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Connection reuse!
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void timeoutsUpdatedOnReusedConnections() throws Exception {
@@ -836,7 +848,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     Request request = new Request.Builder().url(server.url("/b")).build();
     Response response = client.newCall(request).execute();
     BufferedSource bodySource = response.body().source();
-    assertEquals('d', bodySource.readByte());
+    assertThat(bodySource.readByte()).isEqualTo((byte) 'd');
 
     // The second byte of this request will be delayed by 750ms so we should time out after 250ms.
     long startNanos = System.nanoTime();
@@ -847,7 +859,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       // Timed out as expected.
       long elapsedNanos = System.nanoTime() - startNanos;
       long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(elapsedNanos);
-      assertTrue(Util.format("Timed out: %sms", elapsedMillis), elapsedMillis < 500);
+      assertThat(elapsedMillis).isLessThan(500);
     } finally {
       bodySource.close();
     }
@@ -898,6 +910,61 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertBody("success!");
   }
 
+  /** https://github.com/square/okhttp/issues/4875 */
+  @Test public void interceptorRecoversWhenRoutesExhausted() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            try {
+              chain.proceed(chain.request());
+              throw new AssertionError();
+            } catch (IOException expected) {
+              return chain.proceed(chain.request());
+            }
+          }
+        })
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    executeSynchronously(request)
+        .assertCode(200);
+  }
+
+  /** https://github.com/square/okhttp/issues/4761 */
+  @Test public void interceptorCallsProceedWithoutClosingPriorResponse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            Response response = chain.proceed(chain.request());
+            try {
+              chain.proceed(chain.request());
+              fail();
+            } catch (IllegalStateException expected) {
+              assertThat(expected).hasMessageContaining("please call response.close()");
+            }
+            return response;
+          }
+        })
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+  }
+
   /**
    * Make a request with two routes. The first route will fail because the null server connects but
    * never responds. The manual retry will succeed.
@@ -927,13 +994,13 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
   /** https://github.com/square/okhttp/issues/1801 */
   @Test public void asyncCallEngineInitialized() throws Exception {
-    OkHttpClient c = defaultClient().newBuilder()
+    OkHttpClient c = clientTestRule.client.newBuilder()
         .addInterceptor(chain -> { throw new IOException(); })
         .build();
     Request request = new Request.Builder().url(server.url("/")).build();
     c.newCall(request).enqueue(callback);
     RecordedResponse response = callback.await(request.url());
-    assertEquals(request, response.request);
+    assertThat(response.request).isEqualTo(request);
   }
 
   @Test public void reusedSinksGetIndependentTimeoutInstances() throws Exception {
@@ -956,7 +1023,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .method("POST", requestBody1)
         .build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals(200, response1.code());
+    assertThat(response1.code()).isEqualTo(200);
 
     // Call 2: check for the absence of a deadline on the request body.
     RequestBody requestBody2 = new RequestBody() {
@@ -965,7 +1032,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
-        assertFalse(sink.timeout().hasDeadline());
+        assertThat(sink.timeout().hasDeadline()).isFalse();
         sink.writeUtf8("def");
       }
     };
@@ -974,11 +1041,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .method("POST", requestBody2)
         .build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals(200, response2.code());
+    assertThat(response2.code()).isEqualTo(200);
 
     // Use sequence numbers to confirm the connection was pooled.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void reusedSourcesGetIndependentTimeoutInstances() throws Exception {
@@ -989,19 +1056,19 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     Request request1 = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request1).execute();
     BufferedSource body1 = response1.body().source();
-    assertEquals("abc", body1.readUtf8());
+    assertThat(body1.readUtf8()).isEqualTo("abc");
     body1.timeout().deadline(5, TimeUnit.SECONDS);
 
     // Call 2: check for the absence of a deadline on the request body.
     Request request2 = new Request.Builder().url(server.url("/")).build();
     Response response2 = client.newCall(request2).execute();
     BufferedSource body2 = response2.body().source();
-    assertEquals("def", body2.readUtf8());
-    assertFalse(body2.timeout().hasDeadline());
+    assertThat(body2.readUtf8()).isEqualTo("def");
+    assertThat(body2.timeout().hasDeadline()).isFalse();
 
     // Use sequence numbers to confirm the connection was pooled.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void tls() throws Exception {
@@ -1028,17 +1095,48 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void recoverWhenRetryOnConnectionFailureIsTrue() throws Exception {
-    server.enqueue(new MockResponse().setBody("seed connection pool"));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse().setBody("retry success"));
+    // Set to 2 because the seeding request will count down before the retried request does.
+    CountDownLatch requestFinished = new CountDownLatch(2);
+
+    QueueDispatcher dispatcher = new QueueDispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        if (peek().getSocketPolicy() == SocketPolicy.DISCONNECT_AFTER_REQUEST) {
+          requestFinished.await();
+        }
+        return super.dispatch(request);
+      }
+    };
+    dispatcher.enqueueResponse(new MockResponse().setBody("seed connection pool"));
+    dispatcher.enqueueResponse(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    dispatcher.enqueueResponse(new MockResponse().setBody("retry success"));
+    server.setDispatcher(dispatcher);
+
+    listener = new RecordingEventListener() {
+      @Override public void responseHeadersStart(Call call) {
+        requestFinished.countDown();
+        super.responseHeadersStart(call);
+      }
+    };
 
     client = client.newBuilder()
         .dns(new DoubleInetAddressDns())
+        .eventListener(listener)
         .build();
-    assertTrue(client.retryOnConnectionFailure());
+    assertThat(client.retryOnConnectionFailure()).isTrue();
 
     executeSynchronously("/").assertBody("seed connection pool");
     executeSynchronously("/").assertBody("retry success");
+
+    // The call that seeds the connection pool.
+    listener.removeUpToEvent(CallEnd.class);
+
+    // The ResponseFailed event is not necessarily fatal!
+    listener.removeUpToEvent(ConnectionAcquired.class);
+    listener.removeUpToEvent(ResponseFailed.class);
+    listener.removeUpToEvent(ConnectionReleased.class);
+    listener.removeUpToEvent(ConnectionAcquired.class);
+    listener.removeUpToEvent(ConnectionReleased.class);
+    listener.removeUpToEvent(CallEnd.class);
   }
 
   @Test public void recoverWhenRetryOnConnectionFailureIsTrue_HTTP2() throws Exception {
@@ -1062,8 +1160,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously("/")
         .assertFailure(IOException.class)
         .assertFailureMatches("stream was reset: CANCEL",
-            "unexpected end of stream on Connection.*"
-                + server.getHostName() + ":" + server.getPort() + ".*");
+            "unexpected end of stream on " + server.url("/").redact());
   }
 
   @Test public void recoverWhenRetryOnConnectionFailureIsFalse_HTTP2() throws Exception {
@@ -1081,7 +1178,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
             SSLProtocolException.class, // RI response to the FAIL_HANDSHAKE
             SSLHandshakeException.class // Android's response to the FAIL_HANDSHAKE
     );
-    assertFalse(client.connectionSpecs().contains(ConnectionSpec.COMPATIBLE_TLS));
+    assertThat(client.connectionSpecs()).doesNotContain(ConnectionSpec.COMPATIBLE_TLS);
   }
 
   @Test public void recoverFromTlsHandshakeFailure() throws Exception {
@@ -1092,7 +1189,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
         // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
-        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
+        .connectionSpecs(asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
         .sslSocketFactory(
             suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build();
@@ -1101,9 +1198,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void recoverFromTlsHandshakeFailure_tlsFallbackScsvEnabled() throws Exception {
+    platform.assumeNotConscrypt();
+
     final String tlsFallbackScsv = "TLS_FALLBACK_SCSV";
     List<String> supportedCiphers =
-        Arrays.asList(handshakeCertificates.sslSocketFactory().getSupportedCipherSuites());
+        asList(handshakeCertificates.sslSocketFactory().getSupportedCipherSuites());
     if (!supportedCiphers.contains(tlsFallbackScsv)) {
       // This only works if the client socket supports TLS_FALLBACK_SCSV.
       return;
@@ -1117,7 +1216,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client = client.newBuilder()
         .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
         // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
-        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
+        .connectionSpecs(asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
@@ -1130,9 +1229,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     List<SSLSocket> clientSockets = clientSocketFactory.getSocketsCreated();
     SSLSocket firstSocket = clientSockets.get(0);
-    assertFalse(Arrays.asList(firstSocket.getEnabledCipherSuites()).contains(tlsFallbackScsv));
+    assertThat(asList(firstSocket.getEnabledCipherSuites())).doesNotContain(tlsFallbackScsv);
     SSLSocket secondSocket = clientSockets.get(1);
-    assertTrue(Arrays.asList(secondSocket.getEnabledCipherSuites()).contains(tlsFallbackScsv));
+    assertThat(asList(secondSocket.getEnabledCipherSuites())).contains(tlsFallbackScsv);
   }
 
   @Test public void recoverFromTlsHandshakeFailure_Async() throws Exception {
@@ -1143,7 +1242,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
         // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
-        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
+        .connectionSpecs(asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
         .sslSocketFactory(
             suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build();
@@ -1158,7 +1257,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
   @Test public void noRecoveryFromTlsHandshakeFailureWhenTlsFallbackIsDisabled() throws Exception {
     client = client.newBuilder()
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT))
+        .connectionSpecs(asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .sslSocketFactory(
             suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
@@ -1178,49 +1277,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     } catch (SSLException expected) {
       // JDK 11 response to the FAIL_HANDSHAKE
       String jvmVersion = System.getProperty("java.specification.version");
-      assertEquals("11", jvmVersion);
+      assertThat(jvmVersion).isEqualTo("11");
     }
   }
 
-  /**
-   * When the server doesn't present any certificates we fail the TLS handshake. This test requires
-   * that the client and server are each configured with a cipher suite that permits the server to
-   * be unauthenticated.
-   */
-  @Test public void tlsSuccessWithNoPeerCertificates() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    // The _anon_ cipher suites don't require server certificates.
-    CipherSuite cipherSuite = TLS_DH_anon_WITH_AES_128_GCM_SHA256;
-
-    HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
-        .build();
-    client = client.newBuilder()
-        .sslSocketFactory(
-            socketFactoryWithCipherSuite(clientCertificates.sslSocketFactory(), cipherSuite),
-            clientCertificates.trustManager())
-        .connectionSpecs(Arrays.asList(new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-            .cipherSuites(cipherSuite)
-            .build()))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
-        .build();
-    server.useHttps(socketFactoryWithCipherSuite(
-        serverCertificates.sslSocketFactory(), cipherSuite), false);
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertEquals("abc", response.body().string());
-    assertNull(response.handshake().peerPrincipal());
-    assertEquals(Collections.emptyList(), response.handshake().peerCertificates());
-    assertEquals(cipherSuite, response.handshake().cipherSuite());
-  }
-
   @Test public void tlsHostnameVerificationFailure() throws Exception {
     server.enqueue(new MockResponse());
 
@@ -1246,10 +1306,19 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertFailureMatches("(?s)Hostname localhost not verified.*");
   }
 
-  @Test public void tlsHostnameVerificationFailureNoPeerCertificates() throws Exception {
+  /**
+   * Anonymous cipher suites were disabled in OpenJDK because they're rarely used and permit
+   * man-in-the-middle attacks. https://bugs.openjdk.java.net/browse/JDK-8212823
+   */
+  @Test public void anonCipherSuiteUnsupported() throws Exception {
+    platform.assumeNotConscrypt();
+
+    // The _anon_ suites became unsupported in "1.8.0_201" and "11.0.2".
+    assumeFalse(System.getProperty("java.version", "unknown").matches("1\\.8\\.0_1\\d\\d"));
+    assumeFalse(System.getProperty("java.version", "unknown").matches("11"));
+
     server.enqueue(new MockResponse());
 
-    // The _anon_ cipher suites don't require server certificates.
     CipherSuite cipherSuite = TLS_DH_anon_WITH_AES_128_GCM_SHA256;
 
     HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
@@ -1258,7 +1327,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .sslSocketFactory(
             socketFactoryWithCipherSuite(clientCertificates.sslSocketFactory(), cipherSuite),
             clientCertificates.trustManager())
-        .connectionSpecs(Arrays.asList(new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .connectionSpecs(asList(new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
             .cipherSuites(cipherSuite)
             .build()))
         .build();
@@ -1269,13 +1338,13 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         serverCertificates.sslSocketFactory(), cipherSuite), false);
 
     executeSynchronously("/")
-        .assertFailure("Hostname localhost not verified (no certificates)");
+        .assertFailure(SSLHandshakeException.class);
   }
 
   @Test public void cleartextCallsFailWhenCleartextIsDisabled() throws Exception {
     // Configure the client with only TLS configurations. No cleartext!
     client = client.newBuilder()
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+        .connectionSpecs(asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
         .build();
 
     server.enqueue(new MockResponse());
@@ -1285,7 +1354,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       client.newCall(request).execute();
       fail();
     } catch (UnknownServiceException expected) {
-      assertEquals("CLEARTEXT communication not enabled for client", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "CLEARTEXT communication not enabled for client");
     }
   }
 
@@ -1304,7 +1374,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       call.execute();
       fail();
     } catch (UnknownServiceException expected) {
-      assertEquals("H2_PRIOR_KNOWLEDGE cannot be used with HTTPS", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS");
     }
   }
 
@@ -1320,11 +1391,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder().url(server.url("/")).build();
     Response response = client.newCall(request).execute();
-    assertEquals(301, response.code());
+    assertThat(response.code()).isEqualTo(301);
     response.body().close();
   }
 
   @Test public void matchingPinnedCertificate() throws Exception {
+    // TODO https://github.com/square/okhttp/issues/4703
+    assumeFalse(getJvmSpecVersion().equals("11"));
+
     enableTls();
     server.enqueue(new MockResponse());
     server.enqueue(new MockResponse());
@@ -1344,7 +1418,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     Request request2 = new Request.Builder().url(server.url("/")).build();
     Response response2 = client.newCall(request2).execute();
-    assertNotSame(response2.handshake(), response1.handshake());
+    assertThat(response1.handshake()).isNotSameAs(response2.handshake());
     response2.body().close();
   }
 
@@ -1365,7 +1439,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       client.newCall(request).execute();
       fail();
     } catch (SSLPeerUnverifiedException expected) {
-      assertTrue(expected.getMessage().startsWith("Certificate pinning failure!"));
+      assertThat(expected.getMessage()).startsWith("Certificate pinning failure!");
     }
   }
 
@@ -1383,9 +1457,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("def", recordedRequest.getBody().readUtf8());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
+    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
+    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
+        "text/plain; charset=utf-8");
   }
 
   @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
@@ -1396,25 +1471,25 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     // Seed the connection pool so we have something that can fail.
     Request request1 = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals("abc", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("abc");
 
     Request request2 = new Request.Builder()
         .url(server.url("/"))
         .post(RequestBody.create(MediaType.get("text/plain"), "body!"))
         .build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals("def", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("def");
 
     RecordedRequest get = server.takeRequest();
-    assertEquals(0, get.getSequenceNumber());
+    assertThat(get.getSequenceNumber()).isEqualTo(0);
 
     RecordedRequest post1 = server.takeRequest();
-    assertEquals("body!", post1.getBody().readUtf8());
-    assertEquals(1, post1.getSequenceNumber());
+    assertThat(post1.getBody().readUtf8()).isEqualTo("body!");
+    assertThat(post1.getSequenceNumber()).isEqualTo(1);
 
     RecordedRequest post2 = server.takeRequest();
-    assertEquals("body!", post2.getBody().readUtf8());
-    assertEquals(0, post2.getSequenceNumber());
+    assertThat(post2.getBody().readUtf8()).isEqualTo("body!");
+    assertThat(post2.getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void postBodyRetransmittedOnFailureRecovery_HTTP2() throws Exception {
@@ -1440,7 +1515,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertCode(200)
         .assertBody("A");
     long request1ReceivedAt = System.currentTimeMillis();
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
 
     // Hit that stored response. It's different, but Vary says it doesn't matter.
     Thread.sleep(10); // Make sure the timestamps are unique.
@@ -1502,7 +1577,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertHeader("Donut", "a")
         .assertBody("A");
     long request1ReceivedAt = System.currentTimeMillis();
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
 
     // Hit that stored response. It's different, but Vary says it doesn't matter.
     Thread.sleep(10); // Make sure the timestamps are unique.
@@ -1510,7 +1585,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     RecordedResponse cacheHit = executeSynchronously(
         "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
     long request2ReceivedAt = System.currentTimeMillis();
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
 
     // Check the merged response. The request is the application's original request.
     cacheHit.assertCode(200)
@@ -1561,14 +1636,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     client.newCall(request1).enqueue(callback);
     callback.await(request1.url()).assertCode(200).assertBody("A");
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
 
     Request request2 = new Request.Builder()
         .url(server.url("/"))
         .build();
     client.newCall(request2).enqueue(callback);
     callback.await(request2.url()).assertCode(200).assertBody("A");
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
   }
 
   @Test public void conditionalCacheMiss() throws Exception {
@@ -1590,7 +1665,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertCode(200)
         .assertBody("A");
     long request1ReceivedAt = System.currentTimeMillis();
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
 
     // Different request, but Vary says it doesn't matter.
     Thread.sleep(10); // Make sure the timestamps are unique.
@@ -1598,7 +1673,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     RecordedResponse cacheMiss = executeSynchronously(
         "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
     long request2ReceivedAt = System.currentTimeMillis();
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
 
     // Check the user response. It has the application's original request.
     cacheMiss.assertCode(200)
@@ -1640,14 +1715,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     client.newCall(request1).enqueue(callback);
     callback.await(request1.url()).assertCode(200).assertBody("A");
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
 
     Request request2 = new Request.Builder()
         .url(server.url("/"))
         .build();
     client.newCall(request2).enqueue(callback);
     callback.await(request2.url()).assertCode(200).assertBody("B");
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
   }
 
   @Test public void onlyIfCachedReturns504WhenNotCached() throws Exception {
@@ -1701,9 +1776,12 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertCode(301)
         .assertHeader("Test", "Redirect from /a to /b");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
-    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Connection reused.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    // Connection reused again!
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
   }
 
   @Test public void postRedirectsToGet() throws Exception {
@@ -1717,14 +1795,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .url(server.url("/page1"))
         .post(RequestBody.create(MediaType.get("text/plain"), "Request Body"))
         .build()).execute();
-    assertEquals("Page 2", response.body().string());
+    assertThat(response.body().string()).isEqualTo("Page 2");
 
     RecordedRequest page1 = server.takeRequest();
-    assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
-    assertEquals("Request Body", page1.getBody().readUtf8());
+    assertThat(page1.getRequestLine()).isEqualTo("POST /page1 HTTP/1.1");
+    assertThat(page1.getBody().readUtf8()).isEqualTo("Request Body");
 
     RecordedRequest page2 = server.takeRequest();
-    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
+    assertThat(page2.getRequestLine()).isEqualTo("GET /page2 HTTP/1.1");
   }
 
   @Test public void getClientRequestTimeout() throws Exception {
@@ -1740,7 +1818,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     Response response = client.newCall(request).execute();
 
-    assertEquals("Body", response.body().string());
+    assertThat(response.body().string()).isEqualTo("Body");
   }
 
   @Test public void getClientRequestTimeoutWithBackPressure() throws Exception {
@@ -1756,7 +1834,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     Response response = client.newCall(request).execute();
 
-    assertEquals("You took too long!", response.body().string());
+    assertThat(response.body().string()).isEqualTo("You took too long!");
   }
 
   @Test public void requestBodyRetransmittedOnClientRequestTimeout() throws Exception {
@@ -1773,13 +1851,13 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     Response response = client.newCall(request).execute();
 
-    assertEquals("Body", response.body().string());
+    assertThat(response.body().string()).isEqualTo("Body");
 
     RecordedRequest request1 = server.takeRequest();
-    assertEquals("Hello", request1.getBody().readUtf8());
+    assertThat(request1.getBody().readUtf8()).isEqualTo("Hello");
 
     RecordedRequest request2 = server.takeRequest();
-    assertEquals("Hello", request2.getBody().readUtf8());
+    assertThat(request2.getBody().readUtf8()).isEqualTo("Hello");
   }
 
   @Test public void disableClientRequestTimeoutRetry() throws IOException {
@@ -1798,8 +1876,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     Response response = client.newCall(request).execute();
 
-    assertEquals(408, response.code());
-    assertEquals("You took too long!", response.body().string());
+    assertThat(response.code()).isEqualTo(408);
+    assertThat(response.body().string()).isEqualTo("You took too long!");
   }
 
   @Test public void maxClientRequestTimeoutRetries() throws IOException {
@@ -1819,10 +1897,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     Response response = client.newCall(request).execute();
 
-    assertEquals(408, response.code());
-    assertEquals("You took too long!", response.body().string());
+    assertThat(response.code()).isEqualTo(408);
+    assertThat(response.body().string()).isEqualTo("You took too long!");
 
-    assertEquals(2, server.getRequestCount());
+    assertThat(server.getRequestCount()).isEqualTo(2);
   }
 
   @Test public void maxUnavailableTimeoutRetries() throws IOException {
@@ -1844,10 +1922,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     Response response = client.newCall(request).execute();
 
-    assertEquals(503, response.code());
-    assertEquals("You took too long!", response.body().string());
+    assertThat(response.code()).isEqualTo(503);
+    assertThat(response.body().string()).isEqualTo("You took too long!");
 
-    assertEquals(2, server.getRequestCount());
+    assertThat(server.getRequestCount()).isEqualTo(2);
   }
 
   @Test public void retryOnUnavailableWith0RetryAfter() throws IOException {
@@ -1864,7 +1942,72 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     Response response = client.newCall(request).execute();
 
-    assertEquals("Body", response.body().string());
+    assertThat(response.body().string()).isEqualTo("Body");
+  }
+
+  @Test public void canRetryNormalRequestBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(503)
+        .setHeader("Retry-After", "0")
+        .setBody("please retry"));
+    server.enqueue(new MockResponse()
+        .setBody("thank you for retrying"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(new RequestBody() {
+          int attempt = 0;
+
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.writeUtf8("attempt " + (attempt++));
+          }
+        })
+        .build();
+    Response response = client.newCall(request).execute();
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.body().string()).isEqualTo("thank you for retrying");
+
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("attempt 0");
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("attempt 1");
+    assertThat(server.getRequestCount()).isEqualTo(2);
+  }
+
+  @Test public void cannotRetryOneShotRequestBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(503)
+        .setHeader("Retry-After", "0")
+        .setBody("please retry"));
+    server.enqueue(new MockResponse()
+        .setBody("thank you for retrying"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(new RequestBody() {
+          int attempt = 0;
+
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.writeUtf8("attempt " + (attempt++));
+          }
+
+          @Override public boolean isOneShot() {
+            return true;
+          }
+        })
+        .build();
+    Response response = client.newCall(request).execute();
+    assertThat(response.code()).isEqualTo(503);
+    assertThat(response.body().string()).isEqualTo("please retry");
+
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("attempt 0");
+    assertThat(server.getRequestCount()).isEqualTo(1);
   }
 
   @Test public void propfindRedirectsToPropfindAndMaintainsRequestBody() throws Exception {
@@ -1882,15 +2025,15 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build()).execute();
 
     // then
-    assertEquals("Page 2", response.body().string());
+    assertThat(response.body().string()).isEqualTo("Page 2");
 
     RecordedRequest page1 = server.takeRequest();
-    assertEquals("PROPFIND /page1 HTTP/1.1", page1.getRequestLine());
-    assertEquals("Request Body", page1.getBody().readUtf8());
+    assertThat(page1.getRequestLine()).isEqualTo("PROPFIND /page1 HTTP/1.1");
+    assertThat(page1.getBody().readUtf8()).isEqualTo("Request Body");
 
     RecordedRequest page2 = server.takeRequest();
-    assertEquals("PROPFIND /page2 HTTP/1.1", page2.getRequestLine());
-    assertEquals("Request Body", page2.getBody().readUtf8());
+    assertThat(page2.getRequestLine()).isEqualTo("PROPFIND /page2 HTTP/1.1");
+    assertThat(page2.getBody().readUtf8()).isEqualTo("Request Body");
   }
 
   @Test public void responseCookies() throws Exception {
@@ -1906,11 +2049,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously("/").assertCode(200);
 
     List<Cookie> responseCookies = cookieJar.takeResponseCookies();
-    assertEquals(2, responseCookies.size());
-    assertEquals("a=b; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/",
-        responseCookies.get(0).toString());
-    assertEquals("c=d; expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure",
-        responseCookies.get(1).toString());
+    assertThat(responseCookies.size()).isEqualTo(2);
+    assertThat(responseCookies.get(0).toString()).isEqualTo(
+        "a=b; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/");
+    assertThat(responseCookies.get(1).toString()).isEqualTo(
+        "c=d; expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure");
   }
 
   @Test public void requestCookies() throws Exception {
@@ -1928,7 +2071,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously("/").assertCode(200);
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("a=b; c=d", recordedRequest.getHeader("Cookie"));
+    assertThat(recordedRequest.getHeader("Cookie")).isEqualTo("a=b; c=d");
   }
 
   @Test public void redirectsDoNotIncludeTooManyCookies() throws Exception {
@@ -1951,13 +2094,13 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     Response response = client.newCall(new Request.Builder()
         .url(server.url("/page1"))
         .build()).execute();
-    assertEquals("Page 2", response.body().string());
+    assertThat(response.body().string()).isEqualTo("Page 2");
 
     RecordedRequest request1 = server.takeRequest();
-    assertEquals("c=cookie", request1.getHeader("Cookie"));
+    assertThat(request1.getHeader("Cookie")).isEqualTo("c=cookie");
 
     RecordedRequest request2 = server2.takeRequest();
-    assertNull(request2.getHeader("Cookie"));
+    assertThat(request2.getHeader("Cookie")).isNull();
   }
 
   @Test public void redirectsDoNotIncludeTooManyAuthHeaders() throws Exception {
@@ -1974,11 +2117,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder().url(server.url("/a")).build();
     Response response = client.newCall(request).execute();
-    assertEquals("Page 2", response.body().string());
+    assertThat(response.body().string()).isEqualTo("Page 2");
 
     RecordedRequest redirectRequest = server2.takeRequest();
-    assertNull(redirectRequest.getHeader("Authorization"));
-    assertEquals("/b", redirectRequest.getPath());
+    assertThat(redirectRequest.getHeader("Authorization")).isNull();
+    assertThat(redirectRequest.getPath()).isEqualTo("/b");
   }
 
   @Test public void redirect_Async() throws Exception {
@@ -2007,9 +2150,12 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertCode(301)
         .assertHeader("Test", "Redirect from /a to /b");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
-    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Connection reused.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    // Connection reused again!
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
   }
 
   @Test public void follow20Redirects() throws Exception {
@@ -2054,7 +2200,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
       fail();
     } catch (IOException expected) {
-      assertEquals("Too many follow-up requests: 21", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("Too many follow-up requests: 21");
     }
   }
 
@@ -2099,7 +2245,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setBody("I'm not even supposed to be here today."));
 
     executeSynchronously("/")
-        .assertFailureMatches(".*unexpected end of stream on Connection.*");
+        .assertFailureMatches(".*unexpected end of stream on " + server.url("/").redact());
   }
 
   private String stringFill(char fillChar, int length) {
@@ -2117,7 +2263,7 @@ private String stringFill(char fillChar, int length) {
       fail();
     } catch (IOException expected) {
     }
-    assertEquals(0, server.getRequestCount());
+    assertThat(server.getRequestCount()).isEqualTo(0);
   }
 
   @Test public void cancelDuringHttpConnect() throws Exception {
@@ -2146,7 +2292,8 @@ private void cancelDuringConnect(String scheme) throws Exception {
     } catch (IOException expected) {
     }
     long elapsedNanos = System.nanoTime() - startNanos;
-    assertEquals(cancelDelayMillis, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 100f);
+    assertThat((float) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(
+        (float) cancelDelayMillis, offset(100f));
   }
 
   @Test public void cancelImmediatelyAfterEnqueue() throws Exception {
@@ -2186,18 +2333,16 @@ private void cancelDuringConnect(String scheme) throws Exception {
   public void cancelWhileRequestHeadersAreSent() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
 
-    EventListener listener =
-        new EventListener() {
-          @Override
-          public void requestHeadersStart(Call call) {
-            try {
-              // Cancel call from another thread to avoid reentrance.
-              cancelLater(call, 0).join();
-            } catch (InterruptedException e) {
-              throw new AssertionError();
-            }
-          }
-        };
+    EventListener listener = new EventListener() {
+      @Override public void requestHeadersStart(Call call) {
+        try {
+          // Cancel call from another thread to avoid reentrance.
+          cancelLater(call, 0).join();
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+      }
+    };
     client = client.newBuilder().eventListener(listener).build();
 
     Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
@@ -2229,7 +2374,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
       fail();
     } catch (IOException expected) {
     }
-    assertEquals(1, server.getRequestCount());
+    assertThat(server.getRequestCount()).isEqualTo(1);
   }
 
   @Test public void cancelInFlightBeforeResponseReadThrowsIOE() throws Exception {
@@ -2288,7 +2433,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
 
     callA.enqueue(callback);
     callB.enqueue(callback);
-    assertEquals("/a", server.takeRequest().getPath());
+    assertThat(server.takeRequest().getPath()).isEqualTo("/a");
 
     callback.await(requestA.url()).assertBody("A");
     // At this point we know the callback is ready, and that it will receive a cancel failure.
@@ -2316,7 +2461,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
     });
 
     call.enqueue(callback);
-    assertEquals("/a", server.takeRequest().getPath());
+    assertThat(server.takeRequest().getPath()).isEqualTo("/a");
 
     callback.await(requestA.url()).assertFailure("Canceled", "stream was reset: CANCEL",
         "Socket closed");
@@ -2365,8 +2510,8 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
     });
 
     latch.await();
-    assertEquals("A", bodyRef.get());
-    assertFalse(failureRef.get());
+    assertThat(bodyRef.get()).isEqualTo("A");
+    assertThat(failureRef.get()).isFalse();
   }
 
   @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTPS()
@@ -2397,7 +2542,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
       fail();
     } catch (IOException expected) {
     }
-    assertEquals(0, server.getRequestCount());
+    assertThat(server.getRequestCount()).isEqualTo(0);
   }
 
   @Test public void gzip() throws Exception {
@@ -2457,12 +2602,12 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
 
     // The response is not decompressed.
     Response response = call.execute();
-    assertEquals("gzip", response.header("Content-Encoding"));
-    assertEquals(gzippedBody.snapshot(), response.body().source().readByteString());
+    assertThat(response.header("Content-Encoding")).isEqualTo("gzip");
+    assertThat(response.body().source().readByteString()).isEqualTo(gzippedBody.snapshot());
 
     // The request did not offer gzip support.
     RecordedRequest recordedRequest = server.takeRequest();
-    assertNull(recordedRequest.getHeader("Accept-Encoding"));
+    assertThat(recordedRequest.getHeader("Accept-Encoding")).isNull();
   }
 
   @Test public void asyncResponseCanBeConsumedLater() throws Exception {
@@ -2490,13 +2635,15 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
     });
 
     Response response = responseRef.take();
-    assertEquals(200, response.code());
-    assertEquals("abc", response.body().string());
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.body().string()).isEqualTo("abc");
 
     // Make another request just to confirm that that connection can be reused...
     executeSynchronously("/").assertBody("def");
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Connection reused.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
 
     // ... even before we close the response body!
     response.body().close();
@@ -2508,8 +2655,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
     executeSynchronously("/");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertTrue(recordedRequest.getHeader("User-Agent")
-        .matches(Version.userAgent()));
+    assertThat(recordedRequest.getHeader("User-Agent")).matches(Version.userAgent);
   }
 
   @Test public void setFollowRedirectsFalse() throws Exception {
@@ -2541,7 +2687,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
         .assertCode(200)
         .assertSuccessful();
 
-    assertEquals("abc", server.takeRequest().getBody().readUtf8());
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("abc");
   }
 
   @Test public void expect100ContinueEmptyRequestBody() throws Exception {
@@ -2585,7 +2731,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
     }
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("", recordedRequest.getBody().readUtf8());
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("");
   }
 
   @Test public void expect100ContinueTimesOutWithoutContinue_HTTP2() throws Exception {
@@ -2607,7 +2753,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
         .assertSuccessful();
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("abc", recordedRequest.getBody().readUtf8());
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("abc");
   }
 
   @Test public void serverRespondsWithUnsolicited100Continue_HTTP2() throws Exception {
@@ -2636,7 +2782,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
     }
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("abc", recordedRequest.getBody().readUtf8());
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("abc");
   }
 
   @Test public void serverRespondsWith100ContinueOnly_HTTP2() throws Exception {
@@ -2658,8 +2804,8 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
         .url(server.url("/"))
         .build());
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void successfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
@@ -2680,11 +2826,13 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
         .url(server.url("/"))
         .build());
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void unsuccessfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
+    platform.assumeHttp2Support();
+
     enableProtocol(Protocol.HTTP_2);
 
     server.enqueue(new MockResponse());
@@ -2699,18 +2847,18 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
         .url(server.url("/"))
         .build());
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   /** We forbid non-ASCII characters in outgoing request headers, but accept UTF-8. */
   @Test public void responseHeaderParsingIsLenient() throws Exception {
-    Headers headers = new Headers.Builder()
-        .add("Content-Length", "0")
-        .addLenient("a\tb: c\u007fd")
-        .addLenient(": ef")
-        .addLenient("\ud83c\udf69: \u2615\ufe0f")
-        .build();
+    Headers.Builder headersBuilder = new Headers.Builder();
+    headersBuilder.add("Content-Length", "0");
+    addHeaderLenient(headersBuilder, "a\tb: c\u007fd");
+    addHeaderLenient(headersBuilder, ": ef");
+    addHeaderLenient(headersBuilder, "\ud83c\udf69: \u2615\ufe0f");
+    Headers headers = headersBuilder.build();
     server.enqueue(new MockResponse().setHeaders(headers));
 
     executeSynchronously("/")
@@ -2779,7 +2927,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
         .url(server.url("/"))
         .post(requestBody)
         .build());
-    assertEquals("Response 1", call.execute().body().string());
+    assertThat(call.execute().body().string()).isEqualTo("Response 1");
   }
 
   /** Test which headers are sent unencrypted to the HTTP proxy. */
@@ -2805,19 +2953,20 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
         .header("User-Agent", "App 1.0")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("encrypted response from the origin server", response.body().string());
+    assertThat(response.body().string()).isEqualTo(
+        "encrypted response from the origin server");
 
     RecordedRequest connect = server.takeRequest();
-    assertNull(connect.getHeader("Private"));
-    assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
-    assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
-    assertEquals("android.com:443", connect.getHeader("Host"));
+    assertThat(connect.getHeader("Private")).isNull();
+    assertThat(connect.getHeader("User-Agent")).isEqualTo(Version.userAgent);
+    assertThat(connect.getHeader("Proxy-Connection")).isEqualTo("Keep-Alive");
+    assertThat(connect.getHeader("Host")).isEqualTo("android.com:443");
 
     RecordedRequest get = server.takeRequest();
-    assertEquals("Secret", get.getHeader("Private"));
-    assertEquals("App 1.0", get.getHeader("User-Agent"));
+    assertThat(get.getHeader("Private")).isEqualTo("Secret");
+    assertThat(get.getHeader("User-Agent")).isEqualTo("App 1.0");
 
-    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
+    assertThat(hostnameVerifier.calls).containsExactly("verify android.com");
   }
 
   /** Respond to a proxy authorization challenge. */
@@ -2844,19 +2993,19 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
         .url("https://android.com/foo")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("response body", response.body().string());
+    assertThat(response.body().string()).isEqualTo("response body");
 
     RecordedRequest connect1 = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect1.getRequestLine());
-    assertNull(connect1.getHeader("Proxy-Authorization"));
+    assertThat(connect1.getRequestLine()).isEqualTo("CONNECT android.com:443 HTTP/1.1");
+    assertThat(connect1.getHeader("Proxy-Authorization")).isNull();
 
     RecordedRequest connect2 = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect2.getRequestLine());
-    assertEquals("password", connect2.getHeader("Proxy-Authorization"));
+    assertThat(connect2.getRequestLine()).isEqualTo("CONNECT android.com:443 HTTP/1.1");
+    assertThat(connect2.getHeader("Proxy-Authorization")).isEqualTo("password");
 
     RecordedRequest get = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
-    assertNull(get.getHeader("Proxy-Authorization"));
+    assertThat(get.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(get.getHeader("Proxy-Authorization")).isNull();
   }
 
   /** Confirm that the proxy authenticator works for unencrypted HTTP proxies. */
@@ -2876,15 +3025,15 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
         .url("http://android.com/foo")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("response body", response.body().string());
+    assertThat(response.body().string()).isEqualTo("response body");
 
     RecordedRequest get1 = server.takeRequest();
-    assertEquals("GET http://android.com/foo HTTP/1.1", get1.getRequestLine());
-    assertNull(get1.getHeader("Proxy-Authorization"));
+    assertThat(get1.getRequestLine()).isEqualTo("GET http://android.com/foo HTTP/1.1");
+    assertThat(get1.getHeader("Proxy-Authorization")).isNull();
 
     RecordedRequest get2 = server.takeRequest();
-    assertEquals("GET http://android.com/foo HTTP/1.1", get2.getRequestLine());
-    assertEquals("password", get2.getHeader("Proxy-Authorization"));
+    assertThat(get2.getRequestLine()).isEqualTo("GET http://android.com/foo HTTP/1.1");
+    assertThat(get2.getHeader("Proxy-Authorization")).isEqualTo("password");
   }
 
   /**
@@ -2916,16 +3065,16 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
         .url("https://android.com/foo")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("response body", response.body().string());
+    assertThat(response.body().string()).isEqualTo("response body");
 
     // First CONNECT call needs a new connection.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
 
     // Second CONNECT call needs a new connection.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
 
     // GET reuses the connection from the second connect.
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void tooManyProxyAuthFailuresWithConnectionClose() throws IOException {
@@ -2981,13 +3130,13 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
         .header("Proxy-Authorization", "password")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("response body", response.body().string());
+    assertThat(response.body().string()).isEqualTo("response body");
 
     RecordedRequest connect1 = server.takeRequest();
-    assertNull(connect1.getHeader("Proxy-Authorization"));
+    assertThat(connect1.getHeader("Proxy-Authorization")).isNull();
 
     RecordedRequest connect2 = server.takeRequest();
-    assertEquals("password", connect2.getHeader("Proxy-Authorization"));
+    assertThat(connect2.getHeader("Proxy-Authorization")).isEqualTo("password");
   }
 
   /** Confirm that we can send authentication information without being prompted first. */
@@ -3007,12 +3156,12 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
         .proxy(server.toProxyAddress())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .proxyAuthenticator((route, response) -> {
-          assertEquals("CONNECT", response.request().method());
-          assertEquals(HttpURLConnection.HTTP_PROXY_AUTH, response.code());
-          assertEquals("android.com", response.request().url().host());
+          assertThat(response.request().method()).isEqualTo("CONNECT");
+          assertThat(response.code()).isEqualTo(HttpURLConnection.HTTP_PROXY_AUTH);
+          assertThat(response.request().url().host()).isEqualTo("android.com");
 
           List<Challenge> challenges = response.challenges();
-          assertEquals("OkHttp-Preemptive", challenges.get(0).scheme());
+          assertThat(challenges.get(0).scheme()).isEqualTo("OkHttp-Preemptive");
 
           return response.request().newBuilder()
               .header("Proxy-Authorization", credential)
@@ -3027,14 +3176,14 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
     executeSynchronously(request).assertSuccessful();
 
     RecordedRequest connect = server.takeRequest();
-    assertEquals("CONNECT", connect.getMethod());
-    assertEquals(credential, connect.getHeader("Proxy-Authorization"));
-    assertEquals("/", connect.getPath());
+    assertThat(connect.getMethod()).isEqualTo("CONNECT");
+    assertThat(connect.getHeader("Proxy-Authorization")).isEqualTo(credential);
+    assertThat(connect.getPath()).isEqualTo("/");
 
     RecordedRequest get = server.takeRequest();
-    assertEquals("GET", get.getMethod());
-    assertNull(get.getHeader("Proxy-Authorization"));
-    assertEquals("/foo", get.getPath());
+    assertThat(get.getMethod()).isEqualTo("GET");
+    assertThat(get.getHeader("Proxy-Authorization")).isNull();
+    assertThat(get.getPath()).isEqualTo("/foo");
   }
 
   @Test public void preemptiveThenReactiveProxyAuthentication() throws Exception {
@@ -3072,17 +3221,42 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
     executeSynchronously(request).assertSuccessful();
 
     RecordedRequest connect1 = server.takeRequest();
-    assertEquals("CONNECT", connect1.getMethod());
-    assertEquals(credential, connect1.getHeader("Proxy-Authorization"));
+    assertThat(connect1.getMethod()).isEqualTo("CONNECT");
+    assertThat(connect1.getHeader("Proxy-Authorization")).isEqualTo(credential);
 
     RecordedRequest connect2 = server.takeRequest();
-    assertEquals("CONNECT", connect2.getMethod());
-    assertEquals(credential, connect2.getHeader("Proxy-Authorization"));
+    assertThat(connect2.getMethod()).isEqualTo("CONNECT");
+    assertThat(connect2.getHeader("Proxy-Authorization")).isEqualTo(credential);
 
-    assertEquals(Arrays.asList("OkHttp-Preemptive", "Basic"), challengeSchemes);
+    assertThat(challengeSchemes).containsExactly("OkHttp-Preemptive", "Basic");
+  }
+
+  /** https://github.com/square/okhttp/issues/4915 */
+  @Test @Ignore public void proxyDisconnectsAfterRequest() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    try {
+      Response response = client.newCall(request).execute();
+      fail();
+    } catch (IOException expected) {
+    }
   }
 
   @Test public void interceptorGetsHttp2() throws Exception {
+    platform.assumeHttp2Support();
+
     enableProtocol(Protocol.HTTP_2);
 
     // Capture the protocol as it is observed by the interceptor.
@@ -3098,7 +3272,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
     // Make an HTTP/2 request and confirm that the protocol matches.
     server.enqueue(new MockResponse());
     executeSynchronously("/");
-    assertEquals(Protocol.HTTP_2, protocolRef.get());
+    assertThat(protocolRef.get()).isEqualTo(Protocol.HTTP_2);
   }
 
   @Test public void serverSendsInvalidResponseHeaders() throws Exception {
@@ -3138,7 +3312,8 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
       new Request.Builder().addHeader("a b", "c");
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("Unexpected char 0x20 at 1 in header name: a b", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0x20 at 1 in header name: a b");
     }
   }
 
@@ -3147,7 +3322,8 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
       new Request.Builder().addHeader("a\tb", "c");
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("Unexpected char 0x09 at 1 in header name: a\tb", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0x09 at 1 in header name: a\tb");
     }
   }
 
@@ -3159,7 +3335,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals("c", response.header("a b"));
+    assertThat(response.header("a b")).isEqualTo("c");
   }
 
   @Test public void responseHeaderNameWithTabPermitted() throws Exception {
@@ -3170,7 +3346,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals("c", response.header("a\tb"));
+    assertThat(response.header("a\tb")).isEqualTo("c");
   }
 
   @Test public void connectFails() throws Exception {
@@ -3197,7 +3373,7 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
         .build();
 
     executeSynchronously(request);
-    assertEquals("abc", server.takeRequest().getBody().readUtf8());
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("abc");
   }
 
   @Ignore // This may fail in DNS lookup, which we don't have timeouts for.
@@ -3213,29 +3389,29 @@ public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
   @Test public void uploadBodySmallChunkedEncoding() throws Exception {
     upload(true, 1048576, 256);
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(1048576, recordedRequest.getBodySize());
-    assertFalse(recordedRequest.getChunkSizes().isEmpty());
+    assertThat(recordedRequest.getBodySize()).isEqualTo(1048576);
+    assertThat(recordedRequest.getChunkSizes()).isNotEmpty();
   }
 
   @Test public void uploadBodyLargeChunkedEncoding() throws Exception {
     upload(true, 1048576, 65536);
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(1048576, recordedRequest.getBodySize());
-    assertFalse(recordedRequest.getChunkSizes().isEmpty());
+    assertThat(recordedRequest.getBodySize()).isEqualTo(1048576);
+    assertThat(recordedRequest.getChunkSizes()).isNotEmpty();
   }
 
   @Test public void uploadBodySmallFixedLength() throws Exception {
     upload(false, 1048576, 256);
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(1048576, recordedRequest.getBodySize());
-    assertTrue(recordedRequest.getChunkSizes().isEmpty());
+    assertThat(recordedRequest.getBodySize()).isEqualTo(1048576);
+    assertThat(recordedRequest.getChunkSizes()).isEmpty();
   }
 
   @Test public void uploadBodyLargeFixedLength() throws Exception {
     upload(false, 1048576, 65536);
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(1048576, recordedRequest.getBodySize());
-    assertTrue(recordedRequest.getChunkSizes().isEmpty());
+    assertThat(recordedRequest.getBodySize()).isEqualTo(1048576);
+    assertThat(recordedRequest.getChunkSizes()).isEmpty();
   }
 
   private void upload(
@@ -3269,15 +3445,15 @@ private void upload(
         .url("https://[::1]/")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("response body", response.body().string());
+    assertThat(response.body().string()).isEqualTo("response body");
 
     RecordedRequest connect = server.takeRequest();
-    assertEquals("CONNECT [::1]:443 HTTP/1.1", connect.getRequestLine());
-    assertEquals("[::1]:443", connect.getHeader("Host"));
+    assertThat(connect.getRequestLine()).isEqualTo("CONNECT [::1]:443 HTTP/1.1");
+    assertThat(connect.getHeader("Host")).isEqualTo("[::1]:443");
 
     RecordedRequest get = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", get.getRequestLine());
-    assertEquals("[::1]", get.getHeader("Host"));
+    assertThat(get.getRequestLine()).isEqualTo("GET / HTTP/1.1");
+    assertThat(get.getHeader("Host")).isEqualTo("[::1]");
   }
 
   private RequestBody requestBody(final boolean chunked, final long size, final int writeSize) {
@@ -3314,7 +3490,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     server.enqueue(new MockResponse()
         .setBody("This gets leaked."));
 
-    client = defaultClient().newBuilder()
+    client = clientTestRule.client.newBuilder()
         .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
         .build();
 
@@ -3330,10 +3506,10 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
       awaitGarbageCollection();
 
       String message = logHandler.take();
-      assertTrue(message.contains("A connection to " + server.url("/") + " was leaked."
-          + " Did you forget to close a response body?"));
-      assertTrue(message.contains("okhttp3.RealCall.execute("));
-      assertTrue(message.contains("okhttp3.CallTest.leakedResponseBodyLogsStackTrace("));
+      assertThat(message).contains("A connection to " + server.url("/") + " was leaked."
+            + " Did you forget to close a response body?");
+      assertThat(message).contains("okhttp3.RealCall.execute(");
+      assertThat(message).contains("okhttp3.CallTest.leakedResponseBodyLogsStackTrace(");
     } finally {
       logger.setLevel(original);
     }
@@ -3343,7 +3519,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     server.enqueue(new MockResponse()
         .setBody("This gets leaked."));
 
-    client = defaultClient().newBuilder()
+    client = clientTestRule.client.newBuilder()
         .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
         .build();
 
@@ -3373,10 +3549,10 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
       awaitGarbageCollection();
 
       String message = logHandler.take();
-      assertTrue(message.contains("A connection to " + server.url("/") + " was leaked."
-          + " Did you forget to close a response body?"));
-      assertTrue(message.contains("okhttp3.RealCall.enqueue("));
-      assertTrue(message.contains("okhttp3.CallTest.asyncLeakedResponseBodyLogsStackTrace("));
+      assertThat(message).contains("A connection to " + server.url("/") + " was leaked."
+            + " Did you forget to close a response body?");
+      assertThat(message).contains("okhttp3.RealCall.enqueue(");
+      assertThat(message).contains("okhttp3.CallTest.asyncLeakedResponseBodyLogsStackTrace(");
     } finally {
       logger.setLevel(original);
     }
@@ -3397,7 +3573,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     executeSynchronously(request)
         .assertFailure(IOException.class);
 
-    assertEquals(1, client.connectionPool().idleConnectionCount());
+    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(1);
   }
 
   @Test public void failedProxyAuthenticatorReleasesConnection() throws IOException {
@@ -3415,7 +3591,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     executeSynchronously(request)
         .assertFailure(IOException.class);
 
-    assertEquals(1, client.connectionPool().idleConnectionCount());
+    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(1);
   }
 
   @Test public void httpsWithIpAddress() throws Exception {
@@ -3453,7 +3629,8 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
 
     // Confirm that the IP address was used in the host header.
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(localIpAddress + ":" + server.getPort(), recordedRequest.getHeader("Host"));
+    assertThat(recordedRequest.getHeader("Host")).isEqualTo(
+        (localIpAddress + ":" + server.getPort()));
   }
 
   @Test public void postWithFileNotFound() throws Exception {
@@ -3482,7 +3659,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     executeSynchronously(request)
         .assertFailure(FileNotFoundException.class);
 
-    assertEquals(1L, called.get());
+    assertThat(called.get()).isEqualTo(1L);
   }
 
   @Test public void clientReadsHeadersDataTrailersHttp1ChunkedTransferEncoding() throws Exception {
@@ -3501,17 +3678,19 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     Response response = call.execute();
     BufferedSource source = response.body().source();
 
-    assertEquals("v1", response.header("h1"));
-    assertEquals("v2", response.header("h2"));
+    assertThat(response.header("h1")).isEqualTo("v1");
+    assertThat(response.header("h2")).isEqualTo("v2");
 
-    assertEquals("Hello", source.readUtf8(5));
-    assertEquals("Bonjour", source.readUtf8(7));
+    assertThat(source.readUtf8(5)).isEqualTo("Hello");
+    assertThat(source.readUtf8(7)).isEqualTo("Bonjour");
 
-    assertTrue(source.exhausted());
-    assertEquals(Headers.of("trailers", "boom"), response.trailers());
+    assertThat(source.exhausted()).isTrue();
+    assertThat(response.trailers()).isEqualTo(Headers.of("trailers", "boom"));
   }
 
   @Test public void clientReadsHeadersDataTrailersHttp2() throws IOException {
+    platform.assumeHttp2Support();
+
     MockResponse mockResponse = new MockResponse()
         .clearHeaders()
         .addHeader("h1", "v1")
@@ -3528,17 +3707,70 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     try (Response response = call.execute()) {
       BufferedSource source = response.body().source();
 
-      assertEquals("v1", response.header("h1"));
-      assertEquals("v2", response.header("h2"));
+      assertThat(response.header("h1")).isEqualTo("v1");
+      assertThat(response.header("h2")).isEqualTo("v2");
 
-      assertEquals("Hello", source.readUtf8(5));
-      assertEquals("Bonjour", source.readUtf8(7));
+      assertThat(source.readUtf8(5)).isEqualTo("Hello");
+      assertThat(source.readUtf8(7)).isEqualTo("Bonjour");
 
-      assertTrue(source.exhausted());
-      assertEquals(Headers.of("trailers", "boom"), response.trailers());
+      assertThat(source.exhausted()).isTrue();
+      assertThat(response.trailers()).isEqualTo(Headers.of("trailers", "boom"));
     }
   }
 
+  @Test public void requestBodyThrowsUnrelatedToNetwork() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(new RequestBody() {
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            throw new IOException("boom");
+          }
+        })
+        .build();
+
+    executeSynchronously(request).assertFailure("boom");
+  }
+
+  @Test public void requestBodyThrowsUnrelatedToNetwork_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    requestBodyThrowsUnrelatedToNetwork();
+  }
+
+  /** https://github.com/square/okhttp/issues/4583 */
+  @Test public void lateCancelCallsOnFailure() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    AtomicBoolean closed = new AtomicBoolean();
+
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            Response response = chain.proceed(chain.request());
+            chain.call().cancel(); // Cancel after we have the response.
+            ForwardingSource closeTrackingSource = new ForwardingSource(response.body().source()) {
+              @Override public void close() throws IOException {
+                closed.set(true);
+                super.close();
+              }
+            };
+            return response.newBuilder()
+                .body(ResponseBody.create(null, -1L, Okio.buffer(closeTrackingSource)))
+                .build();
+          }
+        })
+        .build();
+
+    executeSynchronously("/").assertFailure("Canceled");
+    assertThat(closed.get()).isTrue();
+  }
+
   private void makeFailingCall() {
     RequestBody requestBody = new RequestBody() {
       @Override public MediaType contentType() {
@@ -3564,7 +3796,7 @@ private void makeFailingCall() {
       call.execute();
       fail();
     } catch (IOException expected) {
-      assertEquals("write body fail!", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("write body fail!");
     }
   }
 
@@ -3595,7 +3827,7 @@ private RecordedResponse executeSynchronously(Request request) throws IOExceptio
   private void enableProtocol(Protocol protocol) {
     enableTls();
     client = client.newBuilder()
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .protocols(asList(protocol, Protocol.HTTP_1_1))
         .build();
     server.setProtocols(client.protocols());
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp/src/test/java/okhttp3/CertificateChainCleanerTest.java
similarity index 82%
rename from okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
rename to okhttp/src/test/java/okhttp3/CertificateChainCleanerTest.java
index e61cb9f294..a2185a9348 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
+++ b/okhttp/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -26,7 +26,7 @@
 import okhttp3.tls.HeldCertificate;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class CertificateChainCleanerTest {
@@ -37,16 +37,14 @@
     HeldCertificate rootB = new HeldCertificate.Builder()
         .serialNumber(2L)
         .build();
-    assertEquals(
-        CertificateChainCleaner.get(rootA.certificate(), rootB.certificate()),
-        CertificateChainCleaner.get(rootB.certificate(), rootA.certificate()));
+    assertThat(CertificateChainCleaner.get(rootB.certificate(), rootA.certificate())).isEqualTo(
+        CertificateChainCleaner.get(rootA.certificate(), rootB.certificate()));
   }
 
   @Test public void equalsFromTrustManager() {
     HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder().build();
     X509TrustManager x509TrustManager = handshakeCertificates.trustManager();
-    assertEquals(
-        CertificateChainCleaner.get(x509TrustManager),
+    assertThat(CertificateChainCleaner.get(x509TrustManager)).isEqualTo(
         CertificateChainCleaner.get(x509TrustManager));
   }
 
@@ -55,7 +53,7 @@
         .serialNumber(1L)
         .build();
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
-    assertEquals(list(root), cleaner.clean(list(root), "hostname"));
+    assertThat(cleaner.clean(list(root), "hostname")).isEqualTo(list(root));
   }
 
   @Test public void normalizeUnknownSelfSignedCertificate() {
@@ -85,7 +83,8 @@
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
-    assertEquals(list(certB, certA, root), cleaner.clean(list(certB, certA, root), "hostname"));
+    assertThat(cleaner.clean(list(certB, certA, root), "hostname")).isEqualTo(
+        list(certB, certA, root));
   }
 
   @Test public void orderedChainOfCertificatesWithoutRoot() throws Exception {
@@ -102,8 +101,9 @@
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
-    assertEquals(list(certB, certA, root),
-        cleaner.clean(list(certB, certA), "hostname")); // Root is added!
+    // Root is added!
+    assertThat(cleaner.clean(list(certB, certA), "hostname")).isEqualTo(
+        list(certB, certA, root));
   }
 
   @Test public void unorderedChainOfCertificatesWithRoot() throws Exception {
@@ -124,8 +124,8 @@
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
-    assertEquals(list(certC, certB, certA, root),
-        cleaner.clean(list(certC, certA, root, certB), "hostname"));
+    assertThat(cleaner.clean(list(certC, certA, root, certB), "hostname")).isEqualTo(
+        list(certC, certB, certA, root));
   }
 
   @Test public void unorderedChainOfCertificatesWithoutRoot() throws Exception {
@@ -146,8 +146,8 @@
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
-    assertEquals(list(certC, certB, certA, root),
-        cleaner.clean(list(certC, certA, certB), "hostname"));
+    assertThat(cleaner.clean(list(certC, certA, certB), "hostname")).isEqualTo(
+        list(certC, certB, certA, root));
   }
 
   @Test public void unrelatedCertificatesAreOmitted() throws Exception {
@@ -167,8 +167,8 @@
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
-    assertEquals(list(certB, certA, root),
-        cleaner.clean(list(certB, certUnnecessary, certA, root), "hostname"));
+    assertThat(cleaner.clean(list(certB, certUnnecessary, certA, root), "hostname")).isEqualTo(
+        list(certB, certA, root));
   }
 
   @Test public void chainGoesAllTheWayToSelfSignedRoot() throws Exception {
@@ -190,12 +190,12 @@
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(
         selfSigned.certificate(), trusted.certificate());
-    assertEquals(list(certB, certA, trusted, selfSigned),
-        cleaner.clean(list(certB, certA), "hostname"));
-    assertEquals(list(certB, certA, trusted, selfSigned),
-        cleaner.clean(list(certB, certA, trusted), "hostname"));
-    assertEquals(list(certB, certA, trusted, selfSigned),
-        cleaner.clean(list(certB, certA, trusted, selfSigned), "hostname"));
+    assertThat(cleaner.clean(list(certB, certA), "hostname")).isEqualTo(
+        list(certB, certA, trusted, selfSigned));
+    assertThat(cleaner.clean(list(certB, certA, trusted), "hostname")).isEqualTo(
+        list(certB, certA, trusted, selfSigned));
+    assertThat(cleaner.clean(list(certB, certA, trusted, selfSigned), "hostname")).isEqualTo(
+        list(certB, certA, trusted, selfSigned));
   }
 
   @Test public void trustedRootNotSelfSigned() throws Exception {
@@ -216,10 +216,10 @@
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(trusted.certificate());
-    assertEquals(list(certificate, intermediateCa, trusted),
-        cleaner.clean(list(certificate, intermediateCa), "hostname"));
-    assertEquals(list(certificate, intermediateCa, trusted),
-        cleaner.clean(list(certificate, intermediateCa, trusted), "hostname"));
+    assertThat(cleaner.clean(list(certificate, intermediateCa), "hostname")).isEqualTo(
+        list(certificate, intermediateCa, trusted));
+    assertThat(cleaner.clean(list(certificate, intermediateCa, trusted), "hostname")).isEqualTo(
+        list(certificate, intermediateCa, trusted));
   }
 
   @Test public void chainMaxLength() throws Exception {
@@ -231,8 +231,9 @@
 
     X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate();
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
-    assertEquals(certificates, cleaner.clean(certificates, "hostname"));
-    assertEquals(certificates, cleaner.clean(certificates.subList(0, 9), "hostname"));
+    assertThat(cleaner.clean(certificates, "hostname")).isEqualTo(certificates);
+    assertThat(cleaner.clean(certificates.subList(0, 9), "hostname")).isEqualTo(
+        certificates);
   }
 
   @Test public void chainTooLong() {
diff --git a/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt b/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt
new file mode 100644
index 0000000000..8c55f3901f
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.CertificatePinner.Companion.newPin
+import okhttp3.tls.HeldCertificate
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+
+class CertificatePinnerKotlinTest {
+
+  @Test
+  fun successfulCheckSha1Pin() {
+    val certificatePinner = CertificatePinner.Builder()
+        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate()).base64())
+        .build()
+
+    certificatePinner.check("example.com", certA1.certificate())
+  }
+
+  @Test fun successfulFindMatchingPins() {
+    val certificatePinner = CertificatePinner.Builder()
+        .add("first.com", certA1Sha256Pin, certB1Sha256Pin)
+        .add("second.com", certC1Sha256Pin)
+        .build()
+
+    val expectedPins = listOf(
+        newPin("first.com", certA1Sha256Pin),
+        newPin("first.com", certB1Sha256Pin))
+    assertThat(certificatePinner.findMatchingPins("first.com")).isEqualTo(expectedPins)
+  }
+
+  @Test fun successfulFindMatchingPinsForWildcardAndDirectCertificates() {
+    val certificatePinner = CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
+        .add("b.example.com", certC1Sha256Pin)
+        .build()
+
+    val expectedPins = listOf(
+        newPin("*.example.com", certA1Sha256Pin),
+        newPin("a.example.com", certB1Sha256Pin))
+    assertThat(certificatePinner.findMatchingPins("a.example.com")).isEqualTo(expectedPins)
+  }
+
+  @Test
+  fun wildcardHostnameShouldNotMatchThroughDot() {
+    val certificatePinner = CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build()
+
+    assertThat(certificatePinner.findMatchingPins("example.com")).isEmpty()
+    assertThat(certificatePinner.findMatchingPins("a.b.example.com")).isEmpty()
+  }
+
+  @Test fun successfulFindMatchingPinsIgnoresCase() {
+    val certificatePinner = CertificatePinner.Builder()
+        .add("EXAMPLE.com", certA1Sha256Pin)
+        .add("*.MyExample.Com", certB1Sha256Pin)
+        .build()
+
+    val expectedPin1 = listOf(newPin("EXAMPLE.com", certA1Sha256Pin))
+    assertThat(certificatePinner.findMatchingPins("example.com")).isEqualTo(expectedPin1)
+
+    val expectedPin2 = listOf(newPin("*.MyExample.Com", certB1Sha256Pin))
+    assertThat(certificatePinner.findMatchingPins("a.myexample.com")).isEqualTo(expectedPin2)
+  }
+
+  @Test fun successfulFindMatchingPinPunycode() {
+    val certificatePinner = CertificatePinner.Builder()
+        .add("khttp.com", certA1Sha256Pin)
+        .build()
+
+    val expectedPin = listOf(newPin("khttp.com", certA1Sha256Pin))
+    assertThat(certificatePinner.findMatchingPins("xn--khttp-fde.com")).isEqualTo(expectedPin)
+  }
+
+  /** https://github.com/square/okhttp/issues/3324  */
+  @Test
+  fun checkSubstringMatch() {
+    val certificatePinner = CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build()
+
+    assertThat(certificatePinner.findMatchingPins("a.example.com.notexample.com")).isEmpty()
+    assertThat(certificatePinner.findMatchingPins("example.com.notexample.com")).isEmpty()
+    assertThat(certificatePinner.findMatchingPins("notexample.com")).isEmpty()
+    assertThat(certificatePinner.findMatchingPins("example.com")).isEmpty()
+    assertThat(certificatePinner.findMatchingPins("a.b.example.com")).isEmpty()
+    assertThat(certificatePinner.findMatchingPins("ple.com")).isEmpty()
+    assertThat(certificatePinner.findMatchingPins("com")).isEmpty()
+
+    val expectedPin = newPin("*.example.com", certA1Sha256Pin)
+    assertThat(certificatePinner.findMatchingPins("a.example.com")).containsExactly(expectedPin)
+    assertThat(certificatePinner.findMatchingPins("example.example.com"))
+        .containsExactly(expectedPin)
+  }
+
+  companion object {
+    internal var certA1: HeldCertificate = HeldCertificate.Builder()
+        .serialNumber(100L)
+        .build()
+    internal var certA1Sha256Pin = CertificatePinner.pin(certA1.certificate())
+
+    internal var certB1 = HeldCertificate.Builder()
+        .serialNumber(200L)
+        .build()
+    internal var certB1Sha256Pin = CertificatePinner.pin(certB1.certificate())
+
+    internal var certC1 = HeldCertificate.Builder()
+        .serialNumber(300L)
+        .build()
+    internal var certC1Sha256Pin = CertificatePinner.pin(certC1.certificate())
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp/src/test/java/okhttp3/CertificatePinnerTest.java
similarity index 54%
rename from okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
rename to okhttp/src/test/java/okhttp3/CertificatePinnerTest.java
index a0e03cdcc6..77dacfe9bb 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
+++ b/okhttp/src/test/java/okhttp3/CertificatePinnerTest.java
@@ -15,44 +15,28 @@
  */
 package okhttp3;
 
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import okhttp3.CertificatePinner.Pin;
 import okhttp3.tls.HeldCertificate;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class CertificatePinnerTest {
-  static HeldCertificate certA1;
-  static String certA1Sha256Pin;
+  static HeldCertificate certA1 = new HeldCertificate.Builder()
+      .serialNumber(100L)
+      .build();
+  static String certA1Sha256Pin = CertificatePinner.pin(certA1.certificate());
 
-  static HeldCertificate certB1;
-  static String certB1Sha256Pin;
+  static HeldCertificate certB1 = new HeldCertificate.Builder()
+      .serialNumber(200L)
+      .build();
+  static String certB1Sha256Pin = CertificatePinner.pin(certB1.certificate());
 
-  static HeldCertificate certC1;
-  static String certC1Sha256Pin;
-
-  static {
-    certA1 = new HeldCertificate.Builder()
-        .serialNumber(100L)
-        .build();
-    certA1Sha256Pin = "sha256/" + CertificatePinner.sha256(certA1.certificate()).base64();
-
-    certB1 = new HeldCertificate.Builder()
-        .serialNumber(200L)
-        .build();
-    certB1Sha256Pin = "sha256/" + CertificatePinner.sha256(certB1.certificate()).base64();
-
-    certC1 = new HeldCertificate.Builder()
-        .serialNumber(300L)
-        .build();
-    certC1Sha256Pin = "sha256/" + CertificatePinner.sha256(certC1.certificate()).base64();
-  }
+  static HeldCertificate certC1 = new HeldCertificate.Builder()
+      .serialNumber(300L)
+      .build();
+  static String certC1Sha256Pin = CertificatePinner.pin(certC1.certificate());
 
   @Test public void malformedPin() throws Exception {
     CertificatePinner.Builder builder = new CertificatePinner.Builder();
@@ -68,7 +52,7 @@
     try {
       builder.add("example.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw*");
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (NullPointerException expected) {
     }
   }
 
@@ -86,9 +70,9 @@
         .build();
     String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate());
 
-    assertEquals(certA1Sha256Pin, keypairACertificate2Pin);
-    assertEquals(certB1Sha256Pin, keypairBCertificate2Pin);
-    assertNotEquals(certA1Sha256Pin, certB1Sha256Pin);
+    assertThat(keypairACertificate2Pin).isEqualTo(certA1Sha256Pin);
+    assertThat(keypairBCertificate2Pin).isEqualTo(certB1Sha256Pin);
+    assertThat(certB1Sha256Pin).isNotEqualTo(certA1Sha256Pin);
   }
 
   @Test public void successfulCheck() throws Exception {
@@ -99,14 +83,6 @@
     certificatePinner.check("example.com", certA1.certificate());
   }
 
-  @Test public void successfulCheckSha1Pin() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate()).base64())
-        .build();
-
-    certificatePinner.check("example.com", certA1.certificate());
-  }
-
   @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
         .add("example.com", certB1Sha256Pin)
@@ -213,88 +189,4 @@
     } catch (SSLPeerUnverifiedException expected) {
     }
   }
-
-  @Test public void successfulFindMatchingPins() {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("first.com", certA1Sha256Pin, certB1Sha256Pin)
-        .add("second.com", certC1Sha256Pin)
-        .build();
-
-    List<Pin> expectedPins = Arrays.asList(
-        new Pin("first.com", certA1Sha256Pin),
-        new Pin("first.com", certB1Sha256Pin));
-    assertEquals(expectedPins, certificatePinner.findMatchingPins("first.com"));
-  }
-
-  @Test public void successfulFindMatchingPinsForWildcardAndDirectCertificates() {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .add("a.example.com", certB1Sha256Pin)
-        .add("b.example.com", certC1Sha256Pin)
-        .build();
-
-    List<Pin> expectedPins = Arrays.asList(
-        new Pin("*.example.com", certA1Sha256Pin),
-        new Pin("a.example.com", certB1Sha256Pin));
-    assertEquals(expectedPins, certificatePinner.findMatchingPins("a.example.com"));
-  }
-
-  @Test public void wildcardHostnameShouldNotMatchThroughDot() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .build();
-
-    assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("example.com"));
-    assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("a.b.example.com"));
-  }
-
-  @Test public void successfulFindMatchingPinsIgnoresCase() {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("EXAMPLE.com", certA1Sha256Pin)
-        .add("*.MyExample.Com", certB1Sha256Pin)
-        .build();
-
-    List<Pin> expectedPin1 = Arrays.asList(new Pin("EXAMPLE.com", certA1Sha256Pin));
-    assertEquals(expectedPin1, certificatePinner.findMatchingPins("example.com"));
-
-    List<Pin> expectedPin2 = Arrays.asList(new Pin("*.MyExample.Com", certB1Sha256Pin));
-    assertEquals(expectedPin2, certificatePinner.findMatchingPins("a.myexample.com"));
-  }
-
-  @Test public void successfulFindMatchingPinPunycode() {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("khttp.com", certA1Sha256Pin)
-        .build();
-
-    List<Pin> expectedPin = Arrays.asList(new Pin("khttp.com", certA1Sha256Pin));
-    assertEquals(expectedPin, certificatePinner.findMatchingPins("xn--khttp-fde.com"));
-  }
-
-  /** https://github.com/square/okhttp/issues/3324 */
-  @Test public void checkSubstringMatch() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .build();
-
-    assertEquals(Collections.emptyList(),
-        certificatePinner.findMatchingPins("a.example.com.notexample.com"));
-    assertEquals(Collections.emptyList(),
-        certificatePinner.findMatchingPins("example.com.notexample.com"));
-    assertEquals(Collections.emptyList(),
-        certificatePinner.findMatchingPins("notexample.com"));
-    assertEquals(Collections.emptyList(),
-        certificatePinner.findMatchingPins("example.com"));
-    assertEquals(Collections.emptyList(),
-        certificatePinner.findMatchingPins("a.b.example.com"));
-    assertEquals(Collections.emptyList(),
-        certificatePinner.findMatchingPins("ple.com"));
-    assertEquals(Collections.emptyList(),
-        certificatePinner.findMatchingPins("com"));
-
-    Pin expectedPin = new Pin("*.example.com", certA1Sha256Pin);
-    assertEquals(Collections.singletonList(expectedPin),
-        certificatePinner.findMatchingPins("a.example.com"));
-    assertEquals(Collections.singletonList(expectedPin),
-        certificatePinner.findMatchingPins("example.example.com"));
-  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java b/okhttp/src/test/java/okhttp3/CipherSuiteTest.java
similarity index 76%
rename from okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
rename to okhttp/src/test/java/okhttp3/CipherSuiteTest.java
index 64754ad5c0..35d7843811 100644
--- a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
+++ b/okhttp/src/test/java/okhttp3/CipherSuiteTest.java
@@ -21,10 +21,9 @@
 import static okhttp3.CipherSuite.TLS_RSA_EXPORT_WITH_RC4_40_MD5;
 import static okhttp3.CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA256;
 import static okhttp3.CipherSuite.forJavaName;
+import static okhttp3.internal.InternalKtKt.applyConnectionSpec;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertSame;
 import static org.junit.Assert.fail;
 
 public class CipherSuiteTest {
@@ -32,24 +31,26 @@
     try {
       forJavaName(null);
       fail("Should have thrown");
-    } catch (NullPointerException expected) {
+    } catch (IllegalArgumentException expected) {
     }
   }
 
   @Test public void hashCode_usesIdentityHashCode_legacyCase() {
     CipherSuite cs = TLS_RSA_EXPORT_WITH_RC4_40_MD5; // This one's javaName starts with "SSL_".
-    assertEquals(cs.toString(), System.identityHashCode(cs), cs.hashCode());
+    assertThat(cs.hashCode()).overridingErrorMessage(cs.toString()).isEqualTo(
+        System.identityHashCode(cs));
   }
 
   @Test public void hashCode_usesIdentityHashCode_regularCase() {
     CipherSuite cs = TLS_RSA_WITH_AES_128_CBC_SHA256; // This one's javaName matches the identifier.
-    assertEquals(cs.toString(), System.identityHashCode(cs), cs.hashCode());
+    assertThat(cs.hashCode()).overridingErrorMessage(cs.toString()).isEqualTo(
+        System.identityHashCode(cs));
   }
 
   @Test public void instancesAreInterned() {
-    assertSame(forJavaName("TestCipherSuite"), forJavaName("TestCipherSuite"));
-    assertSame(TLS_KRB5_WITH_DES_CBC_MD5,
-        forJavaName(TLS_KRB5_WITH_DES_CBC_MD5.javaName()));
+    assertThat(forJavaName("TestCipherSuite")).isSameAs(forJavaName("TestCipherSuite"));
+    assertThat(forJavaName(TLS_KRB5_WITH_DES_CBC_MD5.javaName()))
+        .isSameAs(TLS_KRB5_WITH_DES_CBC_MD5);
   }
 
   /**
@@ -61,14 +62,16 @@
     // We're not holding onto a reference to this String instance outside of the CipherSuite...
     CipherSuite cs = forJavaName(new String("FakeCipherSuite_instancesAreInterned"));
     System.gc(); // Unless cs references the String instance, it may now be garbage collected.
-    assertSame(cs, forJavaName(new String(cs.javaName())));
+    assertThat(forJavaName(new String(cs.javaName()))).isSameAs(cs);
   }
 
   @Test public void equals() {
-    assertEquals(forJavaName("cipher"), forJavaName("cipher"));
-    assertNotEquals(forJavaName("cipherA"), forJavaName("cipherB"));
-    assertEquals(forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"), TLS_RSA_EXPORT_WITH_RC4_40_MD5);
-    assertNotEquals(TLS_RSA_EXPORT_WITH_RC4_40_MD5, TLS_RSA_WITH_AES_128_CBC_SHA256);
+    assertThat(forJavaName("cipher")).isEqualTo(forJavaName("cipher"));
+    assertThat(forJavaName("cipherB")).isNotEqualTo(forJavaName("cipherA"));
+    assertThat(TLS_RSA_EXPORT_WITH_RC4_40_MD5).isEqualTo(
+        forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"));
+    assertThat(TLS_RSA_WITH_AES_128_CBC_SHA256).isNotEqualTo(
+        TLS_RSA_EXPORT_WITH_RC4_40_MD5);
   }
 
   @Test public void forJavaName_acceptsArbitraryStrings() {
@@ -77,16 +80,18 @@
   }
 
   @Test public void javaName_examples() {
-    assertEquals("SSL_RSA_EXPORT_WITH_RC4_40_MD5", TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName());
-    assertEquals("TLS_RSA_WITH_AES_128_CBC_SHA256", TLS_RSA_WITH_AES_128_CBC_SHA256.javaName());
-    assertEquals("TestCipherSuite", forJavaName("TestCipherSuite").javaName());
+    assertThat(TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName()).isEqualTo(
+        "SSL_RSA_EXPORT_WITH_RC4_40_MD5");
+    assertThat(TLS_RSA_WITH_AES_128_CBC_SHA256.javaName()).isEqualTo(
+        "TLS_RSA_WITH_AES_128_CBC_SHA256");
+    assertThat(forJavaName("TestCipherSuite").javaName()).isEqualTo("TestCipherSuite");
   }
 
   @Test public void javaName_equalsToString() {
-    assertEquals(TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName,
-        TLS_RSA_EXPORT_WITH_RC4_40_MD5.toString());
-    assertEquals(TLS_RSA_WITH_AES_128_CBC_SHA256.javaName,
-        TLS_RSA_WITH_AES_128_CBC_SHA256.toString());
+    assertThat(TLS_RSA_EXPORT_WITH_RC4_40_MD5.toString()).isEqualTo(
+        TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName());
+    assertThat(TLS_RSA_WITH_AES_128_CBC_SHA256.toString()).isEqualTo(
+        TLS_RSA_WITH_AES_128_CBC_SHA256.javaName());
   }
 
   /**
@@ -98,15 +103,12 @@
    */
   @Test public void forJavaName_fromLegacyEnumName() {
     // These would have been considered equal in OkHttp 3.3.1, but now aren't.
-    assertEquals(
-        forJavaName("TLS_RSA_EXPORT_WITH_RC4_40_MD5"),
-        forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"));
-    assertEquals(
-        forJavaName("TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"),
-        forJavaName("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"));
-    assertEquals(
-        forJavaName("TLS_FAKE_NEW_CIPHER"),
-        forJavaName("SSL_FAKE_NEW_CIPHER"));
+    assertThat(forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5")).isEqualTo(
+        forJavaName("TLS_RSA_EXPORT_WITH_RC4_40_MD5"));
+    assertThat(forJavaName("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA")).isEqualTo(
+        forJavaName("TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"));
+    assertThat(forJavaName("SSL_FAKE_NEW_CIPHER")).isEqualTo(
+        forJavaName("TLS_FAKE_NEW_CIPHER"));
   }
 
   @Test public void applyIntersectionRetainsSslPrefixes() throws Exception {
@@ -119,7 +121,7 @@
         .tlsVersions(TlsVersion.TLS_1_0)
         .cipherSuites("TLS_A", "TLS_C", "TLS_E")
         .build();
-    connectionSpec.apply(socket, false);
+    applyConnectionSpec(connectionSpec, socket, false);
 
     assertArrayEquals(new String[] { "SSL_A", "SSL_C" }, socket.enabledCipherSuites);
   }
@@ -134,7 +136,7 @@
         .tlsVersions(TlsVersion.TLS_1_0)
         .cipherSuites("SSL_A", "SSL_C", "SSL_E")
         .build();
-    connectionSpec.apply(socket, false);
+    applyConnectionSpec(connectionSpec, socket, false);
 
     assertArrayEquals(new String[] { "TLS_A", "TLS_C" }, socket.enabledCipherSuites);
   }
@@ -149,7 +151,7 @@
         .tlsVersions(TlsVersion.TLS_1_0)
         .cipherSuites("SSL_A")
         .build();
-    connectionSpec.apply(socket, true);
+    applyConnectionSpec(connectionSpec, socket, true);
 
     assertArrayEquals(new String[] { "SSL_A", "SSL_FALLBACK_SCSV" }, socket.enabledCipherSuites);
   }
@@ -164,7 +166,7 @@
         .tlsVersions(TlsVersion.TLS_1_0)
         .cipherSuites("TLS_A")
         .build();
-    connectionSpec.apply(socket, true);
+    applyConnectionSpec(connectionSpec, socket, true);
 
     assertArrayEquals(new String[] { "TLS_A", "TLS_FALLBACK_SCSV" }, socket.enabledCipherSuites);
   }
@@ -179,7 +181,7 @@
         .tlsVersions(TlsVersion.TLS_1_1, TlsVersion.TLS_1_2, TlsVersion.TLS_1_3)
         .cipherSuites("TLS_A")
         .build();
-    connectionSpec.apply(socket, false);
+    applyConnectionSpec(connectionSpec, socket, false);
 
     assertArrayEquals(new String[] { "TLSv1.1", "TLSv1.2" }, socket.enabledProtocols);
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java b/okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java
similarity index 87%
rename from okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
rename to okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java
index c792d75ba0..48ad1cf99a 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
+++ b/okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java
@@ -19,7 +19,6 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -34,11 +33,14 @@
 import org.junit.Rule;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ConnectionCoalescingTest {
+  @Rule public final PlatformRule platform = new PlatformRule();
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   private OkHttpClient client;
 
@@ -49,6 +51,9 @@
   private List<InetAddress> serverIps;
 
   @Before public void setUp() throws Exception {
+    platform.assumeNotConscrypt();
+    platform.assumeHttp2Support();
+
     rootCa = new HeldCertificate.Builder()
         .serialNumber(1L)
         .certificateAuthority(0)
@@ -80,6 +85,7 @@
         .sslSocketFactory(
             handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .build();
+    clientTestRule.client = client;
 
     HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
         .heldCertificate(certificate)
@@ -102,7 +108,7 @@
     HttpUrl sanUrl = url.newBuilder().host("san.com").build();
     assert200Http2Response(execute(sanUrl), "san.com");
 
-    assertEquals(1, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
   /**
@@ -118,7 +124,7 @@
 
     assert200Http2Response(execute(url), server.getHostName());
 
-    assertEquals(1, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
   /** Test a previously coalesced connection that's no longer healthy. */
@@ -143,7 +149,7 @@
     HttpUrl sanUrl = url.newBuilder().host("san.com").build();
     assert200Http2Response(execute(sanUrl), "san.com");
 
-    assertEquals(1, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
   /** If the existing connection matches a SAN but not a match for DNS then skip. */
@@ -178,7 +184,7 @@
   /** Can still coalesce when pinning is used if pins match. */
   @Test public void coalescesWhenCertificatePinsMatch() throws Exception {
     CertificatePinner pinner = new CertificatePinner.Builder()
-        .add("san.com", "sha1/" + CertificatePinner.sha1(certificate.certificate()).base64())
+        .add("san.com", CertificatePinner.pin(certificate.certificate()))
         .build();
     client = client.newBuilder().certificatePinner(pinner).build();
 
@@ -191,7 +197,7 @@
 
     assert200Http2Response(execute(sanUrl), "san.com");
 
-    assertEquals(1, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
   /** Certificate pinning used and not a match will avoid coalescing and try to connect. */
@@ -231,7 +237,7 @@
 
     assert200Http2Response(execute(sanUrl), "san.com");
 
-    assertEquals(2, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(2);
   }
 
   /**
@@ -244,8 +250,8 @@
 
     AtomicInteger connectCount = new AtomicInteger();
     EventListener listener = new EventListener() {
-      @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
-          Proxy proxy) {
+      @Override public void connectStart(
+          Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
         connectCount.getAndIncrement();
       }
     };
@@ -257,12 +263,12 @@
 
     HttpUrl sanUrl = url.newBuilder().host("san.com").build();
     dns.set("san.com",
-        Arrays.asList(InetAddress.getByAddress("san.com", new byte[] {0, 0, 0, 0}),
+        asList(InetAddress.getByAddress("san.com", new byte[] {0, 0, 0, 0}),
             serverIps.get(0)));
     assert200Http2Response(execute(sanUrl), "san.com");
 
-    assertEquals(1, client.connectionPool().connectionCount());
-    assertEquals(1, connectCount.get());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
+    assertThat(connectCount.get()).isEqualTo(1);
   }
 
   /** Check that wildcard SANs are supported. */
@@ -276,7 +282,7 @@
     HttpUrl sanUrl = url.newBuilder().host("www.wildcard.com").build();
     assert200Http2Response(execute(sanUrl), "www.wildcard.com");
 
-    assertEquals(1, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
   /** Network interceptors check for changes to target. */
@@ -293,7 +299,7 @@
     HttpUrl sanUrl = url.newBuilder().host("san.com").build();
     assert200Http2Response(execute(sanUrl), "san.com");
 
-    assertEquals(1, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
   /** Run against public external sites, doesn't run by default. */
@@ -307,7 +313,7 @@
     assert200Http2Response(execute("https://messenger.com/robots.txt"), "messenger.com");
     assert200Http2Response(execute("https://m.facebook.com/robots.txt"), "m.facebook.com");
 
-    assertEquals(3, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(3);
   }
 
   private Response execute(String url) throws IOException {
@@ -319,9 +325,9 @@ private Response execute(HttpUrl url) throws IOException {
   }
 
   private void assert200Http2Response(Response response, String expectedHost) {
-    assertEquals(200, response.code());
-    assertEquals(expectedHost, response.request().url().host());
-    assertEquals(Protocol.HTTP_2, response.protocol());
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.request().url().host()).isEqualTo(expectedHost);
+    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_2);
     response.body().close();
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
similarity index 81%
rename from okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
rename to okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
index f8c4991120..837dae460c 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
+++ b/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
@@ -15,9 +15,11 @@
  */
 package okhttp3;
 
-import java.util.Arrays;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLException;
+import okhttp3.internal.Util;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
@@ -27,18 +29,19 @@
 import org.junit.rules.TestRule;
 import org.junit.rules.Timeout;
 
-import static okhttp3.TestUtil.defaultClient;
+import static java.util.Arrays.asList;
 import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ConnectionReuseTest {
+  @Rule public final PlatformRule platform = new PlatformRule();
   @Rule public final TestRule timeout = new Timeout(30_000);
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client = defaultClient();
+  private OkHttpClient client = clientTestRule.client;
 
   @Test public void connectionsAreReused() throws Exception {
     server.enqueue(new MockResponse().setBody("a"));
@@ -130,9 +133,9 @@
         .url(server.url("/"))
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("b", response.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(response.body().string()).isEqualTo("b");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void connectionsNotReusedWithRedirectIfDiscardingResponseIsSlow() throws Exception {
@@ -150,9 +153,9 @@
         .url(server.url("/"))
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("b", response.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(response.body().string()).isEqualTo("b");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void silentRetryWhenIdempotentRequestFailsOnReusedConnection() throws Exception {
@@ -165,13 +168,13 @@
         .build();
 
     Response responseA = client.newCall(request).execute();
-    assertEquals("a", responseA.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(responseA.body().string()).isEqualTo("a");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
 
     Response responseB = client.newCall(request).execute();
-    assertEquals("b", responseB.body().string());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(responseB.body().string()).isEqualTo("b");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void staleConnectionNotReusedForNonIdempotentRequest() throws Exception {
@@ -183,8 +186,8 @@
         .url(server.url("/"))
         .build();
     Response responseA = client.newCall(requestA).execute();
-    assertEquals("a", responseA.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(responseA.body().string()).isEqualTo("a");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
 
     // Give the socket a chance to become stale.
     Thread.sleep(250);
@@ -194,8 +197,8 @@
         .post(RequestBody.create(MediaType.get("text/plain"), "b"))
         .build();
     Response responseB = client.newCall(requestB).execute();
-    assertEquals("b", responseB.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(responseB.body().string()).isEqualTo("b");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void http2ConnectionsAreSharedBeforeResponseIsConsumed() throws Exception {
@@ -210,8 +213,8 @@
     Response response2 = client.newCall(request).execute();
     response1.body().string(); // Discard the response body.
     response2.body().string(); // Discard the response body.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void connectionsAreEvicted() throws Exception {
@@ -226,16 +229,16 @@
         .build();
 
     Response response1 = client.newCall(request).execute();
-    assertEquals("a", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("a");
 
     // Give the thread pool a chance to evict.
     Thread.sleep(500);
 
     Response response2 = client.newCall(request).execute();
-    assertEquals("b", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("b");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void connectionsAreNotReusedIfSslSocketFactoryChanges() throws Exception {
@@ -285,8 +288,8 @@
     Response response2 = anotherClient.newCall(request).execute();
     response2.body().close();
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   /**
@@ -300,12 +303,15 @@
    * https://github.com/square/okhttp/issues/2409
    */
   @Test public void connectionsAreNotReusedIfNetworkInterceptorInterferes() throws Exception {
+    List<Response> responsesNotClosed = new ArrayList<>();
+
     client = client.newBuilder()
         // Since this test knowingly leaks a connection, avoid using the default shared connection
         // pool, which should remain clean for subsequent tests.
         .connectionPool(new ConnectionPool())
         .addNetworkInterceptor(chain -> {
           Response response = chain.proceed(chain.request());
+          responsesNotClosed.add(response);
           return response
               .newBuilder()
               .body(ResponseBody.create(null, "unrelated response body!"))
@@ -324,11 +330,16 @@
         .url(server.url("/"))
         .build();
     Call call = client.newCall(request);
-    try {
-      call.execute();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertTrue(expected.getMessage().startsWith("Closing the body of"));
+    try (Response response = call.execute()) {
+      assertThat(response.body().string()).isEqualTo("unrelated response body!");
+    }
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // No connection reuse.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+
+    for (Response response : responsesNotClosed) {
+      Util.closeQuietly(response);
     }
   }
 
@@ -337,6 +348,7 @@ private void enableHttps() {
   }
 
   private void enableHttp2() {
+    platform.assumeHttp2Support();
     enableHttpsAndAlpn(Protocol.HTTP_2, Protocol.HTTP_1_1);
   }
 
@@ -345,7 +357,7 @@ private void enableHttpsAndAlpn(Protocol... protocols) {
         .sslSocketFactory(
             handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .protocols(Arrays.asList(protocols))
+        .protocols(asList(protocols))
         .build();
     server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.setProtocols(client.protocols());
@@ -355,7 +367,7 @@ private void assertConnectionReused(Request... requests) throws Exception {
     for (int i = 0; i < requests.length; i++) {
       Response response = client.newCall(requests[i]).execute();
       response.body().string(); // Discard the response body.
-      assertEquals(i, server.takeRequest().getSequenceNumber());
+      assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(i);
     }
   }
 
@@ -363,7 +375,7 @@ private void assertConnectionNotReused(Request... requests) throws Exception {
     for (Request request : requests) {
       Response response = client.newCall(request).execute();
       response.body().string(); // Discard the response body.
-      assertEquals(0, server.takeRequest().getSequenceNumber());
+      assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
     }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java b/okhttp/src/test/java/okhttp3/ConnectionSpecTest.java
similarity index 52%
rename from okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
rename to okhttp/src/test/java/okhttp3/ConnectionSpecTest.java
index 13b2824f06..a42d05bc80 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
+++ b/okhttp/src/test/java/okhttp3/ConnectionSpecTest.java
@@ -15,46 +15,48 @@
  */
 package okhttp3;
 
-import java.util.Arrays;
-import java.util.LinkedHashSet;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Set;
 import java.util.concurrent.CopyOnWriteArraySet;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import org.junit.Rule;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static java.util.Arrays.asList;
+import static okhttp3.internal.InternalKtKt.applyConnectionSpec;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ConnectionSpecTest {
-  @Test public void noTlsVersions() throws Exception {
+  @Rule public final PlatformRule platform = new PlatformRule();
+
+  @Test public void noTlsVersions() {
     try {
       new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
           .tlsVersions(new TlsVersion[0])
           .build();
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("At least one TLS version is required", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("At least one TLS version is required");
     }
   }
 
-  @Test public void noCipherSuites() throws Exception {
+  @Test public void noCipherSuites() {
     try {
       new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
           .cipherSuites(new CipherSuite[0])
           .build();
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("At least one cipher suite is required", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("At least one cipher suite is required");
     }
   }
 
-  @Test public void cleartextBuilder() throws Exception {
+  @Test public void cleartextBuilder() {
     ConnectionSpec cleartextSpec = new ConnectionSpec.Builder(false).build();
-    assertFalse(cleartextSpec.isTls());
+    assertThat(cleartextSpec.isTls()).isFalse();
   }
 
   @Test public void tlsBuilder_explicitCiphers() throws Exception {
@@ -63,9 +65,9 @@
         .tlsVersions(TlsVersion.TLS_1_2)
         .supportsTlsExtensions(true)
         .build();
-    assertEquals(Arrays.asList(CipherSuite.TLS_RSA_WITH_RC4_128_MD5), tlsSpec.cipherSuites());
-    assertEquals(Arrays.asList(TlsVersion.TLS_1_2), tlsSpec.tlsVersions());
-    assertTrue(tlsSpec.supportsTlsExtensions());
+    assertThat(tlsSpec.cipherSuites()).containsExactly(CipherSuite.TLS_RSA_WITH_RC4_128_MD5);
+    assertThat(tlsSpec.tlsVersions()).containsExactly(TlsVersion.TLS_1_2);
+    assertThat(tlsSpec.supportsTlsExtensions()).isTrue();
   }
 
   @Test public void tlsBuilder_defaultCiphers() throws Exception {
@@ -73,12 +75,14 @@
         .tlsVersions(TlsVersion.TLS_1_2)
         .supportsTlsExtensions(true)
         .build();
-    assertNull(tlsSpec.cipherSuites());
-    assertEquals(Arrays.asList(TlsVersion.TLS_1_2), tlsSpec.tlsVersions());
-    assertTrue(tlsSpec.supportsTlsExtensions());
+    assertThat(tlsSpec.cipherSuites()).isNull();
+    assertThat(tlsSpec.tlsVersions()).containsExactly(TlsVersion.TLS_1_2);
+    assertThat(tlsSpec.supportsTlsExtensions()).isTrue();
   }
 
   @Test public void tls_defaultCiphers_noFallbackIndicator() throws Exception {
+    platform.assumeNotConscrypt();
+
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
         .tlsVersions(TlsVersion.TLS_1_2)
         .supportsTlsExtensions(false)
@@ -86,27 +90,27 @@
 
     SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
     socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
     });
     socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName,
-        TlsVersion.TLS_1_1.javaName,
+        TlsVersion.TLS_1_2.javaName(),
+        TlsVersion.TLS_1_1.javaName(),
     });
 
-    assertTrue(tlsSpec.isCompatible(socket));
-    tlsSpec.apply(socket, false /* isFallback */);
+    assertThat(tlsSpec.isCompatible(socket)).isTrue();
+    applyConnectionSpec(tlsSpec, socket, false /* isFallback */);
 
-    assertEquals(set(TlsVersion.TLS_1_2.javaName), set(socket.getEnabledProtocols()));
+    assertThat(socket.getEnabledProtocols()).containsExactly(TlsVersion.TLS_1_2.javaName());
 
-    Set<String> expectedCipherSet =
-        set(
-            CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-            CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName);
-    assertEquals(expectedCipherSet, expectedCipherSet);
+    assertThat(socket.getEnabledCipherSuites()).containsExactlyInAnyOrder(
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName());
   }
 
   @Test public void tls_defaultCiphers_withFallbackIndicator() throws Exception {
+    platform.assumeNotConscrypt();
+
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
         .tlsVersions(TlsVersion.TLS_1_2)
         .supportsTlsExtensions(false)
@@ -114,30 +118,31 @@
 
     SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
     socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
     });
     socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName,
-        TlsVersion.TLS_1_1.javaName,
+        TlsVersion.TLS_1_2.javaName(),
+        TlsVersion.TLS_1_1.javaName(),
     });
 
-    assertTrue(tlsSpec.isCompatible(socket));
-    tlsSpec.apply(socket, true /* isFallback */);
+    assertThat(tlsSpec.isCompatible(socket)).isTrue();
+    applyConnectionSpec(tlsSpec, socket, true /* isFallback */);
 
-    assertEquals(set(TlsVersion.TLS_1_2.javaName), set(socket.getEnabledProtocols()));
+    assertThat(socket.getEnabledProtocols()).containsExactly(TlsVersion.TLS_1_2.javaName());
 
-    Set<String> expectedCipherSet =
-        set(
-            CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-            CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName);
-    if (Arrays.asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
-      expectedCipherSet.add("TLS_FALLBACK_SCSV");
+    List<String> expectedCipherSuites = new ArrayList<>();
+    expectedCipherSuites.add(CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName());
+    expectedCipherSuites.add(CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName());
+    if (asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
+      expectedCipherSuites.add("TLS_FALLBACK_SCSV");
     }
-    assertEquals(expectedCipherSet, expectedCipherSet);
+    assertThat(socket.getEnabledCipherSuites()).containsExactlyElementsOf(expectedCipherSuites);
   }
 
   @Test public void tls_explicitCiphers() throws Exception {
+    platform.assumeNotConscrypt();
+
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
         .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
         .tlsVersions(TlsVersion.TLS_1_2)
@@ -146,24 +151,25 @@
 
     SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
     socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
     });
     socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName,
-        TlsVersion.TLS_1_1.javaName,
+        TlsVersion.TLS_1_2.javaName(),
+        TlsVersion.TLS_1_1.javaName(),
     });
 
-    assertTrue(tlsSpec.isCompatible(socket));
-    tlsSpec.apply(socket, true /* isFallback */);
+    assertThat(tlsSpec.isCompatible(socket)).isTrue();
+    applyConnectionSpec(tlsSpec, socket, true /* isFallback */);
 
-    assertEquals(set(TlsVersion.TLS_1_2.javaName), set(socket.getEnabledProtocols()));
+    assertThat(socket.getEnabledProtocols()).containsExactly(TlsVersion.TLS_1_2.javaName());
 
-    Set<String> expectedCipherSet = set(CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName);
-    if (Arrays.asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
-      expectedCipherSet.add("TLS_FALLBACK_SCSV");
+    List<String> expectedCipherSuites = new ArrayList<>();
+    expectedCipherSuites.add(CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName());
+    if (asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
+      expectedCipherSuites.add("TLS_FALLBACK_SCSV");
     }
-    assertEquals(expectedCipherSet, expectedCipherSet);
+    assertThat(socket.getEnabledCipherSuites()).containsExactlyElementsOf(expectedCipherSuites);
   }
 
   @Test public void tls_stringCiphersAndVersions() throws Exception {
@@ -176,6 +182,8 @@
   }
 
   @Test public void tls_missingRequiredCipher() throws Exception {
+    platform.assumeNotConscrypt();
+
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
         .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
         .tlsVersions(TlsVersion.TLS_1_2)
@@ -184,46 +192,49 @@
 
     SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
     socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName,
-        TlsVersion.TLS_1_1.javaName,
+        TlsVersion.TLS_1_2.javaName(),
+        TlsVersion.TLS_1_1.javaName(),
     });
 
     socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
     });
-    assertTrue(tlsSpec.isCompatible(socket));
+    assertThat(tlsSpec.isCompatible(socket)).isTrue();
 
     socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
     });
-    assertFalse(tlsSpec.isCompatible(socket));
+    assertThat(tlsSpec.isCompatible(socket)).isFalse();
   }
 
   @Test public void allEnabledCipherSuites() throws Exception {
+    platform.assumeNotConscrypt();
+
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
         .allEnabledCipherSuites()
         .build();
-    assertNull(tlsSpec.cipherSuites());
+    assertThat(tlsSpec.cipherSuites()).isNull();
 
     SSLSocket sslSocket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
     sslSocket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
     });
 
-    tlsSpec.apply(sslSocket, false);
-    assertEquals(Arrays.asList(
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName),
-        Arrays.asList(sslSocket.getEnabledCipherSuites()));
+    applyConnectionSpec(tlsSpec, sslSocket, false);
+    assertThat(sslSocket.getEnabledCipherSuites()).containsExactly(
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName());
   }
 
   @Test public void allEnabledTlsVersions() throws Exception {
+    platform.assumeNotConscrypt();
+
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
         .allEnabledTlsVersions()
         .build();
-    assertNull(tlsSpec.tlsVersions());
+    assertThat(tlsSpec.tlsVersions()).isNull();
 
     SSLSocket sslSocket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
     sslSocket.setEnabledProtocols(new String[] {
@@ -231,12 +242,14 @@
         TlsVersion.TLS_1_1.javaName()
     });
 
-    tlsSpec.apply(sslSocket, false);
-    assertEquals(Arrays.asList(TlsVersion.SSL_3_0.javaName(), TlsVersion.TLS_1_1.javaName()),
-        Arrays.asList(sslSocket.getEnabledProtocols()));
+    applyConnectionSpec(tlsSpec, sslSocket, false);
+    assertThat(sslSocket.getEnabledProtocols()).containsExactly(
+        TlsVersion.SSL_3_0.javaName(), TlsVersion.TLS_1_1.javaName());
   }
 
   @Test public void tls_missingTlsVersion() throws Exception {
+    platform.assumeNotConscrypt();
+
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
         .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
         .tlsVersions(TlsVersion.TLS_1_2)
@@ -245,15 +258,15 @@
 
     SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
     socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
     });
 
     socket.setEnabledProtocols(
-        new String[] {TlsVersion.TLS_1_2.javaName, TlsVersion.TLS_1_1.javaName});
-    assertTrue(tlsSpec.isCompatible(socket));
+        new String[] {TlsVersion.TLS_1_2.javaName(), TlsVersion.TLS_1_1.javaName()});
+    assertThat(tlsSpec.isCompatible(socket)).isTrue();
 
-    socket.setEnabledProtocols(new String[] {TlsVersion.TLS_1_1.javaName});
-    assertFalse(tlsSpec.isCompatible(socket));
+    socket.setEnabledProtocols(new String[] {TlsVersion.TLS_1_1.javaName()});
+    assertThat(tlsSpec.isCompatible(socket)).isFalse();
   }
 
   @Test public void equalsAndHashCode() throws Exception {
@@ -265,18 +278,18 @@
         .build();
 
     Set<Object> set = new CopyOnWriteArraySet<>();
-    assertTrue(set.add(ConnectionSpec.MODERN_TLS));
-    assertTrue(set.add(ConnectionSpec.COMPATIBLE_TLS));
-    assertTrue(set.add(ConnectionSpec.CLEARTEXT));
-    assertTrue(set.add(allTlsVersions));
-    assertTrue(set.add(allCipherSuites));
-
-    assertTrue(set.remove(ConnectionSpec.MODERN_TLS));
-    assertTrue(set.remove(ConnectionSpec.COMPATIBLE_TLS));
-    assertTrue(set.remove(ConnectionSpec.CLEARTEXT));
-    assertTrue(set.remove(allTlsVersions));
-    assertTrue(set.remove(allCipherSuites));
-    assertTrue(set.isEmpty());
+    assertThat(set.add(ConnectionSpec.MODERN_TLS)).isTrue();
+    assertThat(set.add(ConnectionSpec.COMPATIBLE_TLS)).isTrue();
+    assertThat(set.add(ConnectionSpec.CLEARTEXT)).isTrue();
+    assertThat(set.add(allTlsVersions)).isTrue();
+    assertThat(set.add(allCipherSuites)).isTrue();
+
+    assertThat(set.remove(ConnectionSpec.MODERN_TLS)).isTrue();
+    assertThat(set.remove(ConnectionSpec.COMPATIBLE_TLS)).isTrue();
+    assertThat(set.remove(ConnectionSpec.CLEARTEXT)).isTrue();
+    assertThat(set.remove(allTlsVersions)).isTrue();
+    assertThat(set.remove(allCipherSuites)).isTrue();
+    assertThat(set).isEmpty();
   }
 
   @Test public void allEnabledToString() throws Exception {
@@ -284,8 +297,9 @@
         .allEnabledTlsVersions()
         .allEnabledCipherSuites()
         .build();
-    assertEquals("ConnectionSpec(cipherSuites=[all enabled], tlsVersions=[all enabled], "
-        + "supportsTlsExtensions=true)", connectionSpec.toString());
+    assertThat(connectionSpec.toString()).isEqualTo(
+        ("ConnectionSpec(cipherSuites=[all enabled], tlsVersions=[all enabled], "
+        + "supportsTlsExtensions=true)"));
   }
 
   @Test public void simpleToString() throws Exception {
@@ -293,12 +307,8 @@
         .tlsVersions(TlsVersion.TLS_1_2)
         .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
         .build();
-    assertEquals("ConnectionSpec(cipherSuites=[SSL_RSA_WITH_RC4_128_MD5], tlsVersions=[TLS_1_2], "
-        + "supportsTlsExtensions=true)", connectionSpec.toString());
-  }
-
-  @SafeVarargs
-  private static <T> Set<T> set(T... values) {
-    return new LinkedHashSet<>(Arrays.asList(values));
+    assertThat(connectionSpec.toString()).isEqualTo(
+        ("ConnectionSpec(cipherSuites=[SSL_RSA_WITH_RC4_128_MD5], tlsVersions=[TLS_1_2], "
+        + "supportsTlsExtensions=true)"));
   }
 }
diff --git a/okhttp/src/test/java/okhttp3/ConscryptTest.kt b/okhttp/src/test/java/okhttp3/ConscryptTest.kt
new file mode 100644
index 0000000000..7b42128fda
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/ConscryptTest.kt
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.platform.ConscryptPlatform
+import okhttp3.internal.platform.Platform
+import org.assertj.core.api.Assertions.assertThat
+import org.conscrypt.Conscrypt
+import org.junit.After
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Assume
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import java.net.InetAddress
+import java.net.UnknownHostException
+
+class ConscryptTest {
+  @Suppress("RedundantVisibilityModifier")
+  @JvmField
+  @Rule public val platform = PlatformRule.conscrypt()
+
+  private lateinit var client: OkHttpClient
+
+  @Before
+  fun createClient() {
+    assertThat(Conscrypt.isConscrypt(Platform.get().platformTrustManager())).isTrue()
+
+    client = OkHttpClient()
+  }
+
+  @After
+  fun tearDown() {
+    TestUtil.ensureAllConnectionsReleased(client)
+  }
+
+  private fun assumeNetwork() {
+    try {
+      InetAddress.getByName("www.google.com")
+    } catch (uhe: UnknownHostException) {
+      Assume.assumeNoException(uhe)
+    }
+  }
+
+  @Test
+  fun testMozilla() {
+    assumeNetwork()
+
+    val request = Request.Builder().url("https://mozilla.org/robots.txt").build()
+
+    val response = client.newCall(request).execute()
+
+    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_2)
+    assertThat(response.handshake()!!.tlsVersion()).isEqualTo(TlsVersion.TLS_1_3)
+  }
+
+  @Test
+  fun testGoogle() {
+    assumeNetwork()
+
+    val request = Request.Builder().url("https://google.com/robots.txt").build()
+
+    val response = client.newCall(request).execute()
+
+    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_2)
+    if (response.handshake()!!.tlsVersion() != TlsVersion.TLS_1_3) {
+      System.err.println("Flaky TLSv1.3 with google")
+//    assertThat(response.handshake()!!.tlsVersion()).isEqualTo(TlsVersion.TLS_1_3)
+    }
+  }
+
+  @Test
+  fun testBuildIfSupported() {
+    val actual = ConscryptPlatform.buildIfSupported()
+    assertThat(actual).isNotNull
+  }
+
+  @Test
+  fun testVersion() {
+    assertTrue(ConscryptPlatform.atLeastVersion(1, 4, 9))
+    assertTrue(ConscryptPlatform.atLeastVersion(2))
+    assertTrue(ConscryptPlatform.atLeastVersion(2, 1))
+    assertTrue(ConscryptPlatform.atLeastVersion(2, 1, 0))
+    assertFalse(ConscryptPlatform.atLeastVersion(2, 1, 1))
+    assertFalse(ConscryptPlatform.atLeastVersion(2, 2))
+    assertFalse(ConscryptPlatform.atLeastVersion(9))
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/CookieTest.java b/okhttp/src/test/java/okhttp3/CookieTest.java
new file mode 100644
index 0000000000..a1f591360f
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/CookieTest.java
@@ -0,0 +1,587 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.List;
+import java.util.Objects;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpDate;
+import org.junit.Test;
+
+import static java.util.Arrays.asList;
+import static okhttp3.internal.InternalKtKt.parseCookie;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CookieTest {
+  HttpUrl url = HttpUrl.get("https://example.com/");
+
+  @Test public void simpleCookie() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42");
+    assertThat(cookie.toString()).isEqualTo("SID=31d4d96e407aad42; path=/");
+  }
+
+  @Test public void noEqualsSign() throws Exception {
+    assertThat(Cookie.parse(url, "foo")).isNull();
+    assertThat(Cookie.parse(url, "foo; Path=/")).isNull();
+  }
+
+  @Test public void emptyName() throws Exception {
+    assertThat(Cookie.parse(url, "=b")).isNull();
+    assertThat(Cookie.parse(url, " =b")).isNull();
+    assertThat(Cookie.parse(url, "\r\t \n=b")).isNull();
+  }
+
+  @Test public void spaceInName() throws Exception {
+    assertThat(Cookie.parse(url, "a b=cd").name()).isEqualTo("a b");
+  }
+
+  @Test public void spaceInValue() throws Exception {
+    assertThat(Cookie.parse(url, "ab=c d").value()).isEqualTo("c d");
+  }
+
+  @Test public void trimLeadingAndTrailingWhitespaceFromName() throws Exception {
+    assertThat(Cookie.parse(url, " a=b").name()).isEqualTo("a");
+    assertThat(Cookie.parse(url, "a =b").name()).isEqualTo("a");
+    assertThat(Cookie.parse(url, "\r\t \na\n\t \n=b").name()).isEqualTo("a");
+  }
+
+  @Test public void emptyValue() throws Exception {
+    assertThat(Cookie.parse(url, "a=").value()).isEqualTo("");
+    assertThat(Cookie.parse(url, "a= ").value()).isEqualTo("");
+    assertThat(Cookie.parse(url, "a=\r\t \n").value()).isEqualTo("");
+  }
+
+  @Test public void trimLeadingAndTrailingWhitespaceFromValue() throws Exception {
+    assertThat(Cookie.parse(url, "a= ").value()).isEqualTo("");
+    assertThat(Cookie.parse(url, "a= b").value()).isEqualTo("b");
+    assertThat(Cookie.parse(url, "a=b ").value()).isEqualTo("b");
+    assertThat(Cookie.parse(url, "a=\r\t \nb\n\t \n").value()).isEqualTo("b");
+  }
+
+  @Test public void invalidCharacters() throws Exception {
+    assertThat(Cookie.parse(url, "a\u0000b=cd")).isNull();
+    assertThat(Cookie.parse(url, "ab=c\u0000d")).isNull();
+    assertThat(Cookie.parse(url, "a\u0001b=cd")).isNull();
+    assertThat(Cookie.parse(url, "ab=c\u0001d")).isNull();
+    assertThat(Cookie.parse(url, "a\u0009b=cd")).isNull();
+    assertThat(Cookie.parse(url, "ab=c\u0009d")).isNull();
+    assertThat(Cookie.parse(url, "a\u001fb=cd")).isNull();
+    assertThat(Cookie.parse(url, "ab=c\u001fd")).isNull();
+    assertThat(Cookie.parse(url, "a\u007fb=cd")).isNull();
+    assertThat(Cookie.parse(url, "ab=c\u007fd")).isNull();
+    assertThat(Cookie.parse(url, "a\u0080b=cd")).isNull();
+    assertThat(Cookie.parse(url, "ab=c\u0080d")).isNull();
+    assertThat(Cookie.parse(url, "a\u00ffb=cd")).isNull();
+    assertThat(Cookie.parse(url, "ab=c\u00ffd")).isNull();
+  }
+
+  @Test public void maxAge() throws Exception {
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=1").expiresAt()).isEqualTo(51000L);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=9223372036854724").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=9223372036854725").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=9223372036854726").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(parseCookie(9223372036854773807L, url, "a=b; Max-Age=1").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(parseCookie(9223372036854773807L, url, "a=b; Max-Age=2").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(parseCookie(9223372036854773807L, url, "a=b; Max-Age=3").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=10000000000000000000").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+  }
+
+  @Test public void maxAgeNonPositive() throws Exception {
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-1").expiresAt()).isEqualTo(Long.MIN_VALUE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=0").expiresAt()).isEqualTo(Long.MIN_VALUE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-9223372036854775808").expiresAt()).isEqualTo(
+        Long.MIN_VALUE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-9223372036854775809").expiresAt()).isEqualTo(
+        Long.MIN_VALUE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-10000000000000000000").expiresAt()).isEqualTo(
+        Long.MIN_VALUE);
+  }
+
+  @Test public void domainAndPath() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Domain=example.com");
+    assertThat(cookie.domain()).isEqualTo("example.com");
+    assertThat(cookie.path()).isEqualTo("/");
+    assertThat(cookie.hostOnly()).isFalse();
+    assertThat(cookie.toString()).isEqualTo(
+        "SID=31d4d96e407aad42; domain=example.com; path=/");
+  }
+
+  @Test public void secureAndHttpOnly() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Secure; HttpOnly");
+    assertThat(cookie.secure()).isTrue();
+    assertThat(cookie.httpOnly()).isTrue();
+    assertThat(cookie.toString()).isEqualTo(
+        "SID=31d4d96e407aad42; path=/; secure; httponly");
+  }
+
+  @Test public void expiresDate() throws Exception {
+    assertThat(new Date(
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT").expiresAt())).isEqualTo(
+        date("1970-01-01T00:00:00.000+0000"));
+    assertThat(new Date(
+        Cookie.parse(url, "a=b; Expires=Wed, 09 Jun 2021 10:18:14 GMT").expiresAt())).isEqualTo(
+        date("2021-06-09T10:18:14.000+0000"));
+    assertThat(new Date(
+        Cookie.parse(url, "a=b; Expires=Sun, 06 Nov 1994 08:49:37 GMT").expiresAt())).isEqualTo(
+        date("1994-11-06T08:49:37.000+0000"));
+  }
+
+  @Test public void awkwardDates() throws Exception {
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 70 00:00:00 GMT").expiresAt()).isEqualTo(
+        0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 January 1970 00:00:00 GMT").expiresAt()).isEqualTo(
+        0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Janucember 1970 00:00:00 GMT").expiresAt()).isEqualTo(
+        0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 1 Jan 1970 00:00:00 GMT").expiresAt()).isEqualTo(
+        0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 0:00:00 GMT").expiresAt()).isEqualTo(
+        0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:0:00 GMT").expiresAt()).isEqualTo(
+        0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:0 GMT").expiresAt()).isEqualTo(
+        0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 Thu, 01 Jan 1970 GMT").expiresAt()).isEqualTo(
+        0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 01").expiresAt()).isEqualTo(0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 1").expiresAt()).isEqualTo(0L);
+  }
+
+  @Test public void invalidYear() throws Exception {
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1600 00:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 19999 00:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 00:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+  }
+
+  @Test public void invalidMonth() throws Exception {
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Foo 1970 00:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Foocember 1970 00:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 1970 00:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+  }
+
+  @Test public void invalidDayOfMonth() throws Exception {
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 32 Jan 1970 00:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, Jan 1970 00:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+  }
+
+  @Test public void invalidHour() throws Exception {
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 24:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+  }
+
+  @Test public void invalidMinute() throws Exception {
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:60:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+  }
+
+  @Test public void invalidSecond() throws Exception {
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:60 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+  }
+
+  @Test public void domainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com");
+    assertThat(cookie.matches(HttpUrl.get("http://example.com"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://www.example.com"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://square.com"))).isFalse();
+  }
+
+  /** If no domain is present, match only the origin domain. */
+  @Test public void domainMatchesNoDomain() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b");
+    assertThat(cookie.matches(HttpUrl.get("http://example.com"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://www.example.com"))).isFalse();
+    assertThat(cookie.matches(HttpUrl.get("http://square.com"))).isFalse();
+  }
+
+  /** Ignore an optional leading `.` in the domain. */
+  @Test public void domainMatchesIgnoresLeadingDot() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=.example.com");
+    assertThat(cookie.matches(HttpUrl.get("http://example.com"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://www.example.com"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://square.com"))).isFalse();
+  }
+
+  /** Ignore the entire attribute if the domain ends with `.`. */
+  @Test public void domainIgnoredWithTrailingDot() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com.");
+    assertThat(cookie.matches(HttpUrl.get("http://example.com"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://www.example.com"))).isFalse();
+    assertThat(cookie.matches(HttpUrl.get("http://square.com"))).isFalse();
+  }
+
+  @Test public void idnDomainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://.net/"), "a=b; domain=.net");
+    assertThat(cookie.matches(HttpUrl.get("http://.net/"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://xn--n3h.net/"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://www..net/"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://www.xn--n3h.net/"))).isTrue();
+  }
+
+  @Test public void punycodeDomainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://xn--n3h.net/"), "a=b; domain=xn--n3h.net");
+    assertThat(cookie.matches(HttpUrl.get("http://.net/"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://xn--n3h.net/"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://www..net/"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://www.xn--n3h.net/"))).isTrue();
+  }
+
+  @Test public void domainMatchesIpAddress() throws Exception {
+    HttpUrl urlWithIp = HttpUrl.get("http://123.45.234.56/");
+    assertThat(Cookie.parse(urlWithIp, "a=b; domain=234.56")).isNull();
+    assertThat(Cookie.parse(urlWithIp, "a=b; domain=123.45.234.56").domain()).isEqualTo(
+        "123.45.234.56");
+  }
+
+  @Test public void domainMatchesIpv6Address() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::1");
+    assertThat(cookie.domain()).isEqualTo("::1");
+    assertThat(cookie.matches(HttpUrl.get("http://[::1]/"))).isTrue();
+  }
+
+  @Test public void domainMatchesIpv6AddressWithCompression() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[0001:0000::]/"), "a=b; domain=0001:0000::");
+    assertThat(cookie.domain()).isEqualTo("1::");
+    assertThat(cookie.matches(HttpUrl.get("http://[1::]/"))).isTrue();
+  }
+
+  @Test public void domainMatchesIpv6AddressWithIpv4Suffix() throws Exception {
+    Cookie cookie = Cookie.parse(
+        HttpUrl.get("http://[::1:ffff:ffff]/"), "a=b; domain=::1:255.255.255.255");
+    assertThat(cookie.domain()).isEqualTo("::1:ffff:ffff");
+    assertThat(cookie.matches(HttpUrl.get("http://[::1:ffff:ffff]/"))).isTrue();
+  }
+
+  @Test public void ipv6AddressDoesntMatch() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::2");
+    assertThat(cookie).isNull();
+  }
+
+  @Test public void ipv6AddressMalformed() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::2::2");
+    assertThat(cookie.domain()).isEqualTo("::1");
+  }
+
+  /**
+   * These public suffixes were selected by inspecting the publicsuffix.org list. It's possible they
+   * may change in the future. If this test begins to fail, please double check they are still
+   * present in the public suffix list.
+   */
+  @Test public void domainIsPublicSuffix() {
+    HttpUrl ascii = HttpUrl.get("https://foo1.foo.bar.elb.amazonaws.com");
+    assertThat(Cookie.parse(ascii, "a=b; domain=foo.bar.elb.amazonaws.com")).isNotNull();
+    assertThat(Cookie.parse(ascii, "a=b; domain=bar.elb.amazonaws.com")).isNull();
+    assertThat(Cookie.parse(ascii, "a=b; domain=com")).isNull();
+
+    HttpUrl unicode = HttpUrl.get("https://...jp");
+    assertThat(Cookie.parse(unicode, "a=b; domain=..jp")).isNotNull();
+    assertThat(Cookie.parse(unicode, "a=b; domain=.jp")).isNull();
+
+    HttpUrl punycode = HttpUrl.get("https://xn--ue5a.xn--ue5a.xn--8ltr62k.jp");
+    assertThat(Cookie.parse(punycode, "a=b; domain=xn--ue5a.xn--8ltr62k.jp")).isNotNull();
+    assertThat(Cookie.parse(punycode, "a=b; domain=xn--8ltr62k.jp")).isNull();
+  }
+
+  @Test public void hostOnly() throws Exception {
+    assertThat(Cookie.parse(url, "a=b").hostOnly()).isTrue();
+    assertThat(Cookie.parse(url, "a=b; domain=example.com").hostOnly()).isFalse();
+  }
+
+  @Test public void defaultPath() throws Exception {
+    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/bar"), "a=b").path()).isEqualTo(
+        "/foo");
+    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/"), "a=b").path()).isEqualTo(
+        "/foo");
+    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo"), "a=b").path()).isEqualTo(
+        "/");
+    assertThat(Cookie.parse(HttpUrl.get("http://example.com/"), "a=b").path()).isEqualTo(
+        "/");
+  }
+
+  @Test public void defaultPathIsUsedIfPathDoesntHaveLeadingSlash() throws Exception {
+    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
+        "a=b; path=quux").path()).isEqualTo("/foo");
+    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
+        "a=b; path=").path()).isEqualTo("/foo");
+  }
+
+  @Test public void pathAttributeDoesntNeedToMatch() throws Exception {
+    assertThat(Cookie.parse(HttpUrl.get("http://example.com/"),
+        "a=b; path=/quux").path()).isEqualTo("/quux");
+    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
+        "a=b; path=/quux").path()).isEqualTo("/quux");
+  }
+
+  @Test public void httpOnly() throws Exception {
+    assertThat(Cookie.parse(url, "a=b").httpOnly()).isFalse();
+    assertThat(Cookie.parse(url, "a=b; HttpOnly").httpOnly()).isTrue();
+  }
+
+  @Test public void secure() throws Exception {
+    assertThat(Cookie.parse(url, "a=b").secure()).isFalse();
+    assertThat(Cookie.parse(url, "a=b; Secure").secure()).isTrue();
+  }
+
+  @Test public void maxAgeTakesPrecedenceOverExpires() throws Exception {
+    // Max-Age = 1, Expires = 2. In either order.
+    assertThat(parseCookie(
+        0L, url, "a=b; Max-Age=1; Expires=Thu, 01 Jan 1970 00:00:02 GMT").expiresAt()).isEqualTo(
+        1000L);
+    assertThat(parseCookie(
+        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:02 GMT; Max-Age=1").expiresAt()).isEqualTo(
+        1000L);
+    // Max-Age = 2, Expires = 1. In either order.
+    assertThat(parseCookie(
+        0L, url, "a=b; Max-Age=2; Expires=Thu, 01 Jan 1970 00:00:01 GMT").expiresAt()).isEqualTo(
+        2000L);
+    assertThat(parseCookie(
+        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Max-Age=2").expiresAt()).isEqualTo(
+        2000L);
+  }
+
+  /** If a cookie incorrectly defines multiple 'Max-Age' attributes, the last one defined wins. */
+  @Test public void lastMaxAgeWins() throws Exception {
+    assertThat(parseCookie(
+        0L, url, "a=b; Max-Age=2; Max-Age=4; Max-Age=1; Max-Age=3").expiresAt()).isEqualTo(3000L);
+  }
+
+  /** If a cookie incorrectly defines multiple 'Expires' attributes, the last one defined wins. */
+  @Test public void lastExpiresAtWins() throws Exception {
+    assertThat(parseCookie(0L, url, "a=b; "
+        + "Expires=Thu, 01 Jan 1970 00:00:02 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:04 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:01 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:03 GMT").expiresAt()).isEqualTo(3000L);
+  }
+
+  @Test public void maxAgeOrExpiresMakesCookiePersistent() throws Exception {
+    assertThat(parseCookie(0L, url, "a=b").persistent()).isFalse();
+    assertThat(parseCookie(0L, url, "a=b; Max-Age=1").persistent()).isTrue();
+    assertThat(parseCookie(0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT").persistent()).isTrue();
+  }
+
+  @Test public void parseAll() throws Exception {
+    Headers headers = new Headers.Builder()
+        .add("Set-Cookie: a=b")
+        .add("Set-Cookie: c=d")
+        .build();
+    List<Cookie> cookies = Cookie.parseAll(url, headers);
+    assertThat(cookies.size()).isEqualTo(2);
+    assertThat(cookies.get(0).toString()).isEqualTo("a=b; path=/");
+    assertThat(cookies.get(1).toString()).isEqualTo("c=d; path=/");
+  }
+
+  @Test public void builder() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain("example.com")
+        .build();
+    assertThat(cookie.name()).isEqualTo("a");
+    assertThat(cookie.value()).isEqualTo("b");
+    assertThat(cookie.expiresAt()).isEqualTo(HttpDate.MAX_DATE);
+    assertThat(cookie.domain()).isEqualTo("example.com");
+    assertThat(cookie.path()).isEqualTo("/");
+    assertThat(cookie.secure()).isFalse();
+    assertThat(cookie.httpOnly()).isFalse();
+    assertThat(cookie.persistent()).isFalse();
+    assertThat(cookie.hostOnly()).isFalse();
+  }
+
+  @Test public void builderNameValidation() throws Exception {
+    try {
+      new Cookie.Builder().name(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Cookie.Builder().name(" a ");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderValueValidation() throws Exception {
+    try {
+      new Cookie.Builder().value(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Cookie.Builder().value(" b ");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderClampsMaxDate() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(Long.MAX_VALUE)
+        .build();
+    assertThat(cookie.toString()).isEqualTo(
+        "a=b; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/");
+  }
+
+  @Test public void builderExpiresAt() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(date("1970-01-01T00:00:01.000+0000").getTime())
+        .build();
+    assertThat(cookie.toString()).isEqualTo(
+        "a=b; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/");
+  }
+
+  @Test public void builderClampsMinDate() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(date("1970-01-01T00:00:00.000+0000").getTime())
+        .build();
+    assertThat(cookie.toString()).isEqualTo("a=b; max-age=0; path=/");
+  }
+
+  @Test public void builderDomainValidation() throws Exception {
+    try {
+      new Cookie.Builder().hostOnlyDomain(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Cookie.Builder().hostOnlyDomain("a/b");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderDomain() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("squareup.com")
+        .build();
+    assertThat(cookie.domain()).isEqualTo("squareup.com");
+    assertThat(cookie.hostOnly()).isTrue();
+  }
+
+  @Test public void builderPath() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .path("/foo")
+        .build();
+    assertThat(cookie.path()).isEqualTo("/foo");
+  }
+
+  @Test public void builderPathValidation() throws Exception {
+    try {
+      new Cookie.Builder().path(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Cookie.Builder().path("foo");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderSecure() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .secure()
+        .build();
+    assertThat(cookie.secure()).isTrue();
+  }
+
+  @Test public void builderHttpOnly() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .httpOnly()
+        .build();
+    assertThat(cookie.httpOnly()).isTrue();
+  }
+
+  @Test public void builderIpv6() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain("0:0:0:0:0:0:0:1")
+        .build();
+    assertThat(cookie.domain()).isEqualTo("::1");
+  }
+
+  @Test public void equalsAndHashCode() throws Exception {
+    List<String> cookieStrings = asList(
+        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
+        "a= ; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
+        "a=b;          Domain=example.com; Max-Age=5; Secure; HttpOnly",
+        "a=b; Path=/c;                     Max-Age=5; Secure; HttpOnly",
+        "a=b; Path=/c; Domain=example.com;            Secure; HttpOnly",
+        "a=b; Path=/c; Domain=example.com; Max-Age=5;         HttpOnly",
+        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure;         "
+    );
+    for (String stringA : cookieStrings) {
+      Cookie cookieA = parseCookie(0, url, stringA);
+      for (String stringB : cookieStrings) {
+        Cookie cookieB = parseCookie(0, url, stringB);
+        if (Objects.equals(stringA, stringB)) {
+          assertThat(cookieB.hashCode()).isEqualTo(cookieA.hashCode());
+          assertThat(cookieB).isEqualTo(cookieA);
+        } else {
+          assertThat(cookieB.hashCode()).isNotEqualTo((long) cookieA.hashCode());
+          assertThat(cookieB).isNotEqualTo(cookieA);
+        }
+      }
+      assertThat(cookieA).isNotEqualTo(null);
+    }
+  }
+
+  private Date date(String s) throws ParseException {
+    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
+    format.setTimeZone(Util.UTC);
+    return format.parse(s);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CookiesTest.java b/okhttp/src/test/java/okhttp3/CookiesTest.java
similarity index 76%
rename from okhttp-tests/src/test/java/okhttp3/CookiesTest.java
rename to okhttp/src/test/java/okhttp3/CookiesTest.java
index add061e3fe..be8d238382 100644
--- a/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
+++ b/okhttp/src/test/java/okhttp3/CookiesTest.java
@@ -23,7 +23,6 @@
 import java.net.HttpURLConnection;
 import java.net.InetAddress;
 import java.net.URI;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -31,19 +30,21 @@
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import org.junit.Rule;
 import org.junit.Test;
 
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
-import static okhttp3.TestUtil.defaultClient;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 import static org.junit.Assert.fail;
 
 /** Derived from Android's CookiesTest. */
 public class CookiesTest {
-  private OkHttpClient client = defaultClient();
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+
+  private OkHttpClient client = clientTestRule.client;
 
   @Test
   public void testNetscapeResponse() throws Exception {
@@ -51,8 +52,6 @@ public void testNetscapeResponse() throws Exception {
     client = client.newBuilder()
         .cookieJar(new JavaNetCookieJar(cookieManager))
         .build();
-    MockWebServer server = new MockWebServer();
-    server.start();
 
     HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
     server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
@@ -63,17 +62,17 @@ public void testNetscapeResponse() throws Exception {
     get(urlWithIpAddress);
 
     List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertEquals(1, cookies.size());
+    assertThat(cookies.size()).isEqualTo(1);
     HttpCookie cookie = cookies.get(0);
-    assertEquals("a", cookie.getName());
-    assertEquals("android", cookie.getValue());
-    assertNull(cookie.getComment());
-    assertNull(cookie.getCommentURL());
-    assertFalse(cookie.getDiscard());
-    assertTrue(cookie.getMaxAge() > 100000000000L);
-    assertEquals("/path", cookie.getPath());
-    assertTrue(cookie.getSecure());
-    assertEquals(0, cookie.getVersion());
+    assertThat(cookie.getName()).isEqualTo("a");
+    assertThat(cookie.getValue()).isEqualTo("android");
+    assertThat(cookie.getComment()).isNull();
+    assertThat(cookie.getCommentURL()).isNull();
+    assertThat(cookie.getDiscard()).isFalse();
+    assertThat(cookie.getMaxAge()).isGreaterThan(100000000000L);
+    assertThat(cookie.getPath()).isEqualTo("/path");
+    assertThat(cookie.getSecure()).isTrue();
+    assertThat(cookie.getVersion()).isEqualTo(0);
   }
 
   @Test public void testRfc2109Response() throws Exception {
@@ -81,8 +80,6 @@ public void testNetscapeResponse() throws Exception {
     client = client.newBuilder()
         .cookieJar(new JavaNetCookieJar(cookieManager))
         .build();
-    MockWebServer server = new MockWebServer();
-    server.start();
 
     HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
     server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
@@ -95,15 +92,16 @@ public void testNetscapeResponse() throws Exception {
     get(urlWithIpAddress);
 
     List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertEquals(1, cookies.size());
+    assertThat(cookies.size()).isEqualTo(1);
     HttpCookie cookie = cookies.get(0);
-    assertEquals("a", cookie.getName());
-    assertEquals("android", cookie.getValue());
-    assertNull(cookie.getCommentURL());
-    assertFalse(cookie.getDiscard());
-    assertEquals(60.0, cookie.getMaxAge(), 1.0); // Converting to a fixed date can cause rounding!
-    assertEquals("/path", cookie.getPath());
-    assertTrue(cookie.getSecure());
+    assertThat(cookie.getName()).isEqualTo("a");
+    assertThat(cookie.getValue()).isEqualTo("android");
+    assertThat(cookie.getCommentURL()).isNull();
+    assertThat(cookie.getDiscard()).isFalse();
+    // Converting to a fixed date can cause rounding!
+    assertThat((double) cookie.getMaxAge()).isCloseTo(60.0, offset(5.0));
+    assertThat(cookie.getPath()).isEqualTo("/path");
+    assertThat(cookie.getSecure()).isTrue();
   }
 
   @Test public void testQuotedAttributeValues() throws Exception {
@@ -111,8 +109,6 @@ public void testNetscapeResponse() throws Exception {
     client = client.newBuilder()
         .cookieJar(new JavaNetCookieJar(cookieManager))
         .build();
-    MockWebServer server = new MockWebServer();
-    server.start();
 
     HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
     server.enqueue(new MockResponse().addHeader("Set-Cookie: a=\"android\"; "
@@ -128,19 +124,18 @@ public void testNetscapeResponse() throws Exception {
     get(urlWithIpAddress);
 
     List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertEquals(1, cookies.size());
+    assertThat(cookies.size()).isEqualTo(1);
     HttpCookie cookie = cookies.get(0);
-    assertEquals("a", cookie.getName());
-    assertEquals("android", cookie.getValue());
-    assertEquals(60.0, cookie.getMaxAge(), 1.0); // Converting to a fixed date can cause rounding!
-    assertEquals("/path", cookie.getPath());
-    assertTrue(cookie.getSecure());
+    assertThat(cookie.getName()).isEqualTo("a");
+    assertThat(cookie.getValue()).isEqualTo("android");
+    // Converting to a fixed date can cause rounding!
+    assertThat((double) cookie.getMaxAge()).isCloseTo(60.0, offset(1.0));
+    assertThat(cookie.getPath()).isEqualTo("/path");
+    assertThat(cookie.getSecure()).isTrue();
   }
 
   @Test public void testSendingCookiesFromStore() throws Exception {
-    MockWebServer server = new MockWebServer();
     server.enqueue(new MockResponse());
-    server.start();
     HttpUrl serverUrl = urlWithIpAddress(server, "/");
 
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
@@ -159,13 +154,11 @@ public void testNetscapeResponse() throws Exception {
     get(serverUrl);
     RecordedRequest request = server.takeRequest();
 
-    assertEquals("a=android; b=banana", request.getHeader("Cookie"));
+    assertThat(request.getHeader("Cookie")).isEqualTo("a=android; b=banana");
   }
 
   @Test public void cookieHandlerLikeAndroid() throws Exception {
-    final MockWebServer server = new MockWebServer();
     server.enqueue(new MockResponse());
-    server.start();
     final HttpUrl serverUrl = urlWithIpAddress(server, "/");
 
     CookieHandler androidCookieHandler = new CookieHandler() {
@@ -187,16 +180,14 @@ public void testNetscapeResponse() throws Exception {
     get(serverUrl);
     RecordedRequest request = server.takeRequest();
 
-    assertEquals("a=android; b=banana", request.getHeader("Cookie"));
+    assertThat(request.getHeader("Cookie")).isEqualTo("a=android; b=banana");
   }
 
   @Test public void receiveAndSendMultipleCookies() throws Exception {
-    MockWebServer server = new MockWebServer();
     server.enqueue(new MockResponse()
         .addHeader("Set-Cookie", "a=android")
         .addHeader("Set-Cookie", "b=banana"));
     server.enqueue(new MockResponse());
-    server.start();
 
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     client = client.newBuilder()
@@ -205,11 +196,11 @@ public void testNetscapeResponse() throws Exception {
 
     get(urlWithIpAddress(server, "/"));
     RecordedRequest request1 = server.takeRequest();
-    assertNull(request1.getHeader("Cookie"));
+    assertThat(request1.getHeader("Cookie")).isNull();
 
     get(urlWithIpAddress(server, "/"));
     RecordedRequest request2 = server.takeRequest();
-    assertEquals("a=android; b=banana", request2.getHeader("Cookie"));
+    assertThat(request2.getHeader("Cookie")).isEqualTo("a=android; b=banana");
   }
 
   @Test public void testRedirectsDoNotIncludeTooManyCookies() throws Exception {
@@ -239,7 +230,7 @@ public void testNetscapeResponse() throws Exception {
     get(redirectSourceUrl);
     RecordedRequest request = redirectSource.takeRequest();
 
-    assertEquals("c=cookie", request.getHeader("Cookie"));
+    assertThat(request.getHeader("Cookie")).isEqualTo("c=cookie");
 
     for (String header : redirectTarget.takeRequest().getHeaders().names()) {
       if (header.startsWith("Cookie")) {
@@ -261,16 +252,14 @@ public void testNetscapeResponse() throws Exception {
         }))
         .build();
 
-    MockWebServer server = new MockWebServer();
     server.enqueue(new MockResponse());
-    server.start();
 
     get(server.url("/"));
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("Bar=bar; Baz=baz", request.getHeader("Cookie"));
-    assertNull(request.getHeader("Cookie2"));
-    assertNull(request.getHeader("Quux"));
+    assertThat(request.getHeader("Cookie")).isEqualTo("Bar=bar; Baz=baz");
+    assertThat(request.getHeader("Cookie2")).isNull();
+    assertThat(request.getHeader("Quux")).isNull();
   }
 
   @Test public void acceptOriginalServerMatchesSubdomain() throws Exception {
@@ -278,12 +267,12 @@ public void testNetscapeResponse() throws Exception {
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
     HttpUrl url = HttpUrl.get("https://www.squareup.com/");
-    cookieJar.saveFromResponse(url, Arrays.asList(
+    cookieJar.saveFromResponse(url, asList(
         Cookie.parse(url, "a=android; Domain=squareup.com")));
     List<Cookie> actualCookies = cookieJar.loadForRequest(url);
-    assertEquals(1, actualCookies.size());
-    assertEquals("a", actualCookies.get(0).name());
-    assertEquals("android", actualCookies.get(0).value());
+    assertThat(actualCookies.size()).isEqualTo(1);
+    assertThat(actualCookies.get(0).name()).isEqualTo("a");
+    assertThat(actualCookies.get(0).value()).isEqualTo("android");
   }
 
   @Test public void acceptOriginalServerMatchesRfc2965Dot() throws Exception {
@@ -291,12 +280,12 @@ public void testNetscapeResponse() throws Exception {
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
     HttpUrl url = HttpUrl.get("https://www.squareup.com/");
-    cookieJar.saveFromResponse(url, Arrays.asList(
+    cookieJar.saveFromResponse(url, asList(
         Cookie.parse(url, "a=android; Domain=.squareup.com")));
     List<Cookie> actualCookies = cookieJar.loadForRequest(url);
-    assertEquals(1, actualCookies.size());
-    assertEquals("a", actualCookies.get(0).name());
-    assertEquals("android", actualCookies.get(0).value());
+    assertThat(actualCookies.size()).isEqualTo(1);
+    assertThat(actualCookies.get(0).name()).isEqualTo("a");
+    assertThat(actualCookies.get(0).value()).isEqualTo("android");
   }
 
   @Test public void acceptOriginalServerMatchesExactly() throws Exception {
@@ -304,12 +293,12 @@ public void testNetscapeResponse() throws Exception {
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
     HttpUrl url = HttpUrl.get("https://squareup.com/");
-    cookieJar.saveFromResponse(url, Arrays.asList(
+    cookieJar.saveFromResponse(url, asList(
         Cookie.parse(url, "a=android; Domain=squareup.com")));
     List<Cookie> actualCookies = cookieJar.loadForRequest(url);
-    assertEquals(1, actualCookies.size());
-    assertEquals("a", actualCookies.get(0).name());
-    assertEquals("android", actualCookies.get(0).value());
+    assertThat(actualCookies.size()).isEqualTo(1);
+    assertThat(actualCookies.get(0).name()).isEqualTo("a");
+    assertThat(actualCookies.get(0).value()).isEqualTo("android");
   }
 
   @Test public void acceptOriginalServerDoesNotMatchDifferentServer() throws Exception {
@@ -317,12 +306,12 @@ public void testNetscapeResponse() throws Exception {
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
     HttpUrl url1 = HttpUrl.get("https://api.squareup.com/");
-    cookieJar.saveFromResponse(url1, Arrays.asList(
+    cookieJar.saveFromResponse(url1, asList(
         Cookie.parse(url1, "a=android; Domain=api.squareup.com")));
 
     HttpUrl url2 = HttpUrl.get("https://www.squareup.com/");
     List<Cookie> actualCookies = cookieJar.loadForRequest(url2);
-    assertEquals(Collections.<Cookie>emptyList(), actualCookies);
+    assertThat(actualCookies).isEmpty();
   }
 
   private HttpUrl urlWithIpAddress(MockWebServer server, String path) throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java b/okhttp/src/test/java/okhttp3/DelegatingSSLSocket.java
similarity index 94%
rename from okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
rename to okhttp/src/test/java/okhttp3/DelegatingSSLSocket.java
index e6c931b6ad..6647dfc4d9 100644
--- a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
+++ b/okhttp/src/test/java/okhttp3/DelegatingSSLSocket.java
@@ -287,6 +287,7 @@ public DelegatingSSLSocket(SSLSocket delegate) {
 
   // Java 9 methods.
 
+  @SuppressWarnings("MissingOverride") // Can only override with JDK 9+
   public SSLSession getHandshakeSession() {
     try {
       return (SSLSession) SSLSocket.class.getMethod("getHandshakeSession").invoke(delegate);
@@ -295,6 +296,7 @@ public SSLSession getHandshakeSession() {
     }
   }
 
+  @SuppressWarnings("MissingOverride") // Can only override with JDK 9+
   public String getApplicationProtocol() {
     try {
       return (String) SSLSocket.class.getMethod("getApplicationProtocol").invoke(delegate);
@@ -303,6 +305,7 @@ public String getApplicationProtocol() {
     }
   }
 
+  @SuppressWarnings("MissingOverride") // Can only override with JDK 9+
   public String getHandshakeApplicationProtocol() {
     try {
       return (String) SSLSocket.class.getMethod("getHandshakeApplicationProtocol").invoke(delegate);
@@ -311,6 +314,7 @@ public String getHandshakeApplicationProtocol() {
     }
   }
 
+  @SuppressWarnings("MissingOverride") // Can only override with JDK 9+
   public <T> Socket setOption(SocketOption<T> name, T value) throws IOException {
     try {
       SSLSocket.class.getMethod("setOption", SocketOption.class, Object.class).invoke(delegate, name, value);
@@ -320,7 +324,10 @@ public String getHandshakeApplicationProtocol() {
     }
   }
 
-  @SuppressWarnings("unchecked") // Using reflection to delegate.
+  @SuppressWarnings({
+      "MissingOverride", // Can only override with JDK 9+
+      "unchecked" // Using reflection to delegate.
+  })
   public <T> T getOption(SocketOption<T> name) throws IOException {
     try {
       return (T) SSLSocket.class.getMethod("getOption", SocketOption.class).invoke(delegate, name);
@@ -329,7 +336,10 @@ public String getHandshakeApplicationProtocol() {
     }
   }
 
-  @SuppressWarnings("unchecked") // Using reflection to delegate.
+  @SuppressWarnings({
+      "MissingOverride", // Can only override with JDK 9+
+      "unchecked" // Using reflection to delegate.
+  })
   public Set<SocketOption<?>> supportedOptions() {
     try {
       return (Set<SocketOption<?>>) SSLSocket.class.getMethod("supportedOptions").invoke(delegate);
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java b/okhttp/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
rename to okhttp/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingServerSocketFactory.java b/okhttp/src/test/java/okhttp3/DelegatingServerSocketFactory.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/DelegatingServerSocketFactory.java
rename to okhttp/src/test/java/okhttp3/DelegatingServerSocketFactory.java
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java b/okhttp/src/test/java/okhttp3/DelegatingSocketFactory.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
rename to okhttp/src/test/java/okhttp3/DelegatingSocketFactory.java
diff --git a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java b/okhttp/src/test/java/okhttp3/DispatcherTest.java
similarity index 72%
rename from okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
rename to okhttp/src/test/java/okhttp3/DispatcherTest.java
index 3e7b1cddef..b7d0291113 100644
--- a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
+++ b/okhttp/src/test/java/okhttp3/DispatcherTest.java
@@ -2,36 +2,25 @@
 
 import java.io.IOException;
 import java.io.InterruptedIOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.AbstractExecutorService;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
-import okhttp3.RealCall.AsyncCall;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
-import static okhttp3.TestUtil.defaultClient;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class DispatcherTest {
-  RecordingExecutor executor = new RecordingExecutor();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+
+  RecordingExecutor executor = new RecordingExecutor(this);
   RecordingCallback callback = new RecordingCallback();
   RecordingWebSocketListener webSocketListener = new RecordingWebSocketListener();
   Dispatcher dispatcher = new Dispatcher(executor);
   RecordingEventListener listener = new RecordingEventListener();
-  OkHttpClient client = defaultClient().newBuilder()
+  OkHttpClient client = clientTestRule.client.newBuilder()
       .dispatcher(dispatcher)
       .eventListener(listener)
       .build();
@@ -138,6 +127,18 @@
     executor.assertJobs("http://a/1");
   }
 
+  @Test public void enqueuedCallsStillRespectMaxCallsPerHost() throws Exception {
+    dispatcher.setMaxRequests(1);
+    dispatcher.setMaxRequestsPerHost(1);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/2")).enqueue(callback);
+    client.newCall(newRequest("http://b/3")).enqueue(callback);
+    dispatcher.setMaxRequests(3);
+    executor.finishJob("http://a/1");
+    executor.assertJobs("http://b/1");
+  }
+
   @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
     dispatcher.setMaxRequests(1);
     Call c1 = client.newCall(newRequest("http://a/1", "tag1"));
@@ -162,10 +163,10 @@
     a3.enqueue(callback);
     a4.enqueue(callback);
     a5.enqueue(callback);
-    assertEquals(3, dispatcher.runningCallsCount());
-    assertEquals(2, dispatcher.queuedCallsCount());
-    assertEquals(set(a1, a2, a3), set(dispatcher.runningCalls()));
-    assertEquals(set(a4, a5), set(dispatcher.queuedCalls()));
+    assertThat(dispatcher.runningCallsCount()).isEqualTo(3);
+    assertThat(dispatcher.queuedCallsCount()).isEqualTo(2);
+    assertThat(dispatcher.runningCalls()).containsExactlyInAnyOrder(a1, a2, a3);
+    assertThat(dispatcher.queuedCalls()).containsExactlyInAnyOrder(a4, a5);
   }
 
   @Test public void synchronousCallAccessors() throws Exception {
@@ -192,16 +193,16 @@
 
     // We created 4 calls and started 2 of them. That's 2 running calls and 0 queued.
     ready.await();
-    assertEquals(2, dispatcher.runningCallsCount());
-    assertEquals(0, dispatcher.queuedCallsCount());
-    assertEquals(set(a1, a2), set(dispatcher.runningCalls()));
-    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+    assertThat(dispatcher.runningCallsCount()).isEqualTo(2);
+    assertThat(dispatcher.queuedCallsCount()).isEqualTo(0);
+    assertThat(dispatcher.runningCalls()).containsExactlyInAnyOrder(a1, a2);
+    assertThat(dispatcher.queuedCalls()).isEmpty();
 
     // Cancel some calls. That doesn't impact running or queued.
     a2.cancel();
     a3.cancel();
-    assertEquals(set(a1, a2), set(dispatcher.runningCalls()));
-    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+    assertThat(dispatcher.runningCalls()).containsExactlyInAnyOrder(a1, a2);
+    assertThat(dispatcher.queuedCalls()).isEmpty();
 
     // Let the calls finish.
     waiting.countDown();
@@ -209,22 +210,22 @@
     t2.join();
 
     // Now we should have 0 running calls and 0 queued calls.
-    assertEquals(0, dispatcher.runningCallsCount());
-    assertEquals(0, dispatcher.queuedCallsCount());
-    assertEquals(Collections.emptyList(), dispatcher.runningCalls());
-    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+    assertThat(dispatcher.runningCallsCount()).isEqualTo(0);
+    assertThat(dispatcher.queuedCallsCount()).isEqualTo(0);
+    assertThat(dispatcher.runningCalls()).isEmpty();
+    assertThat(dispatcher.queuedCalls()).isEmpty();
 
-    assertTrue(a1.isExecuted());
-    assertFalse(a1.isCanceled());
+    assertThat(a1.isExecuted()).isTrue();
+    assertThat(a1.isCanceled()).isFalse();
 
-    assertTrue(a2.isExecuted());
-    assertTrue(a2.isCanceled());
+    assertThat(a2.isExecuted()).isTrue();
+    assertThat(a2.isCanceled()).isTrue();
 
-    assertFalse(a3.isExecuted());
-    assertTrue(a3.isCanceled());
+    assertThat(a3.isExecuted()).isFalse();
+    assertThat(a3.isCanceled()).isTrue();
 
-    assertFalse(a4.isExecuted());
-    assertFalse(a4.isCanceled());
+    assertThat(a4.isExecuted()).isFalse();
+    assertThat(a4.isCanceled()).isFalse();
   }
 
   @Test public void idleCallbackInvokedWhenIdle() throws Exception {
@@ -234,7 +235,7 @@
     client.newCall(newRequest("http://a/1")).enqueue(callback);
     client.newCall(newRequest("http://a/2")).enqueue(callback);
     executor.finishJob("http://a/1");
-    assertFalse(idle.get());
+    assertThat(idle.get()).isFalse();
 
     CountDownLatch ready = new CountDownLatch(1);
     CountDownLatch proceed = new CountDownLatch(1);
@@ -253,11 +254,11 @@
     Thread t1 = makeSynchronousCall(client.newCall(newRequest("http://a/3")));
     ready.await(5, SECONDS);
     executor.finishJob("http://a/2");
-    assertFalse(idle.get());
+    assertThat(idle.get()).isFalse();
 
     proceed.countDown();
     t1.join();
-    assertTrue(idle.get());
+    assertThat(idle.get()).isTrue();
   }
 
   @Test public void executionRejectedImmediately() throws Exception {
@@ -265,7 +266,7 @@
     executor.shutdown();
     client.newCall(request).enqueue(callback);
     callback.await(request.url()).assertFailure(InterruptedIOException.class);
-    assertEquals(Arrays.asList("CallStart", "CallFailed"), listener.recordedEventTypes());
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallFailed");
   }
 
   @Test public void executionRejectedAfterMaxRequestsChange() throws Exception {
@@ -278,8 +279,8 @@
     dispatcher.setMaxRequests(2); // Trigger promotion.
     callback.await(request2.url()).assertFailure(InterruptedIOException.class);
 
-    assertEquals(Arrays.asList("CallStart", "CallStart", "CallFailed"),
-        listener.recordedEventTypes());
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallStart",
+        "CallFailed");
   }
 
   @Test public void executionRejectedAfterMaxRequestsPerHostChange() throws Exception {
@@ -291,8 +292,8 @@
     client.newCall(request2).enqueue(callback);
     dispatcher.setMaxRequestsPerHost(2); // Trigger promotion.
     callback.await(request2.url()).assertFailure(InterruptedIOException.class);
-    assertEquals(Arrays.asList("CallStart", "CallStart", "CallFailed"),
-        listener.recordedEventTypes());
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallStart",
+        "CallFailed");
   }
 
   @Test public void executionRejectedAfterPrecedingCallFinishes() throws Exception {
@@ -304,17 +305,8 @@
     client.newCall(request2).enqueue(callback);
     executor.finishJob("http://a/1"); // Trigger promotion.
     callback.await(request2.url()).assertFailure(InterruptedIOException.class);
-    assertEquals(Arrays.asList("CallStart", "CallStart", "CallFailed"),
-        listener.recordedEventTypes());
-  }
-
-  @SafeVarargs
-  private final <T> Set<T> set(T... values) {
-    return set(Arrays.asList(values));
-  }
-
-  private <T> Set<T> set(List<T> list) {
-    return new LinkedHashSet<>(list);
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallStart",
+        "CallFailed");
   }
 
   private Thread makeSynchronousCall(Call call) {
@@ -329,56 +321,6 @@ private Thread makeSynchronousCall(Call call) {
     return thread;
   }
 
-  class RecordingExecutor extends AbstractExecutorService {
-    private boolean shutdown;
-    private List<AsyncCall> calls = new ArrayList<>();
-
-    @Override public void execute(Runnable command) {
-      if (shutdown) throw new RejectedExecutionException();
-      calls.add((AsyncCall) command);
-    }
-
-    public void assertJobs(String... expectedUrls) {
-      List<String> actualUrls = new ArrayList<>();
-      for (AsyncCall call : calls) {
-        actualUrls.add(call.request().url().toString());
-      }
-      assertEquals(Arrays.asList(expectedUrls), actualUrls);
-    }
-
-    public void finishJob(String url) {
-      for (Iterator<AsyncCall> i = calls.iterator(); i.hasNext(); ) {
-        AsyncCall call = i.next();
-        if (call.request().url().toString().equals(url)) {
-          i.remove();
-          dispatcher.finished(call);
-          return;
-        }
-      }
-      throw new AssertionError("No such job: " + url);
-    }
-
-    @Override public void shutdown() {
-      shutdown = true;
-    }
-
-    @Override public List<Runnable> shutdownNow() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public boolean isShutdown() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public boolean isTerminated() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public boolean awaitTermination(long timeout, TimeUnit unit) {
-      throw new UnsupportedOperationException();
-    }
-  }
-
   private Request newRequest(String url) {
     return new Request.Builder().url(url).build();
   }
diff --git a/okhttp/src/test/java/okhttp3/DuplexTest.java b/okhttp/src/test/java/okhttp3/DuplexTest.java
new file mode 100644
index 0000000000..84a1ed3f9e
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/DuplexTest.java
@@ -0,0 +1,535 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.ProtocolException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.duplex.AsyncRequestBody;
+import okhttp3.internal.duplex.MwsDuplexAccess;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.mockwebserver.internal.duplex.MockDuplexResponseBody;
+import okhttp3.tls.HandshakeCertificates;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.rules.Timeout;
+
+import static java.util.Arrays.asList;
+import static junit.framework.TestCase.assertTrue;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class DuplexTest {
+  @Rule public final PlatformRule platform = new PlatformRule();
+  @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+
+  private RecordingEventListener listener = new RecordingEventListener();
+  private HandshakeCertificates handshakeCertificates = localhost();
+  private OkHttpClient client = clientTestRule.client
+      .newBuilder()
+      .eventListener(listener)
+      .build();
+
+  @Before
+  public void checkHttp2() {
+    platform.assumeHttp2Support();
+  }
+
+  @Test public void http1DoesntSupportDuplex() throws IOException {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
+  @Test public void trueDuplexClientWritesFirst() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders(),
+        new MockDuplexResponseBody()
+            .receiveRequest("request A\n")
+            .sendResponse("response B\n")
+            .receiveRequest("request C\n")
+            .sendResponse("response D\n")
+            .receiveRequest("request E\n")
+            .sendResponse("response F\n")
+            .exhaustRequest()
+            .exhaustResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build());
+
+    try (Response response = call.execute()) {
+      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
+      requestBody.writeUtf8("request A\n");
+      requestBody.flush();
+
+      BufferedSource responseBody = response.body().source();
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response B");
+
+      requestBody.writeUtf8("request C\n");
+      requestBody.flush();
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response D");
+
+      requestBody.writeUtf8("request E\n");
+      requestBody.flush();
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response F");
+
+      requestBody.close();
+      assertThat(responseBody.readUtf8Line()).isNull();
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+  }
+
+  @Test public void trueDuplexServerWritesFirst() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders(),
+        new MockDuplexResponseBody()
+            .sendResponse("response A\n")
+            .receiveRequest("request B\n")
+            .sendResponse("response C\n")
+            .receiveRequest("request D\n")
+            .sendResponse("response E\n")
+            .receiveRequest("request F\n")
+            .exhaustResponse()
+            .exhaustRequest());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build());
+
+    try (Response response = call.execute()) {
+      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
+      BufferedSource responseBody = response.body().source();
+
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response A");
+      requestBody.writeUtf8("request B\n");
+      requestBody.flush();
+
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response C");
+      requestBody.writeUtf8("request D\n");
+      requestBody.flush();
+
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response E");
+      requestBody.writeUtf8("request F\n");
+      requestBody.flush();
+
+      assertThat(responseBody.readUtf8Line()).isNull();
+      requestBody.close();
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+  }
+
+  @Test public void clientReadsHeadersDataTrailers() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders()
+            .addHeader("h1", "v1")
+            .addHeader("h2", "v2")
+            .setTrailers(Headers.of("trailers", "boom")),
+        new MockDuplexResponseBody()
+            .sendResponse("ok")
+            .exhaustResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    try (Response response = call.execute()) {
+      assertThat(response.headers()).isEqualTo(Headers.of("h1", "v1", "h2", "v2"));
+
+      BufferedSource responseBody = response.body().source();
+      assertThat(responseBody.readUtf8(2)).isEqualTo("ok");
+      assertTrue(responseBody.exhausted());
+      assertThat(response.trailers()).isEqualTo(Headers.of("trailers", "boom"));
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+  }
+
+  @Test public void serverReadsHeadersData() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders()
+            .addHeader("h1", "v1")
+            .addHeader("h2", "v2"),
+        new MockDuplexResponseBody()
+            .exhaustResponse()
+            .receiveRequest("hey\n")
+            .receiveRequest("whats going on\n")
+            .exhaustRequest());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method("POST", new AsyncRequestBody())
+        .build();
+    Call call = client.newCall(request);
+
+    try (Response response = call.execute()) {
+      BufferedSink sink = ((AsyncRequestBody) request.body()).takeSink();
+      sink.writeUtf8("hey\n");
+      sink.writeUtf8("whats going on\n");
+      sink.close();
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+  }
+
+  @Test public void requestBodyEndsAfterResponseBody() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders(),
+        new MockDuplexResponseBody()
+            .exhaustResponse()
+            .receiveRequest("request A\n")
+            .exhaustRequest());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build());
+
+    try (Response response = call.execute()) {
+      BufferedSource responseBody = response.body().source();
+      assertTrue(responseBody.exhausted());
+
+      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
+      requestBody.writeUtf8("request A\n");
+      requestBody.close();
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+
+    assertThat(listener.recordedEventTypes()).containsExactly(
+        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
+        "RequestHeadersStart", "RequestHeadersEnd", "RequestBodyStart", "ResponseHeadersStart",
+        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "RequestBodyEnd",
+        "ConnectionReleased", "CallEnd");
+  }
+
+  @Test public void duplexWith100Continue() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders()
+            .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE),
+        new MockDuplexResponseBody()
+            .receiveRequest("request body\n")
+            .sendResponse("response body\n")
+            .exhaustRequest());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(new AsyncRequestBody())
+        .build());
+
+    try (Response response = call.execute()) {
+      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
+      requestBody.writeUtf8("request body\n");
+      requestBody.flush();
+
+      BufferedSource responseBody = response.body().source();
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response body");
+
+      requestBody.close();
+      assertThat(responseBody.readUtf8Line()).isNull();
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+  }
+
+  /**
+   * Duplex calls that have follow-ups are weird. By the time we know there's a follow-up we've
+   * already split off another thread to stream the request body. Because we permit at most one
+   * exchange at a time we break the request stream out from under that writer.
+   */
+  @Test public void duplexWithRedirect() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    CountDownLatch duplexResponseSent = new CountDownLatch(1);
+    listener = new RecordingEventListener() {
+      @Override public void responseHeadersEnd(Call call, Response response) {
+        try {
+          // Wait for the server to send the duplex response before acting on the 301 response
+          // and resetting the stream.
+          duplexResponseSent.await();
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+        super.responseHeadersEnd(call, response);
+      }
+    };
+
+    client = client.newBuilder()
+        .eventListener(listener)
+        .build();
+
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders()
+            .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+            .addHeader("Location: /b"),
+        new MockDuplexResponseBody()
+            .sendResponse("/a has moved!\n", duplexResponseSent)
+            .requestIOException()
+            .exhaustResponse());
+    server.enqueue(new MockResponse()
+        .setBody("this is /b"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build());
+
+    try (Response response = call.execute()) {
+      BufferedSource responseBody = response.body().source();
+      assertThat(responseBody.readUtf8Line()).isEqualTo("this is /b");
+    }
+
+    BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
+    try {
+      requestBody.writeUtf8("request body\n");
+      requestBody.flush();
+      fail();
+    } catch (IOException expected) {
+      assertThat(expected.getMessage()).isEqualTo("stream was reset: CANCEL");
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+
+    assertThat(listener.recordedEventTypes()).containsExactly(
+        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
+        "RequestHeadersStart", "RequestHeadersEnd", "RequestBodyStart", "ResponseHeadersStart",
+        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd", "RequestFailed");
+  }
+
+  /**
+   * Auth requires follow-ups. Unlike redirects, the auth follow-up also has a request body. This
+   * test makes a single call with two duplex requests!
+   */
+  @Test public void duplexWithAuthChallenge() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    String credential = Credentials.basic("jesse", "secret");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential, null))
+        .build();
+
+    MockDuplexResponseBody mockResponseBody1 = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders()
+            .setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED),
+        new MockDuplexResponseBody()
+            .sendResponse("please authenticate!\n")
+            .requestIOException()
+            .exhaustResponse());
+    MockDuplexResponseBody mockResponseBody2 = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders(),
+        new MockDuplexResponseBody()
+            .sendResponse("response body\n")
+            .exhaustResponse()
+            .receiveRequest("request body\n")
+            .exhaustRequest());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build());
+
+    Response response2 = call.execute();
+
+    // First duplex request is detached with violence.
+    BufferedSink requestBody1 = ((AsyncRequestBody) call.request().body()).takeSink();
+    try {
+      requestBody1.writeUtf8("not authenticated\n");
+      requestBody1.flush();
+      fail();
+    } catch (IOException expected) {
+      assertThat(expected.getMessage()).isEqualTo("stream was reset: CANCEL");
+    }
+    mockResponseBody1.awaitSuccess();
+
+    // Second duplex request proceeds normally.
+    BufferedSink requestBody2 = ((AsyncRequestBody) call.request().body()).takeSink();
+    requestBody2.writeUtf8("request body\n");
+    requestBody2.close();
+    BufferedSource responseBody2 = response2.body().source();
+    assertThat(responseBody2.readUtf8Line()).isEqualTo("response body");
+    assertTrue(responseBody2.exhausted());
+    mockResponseBody2.awaitSuccess();
+
+    // No more requests attempted!
+    ((AsyncRequestBody) call.request().body()).assertNoMoreSinks();
+  }
+
+  @Test public void fullCallTimeoutAppliesToSetup() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e.getMessage()).isEqualTo("timeout");
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void fullCallTimeoutDoesNotApplyOnceConnected() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders(),
+        new MockDuplexResponseBody()
+            .sendResponse("response A\n")
+            .sleep(750, TimeUnit.MILLISECONDS)
+            .sendResponse("response B\n")
+            .receiveRequest("request C\n")
+            .exhaustResponse()
+            .exhaustRequest());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(500, TimeUnit.MILLISECONDS); // Long enough for the first TLS handshake.
+
+    try (Response response = call.execute()) {
+      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
+
+      BufferedSource responseBody = response.body().source();
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response A");
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response B");
+
+      requestBody.writeUtf8("request C\n");
+      requestBody.close();
+      assertThat(responseBody.readUtf8Line()).isNull();
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+  }
+
+  @Test public void duplexWithRewriteInterceptors() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders(),
+        new MockDuplexResponseBody()
+            .receiveRequest("REQUEST A\n")
+            .sendResponse("response B\n")
+            .exhaustRequest()
+            .exhaustResponse());
+
+    client = client.newBuilder()
+        .addInterceptor(new UppercaseRequestInterceptor())
+        .addInterceptor(new UppercaseResponseInterceptor())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build());
+
+    try (Response response = call.execute()) {
+      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
+      requestBody.writeUtf8("request A\n");
+      requestBody.flush();
+
+      BufferedSource responseBody = response.body().source();
+      assertThat(responseBody.readUtf8Line()).isEqualTo("RESPONSE B");
+
+      requestBody.close();
+      assertThat(responseBody.readUtf8Line()).isNull();
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+  }
+
+  private MockDuplexResponseBody enqueueResponseWithBody(
+      MockResponse response, MockDuplexResponseBody body) {
+    MwsDuplexAccess.instance.setBody(response, body);
+    server.enqueue(response);
+    return body;
+  }
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
+   */
+  private void enableProtocol(Protocol protocol) {
+    enableTls();
+    client = client.newBuilder()
+        .protocols(asList(protocol, Protocol.HTTP_1_1))
+        .build();
+    server.setProtocols(client.protocols());
+  }
+
+  private void enableTls() {
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp/src/test/java/okhttp3/EventListenerTest.java
similarity index 69%
rename from okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
rename to okhttp/src/test/java/okhttp3/EventListenerTest.java
index fd5f2c2813..8b3947bf74 100644
--- a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp/src/test/java/okhttp3/EventListenerTest.java
@@ -21,7 +21,6 @@
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 import java.net.UnknownHostException;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
@@ -38,10 +37,12 @@
 import okhttp3.RecordingEventListener.RequestBodyEnd;
 import okhttp3.RecordingEventListener.RequestHeadersEnd;
 import okhttp3.RecordingEventListener.ResponseBodyEnd;
+import okhttp3.RecordingEventListener.ResponseFailed;
 import okhttp3.RecordingEventListener.ResponseHeadersEnd;
 import okhttp3.RecordingEventListener.SecureConnectEnd;
 import okhttp3.RecordingEventListener.SecureConnectStart;
 import okhttp3.internal.DoubleInetAddressDns;
+import okhttp3.internal.Internal;
 import okhttp3.internal.RecordingOkAuthenticator;
 import okhttp3.logging.HttpLoggingInterceptor;
 import okhttp3.mockwebserver.MockResponse;
@@ -55,43 +56,40 @@
 import org.hamcrest.Description;
 import org.hamcrest.Matcher;
 import org.junit.After;
+import org.junit.Assert;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.Timeout;
 
 import static java.util.Arrays.asList;
-import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.hamcrest.CoreMatchers.any;
-import static org.hamcrest.CoreMatchers.either;
 import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.junit.Assume.assumeThat;
 
 public final class EventListenerTest {
   public static final Matcher<Response> anyResponse = CoreMatchers.any(Response.class);
+
+  @Rule public final PlatformRule platform = new PlatformRule();
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+  @Rule public final Timeout timeoutRule = new Timeout(20, TimeUnit.SECONDS);
 
   private final RecordingEventListener listener = new RecordingEventListener();
   private final HandshakeCertificates handshakeCertificates = localhost();
 
-  private OkHttpClient client;
+  private OkHttpClient client = clientTestRule.client;
   private SocksProxy socksProxy;
 
   @Before public void setUp() {
-    client = defaultClient().newBuilder()
+    client = clientTestRule.client.newBuilder()
         .eventListener(listener)
         .build();
 
-    listener.forbidLock(client.connectionPool());
+    listener.forbidLock(Internal.instance.realConnectionPool(client.connectionPool()));
     listener.forbidLock(client.dispatcher());
   }
 
@@ -109,15 +107,14 @@
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
-    assertEquals("abc", response.body().string());
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.body().string()).isEqualTo("abc");
     response.body().close();
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
   @Test public void successfulCallEventSequenceForEnqueue() throws Exception {
@@ -144,11 +141,10 @@
 
     completionLatch.await();
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
   @Test public void failedCallEventSequence() {
@@ -163,13 +159,13 @@
       call.execute();
       fail();
     } catch (IOException expected) {
-      assertThat(expected.getMessage(), either(equalTo("timeout")).or(equalTo("Read timed out")));
+      assertThat(expected.getMessage()).isIn("timeout", "Read timed out");
     }
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ConnectionReleased", "CallFailed");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseFailed", "ConnectionReleased",
+        "CallFailed");
   }
 
   @Test public void failedDribbledCallEventSequence() throws IOException {
@@ -188,19 +184,18 @@
 
     Response response = call.execute();
     try {
-      response.body.string();
+      response.body().string();
       fail();
     } catch (IOException expected) {
-      assertThat(expected.getMessage(), equalTo("unexpected end of stream"));
+      assertThat(expected.getMessage()).isEqualTo("unexpected end of stream");
     }
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "CallFailed");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
-    ResponseBodyEnd bodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);
-    assertEquals(5, bodyEnd.bytesRead);
+        "ResponseFailed", "ConnectionReleased", "CallFailed");
+    ResponseFailed responseFailed = listener.removeUpToEvent(ResponseFailed.class);
+    assertThat(responseFailed.ioe.getMessage()).isEqualTo("unexpected end of stream");
   }
 
   @Test public void canceledCallEventSequence() {
@@ -212,11 +207,10 @@
       call.execute();
       fail();
     } catch (IOException expected) {
-      assertEquals("Canceled", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("Canceled");
     }
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "CallFailed");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallFailed");
   }
 
   private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throws IOException {
@@ -224,23 +218,22 @@ private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throw
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().string();
     response.body().close();
 
     assumeThat(response, responseMatcher);
 
-    List<String> expectedEvents = asList("CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+    assertThat(listener.recordedEventTypes()).containsExactly(
+        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
         "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
         "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
         "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-
-    assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
   @Test public void secondCallEventSequence() throws IOException {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
     server.enqueue(new MockResponse());
     server.enqueue(new MockResponse());
 
@@ -256,11 +249,9 @@ private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throw
     Response response = call.execute();
     response.close();
 
-    List<String> expectedEvents = asList("CallStart", "ConnectionAcquired",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "ConnectionAcquired",
         "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
         "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-
-    assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
   private void assertBytesReadWritten(RecordingEventListener listener,
@@ -269,33 +260,32 @@ private void assertBytesReadWritten(RecordingEventListener listener,
 
     if (requestHeaderLength != null) {
       RequestHeadersEnd responseHeadersEnd = listener.removeUpToEvent(RequestHeadersEnd.class);
-      assertThat("request header length", responseHeadersEnd.headerLength, requestHeaderLength);
+      Assert.assertThat("request header length", responseHeadersEnd.headerLength,
+          requestHeaderLength);
     } else {
-      assertFalse("Found RequestHeadersEnd",
-          listener.recordedEventTypes().contains("RequestHeadersEnd"));
+      assertThat(listener.recordedEventTypes()).doesNotContain("RequestHeadersEnd");
     }
 
     if (requestBodyBytes != null) {
       RequestBodyEnd responseBodyEnd = listener.removeUpToEvent(RequestBodyEnd.class);
-      assertThat("request body bytes", responseBodyEnd.bytesWritten, requestBodyBytes);
+      Assert.assertThat("request body bytes", responseBodyEnd.bytesWritten, requestBodyBytes);
     } else {
-      assertFalse("Found RequestBodyEnd", listener.recordedEventTypes().contains("RequestBodyEnd"));
+      assertThat(listener.recordedEventTypes()).doesNotContain("RequestBodyEnd");
     }
 
     if (responseHeaderLength != null) {
       ResponseHeadersEnd responseHeadersEnd = listener.removeUpToEvent(ResponseHeadersEnd.class);
-      assertThat("response header length", responseHeadersEnd.headerLength, responseHeaderLength);
+      Assert.assertThat("response header length", responseHeadersEnd.headerLength,
+          responseHeaderLength);
     } else {
-      assertFalse("Found ResponseHeadersEnd",
-          listener.recordedEventTypes().contains("ResponseHeadersEnd"));
+      assertThat(listener.recordedEventTypes()).doesNotContain("ResponseHeadersEnd");
     }
 
     if (responseBodyBytes != null) {
       ResponseBodyEnd responseBodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);
-      assertThat("response body bytes", responseBodyEnd.bytesRead, responseBodyBytes);
+      Assert.assertThat("response body bytes", responseBodyEnd.bytesRead, responseBodyBytes);
     } else {
-      assertFalse("Found ResponseBodyEnd",
-          listener.recordedEventTypes().contains("ResponseBodyEnd"));
+      assertThat(listener.recordedEventTypes()).doesNotContain("ResponseBodyEnd");
     }
   }
 
@@ -306,7 +296,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
       }
 
       @Override public boolean matches(Object o) {
-        return ((Long)o) > value;
+        return ((Long) o) > value;
       }
     };
   }
@@ -318,7 +308,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
       }
 
       @Override public boolean matches(Object o) {
-        return ((Long)o) < value;
+        return ((Long) o) < value;
       }
     };
   }
@@ -330,14 +320,14 @@ private void assertBytesReadWritten(RecordingEventListener listener,
       }
 
       @Override public boolean matches(Object o) {
-        return ((Response)o).protocol == protocol;
+        return ((Response) o).protocol() == protocol;
       }
     };
   }
 
   @Test public void successfulEmptyH2CallEventSequence() throws IOException {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
     server.enqueue(new MockResponse());
 
     assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));
@@ -348,7 +338,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
 
   @Test public void successfulEmptyHttpsCallEventSequence() throws IOException {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    server.setProtocols(asList(Protocol.HTTP_1_1));
     server.enqueue(new MockResponse()
         .setBody("abc"));
 
@@ -360,7 +350,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
 
   @Test public void successfulChunkedHttpsCallEventSequence() throws IOException {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    server.setProtocols(asList(Protocol.HTTP_1_1));
     server.enqueue(
         new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
 
@@ -372,7 +362,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
 
   @Test public void successfulChunkedH2CallEventSequence() throws IOException {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
     server.enqueue(
         new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
 
@@ -389,17 +379,17 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     DnsStart dnsStart = listener.removeUpToEvent(DnsStart.class);
-    assertSame(call, dnsStart.call);
-    assertEquals(server.getHostName(), dnsStart.domainName);
+    assertThat(dnsStart.call).isSameAs(call);
+    assertThat(dnsStart.domainName).isEqualTo(server.getHostName());
 
     DnsEnd dnsEnd = listener.removeUpToEvent(DnsEnd.class);
-    assertSame(call, dnsEnd.call);
-    assertEquals(server.getHostName(), dnsEnd.domainName);
-    assertEquals(1, dnsEnd.inetAddressList.size());
+    assertThat(dnsEnd.call).isSameAs(call);
+    assertThat(dnsEnd.domainName).isEqualTo(server.getHostName());
+    assertThat(dnsEnd.inetAddressList.size()).isEqualTo(1);
   }
 
   @Test public void noDnsLookupOnPooledConnection() throws IOException {
@@ -411,7 +401,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response1 = call1.execute();
-    assertEquals(200, response1.code());
+    assertThat(response1.code()).isEqualTo(200);
     response1.body().close();
 
     listener.clearAllEvents();
@@ -420,12 +410,12 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals(200, response2.code());
+    assertThat(response2.code()).isEqualTo(200);
     response2.body().close();
 
     List<String> recordedEvents = listener.recordedEventTypes();
-    assertFalse(recordedEvents.contains("DnsStart"));
-    assertFalse(recordedEvents.contains("DnsEnd"));
+    assertThat(recordedEvents).doesNotContain("DnsStart");
+    assertThat(recordedEvents).doesNotContain("DnsEnd");
   }
 
   @Test public void multipleDnsLookupsForSingleCall() throws IOException {
@@ -446,7 +436,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url("http://fakeurl:" + server.getPort())
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     listener.removeUpToEvent(DnsStart.class);
@@ -471,8 +461,8 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     listener.removeUpToEvent(DnsStart.class);
 
     CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    assertSame(call, callFailed.call);
-    assertTrue(callFailed.ioe instanceof UnknownHostException);
+    assertThat(callFailed.call).isSameAs(call);
+    assertThat(callFailed.ioe).isInstanceOf(UnknownHostException.class);
   }
 
   @Test public void emptyDnsLookup() {
@@ -493,8 +483,8 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     listener.removeUpToEvent(DnsStart.class);
 
     CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    assertSame(call, callFailed.call);
-    assertTrue(callFailed.ioe instanceof UnknownHostException);
+    assertThat(callFailed.call).isSameAs(call);
+    assertThat(callFailed.ioe).isInstanceOf(UnknownHostException.class);
   }
 
   @Test public void successfulConnect() throws IOException {
@@ -504,21 +494,21 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     InetAddress address = client.dns().lookup(server.getHostName()).get(0);
     InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
 
     ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
-    assertSame(call, connectStart.call);
-    assertEquals(expectedAddress, connectStart.inetSocketAddress);
-    assertEquals(Proxy.NO_PROXY, connectStart.proxy);
+    assertThat(connectStart.call).isSameAs(call);
+    assertThat(connectStart.inetSocketAddress).isEqualTo(expectedAddress);
+    assertThat(connectStart.proxy).isEqualTo(Proxy.NO_PROXY);
 
     ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
-    assertSame(call, connectEnd.call);
-    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
-    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+    assertThat(connectEnd.call).isSameAs(call);
+    assertThat(connectEnd.inetSocketAddress).isEqualTo(expectedAddress);
+    assertThat(connectEnd.protocol).isEqualTo(Protocol.HTTP_1_1);
   }
 
   @Test public void failedConnect() throws UnknownHostException {
@@ -539,15 +529,15 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
 
     ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
-    assertSame(call, connectStart.call);
-    assertEquals(expectedAddress, connectStart.inetSocketAddress);
-    assertEquals(Proxy.NO_PROXY, connectStart.proxy);
+    assertThat(connectStart.call).isSameAs(call);
+    assertThat(connectStart.inetSocketAddress).isEqualTo(expectedAddress);
+    assertThat(connectStart.proxy).isEqualTo(Proxy.NO_PROXY);
 
     ConnectFailed connectFailed = listener.removeUpToEvent(ConnectFailed.class);
-    assertSame(call, connectFailed.call);
-    assertEquals(expectedAddress, connectFailed.inetSocketAddress);
-    assertNull(connectFailed.protocol);
-    assertNotNull(connectFailed.ioe);
+    assertThat(connectFailed.call).isSameAs(call);
+    assertThat(connectFailed.inetSocketAddress).isEqualTo(expectedAddress);
+    assertThat(connectFailed.protocol).isNull();
+    assertThat(connectFailed.ioe).isNotNull();
   }
 
   @Test public void multipleConnectsForSingleCall() throws IOException {
@@ -564,7 +554,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     listener.removeUpToEvent(ConnectStart.class);
@@ -584,21 +574,21 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url("http://www.fakeurl")
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     InetAddress address = client.dns().lookup(server.getHostName()).get(0);
     InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
 
     ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
-    assertSame(call, connectStart.call);
-    assertEquals(expectedAddress, connectStart.inetSocketAddress);
-    assertEquals(server.toProxyAddress(), connectStart.proxy);
+    assertThat(connectStart.call).isSameAs(call);
+    assertThat(connectStart.inetSocketAddress).isEqualTo(expectedAddress);
+    assertThat(connectStart.proxy).isEqualTo(server.toProxyAddress());
 
     ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
-    assertSame(call, connectEnd.call);
-    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
-    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+    assertThat(connectEnd.call).isSameAs(call);
+    assertThat(connectEnd.inetSocketAddress).isEqualTo(expectedAddress);
+    assertThat(connectEnd.protocol).isEqualTo(Protocol.HTTP_1_1);
   }
 
   @Test public void successfulSocksProxyConnect() throws Exception {
@@ -616,21 +606,21 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url("http://" + SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS + ":" + server.getPort())
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     InetSocketAddress expectedAddress = InetSocketAddress.createUnresolved(
         SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS, server.getPort());
 
     ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
-    assertSame(call, connectStart.call);
-    assertEquals(expectedAddress, connectStart.inetSocketAddress);
-    assertEquals(proxy, connectStart.proxy);
+    assertThat(connectStart.call).isSameAs(call);
+    assertThat(connectStart.inetSocketAddress).isEqualTo(expectedAddress);
+    assertThat(connectStart.proxy).isEqualTo(proxy);
 
     ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
-    assertSame(call, connectEnd.call);
-    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
-    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+    assertThat(connectEnd.call).isSameAs(call);
+    assertThat(connectEnd.inetSocketAddress).isEqualTo(expectedAddress);
+    assertThat(connectEnd.protocol).isEqualTo(Protocol.HTTP_1_1);
   }
 
   @Test public void authenticatingTunnelProxyConnect() throws IOException {
@@ -652,13 +642,13 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     listener.removeUpToEvent(ConnectStart.class);
 
     ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
-    assertNull(connectEnd.protocol);
+    assertThat(connectEnd.protocol).isNull();
 
     listener.removeUpToEvent(ConnectStart.class);
     listener.removeUpToEvent(ConnectEnd.class);
@@ -672,15 +662,15 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
-    assertSame(call, secureStart.call);
+    assertThat(secureStart.call).isSameAs(call);
 
     SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
-    assertSame(call, secureEnd.call);
-    assertNotNull(secureEnd.handshake);
+    assertThat(secureEnd.call).isSameAs(call);
+    assertThat(secureEnd.handshake).isNotNull();
   }
 
   @Test public void failedSecureConnect() {
@@ -698,11 +688,11 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     }
 
     SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
-    assertSame(call, secureStart.call);
+    assertThat(secureStart.call).isSameAs(call);
 
     CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    assertSame(call, callFailed.call);
-    assertNotNull(callFailed.ioe);
+    assertThat(callFailed.call).isSameAs(call);
+    assertThat(callFailed.ioe).isNotNull();
   }
 
   @Test public void secureConnectWithTunnel() throws IOException {
@@ -719,15 +709,15 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
-    assertSame(call, secureStart.call);
+    assertThat(secureStart.call).isSameAs(call);
 
     SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
-    assertSame(call, secureEnd.call);
-    assertNotNull(secureEnd.handshake);
+    assertThat(secureEnd.call).isSameAs(call);
+    assertThat(secureEnd.handshake).isNotNull();
   }
 
   @Test public void multipleSecureConnectsForSingleCall() throws IOException {
@@ -744,7 +734,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     listener.removeUpToEvent(SecureConnectStart.class);
@@ -768,7 +758,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response1 = call1.execute();
-    assertEquals(200, response1.code());
+    assertThat(response1.code()).isEqualTo(200);
     response1.body().close();
 
     listener.clearAllEvents();
@@ -777,12 +767,12 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals(200, response2.code());
+    assertThat(response2.code()).isEqualTo(200);
     response2.body().close();
 
     List<String> recordedEvents = listener.recordedEventTypes();
-    assertFalse(recordedEvents.contains("SecureConnectStart"));
-    assertFalse(recordedEvents.contains("SecureConnectEnd"));
+    assertThat(recordedEvents).doesNotContain("SecureConnectStart");
+    assertThat(recordedEvents).doesNotContain("SecureConnectEnd");
   }
 
   @Test public void successfulConnectionFound() throws IOException {
@@ -792,12 +782,12 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     ConnectionAcquired connectionAcquired = listener.removeUpToEvent(ConnectionAcquired.class);
-    assertSame(call, connectionAcquired.call);
-    assertNotNull(connectionAcquired.connection);
+    assertThat(connectionAcquired.call).isSameAs(call);
+    assertThat(connectionAcquired.connection).isNotNull();
   }
 
   @Test public void noConnectionFoundOnFollowUp() throws IOException {
@@ -811,12 +801,12 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("ABC", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABC");
 
     listener.removeUpToEvent(ConnectionAcquired.class);
 
     List<String> remainingEvents = listener.recordedEventTypes();
-    assertFalse(remainingEvents.contains("ConnectionAcquired"));
+    assertThat(remainingEvents).doesNotContain("ConnectionAcquired");
   }
 
   @Test public void pooledConnectionFound() throws IOException {
@@ -828,7 +818,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response1 = call1.execute();
-    assertEquals(200, response1.code());
+    assertThat(response1.code()).isEqualTo(200);
     response1.body().close();
 
     ConnectionAcquired connectionAcquired1 = listener.removeUpToEvent(ConnectionAcquired.class);
@@ -838,11 +828,12 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals(200, response2.code());
+    assertThat(response2.code()).isEqualTo(200);
     response2.body().close();
 
     ConnectionAcquired connectionAcquired2 = listener.removeUpToEvent(ConnectionAcquired.class);
-    assertSame(connectionAcquired1.connection, connectionAcquired2.connection);
+    assertThat(connectionAcquired2.connection).isSameAs(
+        connectionAcquired1.connection);
   }
 
   @Test public void multipleConnectionsFoundForSingleCall() throws IOException {
@@ -857,7 +848,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("ABC", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABC");
 
     listener.removeUpToEvent(ConnectionAcquired.class);
     listener.removeUpToEvent(ConnectionAcquired.class);
@@ -865,13 +856,15 @@ private void assertBytesReadWritten(RecordingEventListener listener,
 
   @Test public void responseBodyFailHttp1OverHttps() throws IOException {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    server.setProtocols(asList(Protocol.HTTP_1_1));
     responseBodyFail(Protocol.HTTP_1_1);
   }
 
   @Test public void responseBodyFailHttp2OverHttps() throws IOException {
+    platform.assumeHttp2Support();
+
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
     responseBodyFail(Protocol.HTTP_2);
   }
 
@@ -894,15 +887,15 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
       // soft failure since client may not support depending on Platform
       assumeThat(response, matchesProtocol(Protocol.HTTP_2));
     }
-    assertEquals(expectedProtocol, response.protocol());
+    assertThat(response.protocol()).isEqualTo(expectedProtocol);
     try {
-      response.body.string();
+      response.body().string();
       fail();
     } catch (IOException expected) {
     }
 
     CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    assertNotNull(callFailed.ioe);
+    assertThat(callFailed.ioe).isNotNull();
   }
 
   @Test public void emptyResponseBody() throws IOException {
@@ -917,14 +910,12 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
     Response response = call.execute();
     response.body().close();
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
-  @Ignore("CallEnd not emitted")
   @Test public void emptyResponseBodyConnectionClose() throws IOException {
     server.enqueue(new MockResponse()
         .addHeader("Connection", "close")
@@ -936,14 +927,12 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
     Response response = call.execute();
     response.body().close();
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
-  @Ignore("this reports CallFailed not CallEnd")
   @Test public void responseBodyClosedClosedWithoutReadingAllData() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("abc")
@@ -956,44 +945,110 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
     Response response = call.execute();
     response.body().close();
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
-  @Test public void requestBodyFailHttp1OverHttps() throws IOException {
+  @Test public void requestBodyFailHttp1OverHttps() {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
-    requestBodyFail();
+    server.setProtocols(asList(Protocol.HTTP_1_1));
+
+    requestBodyFail(Protocol.HTTP_1_1);
   }
 
-  @Test public void requestBodyFailHttp2OverHttps() throws IOException {
+  @Test public void requestBodyFailHttp2OverHttps() {
+    platform.assumeHttp2Support();
+
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    requestBodyFail();
+    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+
+    requestBodyFail(Protocol.HTTP_2);
+  }
+
+  @Test public void requestBodyFailHttp() {
+    requestBodyFail(null);
+  }
+
+  private void requestBodyFail(@Nullable Protocol expectedProtocol) {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
+
+    NonCompletingRequestBody request = new NonCompletingRequestBody();
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(request)
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    if (expectedProtocol != null) {
+      ConnectionAcquired connectionAcquired = listener.removeUpToEvent(ConnectionAcquired.class);
+      assertThat(connectionAcquired.connection.protocol()).isEqualTo(expectedProtocol);
+    }
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertThat(callFailed.ioe).isNotNull();
+
+    assertThat(request.ioe).isNotNull();
   }
 
-  @Test public void requestBodyFailHttp() throws IOException {
-    requestBodyFail();
+  private class NonCompletingRequestBody extends RequestBody {
+    IOException ioe;
+
+    @Override public MediaType contentType() {
+      return MediaType.get("text/plain");
+    }
+
+    @Override public long contentLength() {
+      return 1024 * 1024 * 4;
+    }
+
+    @Override public void writeTo(BufferedSink sink) throws IOException {
+      try {
+        writeChunk(sink);
+        writeChunk(sink);
+        writeChunk(sink);
+        writeChunk(sink);
+        Thread.sleep(1000);
+        writeChunk(sink);
+        writeChunk(sink);
+      } catch (IOException e) {
+        ioe = e;
+      } catch (InterruptedException e) {
+      }
+    }
+
+    private void writeChunk(BufferedSink sink) throws IOException {
+      sink.write(new byte[1024 * 512]);
+      sink.flush();
+    }
   }
 
-  private void requestBodyFail() {
-    // Stream a 8 MiB body so the disconnect will happen before the server has read everything.
+  @Test public void requestBodyMultipleFailuresReportedOnlyOnce() {
     RequestBody requestBody = new RequestBody() {
       @Override public MediaType contentType() {
         return MediaType.get("text/plain");
       }
 
       @Override public long contentLength() {
-        return 1024 * 8192;
+        return 1024 * 1024 * 256;
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
+        int failureCount = 0;
         for (int i = 0; i < 1024; i++) {
-          sink.write(new byte[8192]);
-          sink.flush();
+          try {
+            sink.write(new byte[1024 * 256]);
+            sink.flush();
+          } catch (IOException e) {
+            failureCount++;
+            if (failureCount == 3) throw e;
+          }
         }
       }
     };
@@ -1011,20 +1066,24 @@ private void requestBodyFail() {
     } catch (IOException expected) {
     }
 
-    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    assertNotNull(callFailed.ioe);
+    assertThat(listener.recordedEventTypes()).containsExactly(
+        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
+        "RequestBodyStart", "RequestFailed", "ConnectionReleased", "CallFailed");
   }
 
   @Test public void requestBodySuccessHttp1OverHttps() throws IOException {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    server.setProtocols(asList(Protocol.HTTP_1_1));
     requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
         equalTo(19L));
   }
 
   @Test public void requestBodySuccessHttp2OverHttps() throws IOException {
+    platform.assumeHttp2Support();
+
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
     requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
         equalTo(19L));
   }
@@ -1057,22 +1116,22 @@ private void requestBodyFail() {
   @Test public void successfulCallEventSequenceWithListener() throws IOException {
     server.enqueue(new MockResponse().setBody("abc"));
 
-    client = client.newBuilder().addNetworkInterceptor(new HttpLoggingInterceptor().setLevel(
-        HttpLoggingInterceptor.Level.BODY)).build();
-
+    client = client.newBuilder()
+        .addNetworkInterceptor(new HttpLoggingInterceptor()
+            .setLevel(HttpLoggingInterceptor.Level.BODY))
+        .build();
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
-    assertEquals("abc", response.body().string());
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.body().string()).isEqualTo("abc");
     response.body().close();
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
   private void requestBodySuccess(RequestBody body, Matcher<Long> requestBodyBytes,
@@ -1084,7 +1143,7 @@ private void requestBodySuccess(RequestBody body, Matcher<Long> requestBodyBytes
         .post(body)
         .build());
     Response response = call.execute();
-    assertEquals("World!", response.body().string());
+    assertThat(response.body().string()).isEqualTo("World!");
 
     assertBytesReadWritten(listener, any(Long.class), requestBodyBytes, responseHeaderLength,
         equalTo(6L));
@@ -1107,15 +1166,14 @@ private void enableTlsWithTunnel(boolean tunnelProxy) {
     server.enqueue(new MockResponse());
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
+    call.execute();
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
         "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
         "CallEnd");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
   @Test
@@ -1128,15 +1186,81 @@ public void redirectUsingNewConnectionEventSequence() throws IOException {
     otherServer.enqueue(new MockResponse());
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
+    call.execute();
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "DnsStart", "DnsEnd", "ConnectStart", "ConnectEnd",
         "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
         "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
         "CallEnd");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void applicationInterceptorProceedsMultipleTimes() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    client = client.newBuilder()
+        .addInterceptor(chain -> {
+          try (Response a = chain.proceed(chain.request())) {
+            assertThat(a.body().string()).isEqualTo("a");
+          }
+          return chain.proceed(chain.request());
+        })
+        .build();
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertThat(response.body().string()).isEqualTo("b");
+
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
+        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
+        "CallEnd");
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+  }
+
+  @Test public void applicationInterceptorShortCircuit() throws Exception {
+    client = client.newBuilder()
+        .addInterceptor(chain -> new Response.Builder()
+            .request(chain.request())
+            .protocol(Protocol.HTTP_1_1)
+            .code(200)
+            .message("OK")
+            .body(ResponseBody.create(null, "a"))
+            .build())
+        .build();
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertThat(response.body().string()).isEqualTo("a");
+
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallEnd");
+  }
+
+  /** Response headers start, then the entire request body, then response headers end. */
+  @Test public void expectContinueStartsResponseHeadersEarly() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.execute();
+
+    assertThat(listener.recordedEventTypes()).containsExactly(
+        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
+        "ResponseHeadersStart", "RequestBodyStart", "RequestBodyEnd", "ResponseHeadersEnd",
+        "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java b/okhttp/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
rename to okhttp/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
diff --git a/okhttp/src/test/java/okhttp3/FormBodyTest.java b/okhttp/src/test/java/okhttp3/FormBodyTest.java
new file mode 100644
index 0000000000..e352298f0e
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/FormBodyTest.java
@@ -0,0 +1,218 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import okio.Buffer;
+import org.junit.Test;
+import java.nio.charset.Charset;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class FormBodyTest {
+  @Test public void urlEncoding() throws Exception {
+    FormBody body = new FormBody.Builder()
+        .add("a+=& b", "c+=& d")
+        .add("space, the", "final frontier")
+        .add("%25", "%25")
+        .build();
+
+    assertThat(body.size()).isEqualTo(3);
+
+    assertThat(body.encodedName(0)).isEqualTo("a%2B%3D%26%20b");
+    assertThat(body.encodedName(1)).isEqualTo("space%2C%20the");
+    assertThat(body.encodedName(2)).isEqualTo("%2525");
+
+    assertThat(body.name(0)).isEqualTo("a+=& b");
+    assertThat(body.name(1)).isEqualTo("space, the");
+    assertThat(body.name(2)).isEqualTo("%25");
+
+    assertThat(body.encodedValue(0)).isEqualTo("c%2B%3D%26%20d");
+    assertThat(body.encodedValue(1)).isEqualTo("final%20frontier");
+    assertThat(body.encodedValue(2)).isEqualTo("%2525");
+
+    assertThat(body.value(0)).isEqualTo("c+=& d");
+    assertThat(body.value(1)).isEqualTo("final frontier");
+    assertThat(body.value(2)).isEqualTo("%25");
+
+    assertThat(body.contentType().toString()).isEqualTo(
+        "application/x-www-form-urlencoded");
+
+    String expected = "a%2B%3D%26%20b=c%2B%3D%26%20d&space%2C%20the=final%20frontier&%2525=%2525";
+    assertThat(body.contentLength()).isEqualTo(expected.length());
+
+    Buffer out = new Buffer();
+    body.writeTo(out);
+    assertThat(out.readUtf8()).isEqualTo(expected);
+  }
+
+  @Test public void addEncoded() throws Exception {
+    FormBody body = new FormBody.Builder()
+        .addEncoded("a+=& b", "c+=& d")
+        .addEncoded("e+=& f", "g+=& h")
+        .addEncoded("%25", "%25")
+        .build();
+
+    String expected = "a+%3D%26%20b=c+%3D%26%20d&e+%3D%26%20f=g+%3D%26%20h&%25=%25";
+    Buffer out = new Buffer();
+    body.writeTo(out);
+    assertThat(out.readUtf8()).isEqualTo(expected);
+  }
+
+  @Test public void encodedPair() throws Exception {
+    FormBody body = new FormBody.Builder()
+        .add("sim", "ple")
+        .build();
+
+    String expected = "sim=ple";
+    assertThat(body.contentLength()).isEqualTo(expected.length());
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
+  }
+
+  @Test public void encodeMultiplePairs() throws Exception {
+    FormBody body = new FormBody.Builder()
+        .add("sim", "ple")
+        .add("hey", "there")
+        .add("help", "me")
+        .build();
+
+    String expected = "sim=ple&hey=there&help=me";
+    assertThat(body.contentLength()).isEqualTo(expected.length());
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
+  }
+
+  @Test public void buildEmptyForm() throws Exception {
+    FormBody body = new FormBody.Builder().build();
+
+    String expected = "";
+    assertThat(body.contentLength()).isEqualTo(expected.length());
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
+  }
+
+  @Test public void characterEncoding() throws Exception {
+    // Browsers convert '\u0000' to '%EF%BF%BD'.
+    assertThat(formEncode(0)).isEqualTo("%00");
+    assertThat(formEncode(1)).isEqualTo("%01");
+    assertThat(formEncode(2)).isEqualTo("%02");
+    assertThat(formEncode(3)).isEqualTo("%03");
+    assertThat(formEncode(4)).isEqualTo("%04");
+    assertThat(formEncode(5)).isEqualTo("%05");
+    assertThat(formEncode(6)).isEqualTo("%06");
+    assertThat(formEncode(7)).isEqualTo("%07");
+    assertThat(formEncode(8)).isEqualTo("%08");
+    assertThat(formEncode(9)).isEqualTo("%09");
+    // Browsers convert '\n' to '\r\n'
+    assertThat(formEncode(10)).isEqualTo("%0A");
+    assertThat(formEncode(11)).isEqualTo("%0B");
+    assertThat(formEncode(12)).isEqualTo("%0C");
+    // Browsers convert '\r' to '\r\n'
+    assertThat(formEncode(13)).isEqualTo("%0D");
+    assertThat(formEncode(14)).isEqualTo("%0E");
+    assertThat(formEncode(15)).isEqualTo("%0F");
+    assertThat(formEncode(16)).isEqualTo("%10");
+    assertThat(formEncode(17)).isEqualTo("%11");
+    assertThat(formEncode(18)).isEqualTo("%12");
+    assertThat(formEncode(19)).isEqualTo("%13");
+    assertThat(formEncode(20)).isEqualTo("%14");
+    assertThat(formEncode(21)).isEqualTo("%15");
+    assertThat(formEncode(22)).isEqualTo("%16");
+    assertThat(formEncode(23)).isEqualTo("%17");
+    assertThat(formEncode(24)).isEqualTo("%18");
+    assertThat(formEncode(25)).isEqualTo("%19");
+    assertThat(formEncode(26)).isEqualTo("%1A");
+    assertThat(formEncode(27)).isEqualTo("%1B");
+    assertThat(formEncode(28)).isEqualTo("%1C");
+    assertThat(formEncode(29)).isEqualTo("%1D");
+    assertThat(formEncode(30)).isEqualTo("%1E");
+    assertThat(formEncode(31)).isEqualTo("%1F");
+    // Browsers use '+' for space.
+    assertThat(formEncode(32)).isEqualTo("%20");
+    assertThat(formEncode(33)).isEqualTo("%21");
+    assertThat(formEncode(34)).isEqualTo("%22");
+    assertThat(formEncode(35)).isEqualTo("%23");
+    assertThat(formEncode(36)).isEqualTo("%24");
+    assertThat(formEncode(37)).isEqualTo("%25");
+    assertThat(formEncode(38)).isEqualTo("%26");
+    assertThat(formEncode(39)).isEqualTo("%27");
+    assertThat(formEncode(40)).isEqualTo("%28");
+    assertThat(formEncode(41)).isEqualTo("%29");
+    assertThat(formEncode(42)).isEqualTo("*");
+    assertThat(formEncode(43)).isEqualTo("%2B");
+    assertThat(formEncode(44)).isEqualTo("%2C");
+    assertThat(formEncode(45)).isEqualTo("-");
+    assertThat(formEncode(46)).isEqualTo(".");
+    assertThat(formEncode(47)).isEqualTo("%2F");
+    assertThat(formEncode(48)).isEqualTo("0");
+    assertThat(formEncode(57)).isEqualTo("9");
+    assertThat(formEncode(58)).isEqualTo("%3A");
+    assertThat(formEncode(59)).isEqualTo("%3B");
+    assertThat(formEncode(60)).isEqualTo("%3C");
+    assertThat(formEncode(61)).isEqualTo("%3D");
+    assertThat(formEncode(62)).isEqualTo("%3E");
+    assertThat(formEncode(63)).isEqualTo("%3F");
+    assertThat(formEncode(64)).isEqualTo("%40");
+    assertThat(formEncode(65)).isEqualTo("A");
+    assertThat(formEncode(90)).isEqualTo("Z");
+    assertThat(formEncode(91)).isEqualTo("%5B");
+    assertThat(formEncode(92)).isEqualTo("%5C");
+    assertThat(formEncode(93)).isEqualTo("%5D");
+    assertThat(formEncode(94)).isEqualTo("%5E");
+    assertThat(formEncode(95)).isEqualTo("_");
+    assertThat(formEncode(96)).isEqualTo("%60");
+    assertThat(formEncode(97)).isEqualTo("a");
+    assertThat(formEncode(122)).isEqualTo("z");
+    assertThat(formEncode(123)).isEqualTo("%7B");
+    assertThat(formEncode(124)).isEqualTo("%7C");
+    assertThat(formEncode(125)).isEqualTo("%7D");
+    assertThat(formEncode(126)).isEqualTo("%7E");
+    assertThat(formEncode(127)).isEqualTo("%7F");
+    assertThat(formEncode(128)).isEqualTo("%C2%80");
+    assertThat(formEncode(255)).isEqualTo("%C3%BF");
+  }
+
+  private String formEncode(int codePoint) throws IOException {
+    // Wrap the codepoint with regular printable characters to prevent trimming.
+    FormBody body = new FormBody.Builder()
+        .add("a", new String(new int[] {'b', codePoint, 'c'}, 0, 3))
+        .build();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    buffer.skip(3); // Skip "a=b" prefix.
+    return buffer.readUtf8(buffer.size() - 1); // Skip the "c" suffix.
+  }
+
+  @Test public void manualCharset() throws Exception {
+    FormBody body = new FormBody.Builder(Charset.forName("ISO-8859-1"))
+        .add("name", "Nicols")
+        .build();
+
+    String expected = "name=Nicol%E1s";
+    assertThat(body.contentLength()).isEqualTo(expected.length());
+
+    Buffer out = new Buffer();
+    body.writeTo(out);
+    assertThat(out.readUtf8()).isEqualTo(expected);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java b/okhttp/src/test/java/okhttp3/HeadersTest.java
similarity index 72%
rename from okhttp-tests/src/test/java/okhttp3/HeadersTest.java
rename to okhttp/src/test/java/okhttp3/HeadersTest.java
index 42dc64111d..b5e14f7dd7 100644
--- a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
+++ b/okhttp/src/test/java/okhttp3/HeadersTest.java
@@ -17,16 +17,16 @@
 
 import java.io.IOException;
 import java.time.Instant;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http2.Header;
-import okhttp3.internal.http2.Http2Codec;
+import okhttp3.internal.http2.Http2ExchangeCodec;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -35,9 +35,7 @@
 import static java.util.Collections.singletonList;
 import static java.util.Collections.singletonMap;
 import static okhttp3.TestUtil.headerEntries;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertNull;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class HeadersTest {
@@ -51,11 +49,11 @@
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = Http2Codec.readHttp2HeadersList(headerBlock, Protocol.HTTP_2).request(request).build();
+    Response response = Http2ExchangeCodec.Companion.readHttp2HeadersList(headerBlock, Protocol.HTTP_2).request(request).build();
     Headers headers = response.headers();
-    assertEquals(1, headers.size());
-    assertEquals(":version", headers.name(0));
-    assertEquals("HTTP/1.1", headers.value(0));
+    assertThat(headers.size()).isEqualTo(1);
+    assertThat(headers.name(0)).isEqualTo(":version");
+    assertThat(headers.value(0)).isEqualTo("HTTP/1.1");
   }
 
   @Test public void http2HeadersListDropsForbiddenHeadersHttp2() {
@@ -71,7 +69,7 @@
         ":path", "/",
         ":authority", "square.com",
         ":scheme", "http");
-    assertEquals(expected, Http2Codec.http2HeadersList(request));
+    assertThat(Http2ExchangeCodec.Companion.http2HeadersList(request)).isEqualTo(expected);
   }
 
   @Test public void http2HeadersListDontDropTeIfTrailersHttp2() {
@@ -84,13 +82,13 @@
         ":path", "/",
         ":scheme", "http",
         "te", "trailers");
-    assertEquals(expected, Http2Codec.http2HeadersList(request));
+    assertThat(Http2ExchangeCodec.Companion.http2HeadersList(request)).isEqualTo(expected);
   }
 
   @Test public void ofTrims() {
     Headers headers = Headers.of("\t User-Agent \n", " \r OkHttp ");
-    assertEquals("User-Agent", headers.name(0));
-    assertEquals("OkHttp", headers.value(0));
+    assertThat(headers.name(0)).isEqualTo("User-Agent");
+    assertThat(headers.value(0)).isEqualTo("OkHttp");
   }
 
   @Test public void addParsing() {
@@ -102,10 +100,10 @@
         .add("ping:  pong  ") // Value whitespace is trimmed.
         .add("kit:kat") // Space after colon is not required.
         .build();
-    assertEquals(Arrays.asList("bar", "baz", "bak"), headers.values("foo"));
-    assertEquals(Arrays.asList("value"), headers.values("key"));
-    assertEquals(Arrays.asList("pong"), headers.values("ping"));
-    assertEquals(Arrays.asList("kat"), headers.values("kit"));
+    assertThat(headers.values("foo")).containsExactly("bar", "baz", "bak");
+    assertThat(headers.values("key")).containsExactly("value");
+    assertThat(headers.values("ping")).containsExactly("pong");
+    assertThat(headers.values("kit")).containsExactly("kat");
   }
 
   @Test public void addThrowsOnEmptyName() {
@@ -144,8 +142,8 @@
           .build();
       fail("Should have complained about invalid value");
     } catch (IllegalArgumentException expected) {
-      assertEquals("Unexpected char 0xe9 at 1 in header name: hader1",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0xe9 at 1 in header name: hader1");
     }
   }
 
@@ -153,7 +151,7 @@
     Headers headers = new Headers.Builder()
         .addUnsafeNonAscii("header1", "valu1")
         .build();
-    assertEquals("header1: valu1\n", headers.toString());
+    assertThat(headers.toString()).isEqualTo("header1: valu1\n");
   }
 
   @Test public void ofThrowsOddNumberOfHeaders() {
@@ -182,7 +180,7 @@
 
   @Test public void ofAcceptsEmptyValue() {
     Headers headers = Headers.of("User-Agent", "");
-    assertEquals("", headers.value(0));
+    assertThat(headers.value(0)).isEqualTo("");
   }
 
   @Test public void ofMakesDefensiveCopy() {
@@ -192,7 +190,7 @@
     };
     Headers headers = Headers.of(namesAndValues);
     namesAndValues[1] = "Chrome";
-    assertEquals("OkHttp", headers.value(0));
+    assertThat(headers.value(0)).isEqualTo("OkHttp");
   }
 
   @Test public void ofRejectsNullChar() {
@@ -207,7 +205,7 @@
     try {
       Headers.of(Collections.singletonMap("User-Agent", null));
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (NullPointerException expected) {
     }
   }
 
@@ -229,17 +227,17 @@
 
   @Test public void ofMapAcceptsEmptyValue() {
     Headers headers = Headers.of(singletonMap("User-Agent", ""));
-    assertEquals("", headers.value(0));
+    assertThat(headers.value(0)).isEqualTo("");
   }
 
   @Test public void ofMapTrimsKey() {
     Headers headers = Headers.of(singletonMap(" User-Agent ", "OkHttp"));
-    assertEquals("User-Agent", headers.name(0));
+    assertThat(headers.name(0)).isEqualTo("User-Agent");
   }
 
   @Test public void ofMapTrimsValue() {
     Headers headers = Headers.of(singletonMap("User-Agent", " OkHttp "));
-    assertEquals("OkHttp", headers.value(0));
+    assertThat(headers.value(0)).isEqualTo("OkHttp");
   }
 
   @Test public void ofMapMakesDefensiveCopy() {
@@ -248,7 +246,7 @@
 
     Headers headers = Headers.of(namesAndValues);
     namesAndValues.put("User-Agent", "Chrome");
-    assertEquals("OkHttp", headers.value(0));
+    assertThat(headers.value(0)).isEqualTo("OkHttp");
   }
 
   @Test public void ofMapRejectsNullCharInName() {
@@ -273,8 +271,8 @@
         "cache-control", "no-store",
         "user-agent", "OkHttp");
     Map<String, List<String>> headerMap = headers.toMultimap();
-    assertEquals(2, headerMap.get("cache-control").size());
-    assertEquals(1, headerMap.get("user-agent").size());
+    assertThat(headerMap.get("cache-control").size()).isEqualTo(2);
+    assertThat(headerMap.get("user-agent").size()).isEqualTo(1);
   }
 
   @Test public void toMultimapUsesCanonicalCase() {
@@ -283,8 +281,8 @@
         "Cache-Control", "no-cache",
         "User-Agent", "OkHttp");
     Map<String, List<String>> headerMap = headers.toMultimap();
-    assertEquals(2, headerMap.get("cache-control").size());
-    assertEquals(1, headerMap.get("user-agent").size());
+    assertThat(headerMap.get("cache-control").size()).isEqualTo(2);
+    assertThat(headerMap.get("user-agent").size()).isEqualTo(1);
   }
 
   @Test public void toMultimapAllowsCaseInsensitiveGet() {
@@ -292,8 +290,8 @@
         "cache-control", "no-store",
         "Cache-Control", "no-cache");
     Map<String, List<String>> headerMap = headers.toMultimap();
-    assertEquals(2, headerMap.get("cache-control").size());
-    assertEquals(2, headerMap.get("Cache-Control").size());
+    assertThat(headerMap.get("cache-control").size()).isEqualTo(2);
+    assertThat(headerMap.get("Cache-Control").size()).isEqualTo(2);
   }
 
   @Test public void nameIndexesAreStrict() {
@@ -303,8 +301,8 @@
       fail();
     } catch (IndexOutOfBoundsException expected) {
     }
-    assertEquals("a", headers.name(0));
-    assertEquals("c", headers.name(1));
+    assertThat(headers.name(0)).isEqualTo("a");
+    assertThat(headers.name(1)).isEqualTo("c");
     try {
       headers.name(2);
       fail();
@@ -319,8 +317,8 @@
       fail();
     } catch (IndexOutOfBoundsException expected) {
     }
-    assertEquals("b", headers.value(0));
-    assertEquals("d", headers.value(1));
+    assertThat(headers.value(0)).isEqualTo("b");
+    assertThat(headers.value(1)).isEqualTo("d");
     try {
       headers.value(2);
       fail();
@@ -333,8 +331,8 @@
       new Headers.Builder().add("hader1", "value1");
       fail("Should have complained about invalid name");
     } catch (IllegalArgumentException expected) {
-      assertEquals("Unexpected char 0xe9 at 1 in header name: hader1",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0xe9 at 1 in header name: hader1");
     }
   }
 
@@ -343,8 +341,8 @@
       new Headers.Builder().add("header1", "valu1");
       fail("Should have complained about invalid value");
     } catch (IllegalArgumentException expected) {
-      assertEquals("Unexpected char 0xe9 at 4 in header1 value: valu1",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0xe9 at 4 in header1 value: valu1");
     }
   }
 
@@ -353,8 +351,8 @@
       Headers.of("hader1", "value1");
       fail("Should have complained about invalid value");
     } catch (IllegalArgumentException expected) {
-      assertEquals("Unexpected char 0xe9 at 1 in header name: hader1",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0xe9 at 1 in header name: hader1");
     }
   }
 
@@ -363,8 +361,8 @@
       Headers.of("header1", "valu1");
       fail("Should have complained about invalid value");
     } catch (IllegalArgumentException expected) {
-      assertEquals("Unexpected char 0xe9 at 4 in header1 value: valu1",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0xe9 at 4 in header1 value: valu1");
     }
   }
 
@@ -373,8 +371,8 @@
       Headers.of(singletonMap("hader1", "value1"));
       fail("Should have complained about invalid value");
     } catch (IllegalArgumentException expected) {
-      assertEquals("Unexpected char 0xe9 at 1 in header name: hader1",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0xe9 at 1 in header name: hader1");
     }
   }
 
@@ -383,8 +381,8 @@
       Headers.of(singletonMap("header1", "valu1"));
       fail("Should have complained about invalid value");
     } catch (IllegalArgumentException expected) {
-      assertEquals("Unexpected char 0xe9 at 4 in header1 value: valu1",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0xe9 at 4 in header1 value: valu1");
     }
   }
 
@@ -397,8 +395,8 @@
         .add("Connection", "close")
         .add("Transfer-Encoding", "chunked")
         .build();
-    assertEquals(headers1, headers2);
-    assertEquals(headers1.hashCode(), headers2.hashCode());
+    assertThat(headers2).isEqualTo(headers1);
+    assertThat(headers2.hashCode()).isEqualTo(headers1.hashCode());
   }
 
   @Test public void headersNotEquals() {
@@ -410,8 +408,8 @@
         .add("Connection", "keep-alive")
         .add("Transfer-Encoding", "chunked")
         .build();
-    assertNotEquals(headers1, headers2);
-    assertNotEquals(headers1.hashCode(), headers2.hashCode());
+    assertThat(headers2).isNotEqualTo(headers1);
+    assertThat(headers2.hashCode()).isNotEqualTo((long) headers1.hashCode());
   }
 
   @Test public void headersToString() {
@@ -419,7 +417,7 @@
         .add("A", "a")
         .add("B", "bb")
         .build();
-    assertEquals("A: a\nB: bb\n", headers.toString());
+    assertThat(headers.toString()).isEqualTo("A: a\nB: bb\n");
   }
 
   @Test public void headersAddAll() {
@@ -433,7 +431,7 @@
         .addAll(sourceHeaders)
         .add("C", "c")
         .build();
-    assertEquals("A: a\nA: aa\na: aa\nB: bb\nC: c\n", headers.toString());
+    assertThat(headers.toString()).isEqualTo("A: a\nA: aa\na: aa\nB: bb\nC: c\n");
   }
 
   /** See https://github.com/square/okhttp/issues/2780. */
@@ -443,15 +441,15 @@
             + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
         .build();
     List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("Digest", challenges.get(0).scheme());
-    assertEquals("myrealm", challenges.get(0).realm());
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
+    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
     Map<String, String> expectedAuthParams = new LinkedHashMap<>();
     expectedAuthParams.put("realm", "myrealm");
     expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
     expectedAuthParams.put("qop", "auth");
     expectedAuthParams.put("stale", "FALSE");
-    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
   }
 
   @Test public void testDigestChallengeWithDifferentlyOrderedAuthParams() {
@@ -460,15 +458,15 @@
             + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
         .build();
     List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("Digest", challenges.get(0).scheme());
-    assertEquals("myrealm", challenges.get(0).realm());
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
+    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
     Map<String, String> expectedAuthParams = new LinkedHashMap<>();
     expectedAuthParams.put("realm", "myrealm");
     expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
     expectedAuthParams.put("qop", "auth");
     expectedAuthParams.put("stale", "FALSE");
-    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
   }
 
   @Test public void testDigestChallengeWithDifferentlyOrderedAuthParams2() {
@@ -477,15 +475,15 @@
             + "asdf\", realm=\"myrealm\", stale=\"FALSE\"")
         .build();
     List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("Digest", challenges.get(0).scheme());
-    assertEquals("myrealm", challenges.get(0).realm());
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
+    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
     Map<String, String> expectedAuthParams = new LinkedHashMap<>();
     expectedAuthParams.put("realm", "myrealm");
     expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
     expectedAuthParams.put("qop", "auth");
     expectedAuthParams.put("stale", "FALSE");
-    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
   }
 
   @Test public void testDigestChallengeWithMissingRealm() {
@@ -494,15 +492,15 @@
             + "rlaskdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
         .build();
     List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("Digest", challenges.get(0).scheme());
-    assertNull(challenges.get(0).realm());
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
+    assertThat(challenges.get(0).realm()).isNull();
     Map<String, String> expectedAuthParams = new LinkedHashMap<>();
     expectedAuthParams.put("underrealm", "myrealm");
     expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
     expectedAuthParams.put("qop", "auth");
     expectedAuthParams.put("stale", "FALSE");
-    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
   }
 
   @Test public void testDigestChallengeWithAdditionalSpaces() {
@@ -511,15 +509,15 @@
             + "askdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
         .build();
     List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("Digest", challenges.get(0).scheme());
-    assertEquals("myrealm", challenges.get(0).realm());
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
+    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
     Map<String, String> expectedAuthParams = new LinkedHashMap<>();
     expectedAuthParams.put("realm", "myrealm");
     expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
     expectedAuthParams.put("qop", "auth");
     expectedAuthParams.put("stale", "FALSE");
-    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
   }
 
   @Test public void testDigestChallengeWithAdditionalSpacesBeforeFirstAuthParam() {
@@ -528,15 +526,15 @@
             + "aksjdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
         .build();
     List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("Digest", challenges.get(0).scheme());
-    assertEquals("myrealm", challenges.get(0).realm());
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
+    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
     Map<String, String> expectedAuthParams = new LinkedHashMap<>();
     expectedAuthParams.put("realm", "myrealm");
     expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
     expectedAuthParams.put("qop", "auth");
     expectedAuthParams.put("stale", "FALSE");
-    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
   }
 
   @Test public void testDigestChallengeWithCamelCasedNames() {
@@ -545,15 +543,15 @@
             + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
         .build();
     List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("DiGeSt", challenges.get(0).scheme());
-    assertEquals("myrealm", challenges.get(0).realm());
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("DiGeSt");
+    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
     Map<String, String> expectedAuthParams = new LinkedHashMap<>();
     expectedAuthParams.put("realm", "myrealm");
     expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
     expectedAuthParams.put("qop", "auth");
     expectedAuthParams.put("stale", "FALSE");
-    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
   }
 
   @Test public void testDigestChallengeWithCamelCasedNames2() {
@@ -563,25 +561,25 @@
             + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
         .build();
     List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("DIgEsT", challenges.get(0).scheme());
-    assertEquals("myrealm", challenges.get(0).realm());
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("DIgEsT");
+    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
     Map<String, String> expectedAuthParams = new LinkedHashMap<>();
     expectedAuthParams.put("realm", "myrealm");
     expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
     expectedAuthParams.put("qop", "auth");
     expectedAuthParams.put("stale", "FALSE");
-    assertEquals(expectedAuthParams, challenges.get(0).authParams());
+    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
   }
 
   @Test public void testDigestChallengeWithTokenFormOfAuthParam() {
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest realm=myrealm").build();
     List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("Digest", challenges.get(0).scheme());
-    assertEquals("myrealm", challenges.get(0).realm());
-    assertEquals(singletonMap("realm", "myrealm"), challenges.get(0).authParams());
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
+    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
+    assertThat(challenges.get(0).authParams()).isEqualTo(singletonMap("realm", "myrealm"));
   }
 
   @Test public void testDigestChallengeWithoutAuthParams() {
@@ -589,18 +587,18 @@
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest").build();
     List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("Digest", challenges.get(0).scheme());
-    assertNull(challenges.get(0).realm());
-    assertEquals(emptyMap(), challenges.get(0).authParams());
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
+    assertThat(challenges.get(0).realm()).isNull();
+    assertThat(challenges.get(0).authParams()).isEqualTo(emptyMap());
   }
 
   @Test public void basicChallenge() {
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate: Basic realm=\"protected area\"")
         .build();
-    assertEquals(singletonList(new Challenge("Basic", singletonMap("realm", "protected area"))),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
+        singletonList(new Challenge("Basic", singletonMap("realm", "protected area"))));
   }
 
   @Test public void basicChallengeWithCharset() {
@@ -610,8 +608,8 @@
     Map<String, String> expectedAuthParams = new LinkedHashMap<>();
     expectedAuthParams.put("realm", "protected area");
     expectedAuthParams.put("charset", "UTF-8");
-    assertEquals(singletonList(new Challenge("Basic", expectedAuthParams)),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
+        singletonList(new Challenge("Basic", expectedAuthParams)));
   }
 
   @Test public void basicChallengeWithUnexpectedCharset() {
@@ -622,74 +620,69 @@
     Map<String, String> expectedAuthParams = new LinkedHashMap<>();
     expectedAuthParams.put("realm", "protected area");
     expectedAuthParams.put("charset", "US-ASCII");
-    assertEquals(singletonList(new Challenge("Basic", expectedAuthParams)),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
+        singletonList(new Challenge("Basic", expectedAuthParams)));
   }
 
   @Test public void separatorsBeforeFirstChallenge() {
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", " ,  , Basic realm=myrealm")
         .build();
-    assertEquals(singletonList(new Challenge("Basic", singletonMap("realm", "myrealm"))),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
+        singletonList(new Challenge("Basic", singletonMap("realm", "myrealm"))));
   }
 
   @Test public void spacesAroundKeyValueSeparator() {
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Basic realm = \"myrealm\"")
         .build();
-    assertEquals(singletonList(new Challenge("Basic", singletonMap("realm", "myrealm"))),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
+        singletonList(new Challenge("Basic", singletonMap("realm", "myrealm"))));
   }
 
   @Test public void multipleChallengesInOneHeader() {
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Basic realm = \"myrealm\",Digest")
         .build();
-    assertEquals(Arrays.asList(
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
         new Challenge("Basic", singletonMap("realm", "myrealm")),
-        new Challenge("Digest", Collections.emptyMap())),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+        new Challenge("Digest", Collections.emptyMap()));
   }
 
   @Test public void multipleChallengesWithSameSchemeButDifferentRealmInOneHeader() {
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Basic realm = \"myrealm\",Basic realm=myotherrealm")
         .build();
-    assertEquals(Arrays.asList(
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
         new Challenge("Basic", singletonMap("realm", "myrealm")),
-        new Challenge("Basic", singletonMap("realm", "myotherrealm"))),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+        new Challenge("Basic", singletonMap("realm", "myotherrealm")));
   }
 
   @Test public void separatorsBeforeFirstAuthParam() {
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest, Basic ,,realm=\"myrealm\"")
         .build();
-    assertEquals(Arrays.asList(
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
         new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "myrealm"))),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+        new Challenge("Basic", singletonMap("realm", "myrealm")));
   }
 
   @Test public void onlyCommaBetweenChallenges() {
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest,Basic realm=\"myrealm\"")
         .build();
-    assertEquals(Arrays.asList(
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
         new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "myrealm"))),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+        new Challenge("Basic", singletonMap("realm", "myrealm")));
   }
 
   @Test public void multipleSeparatorsBetweenChallenges() {
     Headers headers = new Headers.Builder()
         .add("WWW-Authenticate", "Digest,,,, Basic ,,realm=\"myrealm\"")
         .build();
-    assertEquals(Arrays.asList(
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
         new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "myrealm"))),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+        new Challenge("Basic", singletonMap("realm", "myrealm")));
   }
 
   @Test public void unknownAuthParams() {
@@ -700,10 +693,9 @@
     Map<String, String> expectedAuthParams = new LinkedHashMap<>();
     expectedAuthParams.put("realm", "myrealm");
     expectedAuthParams.put("foo", "bar");
-    assertEquals(Arrays.asList(
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
         new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", expectedAuthParams)),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+        new Challenge("Basic", expectedAuthParams));
   }
 
   @Test public void escapedCharactersInQuotedString() {
@@ -711,10 +703,9 @@
         .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\\\\\\\"r\\ealm\"")
         .build();
 
-    assertEquals(Arrays.asList(
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
         new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "my\\\"realm"))),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+        new Challenge("Basic", singletonMap("realm", "my\\\"realm")));
   }
 
   @Test public void commaInQuotedStringAndBeforeFirstChallenge() {
@@ -722,10 +713,9 @@
         .add("WWW-Authenticate", ",Digest,,,, Basic ,,,realm=\"my, realm,\"")
         .build();
 
-    assertEquals(Arrays.asList(
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
         new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "my, realm,"))),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+        new Challenge("Basic", singletonMap("realm", "my, realm,")));
   }
 
   @Test public void unescapedDoubleQuoteInQuotedStringWithEvenNumberOfBackslashesInFront() {
@@ -733,9 +723,8 @@
         .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\\\\\\\\\"r\\ealm\"")
         .build();
 
-    assertEquals(Arrays.asList(
-        new Challenge("Digest", Collections.emptyMap())),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Digest", Collections.emptyMap()));
   }
 
   @Test public void unescapedDoubleQuoteInQuotedString() {
@@ -743,9 +732,8 @@
         .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\"realm\"")
         .build();
 
-    assertEquals(Arrays.asList(
-        new Challenge("Digest", Collections.emptyMap())),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Digest", Collections.emptyMap()));
   }
 
   @Ignore("TODO(jwilson): reject parameters that use invalid characters")
@@ -754,9 +742,8 @@
         .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=my\"realm")
         .build();
 
-    assertEquals(Arrays.asList(
-        new Challenge("Digest", Collections.emptyMap())),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Digest", Collections.emptyMap()));
   }
 
   @Test public void token68InsteadOfAuthParams() {
@@ -764,9 +751,9 @@
         .add("WWW-Authenticate", "Other abc==")
         .build();
 
-    assertEquals(singletonList(
-        new Challenge("Other", singletonMap(null, "abc=="))),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
+        singletonList(
+        new Challenge("Other", singletonMap(null, "abc=="))));
   }
 
   @Test public void token68AndAuthParams() {
@@ -774,9 +761,8 @@
         .add("WWW-Authenticate", "Other abc==, realm=myrealm")
         .build();
 
-    assertEquals(Arrays.asList(
-        new Challenge("Other", singletonMap(null, "abc=="))),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Other", singletonMap(null, "abc==")));
   }
 
   @Test public void repeatedAuthParamKey() {
@@ -784,7 +770,8 @@
         .add("WWW-Authenticate", "Other realm=myotherrealm, realm=myrealm")
         .build();
 
-    assertEquals(emptyList(), HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
+        emptyList());
   }
 
   @Test public void multipleAuthenticateHeaders() {
@@ -793,10 +780,9 @@
         .add("WWW-Authenticate", "Basic realm=myrealm")
         .build();
 
-    assertEquals(Arrays.asList(
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
         new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "myrealm"))),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+        new Challenge("Basic", singletonMap("realm", "myrealm")));
   }
 
   @Test public void multipleAuthenticateHeadersInDifferentOrder() {
@@ -805,10 +791,9 @@
         .add("WWW-Authenticate", "Digest")
         .build();
 
-    assertEquals(Arrays.asList(
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
         new Challenge("Basic", singletonMap("realm", "myrealm")),
-        new Challenge("Digest", Collections.emptyMap())),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+        new Challenge("Digest", Collections.emptyMap()));
   }
 
   @Test public void multipleBasicAuthenticateHeaders() {
@@ -817,23 +802,22 @@
         .add("WWW-Authenticate", "Basic realm=myotherrealm")
         .build();
 
-    assertEquals(Arrays.asList(
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
         new Challenge("Basic", singletonMap("realm", "myrealm")),
-        new Challenge("Basic", singletonMap("realm", "myotherrealm"))),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+        new Challenge("Basic", singletonMap("realm", "myotherrealm")));
   }
 
   @Test public void byteCount() {
-    assertEquals(0L, new Headers.Builder().build().byteCount());
-    assertEquals(10L, new Headers.Builder()
+    assertThat(Util.EMPTY_HEADERS.byteCount()).isEqualTo(0L);
+    assertThat(new Headers.Builder()
         .add("abc", "def")
         .build()
-        .byteCount());
-    assertEquals(20L, new Headers.Builder()
+        .byteCount()).isEqualTo(10L);
+    assertThat(new Headers.Builder()
         .add("abc", "def")
         .add("ghi", "jkl")
         .build()
-        .byteCount());
+        .byteCount()).isEqualTo(20L);
   }
 
   @Test public void addDate() {
@@ -841,8 +825,8 @@
     Headers headers = new Headers.Builder()
         .add("testDate", expected)
         .build();
-    assertEquals("Thu, 01 Jan 1970 00:00:00 GMT", headers.get("testDate"));
-    assertEquals(new Date(0L), headers.getDate("testDate"));
+    assertThat(headers.get("testDate")).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT");
+    assertThat(headers.getDate("testDate")).isEqualTo(new Date(0L));
   }
 
   @Test public void addDateNull() {
@@ -851,8 +835,7 @@
           .add("testDate", (Date) null)
           .build();
       fail();
-    } catch (NullPointerException expected) {
-      assertEquals("value for name testDate == null", expected.getMessage());
+    } catch (IllegalArgumentException expected) {
     }
   }
 
@@ -861,8 +844,8 @@
     Headers headers = new Headers.Builder()
         .add("Test-Instant", expected)
         .build();
-    assertEquals("Thu, 01 Jan 1970 00:00:00 GMT", headers.get("Test-Instant"));
-    assertEquals(expected, headers.getInstant("Test-Instant"));
+    assertThat(headers.get("Test-Instant")).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT");
+    assertThat(headers.getInstant("Test-Instant")).isEqualTo(expected);
   }
 
   @Test public void addInstantNull() {
@@ -871,8 +854,7 @@
           .add("Test-Instant", (Instant) null)
           .build();
       fail();
-    } catch (NullPointerException expected) {
-      assertEquals("value for name Test-Instant == null", expected.getMessage());
+    } catch (IllegalArgumentException expected) {
     }
   }
 
@@ -882,8 +864,8 @@
         .add("testDate", new Date(0L))
         .set("testDate", expected)
         .build();
-    assertEquals("Thu, 01 Jan 1970 00:00:01 GMT", headers.get("testDate"));
-    assertEquals(expected, headers.getDate("testDate"));
+    assertThat(headers.get("testDate")).isEqualTo("Thu, 01 Jan 1970 00:00:01 GMT");
+    assertThat(headers.getDate("testDate")).isEqualTo(expected);
   }
 
   @Test public void setDateNull() {
@@ -892,8 +874,7 @@
           .set("testDate", (Date) null)
           .build();
       fail();
-    } catch (NullPointerException expected) {
-      assertEquals("value for name testDate == null", expected.getMessage());
+    } catch (IllegalArgumentException expected) {
     }
   }
 
@@ -903,8 +884,8 @@
         .add("Test-Instant", Instant.ofEpochMilli(0L))
         .set("Test-Instant", expected)
         .build();
-    assertEquals("Thu, 01 Jan 1970 00:00:01 GMT", headers.get("Test-Instant"));
-    assertEquals(expected, headers.getInstant("Test-Instant"));
+    assertThat(headers.get("Test-Instant")).isEqualTo("Thu, 01 Jan 1970 00:00:01 GMT");
+    assertThat(headers.getInstant("Test-Instant")).isEqualTo(expected);
   }
 
   @Test public void setInstantNull() {
@@ -913,8 +894,7 @@
           .set("Test-Instant", (Instant) null)
           .build();
       fail();
-    } catch (NullPointerException expected) {
-      assertEquals("value for name Test-Instant == null", expected.getMessage());
+    } catch (IllegalArgumentException expected) {
     }
   }
 }
diff --git a/okhttp/src/test/java/okhttp3/HttpUrlTest.java b/okhttp/src/test/java/okhttp3/HttpUrlTest.java
new file mode 100644
index 0000000000..c522044012
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/HttpUrlTest.java
@@ -0,0 +1,1727 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.URI;
+import java.net.URL;
+import java.util.Collection;
+import java.util.Collections;
+import okhttp3.UrlComponentEncodingTester.Component;
+import okhttp3.UrlComponentEncodingTester.Encoding;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static java.util.Arrays.asList;
+import static java.util.Collections.singletonList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(Parameterized.class)
+public final class HttpUrlTest {
+  @Parameterized.Parameters(name = "Use get = {0}")
+  public static Collection<Object[]> parameters() {
+    return asList(
+        new Object[] { true },
+        new Object[] { false }
+    );
+  }
+
+  @Parameterized.Parameter
+  public boolean useGet;
+
+  HttpUrl parse(String url) {
+    return useGet
+        ? HttpUrl.get(url)
+        : HttpUrl.parse(url);
+  }
+
+  @Test public void parseTrimsAsciiWhitespace() throws Exception {
+    HttpUrl expected = parse("http://host/");
+    // Leading.
+    assertThat(parse("http://host/\f\n\t \r")).isEqualTo(expected);
+    // Trailing.
+    assertThat(parse("\r\n\f \thttp://host/")).isEqualTo(expected);
+    // Both.
+    assertThat(parse(" http://host/ ")).isEqualTo(expected);
+    // Both.
+    assertThat(parse("    http://host/    ")).isEqualTo(expected);
+    assertThat(parse("http://host/").resolve("   ")).isEqualTo(expected);
+    assertThat(parse("http://host/").resolve("  .  ")).isEqualTo(expected);
+  }
+
+  @Test public void parseHostAsciiNonPrintable() throws Exception {
+    String host = "host\u0001";
+    assertInvalid("http://" + host + "/", "Invalid URL host: \"host\u0001\"");
+    // TODO make exception message escape non-printable characters
+  }
+
+  @Test public void parseDoesNotTrimOtherWhitespaceCharacters() throws Exception {
+    // Whitespace characters list from Google's Guava team: http://goo.gl/IcR9RD
+    // line tabulation
+    assertThat(parse("http://h/\u000b").encodedPath()).isEqualTo("/%0B");
+    // information separator 4
+    assertThat(parse("http://h/\u001c").encodedPath()).isEqualTo("/%1C");
+    // information separator 3
+    assertThat(parse("http://h/\u001d").encodedPath()).isEqualTo("/%1D");
+    // information separator 2
+    assertThat(parse("http://h/\u001e").encodedPath()).isEqualTo("/%1E");
+    // information separator 1
+    assertThat(parse("http://h/\u001f").encodedPath()).isEqualTo("/%1F");
+    // next line
+    assertThat(parse("http://h/\u0085").encodedPath()).isEqualTo("/%C2%85");
+    // non-breaking space
+    assertThat(parse("http://h/\u00a0").encodedPath()).isEqualTo("/%C2%A0");
+    // ogham space mark
+    assertThat(parse("http://h/\u1680").encodedPath()).isEqualTo("/%E1%9A%80");
+    // mongolian vowel separator
+    assertThat(parse("http://h/\u180e").encodedPath()).isEqualTo("/%E1%A0%8E");
+    // en quad
+    assertThat(parse("http://h/\u2000").encodedPath()).isEqualTo("/%E2%80%80");
+    // em quad
+    assertThat(parse("http://h/\u2001").encodedPath()).isEqualTo("/%E2%80%81");
+    // en space
+    assertThat(parse("http://h/\u2002").encodedPath()).isEqualTo("/%E2%80%82");
+    // em space
+    assertThat(parse("http://h/\u2003").encodedPath()).isEqualTo("/%E2%80%83");
+    // three-per-em space
+    assertThat(parse("http://h/\u2004").encodedPath()).isEqualTo("/%E2%80%84");
+    // four-per-em space
+    assertThat(parse("http://h/\u2005").encodedPath()).isEqualTo("/%E2%80%85");
+    // six-per-em space
+    assertThat(parse("http://h/\u2006").encodedPath()).isEqualTo("/%E2%80%86");
+    // figure space
+    assertThat(parse("http://h/\u2007").encodedPath()).isEqualTo("/%E2%80%87");
+    // punctuation space
+    assertThat(parse("http://h/\u2008").encodedPath()).isEqualTo("/%E2%80%88");
+    // thin space
+    assertThat(parse("http://h/\u2009").encodedPath()).isEqualTo("/%E2%80%89");
+    // hair space
+    assertThat(parse("http://h/\u200a").encodedPath()).isEqualTo("/%E2%80%8A");
+    // zero-width space
+    assertThat(parse("http://h/\u200b").encodedPath()).isEqualTo("/%E2%80%8B");
+    // zero-width non-joiner
+    assertThat(parse("http://h/\u200c").encodedPath()).isEqualTo("/%E2%80%8C");
+    // zero-width joiner
+    assertThat(parse("http://h/\u200d").encodedPath()).isEqualTo("/%E2%80%8D");
+    // left-to-right mark
+    assertThat(parse("http://h/\u200e").encodedPath()).isEqualTo("/%E2%80%8E");
+    // right-to-left mark
+    assertThat(parse("http://h/\u200f").encodedPath()).isEqualTo("/%E2%80%8F");
+    // line separator
+    assertThat(parse("http://h/\u2028").encodedPath()).isEqualTo("/%E2%80%A8");
+    // paragraph separator
+    assertThat(parse("http://h/\u2029").encodedPath()).isEqualTo("/%E2%80%A9");
+    // narrow non-breaking space
+    assertThat(parse("http://h/\u202f").encodedPath()).isEqualTo("/%E2%80%AF");
+    // medium mathematical space
+    assertThat(parse("http://h/\u205f").encodedPath()).isEqualTo("/%E2%81%9F");
+    // ideographic space
+    assertThat(parse("http://h/\u3000").encodedPath()).isEqualTo("/%E3%80%80");
+  }
+
+  @Test public void scheme() throws Exception {
+    assertThat(parse("http://host/")).isEqualTo(parse("http://host/"));
+    assertThat(parse("Http://host/")).isEqualTo(parse("http://host/"));
+    assertThat(parse("http://host/")).isEqualTo(parse("http://host/"));
+    assertThat(parse("HTTP://host/")).isEqualTo(parse("http://host/"));
+    assertThat(parse("https://host/")).isEqualTo(parse("https://host/"));
+    assertThat(parse("HTTPS://host/")).isEqualTo(parse("https://host/"));
+
+    assertInvalid("image640://480.png", "Expected URL scheme 'http' or 'https' but was 'image640'");
+    assertInvalid("httpp://host/", "Expected URL scheme 'http' or 'https' but was 'httpp'");
+    assertInvalid("0ttp://host/", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("ht+tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht+tp'");
+    assertInvalid("ht.tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht.tp'");
+    assertInvalid("ht-tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht-tp'");
+    assertInvalid("ht1tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht1tp'");
+    assertInvalid("httpss://host/", "Expected URL scheme 'http' or 'https' but was 'httpss'");
+  }
+
+  @Test public void parseNoScheme() throws Exception {
+    assertInvalid("//host", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("/path", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("path", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("?query", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("#fragment", "Expected URL scheme 'http' or 'https' but no colon was found");
+  }
+
+  @Test public void newBuilderResolve() throws Exception {
+    // Non-exhaustive tests because implementation is the same as resolve.
+    HttpUrl base = parse("http://host/a/b");
+    assertThat(base.newBuilder("https://host2").build()).isEqualTo(parse("https://host2/"));
+    assertThat(base.newBuilder("//host2").build()).isEqualTo(parse("http://host2/"));
+    assertThat(base.newBuilder("/path").build()).isEqualTo(parse("http://host/path"));
+    assertThat(base.newBuilder("path").build()).isEqualTo(parse("http://host/a/path"));
+    assertThat(base.newBuilder("?query").build()).isEqualTo(parse("http://host/a/b?query"));
+    assertThat(base.newBuilder("#fragment").build())
+        .isEqualTo(parse("http://host/a/b#fragment"));
+    assertThat(base.newBuilder("").build()).isEqualTo(parse("http://host/a/b"));
+    assertThat(base.newBuilder("ftp://b")).isNull();
+    assertThat(base.newBuilder("ht+tp://b")).isNull();
+    assertThat(base.newBuilder("ht-tp://b")).isNull();
+    assertThat(base.newBuilder("ht.tp://b")).isNull();
+  }
+
+  @Test public void redactedUrl() {
+    HttpUrl baseWithPasswordAndUsername = parse("http://username:password@host/a/b#fragment");
+    HttpUrl baseWithUsernameOnly = parse("http://username@host/a/b#fragment");
+    HttpUrl baseWithPasswordOnly = parse("http://password@host/a/b#fragment");
+    assertThat(baseWithPasswordAndUsername.redact()).isEqualTo("http://host/...");
+    assertThat(baseWithUsernameOnly.redact()).isEqualTo("http://host/...");
+    assertThat(baseWithPasswordOnly.redact()).isEqualTo("http://host/...");
+  }
+
+  @Test public void resolveNoScheme() throws Exception {
+    HttpUrl base = parse("http://host/a/b");
+    assertThat(base.resolve("//host2")).isEqualTo(parse("http://host2/"));
+    assertThat(base.resolve("/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("path")).isEqualTo(parse("http://host/a/path"));
+    assertThat(base.resolve("?query")).isEqualTo(parse("http://host/a/b?query"));
+    assertThat(base.resolve("#fragment")).isEqualTo(parse("http://host/a/b#fragment"));
+    assertThat(base.resolve("")).isEqualTo(parse("http://host/a/b"));
+    assertThat(base.resolve("\\path")).isEqualTo(parse("http://host/path"));
+  }
+
+  @Test public void resolveUnsupportedScheme() throws Exception {
+    HttpUrl base = parse("http://a/");
+    assertThat(base.resolve("ftp://b")).isNull();
+    assertThat(base.resolve("ht+tp://b")).isNull();
+    assertThat(base.resolve("ht-tp://b")).isNull();
+    assertThat(base.resolve("ht.tp://b")).isNull();
+  }
+
+  @Test public void resolveSchemeLikePath() throws Exception {
+    HttpUrl base = parse("http://a/");
+    assertThat(base.resolve("http//b/")).isEqualTo(parse("http://a/http//b/"));
+    assertThat(base.resolve("ht+tp//b/")).isEqualTo(parse("http://a/ht+tp//b/"));
+    assertThat(base.resolve("ht-tp//b/")).isEqualTo(parse("http://a/ht-tp//b/"));
+    assertThat(base.resolve("ht.tp//b/")).isEqualTo(parse("http://a/ht.tp//b/"));
+  }
+
+  /** https://tools.ietf.org/html/rfc3986#section-5.4.1 */
+  @Test public void rfc3886NormalExamples() {
+    HttpUrl url = parse("http://a/b/c/d;p?q");
+    // No 'g:' scheme in HttpUrl.
+    assertThat(url.resolve("g:h")).isNull();
+    assertThat(url.resolve("g")).isEqualTo(parse("http://a/b/c/g"));
+    assertThat(url.resolve("./g")).isEqualTo(parse("http://a/b/c/g"));
+    assertThat(url.resolve("g/")).isEqualTo(parse("http://a/b/c/g/"));
+    assertThat(url.resolve("/g")).isEqualTo(parse("http://a/g"));
+    assertThat(url.resolve("//g")).isEqualTo(parse("http://g"));
+    assertThat(url.resolve("?y")).isEqualTo(parse("http://a/b/c/d;p?y"));
+    assertThat(url.resolve("g?y")).isEqualTo(parse("http://a/b/c/g?y"));
+    assertThat(url.resolve("#s")).isEqualTo(parse("http://a/b/c/d;p?q#s"));
+    assertThat(url.resolve("g#s")).isEqualTo(parse("http://a/b/c/g#s"));
+    assertThat(url.resolve("g?y#s")).isEqualTo(parse("http://a/b/c/g?y#s"));
+    assertThat(url.resolve(";x")).isEqualTo(parse("http://a/b/c/;x"));
+    assertThat(url.resolve("g;x")).isEqualTo(parse("http://a/b/c/g;x"));
+    assertThat(url.resolve("g;x?y#s")).isEqualTo(parse("http://a/b/c/g;x?y#s"));
+    assertThat(url.resolve("")).isEqualTo(parse("http://a/b/c/d;p?q"));
+    assertThat(url.resolve(".")).isEqualTo(parse("http://a/b/c/"));
+    assertThat(url.resolve("./")).isEqualTo(parse("http://a/b/c/"));
+    assertThat(url.resolve("..")).isEqualTo(parse("http://a/b/"));
+    assertThat(url.resolve("../")).isEqualTo(parse("http://a/b/"));
+    assertThat(url.resolve("../g")).isEqualTo(parse("http://a/b/g"));
+    assertThat(url.resolve("../..")).isEqualTo(parse("http://a/"));
+    assertThat(url.resolve("../../")).isEqualTo(parse("http://a/"));
+    assertThat(url.resolve("../../g")).isEqualTo(parse("http://a/g"));
+  }
+
+  /** https://tools.ietf.org/html/rfc3986#section-5.4.2 */
+  @Test public void rfc3886AbnormalExamples() {
+    HttpUrl url = parse("http://a/b/c/d;p?q");
+    assertThat(url.resolve("../../../g")).isEqualTo(parse("http://a/g"));
+    assertThat(url.resolve("../../../../g")).isEqualTo(parse("http://a/g"));
+    assertThat(url.resolve("/./g")).isEqualTo(parse("http://a/g"));
+    assertThat(url.resolve("/../g")).isEqualTo(parse("http://a/g"));
+    assertThat(url.resolve("g.")).isEqualTo(parse("http://a/b/c/g."));
+    assertThat(url.resolve(".g")).isEqualTo(parse("http://a/b/c/.g"));
+    assertThat(url.resolve("g..")).isEqualTo(parse("http://a/b/c/g.."));
+    assertThat(url.resolve("..g")).isEqualTo(parse("http://a/b/c/..g"));
+    assertThat(url.resolve("./../g")).isEqualTo(parse("http://a/b/g"));
+    assertThat(url.resolve("./g/.")).isEqualTo(parse("http://a/b/c/g/"));
+    assertThat(url.resolve("g/./h")).isEqualTo(parse("http://a/b/c/g/h"));
+    assertThat(url.resolve("g/../h")).isEqualTo(parse("http://a/b/c/h"));
+    assertThat(url.resolve("g;x=1/./y")).isEqualTo(parse("http://a/b/c/g;x=1/y"));
+    assertThat(url.resolve("g;x=1/../y")).isEqualTo(parse("http://a/b/c/y"));
+    assertThat(url.resolve("g?y/./x")).isEqualTo(parse("http://a/b/c/g?y/./x"));
+    assertThat(url.resolve("g?y/../x")).isEqualTo(parse("http://a/b/c/g?y/../x"));
+    assertThat(url.resolve("g#s/./x")).isEqualTo(parse("http://a/b/c/g#s/./x"));
+    assertThat(url.resolve("g#s/../x")).isEqualTo(parse("http://a/b/c/g#s/../x"));
+    // "http:g" also okay.
+    assertThat(url.resolve("http:g")).isEqualTo(parse("http://a/b/c/g"));
+  }
+
+  @Test public void parseAuthoritySlashCountDoesntMatter() throws Exception {
+    assertThat(parse("http:host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http://host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:/\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:///host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:\\//host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:/\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http://\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:\\\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:/\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:\\\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:////host/path")).isEqualTo(parse("http://host/path"));
+  }
+
+  @Test public void resolveAuthoritySlashCountDoesntMatterWithDifferentScheme() throws Exception {
+    HttpUrl base = parse("https://a/b/c");
+    assertThat(base.resolve("http:host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http://host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:/\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:///host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\//host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:/\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http://\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:/\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:////host/path")).isEqualTo(parse("http://host/path"));
+  }
+
+  @Test public void resolveAuthoritySlashCountMattersWithSameScheme() throws Exception {
+    HttpUrl base = parse("http://a/b/c");
+    assertThat(base.resolve("http:host/path")).isEqualTo(parse("http://a/b/host/path"));
+    assertThat(base.resolve("http:/host/path")).isEqualTo(parse("http://a/host/path"));
+    assertThat(base.resolve("http:\\host/path")).isEqualTo(parse("http://a/host/path"));
+    assertThat(base.resolve("http://host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:/\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:///host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\//host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:/\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http://\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:/\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:////host/path")).isEqualTo(parse("http://host/path"));
+  }
+
+  @Test public void username() throws Exception {
+    assertThat(parse("http://@host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http://user@host/path")).isEqualTo(parse("http://user@host/path"));
+  }
+
+  /** Given multiple '@' characters, the last one is the delimiter. */
+  @Test public void authorityWithMultipleAtSigns() throws Exception {
+    HttpUrl httpUrl = parse("http://foo@bar@baz/path");
+    assertThat(httpUrl.username()).isEqualTo("foo@bar");
+    assertThat(httpUrl.password()).isEqualTo("");
+    assertThat(httpUrl).isEqualTo(parse("http://foo%40bar@baz/path"));
+  }
+
+  /** Given multiple ':' characters, the first one is the delimiter. */
+  @Test public void authorityWithMultipleColons() throws Exception {
+    HttpUrl httpUrl = parse("http://foo:pass1@bar:pass2@baz/path");
+    assertThat(httpUrl.username()).isEqualTo("foo");
+    assertThat(httpUrl.password()).isEqualTo("pass1@bar:pass2");
+    assertThat(httpUrl).isEqualTo(parse("http://foo:pass1%40bar%3Apass2@baz/path"));
+  }
+
+  @Test public void usernameAndPassword() throws Exception {
+    assertThat(parse("http://username:password@host/path"))
+        .isEqualTo(parse("http://username:password@host/path"));
+    assertThat(parse("http://username:@host/path"))
+        .isEqualTo(parse("http://username@host/path"));
+  }
+
+  @Test public void passwordWithEmptyUsername() throws Exception {
+    // Chrome doesn't mind, but Firefox rejects URLs with empty usernames and non-empty passwords.
+    assertThat(parse("http://:@host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http://:password@@host/path").encodedPassword())
+        .isEqualTo("password%40");
+  }
+
+  @Test public void unprintableCharactersArePercentEncoded() throws Exception {
+    assertThat(parse("http://host/\u0000").encodedPath()).isEqualTo("/%00");
+    assertThat(parse("http://host/\u0008").encodedPath()).isEqualTo("/%08");
+    assertThat(parse("http://host/\ufffd").encodedPath()).isEqualTo("/%EF%BF%BD");
+  }
+
+  @Test public void usernameCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.PERCENT, '[', ']', '{', '}', '|', '^', '\'', ';', '=', '@')
+        .override(Encoding.SKIP, ':', '/', '\\', '?', '#')
+        .skipForUri('%')
+        .test(Component.USER);
+  }
+
+  @Test public void passwordCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.PERCENT, '[', ']', '{', '}', '|', '^', '\'', ':', ';', '=', '@')
+        .override(Encoding.SKIP, '/', '\\', '?', '#')
+        .skipForUri('%')
+        .test(Component.PASSWORD);
+  }
+
+  @Test public void hostContainsIllegalCharacter() throws Exception {
+    assertInvalid("http://\n/", "Invalid URL host: \"\n\"");
+    assertInvalid("http:// /", "Invalid URL host: \" \"");
+    assertInvalid("http://%20/", "Invalid URL host: \"%20\"");
+  }
+
+  @Test public void hostnameLowercaseCharactersMappedDirectly() throws Exception {
+    assertThat(parse("http://abcd").host()).isEqualTo("abcd");
+    assertThat(parse("http://").host()).isEqualTo("xn--4xa");
+  }
+
+  @Test public void hostnameUppercaseCharactersConvertedToLowercase() throws Exception {
+    assertThat(parse("http://ABCD").host()).isEqualTo("abcd");
+    assertThat(parse("http://").host()).isEqualTo("xn--4xa");
+  }
+
+  @Test public void hostnameIgnoredCharacters() throws Exception {
+    // The soft hyphen () should be ignored.
+    assertThat(parse("http://AB\u00adCD").host()).isEqualTo("abcd");
+  }
+
+  @Test public void hostnameMultipleCharacterMapping() throws Exception {
+    // Map the single character telephone symbol () to the string "tel".
+    assertThat(parse("http://\u2121").host()).isEqualTo("tel");
+  }
+
+  @Test public void hostnameMappingLastMappedCodePoint() throws Exception {
+    assertThat(parse("http://\uD87E\uDE1D").host()).isEqualTo("xn--pu5l");
+  }
+
+  @Ignore("The java.net.IDN implementation doesn't ignore characters that it should.")
+  @Test public void hostnameMappingLastIgnoredCodePoint() throws Exception {
+    assertThat(parse("http://ab\uDB40\uDDEFcd").host()).isEqualTo("abcd");
+  }
+
+  @Test public void hostnameMappingLastDisallowedCodePoint() throws Exception {
+    assertInvalid("http://\uDBFF\uDFFF", "Invalid URL host: \"\uDBFF\uDFFF\"");
+  }
+
+  @Test public void hostIpv6() throws Exception {
+    // Square braces are absent from host()...
+    assertThat(parse("http://[::1]/").host()).isEqualTo("::1");
+
+    // ... but they're included in toString().
+    assertThat(parse("http://[::1]/").toString()).isEqualTo("http://[::1]/");
+
+    // IPv6 colons don't interfere with port numbers or passwords.
+    assertThat(parse("http://[::1]:8080/").port()).isEqualTo(8080);
+    assertThat(parse("http://user:password@[::1]/").password()).isEqualTo("password");
+    assertThat(parse("http://user:password@[::1]:8080/").host()).isEqualTo("::1");
+
+    // Permit the contents of IPv6 addresses to be percent-encoded...
+    assertThat(parse("http://[%3A%3A%31]/").host()).isEqualTo("::1");
+
+    // Including the Square braces themselves! (This is what Chrome does.)
+    assertThat(parse("http://%5B%3A%3A1%5D/").host()).isEqualTo("::1");
+  }
+
+  @Test public void hostIpv6AddressDifferentFormats() throws Exception {
+    // Multiple representations of the same address; see http://tools.ietf.org/html/rfc5952.
+    String a3 = "2001:db8::1:0:0:1";
+    assertThat(parse("http://[2001:db8:0:0:1:0:0:1]").host()).isEqualTo(a3);
+    assertThat(parse("http://[2001:0db8:0:0:1:0:0:1]").host()).isEqualTo(a3);
+    assertThat(parse("http://[2001:db8::1:0:0:1]").host()).isEqualTo(a3);
+    assertThat(parse("http://[2001:db8::0:1:0:0:1]").host()).isEqualTo(a3);
+    assertThat(parse("http://[2001:0db8::1:0:0:1]").host()).isEqualTo(a3);
+    assertThat(parse("http://[2001:db8:0:0:1::1]").host()).isEqualTo(a3);
+    assertThat(parse("http://[2001:db8:0000:0:1::1]").host()).isEqualTo(a3);
+    assertThat(parse("http://[2001:DB8:0:0:1::1]").host()).isEqualTo(a3);
+  }
+
+  @Test public void hostIpv6AddressLeadingCompression() throws Exception {
+    assertThat(parse("http://[::0001]").host()).isEqualTo("::1");
+    assertThat(parse("http://[0000::0001]").host()).isEqualTo("::1");
+    assertThat(parse("http://[0000:0000:0000:0000:0000:0000:0000:0001]").host())
+        .isEqualTo("::1");
+    assertThat(parse("http://[0000:0000:0000:0000:0000:0000::0001]").host())
+        .isEqualTo("::1");
+  }
+
+  @Test public void hostIpv6AddressTrailingCompression() throws Exception {
+    assertThat(parse("http://[0001:0000::]").host()).isEqualTo("1::");
+    assertThat(parse("http://[0001::0000]").host()).isEqualTo("1::");
+    assertThat(parse("http://[0001::]").host()).isEqualTo("1::");
+    assertThat(parse("http://[1::]").host()).isEqualTo("1::");
+  }
+
+  @Test public void hostIpv6AddressTooManyDigitsInGroup() throws Exception {
+    assertInvalid("http://[00000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[00000:0000:0000:0000:0000:0000:0000:0001]\"");
+    assertInvalid("http://[::00001]", "Invalid URL host: \"[::00001]\"");
+  }
+
+  @Test public void hostIpv6AddressMisplacedColons() throws Exception {
+    assertInvalid("http://[:0000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[:0000:0000:0000:0000:0000:0000:0000:0001]\"");
+    assertInvalid("http://[:::0000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[:::0000:0000:0000:0000:0000:0000:0000:0001]\"");
+    assertInvalid("http://[:1]", "Invalid URL host: \"[:1]\"");
+    assertInvalid("http://[:::1]", "Invalid URL host: \"[:::1]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0001:]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0001:]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001:]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001:]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001::]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001::]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001:::]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001:::]\"");
+    assertInvalid("http://[1:]", "Invalid URL host: \"[1:]\"");
+    assertInvalid("http://[1:::]", "Invalid URL host: \"[1:::]\"");
+    assertInvalid("http://[1:::1]", "Invalid URL host: \"[1:::1]\"");
+    assertInvalid("http://[0000:0000:0000:0000::0000:0000:0000:0001]",
+        "Invalid URL host: \"[0000:0000:0000:0000::0000:0000:0000:0001]\"");
+  }
+
+  @Test public void hostIpv6AddressTooManyGroups() throws Exception {
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0000:0001]\"");
+  }
+
+  @Test public void hostIpv6AddressTooMuchCompression() throws Exception {
+    assertInvalid("http://[0000::0000:0000:0000:0000::0001]",
+        "Invalid URL host: \"[0000::0000:0000:0000:0000::0001]\"");
+    assertInvalid("http://[::0000:0000:0000:0000::0001]",
+        "Invalid URL host: \"[::0000:0000:0000:0000::0001]\"");
+  }
+
+  @Test public void hostIpv6ScopedAddress() throws Exception {
+    // java.net.InetAddress parses scoped addresses. These aren't valid in URLs.
+    assertInvalid("http://[::1%2544]", "Invalid URL host: \"[::1%2544]\"");
+  }
+
+  @Test public void hostIpv6AddressTooManyLeadingZeros() throws Exception {
+    // Guava's been buggy on this case. https://github.com/google/guava/issues/3116
+    assertInvalid("http://[2001:db8:0:0:1:0:0:00001]",
+        "Invalid URL host: \"[2001:db8:0:0:1:0:0:00001]\"");
+  }
+
+  @Test public void hostIpv6WithIpv4Suffix() throws Exception {
+    assertThat(parse("http://[::1:255.255.255.255]/").host()).isEqualTo("::1:ffff:ffff");
+    assertThat(parse("http://[0:0:0:0:0:1:0.0.0.0]/").host()).isEqualTo("::1:0:0");
+  }
+
+  @Test public void hostIpv6WithIpv4SuffixWithOctalPrefix() throws Exception {
+    // Chrome interprets a leading '0' as octal; Firefox rejects them. (We reject them.)
+    assertInvalid("http://[0:0:0:0:0:1:0.0.0.000000]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.0.0.000000]\"");
+    assertInvalid("http://[0:0:0:0:0:1:0.010.0.010]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.010.0.010]\"");
+    assertInvalid("http://[0:0:0:0:0:1:0.0.0.000001]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.0.0.000001]\"");
+  }
+
+  @Test public void hostIpv6WithIpv4SuffixWithHexadecimalPrefix() throws Exception {
+    // Chrome interprets a leading '0x' as hexadecimal; Firefox rejects them. (We reject them.)
+    assertInvalid("http://[0:0:0:0:0:1:0.0x10.0.0x10]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.0x10.0.0x10]\"");
+  }
+
+  @Test public void hostIpv6WithMalformedIpv4Suffix() throws Exception {
+    assertInvalid("http://[0:0:0:0:0:1:0.0:0.0]/", "Invalid URL host: \"[0:0:0:0:0:1:0.0:0.0]\"");
+    assertInvalid("http://[0:0:0:0:0:1:0.0-0.0]/", "Invalid URL host: \"[0:0:0:0:0:1:0.0-0.0]\"");
+    assertInvalid("http://[0:0:0:0:0:1:.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:255..255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255..255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:255.255..255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255.255..255]\"");
+    assertInvalid("http://[0:0:0:0:0:0:1:255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:0:1:255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:256.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:256.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:ff.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:ff.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:0:1:255.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:0:1:255.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:1:255.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:1:255.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:1:0.0.0.0:1]/", "Invalid URL host: \"[0:0:0:0:1:0.0.0.0:1]\"");
+    assertInvalid("http://[0:0.0.0.0:1:0:0:0:0:1]/",
+        "Invalid URL host: \"[0:0.0.0.0:1:0:0:0:0:1]\"");
+    assertInvalid("http://[0.0.0.0:0:0:0:0:0:1]/", "Invalid URL host: \"[0.0.0.0:0:0:0:0:0:1]\"");
+  }
+
+  @Test public void hostIpv6WithIncompleteIpv4Suffix() throws Exception {
+    // To Chrome & Safari these are well-formed; Firefox disagrees. (We're consistent with Firefox).
+    assertInvalid("http://[0:0:0:0:0:1:255.255.255.]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255.255.255.]\"");
+    assertInvalid("http://[0:0:0:0:0:1:255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255.255.255]\"");
+  }
+
+  @Test public void hostIpv6Malformed() throws Exception {
+    assertInvalid("http://[::g]/", "Invalid URL host: \"[::g]\"");
+  }
+
+  @Test public void hostIpv6CanonicalForm() throws Exception {
+    assertThat(parse("http://[abcd:ef01:2345:6789:abcd:ef01:2345:6789]/").host())
+        .isEqualTo("abcd:ef01:2345:6789:abcd:ef01:2345:6789");
+    assertThat(parse("http://[a:0:0:0:b:0:0:0]/").host()).isEqualTo("a::b:0:0:0");
+    assertThat(parse("http://[a:b:0:0:c:0:0:0]/").host()).isEqualTo("a:b:0:0:c::");
+    assertThat(parse("http://[a:b:0:0:0:c:0:0]/").host()).isEqualTo("a:b::c:0:0");
+    assertThat(parse("http://[a:0:0:0:b:0:0:0]/").host()).isEqualTo("a::b:0:0:0");
+    assertThat(parse("http://[0:0:0:a:b:0:0:0]/").host()).isEqualTo("::a:b:0:0:0");
+    assertThat(parse("http://[0:0:0:a:0:0:0:b]/").host()).isEqualTo("::a:0:0:0:b");
+    assertThat(parse("http://[0:a:b:c:d:e:f:1]/").host()).isEqualTo("0:a:b:c:d:e:f:1");
+    assertThat(parse("http://[a:b:c:d:e:f:1:0]/").host()).isEqualTo("a:b:c:d:e:f:1:0");
+    assertThat(parse("http://[FF01:0:0:0:0:0:0:101]/").host()).isEqualTo("ff01::101");
+    assertThat(parse("http://[2001:db8::1]/").host()).isEqualTo("2001:db8::1");
+    assertThat(parse("http://[2001:db8:0:0:0:0:2:1]/").host()).isEqualTo("2001:db8::2:1");
+    assertThat(parse("http://[2001:db8:0:1:1:1:1:1]/").host())
+        .isEqualTo("2001:db8:0:1:1:1:1:1");
+    assertThat(parse("http://[2001:db8:0:0:1:0:0:1]/").host())
+        .isEqualTo("2001:db8::1:0:0:1");
+    assertThat(parse("http://[2001:0:0:1:0:0:0:1]/").host()).isEqualTo("2001:0:0:1::1");
+    assertThat(parse("http://[1:0:0:0:0:0:0:0]/").host()).isEqualTo("1::");
+    assertThat(parse("http://[0:0:0:0:0:0:0:1]/").host()).isEqualTo("::1");
+    assertThat(parse("http://[0:0:0:0:0:0:0:0]/").host()).isEqualTo("::");
+    assertThat(parse("http://[::ffff:c0a8:1fe]/").host()).isEqualTo("192.168.1.254");
+  }
+
+  /** The builder permits square braces but does not require them. */
+  @Test public void hostIpv6Builder() throws Exception {
+    HttpUrl base = parse("http://example.com/");
+    assertThat(base.newBuilder().host("[::1]").build().toString())
+        .isEqualTo("http://[::1]/");
+    assertThat(base.newBuilder().host("[::0001]").build().toString())
+        .isEqualTo("http://[::1]/");
+    assertThat(base.newBuilder().host("::1").build().toString()).isEqualTo("http://[::1]/");
+    assertThat(base.newBuilder().host("::0001").build().toString())
+        .isEqualTo("http://[::1]/");
+  }
+
+  @Test public void hostIpv4CanonicalForm() throws Exception {
+    assertThat(parse("http://255.255.255.255/").host()).isEqualTo("255.255.255.255");
+    assertThat(parse("http://1.2.3.4/").host()).isEqualTo("1.2.3.4");
+    assertThat(parse("http://0.0.0.0/").host()).isEqualTo("0.0.0.0");
+  }
+
+  @Test public void hostWithTrailingDot() throws Exception {
+    assertThat(parse("http://host./").host()).isEqualTo("host.");
+  }
+
+  @Test public void port() throws Exception {
+    assertThat(parse("http://host:80/")).isEqualTo(parse("http://host/"));
+    assertThat(parse("http://host:99/")).isEqualTo(parse("http://host:99/"));
+    assertThat(parse("http://host:/")).isEqualTo(parse("http://host/"));
+    assertThat(parse("http://host:65535/").port()).isEqualTo(65535);
+    assertInvalid("http://host:0/", "Invalid URL port: \"0\"");
+    assertInvalid("http://host:65536/", "Invalid URL port: \"65536\"");
+    assertInvalid("http://host:-1/", "Invalid URL port: \"-1\"");
+    assertInvalid("http://host:a/", "Invalid URL port: \"a\"");
+    assertInvalid("http://host:%39%39/", "Invalid URL port: \"%39%39\"");
+  }
+
+  @Test public void pathCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.PERCENT, '^', '{', '}', '|')
+        .override(Encoding.SKIP, '\\', '?', '#')
+        .skipForUri('%', '[', ']')
+        .test(Component.PATH);
+  }
+
+  @Test public void queryCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.IDENTITY, '?', '`')
+        .override(Encoding.PERCENT, '\'')
+        .override(Encoding.SKIP, '#', '+')
+        .skipForUri('%', '\\', '^', '`', '{', '|', '}')
+        .test(Component.QUERY);
+  }
+
+  @Test public void queryValueCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.IDENTITY, '?', '`')
+        .override(Encoding.PERCENT, '\'')
+        .override(Encoding.SKIP, '#', '+')
+        .skipForUri('%', '\\', '^', '`', '{', '|', '}')
+        .test(Component.QUERY_VALUE);
+  }
+
+  @Test public void fragmentCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.IDENTITY, ' ', '"', '#', '<', '>', '?', '`')
+        .skipForUri('%', ' ', '"', '#', '<', '>', '\\', '^', '`', '{', '|', '}')
+        .identityForNonAscii()
+        .test(Component.FRAGMENT);
+  }
+
+  @Test public void fragmentNonAscii() throws Exception {
+    HttpUrl url = parse("http://host/#");
+    assertThat(url.toString()).isEqualTo("http://host/#");
+    assertThat(url.fragment()).isEqualTo("");
+    assertThat(url.encodedFragment()).isEqualTo("");
+    assertThat(url.uri().toString()).isEqualTo("http://host/#");
+  }
+
+  @Test public void fragmentNonAsciiThatOffendsJavaNetUri() throws Exception {
+    HttpUrl url = parse("http://host/#\u0080");
+    assertThat(url.toString()).isEqualTo("http://host/#\u0080");
+    assertThat(url.fragment()).isEqualTo("\u0080");
+    assertThat(url.encodedFragment()).isEqualTo("\u0080");
+    // Control characters may be stripped!
+    assertThat(url.uri()).isEqualTo(new URI("http://host/#"));
+  }
+
+  @Test public void fragmentPercentEncodedNonAscii() throws Exception {
+    HttpUrl url = parse("http://host/#%C2%80");
+    assertThat(url.toString()).isEqualTo("http://host/#%C2%80");
+    assertThat(url.fragment()).isEqualTo("\u0080");
+    assertThat(url.encodedFragment()).isEqualTo("%C2%80");
+    assertThat(url.uri().toString()).isEqualTo("http://host/#%C2%80");
+  }
+
+  @Test public void fragmentPercentEncodedPartialCodePoint() throws Exception {
+    HttpUrl url = parse("http://host/#%80");
+    assertThat(url.toString()).isEqualTo("http://host/#%80");
+    // Unicode replacement character.
+    assertThat(url.fragment()).isEqualTo("\ufffd");
+    assertThat(url.encodedFragment()).isEqualTo("%80");
+    assertThat(url.uri().toString()).isEqualTo("http://host/#%80");
+  }
+
+  @Test public void relativePath() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.resolve("d/e/f")).isEqualTo(parse("http://host/a/b/d/e/f"));
+    assertThat(base.resolve("../../d/e/f")).isEqualTo(parse("http://host/d/e/f"));
+    assertThat(base.resolve("..")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve("../..")).isEqualTo(parse("http://host/"));
+    assertThat(base.resolve("../../..")).isEqualTo(parse("http://host/"));
+    assertThat(base.resolve(".")).isEqualTo(parse("http://host/a/b/"));
+    assertThat(base.resolve("././..")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve("c/d/../e/../")).isEqualTo(parse("http://host/a/b/c/"));
+    assertThat(base.resolve("..e/")).isEqualTo(parse("http://host/a/b/..e/"));
+    assertThat(base.resolve("e/f../")).isEqualTo(parse("http://host/a/b/e/f../"));
+    assertThat(base.resolve("%2E.")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve(".%2E")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve("%2E%2E")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve("%2e.")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve(".%2e")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve("%2e%2e")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve("%2E")).isEqualTo(parse("http://host/a/b/"));
+    assertThat(base.resolve("%2e")).isEqualTo(parse("http://host/a/b/"));
+  }
+
+  @Test public void relativePathWithTrailingSlash() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c/");
+    assertThat(base.resolve("..")).isEqualTo(parse("http://host/a/b/"));
+    assertThat(base.resolve("../")).isEqualTo(parse("http://host/a/b/"));
+    assertThat(base.resolve("../..")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve("../../")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve("../../..")).isEqualTo(parse("http://host/"));
+    assertThat(base.resolve("../../../")).isEqualTo(parse("http://host/"));
+    assertThat(base.resolve("../../../..")).isEqualTo(parse("http://host/"));
+    assertThat(base.resolve("../../../../")).isEqualTo(parse("http://host/"));
+    assertThat(base.resolve("../../../../a")).isEqualTo(parse("http://host/a"));
+    assertThat(base.resolve("../../../../a/..")).isEqualTo(parse("http://host/"));
+    assertThat(base.resolve("../../../../a/b/..")).isEqualTo(parse("http://host/a/"));
+  }
+
+  @Test public void pathWithBackslash() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.resolve("d\\e\\f")).isEqualTo(parse("http://host/a/b/d/e/f"));
+    assertThat(base.resolve("../..\\d\\e\\f")).isEqualTo(parse("http://host/d/e/f"));
+    assertThat(base.resolve("..\\..")).isEqualTo(parse("http://host/"));
+  }
+
+  @Test public void relativePathWithSameScheme() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.resolve("http:d/e/f")).isEqualTo(parse("http://host/a/b/d/e/f"));
+    assertThat(base.resolve("http:../../d/e/f")).isEqualTo(parse("http://host/d/e/f"));
+  }
+
+  @Test public void decodeUsername() {
+    assertThat(parse("http://user@host/").username()).isEqualTo("user");
+    assertThat(parse("http://%F0%9F%8D%A9@host/").username()).isEqualTo("\uD83C\uDF69");
+  }
+
+  @Test public void decodePassword() {
+    assertThat(parse("http://user:password@host/").password()).isEqualTo("password");
+    assertThat(parse("http://user:@host/").password()).isEqualTo("");
+    assertThat(parse("http://user:%F0%9F%8D%A9@host/").password())
+        .isEqualTo("\uD83C\uDF69");
+  }
+
+  @Test public void decodeSlashCharacterInDecodedPathSegment() {
+    assertThat(parse("http://host/a%2Fb%2Fc").pathSegments()).containsExactly("a/b/c");
+  }
+
+  @Test public void decodeEmptyPathSegments() {
+    assertThat(parse("http://host/").pathSegments()).containsExactly("");
+  }
+
+  @Test public void percentDecode() throws Exception {
+    assertThat(parse("http://host/%00").pathSegments()).containsExactly("\u0000");
+    assertThat(parse("http://host/a/%E2%98%83/c").pathSegments()).containsExactly("a", "\u2603", "c");
+    assertThat(parse("http://host/a/%F0%9F%8D%A9/c").pathSegments()).containsExactly("a", "\uD83C\uDF69", "c");
+    assertThat(parse("http://host/a/%62/c").pathSegments()).containsExactly("a", "b", "c");
+    assertThat(parse("http://host/a/%7A/c").pathSegments()).containsExactly("a", "z", "c");
+    assertThat(parse("http://host/a/%7a/c").pathSegments()).containsExactly("a", "z", "c");
+  }
+
+  @Test public void malformedPercentEncoding() {
+    assertThat(parse("http://host/a%f/b").pathSegments()).containsExactly("a%f", "b");
+    assertThat(parse("http://host/%/b").pathSegments()).containsExactly("%", "b");
+    assertThat(parse("http://host/%").pathSegments()).containsExactly("%");
+    assertThat(parse("http://github.com/%%30%30").pathSegments()).containsExactly("%00");
+  }
+
+  @Test public void malformedUtf8Encoding() {
+    // Replace a partial UTF-8 sequence with the Unicode replacement character.
+    assertThat(parse("http://host/a/%E2%98x/c").pathSegments())
+        .containsExactly("a", "\ufffdx", "c");
+  }
+
+  @Test public void incompleteUrlComposition() throws Exception {
+    try {
+      new HttpUrl.Builder().scheme("http").build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertThat(expected.getMessage()).isEqualTo("host == null");
+    }
+    try {
+      new HttpUrl.Builder().host("host").build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertThat(expected.getMessage()).isEqualTo("scheme == null");
+    }
+  }
+
+  @Test public void builderToString() {
+    assertThat(parse("https://host.com/path").newBuilder().toString())
+        .isEqualTo("https://host.com/path");
+  }
+
+  @Test public void incompleteBuilderToString() {
+    assertThat(new HttpUrl.Builder().scheme("https").encodedPath("/path").toString())
+        .isEqualTo("https:///path");
+    assertThat(new HttpUrl.Builder().host("host.com").encodedPath("/path").toString())
+        .isEqualTo("//host.com/path");
+    assertThat(new HttpUrl.Builder().host("host.com").encodedPath("/path").port(8080).toString())
+        .isEqualTo("//host.com:8080/path");
+  }
+
+  @Test public void minimalUrlComposition() throws Exception {
+    HttpUrl url = new HttpUrl.Builder().scheme("http").host("host").build();
+    assertThat(url.toString()).isEqualTo("http://host/");
+    assertThat(url.scheme()).isEqualTo("http");
+    assertThat(url.username()).isEqualTo("");
+    assertThat(url.password()).isEqualTo("");
+    assertThat(url.host()).isEqualTo("host");
+    assertThat(url.port()).isEqualTo(80);
+    assertThat(url.encodedPath()).isEqualTo("/");
+    assertThat(url.query()).isNull();
+    assertThat(url.fragment()).isNull();
+  }
+
+  @Test public void fullUrlComposition() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("username")
+        .password("password")
+        .host("host")
+        .port(8080)
+        .addPathSegment("path")
+        .query("query")
+        .fragment("fragment")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo("http://username:password@host:8080/path?query#fragment");
+    assertThat(url.scheme()).isEqualTo("http");
+    assertThat(url.username()).isEqualTo("username");
+    assertThat(url.password()).isEqualTo("password");
+    assertThat(url.host()).isEqualTo("host");
+    assertThat(url.port()).isEqualTo(8080);
+    assertThat(url.encodedPath()).isEqualTo("/path");
+    assertThat(url.query()).isEqualTo("query");
+    assertThat(url.fragment()).isEqualTo("fragment");
+  }
+
+  @Test public void changingSchemeChangesDefaultPort() throws Exception {
+    assertThat(parse("http://example.com")
+        .newBuilder()
+        .scheme("https")
+        .build().port()).isEqualTo(443);
+
+    assertThat(parse("https://example.com")
+        .newBuilder()
+        .scheme("http")
+        .build().port()).isEqualTo(80);
+
+    assertThat(parse("https://example.com:1234")
+        .newBuilder()
+        .scheme("http")
+        .build().port()).isEqualTo(1234);
+  }
+
+  @Test public void composeEncodesWhitespace() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("a\r\n\f\t b")
+        .password("c\r\n\f\t d")
+        .host("host")
+        .addPathSegment("e\r\n\f\t f")
+        .query("g\r\n\f\t h")
+        .fragment("i\r\n\f\t j")
+        .build();
+    assertThat(url.toString()).isEqualTo(("http://a%0D%0A%0C%09%20b:c%0D%0A%0C%09%20d@host"
+        + "/e%0D%0A%0C%09%20f?g%0D%0A%0C%09%20h#i%0D%0A%0C%09 j"));
+    assertThat(url.username()).isEqualTo("a\r\n\f\t b");
+    assertThat(url.password()).isEqualTo("c\r\n\f\t d");
+    assertThat(url.pathSegments().get(0)).isEqualTo("e\r\n\f\t f");
+    assertThat(url.query()).isEqualTo("g\r\n\f\t h");
+    assertThat(url.fragment()).isEqualTo("i\r\n\f\t j");
+  }
+
+  @Test public void composeFromUnencodedComponents() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("a:\u0001@/\\?#%b")
+        .password("c:\u0001@/\\?#%d")
+        .host("ef")
+        .port(8080)
+        .addPathSegment("g:\u0001@/\\?#%h")
+        .query("i:\u0001@/\\?#%j")
+        .fragment("k:\u0001@/\\?#%l")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo(("http://a%3A%01%40%2F%5C%3F%23%25b:c%3A%01%40%2F%5C%3F%23%25d@ef:8080/"
+        + "g:%01@%2F%5C%3F%23%25h?i:%01@/\\?%23%25j#k:%01@/\\?#%25l"));
+    assertThat(url.scheme()).isEqualTo("http");
+    assertThat(url.username()).isEqualTo("a:\u0001@/\\?#%b");
+    assertThat(url.password()).isEqualTo("c:\u0001@/\\?#%d");
+    assertThat(url.pathSegments()).containsExactly("g:\u0001@/\\?#%h");
+    assertThat(url.query()).isEqualTo("i:\u0001@/\\?#%j");
+    assertThat(url.fragment()).isEqualTo("k:\u0001@/\\?#%l");
+    assertThat(url.encodedUsername()).isEqualTo("a%3A%01%40%2F%5C%3F%23%25b");
+    assertThat(url.encodedPassword()).isEqualTo("c%3A%01%40%2F%5C%3F%23%25d");
+    assertThat(url.encodedPath()).isEqualTo("/g:%01@%2F%5C%3F%23%25h");
+    assertThat(url.encodedQuery()).isEqualTo("i:%01@/\\?%23%25j");
+    assertThat(url.encodedFragment()).isEqualTo("k:%01@/\\?#%25l");
+  }
+
+  @Test public void composeFromEncodedComponents() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .encodedUsername("a:\u0001@/\\?#%25b")
+        .encodedPassword("c:\u0001@/\\?#%25d")
+        .host("ef")
+        .port(8080)
+        .addEncodedPathSegment("g:\u0001@/\\?#%25h")
+        .encodedQuery("i:\u0001@/\\?#%25j")
+        .encodedFragment("k:\u0001@/\\?#%25l")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo(("http://a%3A%01%40%2F%5C%3F%23%25b:c%3A%01%40%2F%5C%3F%23%25d@ef:8080/"
+        + "g:%01@%2F%5C%3F%23%25h?i:%01@/\\?%23%25j#k:%01@/\\?#%25l"));
+    assertThat(url.scheme()).isEqualTo("http");
+    assertThat(url.username()).isEqualTo("a:\u0001@/\\?#%b");
+    assertThat(url.password()).isEqualTo("c:\u0001@/\\?#%d");
+    assertThat(url.pathSegments()).containsExactly("g:\u0001@/\\?#%h");
+    assertThat(url.query()).isEqualTo("i:\u0001@/\\?#%j");
+    assertThat(url.fragment()).isEqualTo("k:\u0001@/\\?#%l");
+    assertThat(url.encodedUsername()).isEqualTo("a%3A%01%40%2F%5C%3F%23%25b");
+    assertThat(url.encodedPassword()).isEqualTo("c%3A%01%40%2F%5C%3F%23%25d");
+    assertThat(url.encodedPath()).isEqualTo("/g:%01@%2F%5C%3F%23%25h");
+    assertThat(url.encodedQuery()).isEqualTo("i:%01@/\\?%23%25j");
+    assertThat(url.encodedFragment()).isEqualTo("k:%01@/\\?#%25l");
+  }
+
+  @Test public void composeWithEncodedPath() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .encodedPath("/a%2Fb/c")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/a%2Fb/c");
+    assertThat(url.encodedPath()).isEqualTo("/a%2Fb/c");
+    assertThat(url.pathSegments()).containsExactly("a/b", "c");
+  }
+
+  @Test public void composeMixingPathSegments() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .encodedPath("/a%2fb/c")
+        .addPathSegment("d%25e")
+        .addEncodedPathSegment("f%25g")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/a%2fb/c/d%2525e/f%25g");
+    assertThat(url.encodedPath()).isEqualTo("/a%2fb/c/d%2525e/f%25g");
+    assertThat(url.encodedPathSegments()).containsExactly("a%2fb", "c", "d%2525e", "f%25g");
+    assertThat(url.pathSegments()).containsExactly("a/b", "c", "d%25e", "f%g");
+  }
+
+  @Test public void composeWithAddSegment() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().addPathSegment("").build().encodedPath())
+        .isEqualTo("/a/b/c/");
+    assertThat(base.newBuilder().addPathSegment("").addPathSegment("d").build().encodedPath())
+        .isEqualTo("/a/b/c/d");
+    assertThat(base.newBuilder().addPathSegment("..").build().encodedPath())
+        .isEqualTo("/a/b/");
+    assertThat(base.newBuilder().addPathSegment("").addPathSegment("..").build().encodedPath())
+        .isEqualTo("/a/b/");
+    assertThat(base.newBuilder().addPathSegment("").addPathSegment("").build().encodedPath())
+        .isEqualTo("/a/b/c/");
+  }
+
+  @Test public void pathSize() throws Exception {
+    assertThat(parse("http://host/").pathSize()).isEqualTo(1);
+    assertThat(parse("http://host/a/b/c").pathSize()).isEqualTo(3);
+  }
+
+  @Test public void addPathSegments() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+
+    // Add a string with zero slashes: resulting URL gains one slash.
+    assertThat(base.newBuilder().addPathSegments("").build().encodedPath())
+        .isEqualTo("/a/b/c/");
+    assertThat(base.newBuilder().addPathSegments("d").build().encodedPath())
+        .isEqualTo("/a/b/c/d");
+
+    // Add a string with one slash: resulting URL gains two slashes.
+    assertThat(base.newBuilder().addPathSegments("/").build().encodedPath())
+        .isEqualTo("/a/b/c//");
+    assertThat(base.newBuilder().addPathSegments("d/").build().encodedPath())
+        .isEqualTo("/a/b/c/d/");
+    assertThat(base.newBuilder().addPathSegments("/d").build().encodedPath())
+        .isEqualTo("/a/b/c//d");
+
+    // Add a string with two slashes: resulting URL gains three slashes.
+    assertThat(base.newBuilder().addPathSegments("//").build().encodedPath())
+        .isEqualTo("/a/b/c///");
+    assertThat(base.newBuilder().addPathSegments("/d/").build().encodedPath())
+        .isEqualTo("/a/b/c//d/");
+    assertThat(base.newBuilder().addPathSegments("d//").build().encodedPath())
+        .isEqualTo("/a/b/c/d//");
+    assertThat(base.newBuilder().addPathSegments("//d").build().encodedPath())
+        .isEqualTo("/a/b/c///d");
+    assertThat(base.newBuilder().addPathSegments("d/e/f").build().encodedPath())
+        .isEqualTo("/a/b/c/d/e/f");
+  }
+
+  @Test public void addPathSegmentsOntoTrailingSlash() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c/");
+
+    // Add a string with zero slashes: resulting URL gains zero slashes.
+    assertThat(base.newBuilder().addPathSegments("").build().encodedPath())
+        .isEqualTo("/a/b/c/");
+    assertThat(base.newBuilder().addPathSegments("d").build().encodedPath())
+        .isEqualTo("/a/b/c/d");
+
+    // Add a string with one slash: resulting URL gains one slash.
+    assertThat(base.newBuilder().addPathSegments("/").build().encodedPath())
+        .isEqualTo("/a/b/c//");
+    assertThat(base.newBuilder().addPathSegments("d/").build().encodedPath())
+        .isEqualTo("/a/b/c/d/");
+    assertThat(base.newBuilder().addPathSegments("/d").build().encodedPath())
+        .isEqualTo("/a/b/c//d");
+
+    // Add a string with two slashes: resulting URL gains two slashes.
+    assertThat(base.newBuilder().addPathSegments("//").build().encodedPath())
+        .isEqualTo("/a/b/c///");
+    assertThat(base.newBuilder().addPathSegments("/d/").build().encodedPath())
+        .isEqualTo("/a/b/c//d/");
+    assertThat(base.newBuilder().addPathSegments("d//").build().encodedPath())
+        .isEqualTo("/a/b/c/d//");
+    assertThat(base.newBuilder().addPathSegments("//d").build().encodedPath())
+        .isEqualTo("/a/b/c///d");
+    assertThat(base.newBuilder().addPathSegments("d/e/f").build().encodedPath())
+        .isEqualTo("/a/b/c/d/e/f");
+  }
+
+  @Test public void addPathSegmentsWithBackslash() throws Exception {
+    HttpUrl base = parse("http://host/");
+    assertThat(base.newBuilder().addPathSegments("d\\e").build().encodedPath())
+        .isEqualTo("/d/e");
+    assertThat(base.newBuilder().addEncodedPathSegments("d\\e").build().encodedPath())
+        .isEqualTo("/d/e");
+  }
+
+  @Test public void addPathSegmentsWithEmptyPaths() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().addPathSegments("/d/e///f").build().encodedPath())
+        .isEqualTo("/a/b/c//d/e///f");
+  }
+
+  @Test public void addEncodedPathSegments() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(
+        (Object) base.newBuilder().addEncodedPathSegments("d/e/%20/\n").build().encodedPath())
+        .isEqualTo("/a/b/c/d/e/%20/");
+  }
+
+  @Test public void addPathSegmentDotDoesNothing() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().addPathSegment(".").build().encodedPath())
+        .isEqualTo("/a/b/c");
+  }
+
+  @Test public void addPathSegmentEncodes() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().addPathSegment("%2e").build().encodedPath())
+        .isEqualTo("/a/b/c/%252e");
+    assertThat(base.newBuilder().addPathSegment("%2e%2e").build().encodedPath())
+        .isEqualTo("/a/b/c/%252e%252e");
+  }
+
+  @Test public void addPathSegmentDotDotPopsDirectory() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().addPathSegment("..").build().encodedPath())
+        .isEqualTo("/a/b/");
+  }
+
+  @Test public void addPathSegmentDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().addPathSegment(".\n").build().encodedPath())
+        .isEqualTo("/a/b/c/.%0A");
+  }
+
+  @Test public void addEncodedPathSegmentDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().addEncodedPathSegment(".\n").build().encodedPath())
+        .isEqualTo("/a/b/c");
+  }
+
+  @Test public void addEncodedPathSegmentDotDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().addEncodedPathSegment("..\n").build().encodedPath())
+        .isEqualTo("/a/b/");
+  }
+
+  @Test public void setPathSegment() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().setPathSegment(0, "d").build().encodedPath())
+        .isEqualTo("/d/b/c");
+    assertThat(base.newBuilder().setPathSegment(1, "d").build().encodedPath())
+        .isEqualTo("/a/d/c");
+    assertThat(base.newBuilder().setPathSegment(2, "d").build().encodedPath())
+        .isEqualTo("/a/b/d");
+  }
+
+  @Test public void setPathSegmentEncodes() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().setPathSegment(0, "%25").build().encodedPath())
+        .isEqualTo("/%2525/b/c");
+    assertThat(base.newBuilder().setPathSegment(0, ".\n").build().encodedPath())
+        .isEqualTo("/.%0A/b/c");
+    assertThat(base.newBuilder().setPathSegment(0, "%2e").build().encodedPath())
+        .isEqualTo("/%252e/b/c");
+  }
+
+  @Test public void setPathSegmentAcceptsEmpty() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().setPathSegment(0, "").build().encodedPath())
+        .isEqualTo("//b/c");
+    assertThat(base.newBuilder().setPathSegment(2, "").build().encodedPath())
+        .isEqualTo("/a/b/");
+  }
+
+  @Test public void setPathSegmentRejectsDot() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setPathSegment(0, ".");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setPathSegmentRejectsDotDot() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setPathSegment(0, "..");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setPathSegmentWithSlash() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder().setPathSegment(1, "/").build();
+    assertThat(url.encodedPath()).isEqualTo("/a/%2F/c");
+  }
+
+  @Test public void setPathSegmentOutOfBounds() throws Exception {
+    try {
+      new HttpUrl.Builder().setPathSegment(1, "a");
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentEncodes() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().setEncodedPathSegment(0, "%25").build().encodedPath())
+        .isEqualTo("/%25/b/c");
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDot() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, ".");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, ".\n");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDotDot() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, "..");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDotDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, "..\n");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentWithSlash() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder().setEncodedPathSegment(1, "/").build();
+    assertThat(url.encodedPath()).isEqualTo("/a/%2F/c");
+  }
+
+  @Test public void setEncodedPathSegmentOutOfBounds() throws Exception {
+    try {
+      new HttpUrl.Builder().setEncodedPathSegment(1, "a");
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void removePathSegment() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder()
+        .removePathSegment(0)
+        .build();
+    assertThat(url.encodedPath()).isEqualTo("/b/c");
+  }
+
+  @Test public void removePathSegmentDoesntRemovePath() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder()
+        .removePathSegment(0)
+        .removePathSegment(0)
+        .removePathSegment(0)
+        .build();
+    assertThat(url.pathSegments()).containsExactly("");
+    assertThat(url.encodedPath()).isEqualTo("/");
+  }
+
+  @Test public void removePathSegmentOutOfBounds() throws Exception {
+    try {
+      new HttpUrl.Builder().removePathSegment(1);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void toJavaNetUrl() throws Exception {
+    HttpUrl httpUrl = parse("http://username:password@host/path?query#fragment");
+    URL javaNetUrl = httpUrl.url();
+    assertThat(javaNetUrl.toString())
+        .isEqualTo("http://username:password@host/path?query#fragment");
+  }
+
+  @Test public void toUri() throws Exception {
+    HttpUrl httpUrl = parse("http://username:password@host/path?query#fragment");
+    URI uri = httpUrl.uri();
+    assertThat(uri.toString())
+        .isEqualTo("http://username:password@host/path?query#fragment");
+  }
+
+  @Test public void toUriSpecialQueryCharacters() throws Exception {
+    HttpUrl httpUrl = parse("http://host/?d=abc!@[]^`{}|\\");
+    URI uri = httpUrl.uri();
+    assertThat(uri.toString()).isEqualTo("http://host/?d=abc!@[]%5E%60%7B%7D%7C%5C");
+  }
+
+  @Test public void toUriWithUsernameNoPassword() throws Exception {
+    HttpUrl httpUrl = new HttpUrl.Builder()
+        .scheme("http")
+        .username("user")
+        .host("host")
+        .build();
+    assertThat(httpUrl.toString()).isEqualTo("http://user@host/");
+    assertThat(httpUrl.uri().toString()).isEqualTo("http://user@host/");
+  }
+
+  @Test public void toUriUsernameSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .username("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo("http://%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/");
+    assertThat(url.uri().toString())
+        .isEqualTo("http://%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/");
+  }
+
+  @Test public void toUriPasswordSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .username("user")
+        .password("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo("http://user:%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/");
+    assertThat(url.uri().toString())
+        .isEqualTo("http://user:%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/");
+  }
+
+  @Test public void toUriPathSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addPathSegment("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/=[]:;%22~%7C%3F%23@%5E%2F$%25*");
+    assertThat(url.uri().toString())
+        .isEqualTo("http://host/=%5B%5D:;%22~%7C%3F%23@%5E%2F$%25*");
+  }
+
+  @Test public void toUriQueryParameterNameSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addQueryParameter("=[]:;\"~|?#@^/$%*", "a")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo("http://host/?%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*=a");
+    assertThat(url.uri().toString())
+        .isEqualTo("http://host/?%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*=a");
+    assertThat(url.queryParameter("=[]:;\"~|?#@^/$%*")).isEqualTo("a");
+  }
+
+  @Test public void toUriQueryParameterValueSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addQueryParameter("a", "=[]:;\"~|?#@^/$%*")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo("http://host/?a=%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*");
+    assertThat(url.uri().toString())
+        .isEqualTo("http://host/?a=%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*");
+    assertThat(url.queryParameter("a")).isEqualTo("=[]:;\"~|?#@^/$%*");
+  }
+
+  @Test public void toUriQueryValueSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .query("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/?=[]:;%22~|?%23@^/$%25*");
+    assertThat(url.uri().toString()).isEqualTo("http://host/?=[]:;%22~%7C?%23@%5E/$%25*");
+  }
+
+  @Test public void queryCharactersEncodedWhenComposed() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo("http://host/?a=%21%24%28%29%2C%2F%3A%3B%3F%40%5B%5D%5C%5E%60%7B%7C%7D%7E");
+    assertThat(url.queryParameter("a")).isEqualTo("!$(),/:;?@[]\\^`{|}~");
+  }
+
+  /**
+   * When callers use {@code addEncodedQueryParameter()} we only encode what's strictly required.
+   * We retain the encoded (or non-encoded) state of the input.
+   */
+  @Test public void queryCharactersNotReencodedWhenComposedWithAddEncoded() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addEncodedQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/?a=!$(),/:;?@[]\\^`{|}~");
+    assertThat(url.queryParameter("a")).isEqualTo("!$(),/:;?@[]\\^`{|}~");
+  }
+
+  /**
+   * When callers parse a URL with query components that aren't encoded, we shouldn't convert them
+   * into a canonical form because doing so could be semantically different.
+   */
+  @Test public void queryCharactersNotReencodedWhenParsed() throws Exception {
+    HttpUrl url = parse("http://host/?a=!$(),/:;?@[]\\^`{|}~");
+    assertThat(url.toString()).isEqualTo("http://host/?a=!$(),/:;?@[]\\^`{|}~");
+    assertThat(url.queryParameter("a")).isEqualTo("!$(),/:;?@[]\\^`{|}~");
+  }
+
+  @Test public void toUriFragmentSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .fragment("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/#=[]:;\"~|?#@^/$%25*");
+    assertThat(url.uri().toString()).isEqualTo("http://host/#=[]:;%22~%7C?%23@%5E/$%25*");
+  }
+
+  @Test public void toUriWithControlCharacters() throws Exception {
+    // Percent-encoded in the path.
+    assertThat(parse("http://host/a\u0000b").uri()).isEqualTo(new URI("http://host/a%00b"));
+    assertThat(parse("http://host/a\u0080b").uri())
+        .isEqualTo(new URI("http://host/a%C2%80b"));
+    assertThat(parse("http://host/a\u009fb").uri())
+        .isEqualTo(new URI("http://host/a%C2%9Fb"));
+    // Percent-encoded in the query.
+    assertThat(parse("http://host/?a\u0000b").uri())
+        .isEqualTo(new URI("http://host/?a%00b"));
+    assertThat(parse("http://host/?a\u0080b").uri())
+        .isEqualTo(new URI("http://host/?a%C2%80b"));
+    assertThat(parse("http://host/?a\u009fb").uri())
+        .isEqualTo(new URI("http://host/?a%C2%9Fb"));
+    // Stripped from the fragment.
+    assertThat(parse("http://host/#a\u0000b").uri())
+        .isEqualTo(new URI("http://host/#a%00b"));
+    assertThat(parse("http://host/#a\u0080b").uri()).isEqualTo(new URI("http://host/#ab"));
+    assertThat(parse("http://host/#a\u009fb").uri()).isEqualTo(new URI("http://host/#ab"));
+  }
+
+  @Test public void toUriWithSpaceCharacters() throws Exception {
+    // Percent-encoded in the path.
+    assertThat(parse("http://host/a\u000bb").uri()).isEqualTo(new URI("http://host/a%0Bb"));
+    assertThat(parse("http://host/a b").uri()).isEqualTo(new URI("http://host/a%20b"));
+    assertThat(parse("http://host/a\u2009b").uri())
+        .isEqualTo(new URI("http://host/a%E2%80%89b"));
+    assertThat(parse("http://host/a\u3000b").uri())
+        .isEqualTo(new URI("http://host/a%E3%80%80b"));
+    // Percent-encoded in the query.
+    assertThat(parse("http://host/?a\u000bb").uri())
+        .isEqualTo(new URI("http://host/?a%0Bb"));
+    assertThat(parse("http://host/?a b").uri()).isEqualTo(new URI("http://host/?a%20b"));
+    assertThat(parse("http://host/?a\u2009b").uri())
+        .isEqualTo(new URI("http://host/?a%E2%80%89b"));
+    assertThat(parse("http://host/?a\u3000b").uri())
+        .isEqualTo(new URI("http://host/?a%E3%80%80b"));
+    // Stripped from the fragment.
+    assertThat(parse("http://host/#a\u000bb").uri())
+        .isEqualTo(new URI("http://host/#a%0Bb"));
+    assertThat(parse("http://host/#a b").uri()).isEqualTo(new URI("http://host/#a%20b"));
+    assertThat(parse("http://host/#a\u2009b").uri()).isEqualTo(new URI("http://host/#ab"));
+    assertThat(parse("http://host/#a\u3000b").uri()).isEqualTo(new URI("http://host/#ab"));
+  }
+
+  @Test public void toUriWithNonHexPercentEscape() throws Exception {
+    assertThat(parse("http://host/%xx").uri()).isEqualTo(new URI("http://host/%25xx"));
+  }
+
+  @Test public void toUriWithTruncatedPercentEscape() throws Exception {
+    assertThat(parse("http://host/%a").uri()).isEqualTo(new URI("http://host/%25a"));
+    assertThat(parse("http://host/%").uri()).isEqualTo(new URI("http://host/%25"));
+  }
+
+  @Test public void fromJavaNetUrl() throws Exception {
+    URL javaNetUrl = new URL("http://username:password@host/path?query#fragment");
+    HttpUrl httpUrl = HttpUrl.get(javaNetUrl);
+    assertThat(httpUrl.toString())
+        .isEqualTo("http://username:password@host/path?query#fragment");
+  }
+
+  @Test public void fromJavaNetUrlUnsupportedScheme() throws Exception {
+    URL javaNetUrl = new URL("mailto:user@example.com");
+    assertThat(HttpUrl.get(javaNetUrl)).isNull();
+  }
+
+  @Test public void fromUri() throws Exception {
+    URI uri = new URI("http://username:password@host/path?query#fragment");
+    HttpUrl httpUrl = HttpUrl.get(uri);
+    assertThat(httpUrl.toString())
+        .isEqualTo("http://username:password@host/path?query#fragment");
+  }
+
+  @Test public void fromUriUnsupportedScheme() throws Exception {
+    URI uri = new URI("mailto:user@example.com");
+    assertThat(HttpUrl.get(uri)).isNull();
+  }
+
+  @Test public void fromUriPartial() throws Exception {
+    URI uri = new URI("/path");
+    assertThat(HttpUrl.get(uri)).isNull();
+  }
+
+  @Test public void composeQueryWithComponents() throws Exception {
+    HttpUrl base = parse("http://host/");
+    HttpUrl url = base.newBuilder().addQueryParameter("a+=& b", "c+=& d").build();
+    assertThat(url.toString()).isEqualTo("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d");
+    assertThat(url.queryParameterValue(0)).isEqualTo("c+=& d");
+    assertThat(url.queryParameterName(0)).isEqualTo("a+=& b");
+    assertThat(url.queryParameter("a+=& b")).isEqualTo("c+=& d");
+    assertThat(url.queryParameterNames()).isEqualTo(Collections.singleton("a+=& b"));
+    assertThat(url.queryParameterValues("a+=& b")).isEqualTo(singletonList("c+=& d"));
+    assertThat(url.querySize()).isEqualTo(1);
+    // Ambiguous! (Though working as designed.)
+    assertThat(url.query()).isEqualTo("a+=& b=c+=& d");
+    assertThat(url.encodedQuery()).isEqualTo("a%2B%3D%26%20b=c%2B%3D%26%20d");
+  }
+
+  @Test public void composeQueryWithEncodedComponents() throws Exception {
+    HttpUrl base = parse("http://host/");
+    HttpUrl url = base.newBuilder().addEncodedQueryParameter("a+=& b", "c+=& d").build();
+    assertThat(url.toString()).isEqualTo("http://host/?a+%3D%26%20b=c+%3D%26%20d");
+    assertThat(url.queryParameter("a =& b")).isEqualTo("c =& d");
+  }
+
+  @Test public void composeQueryRemoveQueryParameter() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .addQueryParameter("a+=& b", "c+=& d")
+        .removeAllQueryParameters("a+=& b")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/");
+    assertThat(url.queryParameter("a+=& b")).isNull();
+  }
+
+  @Test public void composeQueryRemoveEncodedQueryParameter() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .addEncodedQueryParameter("a+=& b", "c+=& d")
+        .removeAllEncodedQueryParameters("a+=& b")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/");
+    assertThat(url.queryParameter("a =& b")).isNull();
+  }
+
+  @Test public void composeQuerySetQueryParameter() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .addQueryParameter("a+=& b", "c+=& d")
+        .setQueryParameter("a+=& b", "ef")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/?a%2B%3D%26%20b=ef");
+    assertThat(url.queryParameter("a+=& b")).isEqualTo("ef");
+  }
+
+  @Test public void composeQuerySetEncodedQueryParameter() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .addEncodedQueryParameter("a+=& b", "c+=& d")
+        .setEncodedQueryParameter("a+=& b", "ef")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/?a+%3D%26%20b=ef");
+    assertThat(url.queryParameter("a =& b")).isEqualTo("ef");
+  }
+
+  @Test public void composeQueryMultipleEncodedValuesForParameter() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .addQueryParameter("a+=& b", "c+=& d")
+        .addQueryParameter("a+=& b", "e+=& f")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d&a%2B%3D%26%20b=e%2B%3D%26%20f");
+    assertThat(url.querySize()).isEqualTo(2);
+    assertThat(url.queryParameterNames()).isEqualTo(Collections.singleton("a+=& b"));
+    assertThat(url.queryParameterValues("a+=& b")).containsExactly("c+=& d", "e+=& f");
+  }
+
+  @Test public void absentQueryIsZeroNameValuePairs() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .query(null)
+        .build();
+    assertThat(url.querySize()).isEqualTo(0);
+  }
+
+  @Test public void emptyQueryIsSingleNameValuePairWithEmptyKey() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .query("")
+        .build();
+    assertThat(url.querySize()).isEqualTo(1);
+    assertThat(url.queryParameterName(0)).isEqualTo("");
+    assertThat(url.queryParameterValue(0)).isNull();
+  }
+
+  @Test public void ampersandQueryIsTwoNameValuePairsWithEmptyKeys() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .query("&")
+        .build();
+    assertThat(url.querySize()).isEqualTo(2);
+    assertThat(url.queryParameterName(0)).isEqualTo("");
+    assertThat(url.queryParameterValue(0)).isNull();
+    assertThat(url.queryParameterName(1)).isEqualTo("");
+    assertThat(url.queryParameterValue(1)).isNull();
+  }
+
+  @Test public void removeAllDoesNotRemoveQueryIfNoParametersWereRemoved() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .query("")
+        .removeAllQueryParameters("a")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/?");
+  }
+
+  @Test public void queryParametersWithoutValues() throws Exception {
+    HttpUrl url = parse("http://host/?foo&bar&baz");
+    assertThat(url.querySize()).isEqualTo(3);
+    assertThat(url.queryParameterNames()).containsExactly("foo", "bar", "baz");
+    assertThat(url.queryParameterValue(0)).isNull();
+    assertThat(url.queryParameterValue(1)).isNull();
+    assertThat(url.queryParameterValue(2)).isNull();
+    assertThat(url.queryParameterValues("foo")).isEqualTo(singletonList((String) null));
+    assertThat(url.queryParameterValues("bar")).isEqualTo(singletonList((String) null));
+    assertThat(url.queryParameterValues("baz")).isEqualTo(singletonList((String) null));
+  }
+
+  @Test public void queryParametersWithEmptyValues() throws Exception {
+    HttpUrl url = parse("http://host/?foo=&bar=&baz=");
+    assertThat(url.querySize()).isEqualTo(3);
+    assertThat(url.queryParameterNames()).containsExactly("foo", "bar", "baz");
+    assertThat(url.queryParameterValue(0)).isEqualTo("");
+    assertThat(url.queryParameterValue(1)).isEqualTo("");
+    assertThat(url.queryParameterValue(2)).isEqualTo("");
+    assertThat(url.queryParameterValues("foo")).isEqualTo(singletonList(""));
+    assertThat(url.queryParameterValues("bar")).isEqualTo(singletonList(""));
+    assertThat(url.queryParameterValues("baz")).isEqualTo(singletonList(""));
+  }
+
+  @Test public void queryParametersWithRepeatedName() throws Exception {
+    HttpUrl url = parse("http://host/?foo[]=1&foo[]=2&foo[]=3");
+    assertThat(url.querySize()).isEqualTo(3);
+    assertThat(url.queryParameterNames()).isEqualTo(Collections.singleton("foo[]"));
+    assertThat(url.queryParameterValue(0)).isEqualTo("1");
+    assertThat(url.queryParameterValue(1)).isEqualTo("2");
+    assertThat(url.queryParameterValue(2)).isEqualTo("3");
+    assertThat(url.queryParameterValues("foo[]")).containsExactly("1", "2", "3");
+  }
+
+  @Test public void queryParameterLookupWithNonCanonicalEncoding() throws Exception {
+    HttpUrl url = parse("http://host/?%6d=m&+=%20");
+    assertThat(url.queryParameterName(0)).isEqualTo("m");
+    assertThat(url.queryParameterName(1)).isEqualTo(" ");
+    assertThat(url.queryParameter("m")).isEqualTo("m");
+    assertThat(url.queryParameter(" ")).isEqualTo(" ");
+  }
+
+  @Test public void parsedQueryDoesntIncludeFragment() {
+    HttpUrl url = parse("http://host/?#fragment");
+    assertThat(url.fragment()).isEqualTo("fragment");
+    assertThat(url.query()).isEqualTo("");
+    assertThat(url.encodedQuery()).isEqualTo("");
+  }
+
+  @Test public void roundTripBuilder() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("%")
+        .password("%")
+        .host("host")
+        .addPathSegment("%")
+        .query("%")
+        .fragment("%")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://%25:%25@host/%25?%25#%25");
+    assertThat(url.newBuilder().build().toString())
+        .isEqualTo("http://%25:%25@host/%25?%25#%25");
+    assertThat(url.resolve("").toString()).isEqualTo("http://%25:%25@host/%25?%25");
+  }
+
+  /**
+   * Although HttpUrl prefers percent-encodings in uppercase, it should preserve the exact structure
+   * of the original encoding.
+   */
+  @Test public void rawEncodingRetained() throws Exception {
+    String urlString = "http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D#%6d%6D";
+    HttpUrl url = parse(urlString);
+    assertThat(url.encodedUsername()).isEqualTo("%6d%6D");
+    assertThat(url.encodedPassword()).isEqualTo("%6d%6D");
+    assertThat(url.encodedPath()).isEqualTo("/%6d%6D");
+    assertThat(url.encodedPathSegments()).containsExactly("%6d%6D");
+    assertThat(url.encodedQuery()).isEqualTo("%6d%6D");
+    assertThat(url.encodedFragment()).isEqualTo("%6d%6D");
+    assertThat(url.toString()).isEqualTo(urlString);
+    assertThat(url.newBuilder().build().toString()).isEqualTo(urlString);
+    assertThat(url.resolve("").toString())
+        .isEqualTo("http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D");
+  }
+
+  @Test public void clearFragment() throws Exception {
+    HttpUrl url = parse("http://host/#fragment")
+        .newBuilder()
+        .fragment(null)
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/");
+    assertThat(url.fragment()).isNull();
+    assertThat(url.encodedFragment()).isNull();
+  }
+
+  @Test public void clearEncodedFragment() throws Exception {
+    HttpUrl url = parse("http://host/#fragment")
+        .newBuilder()
+        .encodedFragment(null)
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/");
+    assertThat(url.fragment()).isNull();
+    assertThat(url.encodedFragment()).isNull();
+  }
+
+  @Test public void topPrivateDomain() {
+    assertThat(parse("https://google.com").topPrivateDomain()).isEqualTo("google.com");
+    assertThat(parse("https://adwords.google.co.uk").topPrivateDomain())
+        .isEqualTo("google.co.uk");
+    assertThat(parse("https://..jp").topPrivateDomain())
+        .isEqualTo("xn--ewv.xn--4pvxs.jp");
+    assertThat(parse("https://xn--ewv.xn--4pvxs.jp").topPrivateDomain())
+        .isEqualTo("xn--ewv.xn--4pvxs.jp");
+
+    assertThat(parse("https://co.uk").topPrivateDomain()).isNull();
+    assertThat(parse("https://square").topPrivateDomain()).isNull();
+    assertThat(parse("https://.jp").topPrivateDomain()).isNull();
+    assertThat(parse("https://xn--4pvxs.jp").topPrivateDomain()).isNull();
+    assertThat(parse("https://localhost").topPrivateDomain()).isNull();
+    assertThat(parse("https://127.0.0.1").topPrivateDomain()).isNull();
+  }
+
+  private void assertInvalid(String string, String exceptionMessage) {
+    if (useGet) {
+      try {
+        parse(string);
+        fail("Expected get of \"" + string + "\" to throw with: " + exceptionMessage);
+      } catch (IllegalArgumentException e) {
+        assertThat(e.getMessage()).isEqualTo(exceptionMessage);
+      }
+    } else {
+      assertThat(parse(string)).overridingErrorMessage(string).isNull();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java b/okhttp/src/test/java/okhttp3/InterceptorTest.java
similarity index 86%
rename from okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
rename to okhttp/src/test/java/okhttp3/InterceptorTest.java
index 7de63fc138..026ce67daf 100644
--- a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp/src/test/java/okhttp3/InterceptorTest.java
@@ -19,7 +19,6 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketTimeoutException;
-import java.util.Arrays;
 import java.util.Locale;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
@@ -42,19 +41,14 @@
 import org.junit.Rule;
 import org.junit.Test;
 
-import static okhttp3.TestUtil.defaultClient;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class InterceptorTest {
   @Rule public MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
-  private OkHttpClient client = defaultClient();
+  private OkHttpClient client = clientTestRule.client;
   private RecordingCallback callback = new RecordingCallback();
 
   @Test public void applicationInterceptorsCanShortCircuitResponses() throws Exception {
@@ -77,7 +71,7 @@
         .build();
 
     Response response = client.newCall(request).execute();
-    assertSame(interceptorResponse, response);
+    assertThat(response).isSameAs(interceptorResponse);
   }
 
   @Test public void networkInterceptorsCannotShortCircuitResponses() throws Exception {
@@ -102,8 +96,8 @@
       client.newCall(request).execute();
       fail();
     } catch (IllegalStateException expected) {
-      assertEquals("network interceptor " + interceptor + " must call proceed() exactly once",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("network interceptor " + interceptor + " must call proceed() exactly once"));
     }
   }
 
@@ -127,8 +121,8 @@
       client.newCall(request).execute();
       fail();
     } catch (IllegalStateException expected) {
-      assertEquals("network interceptor " + interceptor + " must call proceed() exactly once",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("network interceptor " + interceptor + " must call proceed() exactly once"));
     }
   }
 
@@ -155,8 +149,8 @@
       client.newCall(request).execute();
       fail();
     } catch (IllegalStateException expected) {
-      assertEquals("network interceptor " + interceptor + " must retain the same host and port",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("network interceptor " + interceptor + " must retain the same host and port"));
     }
   }
 
@@ -165,7 +159,7 @@
 
     Interceptor interceptor = chain -> {
       Connection connection = chain.connection();
-      assertNotNull(connection);
+      assertThat(connection).isNotNull();
       return chain.proceed(chain.request());
     };
     client = client.newBuilder()
@@ -186,14 +180,14 @@
     Interceptor interceptor = chain -> {
       // The network request has everything: User-Agent, Host, Accept-Encoding.
       Request networkRequest = chain.request();
-      assertNotNull(networkRequest.header("User-Agent"));
-      assertEquals(server.getHostName() + ":" + server.getPort(),
-          networkRequest.header("Host"));
-      assertNotNull(networkRequest.header("Accept-Encoding"));
+      assertThat(networkRequest.header("User-Agent")).isNotNull();
+      assertThat(networkRequest.header("Host")).isEqualTo(
+          (server.getHostName() + ":" + server.getPort()));
+      assertThat(networkRequest.header("Accept-Encoding")).isNotNull();
 
       // The network response also has everything, including the raw gzipped content.
       Response networkResponse = chain.proceed(networkRequest);
-      assertEquals("gzip", networkResponse.header("Content-Encoding"));
+      assertThat(networkResponse.header("Content-Encoding")).isEqualTo("gzip");
       return networkResponse;
     };
     client = client.newBuilder()
@@ -205,14 +199,14 @@
         .build();
 
     // No extra headers in the application's request.
-    assertNull(request.header("User-Agent"));
-    assertNull(request.header("Host"));
-    assertNull(request.header("Accept-Encoding"));
+    assertThat(request.header("User-Agent")).isNull();
+    assertThat(request.header("Host")).isNull();
+    assertThat(request.header("Accept-Encoding")).isNull();
 
     // No extra headers in the application's response.
     Response response = client.newCall(request).execute();
-    assertNull(request.header("Content-Encoding"));
-    assertEquals("abcabcabc", response.body().string());
+    assertThat(request.header("Content-Encoding")).isNull();
+    assertThat(response.body().string()).isEqualTo("abcabcabc");
   }
 
   @Test public void networkInterceptorsCanChangeRequestMethodFromGetToPost() throws Exception {
@@ -240,8 +234,8 @@
     client.newCall(request).execute();
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("POST", recordedRequest.getMethod());
-    assertEquals("abc", recordedRequest.getBody().readUtf8());
+    assertThat(recordedRequest.getMethod()).isEqualTo("POST");
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("abc");
   }
 
   @Test public void applicationInterceptorsRewriteRequestToServer() throws Exception {
@@ -272,10 +266,10 @@ private void rewriteRequestToServer(boolean network) throws Exception {
     client.newCall(request).execute();
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("ABC", recordedRequest.getBody().readUtf8());
-    assertEquals("foo", recordedRequest.getHeader("Original-Header"));
-    assertEquals("yep", recordedRequest.getHeader("OkHttp-Intercepted"));
-    assertEquals("POST", recordedRequest.getMethod());
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("ABC");
+    assertThat(recordedRequest.getHeader("Original-Header")).isEqualTo("foo");
+    assertThat(recordedRequest.getHeader("OkHttp-Intercepted")).isEqualTo("yep");
+    assertThat(recordedRequest.getMethod()).isEqualTo("POST");
   }
 
   @Test public void applicationInterceptorsRewriteResponseFromServer() throws Exception {
@@ -304,9 +298,9 @@ private void rewriteResponseFromServer(boolean network) throws Exception {
         .build();
 
     Response response = client.newCall(request).execute();
-    assertEquals("ABC", response.body().string());
-    assertEquals("yep", response.header("OkHttp-Intercepted"));
-    assertEquals("foo", response.header("Original-Header"));
+    assertThat(response.body().string()).isEqualTo("ABC");
+    assertThat(response.header("OkHttp-Intercepted")).isEqualTo("yep");
+    assertThat(response.header("Original-Header")).isEqualTo("foo");
   }
 
   @Test public void multipleApplicationInterceptors() throws Exception {
@@ -344,12 +338,11 @@ private void multipleInterceptors(boolean network) throws Exception {
         .build();
 
     Response response = client.newCall(request).execute();
-    assertEquals(Arrays.asList("Cupcake", "Donut"),
-        response.headers("Response-Interceptor"));
+    assertThat(response.headers("Response-Interceptor")).containsExactly("Cupcake", "Donut");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(Arrays.asList("Android", "Bob"),
-        recordedRequest.getHeaders().values("Request-Interceptor"));
+    assertThat(recordedRequest.getHeaders().values("Request-Interceptor"))
+        .containsExactly("Android", "Bob");
   }
 
   @Test public void asyncApplicationInterceptors() throws Exception {
@@ -397,7 +390,7 @@ private void asyncInterceptors(boolean network) throws Exception {
         .build();
 
     Response response = client.newCall(request).execute();
-    assertEquals(response.body().string(), "b");
+    assertThat("b").isEqualTo(response.body().string());
   }
 
   /** Make sure interceptors can interact with the OkHttp client. */
@@ -412,7 +405,7 @@ private void asyncInterceptors(boolean network) throws Exception {
                 .url(server.url("/a"))
                 .build();
             Response responseA = client.newCall(requestA).execute();
-            assertEquals("a", responseA.body().string());
+            assertThat(responseA.body().string()).isEqualTo("a");
           }
 
           return chain.proceed(chain.request());
@@ -423,7 +416,7 @@ private void asyncInterceptors(boolean network) throws Exception {
         .url(server.url("/b"))
         .build();
     Response responseB = client.newCall(requestB).execute();
-    assertEquals("b", responseB.body().string());
+    assertThat(responseB.body().string()).isEqualTo("b");
   }
 
   /** Make sure interceptors can interact with the OkHttp client asynchronously. */
@@ -482,7 +475,7 @@ private void interceptorThrowsRuntimeExceptionSynchronous(boolean network) throw
       client.newCall(request).execute();
       fail();
     } catch (RuntimeException expected) {
-      assertEquals("boom!", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("boom!");
     }
   }
 
@@ -507,9 +500,10 @@ private void interceptorThrowsRuntimeExceptionSynchronous(boolean network) throw
         .build();
 
     Response response = client.newCall(request).execute();
-    assertNotNull(response.request().header("User-Agent"));
-    assertEquals("user request", response.request().header("User-Agent"));
-    assertEquals("intercepted request", response.networkResponse().request().header("User-Agent"));
+    assertThat(response.request().header("User-Agent")).isNotNull();
+    assertThat(response.request().header("User-Agent")).isEqualTo("user request");
+    assertThat(response.networkResponse().request().header("User-Agent")).isEqualTo(
+        "intercepted request");
   }
 
   @Test public void applicationInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
@@ -537,7 +531,7 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
         .build();
     client.newCall(request).enqueue(callback);
 
-    assertEquals("boom!", executor.takeException().getMessage());
+    assertThat(executor.takeException().getMessage()).isEqualTo("boom!");
   }
 
   @Test public void applicationInterceptorReturnsNull() throws Exception {
@@ -563,7 +557,8 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       client.newCall(request).execute();
       fail();
     } catch (NullPointerException expected) {
-      assertEquals("interceptor " + interceptor + " returned null", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("interceptor " + interceptor + " returned null"));
     }
   }
 
@@ -590,7 +585,8 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       client.newCall(request).execute();
       fail();
     } catch (NullPointerException expected) {
-      assertEquals("interceptor " + interceptor + " returned null", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("interceptor " + interceptor + " returned null"));
     }
   }
 
@@ -601,7 +597,7 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
 
     Interceptor interceptor = chain -> {
       Response response = chain.proceed(chain.request());
-      assertNotNull(chain.connection());
+      assertThat(chain.connection()).isNotNull();
       return response;
     };
 
@@ -637,8 +633,8 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       client.newCall(request).execute();
       fail();
     } catch (IllegalStateException expected) {
-      assertEquals("interceptor " + interceptor + " returned a response with no body",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("interceptor " + interceptor + " returned a response with no body"));
     }
   }
 
@@ -662,23 +658,23 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       client.newCall(request).execute();
       fail();
     } catch (IllegalStateException expected) {
-      assertEquals("interceptor " + interceptor + " returned a response with no body",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("interceptor " + interceptor + " returned a response with no body"));
     }
   }
 
   @Test public void connectTimeout() throws Exception {
     Interceptor interceptor1 = chainA -> {
-      assertEquals(5000, chainA.connectTimeoutMillis());
+      assertThat(chainA.connectTimeoutMillis()).isEqualTo(5000);
 
       Interceptor.Chain chainB = chainA.withConnectTimeout(100, TimeUnit.MILLISECONDS);
-      assertEquals(100, chainB.connectTimeoutMillis());
+      assertThat(chainB.connectTimeoutMillis()).isEqualTo(100);
 
       return chainB.proceed(chainA.request());
     };
 
     Interceptor interceptor2 = chain -> {
-      assertEquals(100, chain.connectTimeoutMillis());
+      assertThat(chain.connectTimeoutMillis()).isEqualTo(100);
       return chain.proceed(chain.request());
     };
 
@@ -713,16 +709,16 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
 
   @Test public void chainWithReadTimeout() throws Exception {
     Interceptor interceptor1 = chainA -> {
-      assertEquals(5000, chainA.readTimeoutMillis());
+      assertThat(chainA.readTimeoutMillis()).isEqualTo(5000);
 
       Interceptor.Chain chainB = chainA.withReadTimeout(100, TimeUnit.MILLISECONDS);
-      assertEquals(100, chainB.readTimeoutMillis());
+      assertThat(chainB.readTimeoutMillis()).isEqualTo(100);
 
       return chainB.proceed(chainA.request());
     };
 
     Interceptor interceptor2 = chain -> {
-      assertEquals(100, chain.readTimeoutMillis());
+      assertThat(chain.readTimeoutMillis()).isEqualTo(100);
       return chain.proceed(chain.request());
     };
 
@@ -751,16 +747,16 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
 
   @Test public void chainWithWriteTimeout() throws Exception {
     Interceptor interceptor1 = chainA -> {
-      assertEquals(5000, chainA.writeTimeoutMillis());
+      assertThat(chainA.writeTimeoutMillis()).isEqualTo(5000);
 
       Interceptor.Chain chainB = chainA.withWriteTimeout(100, TimeUnit.MILLISECONDS);
-      assertEquals(100, chainB.writeTimeoutMillis());
+      assertThat(chainB.writeTimeoutMillis()).isEqualTo(100);
 
       return chainB.proceed(chainA.request());
     };
 
     Interceptor interceptor2 = chain -> {
-      assertEquals(100, chain.writeTimeoutMillis());
+      assertThat(chain.writeTimeoutMillis()).isEqualTo(100);
       return chain.proceed(chain.request());
     };
 
@@ -795,9 +791,9 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       Call call = chain.call();
       callRef.set(call);
 
-      assertFalse(call.isCanceled());
+      assertThat(call.isCanceled()).isFalse();
       call.cancel();
-      assertTrue(call.isCanceled());
+      assertThat(call.isCanceled()).isTrue();
 
       return chain.proceed(chain.request());
     };
@@ -817,7 +813,7 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
     } catch (IOException expected) {
     }
 
-    assertSame(call, callRef.get());
+    assertThat(callRef.get()).isSameAs(call);
   }
 
   private RequestBody uppercase(RequestBody original) {
diff --git a/okhttp/src/test/java/okhttp3/KotlinSourceCompatibilityTest.kt b/okhttp/src/test/java/okhttp3/KotlinSourceCompatibilityTest.kt
new file mode 100644
index 0000000000..680538ca82
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/KotlinSourceCompatibilityTest.kt
@@ -0,0 +1,1229 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.http2.Settings
+import okhttp3.internal.proxy.NullProxySelector
+import okhttp3.internal.tls.OkHostnameVerifier
+import okhttp3.logging.HttpLoggingInterceptor
+import okhttp3.logging.LoggingEventListener
+import okhttp3.mockwebserver.MockResponse
+import okhttp3.mockwebserver.MockWebServer
+import okhttp3.mockwebserver.PushPromise
+import okhttp3.mockwebserver.QueueDispatcher
+import okhttp3.mockwebserver.RecordedRequest
+import okhttp3.mockwebserver.SocketPolicy
+import okhttp3.tls.HandshakeCertificates
+import okhttp3.tls.HeldCertificate
+import okhttp3.tls.internal.TlsUtil.localhost
+import okio.Buffer
+import okio.BufferedSink
+import okio.BufferedSource
+import okio.ByteString
+import okio.Timeout
+import org.junit.Ignore
+import org.junit.Test
+import java.io.File
+import java.io.IOException
+import java.math.BigInteger
+import java.net.CookieHandler
+import java.net.InetAddress
+import java.net.InetSocketAddress
+import java.net.Proxy
+import java.net.ProxySelector
+import java.net.Socket
+import java.net.URI
+import java.net.URL
+import java.nio.charset.Charset
+import java.security.KeyPair
+import java.security.KeyPairGenerator
+import java.security.Principal
+import java.security.cert.Certificate
+import java.security.cert.X509Certificate
+import java.time.Duration
+import java.time.Instant
+import java.util.Date
+import java.util.concurrent.ExecutorService
+import java.util.concurrent.Executors
+import java.util.concurrent.TimeUnit
+import javax.net.ServerSocketFactory
+import javax.net.SocketFactory
+import javax.net.ssl.HostnameVerifier
+import javax.net.ssl.SSLContext
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509KeyManager
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Access every type, function, and property from Kotlin to defend against unexpected regressions in
+ * source-compatibility.
+ *
+ * Unlike most tests we're only really interested in whether this test compiles: it's output is not
+ * interesting. Do not simplify this code by removing unused declarations or unnecessary types;
+ * doing so limits the utility of the test.
+ */
+@Suppress(
+    "ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE",
+    "DEPRECATION",
+    "RedundantExplicitType",
+    "RedundantLambdaArrow",
+    "UNUSED_ANONYMOUS_PARAMETER",
+    "UNUSED_VALUE",
+    "UNUSED_VARIABLE",
+    "VARIABLE_WITH_REDUNDANT_INITIALIZER"
+)
+class KotlinSourceCompatibilityTest {
+  @Test @Ignore
+  fun address() {
+    val address: Address = newAddress()
+    val url: HttpUrl = address.url()
+    val dns: Dns = address.dns()
+    val socketFactory: SocketFactory = address.socketFactory()
+    val proxyAuthenticator: Authenticator = address.proxyAuthenticator()
+    val protocols: List<Protocol> = address.protocols()
+    val connectionSpecs: List<ConnectionSpec> = address.connectionSpecs()
+    val proxySelector: ProxySelector = address.proxySelector()
+    val sslSocketFactory: SSLSocketFactory? = address.sslSocketFactory()
+    val hostnameVerifier: HostnameVerifier? = address.hostnameVerifier()
+    val certificatePinner: CertificatePinner? = address.certificatePinner()
+  }
+
+  @Test @Ignore
+  fun authenticator() {
+    var authenticator: Authenticator = object : Authenticator {
+      override fun authenticate(route: Route?, response: Response): Request? = TODO()
+    }
+    authenticator = Authenticator { route: Route?, response: Response -> TODO() }
+  }
+
+  @Test @Ignore
+  fun cache() {
+    val cache = Cache(File("/cache/"), Integer.MAX_VALUE.toLong())
+    cache.initialize()
+    cache.delete()
+    cache.evictAll()
+    val urls: MutableIterator<String> = cache.urls()
+    val writeAbortCount: Int = cache.writeAbortCount()
+    val writeSuccessCount: Int = cache.writeSuccessCount()
+    val size: Long = cache.size()
+    val maxSize: Long = cache.maxSize()
+    cache.flush()
+    cache.close()
+    val directory: File = cache.directory()
+    val networkCount: Int = cache.networkCount()
+    val hitCount: Int = cache.hitCount()
+    val requestCount: Int = cache.requestCount()
+  }
+
+  @Test @Ignore
+  fun cacheControl() {
+    val cacheControl: CacheControl = CacheControl.Builder().build()
+    val noCache: Boolean = cacheControl.noCache()
+    val noStore: Boolean = cacheControl.noStore()
+    val maxAgeSeconds: Int = cacheControl.maxAgeSeconds()
+    val sMaxAgeSeconds: Int = cacheControl.sMaxAgeSeconds()
+    val mustRevalidate: Boolean = cacheControl.mustRevalidate()
+    val maxStaleSeconds: Int = cacheControl.maxStaleSeconds()
+    val minFreshSeconds: Int = cacheControl.minFreshSeconds()
+    val onlyIfCached: Boolean = cacheControl.onlyIfCached()
+    val noTransform: Boolean = cacheControl.noTransform()
+    val immutable: Boolean = cacheControl.immutable()
+    val forceCache: CacheControl = CacheControl.FORCE_CACHE
+    val forceNetwork: CacheControl = CacheControl.FORCE_NETWORK
+    val parse: CacheControl = CacheControl.parse(Headers.of())
+  }
+
+  @Test @Ignore
+  fun cacheControlBuilder() {
+    var builder: CacheControl.Builder = CacheControl.Builder()
+    builder = builder.noCache()
+    builder = builder.noStore()
+    builder = builder.maxAge(0, TimeUnit.MILLISECONDS)
+    builder = builder.maxStale(0, TimeUnit.MILLISECONDS)
+    builder = builder.minFresh(0, TimeUnit.MILLISECONDS)
+    builder = builder.onlyIfCached()
+    builder = builder.noTransform()
+    builder = builder.immutable()
+    val cacheControl: CacheControl = builder.build()
+  }
+
+  @Test @Ignore
+  fun call() {
+    val call: Call = newCall()
+  }
+
+  @Test @Ignore
+  fun callback() {
+    val callback = object : Callback {
+      override fun onFailure(call: Call, e: IOException) = TODO()
+      override fun onResponse(call: Call, response: Response) = TODO()
+    }
+  }
+
+  @Test @Ignore
+  fun certificatePinner() {
+    val heldCertificate: HeldCertificate = HeldCertificate.Builder().build()
+    val certificate: X509Certificate = heldCertificate.certificate()
+    val certificatePinner: CertificatePinner = CertificatePinner.Builder().build()
+    val certificates: List<Certificate> = listOf()
+    certificatePinner.check("", listOf(certificate))
+    certificatePinner.check("", certificate, certificate)
+    val pin: String = CertificatePinner.pin(certificate)
+    val default: CertificatePinner = CertificatePinner.DEFAULT
+  }
+
+  @Test @Ignore
+  fun certificatePinnerBuilder() {
+    val builder: CertificatePinner.Builder = CertificatePinner.Builder()
+    builder.add("", "pin1", "pin2")
+  }
+
+  @Test @Ignore
+  fun challenge() {
+    var challenge = Challenge("", mapOf<String?, String>("" to ""))
+    challenge = Challenge("", "")
+    val scheme: String = challenge.scheme()
+    val authParams: Map<String?, String> = challenge.authParams()
+    val realm: String? = challenge.realm()
+    val charset: Charset = challenge.charset()
+    val utf8: Challenge = challenge.withCharset(Charsets.UTF_8)
+  }
+
+  @Test @Ignore
+  fun cipherSuite() {
+    var cipherSuite: CipherSuite = CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
+    cipherSuite = CipherSuite.forJavaName("")
+    val javaName: String = cipherSuite.javaName()
+  }
+
+  @Test @Ignore
+  fun connection() {
+    val connection = object : Connection {
+      override fun route(): Route = TODO()
+      override fun socket(): Socket = TODO()
+      override fun handshake(): Handshake? = TODO()
+      override fun protocol(): Protocol = TODO()
+    }
+  }
+
+  @Test @Ignore
+  fun connectionPool() {
+    var connectionPool = ConnectionPool()
+    connectionPool = ConnectionPool(0, 0L, TimeUnit.SECONDS)
+    val idleConnectionCount: Int = connectionPool.idleConnectionCount()
+    val connectionCount: Int = connectionPool.connectionCount()
+    connectionPool.evictAll()
+  }
+
+  @Test @Ignore
+  fun connectionSpec() {
+    var connectionSpec: ConnectionSpec = ConnectionSpec.RESTRICTED_TLS
+    connectionSpec = ConnectionSpec.MODERN_TLS
+    connectionSpec = ConnectionSpec.COMPATIBLE_TLS
+    connectionSpec = ConnectionSpec.CLEARTEXT
+    val tlsVersions: List<TlsVersion>? = connectionSpec.tlsVersions()
+    val cipherSuites: List<CipherSuite>? = connectionSpec.cipherSuites()
+    val supportsTlsExtensions: Boolean = connectionSpec.supportsTlsExtensions()
+    val compatible: Boolean = connectionSpec.isCompatible(
+        localhost().sslSocketFactory().createSocket() as SSLSocket)
+  }
+
+  @Test @Ignore
+  fun connectionSpecBuilder() {
+    var builder = ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+    builder = builder.allEnabledCipherSuites()
+    builder = builder.cipherSuites(CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)
+    builder = builder.cipherSuites("", "")
+    builder = builder.allEnabledTlsVersions()
+    builder = builder.tlsVersions(TlsVersion.TLS_1_3)
+    builder = builder.tlsVersions("", "")
+    builder = builder.supportsTlsExtensions(false)
+    val connectionSpec: ConnectionSpec = builder.build()
+  }
+
+  @Test @Ignore
+  fun cookie() {
+    val cookie: Cookie = Cookie.Builder().build()
+    val name: String = cookie.name()
+    val value: String = cookie.value()
+    val persistent: Boolean = cookie.persistent()
+    val expiresAt: Long = cookie.expiresAt()
+    val hostOnly: Boolean = cookie.hostOnly()
+    val domain: String = cookie.domain()
+    val path: String = cookie.path()
+    val httpOnly: Boolean = cookie.httpOnly()
+    val secure: Boolean = cookie.secure()
+    val matches: Boolean = cookie.matches(HttpUrl.get(""))
+    val parsedCookie: Cookie? = Cookie.parse(HttpUrl.get(""), "")
+    val cookies: List<Cookie> = Cookie.parseAll(HttpUrl.get(""), Headers.of())
+  }
+
+  @Test @Ignore
+  fun cookieBuilder() {
+    var builder: Cookie.Builder = Cookie.Builder()
+    builder = builder.name("")
+    builder = builder.value("")
+    builder = builder.expiresAt(0L)
+    builder = builder.domain("")
+    builder = builder.hostOnlyDomain("")
+    builder = builder.path("")
+    builder = builder.secure()
+    builder = builder.httpOnly()
+    val cookie: Cookie = builder.build()
+  }
+
+  @Test @Ignore
+  fun cookieJar() {
+    val cookieJar = object : CookieJar {
+      override fun saveFromResponse(url: HttpUrl, cookies: List<Cookie>) = TODO()
+      override fun loadForRequest(url: HttpUrl): List<Cookie> = TODO()
+    }
+  }
+
+  @Test @Ignore
+  fun credentials() {
+    val basic: String = Credentials.basic("", "")
+  }
+
+  @Test @Ignore
+  fun dispatcher() {
+    var dispatcher = Dispatcher()
+    dispatcher = Dispatcher(Executors.newCachedThreadPool())
+    val maxRequests: Int = dispatcher.maxRequests
+    dispatcher.maxRequests = 0
+    val maxRequestsPerHost: Int = dispatcher.maxRequestsPerHost
+    dispatcher.maxRequestsPerHost = 0
+    val executorService: ExecutorService = dispatcher.executorService()
+    dispatcher.setIdleCallback(object : Runnable {
+      override fun run() = TODO()
+    })
+    dispatcher.setIdleCallback { TODO() }
+    val queuedCalls: List<Call> = dispatcher.queuedCalls()
+    val runningCalls: List<Call> = dispatcher.runningCalls()
+    val queuedCallsCount: Int = dispatcher.queuedCallsCount()
+    val runningCallsCount: Int = dispatcher.runningCallsCount()
+    dispatcher.cancelAll()
+  }
+
+  @Test @Ignore
+  fun dispatcherFromMockWebServer() {
+    val dispatcher = object : okhttp3.mockwebserver.Dispatcher() {
+      override fun dispatch(request: RecordedRequest?): MockResponse = TODO()
+      override fun peek(): MockResponse = TODO()
+      override fun shutdown() = TODO()
+    }
+  }
+
+  @Test @Ignore
+  fun dns() {
+    var dns: Dns = object : Dns {
+      override fun lookup(hostname: String): List<InetAddress> = TODO()
+    }
+    dns = Dns { it: String -> TODO() }
+
+    val system: Dns = Dns.SYSTEM
+  }
+
+  @Test @Ignore
+  fun eventListener() {
+    val eventListener = object : EventListener() {
+      override fun callStart(call: Call) = TODO()
+      override fun dnsStart(call: Call, domainName: String) = TODO()
+      override fun dnsEnd(
+        call: Call,
+        domainName: String,
+        inetAddressList: List<InetAddress>
+      ) = TODO()
+
+      override fun connectStart(
+        call: Call,
+        inetSocketAddress: InetSocketAddress,
+        proxy: Proxy
+      ) = TODO()
+
+      override fun secureConnectStart(call: Call) = TODO()
+      override fun secureConnectEnd(call: Call, handshake: Handshake?) = TODO()
+      override fun connectEnd(
+        call: Call,
+        inetSocketAddress: InetSocketAddress,
+        proxy: Proxy,
+        protocol: Protocol?
+      ) = TODO()
+
+      override fun connectFailed(
+        call: Call,
+        inetSocketAddress: InetSocketAddress,
+        proxy: Proxy,
+        protocol: Protocol?,
+        ioe: IOException
+      ) = TODO()
+
+      override fun connectionAcquired(call: Call, connection: Connection) = TODO()
+      override fun connectionReleased(call: Call, connection: Connection) = TODO()
+      override fun requestHeadersStart(call: Call) = TODO()
+      override fun requestHeadersEnd(call: Call, request: Request) = TODO()
+      override fun requestBodyStart(call: Call) = TODO()
+      override fun requestBodyEnd(call: Call, byteCount: Long) = TODO()
+      override fun requestFailed(call: Call, ioe: IOException) = TODO()
+      override fun responseHeadersStart(call: Call) = TODO()
+      override fun responseHeadersEnd(call: Call, response: Response) = TODO()
+      override fun responseBodyStart(call: Call) = TODO()
+      override fun responseBodyEnd(call: Call, byteCount: Long) = TODO()
+      override fun responseFailed(call: Call, ioe: IOException) = TODO()
+      override fun callEnd(call: Call) = TODO()
+      override fun callFailed(call: Call, ioe: IOException) = TODO()
+    }
+    val none: EventListener = EventListener.NONE
+  }
+
+  @Test @Ignore
+  fun eventListenerBuilder() {
+    var builder: EventListener.Factory = object : EventListener.Factory {
+      override fun create(call: Call): EventListener = TODO()
+    }
+    builder = EventListener.Factory { it: Call -> TODO() }
+  }
+
+  @Test @Ignore
+  fun formBody() {
+    val formBody: FormBody = FormBody.Builder().build()
+    val size: Int = formBody.size()
+    val encodedName: String = formBody.encodedName(0)
+    val name: String = formBody.name(0)
+    val encodedValue: String = formBody.encodedValue(0)
+    val value: String = formBody.value(0)
+    val contentType: MediaType? = formBody.contentType()
+    val contentLength: Long = formBody.contentLength()
+    formBody.writeTo(Buffer())
+    val requestBody: RequestBody = formBody
+  }
+
+  @Test @Ignore
+  fun formBodyBuilder() {
+    var builder: FormBody.Builder = FormBody.Builder()
+    builder = FormBody.Builder(Charsets.UTF_8)
+    builder = builder.add("", "")
+    builder = builder.addEncoded("", "")
+    val formBody: FormBody = builder.build()
+  }
+
+  @Test @Ignore
+  fun handshake() {
+    var handshake: Handshake =
+        Handshake.get((localhost().sslSocketFactory().createSocket() as SSLSocket).session)
+    val listOfCertificates: List<Certificate> = listOf()
+    handshake = Handshake.get(
+        TlsVersion.TLS_1_3,
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+        listOfCertificates,
+        listOfCertificates
+    )
+    val tlsVersion: TlsVersion = handshake.tlsVersion()
+    val cipherSuite: CipherSuite = handshake.cipherSuite()
+    val peerCertificates: List<Certificate> = handshake.peerCertificates()
+    val peerPrincipal: Principal? = handshake.peerPrincipal()
+    val localCertificates: List<Certificate> = handshake.localCertificates()
+    val localPrincipal: Principal? = handshake.localPrincipal()
+  }
+
+  @Test @Ignore
+  fun headers() {
+    var headers: Headers = Headers.of("", "")
+    headers = Headers.of(mapOf("" to ""))
+    val get: String? = headers.get("")
+    val date: Date? = headers.getDate("")
+    val instant: Instant? = headers.getInstant("")
+    val size: Int = headers.size()
+    val name: String = headers.name(0)
+    val value: String = headers.value(0)
+    val names: Set<String> = headers.names()
+    val values: List<String> = headers.values("")
+    val byteCount: Long = headers.byteCount()
+    val builder: Headers.Builder = headers.newBuilder()
+    val multimap: Map<String, List<String>> = headers.toMultimap()
+  }
+
+  @Test @Ignore
+  fun headersBuilder() {
+    var builder: Headers.Builder = Headers.Builder()
+    builder = builder.add("")
+    builder = builder.add("", "")
+    builder = builder.addUnsafeNonAscii("", "")
+    builder = builder.addAll(Headers.of())
+    builder = builder.add("", Date(0L))
+    builder = builder.add("", Instant.EPOCH)
+    builder = builder.set("", "")
+    builder = builder.set("", Date(0L))
+    builder = builder.set("", Instant.EPOCH)
+    builder = builder.removeAll("")
+    val get: String? = builder.get("")
+    val headers: Headers = builder.build()
+  }
+
+  @Test @Ignore
+  fun httpLoggingInterceptor() {
+    var interceptor: HttpLoggingInterceptor = HttpLoggingInterceptor()
+    interceptor = HttpLoggingInterceptor(HttpLoggingInterceptor.Logger.DEFAULT)
+    interceptor.redactHeader("")
+    interceptor.level = HttpLoggingInterceptor.Level.BASIC
+    interceptor.setLevel(HttpLoggingInterceptor.Level.BASIC)
+    var level: HttpLoggingInterceptor.Level = interceptor.level
+    level = interceptor.getLevel()
+    interceptor.intercept(newInterceptorChain())
+  }
+
+  @Test @Ignore
+  fun httpLoggingInterceptorLevel() {
+    val none: HttpLoggingInterceptor.Level = HttpLoggingInterceptor.Level.NONE
+    val basic: HttpLoggingInterceptor.Level = HttpLoggingInterceptor.Level.BASIC
+    val headers: HttpLoggingInterceptor.Level = HttpLoggingInterceptor.Level.HEADERS
+    val body: HttpLoggingInterceptor.Level = HttpLoggingInterceptor.Level.BODY
+  }
+
+  @Test @Ignore
+  fun httpLoggingInterceptorLogger() {
+    var logger: HttpLoggingInterceptor.Logger = object : HttpLoggingInterceptor.Logger {
+      override fun log(message: String) = TODO()
+    }
+    logger = HttpLoggingInterceptor.Logger { TODO() }
+    val default: HttpLoggingInterceptor.Logger = HttpLoggingInterceptor.Logger.DEFAULT
+  }
+
+  @Test @Ignore
+  fun httpUrl() {
+    val httpUrl: HttpUrl = HttpUrl.get("")
+    val isHttps: Boolean = httpUrl.isHttps
+    val url: URL = httpUrl.url()
+    val uri: URI = httpUrl.uri()
+    val scheme: String = httpUrl.scheme()
+    val encodedUsername: String = httpUrl.encodedUsername()
+    val username: String = httpUrl.username()
+    val encodedPassword: String = httpUrl.encodedPassword()
+    val password: String = httpUrl.password()
+    val host: String = httpUrl.host()
+    val port: Int = httpUrl.port()
+    val pathSize: Int = httpUrl.pathSize()
+    val encodedPath: String = httpUrl.encodedPath()
+    val encodedPathSegments: List<String> = httpUrl.encodedPathSegments()
+    val pathSegments: List<String> = httpUrl.pathSegments()
+    val encodedQuery: String? = httpUrl.encodedQuery()
+    val query: String? = httpUrl.query()
+    val querySize: Int = httpUrl.querySize()
+    val queryParameter: String? = httpUrl.queryParameter("")
+    val queryParameterNames: Set<String> = httpUrl.queryParameterNames()
+    val queryParameterValues: List<String?> = httpUrl.queryParameterValues("")
+    val queryParameterName: String = httpUrl.queryParameterName(0)
+    val queryParameterValue: String? = httpUrl.queryParameterValue(0)
+    val encodedFragment: String? = httpUrl.encodedFragment()
+    val fragment: String? = httpUrl.fragment()
+    val redact: String = httpUrl.redact()
+    var builder: HttpUrl.Builder = httpUrl.newBuilder()
+    var resolveBuilder: HttpUrl.Builder? = httpUrl.newBuilder("")
+    val topPrivateDomain: String? = httpUrl.topPrivateDomain()
+    val resolve: HttpUrl? = httpUrl.resolve("")
+    val getFromUrl: HttpUrl? = HttpUrl.get(URL(""))
+    val getFromUri: HttpUrl? = HttpUrl.get(URI(""))
+    val parse: HttpUrl? = HttpUrl.parse("")
+    val defaultPort: Int = HttpUrl.defaultPort("")
+  }
+
+  @Test @Ignore
+  fun httpUrlBuilder() {
+    var builder: HttpUrl.Builder = HttpUrl.Builder()
+    builder = builder.scheme("")
+    builder = builder.username("")
+    builder = builder.encodedUsername("")
+    builder = builder.password("")
+    builder = builder.encodedPassword("")
+    builder = builder.host("")
+    builder = builder.port(0)
+    builder = builder.addPathSegment("")
+    builder = builder.addPathSegments("")
+    builder = builder.addEncodedPathSegment("")
+    builder = builder.addEncodedPathSegments("")
+    builder = builder.setPathSegment(0, "")
+    builder = builder.setEncodedPathSegment(0, "")
+    builder = builder.removePathSegment(0)
+    builder = builder.encodedPath("")
+    builder = builder.query("")
+    builder = builder.encodedQuery("")
+    builder = builder.addQueryParameter("", "")
+    builder = builder.addEncodedQueryParameter("", "")
+    builder = builder.setQueryParameter("", "")
+    builder = builder.setEncodedQueryParameter("", "")
+    builder = builder.removeAllQueryParameters("")
+    builder = builder.removeAllEncodedQueryParameters("")
+    builder = builder.fragment("")
+    builder = builder.encodedFragment("")
+    val httpUrl: HttpUrl = builder.build()
+  }
+
+  @Test @Ignore
+  fun interceptor() {
+    var interceptor: Interceptor = object : Interceptor {
+      override fun intercept(chain: Interceptor.Chain): Response = TODO()
+    }
+    interceptor = Interceptor { it: Interceptor.Chain -> TODO() }
+  }
+
+  @Test @Ignore
+  fun interceptorChain() {
+    val chain: Interceptor.Chain = newInterceptorChain()
+  }
+
+  @Test @Ignore
+  fun handshakeCertificates() {
+    val handshakeCertificates = HandshakeCertificates.Builder().build()
+    val keyManager: X509KeyManager = handshakeCertificates.keyManager()
+    val trustManager: X509TrustManager = handshakeCertificates.trustManager()
+    val sslSocketFactory: SSLSocketFactory = handshakeCertificates.sslSocketFactory()
+    val sslContext: SSLContext = handshakeCertificates.sslContext()
+  }
+
+  @Test @Ignore
+  fun handshakeCertificatesBuilder() {
+    var builder: HandshakeCertificates.Builder = HandshakeCertificates.Builder()
+    val heldCertificate = HeldCertificate.Builder().build()
+    builder = builder.heldCertificate(heldCertificate, heldCertificate.certificate())
+    builder = builder.addTrustedCertificate(heldCertificate.certificate())
+    builder = builder.addPlatformTrustedCertificates()
+    val handshakeCertificates: HandshakeCertificates = builder.build()
+  }
+
+  @Test @Ignore
+  fun heldCertificate() {
+    val heldCertificate: HeldCertificate = HeldCertificate.Builder().build()
+    val certificate: X509Certificate = heldCertificate.certificate()
+    val keyPair: KeyPair = heldCertificate.keyPair()
+    val certificatePem: String = heldCertificate.certificatePem()
+    val privateKeyPkcs8Pem: String = heldCertificate.privateKeyPkcs8Pem()
+    val privateKeyPkcs1Pem: String = heldCertificate.privateKeyPkcs1Pem()
+  }
+
+  @Test @Ignore
+  fun heldCertificateBuilder() {
+    val keyPair: KeyPair = KeyPairGenerator.getInstance("").genKeyPair()
+    var builder: HeldCertificate.Builder = HeldCertificate.Builder()
+    builder = builder.validityInterval(0L, 0L)
+    builder = builder.duration(0L, TimeUnit.SECONDS)
+    builder = builder.addSubjectAlternativeName("")
+    builder = builder.commonName("")
+    builder = builder.organizationalUnit("")
+    builder = builder.serialNumber(BigInteger.ZERO)
+    builder = builder.serialNumber(0L)
+    builder = builder.keyPair(keyPair)
+    builder = builder.keyPair(keyPair.public, keyPair.private)
+    builder = builder.signedBy(HeldCertificate.Builder().build())
+    builder = builder.certificateAuthority(0)
+    builder = builder.ecdsa256()
+    builder = builder.rsa2048()
+    val heldCertificate: HeldCertificate = builder.build()
+  }
+
+  @Test @Ignore
+  fun javaNetAuthenticator() {
+    val authenticator = JavaNetAuthenticator()
+    val response = Response.Builder().build()
+    var request: Request? = authenticator.authenticate(newRoute(), response)
+    request = authenticator.authenticate(null, response)
+  }
+
+  @Test @Ignore
+  fun javaNetCookieJar() {
+    val cookieJar: JavaNetCookieJar = JavaNetCookieJar(newCookieHandler())
+    val httpUrl = HttpUrl.get("")
+    val loadForRequest: List<Cookie> = cookieJar.loadForRequest(httpUrl)
+    cookieJar.saveFromResponse(httpUrl, listOf(Cookie.Builder().build()))
+  }
+
+  @Test @Ignore
+  fun loggingEventListener() {
+    var loggingEventListener: EventListener = LoggingEventListener.Factory().create(newCall())
+  }
+
+  @Test @Ignore
+  fun loggingEventListenerFactory() {
+    var factory: LoggingEventListener.Factory = LoggingEventListener.Factory()
+    factory = LoggingEventListener.Factory(HttpLoggingInterceptor.Logger.DEFAULT)
+    factory = object : LoggingEventListener.Factory() {
+      override fun create(call: Call): EventListener = TODO()
+    }
+    val eventListener: EventListener = factory.create(newCall())
+  }
+
+  @Test @Ignore
+  fun mediaType() {
+    val mediaType: MediaType = MediaType.get("")
+    val defaultCharset: Charset? = mediaType.charset()
+    val charset: Charset? = mediaType.charset(Charsets.UTF_8)
+    val type: String = mediaType.type()
+    val subtype: String = mediaType.subtype()
+    val parse: MediaType? = MediaType.parse("")
+  }
+
+  @Test @Ignore
+  fun mockResponse() {
+    var mockResponse: MockResponse = MockResponse()
+    var status: String = mockResponse.getStatus()
+    status = mockResponse.status
+    mockResponse = mockResponse.setStatus("")
+    mockResponse.status = ""
+    mockResponse = mockResponse.setResponseCode(0)
+    var headers: Headers = mockResponse.getHeaders()
+    headers = mockResponse.headers
+    var trailers: Headers = mockResponse.getTrailers()
+    trailers = mockResponse.trailers
+    mockResponse = mockResponse.clearHeaders()
+    mockResponse = mockResponse.addHeader("")
+    mockResponse = mockResponse.addHeader("", "")
+    mockResponse = mockResponse.addHeaderLenient("", Any())
+    mockResponse = mockResponse.setHeader("", Any())
+    mockResponse = mockResponse.setHeaders(Headers.of())
+    mockResponse = mockResponse.setTrailers(Headers.of())
+    mockResponse = mockResponse.removeHeader("")
+    var body: Buffer? = mockResponse.getBody()
+    body = mockResponse.body
+    mockResponse = mockResponse.setBody(Buffer())
+    mockResponse.body = Buffer()
+    mockResponse = mockResponse.setChunkedBody(Buffer(), 0)
+    mockResponse = mockResponse.setChunkedBody("", 0)
+    var socketPolicy: SocketPolicy = mockResponse.getSocketPolicy()
+    socketPolicy = mockResponse.socketPolicy
+    mockResponse = mockResponse.setSocketPolicy(SocketPolicy.KEEP_OPEN)
+    var http2ErrorCode: Int = mockResponse.getHttp2ErrorCode()
+    http2ErrorCode = mockResponse.http2ErrorCode
+    mockResponse = mockResponse.setHttp2ErrorCode(0)
+    mockResponse.http2ErrorCode = 0
+    mockResponse = mockResponse.throttleBody(0L, 0L, TimeUnit.SECONDS)
+    var throttleBytesPerPeriod: Long = mockResponse.getThrottleBytesPerPeriod()
+    throttleBytesPerPeriod = mockResponse.throttleBytesPerPeriod
+    var throttlePeriod: Long = mockResponse.getThrottlePeriod(TimeUnit.SECONDS)
+    mockResponse = mockResponse.setBodyDelay(0L, TimeUnit.SECONDS)
+    val bodyDelay: Long = mockResponse.getBodyDelay(TimeUnit.SECONDS)
+    mockResponse = mockResponse.setHeadersDelay(0L, TimeUnit.SECONDS)
+    val headersDelay: Long = mockResponse.getHeadersDelay(TimeUnit.SECONDS)
+    mockResponse = mockResponse.withPush(PushPromise("", "", Headers.of(), MockResponse()))
+    var pushPromises: List<PushPromise> = mockResponse.getPushPromises()
+    pushPromises = mockResponse.pushPromises
+    mockResponse = mockResponse.withSettings(Settings())
+    var settings: Settings = mockResponse.getSettings()
+    settings = mockResponse.settings
+    mockResponse = mockResponse.withWebSocketUpgrade(object : WebSocketListener() {
+    })
+    var webSocketListener: WebSocketListener = mockResponse.getWebSocketListener()
+    webSocketListener = mockResponse.webSocketListener
+  }
+
+  @Test @Ignore
+  fun mockWebServer() {
+    val mockWebServer: MockWebServer = MockWebServer()
+    var port: Int = mockWebServer.getPort()
+    port = mockWebServer.port
+    var hostName: String = mockWebServer.getHostName()
+    hostName = mockWebServer.hostName
+    val toProxyAddress: Proxy = mockWebServer.toProxyAddress()
+    mockWebServer.setServerSocketFactory(ServerSocketFactory.getDefault())
+    val url: HttpUrl = mockWebServer.url("")
+    mockWebServer.setBodyLimit(0L)
+    mockWebServer.setProtocolNegotiationEnabled(false)
+    mockWebServer.setProtocols(listOf<Protocol>())
+    val protocols: List<Protocol> = mockWebServer.protocols()
+    mockWebServer.useHttps(SSLSocketFactory.getDefault() as SSLSocketFactory?, false)
+    mockWebServer.noClientAuth()
+    mockWebServer.requestClientAuth()
+    mockWebServer.requireClientAuth()
+    var request: RecordedRequest = mockWebServer.takeRequest()
+    request = mockWebServer.takeRequest(0L, TimeUnit.SECONDS)
+    var requestCount: Int = mockWebServer.getRequestCount()
+    requestCount = mockWebServer.requestCount
+    mockWebServer.enqueue(MockResponse())
+    mockWebServer.start()
+    mockWebServer.start(0)
+    mockWebServer.start(InetAddress.getLocalHost(), 0)
+    mockWebServer.shutdown()
+    var dispatcher: okhttp3.mockwebserver.Dispatcher = mockWebServer.getDispatcher()
+    dispatcher = mockWebServer.dispatcher
+    mockWebServer.setDispatcher(QueueDispatcher())
+    mockWebServer.dispatcher = QueueDispatcher()
+    mockWebServer.close()
+  }
+
+  @Test @Ignore
+  fun multipartBody() {
+    val multipartBody: MultipartBody = MultipartBody.Builder().build()
+    val type: MediaType = multipartBody.type()
+    val boundary: String = multipartBody.boundary()
+    val size: Int = multipartBody.size()
+    val parts: List<MultipartBody.Part> = multipartBody.parts()
+    val part: MultipartBody.Part = multipartBody.part(0)
+    val contentType: MediaType? = multipartBody.contentType()
+    val contentLength: Long = multipartBody.contentLength()
+    multipartBody.writeTo(Buffer())
+    val mixed: MediaType = MultipartBody.MIXED
+    val alternative: MediaType = MultipartBody.ALTERNATIVE
+    val digest: MediaType = MultipartBody.DIGEST
+    val parallel: MediaType = MultipartBody.PARALLEL
+    val form: MediaType = MultipartBody.FORM
+  }
+
+  @Test @Ignore
+  fun multipartBodyPart() {
+    val requestBody: RequestBody = RequestBody.create(null, "")
+    var part: MultipartBody.Part = MultipartBody.Part.create(null, requestBody)
+    part = MultipartBody.Part.create(Headers.of(), requestBody)
+    part = MultipartBody.Part.create(requestBody)
+    part = MultipartBody.Part.createFormData("", "")
+    part = MultipartBody.Part.createFormData("", "", requestBody)
+    part = MultipartBody.Part.createFormData("", null, requestBody)
+    val headers: Headers? = part.headers()
+    val body: RequestBody = part.body()
+  }
+
+  @Test @Ignore
+  fun multipartBodyBuilder() {
+    val requestBody = RequestBody.create(null, "")
+    var builder: MultipartBody.Builder = MultipartBody.Builder()
+    builder = MultipartBody.Builder("")
+    builder = builder.setType(MediaType.get(""))
+    builder = builder.addPart(requestBody)
+    builder = builder.addPart(Headers.of(), requestBody)
+    builder = builder.addPart(null, requestBody)
+    builder = builder.addFormDataPart("", "")
+    builder = builder.addFormDataPart("", "", requestBody)
+    builder = builder.addFormDataPart("", null, requestBody)
+    builder = builder.addPart(MultipartBody.Part.create(requestBody))
+    val multipartBody: MultipartBody = builder.build()
+  }
+
+  @Test @Ignore
+  fun okHttpClient() {
+    val client: OkHttpClient = OkHttpClient()
+    val dispatcher: Dispatcher = client.dispatcher()
+    val proxy: Proxy? = client.proxy()
+    val protocols: List<Protocol> = client.protocols()
+    val connectionSpecs: List<ConnectionSpec> = client.connectionSpecs()
+    val interceptors: List<Interceptor> = client.interceptors()
+    val networkInterceptors: List<Interceptor> = client.networkInterceptors()
+    val eventListenerFactory: EventListener.Factory = client.eventListenerFactory()
+    val proxySelector: ProxySelector = client.proxySelector()
+    val cookieJar: CookieJar = client.cookieJar()
+    val cache: Cache? = client.cache()
+    val socketFactory: SocketFactory = client.socketFactory()
+    val sslSocketFactory: SSLSocketFactory = client.sslSocketFactory()
+    val hostnameVerifier: HostnameVerifier = client.hostnameVerifier()
+    val certificatePinner: CertificatePinner = client.certificatePinner()
+    val proxyAuthenticator: Authenticator = client.proxyAuthenticator()
+    val authenticator: Authenticator = client.authenticator()
+    val connectionPool: ConnectionPool = client.connectionPool()
+    val dns: Dns = client.dns()
+    val followSslRedirects: Boolean = client.followSslRedirects()
+    val followRedirects: Boolean = client.followRedirects()
+    val retryOnConnectionFailure: Boolean = client.retryOnConnectionFailure()
+    val callTimeoutMillis: Int = client.callTimeoutMillis()
+    val connectTimeoutMillis: Int = client.connectTimeoutMillis()
+    val readTimeoutMillis: Int = client.readTimeoutMillis()
+    val writeTimeoutMillis: Int = client.writeTimeoutMillis()
+    val pingIntervalMillis: Int = client.pingIntervalMillis()
+    val call: Call = client.newCall(Request.Builder().build())
+    val webSocket: WebSocket = client.newWebSocket(
+        Request.Builder().build(),
+        object : WebSocketListener() {
+        })
+    val newBuilder: OkHttpClient.Builder = client.newBuilder()
+  }
+
+  @Test @Ignore
+  fun okHttpClientBuilder() {
+    var builder: OkHttpClient.Builder = OkHttpClient.Builder()
+    builder = builder.callTimeout(0L, TimeUnit.SECONDS)
+    builder = builder.callTimeout(Duration.ofSeconds(0L))
+    builder = builder.connectTimeout(0L, TimeUnit.SECONDS)
+    builder = builder.connectTimeout(Duration.ofSeconds(0L))
+    builder = builder.readTimeout(0L, TimeUnit.SECONDS)
+    builder = builder.readTimeout(Duration.ofSeconds(0L))
+    builder = builder.writeTimeout(0L, TimeUnit.SECONDS)
+    builder = builder.writeTimeout(Duration.ofSeconds(0L))
+    builder = builder.pingInterval(0L, TimeUnit.SECONDS)
+    builder = builder.pingInterval(Duration.ofSeconds(0L))
+    builder = builder.proxy(Proxy.NO_PROXY)
+    builder = builder.proxySelector(NullProxySelector())
+    builder = builder.cookieJar(CookieJar.NO_COOKIES)
+    builder = builder.cache(Cache(File("/cache/"), Integer.MAX_VALUE.toLong()))
+    builder = builder.dns(Dns.SYSTEM)
+    builder = builder.socketFactory(SocketFactory.getDefault())
+    builder = builder.sslSocketFactory(localhost().sslSocketFactory(), localhost().trustManager())
+    builder = builder.hostnameVerifier(OkHostnameVerifier)
+    builder = builder.certificatePinner(CertificatePinner.DEFAULT)
+    builder = builder.authenticator(Authenticator.NONE)
+    builder = builder.proxyAuthenticator(Authenticator.NONE)
+    builder = builder.connectionPool(ConnectionPool(0, 0, TimeUnit.SECONDS))
+    builder = builder.followSslRedirects(false)
+    builder = builder.followRedirects(false)
+    builder = builder.retryOnConnectionFailure(false)
+    builder = builder.dispatcher(Dispatcher())
+    builder = builder.protocols(listOf(Protocol.HTTP_1_1))
+    builder = builder.connectionSpecs(listOf(ConnectionSpec.MODERN_TLS))
+    val interceptors: List<Interceptor> = builder.interceptors()
+    builder = builder.addInterceptor(object : Interceptor {
+      override fun intercept(chain: Interceptor.Chain): Response = TODO()
+    })
+    builder = builder.addInterceptor { it: Interceptor.Chain -> TODO() }
+    val networkInterceptors: List<Interceptor> = builder.networkInterceptors()
+    builder = builder.addNetworkInterceptor(object : Interceptor {
+      override fun intercept(chain: Interceptor.Chain): Response = TODO()
+    })
+    builder = builder.addNetworkInterceptor { it: Interceptor.Chain -> TODO() }
+    builder = builder.eventListener(EventListener.NONE)
+    builder = builder.eventListenerFactory(object : EventListener.Factory {
+      override fun create(call: Call): EventListener = TODO()
+    })
+    builder = builder.eventListenerFactory(LoggingEventListener.Factory { s -> TODO() })
+    builder = builder.eventListenerFactory { it: Call -> TODO() }
+    val client: OkHttpClient = builder.build()
+  }
+
+  @Test @Ignore
+  fun testAddInterceptor() {
+    val builder = OkHttpClient.Builder()
+
+    val i = HttpLoggingInterceptor()
+
+    builder.interceptors().add(i)
+    builder.networkInterceptors().add(i)
+  }
+
+  @Test @Ignore
+  fun protocol() {
+    var protocol: Protocol = Protocol.HTTP_2
+    protocol = Protocol.get("")
+  }
+
+  @Test @Ignore
+  fun pushPromise() {
+    val pushPromise: PushPromise = PushPromise("", "", Headers.of(), MockResponse())
+    val method: String = pushPromise.method()
+    val path: String = pushPromise.path()
+    val headers: Headers = pushPromise.headers()
+    val response: MockResponse = pushPromise.response()
+  }
+
+  @Test @Ignore
+  fun queueDispatcher() {
+    var queueDispatcher: QueueDispatcher = object : QueueDispatcher() {
+      override fun dispatch(request: RecordedRequest?): MockResponse = TODO()
+      override fun peek(): MockResponse = TODO()
+      override fun enqueueResponse(response: MockResponse?) = TODO()
+      override fun shutdown() = TODO()
+      override fun setFailFast(failFast: Boolean) = TODO()
+      override fun setFailFast(failFastResponse: MockResponse?) = TODO()
+    }
+    queueDispatcher = QueueDispatcher()
+    var mockResponse: MockResponse = queueDispatcher.dispatch(
+        RecordedRequest("", Headers.of(), listOf(), 0L, Buffer(), 0, Socket()))
+    mockResponse = queueDispatcher.peek()
+    queueDispatcher.enqueueResponse(MockResponse())
+    queueDispatcher.shutdown()
+    queueDispatcher.setFailFast(false)
+    queueDispatcher.setFailFast(MockResponse())
+  }
+
+  @Test @Ignore
+  fun recordedRequest() {
+    var recordedRequest: RecordedRequest = RecordedRequest(
+        "", Headers.of(), listOf(), 0L, Buffer(), 0, Socket())
+    recordedRequest = RecordedRequest(null, null, null, 0L, null, 0, Socket())
+    var requestUrl: HttpUrl? = recordedRequest.getRequestUrl()
+    var requestLine: String? = recordedRequest.getRequestLine()
+    var method: String? = recordedRequest.getMethod()
+    var path: String? = recordedRequest.getPath()
+    var headers: Headers? = recordedRequest.getHeaders()
+    val header: String? = recordedRequest.getHeader("")
+    var chunkSizes: List<Int>? = recordedRequest.getChunkSizes()
+    var bodySize: Long = recordedRequest.getBodySize()
+    var body: Buffer? = recordedRequest.getBody()
+    var utf8Body: String = recordedRequest.getUtf8Body()
+    var sequenceNumber: Int = recordedRequest.getSequenceNumber()
+    var tlsVersion: TlsVersion = recordedRequest.getTlsVersion()
+    var handshake: Handshake = recordedRequest.getHandshake()
+    requestUrl = recordedRequest.requestUrl
+    requestLine = recordedRequest.requestLine
+    method = recordedRequest.method
+    path = recordedRequest.path
+    headers = recordedRequest.headers
+    chunkSizes = recordedRequest.chunkSizes
+    bodySize = recordedRequest.bodySize
+    body = recordedRequest.body
+    utf8Body = recordedRequest.utf8Body
+    sequenceNumber = recordedRequest.sequenceNumber
+    tlsVersion = recordedRequest.tlsVersion
+    handshake = recordedRequest.handshake
+  }
+
+  @Test @Ignore
+  fun request() {
+    val request: Request = Request.Builder().build()
+    val isHttps: Boolean = request.isHttps
+    val url: HttpUrl = request.url()
+    val method: String = request.method()
+    val headers: Headers = request.headers()
+    val header: String? = request.header("")
+    val headersForName: List<String> = request.headers("")
+    val body: RequestBody? = request.body()
+    var tag: Any? = request.tag()
+    tag = request.tag(Any::class.java)
+    val builder: Request.Builder = request.newBuilder()
+    val cacheControl: CacheControl = request.cacheControl()
+  }
+
+  @Test @Ignore
+  fun requestBuilder() {
+    val requestBody = RequestBody.create(null, "")
+    var builder = Request.Builder()
+    builder = builder.url(HttpUrl.get(""))
+    builder = builder.url("")
+    builder = builder.url(URL(""))
+    builder = builder.header("", "")
+    builder = builder.addHeader("", "")
+    builder = builder.removeHeader("")
+    builder = builder.headers(Headers.of())
+    builder = builder.cacheControl(CacheControl.FORCE_CACHE)
+    builder = builder.get()
+    builder = builder.head()
+    builder = builder.post(requestBody)
+    builder = builder.delete(requestBody)
+    builder = builder.delete(null)
+    builder = builder.put(requestBody)
+    builder = builder.patch(requestBody)
+    builder = builder.method("", requestBody)
+    builder = builder.method("", null)
+    builder = builder.tag("")
+    builder = builder.tag(null)
+    builder = builder.tag(String::class.java, "")
+    builder = builder.tag(String::class.java, null)
+    val request: Request = builder.build()
+  }
+
+  @Test @Ignore
+  fun requestBody() {
+    var requestBody: RequestBody = object : RequestBody() {
+      override fun contentType(): MediaType? = TODO()
+      override fun contentLength(): Long = TODO()
+      override fun isDuplex(): Boolean = TODO()
+      override fun isOneShot(): Boolean = TODO()
+      override fun writeTo(sink: BufferedSink) = TODO()
+    }
+    requestBody = RequestBody.create(null, "")
+    requestBody = RequestBody.create(MediaType.parse(""), "")
+    requestBody = RequestBody.create(null, ByteString.EMPTY)
+    requestBody = RequestBody.create(MediaType.parse(""), ByteString.EMPTY)
+    requestBody = RequestBody.create(null, byteArrayOf(0, 1))
+    requestBody = RequestBody.create(MediaType.parse(""), byteArrayOf(0, 1))
+    requestBody = RequestBody.create(null, byteArrayOf(0, 1), 0, 2)
+    requestBody = RequestBody.create(MediaType.parse(""), byteArrayOf(0, 1), 0, 2)
+    requestBody = RequestBody.create(null, File(""))
+    requestBody = RequestBody.create(MediaType.parse(""), File(""))
+  }
+
+  @Test @Ignore
+  fun response() {
+    val response: Response = Response.Builder().build()
+    val request: Request = response.request()
+    val protocol: Protocol = response.protocol()
+    val code: Int = response.code()
+    val successful: Boolean = response.isSuccessful
+    val message: String = response.message()
+    val handshake: Handshake? = response.handshake()
+    val headersForName: List<String> = response.headers("")
+    val header: String? = response.header("")
+    val headers: Headers = response.headers()
+    val trailers: Headers = response.trailers()
+    val peekBody: ResponseBody = response.peekBody(0L)
+    val body: ResponseBody? = response.body()
+    val builder: Response.Builder = response.newBuilder()
+    val redirect: Boolean = response.isRedirect
+    val networkResponse: Response? = response.networkResponse()
+    val cacheResponse: Response? = response.cacheResponse()
+    val priorResponse: Response? = response.priorResponse()
+    val challenges: List<Challenge> = response.challenges()
+    val cacheControl: CacheControl = response.cacheControl()
+    val sentRequestAtMillis: Long = response.sentRequestAtMillis()
+    val receivedResponseAtMillis: Long = response.receivedResponseAtMillis()
+  }
+
+  @Test @Ignore
+  fun responseBuilder() {
+    var builder: Response.Builder = Response.Builder()
+    builder = builder.request(Request.Builder().build())
+    builder = builder.protocol(Protocol.HTTP_2)
+    builder = builder.code(0)
+    builder = builder.message("")
+    builder = builder.handshake(Handshake.get(
+        TlsVersion.TLS_1_3,
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+        listOf(),
+        listOf())
+    )
+    builder = builder.handshake(null)
+    builder = builder.header("", "")
+    builder = builder.addHeader("", "")
+    builder = builder.removeHeader("")
+    builder = builder.headers(Headers.of())
+    builder = builder.body(ResponseBody.create(null, ""))
+    builder = builder.body(null)
+    builder = builder.networkResponse(Response.Builder().build())
+    builder = builder.networkResponse(null)
+    builder = builder.cacheResponse(Response.Builder().build())
+    builder = builder.cacheResponse(null)
+    builder = builder.priorResponse(Response.Builder().build())
+    builder = builder.priorResponse(null)
+    builder = builder.sentRequestAtMillis(0L)
+    builder = builder.receivedResponseAtMillis(0L)
+    val response: Response = builder.build()
+  }
+
+  @Test @Ignore
+  fun responseBody() {
+    var responseBody: ResponseBody = object : ResponseBody() {
+      override fun contentType(): MediaType? = TODO()
+      override fun contentLength(): Long = TODO()
+      override fun source(): BufferedSource = TODO()
+      override fun close() = TODO()
+    }
+    val byteStream = responseBody.byteStream()
+    val source = responseBody.source()
+    val bytes = responseBody.bytes()
+    val charStream = responseBody.charStream()
+    val string = responseBody.string()
+    responseBody.close()
+    responseBody = ResponseBody.create(MediaType.get(""), "")
+    responseBody = ResponseBody.create(null, "")
+    responseBody = ResponseBody.create(MediaType.get(""), ByteString.EMPTY)
+    responseBody = ResponseBody.create(null, ByteString.EMPTY)
+    responseBody = ResponseBody.create(MediaType.get(""), byteArrayOf(0, 1))
+    responseBody = ResponseBody.create(null, byteArrayOf(0, 1))
+    responseBody = ResponseBody.create(MediaType.get(""), 0L, Buffer())
+    responseBody = ResponseBody.create(null, 0L, Buffer())
+  }
+
+  @Test @Ignore
+  fun route() {
+    val route: Route = newRoute()
+    val address: Address = route.address()
+    val proxy: Proxy = route.proxy()
+    val inetSocketAddress: InetSocketAddress = route.socketAddress()
+    val requiresTunnel: Boolean = route.requiresTunnel()
+  }
+
+  @Test @Ignore
+  fun socketPolicy() {
+    val socketPolicy: SocketPolicy = SocketPolicy.KEEP_OPEN
+  }
+
+  @Test @Ignore
+  fun tlsVersion() {
+    var tlsVersion: TlsVersion = TlsVersion.TLS_1_3
+    val javaName: String = tlsVersion.javaName()
+    tlsVersion = TlsVersion.forJavaName("")
+  }
+
+  @Test @Ignore
+  fun webSocket() {
+    val webSocket = object : WebSocket {
+      override fun request(): Request = TODO()
+      override fun queueSize(): Long = TODO()
+      override fun send(text: String): Boolean = TODO()
+      override fun send(bytes: ByteString): Boolean = TODO()
+      override fun close(code: Int, reason: String?): Boolean = TODO()
+      override fun cancel() = TODO()
+    }
+  }
+
+  @Test @Ignore
+  fun webSocketListener() {
+    val webSocketListener = object : WebSocketListener() {
+      override fun onOpen(webSocket: WebSocket, response: Response) = TODO()
+      override fun onMessage(webSocket: WebSocket, text: String) = TODO()
+      override fun onMessage(webSocket: WebSocket, bytes: ByteString) = TODO()
+      override fun onClosing(webSocket: WebSocket, code: Int, reason: String) = TODO()
+      override fun onClosed(webSocket: WebSocket, code: Int, reason: String) = TODO()
+      override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) = TODO()
+    }
+  }
+
+  private fun newAddress(): Address {
+    return Address(
+        "",
+        0,
+        Dns.SYSTEM,
+        SocketFactory.getDefault(),
+        localhost().sslSocketFactory(),
+        OkHostnameVerifier,
+        CertificatePinner.DEFAULT,
+        Authenticator.NONE,
+        Proxy.NO_PROXY,
+        listOf(Protocol.HTTP_1_1),
+        listOf(ConnectionSpec.MODERN_TLS),
+        NullProxySelector()
+    )
+  }
+
+  private fun newCall(): Call {
+    return object : Call {
+      override fun request(): Request = TODO()
+      override fun execute(): Response = TODO()
+      override fun enqueue(responseCallback: Callback) = TODO()
+      override fun cancel() = TODO()
+      override fun isExecuted(): Boolean = TODO()
+      override fun isCanceled(): Boolean = TODO()
+      override fun timeout(): Timeout = TODO()
+      override fun clone(): Call = TODO()
+    }
+  }
+
+  private fun newCookieHandler(): CookieHandler {
+    return object : CookieHandler() {
+      override fun put(
+        uri: URI?,
+        responseHeaders: MutableMap<String, MutableList<String>>?
+      ) = TODO()
+
+      override fun get(
+        uri: URI?,
+        requestHeaders: MutableMap<String, MutableList<String>>?
+      ): MutableMap<String, MutableList<String>> = TODO()
+    }
+  }
+
+  private fun newInterceptorChain(): Interceptor.Chain {
+    return object : Interceptor.Chain {
+      override fun request(): Request = TODO()
+      override fun proceed(request: Request): Response = TODO()
+      override fun connection(): Connection? = TODO()
+      override fun call(): Call = TODO()
+      override fun connectTimeoutMillis(): Int = TODO()
+      override fun withConnectTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain = TODO()
+      override fun readTimeoutMillis(): Int = TODO()
+      override fun withReadTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain = TODO()
+      override fun writeTimeoutMillis(): Int = TODO()
+      override fun withWriteTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain = TODO()
+    }
+  }
+
+  private fun newRoute(): Route {
+    return Route(newAddress(), Proxy.NO_PROXY, InetSocketAddress.createUnresolved("", 0))
+  }
+}
\ No newline at end of file
diff --git a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java b/okhttp/src/test/java/okhttp3/MediaTypeTest.java
similarity index 76%
rename from okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
rename to okhttp/src/test/java/okhttp3/MediaTypeTest.java
index 1520bcaf8e..a74bc9a05b 100644
--- a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
+++ b/okhttp/src/test/java/okhttp3/MediaTypeTest.java
@@ -17,15 +17,14 @@
 package okhttp3;
 
 import java.nio.charset.Charset;
-import java.util.Arrays;
 import java.util.Collection;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 /**
@@ -38,7 +37,7 @@
 public class MediaTypeTest {
   @Parameterized.Parameters(name = "Use get = {0}")
   public static Collection<Object[]> parameters() {
-    return Arrays.asList(
+    return asList(
         new Object[] { true },
         new Object[] { false }
     );
@@ -55,13 +54,13 @@ private MediaType parse(String string) {
 
   @Test public void testParse() throws Exception {
     MediaType mediaType = parse("text/plain;boundary=foo;charset=utf-8");
-    assertEquals("text", mediaType.type());
-    assertEquals("plain", mediaType.subtype());
-    assertEquals("UTF-8", mediaType.charset().name());
-    assertEquals("text/plain;boundary=foo;charset=utf-8", mediaType.toString());
-    assertEquals(mediaType, parse("text/plain;boundary=foo;charset=utf-8"));
-    assertEquals(mediaType.hashCode(),
-        parse("text/plain;boundary=foo;charset=utf-8").hashCode());
+    assertThat(mediaType.type()).isEqualTo("text");
+    assertThat(mediaType.subtype()).isEqualTo("plain");
+    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
+    assertThat(mediaType.toString()).isEqualTo("text/plain;boundary=foo;charset=utf-8");
+    assertThat(parse("text/plain;boundary=foo;charset=utf-8")).isEqualTo(mediaType);
+    assertThat(parse("text/plain;boundary=foo;charset=utf-8").hashCode()).isEqualTo(
+        (long) mediaType.hashCode());
   }
 
   @Test public void testValidParse() throws Exception {
@@ -119,36 +118,36 @@ private MediaType parse(String string) {
 
   @Test public void testDoubleQuotesAreSpecial() throws Exception {
     MediaType mediaType = parse("text/plain;a=\";charset=utf-8;b=\"");
-    assertNull(mediaType.charset());
+    assertThat(mediaType.charset()).isNull();
   }
 
   @Test public void testSingleQuotesAreNotSpecial() throws Exception {
     MediaType mediaType = parse("text/plain;a=';charset=utf-8;b='");
-    assertEquals("UTF-8", mediaType.charset().name());
+    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
   }
 
   @Test public void testParseWithSpecialCharacters() throws Exception {
     MediaType mediaType = parse("!#$%&'*+-.{|}~/!#$%&'*+-.{|}~; !#$%&'*+-.{|}~=!#$%&'*+-.{|}~");
-    assertEquals("!#$%&'*+-.{|}~", mediaType.type());
-    assertEquals("!#$%&'*+-.{|}~", mediaType.subtype());
+    assertThat(mediaType.type()).isEqualTo("!#$%&'*+-.{|}~");
+    assertThat(mediaType.subtype()).isEqualTo("!#$%&'*+-.{|}~");
   }
 
   @Test public void testCharsetIsOneOfManyParameters() throws Exception {
     MediaType mediaType = parse("text/plain;a=1;b=2;charset=utf-8;c=3");
-    assertEquals("text", mediaType.type());
-    assertEquals("plain", mediaType.subtype());
-    assertEquals("UTF-8", mediaType.charset().name());
+    assertThat(mediaType.type()).isEqualTo("text");
+    assertThat(mediaType.subtype()).isEqualTo("plain");
+    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
   }
 
   @Test public void testCharsetAndQuoting() throws Exception {
     MediaType mediaType = parse(
         "text/plain;a=\";charset=us-ascii\";charset=\"utf-8\";b=\"iso-8859-1\"");
-    assertEquals("UTF-8", mediaType.charset().name());
+    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
   }
 
   @Test public void testDuplicatedCharsets() {
     MediaType mediaType = parse("text/plain; charset=utf-8; charset=UTF-8");
-    assertEquals("UTF-8", mediaType.charset().name());
+    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
   }
 
   @Test public void testMultipleCharsets() {
@@ -158,12 +157,12 @@ private MediaType parse(String string) {
 
   @Test public void testIllegalCharsetName() {
     MediaType mediaType = parse("text/plain; charset=\"!@#$%^&*()\"");
-    assertNull(mediaType.charset());
+    assertThat(mediaType.charset()).isNull();
   }
 
   @Test public void testUnsupportedCharset() {
     MediaType mediaType = parse("text/plain; charset=utf-wtf");
-    assertNull(mediaType.charset());
+    assertThat(mediaType.charset()).isNull();
   }
 
   /**
@@ -172,39 +171,39 @@ private MediaType parse(String string) {
    */
   @Test public void testCharsetNameIsSingleQuoted() throws Exception {
     MediaType mediaType = parse("text/plain;charset='utf-8'");
-    assertEquals("UTF-8", mediaType.charset().name());
+    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
   }
 
   @Test public void testCharsetNameIsDoubleQuotedAndSingleQuoted() throws Exception {
     MediaType mediaType = parse("text/plain;charset=\"'utf-8'\"");
-    assertNull(mediaType.charset());
+    assertThat(mediaType.charset()).isNull();
   }
 
   @Test public void testCharsetNameIsDoubleQuotedSingleQuote() throws Exception {
     MediaType mediaType = parse("text/plain;charset=\"'\"");
-    assertNull(mediaType.charset());
+    assertThat(mediaType.charset()).isNull();
   }
 
   @Test public void testDefaultCharset() throws Exception {
     MediaType noCharset = parse("text/plain");
-    assertEquals("UTF-8", noCharset.charset(UTF_8).name());
-    assertEquals("US-ASCII", noCharset.charset(Charset.forName("US-ASCII")).name());
+    assertThat(noCharset.charset(UTF_8).name()).isEqualTo("UTF-8");
+    assertThat(noCharset.charset(Charset.forName("US-ASCII")).name()).isEqualTo("US-ASCII");
 
     MediaType charset = parse("text/plain; charset=iso-8859-1");
-    assertEquals("ISO-8859-1", charset.charset(UTF_8).name());
-    assertEquals("ISO-8859-1", charset.charset(Charset.forName("US-ASCII")).name());
+    assertThat(charset.charset(UTF_8).name()).isEqualTo("ISO-8859-1");
+    assertThat(charset.charset(Charset.forName("US-ASCII")).name()).isEqualTo("ISO-8859-1");
   }
 
   @Test public void testParseDanglingSemicolon() throws Exception {
     MediaType mediaType = parse("text/plain;");
-    assertEquals("text", mediaType.type());
-    assertEquals("plain", mediaType.subtype());
-    assertNull(mediaType.charset());
-    assertEquals("text/plain;", mediaType.toString());
+    assertThat(mediaType.type()).isEqualTo("text");
+    assertThat(mediaType.subtype()).isEqualTo("plain");
+    assertThat(mediaType.charset()).isNull();
+    assertThat(mediaType.toString()).isEqualTo("text/plain;");
   }
 
   private void assertMediaType(String string) {
-    assertEquals(string, parse(string).toString());
+    assertThat(parse(string).toString()).isEqualTo(string);
   }
 
   private void assertInvalid(String string, String exceptionMessage) {
@@ -213,10 +212,10 @@ private void assertInvalid(String string, String exceptionMessage) {
         parse(string);
         fail("Expected get of \"" + string + "\" to throw with: " + exceptionMessage);
       } catch (IllegalArgumentException e) {
-        assertEquals(exceptionMessage, e.getMessage());
+        assertThat(e.getMessage()).isEqualTo(exceptionMessage);
       }
     } else {
-      assertNull(string, parse(string));
+      assertThat(parse(string)).overridingErrorMessage(string).isNull();
     }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java b/okhttp/src/test/java/okhttp3/MultipartBodyTest.java
similarity index 73%
rename from okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
rename to okhttp/src/test/java/okhttp3/MultipartBodyTest.java
index 320a690f77..00ae7bbdf5 100644
--- a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
+++ b/okhttp/src/test/java/okhttp3/MultipartBodyTest.java
@@ -21,7 +21,7 @@
 import org.junit.Test;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class MultipartBodyTest {
@@ -30,7 +30,7 @@
       new MultipartBody.Builder().build();
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Multipart body must have at least one part.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Multipart body must have at least one part.");
     }
   }
 
@@ -46,16 +46,16 @@
         .addPart(RequestBody.create(null, "Hello, World!"))
         .build();
 
-    assertEquals("123", body.boundary());
-    assertEquals(MultipartBody.MIXED, body.type());
-    assertEquals("multipart/mixed; boundary=123", body.contentType().toString());
-    assertEquals(1, body.parts().size());
-    assertEquals(53, body.contentLength());
+    assertThat(body.boundary()).isEqualTo("123");
+    assertThat(body.type()).isEqualTo(MultipartBody.MIXED);
+    assertThat(body.contentType().toString()).isEqualTo("multipart/mixed; boundary=123");
+    assertThat(body.parts().size()).isEqualTo(1);
+    assertThat(body.contentLength()).isEqualTo(53);
 
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
-    assertEquals(buffer.size(), body.contentLength());
-    assertEquals(expected, buffer.readUtf8());
+    assertThat(body.contentLength()).isEqualTo(buffer.size());
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
   }
 
   @Test public void threeParts() throws Exception {
@@ -80,16 +80,16 @@
         .addPart(RequestBody.create(null, "Fox"))
         .build();
 
-    assertEquals("123", body.boundary());
-    assertEquals(MultipartBody.MIXED, body.type());
-    assertEquals("multipart/mixed; boundary=123", body.contentType().toString());
-    assertEquals(3, body.parts().size());
-    assertEquals(112, body.contentLength());
+    assertThat(body.boundary()).isEqualTo("123");
+    assertThat(body.type()).isEqualTo(MultipartBody.MIXED);
+    assertThat(body.contentType().toString()).isEqualTo("multipart/mixed; boundary=123");
+    assertThat(body.parts().size()).isEqualTo(3);
+    assertThat(body.contentLength()).isEqualTo(112);
 
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
-    assertEquals(buffer.size(), body.contentLength());
-    assertEquals(expected, buffer.readUtf8());
+    assertThat(body.contentLength()).isEqualTo(buffer.size());
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
   }
 
   @Test public void fieldAndTwoFiles() throws Exception {
@@ -140,16 +140,17 @@
                 .build())
         .build();
 
-    assertEquals("AaB03x", body.boundary());
-    assertEquals(MultipartBody.FORM, body.type());
-    assertEquals("multipart/form-data; boundary=AaB03x", body.contentType().toString());
-    assertEquals(2, body.parts().size());
-    assertEquals(568, body.contentLength());
+    assertThat(body.boundary()).isEqualTo("AaB03x");
+    assertThat(body.type()).isEqualTo(MultipartBody.FORM);
+    assertThat(body.contentType().toString()).isEqualTo(
+        "multipart/form-data; boundary=AaB03x");
+    assertThat(body.parts().size()).isEqualTo(2);
+    assertThat(body.contentLength()).isEqualTo(568);
 
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
-    assertEquals(buffer.size(), body.contentLength());
-    assertEquals(expected, buffer.readUtf8());
+    assertThat(body.contentLength()).isEqualTo(buffer.size());
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
   }
 
   @Test public void stringEscapingIsWeird() throws Exception {
@@ -188,7 +189,7 @@
 
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
-    assertEquals(expected, buffer.readUtf8());
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
   }
 
   @Test public void streamingPartHasNoLength() throws Exception {
@@ -228,15 +229,15 @@
         .addPart(RequestBody.create(null, "Fox"))
         .build();
 
-    assertEquals("123", body.boundary());
-    assertEquals(MultipartBody.MIXED, body.type());
-    assertEquals("multipart/mixed; boundary=123", body.contentType().toString());
-    assertEquals(3, body.parts().size());
-    assertEquals(-1, body.contentLength());
+    assertThat(body.boundary()).isEqualTo("123");
+    assertThat(body.type()).isEqualTo(MultipartBody.MIXED);
+    assertThat(body.contentType().toString()).isEqualTo("multipart/mixed; boundary=123");
+    assertThat(body.parts().size()).isEqualTo(3);
+    assertThat(body.contentLength()).isEqualTo(-1);
 
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
-    assertEquals(expected, buffer.readUtf8());
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
   }
 
   @Test public void contentTypeHeaderIsForbidden() throws Exception {
@@ -263,12 +264,33 @@
     MultipartBody body = new MultipartBody.Builder()
         .addPart(Headers.of("Foo", "Bar"), RequestBody.create(null, "Baz"))
         .build();
-    assertEquals(1, body.parts().size());
+    assertThat(body.parts().size()).isEqualTo(1);
 
     Buffer part1Buffer = new Buffer();
     MultipartBody.Part part1 = body.part(0);
     part1.body().writeTo(part1Buffer);
-    assertEquals(Headers.of("Foo", "Bar"), part1.headers());
-    assertEquals("Baz", part1Buffer.readUtf8());
+    assertThat(part1.headers()).isEqualTo(Headers.of("Foo", "Bar"));
+    assertThat(part1Buffer.readUtf8()).isEqualTo("Baz");
+  }
+
+  @Test public void nonAsciiFilename() throws Exception {
+    String expected = ""
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"attachment\"; filename=\"resum.pdf\"\r\n"
+        + "Content-Type: application/pdf; charset=utf-8\r\n"
+        + "Content-Length: 17\r\n"
+        + "\r\n"
+        + "Jesses Resum\r\n"
+        + "--AaB03x--\r\n";
+
+    MultipartBody body = new MultipartBody.Builder("AaB03x")
+        .setType(MultipartBody.FORM)
+        .addFormDataPart("attachment", "resum.pdf",
+            RequestBody.create(MediaType.parse("application/pdf"), "Jesses Resum"))
+        .build();
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp/src/test/java/okhttp3/OkHttpClientTest.java
similarity index 73%
rename from okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
rename to okhttp/src/test/java/okhttp3/OkHttpClientTest.java
index caf43a52db..7c8b1ffee7 100644
--- a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
+++ b/okhttp/src/test/java/okhttp3/OkHttpClientTest.java
@@ -19,33 +19,27 @@
 import java.net.CookieManager;
 import java.net.ProxySelector;
 import java.net.ResponseCache;
-import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.After;
-import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 
+import static java.util.Arrays.asList;
 import static okhttp3.TestUtil.defaultClient;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class OkHttpClientTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
   private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
   private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
   private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();
-  private final MockWebServer server = new MockWebServer();
-
-  @Before public void setUp() throws Exception {
-    server.start();
-  }
 
   @After public void tearDown() throws Exception {
-    server.shutdown();
     ProxySelector.setDefault(DEFAULT_PROXY_SELECTOR);
     CookieManager.setDefault(DEFAULT_COOKIE_HANDLER);
     ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
@@ -53,11 +47,11 @@
 
   @Test public void durationDefaults() {
     OkHttpClient client = defaultClient();
-    assertEquals(0, client.callTimeoutMillis());
-    assertEquals(10_000, client.connectTimeoutMillis());
-    assertEquals(10_000, client.readTimeoutMillis());
-    assertEquals(10_000, client.writeTimeoutMillis());
-    assertEquals(0, client.pingIntervalMillis());
+    assertThat(client.callTimeoutMillis()).isEqualTo(0);
+    assertThat(client.connectTimeoutMillis()).isEqualTo(10_000);
+    assertThat(client.readTimeoutMillis()).isEqualTo(10_000);
+    assertThat(client.writeTimeoutMillis()).isEqualTo(10_000);
+    assertThat(client.pingIntervalMillis()).isEqualTo(0);
   }
 
   @Test public void timeoutValidRange() {
@@ -103,8 +97,8 @@
         .addInterceptor(interceptor)
         .addNetworkInterceptor(interceptor)
         .build();
-    assertEquals(0, original.interceptors().size());
-    assertEquals(0, original.networkInterceptors().size());
+    assertThat(original.interceptors().size()).isEqualTo(0);
+    assertThat(original.networkInterceptors().size()).isEqualTo(0);
   }
 
   /**
@@ -116,21 +110,21 @@
 
     // Values should be non-null.
     OkHttpClient a = client.newBuilder().build();
-    assertNotNull(a.dispatcher());
-    assertNotNull(a.connectionPool());
-    assertNotNull(a.sslSocketFactory());
+    assertThat(a.dispatcher()).isNotNull();
+    assertThat(a.connectionPool()).isNotNull();
+    assertThat(a.sslSocketFactory()).isNotNull();
 
     // Multiple clients share the instances.
     OkHttpClient b = client.newBuilder().build();
-    assertSame(a.dispatcher(), b.dispatcher());
-    assertSame(a.connectionPool(), b.connectionPool());
-    assertSame(a.sslSocketFactory(), b.sslSocketFactory());
+    assertThat(b.dispatcher()).isSameAs(a.dispatcher());
+    assertThat(b.connectionPool()).isSameAs(a.connectionPool());
+    assertThat(b.sslSocketFactory()).isSameAs(a.sslSocketFactory());
   }
 
   @Test public void setProtocolsRejectsHttp10() throws Exception {
     OkHttpClient.Builder builder = new OkHttpClient.Builder();
     try {
-      builder.protocols(Arrays.asList(Protocol.HTTP_1_0, Protocol.HTTP_1_1));
+      builder.protocols(asList(Protocol.HTTP_1_0, Protocol.HTTP_1_1));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -139,7 +133,7 @@
   @Test public void certificatePinnerEquality() {
     OkHttpClient clientA = TestUtil.defaultClient();
     OkHttpClient clientB = TestUtil.defaultClient();
-    assertEquals(clientA.certificatePinner(), clientB.certificatePinner());
+    assertThat(clientB.certificatePinner()).isEqualTo(clientA.certificatePinner());
   }
 
   @Test public void nullInterceptor() {
@@ -148,7 +142,6 @@
       builder.addInterceptor(null);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("interceptor == null", expected.getMessage());
     }
   }
 
@@ -158,7 +151,6 @@
       builder.addNetworkInterceptor(null);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("interceptor == null", expected.getMessage());
     }
   }
 
@@ -169,7 +161,7 @@
       builder.build();
       fail();
     } catch (IllegalStateException expected) {
-      assertEquals("Null interceptor: [null]", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("Null interceptor: [null]");
     }
   }
 
@@ -180,38 +172,40 @@
       builder.build();
       fail();
     } catch (IllegalStateException expected) {
-      assertEquals("Null network interceptor: [null]", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("Null network interceptor: [null]");
     }
   }
 
   @Test public void testH2PriorKnowledgeOkHttpClientConstructionFallback() {
     try {
       new OkHttpClient.Builder()
-          .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
+          .protocols(asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
-          + "[h2_prior_knowledge, http/1.1]", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("protocols containing h2_prior_knowledge cannot use other protocols: "
+            + "[h2_prior_knowledge, http/1.1]"));
     }
   }
 
   @Test public void testH2PriorKnowledgeOkHttpClientConstructionDuplicates() {
     try {
       new OkHttpClient.Builder()
-          .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
+          .protocols(asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
-          + "[h2_prior_knowledge, h2_prior_knowledge]", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("protocols containing h2_prior_knowledge cannot use other protocols: "
+            + "[h2_prior_knowledge, h2_prior_knowledge]"));
     }
   }
 
   @Test public void testH2PriorKnowledgeOkHttpClientConstructionSuccess() {
     OkHttpClient okHttpClient = new OkHttpClient.Builder()
-        .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE))
+        .protocols(asList(Protocol.H2_PRIOR_KNOWLEDGE))
         .build();
-    assertEquals(1, okHttpClient.protocols().size());
-    assertEquals(Protocol.H2_PRIOR_KNOWLEDGE, okHttpClient.protocols().get(0));
+    assertThat(okHttpClient.protocols().size()).isEqualTo(1);
+    assertThat(okHttpClient.protocols().get(0)).isEqualTo(Protocol.H2_PRIOR_KNOWLEDGE);
   }
 
   @Test public void nullDefaultProxySelector() throws Exception {
@@ -224,7 +218,7 @@
 
     Request request = new Request.Builder().url(server.url("/")).build();
     Response response = client.newCall(request).execute();
-    assertEquals("abc", response.body().string());
+    assertThat(response.body().string()).isEqualTo("abc");
   }
 
   @Test public void sslSocketFactorySetAsSocketFactory() throws Exception {
diff --git a/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java b/okhttp/src/test/java/okhttp3/PlatformRuleTest.kt
similarity index 55%
rename from okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
rename to okhttp/src/test/java/okhttp3/PlatformRuleTest.kt
index d52cb0133d..2c61838d8a 100644
--- a/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
+++ b/okhttp/src/test/java/okhttp3/PlatformRuleTest.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
+ * Copyright (C) 2019 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,12 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3;
+package okhttp3
+
+import okhttp3.internal.platform.Platform
+import org.junit.Rule
+import org.junit.Test
 
 /**
- * An interface that allows OkHttp to detect that a {@link java.net.ResponseCache} contains a {@link
- * Cache}.
+ * Sanity test for checking which environment and IDE is picking up.
  */
-public interface OkCacheContainer {
-  Cache getCache();
-}
+class PlatformRuleTest {
+  @Suppress("RedundantVisibilityModifier")
+  @JvmField
+  @Rule public val platform = PlatformRule()
+
+  @Test
+  fun testMode() {
+    println(PlatformRule.getPlatformSystemProperty())
+    println(Platform.get().javaClass.simpleName)
+  }
+}
\ No newline at end of file
diff --git a/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java b/okhttp/src/test/java/okhttp3/ProtocolTest.java
similarity index 51%
rename from okhttp-tests/src/test/java/okhttp3/ProtocolTest.java
rename to okhttp/src/test/java/okhttp3/ProtocolTest.java
index 78b408093d..ffced6eacf 100644
--- a/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java
+++ b/okhttp/src/test/java/okhttp3/ProtocolTest.java
@@ -18,17 +18,17 @@
 import java.io.IOException;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class ProtocolTest {
   @Test
   public void testGetKnown() throws IOException {
-    assertEquals(Protocol.HTTP_1_0, Protocol.get("http/1.0"));
-    assertEquals(Protocol.HTTP_1_1, Protocol.get("http/1.1"));
-    assertEquals(Protocol.SPDY_3, Protocol.get("spdy/3.1"));
-    assertEquals(Protocol.HTTP_2, Protocol.get("h2"));
-    assertEquals(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.get("h2_prior_knowledge"));
-    assertEquals(Protocol.QUIC, Protocol.get("quic"));
+    assertThat(Protocol.get("http/1.0")).isEqualTo(Protocol.HTTP_1_0);
+    assertThat(Protocol.get("http/1.1")).isEqualTo(Protocol.HTTP_1_1);
+    assertThat(Protocol.get("spdy/3.1")).isEqualTo(Protocol.SPDY_3);
+    assertThat(Protocol.get("h2")).isEqualTo(Protocol.HTTP_2);
+    assertThat(Protocol.get("h2_prior_knowledge")).isEqualTo(Protocol.H2_PRIOR_KNOWLEDGE);
+    assertThat(Protocol.get("quic")).isEqualTo(Protocol.QUIC);
   }
 
   @Test(expected = IOException.class)
@@ -38,11 +38,11 @@ public void testGetUnknown() throws IOException {
 
   @Test
   public void testToString() throws IOException {
-    assertEquals("http/1.0", Protocol.HTTP_1_0.toString());
-    assertEquals("http/1.1", Protocol.HTTP_1_1.toString());
-    assertEquals("spdy/3.1", Protocol.SPDY_3.toString());
-    assertEquals("h2", Protocol.HTTP_2.toString());
-    assertEquals("h2_prior_knowledge", Protocol.H2_PRIOR_KNOWLEDGE.toString());
-    assertEquals("quic", Protocol.QUIC.toString());
+    assertThat(Protocol.HTTP_1_0.toString()).isEqualTo("http/1.0");
+    assertThat(Protocol.HTTP_1_1.toString()).isEqualTo("http/1.1");
+    assertThat(Protocol.SPDY_3.toString()).isEqualTo("spdy/3.1");
+    assertThat(Protocol.HTTP_2.toString()).isEqualTo("h2");
+    assertThat(Protocol.H2_PRIOR_KNOWLEDGE.toString()).isEqualTo("h2_prior_knowledge");
+    assertThat(Protocol.QUIC.toString()).isEqualTo("quic");
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java b/okhttp/src/test/java/okhttp3/RecordedResponse.java
similarity index 72%
rename from okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
rename to okhttp/src/test/java/okhttp3/RecordedResponse.java
index 715cbda383..482d78179b 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
+++ b/okhttp/src/test/java/okhttp3/RecordedResponse.java
@@ -21,11 +21,7 @@
 import java.util.Date;
 import javax.annotation.Nullable;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /**
  * A received response or failure recorded by the response recorder.
@@ -47,58 +43,58 @@ public RecordedResponse(Request request, @Nullable Response response,
   }
 
   public RecordedResponse assertRequestUrl(HttpUrl url) {
-    assertEquals(url, request.url());
+    assertThat(request.url()).isEqualTo(url);
     return this;
   }
 
   public RecordedResponse assertRequestMethod(String method) {
-    assertEquals(method, request.method());
+    assertThat(request.method()).isEqualTo(method);
     return this;
   }
 
   public RecordedResponse assertRequestHeader(String name, String... values) {
-    assertEquals(Arrays.asList(values), request.headers(name));
+    assertThat(request.headers(name)).containsExactly(values);
     return this;
   }
 
   public RecordedResponse assertCode(int expectedCode) {
-    assertEquals(expectedCode, response.code());
+    assertThat(response.code()).isEqualTo(expectedCode);
     return this;
   }
 
   public RecordedResponse assertSuccessful() {
-    assertTrue(response.isSuccessful());
+    assertThat(response.isSuccessful()).isTrue();
     return this;
   }
 
   public RecordedResponse assertNotSuccessful() {
-    assertFalse(response.isSuccessful());
+    assertThat(response.isSuccessful()).isFalse();
     return this;
   }
 
   public RecordedResponse assertHeader(String name, String... values) {
-    assertEquals(Arrays.asList(values), response.headers(name));
+    assertThat(response.headers(name)).containsExactly(values);
     return this;
   }
 
   public RecordedResponse assertHeaders(Headers headers) {
-    assertEquals(headers, response.headers());
+    assertThat(response.headers()).isEqualTo(headers);
     return this;
   }
 
   public RecordedResponse assertBody(String expectedBody) {
-    assertEquals(expectedBody, body);
+    assertThat(body).isEqualTo(expectedBody);
     return this;
   }
 
   public RecordedResponse assertHandshake() {
     Handshake handshake = response.handshake();
-    assertNotNull(handshake.tlsVersion());
-    assertNotNull(handshake.cipherSuite());
-    assertNotNull(handshake.peerPrincipal());
-    assertEquals(1, handshake.peerCertificates().size());
-    assertNull(handshake.localPrincipal());
-    assertEquals(0, handshake.localCertificates().size());
+    assertThat(handshake.tlsVersion()).isNotNull();
+    assertThat(handshake.cipherSuite()).isNotNull();
+    assertThat(handshake.peerPrincipal()).isNotNull();
+    assertThat(handshake.peerCertificates().size()).isEqualTo(1);
+    assertThat(handshake.localPrincipal()).isNull();
+    assertThat(handshake.localCertificates().size()).isEqualTo(0);
     return this;
   }
 
@@ -107,8 +103,8 @@ public RecordedResponse assertHandshake() {
    */
   public RecordedResponse priorResponse() {
     Response priorResponse = response.priorResponse();
-    assertNotNull(priorResponse);
-    assertNull(priorResponse.body());
+    assertThat(priorResponse).isNotNull();
+    assertThat(priorResponse.body()).isNull();
     return new RecordedResponse(priorResponse.request(), priorResponse, null, null, null);
   }
 
@@ -117,20 +113,20 @@ public RecordedResponse priorResponse() {
    */
   public RecordedResponse networkResponse() {
     Response networkResponse = response.networkResponse();
-    assertNotNull(networkResponse);
-    assertNull(networkResponse.body());
+    assertThat(networkResponse).isNotNull();
+    assertThat(networkResponse.body()).isNull();
     return new RecordedResponse(networkResponse.request(), networkResponse, null, null, null);
   }
 
   /** Asserts that the current response didn't use the network. */
   public RecordedResponse assertNoNetworkResponse() {
-    assertNull(response.networkResponse());
+    assertThat(response.networkResponse()).isNull();
     return this;
   }
 
   /** Asserts that the current response didn't use the cache. */
   public RecordedResponse assertNoCacheResponse() {
-    assertNull(response.cacheResponse());
+    assertThat(response.cacheResponse()).isNull();
     return this;
   }
 
@@ -139,8 +135,8 @@ public RecordedResponse assertNoCacheResponse() {
    */
   public RecordedResponse cacheResponse() {
     Response cacheResponse = response.cacheResponse();
-    assertNotNull(cacheResponse);
-    assertNull(cacheResponse.body());
+    assertThat(cacheResponse).isNotNull();
+    assertThat(cacheResponse.body()).isNull();
     return new RecordedResponse(cacheResponse.request(), cacheResponse, null, null, null);
   }
 
@@ -152,19 +148,21 @@ public RecordedResponse assertFailure(Class<?>... allowedExceptionTypes) {
         break;
       }
     }
-    assertTrue("Expected exception type among " + Arrays.toString(allowedExceptionTypes)
-            + ", got " + failure, found);
+    assertThat(found)
+        .overridingErrorMessage("Expected exception type among "
+            + Arrays.toString(allowedExceptionTypes) + ", got " + failure)
+        .isTrue();
     return this;
   }
 
   public RecordedResponse assertFailure(String... messages) {
-    assertNotNull("No failure found", failure);
-    assertTrue(failure.getMessage(), Arrays.asList(messages).contains(failure.getMessage()));
+    assertThat(failure).overridingErrorMessage("No failure found").isNotNull();
+    assertThat(messages).contains(failure.getMessage());
     return this;
   }
 
   public RecordedResponse assertFailureMatches(String... patterns) {
-    assertNotNull(failure);
+    assertThat(failure).isNotNull();
     for (String pattern : patterns) {
       if (failure.getMessage().matches(pattern)) return this;
     }
@@ -182,8 +180,10 @@ public RecordedResponse assertReceivedResponseAtMillis(long minimum, long maximu
   }
 
   private void assertDateInRange(long minimum, long actual, long maximum) {
-    assertTrue("actual " + format(actual) + " < minimum " + format(maximum), actual >= minimum);
-    assertTrue("actual " + format(actual) + " > maximum " + format(minimum), actual <= maximum);
+    assertThat(actual)
+        .overridingErrorMessage("%s <= %s <= %s", format(minimum), format(actual), format(maximum))
+        .isBetween(minimum, maximum);
+
   }
 
   private String format(long time) {
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java b/okhttp/src/test/java/okhttp3/RecordingCallback.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
rename to okhttp/src/test/java/okhttp3/RecordingCallback.java
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java b/okhttp/src/test/java/okhttp3/RecordingEventListener.java
similarity index 88%
rename from okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
rename to okhttp/src/test/java/okhttp3/RecordingEventListener.java
index ee26e6819f..47d3be7a14 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
+++ b/okhttp/src/test/java/okhttp3/RecordingEventListener.java
@@ -19,18 +19,17 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
-import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Deque;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import javax.annotation.Nullable;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
 
-public final class RecordingEventListener extends EventListener {
-  final Deque<CallEvent> eventSequence = new ArrayDeque<>();
+public class RecordingEventListener extends EventListener {
+  final Deque<CallEvent> eventSequence = new ConcurrentLinkedDeque<>();
 
   final List<Object> forbiddenLocks = new ArrayList<>();
 
@@ -44,11 +43,15 @@ public void forbidLock(Object lock) {
    * {@code eventClass} and returns it.
    */
   public <T> T removeUpToEvent(Class<T> eventClass) {
+    List<CallEvent> fullEventSequence = new ArrayList<>(eventSequence);
     Object event = eventSequence.poll();
     while (event != null && !eventClass.isInstance(event)) {
       event = eventSequence.poll();
     }
-    if (event == null) throw new AssertionError();
+    if (event == null) {
+      throw new AssertionError(
+          eventClass.getSimpleName() + " not found. Found " + fullEventSequence + ".");
+    }
     return eventClass.cast(event);
   }
 
@@ -66,14 +69,13 @@ public void clearAllEvents() {
 
   private void logEvent(CallEvent e) {
     for (Object lock : forbiddenLocks) {
-      assertFalse(lock.toString(), Thread.holdsLock(lock));
+      assertThat(Thread.holdsLock(lock)).overridingErrorMessage(lock.toString()).isFalse();
     }
 
     CallEvent startEvent = e.closes();
 
     if (startEvent != null) {
-      assertTrue(e.getName() + " without matching " + startEvent.getName(),
-          eventSequence.contains(startEvent));
+      assertThat(eventSequence).contains(startEvent);
     }
 
     eventSequence.offer(e);
@@ -127,7 +129,7 @@ private void logEvent(CallEvent e) {
   }
 
   @Override public void requestHeadersEnd(Call call, Request request) {
-    logEvent(new RequestHeadersEnd(call, request.headers.byteCount()));
+    logEvent(new RequestHeadersEnd(call, request.headers().byteCount()));
   }
 
   @Override public void requestBodyStart(Call call) {
@@ -138,12 +140,16 @@ private void logEvent(CallEvent e) {
     logEvent(new RequestBodyEnd(call, byteCount));
   }
 
+  @Override public void requestFailed(Call call, IOException ioe) {
+    logEvent(new RequestFailed(call, ioe));
+  }
+
   @Override public void responseHeadersStart(Call call) {
     logEvent(new ResponseHeadersStart(call));
   }
 
   @Override public void responseHeadersEnd(Call call, Response response) {
-    logEvent(new ResponseHeadersEnd(call, response.headers.byteCount()));
+    logEvent(new ResponseHeadersEnd(call, response.headers().byteCount()));
   }
 
   @Override public void responseBodyStart(Call call) {
@@ -154,6 +160,10 @@ private void logEvent(CallEvent e) {
     logEvent(new ResponseBodyEnd(call, byteCount));
   }
 
+  @Override public void responseFailed(Call call, IOException ioe) {
+    logEvent(new ResponseFailed(call, ioe));
+  }
+
   @Override public void callEnd(Call call) {
     logEvent(new CallEnd(call));
   }
@@ -168,7 +178,7 @@ private void logEvent(CallEvent e) {
 
     CallEvent(Call call, Object... params) {
       this.call = call;
-      this.params = Arrays.asList(params);
+      this.params = asList(params);
     }
 
     public String getName() {
@@ -374,6 +384,15 @@ public String getName() {
     }
   }
 
+  static final class RequestFailed extends CallEvent {
+    final IOException ioe;
+
+    RequestFailed(Call call, IOException ioe) {
+      super(call, ioe);
+      this.ioe = ioe;
+    }
+  }
+
   static final class ResponseHeadersStart extends CallEvent {
     ResponseHeadersStart(Call call) {
       super(call);
@@ -411,4 +430,13 @@ public String getName() {
       return new ResponseBodyStart(call);
     }
   }
+
+  static final class ResponseFailed extends CallEvent {
+    final IOException ioe;
+
+    ResponseFailed(Call call, IOException ioe) {
+      super(call, ioe);
+      this.ioe = ioe;
+    }
+  }
 }
diff --git a/okhttp/src/test/java/okhttp3/RecordingExecutor.kt b/okhttp/src/test/java/okhttp3/RecordingExecutor.kt
new file mode 100644
index 0000000000..c9ea6c8901
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/RecordingExecutor.kt
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import org.assertj.core.api.Assertions.assertThat
+import java.util.ArrayList
+import java.util.concurrent.AbstractExecutorService
+import java.util.concurrent.RejectedExecutionException
+import java.util.concurrent.TimeUnit
+
+internal class RecordingExecutor(
+  private val dispatcherTest: DispatcherTest
+) : AbstractExecutorService() {
+  private var shutdown: Boolean = false
+  private val calls = ArrayList<RealCall.AsyncCall>()
+
+  override fun execute(command: Runnable) {
+    if (shutdown) throw RejectedExecutionException()
+    calls.add(command as RealCall.AsyncCall)
+  }
+
+  fun assertJobs(vararg expectedUrls: String) {
+    val actualUrls = calls.map { it.request().url().toString() }
+    assertThat(actualUrls).containsExactly(*expectedUrls)
+  }
+
+  fun finishJob(url: String) {
+    val i = calls.iterator()
+    while (i.hasNext()) {
+      val call = i.next()
+      if (call.request().url().toString() == url) {
+        i.remove()
+        dispatcherTest.dispatcher.finished(call)
+        return
+      }
+    }
+    throw AssertionError("No such job: $url")
+  }
+
+  override fun shutdown() {
+    shutdown = true
+  }
+
+  override fun shutdownNow(): List<Runnable> {
+    throw UnsupportedOperationException()
+  }
+
+  override fun isShutdown(): Boolean {
+    throw UnsupportedOperationException()
+  }
+
+  override fun isTerminated(): Boolean {
+    throw UnsupportedOperationException()
+  }
+
+  override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean {
+    throw UnsupportedOperationException()
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingWebSocketListener.java b/okhttp/src/test/java/okhttp3/RecordingWebSocketListener.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/RecordingWebSocketListener.java
rename to okhttp/src/test/java/okhttp3/RecordingWebSocketListener.java
diff --git a/okhttp-tests/src/test/java/okhttp3/RequestTest.java b/okhttp/src/test/java/okhttp3/RequestTest.java
similarity index 67%
rename from okhttp-tests/src/test/java/okhttp3/RequestTest.java
rename to okhttp/src/test/java/okhttp3/RequestTest.java
index a335abc2dc..11bfe6a81f 100644
--- a/okhttp-tests/src/test/java/okhttp3/RequestTest.java
+++ b/okhttp/src/test/java/okhttp3/RequestTest.java
@@ -19,60 +19,59 @@
 import java.io.FileWriter;
 import java.io.IOException;
 import java.net.URI;
-import java.util.Arrays;
-import java.util.Collections;
 import java.util.UUID;
 import okio.Buffer;
 import org.junit.Test;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class RequestTest {
   @Test public void string() throws Exception {
     MediaType contentType = MediaType.get("text/plain; charset=utf-8");
     RequestBody body = RequestBody.create(contentType, "abc".getBytes(UTF_8));
-    assertEquals(contentType, body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("616263", bodyToHex(body));
-    assertEquals("Retransmit body", "616263", bodyToHex(body));
+    assertThat(body.contentType()).isEqualTo(contentType);
+    assertThat(body.contentLength()).isEqualTo(3);
+    assertThat(bodyToHex(body)).isEqualTo("616263");
+    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
+        "616263");
   }
 
   @Test public void stringWithDefaultCharsetAdded() throws Exception {
     MediaType contentType = MediaType.get("text/plain");
     RequestBody body = RequestBody.create(contentType, "\u0800");
-    assertEquals(MediaType.get("text/plain; charset=utf-8"), body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("e0a080", bodyToHex(body));
+    assertThat(body.contentType()).isEqualTo(MediaType.get("text/plain; charset=utf-8"));
+    assertThat(body.contentLength()).isEqualTo(3);
+    assertThat(bodyToHex(body)).isEqualTo("e0a080");
   }
 
   @Test public void stringWithNonDefaultCharsetSpecified() throws Exception {
     MediaType contentType = MediaType.get("text/plain; charset=utf-16be");
     RequestBody body = RequestBody.create(contentType, "\u0800");
-    assertEquals(contentType, body.contentType());
-    assertEquals(2, body.contentLength());
-    assertEquals("0800", bodyToHex(body));
+    assertThat(body.contentType()).isEqualTo(contentType);
+    assertThat(body.contentLength()).isEqualTo(2);
+    assertThat(bodyToHex(body)).isEqualTo("0800");
   }
 
   @Test public void byteArray() throws Exception {
     MediaType contentType = MediaType.get("text/plain");
     RequestBody body = RequestBody.create(contentType, "abc".getBytes(UTF_8));
-    assertEquals(contentType, body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("616263", bodyToHex(body));
-    assertEquals("Retransmit body", "616263", bodyToHex(body));
+    assertThat(body.contentType()).isEqualTo(contentType);
+    assertThat(body.contentLength()).isEqualTo(3);
+    assertThat(bodyToHex(body)).isEqualTo("616263");
+    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
+        "616263");
   }
 
   @Test public void byteArrayRange() throws Exception {
     MediaType contentType = MediaType.get("text/plain");
     RequestBody body = RequestBody.create(contentType, ".abcd".getBytes(UTF_8), 1, 3);
-    assertEquals(contentType, body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("616263", bodyToHex(body));
-    assertEquals("Retransmit body", "616263", bodyToHex(body));
+    assertThat(body.contentType()).isEqualTo(contentType);
+    assertThat(body.contentLength()).isEqualTo(3);
+    assertThat(bodyToHex(body)).isEqualTo("616263");
+    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
+        "616263");
   }
 
   @Test public void file() throws Exception {
@@ -83,10 +82,11 @@
 
     MediaType contentType = MediaType.get("text/plain");
     RequestBody body = RequestBody.create(contentType, file);
-    assertEquals(contentType, body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("616263", bodyToHex(body));
-    assertEquals("Retransmit body", "616263", bodyToHex(body));
+    assertThat(body.contentType()).isEqualTo(contentType);
+    assertThat(body.contentLength()).isEqualTo(3);
+    assertThat(bodyToHex(body)).isEqualTo("616263");
+    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
+        "616263");
   }
 
   /** Common verbs used for apis such as GitHub, AWS, and Google Cloud. */
@@ -95,48 +95,50 @@
     RequestBody body = RequestBody.create(contentType, "{}");
 
     Request get = new Request.Builder().url("http://localhost/api").get().build();
-    assertEquals("GET", get.method());
-    assertNull(get.body());
+    assertThat(get.method()).isEqualTo("GET");
+    assertThat(get.body()).isNull();
 
     Request head = new Request.Builder().url("http://localhost/api").head().build();
-    assertEquals("HEAD", head.method());
-    assertNull(head.body());
+    assertThat(head.method()).isEqualTo("HEAD");
+    assertThat(head.body()).isNull();
 
     Request delete = new Request.Builder().url("http://localhost/api").delete().build();
-    assertEquals("DELETE", delete.method());
-    assertEquals(0L, delete.body().contentLength());
+    assertThat(delete.method()).isEqualTo("DELETE");
+    assertThat(delete.body().contentLength()).isEqualTo(0L);
 
     Request post = new Request.Builder().url("http://localhost/api").post(body).build();
-    assertEquals("POST", post.method());
-    assertEquals(body, post.body());
+    assertThat(post.method()).isEqualTo("POST");
+    assertThat(post.body()).isEqualTo(body);
 
     Request put = new Request.Builder().url("http://localhost/api").put(body).build();
-    assertEquals("PUT", put.method());
-    assertEquals(body, put.body());
+    assertThat(put.method()).isEqualTo("PUT");
+    assertThat(put.body()).isEqualTo(body);
 
     Request patch = new Request.Builder().url("http://localhost/api").patch(body).build();
-    assertEquals("PATCH", patch.method());
-    assertEquals(body, patch.body());
+    assertThat(patch.method()).isEqualTo("PATCH");
+    assertThat(patch.body()).isEqualTo(body);
   }
 
   @Test public void uninitializedURI() throws Exception {
     Request request = new Request.Builder().url("http://localhost/api").build();
-    assertEquals(new URI("http://localhost/api"), request.url().uri());
-    assertEquals(HttpUrl.get("http://localhost/api"), request.url());
+    assertThat(request.url().uri()).isEqualTo(new URI("http://localhost/api"));
+    assertThat(request.url()).isEqualTo(HttpUrl.get("http://localhost/api"));
   }
 
   @Test public void newBuilderUrlResetsUrl() {
     Request requestWithoutCache = new Request.Builder().url("http://localhost/api").build();
     Request builtRequestWithoutCache =
         requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
-    assertEquals(HttpUrl.get("http://localhost/api/foo"), builtRequestWithoutCache.url());
+    assertThat(builtRequestWithoutCache.url()).isEqualTo(
+        HttpUrl.get("http://localhost/api/foo"));
 
     Request requestWithCache = new Request.Builder().url("http://localhost/api").build();
     // cache url object
     requestWithCache.url();
     Request builtRequestWithCache = requestWithCache.newBuilder().url(
         "http://localhost/api/foo").build();
-    assertEquals(HttpUrl.get("http://localhost/api/foo"), builtRequestWithCache.url());
+    assertThat(builtRequestWithCache.url()).isEqualTo(
+        HttpUrl.get("http://localhost/api/foo"));
   }
 
   @Test public void cacheControl() {
@@ -144,7 +146,7 @@
         .cacheControl(new CacheControl.Builder().noCache().build())
         .url("https://square.com")
         .build();
-    assertEquals(Arrays.asList("no-cache"), request.headers("Cache-Control"));
+    assertThat(request.headers("Cache-Control")).containsExactly("no-cache");
   }
 
   @Test public void emptyCacheControlClearsAllCacheControlHeaders() {
@@ -153,7 +155,7 @@
         .cacheControl(new CacheControl.Builder().build())
         .url("https://square.com")
         .build();
-    assertEquals(Collections.<String>emptyList(), request.headers("Cache-Control"));
+    assertThat(request.headers("Cache-Control")).isEmpty();
   }
 
   @Test public void headerAcceptsPermittedCharacters() {
@@ -181,22 +183,22 @@
     try {
       builder.header(null, "Value");
       fail();
-    } catch (NullPointerException expected) {
+    } catch (IllegalArgumentException expected) {
     }
     try {
       builder.addHeader(null, "Value");
       fail();
-    } catch (NullPointerException expected) {
+    } catch (IllegalArgumentException expected) {
     }
     try {
       builder.header("Name", null);
       fail();
-    } catch (NullPointerException expected) {
+    } catch (IllegalArgumentException expected) {
     }
     try {
       builder.addHeader("Name", null);
       fail();
-    } catch (NullPointerException expected) {
+    } catch (IllegalArgumentException expected) {
     }
   }
 
@@ -248,10 +250,10 @@ private void assertForbiddenHeader(String s) {
     Request request = new Request.Builder()
         .url("https://square.com")
         .build();
-    assertNull(request.tag());
-    assertNull(request.tag(Object.class));
-    assertNull(request.tag(UUID.class));
-    assertNull(request.tag(String.class));
+    assertThat(request.tag()).isNull();
+    assertThat(request.tag(Object.class)).isNull();
+    assertThat(request.tag(UUID.class)).isNull();
+    assertThat(request.tag(String.class)).isNull();
   }
 
   @Test public void defaultTag() {
@@ -260,10 +262,10 @@ private void assertForbiddenHeader(String s) {
         .url("https://square.com")
         .tag(tag)
         .build();
-    assertSame(tag, request.tag());
-    assertSame(tag, request.tag(Object.class));
-    assertNull(request.tag(UUID.class));
-    assertNull(request.tag(String.class));
+    assertThat(request.tag()).isSameAs(tag);
+    assertThat(request.tag(Object.class)).isSameAs(tag);
+    assertThat(request.tag(UUID.class)).isNull();
+    assertThat(request.tag(String.class)).isNull();
   }
 
   @Test public void nullRemovesTag() {
@@ -272,7 +274,7 @@ private void assertForbiddenHeader(String s) {
         .tag("a")
         .tag(null)
         .build();
-    assertNull(request.tag());
+    assertThat(request.tag()).isNull();
   }
 
   @Test public void removeAbsentTag() {
@@ -280,7 +282,7 @@ private void assertForbiddenHeader(String s) {
         .url("https://square.com")
         .tag(null)
         .build();
-    assertNull(request.tag());
+    assertThat(request.tag()).isNull();
   }
 
   @Test public void objectTag() {
@@ -289,10 +291,10 @@ private void assertForbiddenHeader(String s) {
         .url("https://square.com")
         .tag(Object.class, tag)
         .build();
-    assertSame(tag, request.tag());
-    assertSame(tag, request.tag(Object.class));
-    assertNull(request.tag(UUID.class));
-    assertNull(request.tag(String.class));
+    assertThat(request.tag()).isSameAs(tag);
+    assertThat(request.tag(Object.class)).isSameAs(tag);
+    assertThat(request.tag(UUID.class)).isNull();
+    assertThat(request.tag(String.class)).isNull();
   }
 
   @Test public void typedTag() {
@@ -301,10 +303,10 @@ private void assertForbiddenHeader(String s) {
         .url("https://square.com")
         .tag(UUID.class, uuidTag)
         .build();
-    assertNull(request.tag());
-    assertNull(request.tag(Object.class));
-    assertSame(uuidTag, request.tag(UUID.class));
-    assertNull(request.tag(String.class));
+    assertThat(request.tag()).isNull();
+    assertThat(request.tag(Object.class)).isNull();
+    assertThat(request.tag(UUID.class)).isSameAs(uuidTag);
+    assertThat(request.tag(String.class)).isNull();
   }
 
   @Test public void replaceOnlyTag() {
@@ -315,7 +317,7 @@ private void assertForbiddenHeader(String s) {
         .tag(UUID.class, uuidTag1)
         .tag(UUID.class, uuidTag2)
         .build();
-    assertSame(uuidTag2, request.tag(UUID.class));
+    assertThat(request.tag(UUID.class)).isSameAs(uuidTag2);
   }
 
   @Test public void multipleTags() {
@@ -330,11 +332,11 @@ private void assertForbiddenHeader(String s) {
         .tag(String.class, stringTag)
         .tag(Long.class, longTag)
         .build();
-    assertSame(objectTag, request.tag());
-    assertSame(objectTag, request.tag(Object.class));
-    assertSame(uuidTag, request.tag(UUID.class));
-    assertSame(stringTag, request.tag(String.class));
-    assertSame(longTag, request.tag(Long.class));
+    assertThat(request.tag()).isSameAs(objectTag);
+    assertThat(request.tag(Object.class)).isSameAs(objectTag);
+    assertThat(request.tag(UUID.class)).isSameAs(uuidTag);
+    assertThat(request.tag(String.class)).isSameAs(stringTag);
+    assertThat(request.tag(Long.class)).isSameAs(longTag);
   }
 
   /** Confirm that we don't accidentally share the backing map between objects. */
@@ -344,9 +346,9 @@ private void assertForbiddenHeader(String s) {
     Request requestA = builder.tag(String.class, "a").build();
     Request requestB = builder.tag(String.class, "b").build();
     Request requestC = requestA.newBuilder().tag(String.class, "c").build();
-    assertSame("a", requestA.tag(String.class));
-    assertSame("b", requestB.tag(String.class));
-    assertSame("c", requestC.tag(String.class));
+    assertThat(requestA.tag(String.class)).isSameAs("a");
+    assertThat(requestB.tag(String.class)).isSameAs("b");
+    assertThat(requestC.tag(String.class)).isSameAs("c");
   }
 
   private String bodyToHex(RequestBody body) throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java b/okhttp/src/test/java/okhttp3/ResponseBodyTest.java
similarity index 79%
rename from okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
rename to okhttp/src/test/java/okhttp3/ResponseBodyTest.java
index a64ac17d52..cced85f93a 100644
--- a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
+++ b/okhttp/src/test/java/okhttp3/ResponseBodyTest.java
@@ -28,59 +28,58 @@
 import org.junit.Test;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ResponseBodyTest {
   @Test public void stringEmpty() throws IOException {
     ResponseBody body = body("");
-    assertEquals("", body.string());
+    assertThat(body.string()).isEqualTo("");
   }
 
   @Test public void stringLooksLikeBomButTooShort() throws IOException {
     ResponseBody body = body("000048");
-    assertEquals("\0\0H", body.string());
+    assertThat(body.string()).isEqualTo("\0\0H");
   }
 
   @Test public void stringDefaultsToUtf8() throws IOException {
     ResponseBody body = body("68656c6c6f");
-    assertEquals("hello", body.string());
+    assertThat(body.string()).isEqualTo("hello");
   }
 
   @Test public void stringExplicitCharset() throws IOException {
     ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
-    assertEquals("hello", body.string());
+    assertThat(body.string()).isEqualTo("hello");
   }
 
   @Test public void stringBomOverridesExplicitCharset() throws IOException {
     ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f", "utf-8");
-    assertEquals("hello", body.string());
+    assertThat(body.string()).isEqualTo("hello");
   }
 
   @Test public void stringBomUtf8() throws IOException {
     ResponseBody body = body("efbbbf68656c6c6f");
-    assertEquals("hello", body.string());
+    assertThat(body.string()).isEqualTo("hello");
   }
 
   @Test public void stringBomUtf16Be() throws IOException {
     ResponseBody body = body("feff00680065006c006c006f");
-    assertEquals("hello", body.string());
+    assertThat(body.string()).isEqualTo("hello");
   }
 
   @Test public void stringBomUtf16Le() throws IOException {
     ResponseBody body = body("fffe680065006c006c006f00");
-    assertEquals("hello", body.string());
+    assertThat(body.string()).isEqualTo("hello");
   }
 
   @Test public void stringBomUtf32Be() throws IOException {
     ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f");
-    assertEquals("hello", body.string());
+    assertThat(body.string()).isEqualTo("hello");
   }
 
   @Test public void stringBomUtf32Le() throws IOException {
     ResponseBody body = body("ffff000068000000650000006c0000006c0000006f000000");
-    assertEquals("hello", body.string());
+    assertThat(body.string()).isEqualTo("hello");
   }
 
   @Test public void stringClosesUnderlyingSource() throws IOException {
@@ -104,53 +103,53 @@
         });
       }
     };
-    assertEquals("hello", body.string());
-    assertTrue(closed.get());
+    assertThat(body.string()).isEqualTo("hello");
+    assertThat(closed.get()).isTrue();
   }
 
   @Test public void readerEmpty() throws IOException {
     ResponseBody body = body("");
-    assertEquals("", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("");
   }
 
   @Test public void readerLooksLikeBomButTooShort() throws IOException {
     ResponseBody body = body("000048");
-    assertEquals("\0\0H", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("\0\0H");
   }
 
   @Test public void readerDefaultsToUtf8() throws IOException {
     ResponseBody body = body("68656c6c6f");
-    assertEquals("hello", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("hello");
   }
 
   @Test public void readerExplicitCharset() throws IOException {
     ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
-    assertEquals("hello", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("hello");
   }
 
   @Test public void readerBomUtf8() throws IOException {
     ResponseBody body = body("efbbbf68656c6c6f");
-    assertEquals("hello", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("hello");
   }
 
   @Test public void readerBomUtf16Be() throws IOException {
     ResponseBody body = body("feff00680065006c006c006f");
-    assertEquals("hello", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("hello");
   }
 
   @Test public void readerBomUtf16Le() throws IOException {
     ResponseBody body = body("fffe680065006c006c006f00");
-    assertEquals("hello", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("hello");
   }
 
   @Test public void readerBomUtf32Be() throws IOException {
     ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f");
-    assertEquals("hello", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("hello");
   }
 
   @Test public void readerBomUtf32Le() throws IOException {
     ResponseBody body = body("ffff000068000000650000006c0000006c0000006f000000");
-    assertEquals("hello", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("hello");
   }
 
   @Test public void readerClosedBeforeBomClosesUnderlyingSource() throws IOException {
@@ -175,7 +174,7 @@
       }
     };
     body.charStream().close();
-    assertTrue(closed.get());
+    assertThat(closed.get()).isTrue();
   }
 
   @Test public void readerClosedAfterBomClosesUnderlyingSource() throws IOException {
@@ -200,25 +199,25 @@
       }
     };
     Reader reader = body.charStream();
-    assertEquals('h', reader.read());
+    assertThat(reader.read()).isEqualTo('h');
     reader.close();
-    assertTrue(closed.get());
+    assertThat(closed.get()).isTrue();
   }
 
   @Test public void sourceEmpty() throws IOException {
     ResponseBody body = body("");
     BufferedSource source = body.source();
-    assertTrue(source.exhausted());
-    assertEquals("", source.readUtf8());
+    assertThat(source.exhausted()).isTrue();
+    assertThat(source.readUtf8()).isEqualTo("");
   }
 
   @Test public void sourceSeesBom() throws IOException {
     ResponseBody body = body("efbbbf68656c6c6f");
     BufferedSource source = body.source();
-    assertEquals(0xef, source.readByte() & 0xff);
-    assertEquals(0xbb, source.readByte() & 0xff);
-    assertEquals(0xbf, source.readByte() & 0xff);
-    assertEquals("hello", source.readUtf8());
+    assertThat((source.readByte() & 0xff)).isEqualTo(0xef);
+    assertThat((source.readByte() & 0xff)).isEqualTo(0xbb);
+    assertThat((source.readByte() & 0xff)).isEqualTo(0xbf);
+    assertThat(source.readUtf8()).isEqualTo("hello");
   }
 
   @Test public void sourceClosesUnderlyingSource() throws IOException {
@@ -243,21 +242,21 @@
       }
     };
     body.source().close();
-    assertTrue(closed.get());
+    assertThat(closed.get()).isTrue();
   }
 
   @Test public void bytesEmpty() throws IOException {
     ResponseBody body = body("");
-    assertEquals(0, body.bytes().length);
+    assertThat(body.bytes().length).isEqualTo(0);
   }
 
   @Test public void bytesSeesBom() throws IOException {
     ResponseBody body = body("efbbbf68656c6c6f");
     byte[] bytes = body.bytes();
-    assertEquals(0xef, bytes[0] & 0xff);
-    assertEquals(0xbb, bytes[1] & 0xff);
-    assertEquals(0xbf, bytes[2] & 0xff);
-    assertEquals("hello", new String(bytes, 3, 5, UTF_8));
+    assertThat((bytes[0] & 0xff)).isEqualTo(0xef);
+    assertThat((bytes[1] & 0xff)).isEqualTo(0xbb);
+    assertThat((bytes[2] & 0xff)).isEqualTo(0xbf);
+    assertThat(new String(bytes, 3, 5, UTF_8)).isEqualTo("hello");
   }
 
   @Test public void bytesClosesUnderlyingSource() throws IOException {
@@ -281,8 +280,8 @@
         });
       }
     };
-    assertEquals(5, body.bytes().length);
-    assertTrue(closed.get());
+    assertThat(body.bytes().length).isEqualTo(5);
+    assertThat(closed.get()).isTrue();
   }
 
   @Test public void bytesThrowsWhenLengthsDisagree() {
@@ -303,7 +302,8 @@
       body.bytes();
       fail();
     } catch (IOException e) {
-      assertEquals("Content-Length (10) and stream length (5) disagree", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "Content-Length (10) and stream length (5) disagree");
     }
   }
 
@@ -325,23 +325,24 @@
       body.bytes();
       fail();
     } catch (IOException e) {
-      assertEquals("Cannot buffer entire body for content length: 2147483648", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "Cannot buffer entire body for content length: 2147483648");
     }
   }
 
   @Test public void byteStreamEmpty() throws IOException {
     ResponseBody body = body("");
     InputStream bytes = body.byteStream();
-    assertEquals(-1, bytes.read());
+    assertThat(bytes.read()).isEqualTo(-1);
   }
 
   @Test public void byteStreamSeesBom() throws IOException {
     ResponseBody body = body("efbbbf68656c6c6f");
     InputStream bytes = body.byteStream();
-    assertEquals(0xef, bytes.read());
-    assertEquals(0xbb, bytes.read());
-    assertEquals(0xbf, bytes.read());
-    assertEquals("hello", exhaust(new InputStreamReader(bytes, UTF_8)));
+    assertThat(bytes.read()).isEqualTo(0xef);
+    assertThat(bytes.read()).isEqualTo(0xbb);
+    assertThat(bytes.read()).isEqualTo(0xbf);
+    assertThat(exhaust(new InputStreamReader(bytes, UTF_8))).isEqualTo("hello");
   }
 
   @Test public void byteStreamClosesUnderlyingSource() throws IOException {
@@ -366,7 +367,7 @@
       }
     };
     body.byteStream().close();
-    assertTrue(closed.get());
+    assertThat(closed.get()).isTrue();
   }
 
   @Test public void throwingUnderlyingSourceClosesQuietly() throws IOException {
@@ -388,7 +389,7 @@
         });
       }
     };
-    assertEquals("hello", body.source().readUtf8());
+    assertThat(body.source().readUtf8()).isEqualTo("hello");
     body.close();
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseTest.java b/okhttp/src/test/java/okhttp3/ResponseTest.java
similarity index 84%
rename from okhttp-tests/src/test/java/okhttp3/ResponseTest.java
rename to okhttp/src/test/java/okhttp3/ResponseTest.java
index 5d77a02a26..162d2d9a39 100644
--- a/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
+++ b/okhttp/src/test/java/okhttp3/ResponseTest.java
@@ -23,27 +23,27 @@
 import okio.Timeout;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ResponseTest {
   @Test public void peekShorterThanResponse() throws Exception {
     Response response = newResponse(responseBody("abcdef"));
     ResponseBody peekedBody = response.peekBody(3);
-    assertEquals("abc", peekedBody.string());
-    assertEquals("abcdef", response.body().string());
+    assertThat(peekedBody.string()).isEqualTo("abc");
+    assertThat(response.body().string()).isEqualTo("abcdef");
   }
 
   @Test public void peekLongerThanResponse() throws Exception {
     Response response = newResponse(responseBody("abc"));
     ResponseBody peekedBody = response.peekBody(6);
-    assertEquals("abc", peekedBody.string());
-    assertEquals("abc", response.body().string());
+    assertThat(peekedBody.string()).isEqualTo("abc");
+    assertThat(response.body().string()).isEqualTo("abc");
   }
 
   @Test public void peekAfterReadingResponse() throws Exception {
     Response response = newResponse(responseBody("abc"));
-    assertEquals("abc", response.body().string());
+    assertThat(response.body().string()).isEqualTo("abc");
 
     try {
       response.peekBody(3);
@@ -56,9 +56,9 @@
     Response response = newResponse(responseBody("abcdef"));
     ResponseBody p1 = response.peekBody(4);
     ResponseBody p2 = response.peekBody(2);
-    assertEquals("abcdef", response.body().string());
-    assertEquals("abcd", p1.string());
-    assertEquals("ab", p2.string());
+    assertThat(response.body().string()).isEqualTo("abcdef");
+    assertThat(p1.string()).isEqualTo("abcd");
+    assertThat(p2.string()).isEqualTo("ab");
   }
 
   /**
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java b/okhttp/src/test/java/okhttp3/SocksProxy.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/SocksProxy.java
rename to okhttp/src/test/java/okhttp3/SocksProxy.java
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java b/okhttp/src/test/java/okhttp3/SocksProxyTest.java
similarity index 84%
rename from okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
rename to okhttp/src/test/java/okhttp3/SocksProxyTest.java
index 83a6617b90..6768632b6f 100644
--- a/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
+++ b/okhttp/src/test/java/okhttp3/SocksProxyTest.java
@@ -26,22 +26,22 @@
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class SocksProxyTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
   private final SocksProxy socksProxy = new SocksProxy();
-  private final MockWebServer server = new MockWebServer();
 
   @Before public void setUp() throws Exception {
-    server.start();
     socksProxy.play();
   }
 
   @After public void tearDown() throws Exception {
-    server.shutdown();
     socksProxy.shutdown();
   }
 
@@ -55,14 +55,14 @@
 
     Request request1 = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals("abc", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("abc");
 
     Request request2 = new Request.Builder().url(server.url("/")).build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals("def", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("def");
 
     // The HTTP calls should share a single connection.
-    assertEquals(1, socksProxy.connectionCount());
+    assertThat(socksProxy.connectionCount()).isEqualTo(1);
   }
 
   @Test public void proxySelector() throws Exception {
@@ -84,9 +84,9 @@
 
     Request request = new Request.Builder().url(server.url("/")).build();
     Response response = client.newCall(request).execute();
-    assertEquals("abc", response.body().string());
+    assertThat(response.body().string()).isEqualTo("abc");
 
-    assertEquals(1, socksProxy.connectionCount());
+    assertThat(socksProxy.connectionCount()).isEqualTo(1);
   }
 
   @Test public void checkRemoteDNSResolve() throws Exception {
@@ -104,8 +104,8 @@
 
     Request request = new Request.Builder().url(url).build();
     Response response1 = client.newCall(request).execute();
-    assertEquals("abc", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("abc");
 
-    assertEquals(1, socksProxy.connectionCount());
+    assertThat(socksProxy.connectionCount()).isEqualTo(1);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java b/okhttp/src/test/java/okhttp3/TestLogHandler.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
rename to okhttp/src/test/java/okhttp3/TestLogHandler.java
diff --git a/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java b/okhttp/src/test/java/okhttp3/TestTls13Request.java
similarity index 88%
rename from okhttp-tests/src/main/java/okhttp3/TestTls13Request.java
rename to okhttp/src/test/java/okhttp3/TestTls13Request.java
index 9e954b95fe..797dcde7a9 100644
--- a/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java
+++ b/okhttp/src/test/java/okhttp3/TestTls13Request.java
@@ -2,11 +2,12 @@
 
 import java.io.IOException;
 import java.security.Security;
-import java.util.Arrays;
 import java.util.List;
 import okhttp3.internal.platform.Platform;
 import org.conscrypt.Conscrypt;
 
+import static java.util.Arrays.asList;
+
 public class TestTls13Request {
 
   // TLS 1.3
@@ -15,7 +16,7 @@
       CipherSuite.TLS_AES_256_GCM_SHA384,
       CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
       CipherSuite.TLS_AES_128_CCM_SHA256,
-      CipherSuite.TLS_AES_256_CCM_8_SHA256
+      CipherSuite.TLS_AES_128_CCM_8_SHA256
   };
 
   /**
@@ -45,7 +46,7 @@ public static void main(String[] args) {
 
     // https://github.com/tlswg/tls13-spec/wiki/Implementations
     List<String> urls =
-        Arrays.asList("https://enabled.tls13.com", "https://www.howsmyssl.com/a/check",
+        asList("https://enabled.tls13.com", "https://www.howsmyssl.com/a/check",
             "https://tls13.cloudflare.com", "https://www.allizom.org/robots.txt",
             "https://tls13.crypto.mozilla.org/", "https://tls.ctf.network/robots.txt",
             "https://rustls.jbp.io/", "https://h2o.examp1e.net", "https://mew.org/",
@@ -69,13 +70,13 @@ private static void testClient(List<String> urls, OkHttpClient client) {
         sendRequest(client, url);
       }
     } finally {
-      client.dispatcher.executorService().shutdownNow();
-      client.connectionPool.evictAll();
+      client.dispatcher().executorService().shutdownNow();
+      client.connectionPool().evictAll();
     }
   }
 
   private static OkHttpClient buildClient(ConnectionSpec... specs) {
-    return new OkHttpClient.Builder().connectionSpecs(Arrays.asList(specs)).build();
+    return new OkHttpClient.Builder().connectionSpecs(asList(specs)).build();
   }
 
   private static void sendRequest(OkHttpClient client, String url) {
@@ -94,9 +95,9 @@ private static void sendRequest(OkHttpClient client, String url) {
           + " "
           + response.protocol()
           + " "
-          + response.code
+          + response.code()
           + " "
-          + response.body.bytes().length
+          + response.body().bytes().length
           + "b");
     } catch (IOException ioe) {
       System.out.println(ioe.toString());
diff --git a/okhttp/src/test/java/okhttp3/URLConnectionTest.java b/okhttp/src/test/java/okhttp3/URLConnectionTest.java
new file mode 100644
index 0000000000..104cd45815
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/URLConnectionTest.java
@@ -0,0 +1,3867 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.Authenticator;
+import java.net.ConnectException;
+import java.net.CookieManager;
+import java.net.HttpURLConnection;
+import java.net.InetAddress;
+import java.net.PasswordAuthentication;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketAddress;
+import java.net.SocketException;
+import java.net.SocketTimeoutException;
+import java.net.URI;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.UnknownHostException;
+import java.security.KeyStore;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.zip.GZIPInputStream;
+import javax.annotation.Nullable;
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLProtocolException;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.internal.InternalKtKt;
+import okhttp3.internal.RecordingAuthenticator;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.internal.platform.Platform;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.GzipSink;
+import okio.Okio;
+import okio.Utf8;
+import org.junit.After;
+import org.junit.AssumptionViolatedException;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Arrays.asList;
+import static java.util.Locale.US;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static okhttp3.internal.InternalKtKt.addHeaderLenient;
+import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+/** Android's URLConnectionTest, ported to exercise OkHttp's Call API. */
+public final class URLConnectionTest {
+  @Rule public final PlatformRule platform = new PlatformRule();
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final MockWebServer server2 = new MockWebServer();
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+
+  private HandshakeCertificates handshakeCertificates = localhost();
+  private OkHttpClient client = clientTestRule.client;
+  private @Nullable Cache cache;
+
+  @Before public void setUp() {
+    server.setProtocolNegotiationEnabled(false);
+  }
+
+  @After public void tearDown() throws Exception {
+    Authenticator.setDefault(null);
+    System.clearProperty("proxyHost");
+    System.clearProperty("proxyPort");
+    System.clearProperty("http.proxyHost");
+    System.clearProperty("http.proxyPort");
+    System.clearProperty("https.proxyHost");
+    System.clearProperty("https.proxyPort");
+    if (cache != null) {
+      cache.delete();
+    }
+  }
+
+  @Test public void requestHeaders() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .addHeader("D", "e")
+        .addHeader("D", "f")
+        .build();
+    assertThat(request.header("D")).isEqualTo("f");
+    assertThat(request.header("d")).isEqualTo("f");
+    Headers requestHeaders = request.headers();
+    assertThat(new LinkedHashSet<>(requestHeaders.values("D"))).isEqualTo(
+        newSet("e", "f"));
+    assertThat(new LinkedHashSet<>(requestHeaders.values("d"))).isEqualTo(
+        newSet("e", "f"));
+    try {
+      new Request.Builder()
+          .header(null, "j");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Request.Builder()
+          .addHeader(null, "k");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Request.Builder()
+          .addHeader("NullValue", null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Request.Builder()
+          .addHeader("AnotherNullValue", null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+
+    Response response = getResponse(request);
+    response.close();
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertThat(recordedRequest.getHeaders().values("D")).isEqualTo(
+        asList("e", "f"));
+    assertThat(recordedRequest.getHeader("G")).isNull();
+    assertThat(recordedRequest.getHeader("null")).isNull();
+  }
+
+  @Test public void getRequestPropertyReturnsLastValue() {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .addHeader("A", "value1")
+        .addHeader("A", "value2")
+        .build();
+    assertThat(request.header("A")).isEqualTo("value2");
+  }
+
+  @Test public void responseHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.0 200 Fantastic")
+        .addHeader("A: c")
+        .addHeader("B: d")
+        .addHeader("A: e")
+        .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
+
+    Request request = newRequest("/");
+    Response response = getResponse(request);
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("Fantastic");
+    try {
+      response.header(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    Headers responseHeaders = response.headers();
+    assertThat(new LinkedHashSet<>(responseHeaders.values("A"))).isEqualTo(
+        newSet("c", "e"));
+    assertThat(new LinkedHashSet<>(responseHeaders.values("a"))).isEqualTo(
+        newSet("c", "e"));
+    assertThat(responseHeaders.name(0)).isEqualTo("A");
+    assertThat(responseHeaders.value(0)).isEqualTo("c");
+    assertThat(responseHeaders.name(1)).isEqualTo("B");
+    assertThat(responseHeaders.value(1)).isEqualTo("d");
+    assertThat(responseHeaders.name(2)).isEqualTo("A");
+    assertThat(responseHeaders.value(2)).isEqualTo("e");
+    response.body().close();
+  }
+
+  @Test public void serverSendsInvalidStatusLine() {
+    server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
+
+    Request request = newRequest("/");
+
+    try {
+      getResponse(request);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void serverSendsInvalidCodeTooLarge() {
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
+
+    Request request = newRequest("/");
+
+    try {
+      getResponse(request);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void serverSendsInvalidCodeNotANumber() {
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
+
+    Request request = newRequest("/");
+    try {
+      getResponse(request);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void serverSendsUnnecessaryWhitespace() {
+    server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
+
+    Request request = newRequest("/");
+    try {
+      getResponse(request);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void connectRetriesUntilConnectedOrFailed() throws Exception {
+    Request request = newRequest("/foo");
+    server.shutdown();
+
+    try {
+      getResponse(request);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void requestBodySurvivesRetriesWithFixedLength() throws Exception {
+    testRequestBodySurvivesRetries(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void requestBodySurvivesRetriesWithChunkedStreaming() throws Exception {
+    testRequestBodySurvivesRetries(TransferKind.CHUNKED);
+  }
+
+  private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    // Use a misconfigured proxy to guarantee that the request is retried.
+    client = client.newBuilder()
+        .proxySelector(new FakeProxySelector()
+            .addProxy(server2.toProxyAddress())
+            .addProxy(Proxy.NO_PROXY))
+        .build();
+    server2.shutdown();
+
+    Request request = new Request.Builder()
+        .url(server.url("/def"))
+        .post(transferKind.newRequestBody("body"))
+        .build();
+    Response response = getResponse(request);
+    assertContent("abc", response);
+
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("body");
+  }
+
+  // Check that if we don't read to the end of a response, the next request on the
+  // recycled connection doesn't get the unread tail of the first request's response.
+  // http://code.google.com/p/android/issues/detail?id=2939
+  @Test public void bug2939() throws Exception {
+    MockResponse response = new MockResponse()
+        .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8);
+
+    server.enqueue(response);
+    server.enqueue(response);
+
+    Request request = newRequest("/");
+    Response c1 = getResponse(request);
+    assertContent("ABCDE", c1, 5);
+    Response c2 = getResponse(request);
+    assertContent("ABCDE", c2, 5);
+
+    c1.close();
+    c2.close();
+  }
+
+  @Test public void connectionsArePooled() throws Exception {
+    MockResponse response = new MockResponse()
+        .setBody("ABCDEFGHIJKLMNOPQR");
+
+    server.enqueue(response);
+    server.enqueue(response);
+    server.enqueue(response);
+
+    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/foo")));
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/bar?baz=quux")));
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/z")));
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
+  }
+
+  @Test public void chunkedConnectionsArePooled() throws Exception {
+    MockResponse response = new MockResponse()
+        .setChunkedBody("ABCDEFGHIJKLMNOPQR", 5);
+
+    server.enqueue(response);
+    server.enqueue(response);
+    server.enqueue(response);
+
+    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/foo")));
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/bar?baz=quux")));
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/z")));
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
+  }
+
+  @Test public void serverClosesSocket() throws Exception {
+    testServerClosesOutput(DISCONNECT_AT_END);
+  }
+
+  @Test public void serverShutdownInput() throws Exception {
+    testServerClosesOutput(SHUTDOWN_INPUT_AT_END);
+  }
+
+  @Test public void serverShutdownOutput() throws Exception {
+    testServerClosesOutput(SHUTDOWN_OUTPUT_AT_END);
+  }
+
+  @Test public void invalidHost() throws Exception {
+    // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
+    client = client.newBuilder()
+        .dns(new FakeDns())
+        .build();
+    try {
+      getResponse(new Request.Builder()
+          .url(HttpUrl.get("http://1234.1.1.1/index.html"))
+          .build());
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("This connection won't pool properly")
+        .setSocketPolicy(socketPolicy));
+    MockResponse responseAfter = new MockResponse()
+        .setBody("This comes after a busted connection");
+    server.enqueue(responseAfter);
+    server.enqueue(responseAfter); // Enqueue 2x because the broken connection may be reused.
+
+    Response response1 = getResponse(newRequest("/a"));
+    response1.body().source().timeout().timeout(100, MILLISECONDS);
+    assertContent("This connection won't pool properly", response1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+
+    // Give the server time to enact the socket policy if it's one that could happen after the
+    // client has received the response.
+    Thread.sleep(500);
+
+    Response response2 = getResponse(newRequest("/b"));
+    response1.body().source().timeout().timeout(100, MILLISECONDS);
+    assertContent("This comes after a busted connection", response2);
+
+    // Check that a fresh connection was created, either immediately or after attempting reuse.
+    // We know that a fresh connection was created if the server recorded a request with sequence
+    // number 0. Since the client may have attempted to reuse the broken connection just before
+    // creating a fresh connection, the server may have recorded 2 requests at this point. The order
+    // of recording is non-deterministic.
+    RecordedRequest requestAfter = server.takeRequest();
+    assertThat(requestAfter.getSequenceNumber() == 0
+        || server.getRequestCount() == 3 && server.takeRequest().getSequenceNumber() == 0).isTrue();
+  }
+
+  enum WriteKind {BYTE_BY_BYTE, SMALL_BUFFERS, LARGE_BUFFERS}
+
+  @Test public void chunkedUpload_byteByByte() throws Exception {
+    doUpload(TransferKind.CHUNKED, WriteKind.BYTE_BY_BYTE);
+  }
+
+  @Test public void chunkedUpload_smallBuffers() throws Exception {
+    doUpload(TransferKind.CHUNKED, WriteKind.SMALL_BUFFERS);
+  }
+
+  @Test public void chunkedUpload_largeBuffers() throws Exception {
+    doUpload(TransferKind.CHUNKED, WriteKind.LARGE_BUFFERS);
+  }
+
+  @Test public void fixedLengthUpload_byteByByte() throws Exception {
+    doUpload(TransferKind.FIXED_LENGTH, WriteKind.BYTE_BY_BYTE);
+  }
+
+  @Test public void fixedLengthUpload_smallBuffers() throws Exception {
+    doUpload(TransferKind.FIXED_LENGTH, WriteKind.SMALL_BUFFERS);
+  }
+
+  @Test public void fixedLengthUpload_largeBuffers() throws Exception {
+    doUpload(TransferKind.FIXED_LENGTH, WriteKind.LARGE_BUFFERS);
+  }
+
+  private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Exception {
+    int n = 512 * 1024;
+    server.setBodyLimit(0);
+    server.enqueue(new MockResponse());
+
+    RequestBody requestBody = new RequestBody() {
+      @Override public @Nullable MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return uploadKind == TransferKind.CHUNKED ? -1L : n;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        if (writeKind == WriteKind.BYTE_BY_BYTE) {
+          for (int i = 0; i < n; ++i) {
+            sink.writeByte('x');
+          }
+        } else {
+          byte[] buf = new byte[writeKind == WriteKind.SMALL_BUFFERS ? 256 : 64 * 1024];
+          Arrays.fill(buf, (byte) 'x');
+          for (int i = 0; i < n; i += buf.length) {
+            sink.write(buf, 0, Math.min(buf.length, n - i));
+          }
+        }
+      }
+    };
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(requestBody)
+        .build());
+    assertThat(response.code()).isEqualTo(200);
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBodySize()).isEqualTo(n);
+    if (uploadKind == TransferKind.CHUNKED) {
+      assertThat(request.getChunkSizes()).isNotEmpty();
+    } else {
+      assertThat(request.getChunkSizes()).isEmpty();
+    }
+  }
+
+  @Test public void connectViaHttps() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("this response comes via HTTPS"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Response response = getResponse(newRequest("/foo"));
+    assertContent("this response comes via HTTPS", response);
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+  }
+
+  @Test public void connectViaHttpsReusingConnections() throws Exception {
+    connectViaHttpsReusingConnections(false);
+  }
+
+  @Test public void connectViaHttpsReusingConnectionsAfterRebuildingClient() throws Exception {
+    connectViaHttpsReusingConnections(true);
+  }
+
+  private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("this response comes via HTTPS"));
+    server.enqueue(new MockResponse()
+        .setBody("another response via HTTPS"));
+
+    // The pool will only reuse sockets if the SSL socket factories are the same.
+    SSLSocketFactory clientSocketFactory = handshakeCertificates.sslSocketFactory();
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+
+    CookieJar cookieJar = new JavaNetCookieJar(new CookieManager());
+    ConnectionPool connectionPool = new ConnectionPool();
+
+    client = new OkHttpClient.Builder()
+        .cache(cache)
+        .connectionPool(connectionPool)
+        .cookieJar(cookieJar)
+        .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+    Response response1 = getResponse(newRequest("/"));
+    assertContent("this response comes via HTTPS", response1);
+
+    if (rebuildClient) {
+      client = new OkHttpClient.Builder()
+          .cache(cache)
+          .connectionPool(connectionPool)
+          .cookieJar(cookieJar)
+          .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
+          .hostnameVerifier(hostnameVerifier)
+          .build();
+    }
+
+    Response response2 = getResponse(newRequest("/"));
+    assertContent("another response via HTTPS", response2);
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+  }
+
+  @Test public void connectViaHttpsReusingConnectionsDifferentFactories() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("this response comes via HTTPS"));
+    server.enqueue(new MockResponse()
+        .setBody("another response via HTTPS"));
+
+    // install a custom SSL socket factory so the server can be authorized
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    Response response1 = getResponse(newRequest("/"));
+    assertContent("this response comes via HTTPS", response1);
+
+    SSLContext sslContext2 = Platform.get().newSSLContext();
+    sslContext2.init(null, null, null);
+    SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
+
+    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    trustManagerFactory.init((KeyStore) null);
+    X509TrustManager trustManager = (X509TrustManager) trustManagerFactory.getTrustManagers()[0];
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslSocketFactory2, trustManager)
+        .build();
+    try {
+      getResponse(newRequest("/"));
+      fail("without an SSL socket factory, the connection should fail");
+    } catch (SSLException expected) {
+    }
+  }
+
+  // TODO(jwilson): tests below this marker need to be migrated to OkHttp's request/response API.
+
+  @Test public void connectViaHttpsWithSSLFallback() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse()
+        .setBody("this response comes via SSL"));
+
+    client = client.newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
+        .build();
+    Response response = getResponse(newRequest("/foo"));
+
+    assertContent("this response comes via SSL", response);
+
+    RecordedRequest failHandshakeRequest = server.takeRequest();
+    assertThat(failHandshakeRequest.getRequestLine()).isNull();
+
+    RecordedRequest fallbackRequest = server.takeRequest();
+    assertThat(fallbackRequest.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(fallbackRequest.getTlsVersion()).isIn(TlsVersion.TLS_1_2, TlsVersion.TLS_1_3);
+  }
+
+  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(FAIL_HANDSHAKE));
+
+    client = client.newBuilder()
+        .connectionSpecs(asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
+        .build();
+
+    try {
+      getResponse(newRequest("/foo"));
+      fail();
+    } catch (IOException expected) {
+      assertThat(expected.getSuppressed().length).isEqualTo(1);
+    }
+  }
+
+  /**
+   * When a pooled connection fails, don't blame the route. Otherwise pooled connection failures can
+   * cause unnecessary SSL fallbacks.
+   *
+   * https://github.com/square/okhttp/issues/515
+   */
+  @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setSocketPolicy(DISCONNECT_AT_END));
+    server.enqueue(new MockResponse()
+        .setBody("def"));
+
+    client = client.newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
+        .build();
+
+    assertContent("abc", getResponse(newRequest("/")));
+
+    // Give the server time to disconnect.
+    Thread.sleep(500);
+
+    assertContent("def", getResponse(newRequest("/")));
+
+    Set<TlsVersion> tlsVersions =
+        EnumSet.of(TlsVersion.TLS_1_0, TlsVersion.TLS_1_2,
+            TlsVersion.TLS_1_3); // v1.2 on OpenJDK 8.
+
+    RecordedRequest request1 = server.takeRequest();
+    assertThat(tlsVersions).contains(request1.getTlsVersion());
+
+    RecordedRequest request2 = server.takeRequest();
+    assertThat(tlsVersions).contains(request2.getTlsVersion());
+  }
+
+  /**
+   * Verify that we don't retry connections on certificate verification errors.
+   *
+   * http://code.google.com/p/android/issues/detail?id=13178
+   */
+  @Test public void connectViaHttpsToUntrustedServer() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()); // unused
+
+    try {
+      getResponse(newRequest("/foo"));
+      fail();
+    } catch (SSLHandshakeException expected) {
+      assertThat(expected.getCause()).isInstanceOf(CertificateException.class);
+    }
+    assertThat(server.getRequestCount()).isEqualTo(0);
+  }
+
+  @Test public void connectViaProxyUsingProxyArg() throws Exception {
+    testConnectViaProxy(ProxyConfig.CREATE_ARG);
+  }
+
+  @Test public void connectViaProxyUsingProxySystemProperty() throws Exception {
+    testConnectViaProxy(ProxyConfig.PROXY_SYSTEM_PROPERTY);
+  }
+
+  @Test public void connectViaProxyUsingHttpProxySystemProperty() throws Exception {
+    testConnectViaProxy(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
+  }
+
+  private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
+    MockResponse mockResponse = new MockResponse()
+        .setBody("this response comes via a proxy");
+    server.enqueue(mockResponse);
+
+    HttpUrl url = HttpUrl.parse("http://android.com/foo");
+    Response response = proxyConfig.connect(server, client, url).execute();
+    assertContent("this response comes via a proxy", response);
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getRequestLine()).isEqualTo(
+        "GET http://android.com/foo HTTP/1.1");
+    assertThat(request.getHeader("Host")).isEqualTo("android.com");
+  }
+
+  @Test public void contentDisagreesWithContentLengthHeaderBodyTooLong() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("abc\r\nYOU SHOULD NOT SEE THIS")
+        .clearHeaders()
+        .addHeader("Content-Length: 3"));
+    assertContent("abc", getResponse(newRequest("/")));
+  }
+
+  @Test public void contentDisagreesWithContentLengthHeaderBodyTooShort() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setHeader("Content-Length", "5")
+        .setSocketPolicy(DISCONNECT_AT_END));
+    try {
+      Response response = getResponse(newRequest("/"));
+      response.body().source().readUtf8(5);
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
+  private void testConnectViaSocketFactory(boolean useHttps) throws IOException {
+    SocketFactory uselessSocketFactory = new SocketFactory() {
+      @Override public Socket createSocket() {
+        throw new IllegalArgumentException("useless");
+      }
+
+      @Override public Socket createSocket(InetAddress host, int port) {
+        return null;
+      }
+
+      @Override public Socket createSocket(InetAddress address, int port, InetAddress localAddress,
+          int localPort) {
+        return null;
+      }
+
+      @Override public Socket createSocket(String host, int port) {
+        return null;
+      }
+
+      @Override public Socket createSocket(String host, int port, InetAddress localHost, int localPort) {
+        return null;
+      }
+    };
+
+    if (useHttps) {
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+      client = client.newBuilder()
+          .sslSocketFactory(
+              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+          .hostnameVerifier(new RecordingHostnameVerifier())
+          .build();
+    }
+
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 200 OK"));
+
+    client = client.newBuilder()
+        .socketFactory(uselessSocketFactory)
+        .build();
+    try {
+      getResponse(newRequest("/"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+
+    client = client.newBuilder()
+        .socketFactory(SocketFactory.getDefault())
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.code()).isEqualTo(200);
+  }
+
+  @Test public void connectHttpViaSocketFactory() throws Exception {
+    testConnectViaSocketFactory(false);
+  }
+
+  @Test public void connectHttpsViaSocketFactory() throws Exception {
+    testConnectViaSocketFactory(true);
+  }
+
+  @Test public void contentDisagreesWithChunkedHeaderBodyTooLong() throws IOException {
+    MockResponse mockResponse = new MockResponse()
+        .setChunkedBody("abc", 3);
+    Buffer buffer = mockResponse.getBody();
+    buffer.writeUtf8("\r\nYOU SHOULD NOT SEE THIS");
+    mockResponse.setBody(buffer);
+    mockResponse.clearHeaders();
+    mockResponse.addHeader("Transfer-encoding: chunked");
+
+    server.enqueue(mockResponse);
+
+    assertContent("abc", getResponse(newRequest("/")));
+  }
+
+  @Test public void contentDisagreesWithChunkedHeaderBodyTooShort() {
+    MockResponse mockResponse = new MockResponse()
+        .setChunkedBody("abcdefg", 5);
+
+    Buffer truncatedBody = new Buffer();
+    Buffer fullBody = mockResponse.getBody();
+    truncatedBody.write(fullBody, 4);
+    mockResponse.setBody(truncatedBody);
+
+    mockResponse.clearHeaders();
+    mockResponse.addHeader("Transfer-encoding: chunked");
+    mockResponse.setSocketPolicy(DISCONNECT_AT_END);
+
+    server.enqueue(mockResponse);
+
+    try {
+      Response response = getResponse(newRequest("/"));
+      response.body().source().readUtf8(7);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void connectViaHttpProxyToHttpsUsingProxyArgWithNoProxy() throws Exception {
+    testConnectViaDirectProxyToHttps(ProxyConfig.NO_PROXY);
+  }
+
+  @Test public void connectViaHttpProxyToHttpsUsingHttpProxySystemProperty() throws Exception {
+    // https should not use http proxy
+    testConnectViaDirectProxyToHttps(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
+  }
+
+  private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("this response comes via HTTPS"));
+
+    HttpUrl url = server.url("/foo");
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    Call call = proxyConfig.connect(server, client, url);
+
+    assertContent("this response comes via HTTPS", call.execute());
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+  }
+
+  @Test public void connectViaHttpProxyToHttpsUsingProxyArg() throws Exception {
+    testConnectViaHttpProxyToHttps(ProxyConfig.CREATE_ARG);
+  }
+
+  /**
+   * We weren't honoring all of the appropriate proxy system properties when connecting via HTTPS.
+   * http://b/3097518
+   */
+  @Test public void connectViaHttpProxyToHttpsUsingProxySystemProperty() throws Exception {
+    testConnectViaHttpProxyToHttps(ProxyConfig.PROXY_SYSTEM_PROPERTY);
+  }
+
+  @Test public void connectViaHttpProxyToHttpsUsingHttpsProxySystemProperty() throws Exception {
+    testConnectViaHttpProxyToHttps(ProxyConfig.HTTPS_PROXY_SYSTEM_PROPERTY);
+  }
+
+  /**
+   * We were verifying the wrong hostname when connecting to an HTTPS site through a proxy.
+   * http://b/3097277
+   */
+  private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("this response comes via a secure proxy"));
+
+    HttpUrl url = HttpUrl.parse("https://android.com/foo");
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+    Call call = proxyConfig.connect(server, client, url);
+
+    assertContent("this response comes via a secure proxy", call.execute());
+
+    RecordedRequest connect = server.takeRequest();
+    assertThat(connect.getRequestLine()).overridingErrorMessage(
+        "Connect line failure on proxy").isEqualTo("CONNECT android.com:443 HTTP/1.1");
+    assertThat(connect.getHeader("Host")).isEqualTo("android.com:443");
+
+    RecordedRequest get = server.takeRequest();
+    assertThat(get.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(get.getHeader("Host")).isEqualTo("android.com");
+    assertThat(hostnameVerifier.calls).isEqualTo(
+        asList("verify android.com"));
+  }
+
+  /** Tolerate bad https proxy response when using HttpResponseCache. Android bug 6754912. */
+  @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
+    initResponseCache();
+
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
+    MockResponse badProxyResponse = new MockResponse()
+        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
+        .setBody("bogus proxy connect response content");
+    server.enqueue(badProxyResponse);
+    server.enqueue(new MockResponse()
+        .setBody("response"));
+
+    // Configure a single IP address for the host and a single configuration, so we only need one
+    // failure to fail permanently.
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Response response = getResponse(new Request.Builder()
+        .url(HttpUrl.get("https://android.com/foo"))
+        .build());
+    assertContent("response", response);
+
+    RecordedRequest connect = server.takeRequest();
+    assertThat(connect.getRequestLine()).isEqualTo(
+        "CONNECT android.com:443 HTTP/1.1");
+    assertThat(connect.getHeader("Host")).isEqualTo("android.com:443");
+  }
+
+  private void initResponseCache() {
+    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+  }
+
+  /** Test which headers are sent unencrypted to the HTTP proxy. */
+  @Test public void proxyConnectIncludesProxyHeadersOnly() throws Exception {
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("encrypted response from the origin server"));
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+
+    Response response = getResponse(new Request.Builder()
+        .url(HttpUrl.get("https://android.com/foo"))
+        .header("Private", "Secret")
+        .header("Proxy-Authorization", "bar")
+        .header("User-Agent", "baz")
+        .build());
+    assertContent("encrypted response from the origin server", response);
+
+    RecordedRequest connect = server.takeRequest();
+    assertThat(connect.getHeader("Private")).isNull();
+    assertThat(connect.getHeader("Proxy-Authorization")).isNull();
+    assertThat(connect.getHeader("User-Agent")).isEqualTo(Version.userAgent);
+    assertThat(connect.getHeader("Host")).isEqualTo("android.com:443");
+    assertThat(connect.getHeader("Proxy-Connection")).isEqualTo("Keep-Alive");
+
+    RecordedRequest get = server.takeRequest();
+    assertThat(get.getHeader("Private")).isEqualTo("Secret");
+    assertThat(hostnameVerifier.calls).isEqualTo(
+        asList("verify android.com"));
+  }
+
+  @Test public void proxyAuthenticateOnConnect() throws Exception {
+    Authenticator.setDefault(new RecordingAuthenticator());
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    client = client.newBuilder()
+        .proxyAuthenticator(new JavaNetAuthenticator())
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Response response = getResponse(new Request.Builder()
+        .url(HttpUrl.parse("https://android.com/foo"))
+        .build());
+    assertContent("A", response);
+
+    RecordedRequest connect1 = server.takeRequest();
+    assertThat(connect1.getRequestLine()).isEqualTo(
+        "CONNECT android.com:443 HTTP/1.1");
+    assertThat(connect1.getHeader("Proxy-Authorization")).isNull();
+
+    RecordedRequest connect2 = server.takeRequest();
+    assertThat(connect2.getRequestLine()).isEqualTo(
+        "CONNECT android.com:443 HTTP/1.1");
+    assertThat(connect2.getHeader("Proxy-Authorization")).isEqualTo(
+        ("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS));
+
+    RecordedRequest get = server.takeRequest();
+    assertThat(get.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(get.getHeader("Proxy-Authorization")).isNull();
+  }
+
+  // Don't disconnect after building a tunnel with CONNECT
+  // http://code.google.com/p/android/issues/detail?id=37221
+  @Test public void proxyWithConnectionClose() throws IOException {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("this response comes via a proxy"));
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Response response = getResponse(new Request.Builder()
+        .url("https://android.com/foo")
+        .header("Connection", "close")
+        .build());
+
+    assertContent("this response comes via a proxy", response);
+  }
+
+  @Test public void proxyWithConnectionReuse() throws IOException {
+    SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+
+    server.useHttps(socketFactory, true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response 1"));
+    server.enqueue(new MockResponse()
+        .setBody("response 2"));
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+
+    assertContent("response 1", getResponse(newRequest(HttpUrl.get("https://android.com/foo"))));
+    assertContent("response 2", getResponse(newRequest(HttpUrl.get("https://android.com/foo"))));
+  }
+
+  @Test public void proxySelectorHttpWithConnectionReuse() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("response 1"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(407));
+
+    client = client.newBuilder()
+        .proxySelector(new ProxySelector() {
+          @Override public List<Proxy> select(URI uri) {
+            return Collections.singletonList(server.toProxyAddress());
+          }
+
+          @Override public void connectFailed(
+              URI uri, SocketAddress socketAddress, IOException e) {
+          }
+        }).build();
+    HttpUrl url = HttpUrl.get("http://android.com/foo");
+    assertContent("response 1", getResponse(newRequest(url)));
+    assertThat(getResponse(newRequest(url)).code()).isEqualTo(407);
+  }
+
+  @Test public void disconnectedConnection() throws IOException {
+    server.enqueue(new MockResponse()
+        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
+        .setBody("ABCD"));
+
+    Call call = client.newCall(newRequest("/"));
+    Response response = call.execute();
+    InputStream in = response.body().byteStream();
+    assertThat((char) in.read()).isEqualTo('A');
+    call.cancel();
+    try {
+      // Reading 'B' may succeed if it's buffered.
+      in.read();
+
+      // But 'C' shouldn't be buffered (the response is throttled) and this should fail.
+      in.read();
+      fail("Expected a connection closed exception");
+    } catch (IOException expected) {
+    }
+    in.close();
+  }
+
+  @Test public void disconnectDuringConnect_cookieJar() {
+    AtomicReference<Call> callReference = new AtomicReference<>();
+
+    class DisconnectingCookieJar implements CookieJar {
+      @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
+      }
+
+      @Override public List<Cookie> loadForRequest(HttpUrl url) {
+        callReference.get().cancel();
+        return Collections.emptyList();
+      }
+    }
+    client = client.newBuilder()
+        .cookieJar(new DisconnectingCookieJar())
+        .build();
+
+    Call call = client.newCall(newRequest("/"));
+    callReference.set(call);
+    try {
+      call.execute();
+      fail("Connection should not be established");
+    } catch (IOException expected) {
+      assertThat(expected.getMessage()).isEqualTo("Canceled");
+    }
+  }
+
+  @Test public void disconnectBeforeConnect() {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    Call call = client.newCall(newRequest("/"));
+    call.cancel();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @SuppressWarnings("deprecation") @Test public void defaultRequestProperty() {
+    URLConnection.setDefaultRequestProperty("X-testSetDefaultRequestProperty", "A");
+    assertThat(
+        (Object) URLConnection.getDefaultRequestProperty("X-setDefaultRequestProperty")).isNull();
+  }
+
+  /**
+   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
+   * characters can be read, the remaining characters are returned and the stream is closed.
+   */
+  private String readAscii(InputStream in, int count) throws IOException {
+    StringBuilder result = new StringBuilder();
+    for (int i = 0; i < count; i++) {
+      int value = in.read();
+      if (value == -1) {
+        in.close();
+        break;
+      }
+      result.append((char) value);
+    }
+    return result.toString();
+  }
+
+  @Test public void markAndResetWithContentLengthHeader() throws IOException {
+    testMarkAndReset(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void markAndResetWithChunkedEncoding() throws IOException {
+    testMarkAndReset(TransferKind.CHUNKED);
+  }
+
+  @Test public void markAndResetWithNoLengthHeaders() throws IOException {
+    testMarkAndReset(TransferKind.END_OF_STREAM);
+  }
+
+  private void testMarkAndReset(TransferKind transferKind) throws IOException {
+    MockResponse response = new MockResponse();
+    transferKind.setBody(response, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1024);
+    server.enqueue(response);
+    server.enqueue(response);
+
+    InputStream in = getResponse(newRequest("/")).body().byteStream();
+    assertThat(in.markSupported())
+        .overridingErrorMessage("This implementation claims to support mark().")
+        .isFalse();
+    in.mark(5);
+    assertThat(readAscii(in, 5)).isEqualTo("ABCDE");
+    try {
+      in.reset();
+      fail();
+    } catch (IOException expected) {
+    }
+    assertThat(readAscii(in, Integer.MAX_VALUE)).isEqualTo(
+        "FGHIJKLMNOPQRSTUVWXYZ");
+    in.close();
+    assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", getResponse(newRequest("/")));
+  }
+
+  /**
+   * We've had a bug where we forget the HTTP response when we see response code 401. This causes a
+   * new HTTP request to be issued for every call into the URLConnection.
+   */
+  @Test public void unauthorizedResponseHandling() throws IOException {
+    MockResponse mockResponse = new MockResponse()
+        .addHeader("WWW-Authenticate: challenge")
+        .setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
+        .setBody("Unauthorized");
+    server.enqueue(mockResponse);
+    server.enqueue(mockResponse);
+    server.enqueue(mockResponse);
+
+    Response response = getResponse(newRequest("/"));
+
+    assertThat(response.code()).isEqualTo(401);
+    assertThat(response.code()).isEqualTo(401);
+    assertThat(response.code()).isEqualTo(401);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    response.body().close();
+  }
+
+  @Test public void nonHexChunkSize() {
+    server.enqueue(new MockResponse()
+        .setBody("5\r\nABCDE\r\nG\r\nFGHIJKLMNOPQRSTU\r\n0\r\n\r\n")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked"));
+
+    try (Response response = getResponse(newRequest("/"))) {
+      response.body().string();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void malformedChunkSize() {
+    server.enqueue(new MockResponse()
+        .setBody("5:x\r\nABCDE\r\n0\r\n\r\n")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked"));
+
+    try (Response response = getResponse(newRequest("/"))) {
+      readAscii(response.body().byteStream(), Integer.MAX_VALUE);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void extensionAfterChunkSize() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("5;x\r\nABCDE\r\n0\r\n\r\n")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked"));
+
+    try (Response response = getResponse(newRequest("/"))) {
+      assertContent("ABCDE", response);
+    }
+  }
+
+  @Test public void missingChunkBody() {
+    server.enqueue(new MockResponse()
+        .setBody("5")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked")
+        .setSocketPolicy(DISCONNECT_AT_END));
+
+    try (Response response = getResponse(newRequest("/"))) {
+      readAscii(response.body().byteStream(), Integer.MAX_VALUE);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  /**
+   * This test checks whether connections are gzipped by default. This behavior in not required by
+   * the API, so a failure of this test does not imply a bug in the implementation.
+   */
+  @Test public void gzipEncodingEnabledByDefault() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip"));
+
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "ABCABCABC");
+    assertThat(response.header("Content-Encoding")).isNull();
+    assertThat(response.body().contentLength()).isEqualTo(-1L);
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Accept-Encoding")).isEqualTo("gzip");
+  }
+
+  @Test public void clientConfiguredGzipContentEncoding() throws Exception {
+    Buffer bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
+    server.enqueue(new MockResponse()
+        .setBody(bodyBytes)
+        .addHeader("Content-Encoding: gzip"));
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .header("Accept-Encoding", "gzip")
+        .build());
+    InputStream gunzippedIn = new GZIPInputStream(response.body().byteStream());
+    assertThat(readAscii(gunzippedIn, Integer.MAX_VALUE)).isEqualTo(
+        "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
+    assertThat(response.body().contentLength()).isEqualTo(bodyBytes.size());
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Accept-Encoding")).isEqualTo("gzip");
+  }
+
+  @Test public void gzipAndConnectionReuseWithFixedLength() throws Exception {
+    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, false);
+  }
+
+  @Test public void gzipAndConnectionReuseWithChunkedEncoding() throws Exception {
+    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, false);
+  }
+
+  @Test public void gzipAndConnectionReuseWithFixedLengthAndTls() throws Exception {
+    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, true);
+  }
+
+  @Test public void gzipAndConnectionReuseWithChunkedEncodingAndTls() throws Exception {
+    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, true);
+  }
+
+  @Test public void clientConfiguredCustomContentEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .addHeader("Content-Encoding: custom"));
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .header("Accept-Encoding", "custom")
+        .build());
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "ABCDE");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Accept-Encoding")).isEqualTo("custom");
+  }
+
+  /**
+   * Test a bug where gzip input streams weren't exhausting the input stream, which corrupted the
+   * request that followed or prevented connection reuse. http://code.google.com/p/android/issues/detail?id=7059
+   * http://code.google.com/p/android/issues/detail?id=38817
+   */
+  private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind transferKind,
+      boolean tls) throws Exception {
+    if (tls) {
+      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
+      RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+      server.useHttps(socketFactory, false);
+      client = client.newBuilder()
+          .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
+          .hostnameVerifier(hostnameVerifier)
+          .build();
+    }
+
+    MockResponse responseOne = new MockResponse()
+        .addHeader("Content-Encoding: gzip");
+    transferKind.setBody(responseOne, gzip("one (gzipped)"), 5);
+    server.enqueue(responseOne);
+    MockResponse responseTwo = new MockResponse();
+    transferKind.setBody(responseTwo, "two (identity)", 5);
+    server.enqueue(responseTwo);
+
+    Response response1 = getResponse(new Request.Builder()
+        .header("Accept-Encoding", "gzip")
+        .url(server.url("/"))
+        .build());
+    InputStream gunzippedIn = new GZIPInputStream(response1.body().byteStream());
+    assertThat(readAscii(gunzippedIn, Integer.MAX_VALUE)).isEqualTo(
+        "one (gzipped)");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+
+    Response response2 = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    assertThat(readAscii(response2.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "two (identity)");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+  }
+
+  @Test public void transparentGzipWorksAfterExceptionRecovery() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("a")
+        .setSocketPolicy(SHUTDOWN_INPUT_AT_END));
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("b")));
+
+    // Seed the pool with a bad connection.
+    assertContent("a", getResponse(newRequest("/")));
+
+    // Give the server time to disconnect.
+    Thread.sleep(500);
+
+    // This connection will need to be recovered. When it is, transparent gzip should still work!
+    assertContent("b", getResponse(newRequest("/")));
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Connection is not pooled.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+  }
+
+  @Test public void endOfStreamResponseIsNotPooled() throws Exception {
+    client.connectionPool().evictAll();
+    server.enqueue(new MockResponse()
+        .setBody("{}")
+        .clearHeaders()
+        .setSocketPolicy(DISCONNECT_AT_END));
+
+    Response response = getResponse(newRequest("/"));
+    assertContent("{}", response);
+    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(0);
+  }
+
+  @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
+    testEarlyDisconnectDoesntHarmPooling(TransferKind.CHUNKED);
+  }
+
+  @Test public void earlyDisconnectDoesntHarmPoolingWithFixedLengthEncoding() throws Exception {
+    testEarlyDisconnectDoesntHarmPooling(TransferKind.FIXED_LENGTH);
+  }
+
+  private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) throws Exception {
+    MockResponse mockResponse1 = new MockResponse();
+    transferKind.setBody(mockResponse1, "ABCDEFGHIJK", 1024);
+    server.enqueue(mockResponse1);
+
+    MockResponse mockResponse2 = new MockResponse();
+    transferKind.setBody(mockResponse2, "LMNOPQRSTUV", 1024);
+    server.enqueue(mockResponse2);
+
+    Call call1 = client.newCall(newRequest("/"));
+    Response response1 = call1.execute();
+    InputStream in1 = response1.body().byteStream();
+    assertThat(readAscii(in1, 5)).isEqualTo("ABCDE");
+    in1.close();
+    call1.cancel();
+
+    Call call2 = client.newCall(newRequest("/"));
+    Response response2 = call2.execute();
+    InputStream in2 = response2.body().byteStream();
+    assertThat(readAscii(in2, 5)).isEqualTo("LMNOP");
+    in2.close();
+    call2.cancel();
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Connection is pooled!
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+  }
+
+  @Test public void streamDiscardingIsTimely() throws Exception {
+    // This response takes at least a full second to serve: 10,000 bytes served 100 bytes at a time.
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[10000]))
+        .throttleBody(100, 10, MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    long startNanos = System.nanoTime();
+    Response connection1 = getResponse(newRequest("/"));
+    InputStream in = connection1.body().byteStream();
+    in.close();
+    long elapsedNanos = System.nanoTime() - startNanos;
+    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
+
+    // If we're working correctly, this should be greater than 100ms, but less than double that.
+    // Previously we had a bug where we would download the entire response body as long as no
+    // individual read took longer than 100ms.
+    assertThat(elapsedMillis).isLessThan(500L);
+
+    // Do another request to confirm that the discarded connection was not pooled.
+    assertContent("A", getResponse(newRequest("/")));
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Connection is not pooled.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+  }
+
+  @Test public void setChunkedStreamingMode() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(TransferKind.CHUNKED.newRequestBody("ABCDEFGHIJKLMNOPQ"))
+        .build());
+    assertThat(response.code()).isEqualTo(200);
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("ABCDEFGHIJKLMNOPQ");
+    assertThat(request.getChunkSizes()).isEqualTo(
+        asList("ABCDEFGHIJKLMNOPQ".length()));
+  }
+
+  @Test public void authenticateWithFixedLengthStreaming() throws Exception {
+    testAuthenticateWithStreamingPost(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void authenticateWithChunkedStreaming() throws Exception {
+    testAuthenticateWithStreamingPost(TransferKind.CHUNKED);
+  }
+
+  private void testAuthenticateWithStreamingPost(TransferKind streamingMode) throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate."));
+    server.enqueue(new MockResponse()
+        .setBody("Authenticated!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    client = client.newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build();
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(streamingMode.newRequestBody("ABCD"))
+        .build();
+    Response response = getResponse(request);
+    assertThat(response.code()).isEqualTo(200);
+    assertContent("Authenticated!", response);
+
+    // No authorization header for the request...
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertThat(recordedRequest.getHeader("Authorization")).isNull();
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("ABCD");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    platform.assumeHttp2Support();
+
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    platform.assumeHttp2Support();
+
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse());
+
+    String credential = Credentials.basic("jesse", "secret");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential, null))
+        .build();
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(null, body))
+        .build());
+    assertThat(response.code()).isEqualTo(200);
+    response.body().byteStream().close();
+
+    RecordedRequest recordedRequest1 = server.takeRequest();
+    assertThat(recordedRequest1.getMethod()).isEqualTo("POST");
+    assertThat(recordedRequest1.getBody().readUtf8()).isEqualTo(body);
+    assertThat(recordedRequest1.getHeader("Authorization")).isNull();
+
+    RecordedRequest recordedRequest2 = server.takeRequest();
+    assertThat(recordedRequest2.getMethod()).isEqualTo("POST");
+    assertThat(recordedRequest2.getBody().readUtf8()).isEqualTo(body);
+    assertThat(recordedRequest2.getHeader("Authorization")).isEqualTo(
+        credential);
+  }
+
+  @Test public void nonStandardAuthenticationScheme() throws Exception {
+    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo");
+    assertThat(calls).isEqualTo(Collections.<String>emptyList());
+  }
+
+  @Test public void nonStandardAuthenticationSchemeWithRealm() throws Exception {
+    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo realm=\"Bar\"");
+    assertThat(calls.size()).isEqualTo(0);
+  }
+
+  // Digest auth is currently unsupported. Test that digest requests should fail reasonably.
+  // http://code.google.com/p/android/issues/detail?id=11140
+  @Test public void digestAuthentication() throws Exception {
+    List<String> calls = authCallsForHeader("WWW-Authenticate: Digest "
+        + "realm=\"testrealm@host.com\", qop=\"auth,auth-int\", "
+        + "nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", "
+        + "opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"");
+    assertThat(calls.size()).isEqualTo(0);
+  }
+
+  @Test public void allAttributesSetInServerAuthenticationCallbacks() throws Exception {
+    List<String> calls = authCallsForHeader("WWW-Authenticate: Basic realm=\"Bar\"");
+    assertThat(calls.size()).isEqualTo(1);
+    URL url = server.url("/").url();
+    String call = calls.get(0);
+    assertThat(call).contains("host=" + url.getHost());
+    assertThat(call).contains("port=" + url.getPort());
+    assertThat(call).contains("site=" + url.getHost());
+    assertThat(call).contains("url=" + url);
+    assertThat(call).contains("type=" + Authenticator.RequestorType.SERVER);
+    assertThat(call).contains("prompt=Bar");
+    assertThat(call).contains("protocol=http");
+    assertThat(call.toLowerCase(US)).contains("scheme=basic"); // lowercase for the RI.
+  }
+
+  @Test public void allAttributesSetInProxyAuthenticationCallbacks() throws Exception {
+    List<String> calls = authCallsForHeader("Proxy-Authenticate: Basic realm=\"Bar\"");
+    assertThat(calls.size()).isEqualTo(1);
+    URL url = server.url("/").url();
+    String call = calls.get(0);
+    assertThat(call).contains("host=" + url.getHost());
+    assertThat(call).contains("port=" + url.getPort());
+    assertThat(call).contains("site=" + url.getHost());
+    assertThat(call).contains("url=http://android.com");
+    assertThat(call).contains("type=" + Authenticator.RequestorType.PROXY);
+    assertThat(call).contains("prompt=Bar");
+    assertThat(call).contains("protocol=http");
+    assertThat(call.toLowerCase(US)).contains("scheme=basic");
+  }
+
+  private List<String> authCallsForHeader(String authHeader) throws IOException {
+    boolean proxy = authHeader.startsWith("Proxy-");
+    int responseCode = proxy ? 407 : 401;
+    RecordingAuthenticator authenticator = new RecordingAuthenticator(null);
+    Authenticator.setDefault(authenticator);
+    server.enqueue(new MockResponse()
+        .setResponseCode(responseCode)
+        .addHeader(authHeader)
+        .setBody("Please authenticate."));
+
+    Response response;
+    if (proxy) {
+      client = client.newBuilder()
+          .proxy(server.toProxyAddress())
+          .proxyAuthenticator(new JavaNetAuthenticator())
+          .build();
+      response = getResponse(newRequest(HttpUrl.get("http://android.com/")));
+    } else {
+      client = client.newBuilder()
+          .authenticator(new JavaNetAuthenticator())
+          .build();
+      response = getResponse(newRequest("/"));
+    }
+    assertThat(response.code()).isEqualTo(responseCode);
+    response.body().byteStream().close();
+    return authenticator.calls;
+  }
+
+  @Test public void setValidRequestMethod() {
+    assertMethodForbidsRequestBody("GET");
+    assertMethodPermitsRequestBody("DELETE");
+    assertMethodForbidsRequestBody("HEAD");
+    assertMethodPermitsRequestBody("OPTIONS");
+    assertMethodPermitsRequestBody("POST");
+    assertMethodPermitsRequestBody("PUT");
+    assertMethodPermitsRequestBody("TRACE");
+    assertMethodPermitsRequestBody("PATCH");
+
+    assertMethodPermitsNoRequestBody("GET");
+    assertMethodPermitsNoRequestBody("DELETE");
+    assertMethodPermitsNoRequestBody("HEAD");
+    assertMethodPermitsNoRequestBody("OPTIONS");
+    assertMethodForbidsNoRequestBody("POST");
+    assertMethodForbidsNoRequestBody("PUT");
+    assertMethodPermitsNoRequestBody("TRACE");
+    assertMethodForbidsNoRequestBody("PATCH");
+  }
+
+  private void assertMethodPermitsRequestBody(String requestMethod) {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method(requestMethod, RequestBody.create(null, "abc"))
+        .build();
+    assertThat(request.method()).isEqualTo(requestMethod);
+  }
+
+  private void assertMethodForbidsRequestBody(String requestMethod) {
+    try {
+      new Request.Builder()
+          .url(server.url("/"))
+          .method(requestMethod, RequestBody.create(null, "abc"))
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  private void assertMethodPermitsNoRequestBody(String requestMethod) {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method(requestMethod, null)
+        .build();
+    assertThat(request.method()).isEqualTo(requestMethod);
+  }
+
+  private void assertMethodForbidsNoRequestBody(String requestMethod) {
+    try {
+      new Request.Builder()
+          .url(server.url("/"))
+          .method(requestMethod, null)
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setInvalidRequestMethodLowercase() throws Exception {
+    assertValidRequestMethod("get");
+  }
+
+  @Test public void setInvalidRequestMethodConnect() throws Exception {
+    assertValidRequestMethod("CONNECT");
+  }
+
+  private void assertValidRequestMethod(String requestMethod) throws Exception {
+    server.enqueue(new MockResponse());
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .method(requestMethod, null)
+        .build());
+    assertThat(response.code()).isEqualTo(200);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertThat(recordedRequest.getMethod()).isEqualTo(requestMethod);
+  }
+
+  @Test public void shoutcast() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("ICY 200 OK")
+        .addHeader("Accept-Ranges: none")
+        .addHeader("Content-Type: audio/mpeg")
+        .addHeader("icy-br:128")
+        .addHeader("ice-audio-info: bitrate=128;samplerate=44100;channels=2")
+        .addHeader("icy-br:128")
+        .addHeader("icy-description:Rock")
+        .addHeader("icy-genre:riders")
+        .addHeader("icy-name:A2RRock")
+        .addHeader("icy-pub:1")
+        .addHeader("icy-url:http://www.A2Rradio.com")
+        .addHeader("Server: Icecast 2.3.3-kh8")
+        .addHeader("Cache-Control: no-cache")
+        .addHeader("Pragma: no-cache")
+        .addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT")
+        .addHeader("icy-metaint:16000")
+        .setBody("mp3 data"));
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("OK");
+    assertContent("mp3 data", response);
+  }
+
+  @Test public void secureFixedLengthStreaming() throws Exception {
+    testSecureStreamingPost(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void secureChunkedStreaming() throws Exception {
+    testSecureStreamingPost(TransferKind.CHUNKED);
+  }
+
+  /**
+   * Users have reported problems using HTTPS with streaming request bodies.
+   * http://code.google.com/p/android/issues/detail?id=12860
+   */
+  private void testSecureStreamingPost(TransferKind streamingMode) throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("Success!"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(streamingMode.newRequestBody("ABCD"))
+        .build());
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Success!");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getRequestLine()).isEqualTo("POST / HTTP/1.1");
+    if (streamingMode == TransferKind.FIXED_LENGTH) {
+      assertThat(request.getChunkSizes()).isEqualTo(
+          Collections.<Integer>emptyList());
+    } else if (streamingMode == TransferKind.CHUNKED) {
+      assertThat(request.getChunkSizes()).containsExactly(4);
+    }
+    assertThat(request.getBody().readUtf8()).isEqualTo("ABCD");
+  }
+
+  @Test public void authenticateWithPost() throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate.");
+    // Fail auth three times...
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    // ...then succeed the fourth time.
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    client = client.newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build();
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(null, "ABCD"))
+        .build());
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Successful auth!");
+
+    // No authorization header for the first request...
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Authorization")).isNull();
+
+    // ...but the three requests that follow include an authorization header.
+    for (int i = 0; i < 3; i++) {
+      request = server.takeRequest();
+      assertThat(request.getRequestLine()).isEqualTo("POST / HTTP/1.1");
+      assertThat(request.getHeader("Authorization")).isEqualTo(
+          ("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS));
+      assertThat(request.getBody().readUtf8()).isEqualTo("ABCD");
+    }
+  }
+
+  @Test public void authenticateWithGet() throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate.");
+    // Fail auth three times...
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    // ...then succeed the fourth time.
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    client = client.newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Successful auth!");
+
+    // No authorization header for the first request...
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Authorization")).isNull();
+
+    // ...but the three requests that follow requests include an authorization header.
+    for (int i = 0; i < 3; i++) {
+      request = server.takeRequest();
+      assertThat(request.getRequestLine()).isEqualTo("GET / HTTP/1.1");
+      assertThat(request.getHeader("Authorization")).isEqualTo(
+          ("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS));
+    }
+  }
+
+  @Test public void authenticateWithCharset() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
+        .setBody("Please authenticate with UTF-8."));
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate with ISO-8859-1."));
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator(
+        new PasswordAuthentication("username", "mtorhead".toCharArray())));
+    client = client.newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Successful auth!");
+
+    // No authorization header for the first request...
+    RecordedRequest request1 = server.takeRequest();
+    assertThat(request1.getHeader("Authorization")).isNull();
+
+    // UTF-8 encoding for the first credential.
+    RecordedRequest request2 = server.takeRequest();
+    assertThat(request2.getHeader("Authorization")).isEqualTo(
+        "Basic dXNlcm5hbWU6bcO2dG9yaGVhZA==");
+
+    // ISO-8859-1 encoding for the second credential.
+    RecordedRequest request3 = server.takeRequest();
+    assertThat(request3.getHeader("Authorization")).isEqualTo(
+        "Basic dXNlcm5hbWU6bfZ0b3JoZWFk");
+  }
+
+  /** https://code.google.com/p/android/issues/detail?id=74026 */
+  @Test public void authenticateWithGetAndTransparentGzip() throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate.");
+    // Fail auth three times...
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    // ...then succeed the fourth time.
+    MockResponse successfulResponse = new MockResponse()
+        .addHeader("Content-Encoding", "gzip")
+        .setBody(gzip("Successful auth!"));
+    server.enqueue(successfulResponse);
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    client = client.newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Successful auth!");
+
+    // no authorization header for the first request...
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Authorization")).isNull();
+
+    // ...but the three requests that follow requests include an authorization header
+    for (int i = 0; i < 3; i++) {
+      request = server.takeRequest();
+      assertThat(request.getRequestLine()).isEqualTo("GET / HTTP/1.1");
+      assertThat(request.getHeader("Authorization")).isEqualTo(
+          ("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS));
+    }
+  }
+
+  /** https://github.com/square/okhttp/issues/342 */
+  @Test public void authenticateRealmUppercase() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("wWw-aUtHeNtIcAtE: bAsIc rEaLm=\"pRoTeCtEd aReA\"")
+        .setBody("Please authenticate."));
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    client = client.newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Successful auth!");
+  }
+
+  @Test public void redirectedWithChunkedEncoding() throws Exception {
+    testRedirected(TransferKind.CHUNKED, true);
+  }
+
+  @Test public void redirectedWithContentLengthHeader() throws Exception {
+    testRedirected(TransferKind.FIXED_LENGTH, true);
+  }
+
+  @Test public void redirectedWithNoLengthHeaders() throws Exception {
+    testRedirected(TransferKind.END_OF_STREAM, false);
+  }
+
+  private void testRedirected(TransferKind transferKind, boolean reuse) throws Exception {
+    MockResponse mockResponse = new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo");
+    transferKind.setBody(mockResponse, "This page has moved!", 10);
+    server.enqueue(mockResponse);
+    server.enqueue(new MockResponse()
+        .setBody("This is the new location!"));
+
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "This is the new location!");
+
+    RecordedRequest first = server.takeRequest();
+    assertThat(first.getRequestLine()).isEqualTo("GET / HTTP/1.1");
+    RecordedRequest retry = server.takeRequest();
+    assertThat(retry.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    if (reuse) {
+      assertThat(retry.getSequenceNumber()).overridingErrorMessage(
+          "Expected connection reuse").isEqualTo(1);
+    }
+  }
+
+  @Test public void redirectedOnHttps() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse()
+        .setBody("This is the new location!"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "This is the new location!");
+
+    RecordedRequest first = server.takeRequest();
+    assertThat(first.getRequestLine()).isEqualTo("GET / HTTP/1.1");
+    RecordedRequest retry = server.takeRequest();
+    assertThat(retry.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(retry.getSequenceNumber()).overridingErrorMessage(
+        "Expected connection reuse").isEqualTo(1);
+  }
+
+  @Test public void notRedirectedFromHttpsToHttp() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: http://anyhost/foo")
+        .setBody("This page has moved!"));
+
+    client = client.newBuilder()
+        .followSslRedirects(false)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "This page has moved!");
+  }
+
+  @Test public void notRedirectedFromHttpToHttps() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: https://anyhost/foo")
+        .setBody("This page has moved!"));
+
+    client = client.newBuilder()
+        .followSslRedirects(false)
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "This page has moved!");
+  }
+
+  @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
+    server2.enqueue(new MockResponse()
+        .setBody("This is insecure HTTP!"));
+
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.url("/").url())
+        .setBody("This page has moved!"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .followSslRedirects(true)
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertContent("This is insecure HTTP!", response);
+    assertThat(response.handshake()).isNull();
+  }
+
+  @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
+    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server2.enqueue(new MockResponse()
+        .setBody("This is secure HTTPS!"));
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.url("/").url())
+        .setBody("This page has moved!"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .followSslRedirects(true)
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertContent("This is secure HTTPS!", response);
+  }
+
+  @Test public void redirectToAnotherOriginServer() throws Exception {
+    redirectToAnotherOriginServer(false);
+  }
+
+  @Test public void redirectToAnotherOriginServerWithHttps() throws Exception {
+    redirectToAnotherOriginServer(true);
+  }
+
+  private void redirectToAnotherOriginServer(boolean https) throws Exception {
+    if (https) {
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+      server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
+      server2.setProtocolNegotiationEnabled(false);
+      client = client.newBuilder()
+          .sslSocketFactory(
+              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+          .hostnameVerifier(new RecordingHostnameVerifier())
+          .build();
+    }
+
+    server2.enqueue(new MockResponse()
+        .setBody("This is the 2nd server!"));
+    server2.enqueue(new MockResponse()
+        .setBody("This is the 2nd server, again!"));
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.url("/").url().toString())
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse()
+        .setBody("This is the first server again!"));
+
+    Response response = getResponse(newRequest("/"));
+    assertContent("This is the 2nd server!", response);
+    assertThat(response.request().url()).isEqualTo(server2.url("/"));
+
+    // make sure the first server was careful to recycle the connection
+    assertContent("This is the first server again!", getResponse(newRequest(server.url("/"))));
+    assertContent("This is the 2nd server, again!", getResponse(newRequest(server2.url("/"))));
+
+    String server1Host = server.getHostName() + ":" + server.getPort();
+    String server2Host = server2.getHostName() + ":" + server2.getPort();
+    assertThat(server.takeRequest().getHeader("Host")).isEqualTo(server1Host);
+    assertThat(server2.takeRequest().getHeader("Host")).isEqualTo(server2Host);
+    assertThat(server.takeRequest().getSequenceNumber()).overridingErrorMessage(
+        "Expected connection reuse").isEqualTo(1);
+    assertThat(server2.takeRequest().getSequenceNumber()).overridingErrorMessage(
+        "Expected connection reuse").isEqualTo(1);
+  }
+
+  @Test public void redirectWithProxySelector() throws Exception {
+    final List<URI> proxySelectionRequests = new ArrayList<>();
+    client = client.newBuilder()
+        .proxySelector(new ProxySelector() {
+          @Override public List<Proxy> select(URI uri) {
+            proxySelectionRequests.add(uri);
+            MockWebServer proxyServer = (uri.getPort() == server.getPort())
+                ? server
+                : server2;
+            return asList(proxyServer.toProxyAddress());
+          }
+
+          @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
+            throw new AssertionError();
+          }
+        })
+        .build();
+
+    server2.enqueue(new MockResponse()
+        .setBody("This is the 2nd server!"));
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.url("/b").toString())
+        .setBody("This page has moved!"));
+
+    assertContent("This is the 2nd server!", getResponse(newRequest("/a")));
+
+    assertThat(proxySelectionRequests).isEqualTo(
+        asList(server.url("/").url().toURI(), server2.url("/").url().toURI()));
+  }
+
+  @Test public void redirectWithAuthentication() throws Exception {
+    server2.enqueue(new MockResponse()
+        .setBody("Page 2"));
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: " + server2.url("/b")));
+
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret"), null))
+        .build();
+    assertContent("Page 2", getResponse(newRequest("/a")));
+
+    RecordedRequest redirectRequest = server2.takeRequest();
+    assertThat(redirectRequest.getHeader("Authorization")).isNull();
+    assertThat(redirectRequest.getPath()).isEqualTo("/b");
+  }
+
+  @Test public void response300MultipleChoiceWithPost() throws Exception {
+    // Chrome doesn't follow the redirect, but Firefox and the RI both do
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MULT_CHOICE, TransferKind.END_OF_STREAM);
+  }
+
+  @Test public void response301MovedPermanentlyWithPost() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_PERM, TransferKind.END_OF_STREAM);
+  }
+
+  @Test public void response302MovedTemporarilyWithPost() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.END_OF_STREAM);
+  }
+
+  @Test public void response303SeeOtherWithPost() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_SEE_OTHER, TransferKind.END_OF_STREAM);
+  }
+
+  @Test public void postRedirectToGetWithChunkedRequest() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.CHUNKED);
+  }
+
+  @Test public void postRedirectToGetWithStreamedRequest() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.FIXED_LENGTH);
+  }
+
+  private void testResponseRedirectedWithPost(int redirectCode, TransferKind transferKind)
+      throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(redirectCode)
+        .addHeader("Location: /page2")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse()
+        .setBody("Page 2"));
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/page1"))
+        .post(transferKind.newRequestBody("ABCD"))
+        .build());
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Page 2");
+
+    RecordedRequest page1 = server.takeRequest();
+    assertThat(page1.getRequestLine()).isEqualTo("POST /page1 HTTP/1.1");
+    assertThat(page1.getBody().readUtf8()).isEqualTo("ABCD");
+
+    RecordedRequest page2 = server.takeRequest();
+    assertThat(page2.getRequestLine()).isEqualTo("GET /page2 HTTP/1.1");
+  }
+
+  @Test public void redirectedPostStripsRequestBodyHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /page2"));
+    server.enqueue(new MockResponse()
+        .setBody("Page 2"));
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/page1"))
+        .post(RequestBody.create(MediaType.get("text/plain; charset=utf-8"), "ABCD"))
+        .header("Transfer-Encoding", "identity")
+        .build());
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Page 2");
+
+    assertThat(server.takeRequest().getRequestLine()).isEqualTo(
+        "POST /page1 HTTP/1.1");
+
+    RecordedRequest page2 = server.takeRequest();
+    assertThat(page2.getRequestLine()).isEqualTo("GET /page2 HTTP/1.1");
+    assertThat(page2.getHeader("Content-Length")).isNull();
+    assertThat(page2.getHeader("Content-Type")).isNull();
+    assertThat(page2.getHeader("Transfer-Encoding")).isNull();
+  }
+
+  @Test public void response305UseProxy() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_USE_PROXY)
+        .addHeader("Location: " + server.url("/").url())
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse()
+        .setBody("Proxy Response"));
+
+    Response response = getResponse(newRequest("/foo"));
+    // Fails on the RI, which gets "Proxy Response".
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "This page has moved!");
+
+    RecordedRequest page1 = server.takeRequest();
+    assertThat(page1.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+
+  @Test public void response307WithGet() throws Exception {
+    testRedirect(true, "GET");
+  }
+
+  @Test public void response307WithHead() throws Exception {
+    testRedirect(true, "HEAD");
+  }
+
+  @Test public void response307WithOptions() throws Exception {
+    testRedirect(true, "OPTIONS");
+  }
+
+  @Test public void response307WithPost() throws Exception {
+    testRedirect(true, "POST");
+  }
+
+  @Test public void response308WithGet() throws Exception {
+    testRedirect(false, "GET");
+  }
+
+  @Test public void response308WithHead() throws Exception {
+    testRedirect(false, "HEAD");
+  }
+
+  @Test public void response308WithOptions() throws Exception {
+    testRedirect(false, "OPTIONS");
+  }
+
+  @Test public void response308WithPost() throws Exception {
+    testRedirect(false, "POST");
+  }
+
+  private void testRedirect(boolean temporary, String method) throws Exception {
+    MockResponse response1 = new MockResponse()
+        .setResponseCode(temporary ? HTTP_TEMP_REDIRECT : HTTP_PERM_REDIRECT)
+        .addHeader("Location: /page2");
+    if (!method.equals("HEAD")) {
+      response1.setBody("This page has moved!");
+    }
+    server.enqueue(response1);
+    server.enqueue(new MockResponse()
+        .setBody("Page 2"));
+
+    Request.Builder requestBuilder = new Request.Builder()
+        .url(server.url("/page1"));
+    if (method.equals("POST")) {
+      requestBuilder.post(RequestBody.create(null, "ABCD"));
+    } else {
+      requestBuilder.method(method, null);
+    }
+
+    Response response = getResponse(requestBuilder.build());
+    String responseString = readAscii(response.body().byteStream(), Integer.MAX_VALUE);
+
+    RecordedRequest page1 = server.takeRequest();
+    assertThat(page1.getRequestLine()).isEqualTo((method + " /page1 HTTP/1.1"));
+
+    if (method.equals("GET")) {
+      assertThat(responseString).isEqualTo("Page 2");
+    } else if (method.equals("HEAD")) {
+      assertThat(responseString).isEqualTo("");
+    } else {
+      // Methods other than GET/HEAD shouldn't follow the redirect.
+      if (method.equals("POST")) {
+        assertThat(page1.getBody().readUtf8()).isEqualTo("ABCD");
+      }
+      assertThat(server.getRequestCount()).isEqualTo(1);
+      assertThat(responseString).isEqualTo("This page has moved!");
+      return;
+    }
+
+    // GET/HEAD requests should have followed the redirect with the same method.
+    assertThat(server.getRequestCount()).isEqualTo(2);
+    RecordedRequest page2 = server.takeRequest();
+    assertThat(page2.getRequestLine()).isEqualTo((method + " /page2 HTTP/1.1"));
+  }
+
+  @Test public void follow20Redirects() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.enqueue(new MockResponse()
+        .setBody("Success!"));
+
+    Response response = getResponse(newRequest("/0"));
+    assertContent("Success!", response);
+    assertThat(response.request().url()).isEqualTo(server.url("/20"));
+  }
+
+  @Test public void doesNotFollow21Redirects() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+
+    try {
+      getResponse(newRequest("/0"));
+      fail();
+    } catch (ProtocolException expected) {
+      assertThat(expected.getMessage()).isEqualTo(
+          "Too many follow-up requests: 21");
+    }
+  }
+
+  @Test public void httpsWithCustomTrustManager() throws Exception {
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+    RecordingTrustManager trustManager =
+        new RecordingTrustManager(handshakeCertificates.trustManager());
+    SSLContext sslContext = Platform.get().newSSLContext();
+    sslContext.init(null, new TrustManager[] {trustManager}, null);
+
+    client = client.newBuilder()
+        .hostnameVerifier(hostnameVerifier)
+        .sslSocketFactory(sslContext.getSocketFactory(), trustManager)
+        .build();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setBody("GHI"));
+
+    assertContent("ABC", getResponse(newRequest("/")));
+    assertContent("DEF", getResponse(newRequest("/")));
+    assertContent("GHI", getResponse(newRequest("/")));
+
+    assertThat(hostnameVerifier.calls).isEqualTo(
+        asList("verify " + server.getHostName()));
+    assertThat(trustManager.calls).isEqualTo(
+        asList("checkServerTrusted [CN=localhost 1]"));
+  }
+
+  @Test public void getClientRequestTimeout() throws Exception {
+    enqueueClientRequestTimeoutResponses();
+
+    Response response = getResponse(newRequest("/"));
+
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Body");
+  }
+
+  private void enqueueClientRequestTimeoutResponses() {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(HttpURLConnection.HTTP_CLIENT_TIMEOUT)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse()
+        .setBody("Body"));
+  }
+
+  @Test public void bufferedBodyWithClientRequestTimeout() throws Exception {
+    enqueueClientRequestTimeoutResponses();
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(null, "Hello"))
+        .build());
+
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Body");
+
+    RecordedRequest request1 = server.takeRequest();
+    assertThat(request1.getBody().readUtf8()).isEqualTo("Hello");
+
+    RecordedRequest request2 = server.takeRequest();
+    assertThat(request2.getBody().readUtf8()).isEqualTo("Hello");
+  }
+
+  @Test public void streamedBodyWithClientRequestTimeout() throws Exception {
+    enqueueClientRequestTimeoutResponses();
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(TransferKind.CHUNKED.newRequestBody("Hello"))
+        .build());
+
+    assertThat(response.code()).isEqualTo(200);
+    assertContent("Body", response);
+    response.close();
+    assertThat(server.getRequestCount()).isEqualTo(2);
+  }
+
+  @Test public void readTimeouts() throws IOException {
+    // This relies on the fact that MockWebServer doesn't close the
+    // connection after a response has been sent. This causes the client to
+    // try to read more bytes than are sent, which results in a timeout.
+    server.enqueue(new MockResponse()
+        .setBody("ABC")
+        .clearHeaders()
+        .addHeader("Content-Length: 4"));
+    server.enqueue(new MockResponse()
+        .setBody("unused")); // to keep the server alive
+
+    Response response = getResponse(newRequest("/"));
+    BufferedSource in = response.body().source();
+    in.timeout().timeout(1000, MILLISECONDS);
+    assertThat(in.readByte()).isEqualTo((byte) 'A');
+    assertThat(in.readByte()).isEqualTo((byte) 'B');
+    assertThat(in.readByte()).isEqualTo((byte) 'C');
+    try {
+      in.readByte(); // If Content-Length was accurate, this would return -1 immediately.
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+    in.close();
+  }
+
+  /** Confirm that an unacknowledged write times out. */
+  @Test public void writeTimeouts() throws IOException {
+    MockWebServer server = new MockWebServer();
+    // Sockets on some platforms can have large buffers that mean writes do not block when
+    // required. These socket factories explicitly set the buffer sizes on sockets created.
+    final int SOCKET_BUFFER_SIZE = 4 * 1024;
+    server.setServerSocketFactory(
+        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
+          @Override
+          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
+              throws IOException {
+            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return serverSocket;
+          }
+        });
+    client = client.newBuilder()
+        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+          @Override protected Socket configureSocket(Socket socket) throws IOException {
+            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+            return socket;
+          }
+        })
+        .writeTimeout(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    server.start();
+    server.enqueue(new MockResponse()
+        .throttleBody(1, 1, TimeUnit.SECONDS)); // Prevent the server from reading!
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(new RequestBody() {
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
+            sink.write(data);
+          }
+        })
+        .build();
+    try {
+      getResponse(request);
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+  }
+
+  @Test public void setChunkedEncodingAsRequestProperty() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .header("Transfer-encoding", "chunked")
+        .post(TransferKind.CHUNKED.newRequestBody("ABC"))
+        .build());
+    assertThat(response.code()).isEqualTo(200);
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("ABC");
+  }
+
+  @Test public void connectionCloseInRequest() throws Exception {
+    server.enqueue(new MockResponse()); // Server doesn't honor the connection: close header!
+    server.enqueue(new MockResponse());
+
+    Response a = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .header("Connection", "close")
+        .build());
+    assertThat(a.code()).isEqualTo(200);
+
+    Response b = getResponse(newRequest("/"));
+    assertThat(b.code()).isEqualTo(200);
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).overridingErrorMessage(
+        "When connection: close is used, each request should get its own connection").isEqualTo(
+        (long) 0);
+  }
+
+  @Test public void connectionCloseInResponse() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Connection: close"));
+    server.enqueue(new MockResponse());
+
+    Response a = getResponse(newRequest("/"));
+    assertThat(a.code()).isEqualTo(200);
+
+    Response b = getResponse(newRequest("/"));
+    assertThat(b.code()).isEqualTo(200);
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).overridingErrorMessage(
+        "When connection: close is used, each request should get its own connection").isEqualTo(
+        (long) 0);
+  }
+
+  @Test public void connectionCloseWithRedirect() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .addHeader("Connection: close"));
+    server.enqueue(new MockResponse()
+        .setBody("This is the new location!"));
+
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "This is the new location!");
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).overridingErrorMessage(
+        "When connection: close is used, each request should get its own connection").isEqualTo(
+        (long) 0);
+  }
+
+  /**
+   * Retry redirects if the socket is closed.
+   * https://code.google.com/p/android/issues/detail?id=41576
+   */
+  @Test public void sameConnectionRedirectAndReuse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse()
+        .setBody("This is the new page!"));
+
+    assertContent("This is the new page!", getResponse(newRequest("/")));
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+  }
+
+  @Test public void responseCodeDisagreesWithHeaders() {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
+        .setBody("This body is not allowed!"));
+
+    try {
+      getResponse(newRequest("/"));
+      fail();
+    } catch (IOException expected) {
+      assertThat(expected.getMessage()).isEqualTo(
+          "HTTP 204 had non-zero Content-Length: 25");
+    }
+  }
+
+  @Test public void singleByteReadIsSigned() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer()
+            .writeByte(-2)
+            .writeByte(-1)));
+
+    Response response = getResponse(newRequest("/"));
+    InputStream in = response.body().byteStream();
+    assertThat(in.read()).isEqualTo(254);
+    assertThat(in.read()).isEqualTo(255);
+    assertThat(in.read()).isEqualTo(-1);
+  }
+
+  @Test public void flushAfterStreamTransmittedWithChunkedEncoding() throws IOException {
+    testFlushAfterStreamTransmitted(TransferKind.CHUNKED);
+  }
+
+  @Test public void flushAfterStreamTransmittedWithFixedLength() throws IOException {
+    testFlushAfterStreamTransmitted(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void flushAfterStreamTransmittedWithNoLengthHeaders() throws IOException {
+    testFlushAfterStreamTransmitted(TransferKind.END_OF_STREAM);
+  }
+
+  /**
+   * We explicitly permit apps to close the upload stream even after it has been transmitted.  We
+   * also permit flush so that buffered streams can do a no-op flush when they are closed.
+   * http://b/3038470
+   */
+  private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    AtomicReference<BufferedSink> sinkReference = new AtomicReference<>();
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(new ForwardingRequestBody(transferKind.newRequestBody("def")) {
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sinkReference.set(sink);
+            super.writeTo(sink);
+          }
+        })
+        .build());
+
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "abc");
+
+    try {
+      sinkReference.get().flush();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      sinkReference.get().write("ghi".getBytes(UTF_8));
+      sinkReference.get().emit();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void getHeadersThrows() {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(DISCONNECT_AT_START));
+
+    try {
+      getResponse(newRequest("/"));
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void dnsFailureThrowsIOException() {
+    client = client.newBuilder()
+        .dns(new FakeDns())
+        .build();
+    try {
+      getResponse(newRequest(HttpUrl.get("http://host.unlikelytld")));
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
+    try {
+      getResponse(newRequest(HttpUrl.get("http://./foo.html")));
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void getKeepAlive() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    // The request should work once and then fail.
+    Response connection1 = getResponse(newRequest("/"));
+    BufferedSource source1 = connection1.body().source();
+    source1.timeout().timeout(100, TimeUnit.MILLISECONDS);
+    assertThat(readAscii(source1.inputStream(), Integer.MAX_VALUE)).isEqualTo(
+        "ABC");
+    server.shutdown();
+    try {
+      getResponse(newRequest("/"));
+      fail();
+    } catch (ConnectException expected) {
+    }
+  }
+
+  /** http://code.google.com/p/android/issues/detail?id=14562 */
+  @Test public void readAfterLastByte() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABC")
+        .clearHeaders()
+        .addHeader("Connection: close")
+        .setSocketPolicy(DISCONNECT_AT_END));
+
+    Response response = getResponse(newRequest("/"));
+    InputStream in = response.body().byteStream();
+    assertThat(readAscii(in, 3)).isEqualTo("ABC");
+    assertThat(in.read()).isEqualTo(-1);
+    // throws IOException in Gingerbread.
+    assertThat(in.read()).isEqualTo(-1);
+  }
+
+  @Test public void getOutputStreamOnGetFails() {
+    try {
+      new Request.Builder()
+          .url(server.url("/"))
+          .method("GET", RequestBody.create(null, "abc"))
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void clientSendsContentLength() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(null, "ABC"))
+        .build());
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "A");
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Content-Length")).isEqualTo("3");
+    response.body().close();
+  }
+
+  @Test public void getContentLengthConnects() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.body().contentLength()).isEqualTo(3L);
+    response.body().close();
+  }
+
+  @Test public void getContentTypeConnects() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Type: text/plain")
+        .setBody("ABC"));
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.body().contentType()).isEqualTo(
+        MediaType.get("text/plain"));
+    response.body().close();
+  }
+
+  @Test public void getContentEncodingConnects() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Encoding: identity")
+        .setBody("ABC"));
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.header("Content-Encoding")).isEqualTo("identity");
+    response.body().close();
+  }
+
+  @Test public void urlContainsQueryButNoPath() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    HttpUrl url = server.url("?query");
+    Response response = getResponse(newRequest(url));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "A");
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getRequestLine()).isEqualTo("GET /?query HTTP/1.1");
+  }
+
+  @Test public void doOutputForMethodThatDoesntSupportOutput() {
+    try {
+      new Request.Builder()
+          .url(server.url("/"))
+          .method("HEAD", RequestBody.create(null, ""))
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  // http://code.google.com/p/android/issues/detail?id=20442
+  @Test public void inputStreamAvailableWithChunkedEncoding() throws Exception {
+    testInputStreamAvailable(TransferKind.CHUNKED);
+  }
+
+  @Test public void inputStreamAvailableWithContentLengthHeader() throws Exception {
+    testInputStreamAvailable(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void inputStreamAvailableWithNoLengthHeaders() throws Exception {
+    testInputStreamAvailable(TransferKind.END_OF_STREAM);
+  }
+
+  private void testInputStreamAvailable(TransferKind transferKind) throws IOException {
+    String body = "ABCDEFGH";
+    MockResponse mockResponse = new MockResponse();
+    transferKind.setBody(mockResponse, body, 4);
+    server.enqueue(mockResponse);
+    Response response = getResponse(newRequest("/"));
+    InputStream in = response.body().byteStream();
+    for (int i = 0; i < body.length(); i++) {
+      assertThat(in.available()).isGreaterThanOrEqualTo(0);
+      assertThat(in.read()).isEqualTo(body.charAt(i));
+    }
+    assertThat(in.available()).isEqualTo(0);
+    assertThat(in.read()).isEqualTo(-1);
+  }
+
+  @Test public void postFailsWithBufferedRequestForSmallRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 1024);
+  }
+
+  @Test public void postFailsWithBufferedRequestForLargeRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 16384);
+  }
+
+  @Test public void postFailsWithChunkedRequestForSmallRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 1024);
+  }
+
+  @Test public void postFailsWithChunkedRequestForLargeRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 16384);
+  }
+
+  @Test public void postFailsWithFixedLengthRequestForSmallRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 1024);
+  }
+
+  @Test public void postFailsWithFixedLengthRequestForLargeRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 16384);
+  }
+
+  private void reusedConnectionFailsWithPost(TransferKind transferKind, int requestSize)
+      throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .setSocketPolicy(DISCONNECT_AT_END));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    assertContent("A", getResponse(newRequest("/a")));
+
+    // Give the server time to disconnect.
+    Thread.sleep(500);
+
+    // If the request body is larger than OkHttp's replay buffer, the failure may still occur.
+    char[] requestBodyChars = new char[requestSize];
+    Arrays.fill(requestBodyChars, 'x');
+    String requestBody = new String(requestBodyChars);
+
+    for (int j = 0; j < 2; j++) {
+      try {
+        Response response = getResponse(new Request.Builder()
+            .url(server.url("/b"))
+            .post(transferKind.newRequestBody(requestBody))
+            .build());
+        assertContent("B", response);
+        break;
+      } catch (IOException socketException) {
+        // If there's a socket exception, this must have a streamed request body.
+        assertThat(j).isEqualTo(0);
+        assertThat(transferKind).isIn(TransferKind.CHUNKED, TransferKind.FIXED_LENGTH);
+      }
+    }
+
+    RecordedRequest requestA = server.takeRequest();
+    assertThat(requestA.getPath()).isEqualTo("/a");
+    RecordedRequest requestB = server.takeRequest();
+    assertThat(requestB.getPath()).isEqualTo("/b");
+    assertThat(requestB.getBody().readUtf8()).isEqualTo(requestBody);
+  }
+
+  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse()
+        .setBody("def"));
+
+    // Seed the connection pool so we have something that can fail.
+    assertContent("abc", getResponse(newRequest("/")));
+
+    Response post = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(null, "body!"))
+        .build());
+    assertContent("def", post);
+
+    RecordedRequest get = server.takeRequest();
+    assertThat(get.getSequenceNumber()).isEqualTo(0);
+
+    RecordedRequest post1 = server.takeRequest();
+    assertThat(post1.getBody().readUtf8()).isEqualTo("body!");
+    assertThat(post1.getSequenceNumber()).isEqualTo(1);
+
+    RecordedRequest post2 = server.takeRequest();
+    assertThat(post2.getBody().readUtf8()).isEqualTo("body!");
+    assertThat(post2.getSequenceNumber()).isEqualTo(0);
+  }
+
+  @Test public void fullyBufferedPostIsTooShort() {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    RequestBody requestBody = new RequestBody() {
+      @Override public @Nullable MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 4L;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("abc");
+      }
+    };
+    try {
+      getResponse(new Request.Builder()
+          .url(server.url("/b"))
+          .post(requestBody)
+          .build());
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void fullyBufferedPostIsTooLong() {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    RequestBody requestBody = new RequestBody() {
+      @Override public @Nullable MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 3L;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("abcd");
+      }
+    };
+    try {
+      getResponse(new Request.Builder()
+          .url(server.url("/b"))
+          .post(requestBody)
+          .build());
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test @Ignore public void testPooledConnectionsDetectHttp10() {
+    // TODO: write a test that shows pooled connections detect HTTP/1.0 (vs. HTTP/1.1)
+    fail("TODO");
+  }
+
+  @Test @Ignore public void postBodiesRetransmittedOnAuthProblems() {
+    fail("TODO");
+  }
+
+  @Test @Ignore public void cookiesAndTrailers() {
+    // Do cookie headers get processed too many times?
+    fail("TODO");
+  }
+
+  @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("body"));
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .header("B", "")
+        .build());
+    assertContent("body", response);
+    assertThat(response.request().header("B")).isEqualTo("");
+  }
+
+  @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("A:")
+        .setBody("body"));
+    Response response = getResponse(newRequest("/"));
+    assertContent("body", response);
+    assertThat(response.header("A")).isEqualTo("");
+  }
+
+  @Test public void emptyRequestHeaderNameIsStrict() {
+    try {
+      new Request.Builder()
+          .url(server.url("/"))
+          .header("", "A")
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void emptyResponseHeaderNameIsLenient() throws Exception {
+    Headers.Builder headers = new Headers.Builder();
+    InternalKtKt.addHeaderLenient(headers, ":A");
+    server.enqueue(new MockResponse()
+        .setHeaders(headers.build())
+        .setBody("body"));
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.header("")).isEqualTo("A");
+    response.body().close();
+  }
+
+  @Test public void requestHeaderValidationIsStrict() {
+    try {
+      new Request.Builder()
+          .addHeader("a\tb", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Request.Builder()
+          .addHeader("Name", "c\u007fd");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Request.Builder()
+          .addHeader("", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Request.Builder()
+          .addHeader("\ud83c\udf69", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Request.Builder()
+          .addHeader("Name", "\u2615\ufe0f");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void responseHeaderParsingIsLenient() throws Exception {
+    Headers.Builder headersBuilder = new Headers.Builder();
+    headersBuilder.add("Content-Length", "0");
+    addHeaderLenient(headersBuilder, "a\tb: c\u007fd");
+    addHeaderLenient(headersBuilder, ": ef");
+    addHeaderLenient(headersBuilder, "\ud83c\udf69: \u2615\ufe0f");
+    Headers headers = headersBuilder.build();
+    server.enqueue(new MockResponse()
+        .setHeaders(headers));
+
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.header("a\tb")).isEqualTo("c\u007fd");
+    assertThat(response.header("\ud83c\udf69")).isEqualTo("\u2615\ufe0f");
+    assertThat(response.header("")).isEqualTo("ef");
+  }
+
+  @Test @Ignore public void deflateCompression() {
+    fail("TODO");
+  }
+
+  @Test @Ignore public void postBodiesRetransmittedOnIpAddressProblems() {
+    fail("TODO");
+  }
+
+  @Test @Ignore public void pooledConnectionProblemsNotReportedToProxySelector() {
+    fail("TODO");
+  }
+
+  @Test public void customBasicAuthenticator() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate."));
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    String credential = Credentials.basic("jesse", "peanutbutter");
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential, null);
+    client = client.newBuilder()
+        .authenticator(authenticator)
+        .build();
+    assertContent("A", getResponse(newRequest("/private")));
+
+    assertThat(server.takeRequest().getHeader("Authorization")).isNull();
+    assertThat(server.takeRequest().getHeader("Authorization")).isEqualTo(
+        credential);
+
+    assertThat(authenticator.onlyRoute().proxy()).isEqualTo(Proxy.NO_PROXY);
+    Response response = authenticator.onlyResponse();
+    assertThat(response.request().url().url().getPath()).isEqualTo("/private");
+    assertThat(response.challenges()).isEqualTo(
+        asList(new Challenge("Basic", "protected area")));
+  }
+
+  @Test public void customTokenAuthenticator() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
+        .setBody("Please authenticate."));
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    RecordingOkAuthenticator authenticator
+        = new RecordingOkAuthenticator("oauthed abc123", "Bearer");
+    client = client.newBuilder()
+        .authenticator(authenticator)
+        .build();
+    assertContent("A", getResponse(newRequest("/private")));
+
+    assertThat(server.takeRequest().getHeader("Authorization")).isNull();
+    assertThat(server.takeRequest().getHeader("Authorization")).isEqualTo(
+        "oauthed abc123");
+
+    Response response = authenticator.onlyResponse();
+    assertThat(response.request().url().url().getPath()).isEqualTo("/private");
+    assertThat(response.challenges()).isEqualTo(
+        asList(new Challenge("Bearer", "oauthed")));
+  }
+
+  @Test public void authenticateCallsTrackedAsRedirects() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\""));
+    server.enqueue(new MockResponse()
+        .setBody("c"));
+
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
+        Credentials.basic("jesse", "peanutbutter"), "Basic");
+    client = client.newBuilder()
+        .authenticator(authenticator)
+        .build();
+    assertContent("c", getResponse(newRequest("/a")));
+
+    Response challengeResponse = authenticator.responses.get(0);
+    assertThat(challengeResponse.request().url().url().getPath()).isEqualTo(
+        "/b");
+
+    Response redirectedBy = challengeResponse.priorResponse();
+    assertThat(redirectedBy.request().url().url().getPath()).isEqualTo("/a");
+  }
+
+  @Test public void attemptAuthorization20Times() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(401));
+    }
+    server.enqueue(new MockResponse()
+        .setBody("Success!"));
+
+    String credential = Credentials.basic("jesse", "peanutbutter");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential, null))
+        .build();
+
+    Response response = getResponse(newRequest("/0"));
+    assertContent("Success!", response);
+  }
+
+  @Test public void doesNotAttemptAuthorization21Times() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(401));
+    }
+
+    String credential = Credentials.basic("jesse", "peanutbutter");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential, null))
+        .build();
+
+    try {
+      getResponse(newRequest("/"));
+      fail();
+    } catch (ProtocolException expected) {
+      assertThat(expected.getMessage()).isEqualTo(
+          "Too many follow-up requests: 21");
+    }
+  }
+
+  @Test public void setsNegotiatedProtocolHeader_HTTP_2() throws Exception {
+    platform.assumeHttp2Support();
+
+    setsNegotiatedProtocolHeader(Protocol.HTTP_2);
+  }
+
+  private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException {
+    enableProtocol(protocol);
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+    client = client.newBuilder()
+        .protocols(asList(protocol, Protocol.HTTP_1_1))
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.protocol()).isEqualTo(protocol);
+    assertContent("A", response);
+  }
+
+  @Test public void http10SelectedProtocol() throws IOException {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.0 200 OK"));
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_1_0);
+  }
+
+  @Test public void http11SelectedProtocol() throws IOException {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 200 OK"));
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_1_1);
+  }
+
+  /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
+  @Test public void zeroLengthPost() throws Exception {
+    zeroLengthPayload("POST");
+  }
+
+  @Test public void zeroLengthPost_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    zeroLengthPost();
+  }
+
+  /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
+  @Test public void zeroLengthPut() throws Exception {
+    zeroLengthPayload("PUT");
+  }
+
+  @Test public void zeroLengthPut_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    zeroLengthPut();
+  }
+
+  private void zeroLengthPayload(String method) throws Exception {
+    server.enqueue(new MockResponse());
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .method(method, RequestBody.create(null, ""))
+        .build());
+    assertContent("", response);
+    RecordedRequest zeroLengthPayload = server.takeRequest();
+    assertThat(zeroLengthPayload.getMethod()).isEqualTo(method);
+    assertThat(zeroLengthPayload.getHeader("content-length")).isEqualTo("0");
+    assertThat(zeroLengthPayload.getBodySize()).isEqualTo(0L);
+  }
+
+  @Test public void setProtocols() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+    client = client.newBuilder()
+        .protocols(asList(Protocol.HTTP_1_1))
+        .build();
+    assertContent("A", getResponse(newRequest("/")));
+  }
+
+  @Test public void setProtocolsWithoutHttp11() {
+    try {
+      new OkHttpClient.Builder()
+          .protocols(asList(Protocol.HTTP_2));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setProtocolsWithNull() {
+    try {
+      new OkHttpClient.Builder()
+          .protocols(asList(Protocol.HTTP_1_1, null));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void veryLargeFixedLengthRequest() throws Exception {
+    server.setBodyLimit(0);
+    server.enqueue(new MockResponse());
+
+    long contentLength = Integer.MAX_VALUE + 1L;
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(new RequestBody() {
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
+
+          @Override public long contentLength() {
+            return contentLength;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            byte[] buffer = new byte[1024 * 1024];
+            for (long bytesWritten = 0; bytesWritten < contentLength; ) {
+              int byteCount = (int) Math.min(buffer.length, contentLength - bytesWritten);
+              bytesWritten += byteCount;
+              sink.write(buffer, 0, byteCount);
+            }
+          }
+        })
+        .build());
+
+    assertContent("", response);
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Content-Length")).isEqualTo(
+        Long.toString(contentLength));
+  }
+
+  @Test public void testNoSslFallback() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false /* tunnelProxy */);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse()
+        .setBody("Response that would have needed fallbacks"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .build();
+    try {
+      getResponse(newRequest("/"));
+      fail();
+    } catch (SSLProtocolException expected) {
+      // RI response to the FAIL_HANDSHAKE
+    } catch (SSLHandshakeException expected) {
+      // Android's response to the FAIL_HANDSHAKE
+    } catch (SSLException expected) {
+      // JDK 1.9 response to the FAIL_HANDSHAKE
+      // javax.net.ssl.SSLException: Unexpected handshake message: client_hello
+    } catch (SocketException expected) {
+      // Conscrypt's response to the FAIL_HANDSHAKE
+    }
+  }
+
+  /**
+   * We had a bug where we attempted to gunzip responses that didn't have a body. This only came up
+   * with 304s since that response code can include headers (like "Content-Encoding") without any
+   * content to go along with it. https://github.com/square/okhttp/issues/358
+   */
+  @Test public void noTransparentGzipFor304NotModified() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+        .setBody("b"));
+
+    Response response1 = getResponse(newRequest("/"));
+    assertThat(response1.code()).isEqualTo(
+        (long) HttpURLConnection.HTTP_NOT_MODIFIED);
+    assertContent("", response1);
+
+    Response response2 = getResponse(newRequest("/"));
+    assertThat(response2.code()).isEqualTo(HttpURLConnection.HTTP_OK);
+    assertContent("b", response2);
+
+    RecordedRequest requestA = server.takeRequest();
+    assertThat(requestA.getSequenceNumber()).isEqualTo(0);
+
+    RecordedRequest requestB = server.takeRequest();
+    assertThat(requestB.getSequenceNumber()).isEqualTo(1);
+  }
+
+  @Test public void nullSSLSocketFactory_throws() {
+    try {
+      client.newBuilder().sslSocketFactory(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  /**
+   * We had a bug where we weren't closing Gzip streams on redirects.
+   * https://github.com/square/okhttp/issues/441
+   */
+  @Test public void gzipWithRedirectAndConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("Moved! Moved! Moved!")));
+    server.enqueue(new MockResponse()
+        .setBody("This is the new page!"));
+
+    Response response = getResponse(newRequest("/"));
+    assertContent("This is the new page!", response);
+
+    RecordedRequest requestA = server.takeRequest();
+    assertThat(requestA.getSequenceNumber()).isEqualTo(0);
+
+    RecordedRequest requestB = server.takeRequest();
+    assertThat(requestB.getSequenceNumber()).isEqualTo(1);
+  }
+
+  /**
+   * The RFC is unclear in this regard as it only specifies that this should invalidate the cache
+   * entry (if any).
+   */
+  @Test public void bodyPermittedOnDelete() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .delete(RequestBody.create(null, "BODY"))
+        .build());
+    assertThat(response.code()).isEqualTo(200);
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getMethod()).isEqualTo("DELETE");
+    assertThat(request.getBody().readUtf8()).isEqualTo("BODY");
+  }
+
+  @Test public void userAgentDefaultsToOkHttpVersion() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    assertContent("abc", getResponse(newRequest("/")));
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("User-Agent")).isEqualTo(Version.userAgent);
+  }
+
+  @Test public void urlWithSpaceInHost() {
+    try {
+      HttpUrl.get("http://and roid.com/");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void urlWithSpaceInHostViaHttpProxy() {
+    try {
+      HttpUrl.get("http://and roid.com/");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void urlHostWithNul() {
+    try {
+      HttpUrl.get("http://host\u0000/");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void urlRedirectToHostWithNul() throws Exception {
+    String redirectUrl = "http://host\u0000/";
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeaderLenient("Location", redirectUrl));
+
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.code()).isEqualTo(302);
+    assertThat(response.header("Location")).isEqualTo(redirectUrl);
+  }
+
+  @Test public void urlWithBadAsciiHost() {
+    try {
+      HttpUrl.get("http://host\u0001/");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setSslSocketFactoryFailsOnJdk9() {
+    platform.assumeJdk9();
+
+    try {
+      client.newBuilder()
+          .sslSocketFactory(handshakeCertificates.sslSocketFactory());
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
+  @Test public void unexpectedExceptionSync() throws Exception {
+    client = client.newBuilder()
+        .dns(hostname -> {
+          throw new RuntimeException("boom!");
+        })
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    try {
+      getResponse(newRequest("/"));
+      fail();
+    } catch (RuntimeException expected) {
+      assertThat(expected.getMessage()).isEqualTo("boom!");
+    }
+  }
+
+  @Test public void streamedBodyIsRetriedOnHttp2Shutdown() throws Exception {
+    platform.assumeHttp2Support();
+
+    enableProtocol(Protocol.HTTP_2);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setBody("abc"));
+    server.enqueue(new MockResponse()
+        .setBody("def"));
+
+    // Send a separate request which will trigger a GOAWAY frame on the healthy connection.
+    Response response = getResponse(newRequest("/"));
+    assertContent("abc", response);
+
+    // Ensure the GOAWAY frame has time to be read and processed.
+    Thread.sleep(500);
+
+    assertContent("def", getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(null, "123"))
+        .build()));
+
+    RecordedRequest request1 = server.takeRequest();
+    assertThat(request1.getSequenceNumber()).isEqualTo(0);
+
+    RecordedRequest request2 = server.takeRequest();
+    assertThat(request2.getBody().readUtf8()).isEqualTo("123");
+    assertThat(request2.getSequenceNumber()).isEqualTo(0);
+  }
+
+  @Test public void authenticateNoConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Connection: close")
+        .setResponseCode(401)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+
+    Authenticator.setDefault(new RecordingAuthenticator(null));
+    client = client.newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.code()).isEqualTo(401);
+  }
+
+  private Request newRequest(String s) {
+    return newRequest(server.url(s));
+  }
+
+  private Request newRequest(HttpUrl url) {
+    return new Request.Builder()
+        .url(url)
+        .build();
+  }
+
+  private Response getResponse(Request request) throws IOException {
+    return client.newCall(request).execute();
+  }
+
+  /** Returns a gzipped copy of {@code bytes}. */
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink gzipSink = Okio.buffer(new GzipSink(result));
+    gzipSink.writeUtf8(data);
+    gzipSink.close();
+    return result;
+  }
+
+  private void assertContent(String expected, Response response, int limit)
+      throws IOException {
+    assertThat(readAscii(response.body().byteStream(), limit)).isEqualTo(
+        expected);
+  }
+
+  private void assertContent(String expected, Response response) throws IOException {
+    assertContent(expected, response, Integer.MAX_VALUE);
+  }
+
+  private Set<String> newSet(String... elements) {
+    return new LinkedHashSet<>(asList(elements));
+  }
+
+  enum TransferKind {
+    CHUNKED {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setChunkedBody(content, chunkSize);
+      }
+
+      @Override RequestBody newRequestBody(String body) {
+        return new RequestBody() {
+          @Override public long contentLength() {
+            return -1L;
+          }
+
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.writeUtf8(body);
+          }
+        };
+      }
+    },
+    FIXED_LENGTH {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+      }
+
+      @Override RequestBody newRequestBody(String body) {
+        return new RequestBody() {
+          @Override public long contentLength() {
+            return Utf8.size(body);
+          }
+
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.writeUtf8(body);
+          }
+        };
+      }
+    },
+    END_OF_STREAM {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+        response.setSocketPolicy(DISCONNECT_AT_END);
+        response.removeHeader("Content-Length");
+      }
+
+      @Override RequestBody newRequestBody(String body) {
+        throw new AssumptionViolatedException("END_OF_STREAM not implemented for requests");
+      }
+    };
+
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
+
+    abstract RequestBody newRequestBody(String body);
+
+    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
+    }
+  }
+
+  enum ProxyConfig {
+    NO_PROXY() {
+      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
+        return client.newBuilder()
+            .proxy(Proxy.NO_PROXY)
+            .build();
+      }
+    },
+
+    CREATE_ARG() {
+      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
+        return client.newBuilder()
+            .proxy(server.toProxyAddress())
+            .build();
+      }
+    },
+
+    PROXY_SYSTEM_PROPERTY() {
+      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
+        System.setProperty("proxyHost", server.getHostName());
+        System.setProperty("proxyPort", Integer.toString(server.getPort()));
+        return client;
+      }
+    },
+
+    HTTP_PROXY_SYSTEM_PROPERTY() {
+      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
+        System.setProperty("http.proxyHost", server.getHostName());
+        System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
+        return client;
+      }
+    },
+
+    HTTPS_PROXY_SYSTEM_PROPERTY() {
+      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
+        System.setProperty("https.proxyHost", server.getHostName());
+        System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
+        return client;
+      }
+    };
+
+    public abstract Call.Factory connect(MockWebServer server, OkHttpClient client)
+        throws IOException;
+
+    public Call connect(
+        MockWebServer server, OkHttpClient client, HttpUrl url) throws IOException {
+      Request request = new Request.Builder()
+          .url(url)
+          .build();
+      return connect(server, client).newCall(request);
+    }
+  }
+
+  private static class RecordingTrustManager implements X509TrustManager {
+    private final List<String> calls = new ArrayList<>();
+    private final X509TrustManager delegate;
+
+    RecordingTrustManager(X509TrustManager delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public X509Certificate[] getAcceptedIssuers() {
+      return delegate.getAcceptedIssuers();
+    }
+
+    @Override public void checkClientTrusted(X509Certificate[] chain, String authType) {
+      calls.add("checkClientTrusted " + certificatesToString(chain));
+    }
+
+    @Override public void checkServerTrusted(X509Certificate[] chain, String authType) {
+      calls.add("checkServerTrusted " + certificatesToString(chain));
+    }
+
+    private String certificatesToString(X509Certificate[] certificates) {
+      List<String> result = new ArrayList<>();
+      for (X509Certificate certificate : certificates) {
+        result.add(certificate.getSubjectDN() + " " + certificate.getSerialNumber());
+      }
+      return result.toString();
+    }
+  }
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
+   */
+  private void enableProtocol(Protocol protocol) {
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .protocols(asList(protocol, Protocol.HTTP_1_1))
+        .build();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.setProtocolNegotiationEnabled(true);
+    server.setProtocols(client.protocols());
+  }
+
+  /**
+   * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
+   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
+   * for details.
+   */
+  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
+    return new FallbackTestClientSocketFactory(handshakeCertificates.sslSocketFactory());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java b/okhttp/src/test/java/okhttp3/UrlComponentEncodingTester.java
similarity index 99%
rename from okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
rename to okhttp/src/test/java/okhttp3/UrlComponentEncodingTester.java
index 5875bc3970..bc2f054fc9 100644
--- a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
+++ b/okhttp/src/test/java/okhttp3/UrlComponentEncodingTester.java
@@ -306,13 +306,13 @@ private void testUri(
 
   public enum Encoding {
     IDENTITY {
-      public String encode(int codePoint) {
+      @Override public String encode(int codePoint) {
         return new String(new int[] {codePoint}, 0, 1);
       }
     },
 
     PERCENT {
-      public String encode(int codePoint) {
+      @Override public String encode(int codePoint) {
         ByteString utf8 = ByteString.encodeUtf8(IDENTITY.encode(codePoint));
         Buffer percentEncoded = new Buffer();
         for (int i = 0; i < utf8.size(); i++) {
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java b/okhttp/src/test/java/okhttp3/WebPlatformUrlTest.java
similarity index 83%
rename from okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
rename to okhttp/src/test/java/okhttp3/WebPlatformUrlTest.java
index d9b3d442f3..c12c6a417a 100644
--- a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
+++ b/okhttp/src/test/java/okhttp3/WebPlatformUrlTest.java
@@ -26,9 +26,7 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameter;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /** Runs the web platform URL tests against Java URL models. */
 @RunWith(Parameterized.class)
@@ -101,9 +99,10 @@ private void testHttpUrl() {
     }
 
     if (testData.expectParseFailure()) {
-      assertNull("Expected URL to fail parsing", url);
+      assertThat(url).overridingErrorMessage("Expected URL to fail parsing").isNull();
     } else {
-      assertNotNull("Expected URL to parse successfully, but was null", url);
+      assertThat(url).overridingErrorMessage(
+          "Expected URL to parse successfully, but was null").isNotNull();
       String effectivePort = url.port() != HttpUrl.defaultPort(url.scheme())
           ? Integer.toString(url.port())
           : "";
@@ -112,12 +111,13 @@ private void testHttpUrl() {
       String effectiveHost = url.host().contains(":")
           ? ("[" + url.host() + "]")
           : url.host();
-      assertEquals("scheme", testData.scheme, url.scheme());
-      assertEquals("host", testData.host, effectiveHost);
-      assertEquals("port", testData.port, effectivePort);
-      assertEquals("path", testData.path, url.encodedPath());
-      assertEquals("query", testData.query, effectiveQuery);
-      assertEquals("fragment", testData.fragment, effectiveFragment);
+      assertThat(url.scheme()).overridingErrorMessage("scheme").isEqualTo(testData.scheme);
+      assertThat(effectiveHost).overridingErrorMessage("host").isEqualTo(testData.host);
+      assertThat(effectivePort).overridingErrorMessage("port").isEqualTo(testData.port);
+      assertThat(url.encodedPath()).overridingErrorMessage("path").isEqualTo(testData.path);
+      assertThat(effectiveQuery).overridingErrorMessage("query").isEqualTo(testData.query);
+      assertThat(effectiveFragment).overridingErrorMessage("fragment").isEqualTo(
+          testData.fragment);
     }
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java b/okhttp/src/test/java/okhttp3/WebPlatformUrlTestData.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
rename to okhttp/src/test/java/okhttp3/WebPlatformUrlTestData.java
diff --git a/okhttp-tests/src/test/java/okhttp3/WholeOperationTimeoutTest.java b/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
similarity index 88%
rename from okhttp-tests/src/test/java/okhttp3/WholeOperationTimeoutTest.java
rename to okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
index 09adba67f4..6d9dcef39f 100644
--- a/okhttp-tests/src/test/java/okhttp3/WholeOperationTimeoutTest.java
+++ b/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
@@ -27,11 +27,7 @@
 import org.junit.Rule;
 import org.junit.Test;
 
-import static okhttp3.TestUtil.defaultClient;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class WholeOperationTimeoutTest {
@@ -39,15 +35,16 @@
   private static final String BIG_ENOUGH_BODY = TestUtil.repeat('a', 64 * 1024);
 
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
-  private OkHttpClient client = defaultClient();
+  private OkHttpClient client = clientTestRule.client;
 
   @Test public void defaultConfigIsNoTimeout() throws Exception {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .build();
     Call call = client.newCall(request);
-    assertEquals(0, call.timeout().timeoutNanos());
+    assertThat(call.timeout().timeoutNanos()).isEqualTo(0);
   }
 
   @Test public void configureClientDefault() throws Exception {
@@ -60,7 +57,7 @@
         .build();
 
     Call call = timeoutClient.newCall(request);
-    assertEquals(TimeUnit.MILLISECONDS.toNanos(456), call.timeout().timeoutNanos());
+    assertThat(call.timeout().timeoutNanos()).isEqualTo(TimeUnit.MILLISECONDS.toNanos(456));
   }
 
   @Test public void timeoutWritingRequest() throws Exception {
@@ -77,7 +74,8 @@
       call.execute();
       fail();
     } catch (IOException e) {
-      assertTrue(call.isCanceled());
+      assertThat(e.getMessage()).isEqualTo("timeout");
+      assertThat(call.isCanceled()).isTrue();
     }
   }
 
@@ -107,8 +105,8 @@
     });
 
     latch.await();
-    assertTrue(call.isCanceled());
-    assertNotNull(exceptionRef.get());
+    assertThat(call.isCanceled()).isTrue();
+    assertThat(exceptionRef.get()).isNotNull();
   }
 
   @Test public void timeoutProcessing() throws Exception {
@@ -125,7 +123,8 @@
       call.execute();
       fail();
     } catch (IOException e) {
-      assertTrue(call.isCanceled());
+      assertThat(e.getMessage()).isEqualTo("timeout");
+      assertThat(call.isCanceled()).isTrue();
     }
   }
 
@@ -155,8 +154,8 @@
     });
 
     latch.await();
-    assertTrue(call.isCanceled());
-    assertNotNull(exceptionRef.get());
+    assertThat(call.isCanceled()).isTrue();
+    assertThat(exceptionRef.get()).isNotNull();
   }
 
   @Test public void timeoutReadingResponse() throws Exception {
@@ -175,7 +174,8 @@
       response.body().source().readUtf8();
       fail();
     } catch (IOException e) {
-      assertTrue(call.isCanceled());
+      assertThat(e.getMessage()).isEqualTo("timeout");
+      assertThat(call.isCanceled()).isTrue();
     }
   }
 
@@ -215,8 +215,8 @@
     });
 
     latch.await();
-    assertTrue(call.isCanceled());
-    assertNotNull(exceptionRef.get());
+    assertThat(call.isCanceled()).isTrue();
+    assertThat(exceptionRef.get()).isNotNull();
   }
 
   @Test public void singleTimeoutForAllFollowUpRequests() throws Exception {
@@ -252,7 +252,8 @@
       call.execute();
       fail();
     } catch (IOException e) {
-      assertTrue(call.isCanceled());
+      assertThat(e.getMessage()).isEqualTo("timeout");
+      assertThat(call.isCanceled()).isTrue();
     }
   }
 
@@ -272,10 +273,11 @@ public void timeoutFollowingRedirectOnNewConnection() throws Exception {
     Call call = client.newCall(request);
     call.timeout().timeout(250, TimeUnit.MILLISECONDS);
     try {
-      Response response = call.execute();
+      call.execute();
       fail();
     } catch (IOException e) {
-      assertTrue(call.isCanceled());
+      assertThat(e.getMessage()).isEqualTo("timeout");
+      assertThat(call.isCanceled()).isTrue();
     }
   }
 
@@ -295,7 +297,7 @@ public void timeoutFollowingRedirectOnNewConnection() throws Exception {
     Thread.sleep(250);
     response.body().source().readUtf8();
     response.close();
-    assertFalse(call.isCanceled());
+    assertThat(call.isCanceled()).isFalse();
   }
 
   private RequestBody sleepingRequestBody(final int sleepMillis) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java b/okhttp/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
similarity index 92%
rename from okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
rename to okhttp/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
index 7811ff5d75..ac42c15c7f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
+++ b/okhttp/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
@@ -17,10 +17,11 @@
 
 import java.net.InetAddress;
 import java.net.UnknownHostException;
-import java.util.Arrays;
 import java.util.List;
 import okhttp3.Dns;
 
+import static java.util.Arrays.asList;
+
 /**
  * A network that always resolves two IP addresses per host. Use this when testing route selection
  * fallbacks to guarantee that a fallback address is available.
@@ -28,6 +29,6 @@
 public class DoubleInetAddressDns implements Dns {
   @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
     List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
-    return Arrays.asList(addresses.get(0), addresses.get(0));
+    return asList(addresses.get(0), addresses.get(0));
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java b/okhttp/src/test/java/okhttp3/internal/RecordingAuthenticator.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java
rename to okhttp/src/test/java/okhttp3/internal/RecordingAuthenticator.java
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java b/okhttp/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
rename to okhttp/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java b/okhttp/src/test/java/okhttp3/internal/SocketRecorder.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java
rename to okhttp/src/test/java/okhttp3/internal/SocketRecorder.java
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java b/okhttp/src/test/java/okhttp3/internal/UtilTest.java
similarity index 84%
rename from okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
rename to okhttp/src/test/java/okhttp3/internal/UtilTest.java
index dacf8ddaff..cac32a9922 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/UtilTest.java
@@ -20,7 +20,7 @@
 import java.util.Map;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class UtilTest {
@@ -28,9 +28,9 @@
     Map<String, String> map = new LinkedHashMap<>();
     map.put("a", "A");
     Map<String, String> immutableCopy = Util.immutableMap(map);
-    assertEquals(immutableCopy, Collections.singletonMap("a", "A"));
+    assertThat(Collections.singletonMap("a", "A")).isEqualTo(immutableCopy);
     map.clear();
-    assertEquals(immutableCopy, Collections.singletonMap("a", "A"));
+    assertThat(Collections.singletonMap("a", "A")).isEqualTo(immutableCopy);
     try {
       immutableCopy.clear();
       fail();
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java b/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
similarity index 86%
rename from okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
rename to okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
index 1d5bf30731..01b65d77cb 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
@@ -19,7 +19,6 @@
 import java.io.IOException;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Deque;
 import java.util.Iterator;
 import java.util.List;
@@ -38,15 +37,12 @@
 import org.junit.rules.TemporaryFolder;
 import org.junit.rules.Timeout;
 
+import static java.util.Arrays.asList;
 import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE;
 import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE_BACKUP;
 import static okhttp3.internal.cache.DiskLruCache.MAGIC;
 import static okhttp3.internal.cache.DiskLruCache.VERSION_1;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class DiskLruCacheTest {
@@ -120,7 +116,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     fileSystem.setFaultyDelete(cacheDir, false);
 
     DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertNull(snapshot);
+    assertThat(snapshot).isNull();
   }
 
   @Test public void validateKey() throws Exception {
@@ -130,35 +126,40 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
       cache.edit(key);
       fail("Expecting an IllegalArgumentException as the key was invalid.");
     } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+      assertThat(iae.getMessage()).isEqualTo(
+          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
     }
     try {
       key = "has_CR\r";
       cache.edit(key);
       fail("Expecting an IllegalArgumentException as the key was invalid.");
     } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+      assertThat(iae.getMessage()).isEqualTo(
+          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
     }
     try {
       key = "has_LF\n";
       cache.edit(key);
       fail("Expecting an IllegalArgumentException as the key was invalid.");
     } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+      assertThat(iae.getMessage()).isEqualTo(
+          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
     }
     try {
       key = "has_invalid/";
       cache.edit(key);
       fail("Expecting an IllegalArgumentException as the key was invalid.");
     } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+      assertThat(iae.getMessage()).isEqualTo(
+          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
     }
     try {
       key = "has_invalid\u2603";
       cache.edit(key);
       fail("Expecting an IllegalArgumentException as the key was invalid.");
     } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+      assertThat(iae.getMessage()).isEqualTo(
+          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
     }
     try {
       key = "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long_"
@@ -166,7 +167,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
       cache.edit(key);
       fail("Expecting an IllegalArgumentException as the key was too long.");
     } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+      assertThat(iae.getMessage()).isEqualTo(
+          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
     }
 
     // Test valid cases.
@@ -187,8 +189,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor creator = cache.edit("k1");
     setString(creator, 0, "ABC");
     setString(creator, 1, "DE");
-    assertNull(creator.newSource(0));
-    assertNull(creator.newSource(1));
+    assertThat(creator.newSource(0)).isNull();
+    assertThat(creator.newSource(1)).isNull();
     creator.commit();
 
     DiskLruCache.Snapshot snapshot = cache.get("k1");
@@ -252,7 +254,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void journalDoesNotIncludeReadOfYetUnpublishedValue() throws Exception {
     DiskLruCache.Editor creator = cache.edit("k1");
-    assertNull(cache.get("k1"));
+    assertThat(cache.get("k1")).isNull();
     setString(creator, 0, "A");
     setString(creator, 1, "BC");
     creator.commit();
@@ -297,16 +299,16 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     setString(editor, 1, "B");
     editor.commit();
     File k1 = getCleanFile("k1", 0);
-    assertEquals("ABC", readFile(k1));
+    assertThat(readFile(k1)).isEqualTo("ABC");
     cache.remove("k1");
-    assertFalse(fileSystem.exists(k1));
+    assertThat(fileSystem.exists(k1)).isFalse();
   }
 
   @Test public void removePreventsActiveEditFromStoringAValue() throws Exception {
     set("a", "a", "a");
     DiskLruCache.Editor a = cache.edit("a");
     setString(a, 0, "a1");
-    assertTrue(cache.remove("a"));
+    assertThat(cache.remove("a")).isTrue();
     setString(a, 1, "a2");
     a.commit();
     assertAbsent("a");
@@ -324,8 +326,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     DiskLruCache.Snapshot snapshot1 = cache.get("k1");
     BufferedSource inV1 = Okio.buffer(snapshot1.getSource(0));
-    assertEquals('A', inV1.readByte());
-    assertEquals('A', inV1.readByte());
+    assertThat(inV1.readByte()).isEqualTo((byte) 'A');
+    assertThat(inV1.readByte()).isEqualTo((byte) 'A');
 
     DiskLruCache.Editor v1Updater = cache.edit("k1");
     setString(v1Updater, 0, "CCcc");
@@ -337,8 +339,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertSnapshotValue(snapshot2, 1, "DDdd");
     snapshot2.close();
 
-    assertEquals('a', inV1.readByte());
-    assertEquals('a', inV1.readByte());
+    assertThat(inV1.readByte()).isEqualTo((byte) 'a');
+    assertThat(inV1.readByte()).isEqualTo((byte) 'a');
     assertSnapshotValue(snapshot1, 1, "BBbb");
     snapshot1.close();
   }
@@ -355,11 +357,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     writeFile(dirtyFile1, "D");
     createJournal("CLEAN k1 1 1", "DIRTY   k1");
     createNewCache();
-    assertFalse(fileSystem.exists(cleanFile0));
-    assertFalse(fileSystem.exists(cleanFile1));
-    assertFalse(fileSystem.exists(dirtyFile0));
-    assertFalse(fileSystem.exists(dirtyFile1));
-    assertNull(cache.get("k1"));
+    assertThat(fileSystem.exists(cleanFile0)).isFalse();
+    assertThat(fileSystem.exists(cleanFile1)).isFalse();
+    assertThat(fileSystem.exists(dirtyFile0)).isFalse();
+    assertThat(fileSystem.exists(dirtyFile1)).isFalse();
+    assertThat(cache.get("k1")).isNull();
   }
 
   @Test public void openWithInvalidVersionClearsDirectory() throws Exception {
@@ -400,7 +402,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     createJournal("CLEAN k1 1 1", "BOGUS");
     createNewCache();
     assertGarbageFilesAllDeleted();
-    assertNull(cache.get("k1"));
+    assertThat(cache.get("k1")).isNull();
   }
 
   @Test public void openWithInvalidFileSizeClearsDirectory() throws Exception {
@@ -409,7 +411,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     createJournal("CLEAN k1 0000x001 1");
     createNewCache();
     assertGarbageFilesAllDeleted();
-    assertNull(cache.get("k1"));
+    assertThat(cache.get("k1")).isNull();
   }
 
   @Test public void openWithTruncatedLineDiscardsThatLine() throws Exception {
@@ -421,7 +423,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     sink.writeUtf8(MAGIC + "\n" + VERSION_1 + "\n100\n2\n\nCLEAN k1 1 1"); // no trailing newline
     sink.close();
     createNewCache();
-    assertNull(cache.get("k1"));
+    assertThat(cache.get("k1")).isNull();
 
     // The journal is not corrupt when editing after a truncated line.
     set("k1", "C", "D");
@@ -437,7 +439,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     createJournal("CLEAN k1 1 1 1");
     createNewCache();
     assertGarbageFilesAllDeleted();
-    assertNull(cache.get("k1"));
+    assertThat(cache.get("k1")).isNull();
   }
 
   @Test public void keyWithSpaceNotPermitted() throws Exception {
@@ -468,7 +470,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     try {
       cache.edit(null);
       fail();
-    } catch (NullPointerException expected) {
+    } catch (IllegalArgumentException expected) {
     }
   }
 
@@ -481,11 +483,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     } catch (IllegalStateException expected) {
     }
 
-    assertFalse(fileSystem.exists(getCleanFile("k1", 0)));
-    assertFalse(fileSystem.exists(getCleanFile("k1", 1)));
-    assertFalse(fileSystem.exists(getDirtyFile("k1", 0)));
-    assertFalse(fileSystem.exists(getDirtyFile("k1", 1)));
-    assertNull(cache.get("k1"));
+    assertThat(fileSystem.exists(getCleanFile("k1", 0))).isFalse();
+    assertThat(fileSystem.exists(getCleanFile("k1", 1))).isFalse();
+    assertThat(fileSystem.exists(getDirtyFile("k1", 0))).isFalse();
+    assertThat(fileSystem.exists(getDirtyFile("k1", 1))).isFalse();
+    assertThat(cache.get("k1")).isNull();
 
     DiskLruCache.Editor creator2 = cache.edit("k1");
     setString(creator2, 0, "B");
@@ -497,11 +499,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor creator = cache.edit("k1");
     setString(creator, 1, "A");
     creator.abort();
-    assertFalse(fileSystem.exists(getCleanFile("k1", 0)));
-    assertFalse(fileSystem.exists(getCleanFile("k1", 1)));
-    assertFalse(fileSystem.exists(getDirtyFile("k1", 0)));
-    assertFalse(fileSystem.exists(getDirtyFile("k1", 1)));
-    assertNull(cache.get("k1"));
+    assertThat(fileSystem.exists(getCleanFile("k1", 0))).isFalse();
+    assertThat(fileSystem.exists(getCleanFile("k1", 1))).isFalse();
+    assertThat(fileSystem.exists(getDirtyFile("k1", 0))).isFalse();
+    assertThat(fileSystem.exists(getDirtyFile("k1", 1))).isFalse();
+    assertThat(cache.get("k1")).isNull();
   }
 
   @Test public void updateExistingEntryWithTooFewValuesReusesPreviousValues() throws Exception {
@@ -527,7 +529,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "bb", "bbbb"); // size 6
     cache.setMaxSize(20);
     set("c", "c", "c"); // size 12
-    assertEquals(12, cache.size());
+    assertThat(cache.size()).isEqualTo(12);
   }
 
   @Test public void shrinkMaxSizeEvicts() throws Exception {
@@ -537,7 +539,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "bb", "bbbb"); // size 6
     set("c", "c", "c"); // size 12
     cache.setMaxSize(10);
-    assertEquals(1, executor.jobs.size());
+    assertThat(executor.jobs.size()).isEqualTo(1);
   }
 
   @Test public void evictOnInsert() throws Exception {
@@ -546,12 +548,12 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     set("a", "a", "aaa"); // size 4
     set("b", "bb", "bbbb"); // size 6
-    assertEquals(10, cache.size());
+    assertThat(cache.size()).isEqualTo(10);
 
     // Cause the size to grow to 12 should evict 'A'.
     set("c", "c", "c");
     cache.flush();
-    assertEquals(8, cache.size());
+    assertThat(cache.size()).isEqualTo(8);
     assertAbsent("a");
     assertValue("b", "bb", "bbbb");
     assertValue("c", "c", "c");
@@ -559,7 +561,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     // Causing the size to grow to 10 should evict nothing.
     set("d", "d", "d");
     cache.flush();
-    assertEquals(10, cache.size());
+    assertThat(cache.size()).isEqualTo(10);
     assertAbsent("a");
     assertValue("b", "bb", "bbbb");
     assertValue("c", "c", "c");
@@ -568,7 +570,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     // Causing the size to grow to 18 should evict 'B' and 'C'.
     set("e", "eeee", "eeee");
     cache.flush();
-    assertEquals(10, cache.size());
+    assertThat(cache.size()).isEqualTo(10);
     assertAbsent("a");
     assertAbsent("b");
     assertAbsent("c");
@@ -583,12 +585,12 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("a", "a", "aa"); // size 3
     set("b", "b", "bb"); // size 3
     set("c", "c", "cc"); // size 3
-    assertEquals(9, cache.size());
+    assertThat(cache.size()).isEqualTo(9);
 
     // Causing the size to grow to 11 should evict 'A'.
     set("b", "b", "bbbb");
     cache.flush();
-    assertEquals(8, cache.size());
+    assertThat(cache.size()).isEqualTo(8);
     assertAbsent("a");
     assertValue("b", "b", "bbbb");
     assertValue("c", "c", "cc");
@@ -609,7 +611,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     // Causing the size to grow to 12 should evict 'C'.
     set("g", "g", "g");
     cache.flush();
-    assertEquals(10, cache.size());
+    assertThat(cache.size()).isEqualTo(10);
     assertAbsent("a");
     assertValue("b", "b", "b");
     assertAbsent("c");
@@ -626,13 +628,13 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("e", "e", "e");
     set("f", "f", "f");
     cache.get("b").close(); // 'B' is now least recently used.
-    assertEquals(12, cache.size());
+    assertThat(cache.size()).isEqualTo(12);
     cache.close();
     createNewCacheWithSize(10);
 
     set("g", "g", "g");
     cache.flush();
-    assertEquals(10, cache.size());
+    assertThat(cache.size()).isEqualTo(10);
     assertAbsent("a");
     assertValue("b", "b", "b");
     assertAbsent("c");
@@ -681,7 +683,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   @Test public void readingTheSameStreamMultipleTimes() throws Exception {
     set("a", "a", "b");
     DiskLruCache.Snapshot snapshot = cache.get("a");
-    assertSame(snapshot.getSource(0), snapshot.getSource(0));
+    assertThat(snapshot.getSource(0)).isSameAs(snapshot.getSource(0));
     snapshot.close();
   }
 
@@ -739,10 +741,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     executor.jobs.removeFirst().run();
 
     // Don't allow edits under any circumstances.
-    assertNull(cache.edit("a"));
-    assertNull(cache.edit("c"));
+    assertThat(cache.edit("a")).isNull();
+    assertThat(cache.edit("c")).isNull();
     DiskLruCache.Snapshot snapshot = cache.get("a");
-    assertNull(snapshot.edit());
+    assertThat(snapshot.edit()).isNull();
     snapshot.close();
   }
 
@@ -759,12 +761,12 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     // The rebuild is retried on cache hits and on cache edits.
     DiskLruCache.Snapshot snapshot = cache.get("b");
     snapshot.close();
-    assertNull(cache.edit("d"));
-    assertEquals(2, executor.jobs.size());
+    assertThat(cache.edit("d")).isNull();
+    assertThat(executor.jobs.size()).isEqualTo(2);
 
     // On cache misses, no retry job is queued.
-    assertNull(cache.get("c"));
-    assertEquals(2, executor.jobs.size());
+    assertThat(cache.get("c")).isNull();
+    assertThat(executor.jobs.size()).isEqualTo(2);
 
     // Let the rebuild complete successfully.
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
@@ -825,7 +827,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     // Although 'c' successfully committed above, the journal wasn't available to issue a CLEAN op.
     // Because the last state of 'c' was DIRTY before the journal failed, it should be removed
     // entirely on a subsequent open.
-    assertEquals(4, cache.size());
+    assertThat(cache.size()).isEqualTo(4);
     assertAbsent("c");
     assertAbsent("d");
     assertAbsent("e");
@@ -841,7 +843,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
     executor.jobs.removeFirst().run();
 
-    assertTrue(cache.remove("a"));
+    assertThat(cache.remove("a")).isTrue();
     assertAbsent("a");
 
     // Let the rebuild complete successfully.
@@ -861,7 +863,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
     executor.jobs.removeFirst().run();
 
-    assertTrue(cache.remove("a"));
+    assertThat(cache.remove("a")).isTrue();
     assertAbsent("a");
 
     cache.close();
@@ -870,9 +872,9 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     // The journal will have no record that 'a' was removed. It will have an entry for 'a', but when
     // it tries to read the cache files, it will find they were deleted. Once it encounters an entry
     // with missing cache files, it should remove it from the cache entirely.
-    assertEquals(4, cache.size());
-    assertNull(cache.get("a"));
-    assertEquals(2, cache.size());
+    assertThat(cache.size()).isEqualTo(4);
+    assertThat(cache.get("a")).isNull();
+    assertThat(cache.size()).isEqualTo(2);
   }
 
   @Test public void rebuildJournalFailureAllowsEvictAll() throws Exception {
@@ -887,7 +889,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     cache.evictAll();
 
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
     assertAbsent("a");
     assertAbsent("b");
 
@@ -897,10 +899,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     // The journal has no record that 'a' and 'b' were removed. It will have an entry for both, but
     // when it tries to read the cache files for either entry, it will discover the cache files are
     // missing and remove the entries from the cache.
-    assertEquals(4, cache.size());
-    assertNull(cache.get("a"));
-    assertNull(cache.get("b"));
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(4);
+    assertThat(cache.get("a")).isNull();
+    assertThat(cache.get("b")).isNull();
+    assertThat(cache.size()).isEqualTo(0);
   }
 
   @Test public void rebuildJournalFailureWithCacheTrim() throws Exception {
@@ -929,7 +931,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     cache.close();
 
     fileSystem.rename(journalFile, journalBkpFile);
-    assertFalse(fileSystem.exists(journalFile));
+    assertThat(fileSystem.exists(journalFile)).isFalse();
 
     createNewCache();
 
@@ -937,8 +939,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertSnapshotValue(snapshot, 0, "ABC");
     assertSnapshotValue(snapshot, 1, "DE");
 
-    assertFalse(fileSystem.exists(journalBkpFile));
-    assertTrue(fileSystem.exists(journalFile));
+    assertThat(fileSystem.exists(journalBkpFile)).isFalse();
+    assertThat(fileSystem.exists(journalFile)).isTrue();
   }
 
   @Test public void journalFileIsPreferredOverBackupFile() throws Exception {
@@ -956,8 +958,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     creator.commit();
     cache.close();
 
-    assertTrue(fileSystem.exists(journalFile));
-    assertTrue(fileSystem.exists(journalBkpFile));
+    assertThat(fileSystem.exists(journalFile)).isTrue();
+    assertThat(fileSystem.exists(journalBkpFile)).isTrue();
 
     createNewCache();
 
@@ -969,8 +971,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertSnapshotValue(snapshotB, 0, "F");
     assertSnapshotValue(snapshotB, 1, "GH");
 
-    assertFalse(fileSystem.exists(journalBkpFile));
-    assertTrue(fileSystem.exists(journalFile));
+    assertThat(fileSystem.exists(journalBkpFile)).isFalse();
+    assertThat(fileSystem.exists(journalFile)).isTrue();
   }
 
   @Test public void openCreatesDirectoryIfNecessary() throws Exception {
@@ -978,16 +980,16 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     File dir = tempDir.newFolder("testOpenCreatesDirectoryIfNecessary");
     cache = DiskLruCache.create(fileSystem, dir, appVersion, 2, Integer.MAX_VALUE);
     set("a", "a", "a");
-    assertTrue(fileSystem.exists(new File(dir, "a.0")));
-    assertTrue(fileSystem.exists(new File(dir, "a.1")));
-    assertTrue(fileSystem.exists(new File(dir, "journal")));
+    assertThat(fileSystem.exists(new File(dir, "a.0"))).isTrue();
+    assertThat(fileSystem.exists(new File(dir, "a.1"))).isTrue();
+    assertThat(fileSystem.exists(new File(dir, "journal"))).isTrue();
   }
 
   @Test public void fileDeletedExternally() throws Exception {
     set("a", "a", "a");
     fileSystem.delete(getCleanFile("a", 1));
-    assertNull(cache.get("a"));
-    assertEquals(0, cache.size());
+    assertThat(cache.get("a")).isNull();
+    assertThat(cache.size()).isEqualTo(0);
   }
 
   @Test public void editSameVersion() throws Exception {
@@ -1017,7 +1019,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor toAbort = snapshot.edit();
     setString(toAbort, 0, "b");
     toAbort.commit();
-    assertNull(snapshot.edit());
+    assertThat(snapshot.edit()).isNull();
   }
 
   @Test public void editSinceEvicted() throws Exception {
@@ -1028,7 +1030,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "bb", "bbb"); // size 5
     set("c", "cc", "ccc"); // size 5; will evict 'A'
     cache.flush();
-    assertNull(snapshot.edit());
+    assertThat(snapshot.edit()).isNull();
   }
 
   @Test public void editSinceEvictedAndRecreated() throws Exception {
@@ -1040,7 +1042,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("c", "cc", "ccc"); // size 5; will evict 'A'
     set("a", "a", "aaaa"); // size 5; will evict 'B'
     cache.flush();
-    assertNull(snapshot.edit());
+    assertThat(snapshot.edit()).isNull();
   }
 
   /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
@@ -1074,13 +1076,13 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     fileSystem.deleteContents(tempDir.getRoot());
     setString(a, 1, "a2");
     a.commit();
-    assertNull(cache.get("a"));
+    assertThat(cache.get("a")).isNull();
   }
 
   /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
   @Test public void aggressiveClearingHandlesRead() throws Exception {
     fileSystem.deleteContents(tempDir.getRoot());
-    assertNull(cache.get("a"));
+    assertThat(cache.get("a")).isNull();
   }
 
   /**
@@ -1094,21 +1096,21 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     cache.setMaxSize(8); // Smaller than the sum of active edits!
     cache.flush(); // Force trimToSize().
-    assertEquals(0, cache.size());
-    assertNull(cache.get("a"));
+    assertThat(cache.size()).isEqualTo(0);
+    assertThat(cache.get("a")).isNull();
 
     // After the edit is completed, its entry is still gone.
     setString(a, 1, "a1");
     a.commit();
     assertAbsent("a");
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
   }
 
   @Test public void evictAll() throws Exception {
     set("a", "a", "a");
     set("b", "b", "b");
     cache.evictAll();
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
     assertAbsent("a");
     assertAbsent("b");
   }
@@ -1118,7 +1120,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     setString(a, 0, "a1");
     setString(a, 1, "a2");
     cache.evictAll();
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
     a.commit();
     assertAbsent("a");
   }
@@ -1129,7 +1131,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     setString(a, 0, "a1");
     setString(a, 1, "a2");
     cache.evictAll();
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
     a.commit();
     assertAbsent("a");
   }
@@ -1139,7 +1141,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Snapshot a = cache.get("a");
     assertSnapshotValue(a, 0, "a");
     cache.evictAll();
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
     assertAbsent("a");
     assertSnapshotValue(a, 1, "a");
     a.close();
@@ -1149,9 +1151,9 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("a", "a", "a");
     DiskLruCache.Snapshot a = cache.get("a");
     cache.evictAll();
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
     assertAbsent("a");
-    assertNull(a.edit());
+    assertThat(a.edit()).isNull();
     a.close();
   }
 
@@ -1161,28 +1163,28 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("c", "c1", "c2");
     Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
 
-    assertTrue(iterator.hasNext());
+    assertThat(iterator.hasNext()).isTrue();
     DiskLruCache.Snapshot a = iterator.next();
-    assertEquals("a", a.key());
+    assertThat(a.key()).isEqualTo("a");
     assertSnapshotValue(a, 0, "a1");
     assertSnapshotValue(a, 1, "a2");
     a.close();
 
-    assertTrue(iterator.hasNext());
+    assertThat(iterator.hasNext()).isTrue();
     DiskLruCache.Snapshot b = iterator.next();
-    assertEquals("b", b.key());
+    assertThat(b.key()).isEqualTo("b");
     assertSnapshotValue(b, 0, "b1");
     assertSnapshotValue(b, 1, "b2");
     b.close();
 
-    assertTrue(iterator.hasNext());
+    assertThat(iterator.hasNext()).isTrue();
     DiskLruCache.Snapshot c = iterator.next();
-    assertEquals("c", c.key());
+    assertThat(c.key()).isEqualTo("c");
     assertSnapshotValue(c, 0, "c1");
     assertSnapshotValue(c, 1, "c2");
     c.close();
 
-    assertFalse(iterator.hasNext());
+    assertThat(iterator.hasNext()).isFalse();
     try {
       iterator.next();
       fail();
@@ -1196,16 +1198,16 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
 
     DiskLruCache.Snapshot a = iterator.next();
-    assertEquals("a", a.key());
+    assertThat(a.key()).isEqualTo("a");
     a.close();
 
     set("c", "c1", "c2");
 
     DiskLruCache.Snapshot b = iterator.next();
-    assertEquals("b", b.key());
+    assertThat(b.key()).isEqualTo("b");
     b.close();
 
-    assertFalse(iterator.hasNext());
+    assertThat(iterator.hasNext()).isFalse();
   }
 
   @Test public void iteratorElementsUpdatedDuringIterationAreUpdated() throws Exception {
@@ -1214,13 +1216,13 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
 
     DiskLruCache.Snapshot a = iterator.next();
-    assertEquals("a", a.key());
+    assertThat(a.key()).isEqualTo("a");
     a.close();
 
     set("b", "b3", "b4");
 
     DiskLruCache.Snapshot b = iterator.next();
-    assertEquals("b", b.key());
+    assertThat(b.key()).isEqualTo("b");
     assertSnapshotValue(b, 0, "b3");
     assertSnapshotValue(b, 1, "b4");
     b.close();
@@ -1234,10 +1236,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     cache.remove("b");
 
     DiskLruCache.Snapshot a = iterator.next();
-    assertEquals("a", a.key());
+    assertThat(a.key()).isEqualTo("a");
     a.close();
 
-    assertFalse(iterator.hasNext());
+    assertThat(iterator.hasNext()).isFalse();
   }
 
   @Test public void iteratorRemove() throws Exception {
@@ -1248,7 +1250,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     a.close();
     iterator.remove();
 
-    assertNull(cache.get("a"));
+    assertThat(cache.get("a")).isNull();
   }
 
   @Test public void iteratorRemoveBeforeNext() throws Exception {
@@ -1280,7 +1282,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("a", "a1", "a2");
     Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
     cache.close();
-    assertFalse(iterator.hasNext());
+    assertThat(iterator.hasNext()).isFalse();
   }
 
   @Test public void isClosed_uninitializedCache() throws Exception {
@@ -1288,9 +1290,9 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
     toClose.add(cache);
 
-    assertFalse(cache.isClosed());
+    assertThat(cache.isClosed()).isFalse();
     cache.close();
-    assertTrue(cache.isClosed());
+    assertThat(cache.isClosed()).isTrue();
   }
 
   @Test public void journalWriteFailsDuringEdit() throws Exception {
@@ -1299,11 +1301,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // We can't begin the edit if writing 'DIRTY' fails.
     fileSystem.setFaultyWrite(journalFile, true);
-    assertNull(cache.edit("c"));
+    assertThat(cache.edit("c")).isNull();
 
     // Once the journal has a failure, subsequent writes aren't permitted.
     fileSystem.setFaultyWrite(journalFile, false);
-    assertNull(cache.edit("d"));
+    assertThat(cache.edit("d")).isNull();
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
     cache.close();
@@ -1331,7 +1333,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Once the journal has a failure, subsequent writes aren't permitted.
     fileSystem.setFaultyWrite(journalFile, false);
-    assertNull(cache.edit("d"));
+    assertThat(cache.edit("d")).isNull();
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
     cache.close();
@@ -1355,7 +1357,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Once the journal has a failure, subsequent writes aren't permitted.
     fileSystem.setFaultyWrite(journalFile, false);
-    assertNull(cache.edit("d"));
+    assertThat(cache.edit("d")).isNull();
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
     cache.close();
@@ -1372,7 +1374,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Remove, but the journal write will fail.
     fileSystem.setFaultyWrite(journalFile, true);
-    assertTrue(cache.remove("a"));
+    assertThat(cache.remove("a")).isTrue();
 
     // Confirm that the entry was still removed.
     fileSystem.setFaultyWrite(journalFile, false);
@@ -1393,9 +1395,9 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     executor.jobs.pop().run();
 
     // Confirm that edits are prevented after a cache trim failure.
-    assertNull(cache.edit("a"));
-    assertNull(cache.edit("b"));
-    assertNull(cache.edit("c"));
+    assertThat(cache.edit("a")).isNull();
+    assertThat(cache.edit("b")).isNull();
+    assertThat(cache.edit("c")).isNull();
 
     // Allow the test to clean up.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
@@ -1412,12 +1414,12 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     executor.jobs.pop().run();
 
     // An edit should now add a job to clean up if the most recent trim failed.
-    assertNull(cache.edit("b"));
+    assertThat(cache.edit("b")).isNull();
     executor.jobs.pop().run();
 
     // Confirm a successful cache trim now allows edits.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    assertNull(cache.edit("c"));
+    assertThat(cache.edit("c")).isNull();
     executor.jobs.pop().run();
     set("c", "cc", "cc");
     assertValue("c", "cc", "cc");
@@ -1475,10 +1477,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Confirm snapshot writes are prevented after a trim failure.
     DiskLruCache.Snapshot snapshot1 = cache.get("a");
-    assertNull(snapshot1.edit());
+    assertThat(snapshot1.edit()).isNull();
     snapshot1.close();
     DiskLruCache.Snapshot snapshot2 = cache.get("b");
-    assertNull(snapshot2.edit());
+    assertThat(snapshot2.edit()).isNull();
     snapshot2.close();
 
     // Allow the test to clean up.
@@ -1496,7 +1498,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     executor.jobs.pop().run();
 
     // Confirm we prevent edits after a trim failure.
-    assertNull(cache.edit("c"));
+    assertThat(cache.edit("c")).isNull();
 
     // A successful eviction should allow new writes.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
@@ -1516,7 +1518,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     executor.jobs.pop().run();
 
     // Confirm we prevent edits after a trim failure.
-    assertNull(cache.edit("c"));
+    assertThat(cache.edit("c")).isNull();
 
     // A successful removal which trims the cache should allow new writes.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
@@ -1536,7 +1538,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     executor.jobs.pop().run();
 
     // Confirm we prevent edits after a trim failure.
-    assertNull(cache.edit("c"));
+    assertThat(cache.edit("c")).isNull();
 
     // A successful flush trims the cache and should allow new writes.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
@@ -1556,15 +1558,15 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     executor.jobs.pop().run();
 
     // Confirm the partial snapshot is not returned.
-    assertNull(cache.get("a"));
+    assertThat(cache.get("a")).isNull();
 
     // Confirm we prevent edits after a trim failure.
-    assertNull(cache.edit("a"));
+    assertThat(cache.edit("a")).isNull();
 
     // Confirm the partial snapshot is not returned after a successful trim.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), false);
     executor.jobs.pop().run();
-    assertNull(cache.get("a"));
+    assertThat(cache.get("a")).isNull();
   }
 
   @Test public void noSizeCorruptionAfterCreatorDetached() throws Exception {
@@ -1576,11 +1578,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Create a new value in its place.
     set("k1", "bb", "bb");
-    assertEquals(4, cache.size());
+    assertThat(cache.size()).isEqualTo(4);
 
     // Committing the detached editor should not change the cache's size.
     editor.commit();
-    assertEquals(4, cache.size());
+    assertThat(cache.size()).isEqualTo(4);
     assertValue("k1", "bb", "bb");
   }
 
@@ -1595,11 +1597,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Create a new value in its place.
     set("k1", "ccc", "ccc");
-    assertEquals(6, cache.size());
+    assertThat(cache.size()).isEqualTo(6);
 
     // Committing the detached editor should not change the cache's size.
     editor.commit();
-    assertEquals(6, cache.size());
+    assertThat(cache.size()).isEqualTo(6);
     assertValue("k1", "ccc", "ccc");
   }
 
@@ -1609,7 +1611,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor editor = cache.edit("k1");
     cache.evictAll();
 
-    assertNull(editor.newSource(0));
+    assertThat(editor.newSource(0)).isNull();
   }
 
   @Test public void editsDiscardedAfterEditorDetached() throws Exception {
@@ -1637,7 +1639,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     cache.evictAll();
 
     editor.abort();
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
     assertAbsent("k1");
   }
 
@@ -1648,8 +1650,8 @@ private void assertJournalEquals(String... expectedBodyLines) throws Exception {
     expectedLines.add("100");
     expectedLines.add("2");
     expectedLines.add("");
-    expectedLines.addAll(Arrays.asList(expectedBodyLines));
-    assertEquals(expectedLines, readJournalLines());
+    expectedLines.addAll(asList(expectedBodyLines));
+    assertThat(readJournalLines()).isEqualTo(expectedLines);
   }
 
   private void createJournal(String... bodyLines) throws Exception {
@@ -1743,12 +1745,12 @@ private void generateSomeGarbageFiles() throws Exception {
   }
 
   private void assertGarbageFilesAllDeleted() {
-    assertFalse(fileSystem.exists(getCleanFile("g1", 0)));
-    assertFalse(fileSystem.exists(getCleanFile("g1", 1)));
-    assertFalse(fileSystem.exists(getCleanFile("g2", 0)));
-    assertFalse(fileSystem.exists(getCleanFile("g2", 1)));
-    assertFalse(fileSystem.exists(new File(cacheDir, "otherFile0")));
-    assertFalse(fileSystem.exists(new File(cacheDir, "dir1")));
+    assertThat(fileSystem.exists(getCleanFile("g1", 0))).isFalse();
+    assertThat(fileSystem.exists(getCleanFile("g1", 1))).isFalse();
+    assertThat(fileSystem.exists(getCleanFile("g2", 0))).isFalse();
+    assertThat(fileSystem.exists(getCleanFile("g2", 1))).isFalse();
+    assertThat(fileSystem.exists(new File(cacheDir, "otherFile0"))).isFalse();
+    assertThat(fileSystem.exists(new File(cacheDir, "dir1"))).isFalse();
   }
 
   private void set(String key, String value0, String value1) throws Exception {
@@ -1771,25 +1773,25 @@ private void assertAbsent(String key) throws Exception {
       snapshot.close();
       fail();
     }
-    assertFalse(fileSystem.exists(getCleanFile(key, 0)));
-    assertFalse(fileSystem.exists(getCleanFile(key, 1)));
-    assertFalse(fileSystem.exists(getDirtyFile(key, 0)));
-    assertFalse(fileSystem.exists(getDirtyFile(key, 1)));
+    assertThat(fileSystem.exists(getCleanFile(key, 0))).isFalse();
+    assertThat(fileSystem.exists(getCleanFile(key, 1))).isFalse();
+    assertThat(fileSystem.exists(getDirtyFile(key, 0))).isFalse();
+    assertThat(fileSystem.exists(getDirtyFile(key, 1))).isFalse();
   }
 
   private void assertValue(String key, String value0, String value1) throws Exception {
     DiskLruCache.Snapshot snapshot = cache.get(key);
     assertSnapshotValue(snapshot, 0, value0);
     assertSnapshotValue(snapshot, 1, value1);
-    assertTrue(fileSystem.exists(getCleanFile(key, 0)));
-    assertTrue(fileSystem.exists(getCleanFile(key, 1)));
+    assertThat(fileSystem.exists(getCleanFile(key, 0))).isTrue();
+    assertThat(fileSystem.exists(getCleanFile(key, 1))).isTrue();
     snapshot.close();
   }
 
   private void assertSnapshotValue(DiskLruCache.Snapshot snapshot, int index, String value)
       throws IOException {
-    assertEquals(value, sourceAsString(snapshot.getSource(index)));
-    assertEquals(value.length(), snapshot.getLength(index));
+    assertThat(sourceAsString(snapshot.getSource(index))).isEqualTo(value);
+    assertThat(snapshot.getLength(index)).isEqualTo(value.length());
   }
 
   private String sourceAsString(Source source) throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java b/okhttp/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
similarity index 87%
rename from okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
rename to okhttp/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
index 21bbd49358..cca27974fc 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
@@ -30,7 +30,7 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class FileOperatorTest {
@@ -55,10 +55,10 @@
 
     Buffer buffer = new Buffer();
     operator.read(0, buffer, 5);
-    assertEquals("Hello", buffer.readUtf8());
+    assertThat(buffer.readUtf8()).isEqualTo("Hello");
 
     operator.read(4, buffer, 5);
-    assertEquals("o, Wo", buffer.readUtf8());
+    assertThat(buffer.readUtf8()).isEqualTo("o, Wo");
   }
 
   @Test public void write() throws Exception {
@@ -66,13 +66,13 @@
 
     Buffer buffer1 = new Buffer().writeUtf8("Hello, World");
     operator.write(0, buffer1, 5);
-    assertEquals(", World", buffer1.readUtf8());
+    assertThat(buffer1.readUtf8()).isEqualTo(", World");
 
     Buffer buffer2 = new Buffer().writeUtf8("icopter!");
     operator.write(3, buffer2, 7);
-    assertEquals("!", buffer2.readUtf8());
+    assertThat(buffer2.readUtf8()).isEqualTo("!");
 
-    assertEquals(ByteString.encodeUtf8("Helicopter"), snapshot());
+    assertThat(snapshot()).isEqualTo(ByteString.encodeUtf8("Helicopter"));
   }
 
   @Test public void readAndWrite() throws Exception {
@@ -99,12 +99,12 @@
     operator.read(4, buffer, 19);
     operator.write(80, buffer, buffer.size());
 
-    assertEquals(snapshot(), ByteString.encodeUtf8(""
+    assertThat(ByteString.encodeUtf8(""
         + "god creates dinosaurs. "
         + "god destroys dinosaurs. "
         + "god creates man. "
         + "man destroys god. "
-        + "man creates dinosaurs. "));
+        + "man creates dinosaurs. ")).isEqualTo(snapshot());
   }
 
   @Test public void multipleOperatorsShareOneFile() throws Exception {
@@ -124,13 +124,13 @@
     operatorA.write(36, bufferA, 33);
 
     operatorB.read(0, bufferB, 9);
-    assertEquals("Dodgson!\n", bufferB.readUtf8());
+    assertThat(bufferB.readUtf8()).isEqualTo("Dodgson!\n");
 
     operatorA.read(9, bufferA, 27);
-    assertEquals("You shouldn't use my name.\n", bufferA.readUtf8());
+    assertThat(bufferA.readUtf8()).isEqualTo("You shouldn't use my name.\n");
 
     operatorB.read(36, bufferB, 33);
-    assertEquals("Dodgson, we've got Dodgson here!\n", bufferB.readUtf8());
+    assertThat(bufferB.readUtf8()).isEqualTo("Dodgson, we've got Dodgson here!\n");
   }
 
   @Test public void largeRead() throws Exception {
@@ -141,7 +141,7 @@
 
     Buffer buffer = new Buffer();
     operator.read(0, buffer, data.size());
-    assertEquals(data, buffer.readByteString());
+    assertThat(buffer.readByteString()).isEqualTo(data);
   }
 
   @Test public void largeWrite() throws Exception {
@@ -152,7 +152,7 @@
     Buffer buffer = new Buffer().write(data);
     operator.write(0, buffer, data.size());
 
-    assertEquals(data, snapshot());
+    assertThat(snapshot()).isEqualTo(data);
   }
 
   @Test public void readBounds() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java b/okhttp/src/test/java/okhttp3/internal/cache2/RelayTest.java
similarity index 69%
rename from okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
rename to okhttp/src/test/java/okhttp3/internal/cache2/RelayTest.java
index 8ed0c911f7..5e3911899f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/cache2/RelayTest.java
@@ -34,10 +34,7 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class RelayTest {
@@ -63,17 +60,17 @@
     Source source = relay.newSource();
     Buffer sourceBuffer = new Buffer();
 
-    assertEquals(5, source.read(sourceBuffer, 5));
-    assertEquals("abcde", sourceBuffer.readUtf8());
+    assertThat(source.read(sourceBuffer, 5)).isEqualTo(5);
+    assertThat(sourceBuffer.readUtf8()).isEqualTo("abcde");
 
-    assertEquals(8, source.read(sourceBuffer, 1024));
-    assertEquals("fghijklm", sourceBuffer.readUtf8());
+    assertThat(source.read(sourceBuffer, 1024)).isEqualTo(8);
+    assertThat(sourceBuffer.readUtf8()).isEqualTo("fghijklm");
 
-    assertEquals(-1, source.read(sourceBuffer, 1024));
-    assertEquals(0, sourceBuffer.size());
+    assertThat(source.read(sourceBuffer, 1024)).isEqualTo(-1);
+    assertThat(sourceBuffer.size()).isEqualTo(0);
 
     source.close();
-    assertTrue(relay.isClosed());
+    assertThat(relay.isClosed()).isTrue();
     assertFile(Relay.PREFIX_CLEAN, 13L, metadata.size(), "abcdefghijklm", metadata);
   }
 
@@ -85,11 +82,11 @@
     BufferedSource source1 = Okio.buffer(relay.newSource());
     BufferedSource source2 = Okio.buffer(relay.newSource());
 
-    assertEquals("abcdefghijklm", source1.readUtf8());
-    assertEquals("abcdefghijklm", source2.readUtf8());
+    assertThat(source1.readUtf8()).isEqualTo("abcdefghijklm");
+    assertThat(source2.readUtf8()).isEqualTo("abcdefghijklm");
     source1.close();
     source2.close();
-    assertTrue(relay.isClosed());
+    assertThat(relay.isClosed()).isTrue();
 
     assertFile(Relay.PREFIX_CLEAN, 13L, metadata.size(), "abcdefghijklm", metadata);
   }
@@ -102,15 +99,15 @@
     BufferedSource source1 = Okio.buffer(relay.newSource());
     BufferedSource source2 = Okio.buffer(relay.newSource());
 
-    assertEquals("abcde", source1.readUtf8(5));
-    assertEquals("abcde", source2.readUtf8(5));
-    assertEquals("fghij", source2.readUtf8(5));
-    assertEquals("fghij", source1.readUtf8(5));
-    assertTrue(source1.exhausted());
-    assertTrue(source2.exhausted());
+    assertThat(source1.readUtf8(5)).isEqualTo("abcde");
+    assertThat(source2.readUtf8(5)).isEqualTo("abcde");
+    assertThat(source2.readUtf8(5)).isEqualTo("fghij");
+    assertThat(source1.readUtf8(5)).isEqualTo("fghij");
+    assertThat(source1.exhausted()).isTrue();
+    assertThat(source2.exhausted()).isTrue();
     source1.close();
     source2.close();
-    assertTrue(relay.isClosed());
+    assertThat(relay.isClosed()).isTrue();
 
     assertFile(Relay.PREFIX_CLEAN, 10L, metadata.size(), "abcdefghij", metadata);
   }
@@ -123,15 +120,15 @@
     BufferedSource source1 = Okio.buffer(relay.newSource());
     BufferedSource source2 = Okio.buffer(relay.newSource());
 
-    assertEquals("abcdefghij", source1.readUtf8(10));
-    assertEquals("abcdefghij", source2.readUtf8(10));
-    assertEquals("klmnopqrst", source2.readUtf8(10));
-    assertEquals("klmnopqrst", source1.readUtf8(10));
-    assertTrue(source1.exhausted());
-    assertTrue(source2.exhausted());
+    assertThat(source1.readUtf8(10)).isEqualTo("abcdefghij");
+    assertThat(source2.readUtf8(10)).isEqualTo("abcdefghij");
+    assertThat(source2.readUtf8(10)).isEqualTo("klmnopqrst");
+    assertThat(source1.readUtf8(10)).isEqualTo("klmnopqrst");
+    assertThat(source1.exhausted()).isTrue();
+    assertThat(source2.exhausted()).isTrue();
     source1.close();
     source2.close();
-    assertTrue(relay.isClosed());
+    assertThat(relay.isClosed()).isTrue();
 
     assertFile(Relay.PREFIX_CLEAN, 20L, metadata.size(), "abcdefghijklmnopqrst", metadata);
   }
@@ -142,24 +139,24 @@
 
     Relay relay1 = Relay.edit(file, upstream, metadata, 5);
     BufferedSource source1 = Okio.buffer(relay1.newSource());
-    assertEquals("abcdefghij", source1.readUtf8(10));
-    assertTrue(source1.exhausted());
+    assertThat(source1.readUtf8(10)).isEqualTo("abcdefghij");
+    assertThat(source1.exhausted()).isTrue();
     source1.close();
-    assertTrue(relay1.isClosed());
+    assertThat(relay1.isClosed()).isTrue();
 
     // Since relay1 is closed, new sources cannot be created.
-    assertNull(relay1.newSource());
+    assertThat(relay1.newSource()).isNull();
 
     Relay relay2 = Relay.read(file);
-    assertEquals(metadata, relay2.metadata());
+    assertThat(relay2.metadata()).isEqualTo(metadata);
     BufferedSource source2 = Okio.buffer(relay2.newSource());
-    assertEquals("abcdefghij", source2.readUtf8(10));
-    assertTrue(source2.exhausted());
+    assertThat(source2.readUtf8(10)).isEqualTo("abcdefghij");
+    assertThat(source2.exhausted()).isTrue();
     source2.close();
-    assertTrue(relay2.isClosed());
+    assertThat(relay2.isClosed()).isTrue();
 
     // Since relay2 is closed, new sources cannot be created.
-    assertNull(relay2.newSource());
+    assertThat(relay2.newSource()).isNull();
 
     assertFile(Relay.PREFIX_CLEAN, 10L, metadata.size(), "abcdefghij", metadata);
   }
@@ -170,15 +167,15 @@
 
     Relay relay1 = Relay.edit(file, upstream, metadata, 5);
     BufferedSource source1 = Okio.buffer(relay1.newSource());
-    assertEquals("abcdefghij", source1.readUtf8(10));
+    assertThat(source1.readUtf8(10)).isEqualTo("abcdefghij");
     source1.close(); // Not exhausted!
-    assertTrue(relay1.isClosed());
+    assertThat(relay1.isClosed()).isTrue();
 
     try {
       Relay.read(file);
       fail();
     } catch (IOException expected) {
-      assertEquals("unreadable cache file", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("unreadable cache file");
     }
 
     assertFile(Relay.PREFIX_DIRTY, -1L, -1, null, null);
@@ -194,10 +191,10 @@
 
     source1.close();
     source1.close(); // Unnecessary. Shouldn't decrement the reference count.
-    assertFalse(relay.isClosed());
+    assertThat(relay.isClosed()).isFalse();
 
     source2.close();
-    assertTrue(relay.isClosed());
+    assertThat(relay.isClosed()).isTrue();
     assertFile(Relay.PREFIX_DIRTY, -1L, -1, null, null);
   }
 
@@ -217,10 +214,10 @@
     sink.writeUtf8("klmnopqrst");
     sink.close();
 
-    assertEquals(ByteString.encodeUtf8("abcdefghijklmnopqrst"), future1.get());
-    assertEquals(ByteString.encodeUtf8("abcdefghijklmnopqrst"), future2.get());
+    assertThat(future1.get()).isEqualTo(ByteString.encodeUtf8("abcdefghijklmnopqrst"));
+    assertThat(future2.get()).isEqualTo(ByteString.encodeUtf8("abcdefghijklmnopqrst"));
 
-    assertTrue(relay.isClosed());
+    assertThat(relay.isClosed()).isTrue();
 
     assertFile(Relay.PREFIX_CLEAN, 20L, metadata.size(), "abcdefghijklmnopqrst", metadata);
   }
@@ -239,14 +236,14 @@
   private void assertFile(ByteString prefix, long upstreamSize, int metadataSize, String upstream,
       ByteString metadata) throws IOException {
     BufferedSource source = Okio.buffer(Okio.source(file));
-    assertEquals(prefix, source.readByteString(prefix.size()));
-    assertEquals(upstreamSize, source.readLong());
-    assertEquals(metadataSize, source.readLong());
+    assertThat(source.readByteString(prefix.size())).isEqualTo(prefix);
+    assertThat(source.readLong()).isEqualTo(upstreamSize);
+    assertThat(source.readLong()).isEqualTo(metadataSize);
     if (upstream != null) {
-      assertEquals(upstream, source.readUtf8(upstreamSize));
+      assertThat(source.readUtf8(upstreamSize)).isEqualTo(upstream);
     }
     if (metadata != null) {
-      assertEquals(metadata, source.readByteString(metadataSize));
+      assertThat(source.readByteString(metadataSize)).isEqualTo(metadata);
     }
     source.close();
   }
diff --git a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
new file mode 100644
index 0000000000..8140a62d32
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.Socket;
+import java.util.Collections;
+import java.util.concurrent.TimeUnit;
+import javax.net.SocketFactory;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.ConnectionPool;
+import okhttp3.Dns;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Route;
+import okhttp3.internal.Internal;
+import okhttp3.internal.RecordingOkAuthenticator;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.awaitGarbageCollection;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ConnectionPoolTest {
+  private final Address addressA = newAddress("a");
+  private final Route routeA1 = newRoute(addressA);
+  private final Address addressB = newAddress("b");
+  private final Route routeB1 = newRoute(addressB);
+  private final Address addressC = newAddress("c");
+  private final Route routeC1 = newRoute(addressC);
+
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
+  @Test public void connectionsEvictedWhenIdleLongEnough() throws Exception {
+    RealConnectionPool pool = new RealConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    pool.setCleanupRunning(true); // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 50L);
+
+    // Running at time 50, the pool returns that nothing can be evicted until time 150.
+    assertThat(pool.cleanup(50L)).isEqualTo(100L);
+    assertThat(pool.connectionCount()).isEqualTo(1);
+    assertThat(c1.socket().isClosed()).isFalse();
+
+    // Running at time 60, the pool returns that nothing can be evicted until time 150.
+    assertThat(pool.cleanup(60L)).isEqualTo(90L);
+    assertThat(pool.connectionCount()).isEqualTo(1);
+    assertThat(c1.socket().isClosed()).isFalse();
+
+    // Running at time 149, the pool returns that nothing can be evicted until time 150.
+    assertThat(pool.cleanup(149L)).isEqualTo(1L);
+    assertThat(pool.connectionCount()).isEqualTo(1);
+    assertThat(c1.socket().isClosed()).isFalse();
+
+    // Running at time 150, the pool evicts.
+    assertThat(pool.cleanup(150L)).isEqualTo(0);
+    assertThat(pool.connectionCount()).isEqualTo(0);
+    assertThat(c1.socket().isClosed()).isTrue();
+
+    // Running again, the pool reports that no further runs are necessary.
+    assertThat(pool.cleanup(150L)).isEqualTo(-1);
+    assertThat(pool.connectionCount()).isEqualTo(0);
+    assertThat(c1.socket().isClosed()).isTrue();
+  }
+
+  @Test public void inUseConnectionsNotEvicted() throws Exception {
+    ConnectionPool poolApi = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    RealConnectionPool pool = Internal.instance.realConnectionPool(poolApi);
+    pool.setCleanupRunning(true); // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 50L);
+    synchronized (pool) {
+      OkHttpClient client = new OkHttpClient.Builder()
+          .connectionPool(poolApi)
+          .build();
+      Call call = client.newCall(newRequest(addressA));
+      Transmitter transmitter = new Transmitter(client, call);
+      transmitter.prepareToConnect(call.request());
+      transmitter.acquireConnectionNoEvents(c1);
+    }
+
+    // Running at time 50, the pool returns that nothing can be evicted until time 150.
+    assertThat(pool.cleanup(50L)).isEqualTo(100L);
+    assertThat(pool.connectionCount()).isEqualTo(1);
+    assertThat(c1.socket().isClosed()).isFalse();
+
+    // Running at time 60, the pool returns that nothing can be evicted until time 160.
+    assertThat(pool.cleanup(60L)).isEqualTo(100L);
+    assertThat(pool.connectionCount()).isEqualTo(1);
+    assertThat(c1.socket().isClosed()).isFalse();
+
+    // Running at time 160, the pool returns that nothing can be evicted until time 260.
+    assertThat(pool.cleanup(160L)).isEqualTo(100L);
+    assertThat(pool.connectionCount()).isEqualTo(1);
+    assertThat(c1.socket().isClosed()).isFalse();
+  }
+
+  @Test public void cleanupPrioritizesEarliestEviction() throws Exception {
+    RealConnectionPool pool = new RealConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    pool.setCleanupRunning(true); // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 75L);
+    RealConnection c2 = newConnection(pool, routeB1, 50L);
+
+    // Running at time 75, the pool returns that nothing can be evicted until time 150.
+    assertThat(pool.cleanup(75L)).isEqualTo(75L);
+    assertThat(pool.connectionCount()).isEqualTo(2);
+
+    // Running at time 149, the pool returns that nothing can be evicted until time 150.
+    assertThat(pool.cleanup(149L)).isEqualTo(1L);
+    assertThat(pool.connectionCount()).isEqualTo(2);
+
+    // Running at time 150, the pool evicts c2.
+    assertThat(pool.cleanup(150L)).isEqualTo(0L);
+    assertThat(pool.connectionCount()).isEqualTo(1);
+    assertThat(c1.socket().isClosed()).isFalse();
+    assertThat(c2.socket().isClosed()).isTrue();
+
+    // Running at time 150, the pool returns that nothing can be evicted until time 175.
+    assertThat(pool.cleanup(150L)).isEqualTo(25L);
+    assertThat(pool.connectionCount()).isEqualTo(1);
+
+    // Running at time 175, the pool evicts c1.
+    assertThat(pool.cleanup(175L)).isEqualTo(0L);
+    assertThat(pool.connectionCount()).isEqualTo(0);
+    assertThat(c1.socket().isClosed()).isTrue();
+    assertThat(c2.socket().isClosed()).isTrue();
+  }
+
+  @Test public void oldestConnectionsEvictedIfIdleLimitExceeded() throws Exception {
+    RealConnectionPool pool = new RealConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
+    pool.setCleanupRunning(true); // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 50L);
+    RealConnection c2 = newConnection(pool, routeB1, 75L);
+
+    // With 2 connections, there's no need to evict until the connections time out.
+    assertThat(pool.cleanup(100L)).isEqualTo(50L);
+    assertThat(pool.connectionCount()).isEqualTo(2);
+    assertThat(c1.socket().isClosed()).isFalse();
+    assertThat(c2.socket().isClosed()).isFalse();
+
+    // Add a third connection
+    RealConnection c3 = newConnection(pool, routeC1, 75L);
+
+    // The third connection bounces the first.
+    assertThat(pool.cleanup(100L)).isEqualTo(0L);
+    assertThat(pool.connectionCount()).isEqualTo(2);
+    assertThat(c1.socket().isClosed()).isTrue();
+    assertThat(c2.socket().isClosed()).isFalse();
+    assertThat(c3.socket().isClosed()).isFalse();
+  }
+
+  @Test public void leakedAllocation() throws Exception {
+    ConnectionPool poolApi = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    RealConnectionPool pool = Internal.instance.realConnectionPool(poolApi);
+    pool.setCleanupRunning(true); // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 0L);
+    allocateAndLeakAllocation(poolApi, c1);
+
+    awaitGarbageCollection();
+    assertThat(pool.cleanup(100L)).isEqualTo(0L);
+    assertThat(c1.transmitters).isEmpty();
+
+    // Can't allocate once a leak has been detected.
+    assertThat(c1.noNewExchanges).isTrue();
+  }
+
+  /** Use a helper method so there's no hidden reference remaining on the stack. */
+  private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
+    synchronized (Internal.instance.realConnectionPool(pool)) {
+      OkHttpClient client = new OkHttpClient.Builder()
+          .connectionPool(pool)
+          .build();
+      Call call = client.newCall(newRequest(connection.route().address()));
+      Transmitter transmitter = new Transmitter(client, call);
+      transmitter.prepareToConnect(call.request());
+      transmitter.acquireConnectionNoEvents(connection);
+    }
+  }
+
+  private RealConnection newConnection(RealConnectionPool pool, Route route, long idleAtNanos) {
+    RealConnection result = RealConnection.testConnection(pool, route, new Socket(), idleAtNanos);
+    synchronized (pool) {
+      pool.put(result);
+    }
+    return result;
+  }
+
+  private Address newAddress(String name) {
+    return new Address(name, 1, Dns.SYSTEM, SocketFactory.getDefault(), null, null, null,
+        new RecordingOkAuthenticator("password", null), null, Collections.emptyList(),
+        Collections.emptyList(), ProxySelector.getDefault());
+  }
+
+  private Route newRoute(Address address) {
+    return new Route(address, Proxy.NO_PROXY,
+        InetSocketAddress.createUnresolved(address.url().host(), address.url().port()));
+  }
+
+  private Request newRequest(Address address) {
+    return new Request.Builder()
+        .url(address.url())
+        .build();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
similarity index 89%
rename from okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
rename to okhttp/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
index 25e6b86a4a..ed3c8d304a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
@@ -17,9 +17,6 @@
 
 import java.io.IOException;
 import java.security.cert.CertificateException;
-import java.util.Arrays;
-import java.util.LinkedHashSet;
-import java.util.Set;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocket;
 import okhttp3.ConnectionSpec;
@@ -28,10 +25,9 @@
 import okhttp3.tls.HandshakeCertificates;
 import org.junit.Test;
 
+import static java.util.Arrays.asList;
 import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class ConnectionSpecSelectorTest {
   static {
@@ -52,7 +48,7 @@ public void nonRetryableIOException() throws Exception {
 
     boolean retry = connectionSpecSelector.connectionFailed(
         new IOException("Non-handshake exception"));
-    assertFalse(retry);
+    assertThat(retry).isFalse();
     socket.close();
   }
 
@@ -67,7 +63,7 @@ public void nonRetryableSSLHandshakeException() throws Exception {
         new SSLHandshakeException("Certificate handshake exception");
     trustIssueException.initCause(new CertificateException());
     boolean retry = connectionSpecSelector.connectionFailed(trustIssueException);
-    assertFalse(retry);
+    assertThat(retry).isFalse();
     socket.close();
   }
 
@@ -80,7 +76,7 @@ public void retryableSSLHandshakeException() throws Exception {
     connectionSpecSelector.configureSecureSocket(socket);
 
     boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
-    assertTrue(retry);
+    assertThat(retry).isTrue();
     socket.close();
   }
 
@@ -103,7 +99,7 @@ public void someFallbacksSupported() throws Exception {
     assertEnabledProtocols(socket, TlsVersion.TLS_1_2);
 
     boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
-    assertTrue(retry);
+    assertThat(retry).isTrue();
     socket.close();
 
     // COMPATIBLE_TLS is used here.
@@ -112,7 +108,7 @@ public void someFallbacksSupported() throws Exception {
     assertEnabledProtocols(socket, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
 
     retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
-    assertFalse(retry);
+    assertThat(retry).isFalse();
     socket.close();
 
     // sslV3 is not used because SSLv3 is not enabled on the socket.
@@ -120,7 +116,7 @@ public void someFallbacksSupported() throws Exception {
 
   private static ConnectionSpecSelector createConnectionSpecSelector(
       ConnectionSpec... connectionSpecs) {
-    return new ConnectionSpecSelector(Arrays.asList(connectionSpecs));
+    return new ConnectionSpecSelector(asList(connectionSpecs));
   }
 
   private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) throws IOException {
@@ -130,9 +126,7 @@ private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) th
   }
 
   private static void assertEnabledProtocols(SSLSocket socket, TlsVersion... required) {
-    Set<String> actual = new LinkedHashSet<>(Arrays.asList(socket.getEnabledProtocols()));
-    Set<String> expected = new LinkedHashSet<>(Arrays.asList(javaNames(required)));
-    assertEquals(expected, actual);
+    assertThat(socket.getEnabledProtocols()).containsExactlyInAnyOrder(javaNames(required));
   }
 
   private static String[] javaNames(TlsVersion... tlsVersions) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java b/okhttp/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
similarity index 72%
rename from okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
rename to okhttp/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
index 44e939aaea..bce264a618 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
@@ -18,16 +18,15 @@
 import java.io.IOException;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertSame;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class RouteExceptionTest {
 
   @Test public void getConnectionIOException_single() {
     IOException firstException = new IOException();
     RouteException re = new RouteException(firstException);
-    assertSame(firstException, re.getFirstConnectException());
-    assertSame(firstException, re.getLastConnectException());
+    assertThat(re.getFirstConnectException()).isSameAs(firstException);
+    assertThat(re.getLastConnectException()).isSameAs(firstException);
   }
 
   @Test public void getConnectionIOException_multiple() {
@@ -39,12 +38,12 @@
     re.addConnectException(thirdException);
 
     IOException connectionIOException = re.getFirstConnectException();
-    assertSame(firstException, connectionIOException);
+    assertThat(connectionIOException).isSameAs(firstException);
     Throwable[] suppressedExceptions = connectionIOException.getSuppressed();
-    assertEquals(2, suppressedExceptions.length);
-    assertSame(secondException, suppressedExceptions[0]);
-    assertSame(thirdException, suppressedExceptions[1]);
+    assertThat(suppressedExceptions.length).isEqualTo(2);
+    assertThat(suppressedExceptions[0]).isSameAs(secondException);
+    assertThat(suppressedExceptions[1]).isSameAs(thirdException);
 
-    assertSame(thirdException, re.getLastConnectException());
+    assertThat(re.getLastConnectException()).isSameAs(thirdException);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java b/okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
similarity index 79%
rename from okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
rename to okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
index 6c4a0d2d9a..ead073c6f6 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
@@ -32,11 +32,14 @@
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Address;
 import okhttp3.Authenticator;
+import okhttp3.Call;
 import okhttp3.ConnectionSpec;
 import okhttp3.EventListener;
 import okhttp3.FakeDns;
 import okhttp3.Protocol;
+import okhttp3.Request;
 import okhttp3.Route;
+import okhttp3.TestUtil;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.RecordingProxySelector;
 import okhttp3.tls.HandshakeCertificates;
@@ -45,10 +48,7 @@
 
 import static java.net.Proxy.NO_PROXY;
 import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class RouteSelectorTest {
@@ -68,6 +68,7 @@
   private String uriHost = "hosta";
   private int uriPort = 1003;
 
+  private Call call;
   private SocketFactory socketFactory;
   private final HandshakeCertificates handshakeCertificates = localhost();
   private final SSLSocketFactory sslSocketFactory = handshakeCertificates.sslSocketFactory();
@@ -80,28 +81,31 @@
   private RouteDatabase routeDatabase = new RouteDatabase();
 
   @Before public void setUp() throws Exception {
+    call = TestUtil.defaultClient().newCall(new Request.Builder()
+        .url("https://" + uriHost + ":" + uriPort + "/")
+        .build());
     socketFactory = SocketFactory.getDefault();
     hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
   }
 
   @Test public void singleRoute() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(uriHost, dns.allocate(1));
     RouteSelector.Selection selection = routeSelector.next();
     assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
-    assertFalse(selection.hasNext());
+    assertThat(selection.hasNext()).isFalse();
     try {
       selection.next();
       fail();
     } catch (NoSuchElementException expected) {
     }
 
-    assertFalse(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isFalse();
     try {
       routeSelector.next();
       fail();
@@ -111,18 +115,18 @@
 
   @Test public void singleRouteReturnsFailedRoute() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(uriHost, dns.allocate(1));
     RouteSelector.Selection selection = routeSelector.next();
     Route route = selection.next();
     routeDatabase.failed(route);
-    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
+    routeSelector = new RouteSelector(address, routeDatabase, call, EventListener.NONE);
     selection = routeSelector.next();
     assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    assertFalse(selection.hasNext());
+    assertThat(selection.hasNext()).isFalse();
 
     try {
       selection.next();
@@ -130,7 +134,7 @@
     } catch (NoSuchElementException expected) {
     }
 
-    assertFalse(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isFalse();
     try {
       routeSelector.next();
       fail();
@@ -141,17 +145,17 @@
   @Test public void explicitProxyTriesThatProxysAddressesOnly() throws Exception {
     Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
         authenticator, proxyA, protocols, connectionSpecs, proxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(proxyAHost, dns.allocate(2));
     RouteSelector.Selection selection = routeSelector.next();
     assertRoute(selection.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     assertRoute(selection.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
 
-    assertFalse(selection.hasNext());
-    assertFalse(routeSelector.hasNext());
+    assertThat(selection.hasNext()).isFalse();
+    assertThat(routeSelector.hasNext()).isFalse();
     dns.assertRequests(proxyAHost);
     proxySelector.assertRequests(); // No proxy selector requests!
   }
@@ -159,17 +163,17 @@
   @Test public void explicitDirectProxy() throws Exception {
     Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
         authenticator, NO_PROXY, protocols, connectionSpecs, proxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(uriHost, dns.allocate(2));
     RouteSelector.Selection selection = routeSelector.next();
     assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
 
-    assertFalse(selection.hasNext());
-    assertFalse(routeSelector.hasNext());
+    assertThat(selection.hasNext()).isFalse();
+    assertThat(routeSelector.hasNext()).isFalse();
     dns.assertRequests(uriHost);
     proxySelector.assertRequests(); // No proxy selector requests!
   }
@@ -177,7 +181,7 @@
   @Test public void proxySelectorReturnsNull() throws Exception {
     ProxySelector nullProxySelector = new ProxySelector() {
       @Override public List<Proxy> select(URI uri) {
-        assertEquals(uriHost, uri.getHost());
+        assertThat(uri.getHost()).isEqualTo(uriHost);
         return null;
       }
 
@@ -189,31 +193,31 @@
 
     Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, nullProxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(uriHost, dns.allocate(1));
     RouteSelector.Selection selection = routeSelector.next();
     assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
 
-    assertFalse(selection.hasNext());
-    assertFalse(routeSelector.hasNext());
+    assertThat(selection.hasNext()).isFalse();
+    assertThat(routeSelector.hasNext()).isFalse();
   }
 
   @Test public void proxySelectorReturnsNoProxies() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(uriHost, dns.allocate(2));
     RouteSelector.Selection selection = routeSelector.next();
     assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
 
-    assertFalse(selection.hasNext());
-    assertFalse(routeSelector.hasNext());
+    assertThat(selection.hasNext()).isFalse();
+    assertThat(routeSelector.hasNext()).isFalse();
     dns.assertRequests(uriHost);
     proxySelector.assertRequests(address.url().uri());
   }
@@ -223,48 +227,48 @@
 
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
     proxySelector.assertRequests(address.url().uri());
 
     // First try the IP addresses of the first proxy, in sequence.
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(proxyAHost, dns.allocate(2));
     RouteSelector.Selection selection1 = routeSelector.next();
     assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
     dns.assertRequests(proxyAHost);
-    assertFalse(selection1.hasNext());
+    assertThat(selection1.hasNext()).isFalse();
 
     // Next try the IP address of the second proxy.
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(proxyBHost, dns.allocate(1));
     RouteSelector.Selection selection2 = routeSelector.next();
     assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
     dns.assertRequests(proxyBHost);
-    assertFalse(selection2.hasNext());
+    assertThat(selection2.hasNext()).isFalse();
 
     // No more proxies to try.
-    assertFalse(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isFalse();
   }
 
   @Test public void proxySelectorDirectConnectionsAreSkipped() throws Exception {
     Address address = httpAddress();
 
     proxySelector.proxies.add(NO_PROXY);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
     proxySelector.assertRequests(address.url().uri());
 
     // Only the origin server will be attempted.
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(uriHost, dns.allocate(1));
     RouteSelector.Selection selection = routeSelector.next();
     assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
 
-    assertFalse(selection.hasNext());
-    assertFalse(routeSelector.hasNext());
+    assertThat(selection.hasNext()).isFalse();
+    assertThat(routeSelector.hasNext()).isFalse();
   }
 
   @Test public void proxyDnsFailureContinuesToNextProxy() throws Exception {
@@ -273,18 +277,18 @@
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
     proxySelector.proxies.add(proxyA);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
     proxySelector.assertRequests(address.url().uri());
 
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(proxyAHost, dns.allocate(1));
     RouteSelector.Selection selection1 = routeSelector.next();
     assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
-    assertFalse(selection1.hasNext());
+    assertThat(selection1.hasNext()).isFalse();
 
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.clear(proxyBHost);
     try {
       routeSelector.next();
@@ -293,21 +297,21 @@
     }
     dns.assertRequests(proxyBHost);
 
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(proxyAHost, dns.allocate(1));
     RouteSelector.Selection selection2 = routeSelector.next();
     assertRoute(selection2.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
 
-    assertFalse(selection2.hasNext());
-    assertFalse(routeSelector.hasNext());
+    assertThat(selection2.hasNext()).isFalse();
+    assertThat(routeSelector.hasNext()).isFalse();
   }
 
   @Test public void multipleProxiesMultipleInetAddressesMultipleConfigurations() throws Exception {
     Address address = httpsAddress();
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
     // Proxy A
@@ -316,7 +320,7 @@
     assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
     assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
-    assertFalse(selection1.hasNext());
+    assertThat(selection1.hasNext()).isFalse();
 
     // Proxy B
     dns.set(proxyBHost, dns.allocate(2));
@@ -324,15 +328,15 @@
     assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
     dns.assertRequests(proxyBHost);
     assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 1), proxyBPort);
-    assertFalse(selection2.hasNext());
+    assertThat(selection2.hasNext()).isFalse();
 
     // No more proxies to attempt.
-    assertFalse(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isFalse();
   }
 
   @Test public void failedRouteWithSingleProxy() throws Exception {
     Address address = httpsAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
     final int numberOfAddresses = 2;
@@ -343,30 +347,30 @@
     List<Route> regularRoutes = selection1.getAll();
 
     // Check that we do indeed have more than one route.
-    assertEquals(numberOfAddresses, regularRoutes.size());
+    assertThat(regularRoutes.size()).isEqualTo(numberOfAddresses);
     // Add first regular route as failed.
     routeDatabase.failed(regularRoutes.get(0));
     // Reset selector
-    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
+    routeSelector = new RouteSelector(address, routeDatabase, call, EventListener.NONE);
 
     // The first selection prioritizes the non-failed routes.
     RouteSelector.Selection selection2 = routeSelector.next();
-    assertEquals(regularRoutes.get(1), selection2.next());
-    assertFalse(selection2.hasNext());
+    assertThat(selection2.next()).isEqualTo(regularRoutes.get(1));
+    assertThat(selection2.hasNext()).isFalse();
 
     // The second selection will contain all failed routes.
     RouteSelector.Selection selection3 = routeSelector.next();
-    assertEquals(regularRoutes.get(0), selection3.next());
-    assertFalse(selection3.hasNext());
+    assertThat(selection3.next()).isEqualTo(regularRoutes.get(0));
+    assertThat(selection3.hasNext()).isFalse();
 
-    assertFalse(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isFalse();
   }
 
   @Test public void failedRouteWithMultipleProxies() throws IOException {
     Address address = httpsAddress();
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
     dns.set(proxyAHost, dns.allocate(1));
@@ -379,26 +383,26 @@
     assertRoute(route, address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     routeDatabase.failed(route);
 
-    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
+    routeSelector = new RouteSelector(address, routeDatabase, call, EventListener.NONE);
 
     // Confirm we enumerate both proxies, giving preference to the route from ProxyB.
     RouteSelector.Selection selection2 = routeSelector.next();
     dns.assertRequests(proxyAHost, proxyBHost);
     assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
-    assertFalse(selection2.hasNext());
+    assertThat(selection2.hasNext()).isFalse();
 
     // Confirm the last selection contains the postponed route from ProxyA.
     RouteSelector.Selection selection3 = routeSelector.next();
     dns.assertRequests();
     assertRoute(selection3.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    assertFalse(selection3.hasNext());
+    assertThat(selection3.hasNext()).isFalse();
 
-    assertFalse(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isFalse();
   }
 
   @Test public void queryForAllSelectedRoutes() throws IOException {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
     dns.set(uriHost, dns.allocate(2));
@@ -409,42 +413,42 @@
     assertRoute(routes.get(0), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     assertRoute(routes.get(1), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
 
-    assertSame(routes.get(0), selection.next());
-    assertSame(routes.get(1), selection.next());
-    assertFalse(selection.hasNext());
-    assertFalse(routeSelector.hasNext());
+    assertThat(selection.next()).isSameAs(routes.get(0));
+    assertThat(selection.next()).isSameAs(routes.get(1));
+    assertThat(selection.hasNext()).isFalse();
+    assertThat(routeSelector.hasNext()).isFalse();
   }
 
   @Test public void getHostString() throws Exception {
     // Name proxy specification.
     InetSocketAddress socketAddress = InetSocketAddress.createUnresolved("host", 1234);
-    assertEquals("host", RouteSelector.getHostString(socketAddress));
+    assertThat(RouteSelector.getHostString(socketAddress)).isEqualTo("host");
     socketAddress = InetSocketAddress.createUnresolved("127.0.0.1", 1234);
-    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+    assertThat(RouteSelector.getHostString(socketAddress)).isEqualTo("127.0.0.1");
 
     // InetAddress proxy specification.
     socketAddress = new InetSocketAddress(InetAddress.getByName("localhost"), 1234);
-    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+    assertThat(RouteSelector.getHostString(socketAddress)).isEqualTo("127.0.0.1");
     socketAddress = new InetSocketAddress(
         InetAddress.getByAddress(new byte[] {127, 0, 0, 1}), 1234);
-    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+    assertThat(RouteSelector.getHostString(socketAddress)).isEqualTo("127.0.0.1");
     socketAddress = new InetSocketAddress(
         InetAddress.getByAddress("foobar", new byte[] {127, 0, 0, 1}), 1234);
-    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+    assertThat(RouteSelector.getHostString(socketAddress)).isEqualTo("127.0.0.1");
   }
 
   @Test public void routeToString() throws Exception {
     Route route = new Route(httpAddress(), Proxy.NO_PROXY,
         InetSocketAddress.createUnresolved("host", 1234));
-    assertEquals("Route{host:1234}", route.toString());
+    assertThat(route.toString()).isEqualTo("Route{host:1234}");
   }
 
   private void assertRoute(Route route, Address address, Proxy proxy, InetAddress socketAddress,
       int socketPort) {
-    assertEquals(address, route.address());
-    assertEquals(proxy, route.proxy());
-    assertEquals(socketAddress, route.socketAddress().getAddress());
-    assertEquals(socketPort, route.socketAddress().getPort());
+    assertThat(route.address()).isEqualTo(address);
+    assertThat(route.proxy()).isEqualTo(proxy);
+    assertThat(route.socketAddress().getAddress()).isEqualTo(socketAddress);
+    assertThat(route.socketAddress().getPort()).isEqualTo(socketPort);
   }
 
   /** Returns an address that's without an SSL socket factory or hostname verifier. */
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java b/okhttp/src/test/java/okhttp3/internal/http/CancelTest.java
similarity index 62%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
rename to okhttp/src/test/java/okhttp3/internal/http/CancelTest.java
index 0a89a1a567..6f11d320b7 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http/CancelTest.java
@@ -17,27 +17,33 @@
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.HttpURLConnection;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import javax.net.ServerSocketFactory;
 import javax.net.SocketFactory;
+import okhttp3.Call;
 import okhttp3.DelegatingServerSocketFactory;
 import okhttp3.DelegatingSocketFactory;
+import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
+import okhttp3.OkHttpClientTestRule;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okio.Buffer;
+import okio.BufferedSink;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 
-import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.fail;
 
-public final class DisconnectTest {
+public final class CancelTest {
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   // The size of the socket buffers in bytes.
   private static final int SOCKET_BUFFER_SIZE = 256 * 1024;
@@ -57,7 +63,7 @@
             return serverSocket;
           }
         });
-    client = defaultClient().newBuilder()
+    client = clientTestRule.client.newBuilder()
         .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
           @Override protected Socket configureSocket(Socket socket) throws IOException {
             socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
@@ -68,44 +74,51 @@
         .build();
   }
 
-  @Test public void interruptWritingRequestBody() throws Exception {
-    int requestBodySize = 2 * 1024 * 1024; // 2 MiB
-
-    server.enqueue(new MockResponse()
-        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
+  @Test public void cancelWritingRequestBody() throws Exception {
+    server.enqueue(new MockResponse());
     server.start();
 
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
-    disconnectLater(connection, 500);
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new RequestBody() {
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            for (int i = 0; i < 10; i++) {
+              sink.writeByte(0);
+              sink.flush();
+              sleep(100);
+            }
+            fail("Expected connection to be closed");
+          }
+        })
+        .build());
 
-    connection.setDoOutput(true);
-    connection.setFixedLengthStreamingMode(requestBodySize);
-    OutputStream requestBody = connection.getOutputStream();
-    byte[] buffer = new byte[1024];
+    cancelLater(call, 500);
     try {
-      for (int i = 0; i < requestBodySize; i += buffer.length) {
-        requestBody.write(buffer);
-        requestBody.flush();
-      }
-      fail("Expected connection to be closed");
+      call.execute();
+      fail();
     } catch (IOException expected) {
     }
-
-    connection.disconnect();
   }
 
-  @Test public void interruptReadingResponseBody() throws Exception {
-    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
+  @Test public void cancelReadingResponseBody() throws Exception {
+    int responseBodySize = 8 * 1024 * 1024; // 8 MiB.
 
     server.enqueue(new MockResponse()
         .setBody(new Buffer().write(new byte[responseBodySize]))
         .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
     server.start();
 
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
-    disconnectLater(connection, 500);
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
 
-    InputStream responseBody = connection.getInputStream();
+    Response response = call.execute();
+    cancelLater(call, 500);
+    InputStream responseBody = response.body().byteStream();
     byte[] buffer = new byte[1024];
     try {
       while (responseBody.read(buffer) != -1) {
@@ -117,14 +130,18 @@
     responseBody.close();
   }
 
-  private void disconnectLater(HttpURLConnection connection, int delayMillis) {
+  private void sleep(int delayMillis) {
+    try {
+      Thread.sleep(delayMillis);
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+    }
+  }
+
+  private void cancelLater(Call call, int delayMillis) {
     Thread interruptingCow = new Thread(() -> {
-      try {
-        Thread.sleep(delayMillis);
-        connection.disconnect();
-      } catch (InterruptedException e) {
-        throw new RuntimeException(e);
-      }
+      sleep(delayMillis);
+      call.cancel();
     });
     interruptingCow.start();
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java b/okhttp/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
rename to okhttp/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java b/okhttp/src/test/java/okhttp3/internal/http/HttpDateTest.java
similarity index 51%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
rename to okhttp/src/test/java/okhttp3/internal/http/HttpDateTest.java
index 0a22eb0f8a..3d9860da64 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http/HttpDateTest.java
@@ -21,8 +21,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class HttpDateTest {
 
@@ -43,48 +42,51 @@ public void tearDown() throws Exception {
 
   @Test public void parseStandardFormats() throws Exception {
     // RFC 822, updated by RFC 1123 with GMT.
-    assertEquals(0L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT").getTime());
-    assertEquals(1402057830000L, HttpDate.parse("Fri, 06 Jun 2014 12:30:30 GMT").getTime());
+    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT").getTime()).isEqualTo(0L);
+    assertThat(HttpDate.parse("Fri, 06 Jun 2014 12:30:30 GMT").getTime()).isEqualTo(1402057830000L);
 
     // RFC 850, obsoleted by RFC 1036 with GMT.
-    assertEquals(0L, HttpDate.parse("Thursday, 01-Jan-70 00:00:00 GMT").getTime());
-    assertEquals(1402057830000L, HttpDate.parse("Friday, 06-Jun-14 12:30:30 GMT").getTime());
+    assertThat(HttpDate.parse("Thursday, 01-Jan-70 00:00:00 GMT").getTime()).isEqualTo(0L);
+    assertThat(HttpDate.parse("Friday, 06-Jun-14 12:30:30 GMT").getTime()).isEqualTo(1402057830000L);
 
     // ANSI C's asctime(): should use GMT, not platform default.
-    assertEquals(0L, HttpDate.parse("Thu Jan 1 00:00:00 1970").getTime());
-    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014").getTime());
+    assertThat(HttpDate.parse("Thu Jan 1 00:00:00 1970").getTime()).isEqualTo(0L);
+    assertThat(HttpDate.parse("Fri Jun 6 12:30:30 2014").getTime()).isEqualTo(1402057830000L);
   }
 
   @Test public void format() throws Exception {
-    assertEquals("Thu, 01 Jan 1970 00:00:00 GMT", HttpDate.format(new Date(0)));
-    assertEquals("Fri, 06 Jun 2014 12:30:30 GMT", HttpDate.format(new Date(1402057830000L)));
+    assertThat(HttpDate.format(new Date(0))).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT");
+    assertThat(HttpDate.format(new Date(1402057830000L))).isEqualTo(
+        "Fri, 06 Jun 2014 12:30:30 GMT");
   }
 
   @Test public void parseNonStandardStrings() throws Exception {
     // RFC 822, updated by RFC 1123 with any TZ
-    assertEquals(3600000L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT-01:00").getTime());
-    assertEquals(28800000L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 PST").getTime());
+    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT-01:00").getTime()).isEqualTo(3600000L);
+    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00 PST").getTime()).isEqualTo(28800000L);
     // Ignore trailing junk
-    assertEquals(0L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT JUNK").getTime());
+    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT JUNK").getTime()).isEqualTo(0L);
     // Missing timezones treated as bad.
-    assertNull(HttpDate.parse("Thu, 01 Jan 1970 00:00:00"));
+    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00")).isNull();
     // Missing seconds treated as bad.
-    assertNull(HttpDate.parse("Thu, 01 Jan 1970 00:00 GMT"));
+    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00 GMT")).isNull();
     // Extra spaces treated as bad.
-    assertNull(HttpDate.parse("Thu,  01 Jan 1970 00:00 GMT"));
+    assertThat(HttpDate.parse("Thu,  01 Jan 1970 00:00 GMT")).isNull();
     // Missing leading zero treated as bad.
-    assertNull(HttpDate.parse("Thu, 1 Jan 1970 00:00 GMT"));
+    assertThat(HttpDate.parse("Thu, 1 Jan 1970 00:00 GMT")).isNull();
 
     // RFC 850, obsoleted by RFC 1036 with any TZ.
-    assertEquals(3600000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 GMT-01:00").getTime());
-    assertEquals(28800000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST").getTime());
+    assertThat(HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 GMT-01:00").getTime()).isEqualTo(
+        3600000L);
+    assertThat(HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST").getTime()).isEqualTo(28800000L);
     // Ignore trailing junk
-    assertEquals(28800000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST JUNK").getTime());
+    assertThat(HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST JUNK").getTime()).isEqualTo(
+        28800000L);
 
     // ANSI C's asctime() format
     // This format ignores the timezone entirely even if it is present and uses GMT.
-    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014 PST").getTime());
+    assertThat(HttpDate.parse("Fri Jun 6 12:30:30 2014 PST").getTime()).isEqualTo(1402057830000L);
     // Ignore trailing junk.
-    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014 JUNK").getTime());
+    assertThat(HttpDate.parse("Fri Jun 6 12:30:30 2014 JUNK").getTime()).isEqualTo(1402057830000L);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java b/okhttp/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
similarity index 92%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
rename to okhttp/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
index fb37e7e491..3f1698d503 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
+++ b/okhttp/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
@@ -22,11 +22,10 @@
 import java.net.SocketAddress;
 import java.net.URI;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 import okhttp3.internal.Util;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class RecordingProxySelector extends ProxySelector {
   public final List<Proxy> proxies = new ArrayList<>();
@@ -39,7 +38,7 @@
   }
 
   public void assertRequests(URI... expectedUris) {
-    assertEquals(Arrays.asList(expectedUris), requestedUris);
+    assertThat(requestedUris).containsExactly(expectedUris);
     requestedUris.clear();
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java b/okhttp/src/test/java/okhttp3/internal/http/StatusLineTest.java
similarity index 81%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
rename to okhttp/src/test/java/okhttp3/internal/http/StatusLineTest.java
index 6eb1aa8b12..08e002de7e 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http/StatusLineTest.java
@@ -20,7 +20,7 @@
 import okhttp3.Protocol;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class StatusLineTest {
@@ -29,18 +29,18 @@
     int version = 1;
     int code = 200;
     StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code + " " + message);
-    assertEquals(message, statusLine.message);
-    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
-    assertEquals(code, statusLine.code);
+    assertThat(statusLine.message).isEqualTo(message);
+    assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_1);
+    assertThat(statusLine.code).isEqualTo(code);
   }
 
   @Test public void emptyMessage() throws IOException {
     int version = 1;
     int code = 503;
     StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code + " ");
-    assertEquals("", statusLine.message);
-    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
-    assertEquals(code, statusLine.code);
+    assertThat(statusLine.message).isEqualTo("");
+    assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_1);
+    assertThat(statusLine.code).isEqualTo(code);
   }
 
   /**
@@ -51,17 +51,17 @@
     int version = 1;
     int code = 503;
     StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code);
-    assertEquals("", statusLine.message);
-    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
-    assertEquals(code, statusLine.code);
+    assertThat(statusLine.message).isEqualTo("");
+    assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_1);
+    assertThat(statusLine.code).isEqualTo(code);
   }
 
   // https://github.com/square/okhttp/issues/386
   @Test public void shoutcast() throws IOException {
     StatusLine statusLine = StatusLine.parse("ICY 200 OK");
-    assertEquals("OK", statusLine.message);
-    assertEquals(Protocol.HTTP_1_0, statusLine.protocol);
-    assertEquals(200, statusLine.code);
+    assertThat(statusLine.message).isEqualTo("OK");
+    assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_0);
+    assertThat(statusLine.code).isEqualTo(200);
   }
 
   @Test public void missingProtocol() throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java b/okhttp/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
similarity index 63%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
rename to okhttp/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
index 8926e10c31..86364052f6 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
@@ -17,35 +17,40 @@
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.InterruptedIOException;
-import java.io.OutputStream;
-import java.net.HttpURLConnection;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import javax.net.ServerSocketFactory;
 import javax.net.SocketFactory;
+import okhttp3.Call;
 import okhttp3.DelegatingServerSocketFactory;
 import okhttp3.DelegatingSocketFactory;
+import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
+import okhttp3.OkHttpClientTestRule;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okio.Buffer;
+import okio.BufferedSink;
+import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 
-import static okhttp3.TestUtil.defaultClient;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class ThreadInterruptTest {
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   // The size of the socket buffers in bytes.
   private static final int SOCKET_BUFFER_SIZE = 256 * 1024;
 
   private MockWebServer server;
-  private OkHttpClient client;
+  private OkHttpClient client = clientTestRule.client;
 
   @Before public void setUp() throws Exception {
     // Sockets on some platforms can have large buffers that mean writes do not block when
@@ -60,7 +65,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
             return serverSocket;
           }
         });
-    client = defaultClient().newBuilder()
+    client = clientTestRule.client.newBuilder()
         .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
           @Override
           protected Socket configureSocket(Socket socket) throws IOException {
@@ -72,66 +77,79 @@ protected Socket configureSocket(Socket socket) throws IOException {
         .build();
   }
 
-  @Test public void interruptWritingRequestBody() throws Exception {
-    int requestBodySize = 2 * 1024 * 1024; // 2 MiB
+  @After public void tearDown() throws Exception {
+    Thread.interrupted(); // Clear interrupted state.
+  }
 
-    server.enqueue(new MockResponse()
-        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
+  @Test public void interruptWritingRequestBody() throws Exception {
+    server.enqueue(new MockResponse());
     server.start();
 
-    interruptLater(500);
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new RequestBody() {
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
 
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
-    connection.setDoOutput(true);
-    connection.setFixedLengthStreamingMode(requestBodySize);
-    OutputStream requestBody = connection.getOutputStream();
-    byte[] buffer = new byte[1024];
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            for (int i = 0; i < 10; i++) {
+              sink.writeByte(0);
+              sink.flush();
+              sleep(100);
+            }
+            fail("Expected connection to be closed");
+          }
+        })
+        .build());
+
+    interruptLater(500);
     try {
-      for (int i = 0; i < requestBodySize; i += buffer.length) {
-        requestBody.write(buffer);
-        requestBody.flush();
-      }
-      fail("Expected thread to be interrupted");
-    } catch (InterruptedIOException expected) {
-      assertTrue(Thread.interrupted());
+      call.execute();
+      fail();
+    } catch (IOException expected) {
     }
-
-    connection.disconnect();
   }
 
   @Test public void interruptReadingResponseBody() throws Exception {
-    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
+    int responseBodySize = 8 * 1024 * 1024; // 8 MiB.
 
     server.enqueue(new MockResponse()
         .setBody(new Buffer().write(new byte[responseBodySize]))
         .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
     server.start();
 
-    interruptLater(500);
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
 
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
-    InputStream responseBody = connection.getInputStream();
+    Response response = call.execute();
+    interruptLater(500);
+    InputStream responseBody = response.body().byteStream();
     byte[] buffer = new byte[1024];
     try {
       while (responseBody.read(buffer) != -1) {
       }
-      fail("Expected thread to be interrupted");
-    } catch (InterruptedIOException expected) {
-      assertTrue(Thread.interrupted());
+      fail("Expected connection to be interrupted");
+    } catch (IOException expected) {
     }
 
     responseBody.close();
   }
 
+  private void sleep(int delayMillis) {
+    try {
+      Thread.sleep(delayMillis);
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+    }
+  }
+
   private void interruptLater(int delayMillis) {
     Thread toInterrupt = Thread.currentThread();
     Thread interruptingCow = new Thread(() -> {
-      try {
-        Thread.sleep(delayMillis);
-        toInterrupt.interrupt();
-      } catch (InterruptedException e) {
-        throw new AssertionError(e);
-      }
+      sleep(delayMillis);
+      toInterrupt.interrupt();
     });
     interruptingCow.start();
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java b/okhttp/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
rename to okhttp/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java b/okhttp/src/test/java/okhttp3/internal/http2/FrameLogTest.java
similarity index 58%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java
rename to okhttp/src/test/java/okhttp3/internal/http2/FrameLogTest.java
index 94e5e83581..4ab9ca9340 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/FrameLogTest.java
@@ -16,7 +16,6 @@
 package okhttp3.internal.http2;
 
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 import org.junit.Test;
 
@@ -32,56 +31,56 @@
 import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
 import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
 import static okhttp3.internal.http2.Http2.frameLog;
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class FrameLogTest {
   /** Real stream traffic applied to the log format. */
   @Test public void exampleStream() {
-    assertEquals(">> 0x00000000     5 SETTINGS      ",
-        frameLog(false, 0, 5, TYPE_SETTINGS, FLAG_NONE));
-    assertEquals(">> 0x00000003   100 HEADERS       END_HEADERS",
-        frameLog(false, 3, 100, TYPE_HEADERS, FLAG_END_HEADERS));
-    assertEquals(">> 0x00000003     0 DATA          END_STREAM",
-        frameLog(false, 3, 0, TYPE_DATA, FLAG_END_STREAM));
-    assertEquals("<< 0x00000000    15 SETTINGS      ",
-        frameLog(true, 0, 15, TYPE_SETTINGS, FLAG_NONE));
-    assertEquals(">> 0x00000000     0 SETTINGS      ACK",
-        frameLog(false, 0, 0, TYPE_SETTINGS, FLAG_ACK));
-    assertEquals("<< 0x00000000     0 SETTINGS      ACK",
-        frameLog(true, 0, 0, TYPE_SETTINGS, FLAG_ACK));
-    assertEquals("<< 0x00000003    22 HEADERS       END_HEADERS",
-        frameLog(true, 3, 22, TYPE_HEADERS, FLAG_END_HEADERS));
-    assertEquals("<< 0x00000003   226 DATA          END_STREAM",
-        frameLog(true, 3, 226, TYPE_DATA, FLAG_END_STREAM));
-    assertEquals(">> 0x00000000     8 GOAWAY        ",
-        frameLog(false, 0, 8, TYPE_GOAWAY, FLAG_NONE));
+    assertThat(frameLog(false, 0, 5, TYPE_SETTINGS, FLAG_NONE)).isEqualTo(
+        ">> 0x00000000     5 SETTINGS      ");
+    assertThat(frameLog(false, 3, 100, TYPE_HEADERS, FLAG_END_HEADERS)).isEqualTo(
+        ">> 0x00000003   100 HEADERS       END_HEADERS");
+    assertThat(frameLog(false, 3, 0, TYPE_DATA, FLAG_END_STREAM)).isEqualTo(
+        ">> 0x00000003     0 DATA          END_STREAM");
+    assertThat(frameLog(true, 0, 15, TYPE_SETTINGS, FLAG_NONE)).isEqualTo(
+        "<< 0x00000000    15 SETTINGS      ");
+    assertThat(frameLog(false, 0, 0, TYPE_SETTINGS, FLAG_ACK)).isEqualTo(
+        ">> 0x00000000     0 SETTINGS      ACK");
+    assertThat(frameLog(true, 0, 0, TYPE_SETTINGS, FLAG_ACK)).isEqualTo(
+        "<< 0x00000000     0 SETTINGS      ACK");
+    assertThat(frameLog(true, 3, 22, TYPE_HEADERS, FLAG_END_HEADERS)).isEqualTo(
+        "<< 0x00000003    22 HEADERS       END_HEADERS");
+    assertThat(frameLog(true, 3, 226, TYPE_DATA, FLAG_END_STREAM)).isEqualTo(
+        "<< 0x00000003   226 DATA          END_STREAM");
+    assertThat(frameLog(false, 0, 8, TYPE_GOAWAY, FLAG_NONE)).isEqualTo(
+        ">> 0x00000000     8 GOAWAY        ");
   }
 
   @Test public void flagOverlapOn0x1() {
-    assertEquals("<< 0x00000000     0 SETTINGS      ACK",
-        frameLog(true, 0, 0, TYPE_SETTINGS, (byte) 0x1));
-    assertEquals("<< 0x00000000     8 PING          ACK",
-        frameLog(true, 0, 8, TYPE_PING, (byte) 0x1));
-    assertEquals("<< 0x00000003     0 HEADERS       END_STREAM",
-        frameLog(true, 3, 0, TYPE_HEADERS, (byte) 0x1));
-    assertEquals("<< 0x00000003     0 DATA          END_STREAM",
-        frameLog(true, 3, 0, TYPE_DATA, (byte) 0x1));
+    assertThat(frameLog(true, 0, 0, TYPE_SETTINGS, (byte) 0x1)).isEqualTo(
+        "<< 0x00000000     0 SETTINGS      ACK");
+    assertThat(frameLog(true, 0, 8, TYPE_PING, (byte) 0x1)).isEqualTo(
+        "<< 0x00000000     8 PING          ACK");
+    assertThat(frameLog(true, 3, 0, TYPE_HEADERS, (byte) 0x1)).isEqualTo(
+        "<< 0x00000003     0 HEADERS       END_STREAM");
+    assertThat(frameLog(true, 3, 0, TYPE_DATA, (byte) 0x1)).isEqualTo(
+        "<< 0x00000003     0 DATA          END_STREAM");
   }
 
   @Test public void flagOverlapOn0x4() {
-    assertEquals("<< 0x00000003 10000 HEADERS       END_HEADERS",
-        frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x4));
-    assertEquals("<< 0x00000003 10000 CONTINUATION  END_HEADERS",
-        frameLog(true, 3, 10000, TYPE_CONTINUATION, (byte) 0x4));
-    assertEquals("<< 0x00000004 10000 PUSH_PROMISE  END_PUSH_PROMISE",
-        frameLog(true, 4, 10000, TYPE_PUSH_PROMISE, (byte) 0x4));
+    assertThat(frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x4)).isEqualTo(
+        "<< 0x00000003 10000 HEADERS       END_HEADERS");
+    assertThat(frameLog(true, 3, 10000, TYPE_CONTINUATION, (byte) 0x4)).isEqualTo(
+        "<< 0x00000003 10000 CONTINUATION  END_HEADERS");
+    assertThat(frameLog(true, 4, 10000, TYPE_PUSH_PROMISE, (byte) 0x4)).isEqualTo(
+        "<< 0x00000004 10000 PUSH_PROMISE  END_PUSH_PROMISE");
   }
 
   @Test public void flagOverlapOn0x20() {
-    assertEquals("<< 0x00000003 10000 HEADERS       PRIORITY",
-        frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x20));
-    assertEquals("<< 0x00000003 10000 DATA          COMPRESSED",
-        frameLog(true, 3, 10000, TYPE_DATA, (byte) 0x20));
+    assertThat(frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x20)).isEqualTo(
+        "<< 0x00000003 10000 HEADERS       PRIORITY");
+    assertThat(frameLog(true, 3, 10000, TYPE_DATA, (byte) 0x20)).isEqualTo(
+        "<< 0x00000003 10000 DATA          COMPRESSED");
   }
 
   /**
@@ -92,7 +91,7 @@
     List<String> formattedFlags = new ArrayList<>(0x40); // Highest valid flag is 0x20.
     for (byte i = 0; i < 0x40; i++) formattedFlags.add(Http2.formatFlags(TYPE_HEADERS, i));
 
-    assertEquals(Arrays.asList(
+    assertThat(formattedFlags).containsExactly(
         "",
         "END_STREAM",
         "00000010",
@@ -157,6 +156,6 @@
         "00111101",
         "00111110",
         "00111111"
-    ), formattedFlags);
+    );
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java b/okhttp/src/test/java/okhttp3/internal/http2/HpackTest.java
similarity index 80%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
rename to okhttp/src/test/java/okhttp3/internal/http2/HpackTest.java
index f8bd931282..90a7d7290f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/HpackTest.java
@@ -23,10 +23,10 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static java.util.Arrays.asList;
 import static okhttp3.TestUtil.headerEntries;
 import static okio.ByteString.decodeHex;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class HpackTest {
@@ -55,9 +55,9 @@
     bytesIn.writeAll(bytesOut);
     hpackReader.readHeaders();
 
-    assertEquals(0, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(0);
 
-    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
   }
 
   /**
@@ -75,9 +75,10 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(0, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(0);
 
-    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
+        headerEntries("custom-key", "custom-header"));
   }
 
   /** Oldest entries are evicted to support newer ones. */
@@ -115,8 +116,8 @@
     Hpack.Writer writer = new Hpack.Writer(110, false, bytesOut);
     writer.writeHeaders(headerBlock);
 
-    assertEquals(bytesIn, bytesOut);
-    assertEquals(2, writer.headerCount);
+    assertThat(bytesOut).isEqualTo(bytesIn);
+    assertThat(writer.headerCount).isEqualTo(2);
 
     int tableLength = writer.dynamicTable.length;
     Header entry = writer.dynamicTable[tableLength - 1];
@@ -160,7 +161,7 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(2, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(2);
 
     Header entry1 = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry1, "custom-bar", "custom-header", 55);
@@ -170,13 +171,13 @@
 
     // Once a header field is decoded and added to the reconstructed header
     // list, it cannot be removed from it. Hence, foo is here.
-    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
 
     // Simulate receiving a small dynamic table size update, that implies eviction.
     bytesIn.writeByte(0x3F); // Dynamic table size update (size = 55).
     bytesIn.writeByte(0x18);
     hpackReader.readHeaders();
-    assertEquals(1, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(1);
   }
 
   /** Header table backing array is initially 8 long, let's ensure it grows. */
@@ -198,7 +199,7 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(256, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(256);
   }
 
   @Test public void huffmanDecodingSupported() throws IOException {
@@ -210,8 +211,8 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(1, hpackReader.headerCount);
-    assertEquals(52, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.headerCount).isEqualTo(1);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(52);
 
     Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":path", "www.example.com", 52);
@@ -230,13 +231,14 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(1, hpackReader.headerCount);
-    assertEquals(55, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.headerCount).isEqualTo(1);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(55);
 
     Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, "custom-key", "custom-header", 55);
 
-    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
+        headerEntries("custom-key", "custom-header"));
   }
 
   /**
@@ -251,13 +253,13 @@
     bytesIn.writeUtf8("/sample/path");
 
     hpackWriter.writeHeaders(headerBlock);
-    assertEquals(bytesIn, bytesOut);
+    assertThat(bytesOut).isEqualTo(bytesIn);
 
     hpackReader.readHeaders();
 
-    assertEquals(0, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(0);
 
-    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
   }
 
   @Test public void literalHeaderFieldWithoutIndexingNewName() throws IOException {
@@ -272,9 +274,9 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(0, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(0);
 
-    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
   }
 
   @Test public void literalHeaderFieldNeverIndexedIndexedName() throws IOException {
@@ -285,9 +287,10 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(0, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(0);
 
-    assertEquals(headerEntries(":path", "/sample/path"), hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
+        headerEntries(":path", "/sample/path"));
   }
 
   @Test public void literalHeaderFieldNeverIndexedNewName() throws IOException {
@@ -302,9 +305,9 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(0, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(0);
 
-    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
   }
 
   @Test public void literalHeaderFieldWithIncrementalIndexingIndexedName() throws IOException {
@@ -316,9 +319,9 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(1, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(1);
 
-    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
   }
 
   @Test public void literalHeaderFieldWithIncrementalIndexingNewName() throws IOException {
@@ -332,18 +335,18 @@
     bytesIn.writeUtf8("custom-header");
 
     hpackWriter.writeHeaders(headerBlock);
-    assertEquals(bytesIn, bytesOut);
+    assertThat(bytesOut).isEqualTo(bytesIn);
 
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
 
     Header entry = hpackWriter.dynamicTable[hpackWriter.dynamicTable.length - 1];
     checkEntry(entry, "custom-key", "custom-header", 55);
 
     hpackReader.readHeaders();
 
-    assertEquals(1, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(1);
 
-    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
   }
 
   @Test public void theSameHeaderAfterOneIncrementalIndexed() throws IOException {
@@ -362,18 +365,18 @@
     bytesIn.writeByte(0xbe); // Indexed name and value (idx = 63)
 
     hpackWriter.writeHeaders(headerBlock);
-    assertEquals(bytesIn, bytesOut);
+    assertThat(bytesOut).isEqualTo(bytesIn);
 
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
 
     Header entry = hpackWriter.dynamicTable[hpackWriter.dynamicTable.length - 1];
     checkEntry(entry, "custom-key", "custom-header", 55);
 
     hpackReader.readHeaders();
 
-    assertEquals(1, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(1);
 
-    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
   }
 
   @Test public void staticHeaderIsNotCopiedIntoTheIndexedTable() throws IOException {
@@ -382,12 +385,13 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(0, hpackReader.headerCount);
-    assertEquals(0, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.headerCount).isEqualTo(0);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(0);
 
-    assertNull(hpackReader.dynamicTable[readerHeaderTableLength() - 1]);
+    assertThat(hpackReader.dynamicTable[readerHeaderTableLength() - 1]).isNull();
 
-    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
+        headerEntries(":method", "GET"));
   }
 
   // Example taken from twitter/hpack DecoderTest.testUnusedIndex
@@ -398,7 +402,7 @@
       hpackReader.readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("index == 0", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("index == 0");
     }
   }
 
@@ -410,7 +414,7 @@
       hpackReader.readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("Header index too large 127", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Header index too large 127");
     }
   }
 
@@ -423,7 +427,7 @@
       hpackReader.readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("Header index too large -2147483521", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Header index too large -2147483521");
     }
   }
 
@@ -432,14 +436,14 @@
     bytesIn.writeByte(0x20);
     hpackReader.readHeaders();
 
-    assertEquals(0, hpackReader.maxDynamicTableByteCount());
+    assertThat(hpackReader.maxDynamicTableByteCount()).isEqualTo(0);
 
     bytesIn.writeByte(0x3f); // encode size 4096
     bytesIn.writeByte(0xe1);
     bytesIn.writeByte(0x1f);
     hpackReader.readHeaders();
 
-    assertEquals(4096, hpackReader.maxDynamicTableByteCount());
+    assertThat(hpackReader.maxDynamicTableByteCount()).isEqualTo(4096);
   }
 
   // Example taken from twitter/hpack DecoderTest.testIllegalHeaderTableSizeUpdate
@@ -452,7 +456,7 @@
       hpackReader.readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("Invalid dynamic table size update 4097", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Invalid dynamic table size update 4097");
     }
   }
 
@@ -465,7 +469,7 @@
       hpackReader.readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("Invalid dynamic table size update -2147483648", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Invalid dynamic table size update -2147483648");
     }
   }
 
@@ -480,9 +484,10 @@
     hpackReader.readHeaders();
 
     // Not buffered in header table.
-    assertEquals(0, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(0);
 
-    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
+        headerEntries(":method", "GET"));
   }
 
   @Test public void readLiteralHeaderWithIncrementalIndexingStaticName() throws IOException {
@@ -493,7 +498,8 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(Arrays.asList(new Header("www-authenticate", "Basic")), hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList())
+        .containsExactly(new Header("www-authenticate", "Basic"));
   }
 
   @Test public void readLiteralHeaderWithIncrementalIndexingDynamicName() throws IOException {
@@ -509,9 +515,8 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(
-        Arrays.asList(new Header("custom-foo", "Basic"), new Header("custom-foo", "Basic2")),
-        hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).containsExactly(
+        new Header("custom-foo", "Basic"), new Header("custom-foo", "Basic2"));
   }
 
   /**
@@ -548,7 +553,7 @@
       hpackReader.readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("Header index too large 78", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Header index too large 78");
     }
   }
 
@@ -566,21 +571,21 @@ private void firstRequestWithoutHuffman() {
   }
 
   private void checkReadFirstRequestWithoutHuffman() {
-    assertEquals(1, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(1);
 
     // [  1] (s =  57) :authority: www.example.com
     Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 57
-    assertEquals(57, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(57);
 
     // Decoded header list:
-    assertEquals(headerEntries(
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
         ":method", "GET",
         ":scheme", "http",
         ":path", "/",
-        ":authority", "www.example.com"), hpackReader.getAndResetHeaderList());
+        ":authority", "www.example.com"));
   }
 
   private void secondRequestWithoutHuffman() {
@@ -599,7 +604,7 @@ private void secondRequestWithoutHuffman() {
   }
 
   private void checkReadSecondRequestWithoutHuffman() {
-    assertEquals(2, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(2);
 
     // [  1] (s =  53) cache-control: no-cache
     Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
@@ -610,15 +615,15 @@ private void checkReadSecondRequestWithoutHuffman() {
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 110
-    assertEquals(110, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(110);
 
     // Decoded header list:
-    assertEquals(headerEntries(
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
         ":method", "GET",
         ":scheme", "http",
         ":path", "/",
         ":authority", "www.example.com",
-        "cache-control", "no-cache"), hpackReader.getAndResetHeaderList());
+        "cache-control", "no-cache"));
   }
 
   private void thirdRequestWithoutHuffman() {
@@ -638,7 +643,7 @@ private void thirdRequestWithoutHuffman() {
   }
 
   private void checkReadThirdRequestWithoutHuffman() {
-    assertEquals(3, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(3);
 
     // [  1] (s =  54) custom-key: custom-value
     Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 3];
@@ -653,15 +658,15 @@ private void checkReadThirdRequestWithoutHuffman() {
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 164
-    assertEquals(164, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(164);
 
     // Decoded header list:
-    assertEquals(headerEntries(
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
         ":method", "GET",
         ":scheme", "https",
         ":path", "/index.html",
         ":authority", "www.example.com",
-        "custom-key", "custom-value"), hpackReader.getAndResetHeaderList());
+        "custom-key", "custom-value"));
   }
 
   /**
@@ -696,21 +701,21 @@ private void firstRequestWithHuffman() {
   }
 
   private void checkReadFirstRequestWithHuffman() {
-    assertEquals(1, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(1);
 
     // [  1] (s =  57) :authority: www.example.com
     Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 57
-    assertEquals(57, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(57);
 
     // Decoded header list:
-    assertEquals(headerEntries(
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
         ":method", "GET",
         ":scheme", "http",
         ":path", "/",
-        ":authority", "www.example.com"), hpackReader.getAndResetHeaderList());
+        ":authority", "www.example.com"));
   }
 
   private void secondRequestWithHuffman() {
@@ -730,7 +735,7 @@ private void secondRequestWithHuffman() {
   }
 
   private void checkReadSecondRequestWithHuffman() {
-    assertEquals(2, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(2);
 
     // [  1] (s =  53) cache-control: no-cache
     Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
@@ -741,15 +746,15 @@ private void checkReadSecondRequestWithHuffman() {
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 110
-    assertEquals(110, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(110);
 
     // Decoded header list:
-    assertEquals(headerEntries(
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
         ":method", "GET",
         ":scheme", "http",
         ":path", "/",
         ":authority", "www.example.com",
-        "cache-control", "no-cache"), hpackReader.getAndResetHeaderList());
+        "cache-control", "no-cache"));
   }
 
   private void thirdRequestWithHuffman() {
@@ -771,7 +776,7 @@ private void thirdRequestWithHuffman() {
   }
 
   private void checkReadThirdRequestWithHuffman() {
-    assertEquals(3, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(3);
 
     // [  1] (s =  54) custom-key: custom-value
     Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 3];
@@ -786,24 +791,24 @@ private void checkReadThirdRequestWithHuffman() {
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 164
-    assertEquals(164, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(164);
 
     // Decoded header list:
-    assertEquals(headerEntries(
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
         ":method", "GET",
         ":scheme", "https",
         ":path", "/index.html",
         ":authority", "www.example.com",
-        "custom-key", "custom-value"), hpackReader.getAndResetHeaderList());
+        "custom-key", "custom-value"));
   }
 
   @Test public void readSingleByteInt() throws IOException {
-    assertEquals(10, newReader(byteStream()).readInt(10, 31));
-    assertEquals(10, newReader(byteStream()).readInt(0xe0 | 10, 31));
+    assertThat(newReader(byteStream()).readInt(10, 31)).isEqualTo(10);
+    assertThat(newReader(byteStream()).readInt(0xe0 | 10, 31)).isEqualTo(10);
   }
 
   @Test public void readMultibyteInt() throws IOException {
-    assertEquals(1337, newReader(byteStream(154, 10)).readInt(31, 31));
+    assertThat(newReader(byteStream(154, 10)).readInt(31, 31)).isEqualTo(1337);
   }
 
   @Test public void writeSingleByteInt() throws IOException {
@@ -823,30 +828,30 @@ private void checkReadThirdRequestWithHuffman() {
   @Test public void max31BitValue() throws IOException {
     hpackWriter.writeInt(0x7fffffff, 31, 0);
     assertBytes(31, 224, 255, 255, 255, 7);
-    assertEquals(0x7fffffff,
-        newReader(byteStream(224, 255, 255, 255, 7)).readInt(31, 31));
+    assertThat(newReader(byteStream(224, 255, 255, 255, 7)).readInt(31, 31)).isEqualTo(
+        (long) 0x7fffffff);
   }
 
   @Test public void prefixMask() throws IOException {
     hpackWriter.writeInt(31, 31, 0);
     assertBytes(31, 0);
-    assertEquals(31, newReader(byteStream(0)).readInt(31, 31));
+    assertThat(newReader(byteStream(0)).readInt(31, 31)).isEqualTo(31);
   }
 
   @Test public void prefixMaskMinusOne() throws IOException {
     hpackWriter.writeInt(30, 31, 0);
     assertBytes(30);
-    assertEquals(31, newReader(byteStream(0)).readInt(31, 31));
+    assertThat(newReader(byteStream(0)).readInt(31, 31)).isEqualTo(31);
   }
 
   @Test public void zero() throws IOException {
     hpackWriter.writeInt(0, 31, 0);
     assertBytes(0);
-    assertEquals(0, newReader(byteStream()).readInt(0, 31));
+    assertThat(newReader(byteStream()).readInt(0, 31)).isEqualTo(0);
   }
 
   @Test public void lowercaseHeaderNameBeforeEmit() throws IOException {
-    hpackWriter.writeHeaders(Arrays.asList(new Header("FoO", "BaR")));
+    hpackWriter.writeHeaders(asList(new Header("FoO", "BaR")));
     assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'B', 'a', 'R');
   }
 
@@ -855,38 +860,39 @@ private void checkReadThirdRequestWithHuffman() {
       newReader(byteStream(0, 3, 'F', 'o', 'o', 3, 'B', 'a', 'R')).readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR response malformed: mixed case name: Foo", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "PROTOCOL_ERROR response malformed: mixed case name: Foo");
     }
   }
 
   @Test public void emptyHeaderName() throws IOException {
     hpackWriter.writeByteString(ByteString.encodeUtf8(""));
     assertBytes(0);
-    assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString());
+    assertThat(newReader(byteStream(0)).readByteString()).isEqualTo(ByteString.EMPTY);
   }
 
   @Test public void emitsDynamicTableSizeUpdate() throws IOException {
     hpackWriter.setHeaderTableSizeSetting(2048);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+    hpackWriter.writeHeaders(asList(new Header("foo", "bar")));
     assertBytes(
         0x3F, 0xE1, 0xF, // Dynamic table size update (size = 2048).
         0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
 
     hpackWriter.setHeaderTableSizeSetting(8192);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("bar", "foo")));
+    hpackWriter.writeHeaders(asList(new Header("bar", "foo")));
     assertBytes(
         0x3F, 0xE1, 0x3F, // Dynamic table size update (size = 8192).
         0x40, 3, 'b', 'a', 'r', 3, 'f', 'o', 'o');
 
     // No more dynamic table updates should be emitted.
-    hpackWriter.writeHeaders(Arrays.asList(new Header("far", "boo")));
+    hpackWriter.writeHeaders(asList(new Header("far", "boo")));
     assertBytes(0x40, 3, 'f', 'a', 'r', 3, 'b', 'o', 'o');
   }
 
   @Test public void noDynamicTableSizeUpdateWhenSizeIsEqual() throws IOException {
     int currentSize = hpackWriter.headerTableSizeSetting;
     hpackWriter.setHeaderTableSizeSetting(currentSize);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+    hpackWriter.writeHeaders(asList(new Header("foo", "bar")));
 
     assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
   }
@@ -894,7 +900,7 @@ private void checkReadThirdRequestWithHuffman() {
   @Test public void growDynamicTableSize() throws IOException {
     hpackWriter.setHeaderTableSizeSetting(8192);
     hpackWriter.setHeaderTableSizeSetting(16384);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+    hpackWriter.writeHeaders(asList(new Header("foo", "bar")));
 
     assertBytes(
         0x3F, 0xE1, 0x7F, // Dynamic table size update (size = 16384).
@@ -904,7 +910,7 @@ private void checkReadThirdRequestWithHuffman() {
   @Test public void shrinkDynamicTableSize() throws IOException {
     hpackWriter.setHeaderTableSizeSetting(2048);
     hpackWriter.setHeaderTableSizeSetting(0);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+    hpackWriter.writeHeaders(asList(new Header("foo", "bar")));
 
     assertBytes(
         0x20, // Dynamic size update (size = 0).
@@ -917,7 +923,7 @@ private void checkReadThirdRequestWithHuffman() {
     hpackWriter.setHeaderTableSizeSetting(0);
     hpackWriter.setHeaderTableSizeSetting(4096);
     hpackWriter.setHeaderTableSizeSetting(2048);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+    hpackWriter.writeHeaders(asList(new Header("foo", "bar")));
 
     assertBytes(
         0x20, // Dynamic size update (size = 0).
@@ -931,13 +937,13 @@ private void checkReadThirdRequestWithHuffman() {
             "custom-key1", "custom-header",
             "custom-key2", "custom-header");
     hpackWriter.writeHeaders(headerBlock);
-    assertEquals(2, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(2);
 
     hpackWriter.setHeaderTableSizeSetting(56);
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
 
     hpackWriter.setHeaderTableSizeSetting(0);
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
   }
 
   @Test public void noEvictionOnDynamicTableSizeIncrease() throws IOException {
@@ -946,15 +952,15 @@ private void checkReadThirdRequestWithHuffman() {
             "custom-key1", "custom-header",
             "custom-key2", "custom-header");
     hpackWriter.writeHeaders(headerBlock);
-    assertEquals(2, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(2);
 
     hpackWriter.setHeaderTableSizeSetting(8192);
-    assertEquals(2, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(2);
   }
 
   @Test public void dynamicTableSizeHasAnUpperBound() {
     hpackWriter.setHeaderTableSizeSetting(1048576);
-    assertEquals(16384, hpackWriter.maxDynamicTableByteCount);
+    assertThat(hpackWriter.maxDynamicTableByteCount).isEqualTo(16384);
   }
 
   @Test public void huffmanEncode() throws IOException {
@@ -973,33 +979,33 @@ private void checkReadThirdRequestWithHuffman() {
         .readByteString();
 
     ByteString actual = bytesOut.readByteString();
-    assertEquals(expected, actual);
+    assertThat(actual).isEqualTo(expected);
   }
 
   @Test public void staticTableIndexedHeaders() throws IOException {
     hpackWriter.writeHeaders(headerEntries(":method", "GET"));
     assertBytes(0x82);
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
 
     hpackWriter.writeHeaders(headerEntries(":method", "POST"));
     assertBytes(0x83);
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
 
     hpackWriter.writeHeaders(headerEntries(":path", "/"));
     assertBytes(0x84);
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
 
     hpackWriter.writeHeaders(headerEntries(":path", "/index.html"));
     assertBytes(0x85);
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
 
     hpackWriter.writeHeaders(headerEntries(":scheme", "http"));
     assertBytes(0x86);
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
 
     hpackWriter.writeHeaders(headerEntries(":scheme", "https"));
     assertBytes(0x87);
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
   }
 
   @Test public void dynamicTableIndexedHeader() throws IOException {
@@ -1007,64 +1013,64 @@ private void checkReadThirdRequestWithHuffman() {
     assertBytes(0x40,
         10, 'c', 'u', 's', 't', 'o', 'm', '-', 'k', 'e', 'y',
         13, 'c', 'u', 's', 't', 'o', 'm', '-', 'h', 'e', 'a', 'd', 'e', 'r');
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
 
     hpackWriter.writeHeaders(headerEntries("custom-key", "custom-header"));
     assertBytes(0xbe);
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
   }
 
   @Test public void doNotIndexPseudoHeaders() throws IOException {
     hpackWriter.writeHeaders(headerEntries(":method", "PUT"));
     assertBytes(0x02, 3, 'P', 'U', 'T');
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
 
     hpackWriter.writeHeaders(headerEntries(":path", "/okhttp"));
     assertBytes(0x04, 7, '/', 'o', 'k', 'h', 't', 't', 'p');
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
   }
 
   @Test public void incrementalIndexingWithAuthorityPseudoHeader() throws IOException {
     hpackWriter.writeHeaders(headerEntries(":authority", "foo.com"));
     assertBytes(0x41, 7, 'f', 'o', 'o', '.', 'c', 'o', 'm');
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
 
     hpackWriter.writeHeaders(headerEntries(":authority", "foo.com"));
     assertBytes(0xbe);
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
 
     // If the :authority header somehow changes, it should be re-added to the dynamic table.
     hpackWriter.writeHeaders(headerEntries(":authority", "bar.com"));
     assertBytes(0x41, 7, 'b', 'a', 'r', '.', 'c', 'o', 'm');
-    assertEquals(2, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(2);
 
     hpackWriter.writeHeaders(headerEntries(":authority", "bar.com"));
     assertBytes(0xbe);
-    assertEquals(2, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(2);
   }
 
   @Test public void incrementalIndexingWithStaticTableIndexedName() throws IOException {
     hpackWriter.writeHeaders(headerEntries("accept-encoding", "gzip"));
     assertBytes(0x50, 4, 'g', 'z', 'i', 'p');
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
 
     hpackWriter.writeHeaders(headerEntries("accept-encoding", "gzip"));
     assertBytes(0xbe);
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
   }
 
   @Test public void incrementalIndexingWithDynamcTableIndexedName() throws IOException {
     hpackWriter.writeHeaders(headerEntries("foo", "bar"));
     assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
 
     hpackWriter.writeHeaders(headerEntries("foo", "bar1"));
     assertBytes(0x7e, 4, 'b', 'a', 'r', '1');
-    assertEquals(2, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(2);
 
     hpackWriter.writeHeaders(headerEntries("foo", "bar1"));
     assertBytes(0xbe);
-    assertEquals(2, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(2);
   }
 
   private Hpack.Reader newReader(Buffer source) {
@@ -1076,15 +1082,15 @@ private Buffer byteStream(int... bytes) {
   }
 
   private void checkEntry(Header entry, String name, String value, int size) {
-    assertEquals(name, entry.name.utf8());
-    assertEquals(value, entry.value.utf8());
-    assertEquals(size, entry.hpackSize);
+    assertThat(entry.name.utf8()).isEqualTo(name);
+    assertThat(entry.value.utf8()).isEqualTo(value);
+    assertThat(entry.hpackSize).isEqualTo(size);
   }
 
   private void assertBytes(int... bytes) throws IOException {
     ByteString expected = intArrayToByteArray(bytes);
     ByteString actual = bytesOut.readByteString();
-    assertEquals(expected, actual);
+    assertThat(actual).isEqualTo(expected);
   }
 
   private ByteString intArrayToByteArray(int[] bytes) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
similarity index 76%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
rename to okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index f457f8f822..03b1e1eb4d 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -15,6 +15,7 @@
  */
 package okhttp3.internal.http2;
 
+import java.io.EOFException;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.Socket;
@@ -43,6 +44,7 @@
 import org.junit.rules.Timeout;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Arrays.asList;
 import static okhttp3.TestUtil.headerEntries;
 import static okhttp3.TestUtil.repeat;
 import static okhttp3.internal.Internal.initializeInstanceForTests;
@@ -55,16 +57,15 @@
 import static okhttp3.internal.http2.Settings.INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
 import static okhttp3.internal.http2.Settings.MAX_FRAME_SIZE;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class Http2ConnectionTest {
   private final MockHttp2Peer peer = new MockHttp2Peer();
 
-  @Rule public final TestRule timeout = new Timeout(5_000);
+  @Rule public final TestRule timeout = new Timeout(5_000, TimeUnit.MILLISECONDS);
 
   @Before public void setup() {
     initializeInstanceForTests();
@@ -87,11 +88,11 @@
 
     // verify the peer received what was expected
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
-    assertEquals(0, ping.streamId);
-    assertEquals(2, ping.payload1);
-    assertEquals(3, ping.payload2);
-    assertTrue(ping.ack);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
+    assertThat(ping.streamId).isEqualTo(0);
+    assertThat(ping.payload1).isEqualTo(2);
+    assertThat(ping.payload2).isEqualTo(3);
+    assertThat(ping.ack).isTrue();
   }
 
   @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
@@ -111,16 +112,16 @@
 
     // Verify the peer received the second ACK.
     InFrame ackFrame = peer.takeFrame();
-    assertEquals(Http2.TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
+    assertThat(ackFrame.type).isEqualTo(Http2.TYPE_SETTINGS);
+    assertThat(ackFrame.streamId).isEqualTo(0);
+    assertThat(ackFrame.ack).isTrue();
 
     // This stream was created *after* the connection settings were adjusted.
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
 
-    assertEquals(3368, connection.peerSettings.getInitialWindowSize());
+    assertThat(connection.peerSettings.getInitialWindowSize()).isEqualTo(3368);
     // New Stream is has the most recent initial window size.
-    assertEquals(3368, stream.bytesLeftInWriteWindow);
+    assertThat(stream.bytesLeftInWriteWindow).isEqualTo(3368);
   }
 
   @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
@@ -131,10 +132,10 @@
     Http2Connection connection = connectWithSettings(client, settings);
 
     // Verify the peer's settings were read and applied.
-    assertEquals(0, connection.peerSettings.getHeaderTableSize());
+    assertThat(connection.peerSettings.getHeaderTableSize()).isEqualTo(0);
     Http2Writer writer = connection.writer;
-    assertEquals(0, writer.hpackWriter.dynamicTableByteCount);
-    assertEquals(0, writer.hpackWriter.headerTableSizeSetting);
+    assertThat(writer.hpackWriter.dynamicTableByteCount).isEqualTo(0);
+    assertThat(writer.hpackWriter.headerTableSizeSetting).isEqualTo(0);
   }
 
   @Test public void peerHttp2ClientDisablesPush() throws Exception {
@@ -145,7 +146,7 @@
     Http2Connection connection = connectWithSettings(client, settings);
 
     // verify the peer's settings were read and applied.
-    assertFalse(connection.peerSettings.getEnablePush(true));
+    assertThat(connection.peerSettings.getEnablePush(true)).isFalse();
   }
 
   @Test public void peerIncreasesMaxFrameSize() throws Exception {
@@ -156,8 +157,8 @@
     Http2Connection connection = connectWithSettings(true, settings);
 
     // verify the peer's settings were read and applied.
-    assertEquals(newMaxFrameSize, connection.peerSettings.getMaxFrameSize(-1));
-    assertEquals(newMaxFrameSize, connection.writer.maxDataLength());
+    assertThat(connection.peerSettings.getMaxFrameSize(-1)).isEqualTo(newMaxFrameSize);
+    assertThat(connection.writer.maxDataLength()).isEqualTo(newMaxFrameSize);
   }
 
   /**
@@ -192,14 +193,14 @@
     // Verify the peer received what was expected.
     peer.takeFrame(); // PING
     InFrame headers = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, headers.type);
+    assertThat(headers.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame data1 = peer.takeFrame();
-    assertEquals(Http2.TYPE_DATA, data1.type);
-    assertEquals(3, data1.streamId);
+    assertThat(data1.type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(data1.streamId).isEqualTo(3);
     assertArrayEquals("abcde".getBytes(UTF_8), data1.data);
     InFrame data2 = peer.takeFrame();
-    assertEquals(Http2.TYPE_DATA, data2.type);
-    assertEquals(3, data2.streamId);
+    assertThat(data2.type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(data2.streamId).isEqualTo(3);
     assertArrayEquals("fghi".getBytes(UTF_8), data2.data);
   }
 
@@ -224,16 +225,16 @@
     Source source = stream1.getSource();
     Buffer buffer = new Buffer();
     while (buffer.size() != 1024) source.read(buffer, 1024);
-    stream1.close(ErrorCode.CANCEL);
+    stream1.close(ErrorCode.CANCEL, null);
 
     InFrame frame1 = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, frame1.type);
+    assertThat(frame1.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame frame2 = peer.takeFrame();
-    assertEquals(Http2.TYPE_RST_STREAM, frame2.type);
+    assertThat(frame2.type).isEqualTo(Http2.TYPE_RST_STREAM);
     InFrame frame3 = peer.takeFrame();
-    assertEquals(Http2.TYPE_RST_STREAM, frame3.type);
+    assertThat(frame3.type).isEqualTo(Http2.TYPE_RST_STREAM);
 
-    assertEquals(2048, connection.unacknowledgedBytesRead);
+    assertThat(connection.unacknowledgedBytesRead).isEqualTo(2048);
   }
 
   @Test public void receiveGoAwayHttp2() throws Exception {
@@ -261,7 +262,7 @@
       sink2.flush();
       fail();
     } catch (IOException expected) {
-      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream was reset: REFUSED_STREAM");
     }
     sink1.writeUtf8("def");
     sink1.close();
@@ -270,20 +271,20 @@
       fail();
     } catch (ConnectionShutdownException expected) {
     }
-    assertTrue(stream1.isOpen());
-    assertFalse(stream2.isOpen());
-    assertEquals(1, connection.openStreamCount());
+    assertThat(stream1.isOpen()).isTrue();
+    assertThat(stream2.isOpen()).isFalse();
+    assertThat(connection.openStreamCount()).isEqualTo(1);
 
     // verify the peer received what was expected
     InFrame synStream1 = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream1.type);
+    assertThat(synStream1.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame synStream2 = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream2.type);
+    assertThat(synStream2.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
     InFrame data1 = peer.takeFrame();
-    assertEquals(Http2.TYPE_DATA, data1.type);
-    assertEquals(3, data1.streamId);
+    assertThat(data1.type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(data1.streamId).isEqualTo(3);
     assertArrayEquals("abcdef".getBytes(UTF_8), data1.data);
   }
 
@@ -311,26 +312,28 @@
     Http2Connection connection = connect(peer);
     connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
+    assertThat(stream.unacknowledgedBytesRead).isEqualTo(0);
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
     buffer.writeAll(in);
-    assertEquals(-1, in.read(buffer, 1));
-    assertEquals(150, buffer.size());
+    assertThat(in.read(buffer, 1)).isEqualTo(-1);
+    assertThat(buffer.size()).isEqualTo(150);
 
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     for (int i = 0; i < 3; i++) {
       List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
       for (int j = 0; j < 2; j++) {
         InFrame windowUpdate = peer.takeFrame();
-        assertEquals(Http2.TYPE_WINDOW_UPDATE, windowUpdate.type);
+        assertThat(windowUpdate.type).isEqualTo(Http2.TYPE_WINDOW_UPDATE);
         windowUpdateStreamIds.add(windowUpdate.streamId);
-        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+        assertThat(windowUpdate.windowSizeIncrement).isEqualTo(windowUpdateThreshold);
       }
-      assertTrue(windowUpdateStreamIds.contains(0)); // connection
-      assertTrue(windowUpdateStreamIds.contains(3)); // stream
+      // connection
+      assertThat(windowUpdateStreamIds).contains(0);
+      // stream
+      assertThat(windowUpdateStreamIds).contains(3);
     }
   }
 
@@ -346,12 +349,12 @@
     // Play it back.
     Http2Connection connection = connect(peer);
     Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+    assertThat(client.getSource().read(new Buffer(), 1)).isEqualTo(-1);
 
     // Verify the peer received what was expected.
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertEquals(5, peer.frameCount());
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.frameCount()).isEqualTo(5);
   }
 
   @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
@@ -372,9 +375,9 @@
     out.close();
 
     // Verify the peer received what was expected.
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
-    assertEquals(5, peer.frameCount());
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(peer.frameCount()).isEqualTo(5);
   }
 
   @Test public void maxFrameSizeHonored() throws Exception {
@@ -399,11 +402,11 @@
     out.close();
 
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame data = peer.takeFrame();
-    assertEquals(peer.maxOutboundDataLength(), data.data.length);
+    assertThat(data.data.length).isEqualTo(peer.maxOutboundDataLength());
     data = peer.takeFrame();
-    assertEquals(1, data.data.length);
+    assertThat(data.data.length).isEqualTo(1);
   }
 
   @Test public void pushPromiseStream() throws Exception {
@@ -412,14 +415,14 @@
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    final List<Header> expectedRequestHeaders = Arrays.asList(
+    final List<Header> expectedRequestHeaders = asList(
         new Header(Header.TARGET_METHOD, "GET"),
         new Header(Header.TARGET_SCHEME, "https"),
         new Header(Header.TARGET_AUTHORITY, "squareup.com"),
         new Header(Header.TARGET_PATH, "/cached")
     );
     peer.sendFrame().pushPromise(3, 2, expectedRequestHeaders);
-    final List<Header> expectedResponseHeaders = Arrays.asList(
+    final List<Header> expectedResponseHeaders = asList(
         new Header(Header.RESPONSE_STATUS, "200")
     );
     peer.sendFrame().headers(true, 2, expectedResponseHeaders);
@@ -431,13 +434,13 @@
     // play it back
     Http2Connection connection = connect(peer, observer, REFUSE_INCOMING_STREAMS);
     Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+    assertThat(client.getSource().read(new Buffer(), 1)).isEqualTo(-1);
 
     // verify the peer received what was expected
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
 
-    assertEquals(expectedRequestHeaders, observer.takeEvent());
-    assertEquals(expectedResponseHeaders, observer.takeEvent());
+    assertThat(observer.takeEvent()).isEqualTo(expectedRequestHeaders);
+    assertThat(observer.takeEvent()).isEqualTo(expectedResponseHeaders);
   }
 
   @Test public void doublePushPromise() throws Exception {
@@ -455,21 +458,21 @@
     connection.newStream(headerEntries("b", "banana"), false);
 
     // verify the peer received what was expected
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(ErrorCode.PROTOCOL_ERROR, peer.takeFrame().errorCode);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.takeFrame().errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
   }
 
   @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
     // write the mocking script
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
-    peer.sendFrame().pushPromise(3, 2, Arrays.asList(
+    peer.sendFrame().pushPromise(3, 2, asList(
         new Header(Header.TARGET_METHOD, "GET"),
         new Header(Header.TARGET_SCHEME, "https"),
         new Header(Header.TARGET_AUTHORITY, "squareup.com"),
         new Header(Header.TARGET_PATH, "/cached")
     ));
-    peer.sendFrame().headers(true, 2, Arrays.asList(
+    peer.sendFrame().headers(true, 2, asList(
         new Header(Header.RESPONSE_STATUS, "200")
     ));
     peer.acceptFrame(); // RST_STREAM
@@ -480,9 +483,9 @@
 
     // verify the peer received what was expected
     InFrame rstStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
-    assertEquals(2, rstStream.streamId);
-    assertEquals(ErrorCode.CANCEL, rstStream.errorCode);
+    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
+    assertThat(rstStream.streamId).isEqualTo(2);
+    assertThat(rstStream.errorCode).isEqualTo(ErrorCode.CANCEL);
   }
 
   /**
@@ -534,18 +537,18 @@
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("c3po");
     out.close();
-    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     assertStreamData("robot", stream.getSource());
     connection.writePingAndAwaitPong();
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertFalse(synStream.outFinished);
-    assertEquals(3, synStream.streamId);
-    assertEquals(-1, synStream.associatedStreamId);
-    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.outFinished).isFalse();
+    assertThat(synStream.streamId).isEqualTo(3);
+    assertThat(synStream.associatedStreamId).isEqualTo(-1);
+    assertThat(synStream.headerBlock).isEqualTo(headerEntries("b", "banana"));
     InFrame requestData = peer.takeFrame();
     assertArrayEquals("c3po".getBytes(UTF_8), requestData.data);
   }
@@ -564,17 +567,17 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), false);
     connection.writePingAndAwaitPong();
-    assertEquals(Headers.of("headers", "bam"), stream.takeHeaders());
-    assertEquals(EMPTY_HEADERS, stream.trailers());
-    assertEquals(0, connection.openStreamCount());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("headers", "bam"));
+    assertThat(stream.trailers()).isEqualTo(EMPTY_HEADERS);
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertFalse(synStream.outFinished);
-    assertEquals(3, synStream.streamId);
-    assertEquals(-1, synStream.associatedStreamId);
-    assertEquals(headerEntries("a", "artichaut"), synStream.headerBlock);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.outFinished).isFalse();
+    assertThat(synStream.streamId).isEqualTo(3);
+    assertThat(synStream.associatedStreamId).isEqualTo(-1);
+    assertThat(synStream.headerBlock).isEqualTo(headerEntries("a", "artichaut"));
   }
 
   @Test public void serverWritesTrailersAndClientReadsTrailers() throws Exception {
@@ -591,18 +594,18 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), false);
-    assertEquals(Headers.of("headers", "bam"), stream.takeHeaders());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("headers", "bam"));
     connection.writePingAndAwaitPong();
-    assertEquals(Headers.of("trailers", "boom"), stream.trailers());
-    assertEquals(0, connection.openStreamCount());
+    assertThat(stream.trailers()).isEqualTo(Headers.of("trailers", "boom"));
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertFalse(synStream.outFinished);
-    assertEquals(3, synStream.streamId);
-    assertEquals(-1, synStream.associatedStreamId);
-    assertEquals(headerEntries("a", "artichaut"), synStream.headerBlock);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.outFinished).isFalse();
+    assertThat(synStream.streamId).isEqualTo(3);
+    assertThat(synStream.associatedStreamId).isEqualTo(-1);
+    assertThat(synStream.headerBlock).isEqualTo(headerEntries("a", "artichaut"));
   }
 
   @Test public void serverWritesTrailersWithData() throws Exception {
@@ -631,15 +634,15 @@
 
     // Verify the peer received what was expected.
     InFrame headers1 = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, headers1.type);
+    assertThat(headers1.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame data1 = peer.takeFrame();
-    assertEquals(Http2.TYPE_DATA, data1.type);
-    assertEquals(3, data1.streamId);
+    assertThat(data1.type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(data1.streamId).isEqualTo(3);
     assertArrayEquals("abcdefghi".getBytes(UTF_8), data1.data);
-    assertFalse(data1.inFinished);
+    assertThat(data1.inFinished).isFalse();
     InFrame headers2 = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, headers2.type);
-    assertTrue(headers2.inFinished);
+    assertThat(headers2.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(headers2.inFinished).isTrue();
   }
 
   @Test public void clientCannotReadTrailersWithoutExhaustingStream() throws Exception {
@@ -722,18 +725,18 @@
     Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), false);
     BufferedSource source = Okio.buffer(stream.getSource());
     connection.writePingAndAwaitPong();
-    assertEquals(Headers.of("headers", "bam"), stream.takeHeaders());
-    assertEquals("robot", source.readUtf8(5));
-    assertEquals(EMPTY_HEADERS, stream.trailers());
-    assertEquals(0, connection.openStreamCount());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("headers", "bam"));
+    assertThat(source.readUtf8(5)).isEqualTo("robot");
+    assertThat(stream.trailers()).isEqualTo(EMPTY_HEADERS);
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertFalse(synStream.outFinished);
-    assertEquals(3, synStream.streamId);
-    assertEquals(-1, synStream.associatedStreamId);
-    assertEquals(headerEntries("a", "artichaut"), synStream.headerBlock);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.outFinished).isFalse();
+    assertThat(synStream.streamId).isEqualTo(3);
+    assertThat(synStream.associatedStreamId).isEqualTo(-1);
+    assertThat(synStream.headerBlock).isEqualTo(headerEntries("a", "artichaut"));
   }
 
   @Test public void serverReadsHeadersDataHeaders() throws Exception {
@@ -756,20 +759,20 @@
     out.close();
     stream.writeHeaders(headerEntries("e", "elephant"), false, false);
     connection.writePingAndAwaitPong();
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertFalse(synStream.outFinished);
-    assertEquals(3, synStream.streamId);
-    assertEquals(-1, synStream.associatedStreamId);
-    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.outFinished).isFalse();
+    assertThat(synStream.streamId).isEqualTo(3);
+    assertThat(synStream.associatedStreamId).isEqualTo(-1);
+    assertThat(synStream.headerBlock).isEqualTo(headerEntries("b", "banana"));
     InFrame requestData = peer.takeFrame();
     assertArrayEquals("c3po".getBytes(UTF_8), requestData.data);
 
     InFrame nextFrame = peer.takeFrame();
-    assertEquals(headerEntries("e", "elephant"), nextFrame.headerBlock);
+    assertThat(nextFrame.headerBlock).isEqualTo(headerEntries("e", "elephant"));
   }
 
   @Test public void clientCreatesStreamAndServerRepliesWithFin() throws Exception {
@@ -785,15 +788,15 @@
     // play it back
     Http2Connection connection = connect(peer);
     connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(1, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(1);
     connection.writePingAndAwaitPong(); // Ensure that the SYN_REPLY has been received.
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
   }
 
   @Test public void serverPingsClient() throws Exception {
@@ -809,10 +812,10 @@
 
     // verify the peer received what was expected
     InFrame ping = peer.takeFrame();
-    assertEquals(0, ping.streamId);
-    assertEquals(2, ping.payload1);
-    assertEquals(0, ping.payload2);
-    assertTrue(ping.ack);
+    assertThat(ping.streamId).isEqualTo(0);
+    assertThat(ping.payload1).isEqualTo(2);
+    assertThat(ping.payload2).isEqualTo(0);
+    assertThat(ping.ack).isTrue();
   }
 
   @Test public void clientPingsServer() throws Exception {
@@ -828,16 +831,18 @@
     long pingAtNanos = System.nanoTime();
     connection.writePingAndAwaitPong();
     long elapsedNanos = System.nanoTime() - pingAtNanos;
-    assertTrue(elapsedNanos > 0);
-    assertTrue(elapsedNanos < TimeUnit.SECONDS.toNanos(1));
+    assertThat(elapsedNanos).isGreaterThan(0L);
+    assertThat(elapsedNanos).isLessThan(TimeUnit.SECONDS.toNanos(1));
 
     // verify the peer received what was expected
     InFrame pingFrame = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, pingFrame.type);
-    assertEquals(0, pingFrame.streamId);
-    assertEquals(0x4f4b6f6b, pingFrame.payload1); // OkOk
-    assertEquals(0xf09f8da9, pingFrame.payload2); // donut
-    assertFalse(pingFrame.ack);
+    assertThat(pingFrame.type).isEqualTo(Http2.TYPE_PING);
+    assertThat(pingFrame.streamId).isEqualTo(0);
+    // OkOk
+    assertThat(pingFrame.payload1).isEqualTo(0x4f4b6f6b);
+    // donut
+    assertThat(pingFrame.payload2).isEqualTo(0xf09f8da9);
+    assertThat(pingFrame.ack).isFalse();
   }
 
   @Test public void unexpectedPingIsNotReturned() throws Exception {
@@ -856,9 +861,9 @@
 
     // verify the peer received what was expected
     InFrame ping2 = peer.takeFrame();
-    assertEquals(2, ping2.payload1);
+    assertThat(ping2.payload1).isEqualTo(2);
     InFrame ping4 = peer.takeFrame();
-    assertEquals(4, ping4.payload1);
+    assertThat(ping4.payload1).isEqualTo(4);
   }
 
   @Test public void serverSendsSettingsToClient() throws Exception {
@@ -887,10 +892,10 @@
     Http2Connection connection = connect(peer, IGNORE, listener);
 
     synchronized (connection) {
-      assertEquals(10, connection.peerSettings.getMaxConcurrentStreams(-1));
+      assertThat(connection.peerSettings.getMaxConcurrentStreams(-1)).isEqualTo(10);
     }
     maxConcurrentStreamsUpdated.await();
-    assertEquals(10, maxConcurrentStreams.get());
+    assertThat(maxConcurrentStreams.get()).isEqualTo(10);
   }
 
   @Test public void multipleSettingsFramesAreMerged() throws Exception {
@@ -914,13 +919,13 @@
     // play it back
     Http2Connection connection = connect(peer);
 
-    assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_SETTINGS);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
     synchronized (connection) {
-      assertEquals(10000, connection.peerSettings.getHeaderTableSize());
-      assertEquals(40000, connection.peerSettings.getInitialWindowSize());
-      assertEquals(50000, connection.peerSettings.getMaxFrameSize(-1));
-      assertEquals(60000, connection.peerSettings.getMaxConcurrentStreams(-1));
+      assertThat(connection.peerSettings.getHeaderTableSize()).isEqualTo(10000);
+      assertThat(connection.peerSettings.getInitialWindowSize()).isEqualTo(40000);
+      assertThat(connection.peerSettings.getMaxFrameSize(-1)).isEqualTo(50000);
+      assertThat(connection.peerSettings.getMaxConcurrentStreams(-1)).isEqualTo(60000);
     }
   }
 
@@ -945,10 +950,11 @@
     connection.readerRunnable.settings(true, settings2);
 
     synchronized (connection) {
-      assertEquals(-1, connection.peerSettings.getHeaderTableSize());
-      assertEquals(DEFAULT_INITIAL_WINDOW_SIZE, connection.peerSettings.getInitialWindowSize());
-      assertEquals(-1, connection.peerSettings.getMaxFrameSize(-1));
-      assertEquals(60000, connection.peerSettings.getMaxConcurrentStreams(-1));
+      assertThat(connection.peerSettings.getHeaderTableSize()).isEqualTo(-1);
+      assertThat(connection.peerSettings.getInitialWindowSize()).isEqualTo(
+          (long) DEFAULT_INITIAL_WINDOW_SIZE);
+      assertThat(connection.peerSettings.getMaxFrameSize(-1)).isEqualTo(-1);
+      assertThat(connection.peerSettings.getMaxConcurrentStreams(-1)).isEqualTo(60000);
     }
   }
 
@@ -967,11 +973,11 @@
 
     // verify the peer received what was expected
     InFrame rstStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
-    assertEquals(41, rstStream.streamId);
-    assertEquals(ErrorCode.PROTOCOL_ERROR, rstStream.errorCode);
+    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
+    assertThat(rstStream.streamId).isEqualTo(41);
+    assertThat(rstStream.errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
     InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.payload1);
+    assertThat(ping.payload1).isEqualTo(2);
   }
 
   @Test public void bogusReplySilentlyIgnored() throws Exception {
@@ -988,7 +994,7 @@
 
     // verify the peer received what was expected
     InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.payload1);
+    assertThat(ping.payload1).isEqualTo(2);
   }
 
   @Test public void serverClosesClientOutputStream() throws Exception {
@@ -1011,7 +1017,7 @@
       out.flush();
       fail();
     } catch (IOException expected) {
-      assertEquals("stream was reset: CANCEL", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream was reset: CANCEL");
     }
     try {
       out.close();
@@ -1019,15 +1025,15 @@
     } catch (IOException expected) {
       // Close throws because buffered data wasn't flushed.
     }
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertFalse(synStream.inFinished);
-    assertFalse(synStream.outFinished);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.inFinished).isFalse();
+    assertThat(synStream.outFinished).isFalse();
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
   }
 
   /**
@@ -1051,25 +1057,25 @@
       in.read(new Buffer(), 1);
       fail();
     } catch (IOException expected) {
-      assertEquals("stream closed", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream closed");
     }
     try {
       out.writeUtf8("a");
       out.flush();
       fail();
     } catch (IOException expected) {
-      assertEquals("stream finished", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream finished");
     }
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertTrue(synStream.inFinished);
-    assertFalse(synStream.outFinished);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.inFinished).isTrue();
+    assertThat(synStream.outFinished).isFalse();
     InFrame rstStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
-    assertEquals(ErrorCode.CANCEL, rstStream.errorCode);
+    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
+    assertThat(rstStream.errorCode).isEqualTo(ErrorCode.CANCEL);
   }
 
   /**
@@ -1095,28 +1101,28 @@
       source.read(new Buffer(), 1);
       fail();
     } catch (IOException expected) {
-      assertEquals("stream closed", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream closed");
     }
     out.writeUtf8("square");
     out.flush();
     out.close();
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertFalse(synStream.inFinished);
-    assertFalse(synStream.outFinished);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.inFinished).isFalse();
+    assertThat(synStream.outFinished).isFalse();
     InFrame data = peer.takeFrame();
-    assertEquals(Http2.TYPE_DATA, data.type);
+    assertThat(data.type).isEqualTo(Http2.TYPE_DATA);
     assertArrayEquals("square".getBytes(UTF_8), data.data);
     InFrame fin = peer.takeFrame();
-    assertEquals(Http2.TYPE_DATA, fin.type);
-    assertTrue(fin.inFinished);
-    assertFalse(fin.outFinished);
+    assertThat(fin.type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(fin.inFinished).isTrue();
+    assertThat(fin.outFinished).isFalse();
     InFrame rstStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
-    assertEquals(ErrorCode.CANCEL, rstStream.errorCode);
+    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
+    assertThat(rstStream.errorCode).isEqualTo(ErrorCode.CANCEL);
   }
 
   @Test public void serverClosesClientInputStream() throws Exception {
@@ -1136,13 +1142,13 @@
     Source source = stream.getSource();
     assertStreamData("square", source);
     connection.writePingAndAwaitPong(); // Ensure that inFinished has been received.
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertTrue(synStream.inFinished);
-    assertFalse(synStream.outFinished);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.inFinished).isTrue();
+    assertThat(synStream.outFinished).isFalse();
   }
 
   @Test public void remoteDoubleSynReply() throws Exception {
@@ -1159,14 +1165,14 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("c", "cola"), false);
-    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     connection.writePingAndAwaitPong(); // Ensure that the 2nd SYN REPLY has been received.
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
   }
 
   @Test public void remoteSendsDataAfterInFinished() throws Exception {
@@ -1185,18 +1191,18 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     assertStreamData("robot", stream.getSource());
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame rstStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
-    assertEquals(3, rstStream.streamId);
+    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
+    assertThat(rstStream.streamId).isEqualTo(3);
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
-    assertEquals(2, ping.payload1);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
+    assertThat(ping.payload1).isEqualTo(2);
   }
 
   @Test public void clientDoesNotLimitFlowControl() throws Exception {
@@ -1218,14 +1224,14 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    assertEquals(Headers.of("b", "banana"), stream.takeHeaders());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("b", "banana"));
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
-    assertEquals(2, ping.payload1);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
+    assertThat(ping.payload1).isEqualTo(2);
   }
 
   @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
@@ -1245,16 +1251,16 @@
       stream.takeHeaders();
       fail();
     } catch (IOException expected) {
-      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream was reset: REFUSED_STREAM");
     }
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
-    assertEquals(2, ping.payload1);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
+    assertThat(ping.payload1).isEqualTo(2);
   }
 
   @Test public void receiveGoAway() throws Exception {
@@ -1282,7 +1288,7 @@
       sink2.flush();
       fail();
     } catch (IOException expected) {
-      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream was reset: REFUSED_STREAM");
     }
     sink1.writeUtf8("def");
     sink1.close();
@@ -1291,20 +1297,20 @@
       fail();
     } catch (ConnectionShutdownException expected) {
     }
-    assertTrue(stream1.isOpen());
-    assertFalse(stream2.isOpen());
-    assertEquals(1, connection.openStreamCount());
+    assertThat(stream1.isOpen()).isTrue();
+    assertThat(stream2.isOpen()).isFalse();
+    assertThat(connection.openStreamCount()).isEqualTo(1);
 
     // verify the peer received what was expected
     InFrame synStream1 = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream1.type);
+    assertThat(synStream1.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame synStream2 = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream2.type);
+    assertThat(synStream2.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
     InFrame data1 = peer.takeFrame();
-    assertEquals(Http2.TYPE_DATA, data1.type);
-    assertEquals(3, data1.streamId);
+    assertThat(data1.type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(data1.streamId).isEqualTo(3);
     assertArrayEquals("abcdef".getBytes(UTF_8), data1.data);
   }
 
@@ -1329,18 +1335,18 @@
     }
     connection.writePing(false, 0x01, 0x02);
     connection.shutdown(ErrorCode.PROTOCOL_ERROR);
-    assertEquals(1, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(1);
     connection.awaitPong(); // Prevent the peer from exiting prematurely.
 
     // verify the peer received what was expected
     InFrame synStream1 = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream1.type);
+    assertThat(synStream1.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame pingFrame = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, pingFrame.type);
+    assertThat(pingFrame.type).isEqualTo(Http2.TYPE_PING);
     InFrame goaway = peer.takeFrame();
-    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
-    assertEquals(0, goaway.streamId);
-    assertEquals(ErrorCode.PROTOCOL_ERROR, goaway.errorCode);
+    assertThat(goaway.type).isEqualTo(Http2.TYPE_GOAWAY);
+    assertThat(goaway.streamId).isEqualTo(0);
+    assertThat(goaway.errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
   }
 
   @Test public void close() throws Exception {
@@ -1355,9 +1361,9 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    assertEquals(1, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(1);
     connection.close();
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
     try {
       connection.newStream(headerEntries("b", "banana"), false);
       fail();
@@ -1369,23 +1375,23 @@
       sink.flush();
       fail();
     } catch (IOException expected) {
-      assertEquals("stream finished", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream finished");
     }
     try {
       stream.getSource().read(new Buffer(), 1);
       fail();
     } catch (IOException expected) {
-      assertEquals("stream was reset: CANCEL", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream was reset: CANCEL");
     }
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame goaway = peer.takeFrame();
-    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
+    assertThat(goaway.type).isEqualTo(Http2.TYPE_GOAWAY);
     InFrame rstStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
-    assertEquals(3, rstStream.streamId);
+    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
+    assertThat(rstStream.streamId).isEqualTo(3);
   }
 
   @Test public void getResponseHeadersTimesOut() throws Exception {
@@ -1408,12 +1414,13 @@
     }
     long elapsedNanos = System.nanoTime() - startNanos;
     awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
+    /* 200ms delta */
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(500d, offset(200d));
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_RST_STREAM);
   }
 
   @Test public void readTimesOut() throws Exception {
@@ -1438,12 +1445,13 @@
     }
     long elapsedNanos = System.nanoTime() - startNanos;
     awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
+    /* 200ms delta */
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(500d, offset(200d));
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_RST_STREAM);
   }
 
   @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
@@ -1477,14 +1485,15 @@
     }
     long elapsedNanos = System.nanoTime() - startNanos;
     awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
+    /* 200ms delta */
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(500d, offset(200d));
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
-    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_RST_STREAM);
   }
 
   @Test public void writeTimesOutAwaitingConnectionWindow() throws Exception {
@@ -1521,15 +1530,16 @@
     }
     long elapsedNanos = System.nanoTime() - startNanos;
     awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
+    /* 200ms delta */
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(500d, offset(200d));
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
-    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_RST_STREAM);
   }
 
   @Test public void outgoingWritesAreBatched() throws Exception {
@@ -1552,11 +1562,11 @@
     sink.close();
 
     // verify the peer received one incoming frame
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame data = peer.takeFrame();
-    assertEquals(Http2.TYPE_DATA, data.type);
+    assertThat(data.type).isEqualTo(Http2.TYPE_DATA);
     assertArrayEquals("abcdefghij".getBytes(UTF_8), data.data);
-    assertTrue(data.inFinished);
+    assertThat(data.inFinished).isTrue();
   }
 
   @Test public void headers() throws Exception {
@@ -1574,14 +1584,14 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     connection.writePingAndAwaitPong(); // Ensure that the HEADERS has been received.
-    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
-    assertEquals(Headers.of("c", "c3po"), stream.takeHeaders());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("c", "c3po"));
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
   }
 
   @Test public void readMultipleSetsOfResponseHeaders() throws Exception {
@@ -1599,13 +1609,13 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     stream.getConnection().flush();
-    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     connection.writePingAndAwaitPong();
-    assertEquals(Headers.of("c", "cola"), stream.trailers());
+    assertThat(stream.trailers()).isEqualTo(Headers.of("c", "cola"));
 
     // verify the peer received what was expected
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
   }
 
   @Test public void readSendsWindowUpdate() throws Exception {
@@ -1632,26 +1642,28 @@
     Http2Connection connection = connect(peer);
     connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
+    assertThat(stream.unacknowledgedBytesRead).isEqualTo(0);
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
     buffer.writeAll(in);
-    assertEquals(-1, in.read(buffer, 1));
-    assertEquals(150, buffer.size());
+    assertThat(in.read(buffer, 1)).isEqualTo(-1);
+    assertThat(buffer.size()).isEqualTo(150);
 
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     for (int i = 0; i < 3; i++) {
       List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
       for (int j = 0; j < 2; j++) {
         InFrame windowUpdate = peer.takeFrame();
-        assertEquals(Http2.TYPE_WINDOW_UPDATE, windowUpdate.type);
+        assertThat(windowUpdate.type).isEqualTo(Http2.TYPE_WINDOW_UPDATE);
         windowUpdateStreamIds.add(windowUpdate.streamId);
-        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+        assertThat(windowUpdate.windowSizeIncrement).isEqualTo(windowUpdateThreshold);
       }
-      assertTrue(windowUpdateStreamIds.contains(0)); // connection
-      assertTrue(windowUpdateStreamIds.contains(3)); // stream
+      // connection
+      assertThat(windowUpdateStreamIds).contains(0);
+      // stream
+      assertThat(windowUpdateStreamIds).contains(3);
     }
   }
 
@@ -1667,12 +1679,12 @@
     // Play it back.
     Http2Connection connection = connect(peer);
     Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+    assertThat(client.getSource().read(new Buffer(), 1)).isEqualTo(-1);
 
     // Verify the peer received what was expected.
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertEquals(5, peer.frameCount());
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.frameCount()).isEqualTo(5);
   }
 
   @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
@@ -1693,9 +1705,9 @@
     out.close();
 
     // Verify the peer received what was expected.
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
-    assertEquals(5, peer.frameCount());
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(peer.frameCount()).isEqualTo(5);
   }
 
   @Test public void testTruncatedDataFrame() throws Exception {
@@ -1711,13 +1723,12 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(Headers.of("a", "android"), stream.takeHeaders());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     Source in = stream.getSource();
     try {
       Okio.buffer(in).readByteString(101);
       fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
+    } catch (EOFException expected) {
     }
   }
 
@@ -1743,14 +1754,14 @@
     out1.flush();
 
     // Check that we've filled the window for both the stream and also the connection.
-    assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+    assertThat(connection.bytesLeftInWriteWindow).isEqualTo(0);
+    assertThat(connection.getStream(3).bytesLeftInWriteWindow).isEqualTo(0);
 
     // receiving a window update on the connection will unblock new streams.
     connection.readerRunnable.windowUpdate(0, 3);
 
-    assertEquals(3, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+    assertThat(connection.bytesLeftInWriteWindow).isEqualTo(3);
+    assertThat(connection.getStream(3).bytesLeftInWriteWindow).isEqualTo(0);
 
     // Another stream should be able to send data even though 1 is blocked.
     Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
@@ -1758,9 +1769,10 @@
     out2.writeUtf8("foo");
     out2.flush();
 
-    assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
-    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE - 3, connection.getStream(5).bytesLeftInWriteWindow);
+    assertThat(connection.bytesLeftInWriteWindow).isEqualTo(0);
+    assertThat(connection.getStream(3).bytesLeftInWriteWindow).isEqualTo(0);
+    assertThat(connection.getStream(5).bytesLeftInWriteWindow).isEqualTo(
+        (long) (DEFAULT_INITIAL_WINDOW_SIZE - 3));
   }
 
   @Test public void remoteOmitsInitialSettings() throws Exception {
@@ -1780,15 +1792,15 @@
       stream.takeHeaders();
       fail();
     } catch (IOException expected) {
-      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("Expected a SETTINGS frame but was 1");
     }
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame goaway = peer.takeFrame();
-    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
-    assertEquals(ErrorCode.PROTOCOL_ERROR, goaway.errorCode);
+    assertThat(goaway.type).isEqualTo(Http2.TYPE_GOAWAY);
+    assertThat(goaway.errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
   }
 
   private Buffer data(int byteCount) {
@@ -1797,12 +1809,12 @@ private Buffer data(int byteCount) {
 
   private void assertStreamData(String expected, Source source) throws IOException {
     String actual = Okio.buffer(source).readUtf8();
-    assertEquals(expected, actual);
+    assertThat(actual).isEqualTo(expected);
   }
 
   /** Reads {@code prefix} from {@code source}. */
   private void assertStreamPrefix(String prefix, BufferedSource source) throws IOException {
-    assertEquals(prefix, source.readUtf8(Utf8.size(prefix)));
+    assertThat(source.readUtf8(Utf8.size(prefix))).isEqualTo(prefix);
   }
 
   /**
@@ -1850,9 +1862,9 @@ private Http2Connection connect(MockHttp2Peer peer, PushObserver pushObserver,
 
     // verify the peer received the ACK
     InFrame ackFrame = peer.takeFrame();
-    assertEquals(Http2.TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
+    assertThat(ackFrame.type).isEqualTo(Http2.TYPE_SETTINGS);
+    assertThat(ackFrame.streamId).isEqualTo(0);
+    assertThat(ackFrame.ack).isTrue();
 
     return connection;
   }
@@ -1888,7 +1900,7 @@ public synchronized Object takeEvent() throws Exception {
     }
 
     @Override public synchronized boolean onRequest(int streamId, List<Header> requestHeaders) {
-      assertEquals(2, streamId);
+      assertThat(streamId).isEqualTo(2);
       events.add(requestHeaders);
       notifyAll();
       return false;
@@ -1896,8 +1908,8 @@ public synchronized Object takeEvent() throws Exception {
 
     @Override public synchronized boolean onHeaders(
         int streamId, List<Header> responseHeaders, boolean last) {
-      assertEquals(2, streamId);
-      assertTrue(last);
+      assertThat(streamId).isEqualTo(2);
+      assertThat(last).isTrue();
       events.add(responseHeaders);
       notifyAll();
       return false;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java b/okhttp/src/test/java/okhttp3/internal/http2/Http2Test.java
similarity index 81%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
rename to okhttp/src/test/java/okhttp3/internal/http2/Http2Test.java
index 684d222693..bce4c34858 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/Http2Test.java
@@ -28,6 +28,7 @@
 import okio.Okio;
 import org.junit.Test;
 
+import static java.util.Arrays.asList;
 import static okhttp3.TestUtil.headerEntries;
 import static okhttp3.internal.http2.Http2.FLAG_COMPRESSED;
 import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
@@ -35,9 +36,7 @@
 import static okhttp3.internal.http2.Http2.FLAG_NONE;
 import static okhttp3.internal.http2.Http2.FLAG_PADDED;
 import static okhttp3.internal.http2.Http2.FLAG_PRIORITY;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class Http2Test {
@@ -65,15 +64,16 @@
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBytes);
 
-    assertEquals(frame, sendHeaderFrames(true, sentHeaders)); // Check writer sends the same bytes.
+    // Check writer sends the same bytes.
+    assertThat(sendHeaderFrames(true, sentHeaders)).isEqualTo(frame);
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void headers(boolean inFinished, int streamId,
           int associatedStreamId, List<Header> headerBlock) {
-        assertTrue(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(sentHeaders, headerBlock);
+        assertThat(inFinished).isTrue();
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(associatedStreamId).isEqualTo(-1);
+        assertThat(headerBlock).isEqualTo(sentHeaders);
       }
     });
   }
@@ -93,17 +93,17 @@
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void priority(int streamId, int streamDependency, int weight,
           boolean exclusive) {
-        assertEquals(0, streamDependency);
-        assertEquals(256, weight);
-        assertFalse(exclusive);
+        assertThat(streamDependency).isEqualTo(0);
+        assertThat(weight).isEqualTo(256);
+        assertThat(exclusive).isFalse();
       }
 
       @Override public void headers(boolean inFinished, int streamId,
           int associatedStreamId, List<Header> nameValueBlock) {
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(sentHeaders, nameValueBlock);
+        assertThat(inFinished).isFalse();
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(associatedStreamId).isEqualTo(-1);
+        assertThat(nameValueBlock).isEqualTo(sentHeaders);
       }
     });
   }
@@ -128,16 +128,17 @@
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBlock);
 
-    assertEquals(frame, sendHeaderFrames(false, sentHeaders)); // Check writer sends the same bytes.
+    // Check writer sends the same bytes.
+    assertThat(sendHeaderFrames(false, sentHeaders)).isEqualTo(frame);
 
     // Reading the above frames should result in a concatenated headerBlock.
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void headers(boolean inFinished, int streamId,
           int associatedStreamId, List<Header> headerBlock) {
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(sentHeaders, headerBlock);
+        assertThat(inFinished).isFalse();
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(associatedStreamId).isEqualTo(-1);
+        assertThat(headerBlock).isEqualTo(sentHeaders);
       }
     });
   }
@@ -145,7 +146,7 @@
   @Test public void pushPromise() throws IOException {
     final int expectedPromisedStreamId = 11;
 
-    final List<Header> pushPromise = Arrays.asList(
+    final List<Header> pushPromise = asList(
         new Header(Header.TARGET_METHOD, "GET"),
         new Header(Header.TARGET_SCHEME, "https"),
         new Header(Header.TARGET_AUTHORITY, "squareup.com"),
@@ -161,14 +162,15 @@
     frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
     frame.writeAll(headerBytes);
 
-    assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
+    assertThat(sendPushPromiseFrames(expectedPromisedStreamId, pushPromise)).isEqualTo(
+        frame);
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override
       public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(expectedPromisedStreamId, promisedStreamId);
-        assertEquals(pushPromise, headerBlock);
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(promisedStreamId).isEqualTo(expectedPromisedStreamId);
+        assertThat(headerBlock).isEqualTo(pushPromise);
       }
     });
   }
@@ -196,15 +198,16 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBlock);
 
-    assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
+    assertThat(sendPushPromiseFrames(expectedPromisedStreamId, pushPromise)).isEqualTo(
+        frame);
 
     // Reading the above frames should result in a concatenated headerBlock.
     reader.nextFrame(false, new BaseTestHandler() {
       @Override
       public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(expectedPromisedStreamId, promisedStreamId);
-        assertEquals(pushPromise, headerBlock);
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(promisedStreamId).isEqualTo(expectedPromisedStreamId);
+        assertThat(headerBlock).isEqualTo(pushPromise);
       }
     });
   }
@@ -218,8 +221,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void rstStream(int streamId, ErrorCode errorCode) {
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(ErrorCode.PROTOCOL_ERROR, errorCode);
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
       }
     });
   }
@@ -238,9 +241,10 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void settings(boolean clearPrevious, Settings settings) {
-        assertFalse(clearPrevious); // No clearPrevious in HTTP/2.
-        assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
-        assertFalse(settings.getEnablePush(true));
+        // No clearPrevious in HTTP/2.
+        assertThat(clearPrevious).isFalse();
+        assertThat(settings.getHeaderTableSize()).isEqualTo(reducedTableSizeBytes);
+        assertThat(settings.getEnablePush(true)).isFalse();
       }
     });
   }
@@ -257,7 +261,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
     }
   }
 
@@ -275,7 +279,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
         settingValue.set(settings.get(7));
       }
     });
-    assertEquals(settingValue.intValue(), 1);
+    assertThat(1).isEqualTo(settingValue.intValue());
   }
 
   @Test public void readSettingsFrameExperimentalId() throws IOException {
@@ -305,7 +309,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
     }
   }
 
@@ -321,7 +326,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: -2147483648", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: -2147483648");
     }
   }
 
@@ -337,7 +343,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16383", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16383");
     }
   }
 
@@ -353,7 +359,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16777216", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16777216");
     }
   }
 
@@ -369,13 +376,13 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(expectedPayload2);
 
     // Check writer sends the same bytes.
-    assertEquals(frame, sendPingFrame(true, expectedPayload1, expectedPayload2));
+    assertThat(sendPingFrame(true, expectedPayload1, expectedPayload2)).isEqualTo(frame);
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void ping(boolean ack, int payload1, int payload2) {
-        assertTrue(ack);
-        assertEquals(expectedPayload1, payload1);
-        assertEquals(expectedPayload2, payload2);
+        assertThat(ack).isTrue();
+        assertThat(payload1).isEqualTo(expectedPayload1);
+        assertThat(payload2).isEqualTo(expectedPayload2);
       }
     });
   }
@@ -391,17 +398,17 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.write(expectedData);
 
     // Check writer sends the same bytes.
-    assertEquals(frame, sendDataFrame(new Buffer().write(expectedData)));
+    assertThat(sendDataFrame(new Buffer().write(expectedData))).isEqualTo(frame);
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void data(boolean inFinished, int streamId, BufferedSource source,
           int length) throws IOException {
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(Http2.INITIAL_MAX_FRAME_SIZE, length);
+        assertThat(inFinished).isFalse();
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(length).isEqualTo(Http2.INITIAL_MAX_FRAME_SIZE);
         ByteString data = source.readByteString(length);
         for (byte b : data.toByteArray()) {
-          assertEquals(2, b);
+          assertThat(b).isEqualTo((byte) 2);
         }
       }
     });
@@ -420,7 +427,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR: TYPE_DATA streamId == 0", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("PROTOCOL_ERROR: TYPE_DATA streamId == 0");
     }
   }
 
@@ -441,8 +448,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA",
-          e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
     }
   }
 
@@ -464,7 +471,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.write(padding);
 
     reader.nextFrame(false, assertData());
-    assertTrue(frame.exhausted()); // Padding was skipped.
+    // Padding was skipped.
+    assertThat(frame.exhausted()).isTrue();
   }
 
   @Test public void readPaddedDataFrameZeroPadding() throws IOException {
@@ -497,7 +505,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.write(padding);
 
     reader.nextFrame(false, assertHeaderBlock());
-    assertTrue(frame.exhausted()); // Padding was skipped.
+    // Padding was skipped.
+    assertThat(frame.exhausted()).isTrue();
   }
 
   @Test public void readPaddedHeadersFrameZeroPadding() throws IOException {
@@ -538,7 +547,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeAll(headerBlock);
 
     reader.nextFrame(false, assertHeaderBlock());
-    assertTrue(frame.exhausted());
+    assertThat(frame.exhausted()).isTrue();
   }
 
   @Test public void tooLargeDataFrame() throws IOException {
@@ -546,7 +555,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       sendDataFrame(new Buffer().write(new byte[0x1000000]));
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("FRAME_SIZE_ERROR length > 16384: 16777216", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("FRAME_SIZE_ERROR length > 16384: 16777216");
     }
   }
 
@@ -560,12 +569,12 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt((int) expectedWindowSizeIncrement);
 
     // Check writer sends the same bytes.
-    assertEquals(frame, windowUpdate(expectedWindowSizeIncrement));
+    assertThat(windowUpdate(expectedWindowSizeIncrement)).isEqualTo(frame);
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(windowSizeIncrement).isEqualTo(expectedWindowSizeIncrement);
       }
     });
   }
@@ -575,15 +584,15 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       windowUpdate(0);
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 0",
-          e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 0");
     }
     try {
       windowUpdate(0x80000000L);
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 2147483648",
-          e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 2147483648");
     }
   }
 
@@ -598,14 +607,15 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(expectedError.httpCode);
 
     // Check writer sends the same bytes.
-    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
+    assertThat(sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY)).isEqualTo(
+        frame);
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void goAway(
           int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-        assertEquals(expectedStreamId, lastGoodStreamId);
-        assertEquals(expectedError, errorCode);
-        assertEquals(0, debugData.size());
+        assertThat(lastGoodStreamId).isEqualTo(expectedStreamId);
+        assertThat(errorCode).isEqualTo(expectedError);
+        assertThat(debugData.size()).isEqualTo(0);
       }
     });
   }
@@ -624,14 +634,14 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.write(expectedData.toByteArray());
 
     // Check writer sends the same bytes.
-    assertEquals(frame, sendGoAway(0, expectedError, expectedData.toByteArray()));
+    assertThat(sendGoAway(0, expectedError, expectedData.toByteArray())).isEqualTo(frame);
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void goAway(
           int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-        assertEquals(0, lastGoodStreamId);
-        assertEquals(expectedError, errorCode);
-        assertEquals(expectedData, debugData);
+        assertThat(lastGoodStreamId).isEqualTo(0);
+        assertThat(errorCode).isEqualTo(expectedError);
+        assertThat(debugData).isEqualTo(expectedData);
       }
     });
   }
@@ -644,7 +654,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       fail();
     } catch (IllegalArgumentException e) {
       // TODO: real max is based on settings between 16384 and 16777215
-      assertEquals("FRAME_SIZE_ERROR length > 16384: 16777216", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("FRAME_SIZE_ERROR length > 16384: 16777216");
     }
   }
 
@@ -655,7 +665,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
     writer.applyAndAckSettings(new Settings().set(Settings.MAX_FRAME_SIZE, newMaxFrameSize));
 
-    assertEquals(newMaxFrameSize, writer.maxDataLength());
+    assertThat(writer.maxDataLength()).isEqualTo(newMaxFrameSize);
     writer.frameHeader(0, newMaxFrameSize, Http2.TYPE_DATA, FLAG_NONE);
   }
 
@@ -668,7 +678,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       writer.frameHeader(streamId, Http2.INITIAL_MAX_FRAME_SIZE, Http2.TYPE_DATA, FLAG_NONE);
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("reserved bit set: -2147483645", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("reserved bit set: -2147483645");
     }
   }
 
@@ -720,10 +730,10 @@ private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
     return new BaseTestHandler() {
       @Override public void headers(boolean inFinished, int streamId,
           int associatedStreamId, List<Header> headerBlock) {
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
+        assertThat(inFinished).isFalse();
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(associatedStreamId).isEqualTo(-1);
+        assertThat(headerBlock).isEqualTo(headerEntries("foo", "barrr", "baz", "qux"));
       }
     };
   }
@@ -732,12 +742,12 @@ private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
     return new BaseTestHandler() {
       @Override public void data(boolean inFinished, int streamId, BufferedSource source,
           int length) throws IOException {
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(1123, length);
+        assertThat(inFinished).isFalse();
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(length).isEqualTo(1123);
         ByteString data = source.readByteString(length);
         for (byte b : data.toByteArray()) {
-          assertEquals(2, b);
+          assertThat(b).isEqualTo((byte) 2);
         }
       }
     };
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
similarity index 71%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
rename to okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 6a8bcd0be4..ebf1700c3c 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -40,6 +40,8 @@
 import okhttp3.Interceptor;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
+import okhttp3.OkHttpClientTestRule;
+import okhttp3.PlatformRule;
 import okhttp3.Protocol;
 import okhttp3.RecordingCookieJar;
 import okhttp3.RecordingHostnameVerifier;
@@ -70,21 +72,19 @@
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
+import org.junit.rules.Timeout;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Arrays.asList;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
-import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.hamcrest.CoreMatchers.containsString;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertThat;
 import static org.junit.Assert.fail;
 import static org.junit.Assume.assumeTrue;
 
@@ -96,11 +96,14 @@
 
   @Parameters(name = "{0}")
   public static Collection<Protocol> data() {
-    return Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_2);
+    return asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_2);
   }
 
+  @Rule public final PlatformRule platform = new PlatformRule();
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+  @Rule public final Timeout timeout = new Timeout(5, SECONDS);
 
   private OkHttpClient client;
   private Cache cache;
@@ -115,15 +118,22 @@ public HttpOverHttp2Test(Protocol protocol) {
     this.protocol = protocol;
   }
 
-  private static OkHttpClient buildH2PriorKnowledgeClient() {
-    return defaultClient().newBuilder()
-        .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE))
+  @Before
+  public void checkHttp2() {
+    if (protocol == Protocol.HTTP_2) {
+      platform.assumeHttp2Support();
+    }
+  }
+
+  private OkHttpClient buildH2PriorKnowledgeClient() {
+    return clientTestRule.client.newBuilder()
+        .protocols(asList(Protocol.H2_PRIOR_KNOWLEDGE))
         .build();
   }
 
-  private static OkHttpClient buildHttp2Client() {
-    return defaultClient().newBuilder()
-        .protocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
+  private OkHttpClient buildHttp2Client() {
+    return clientTestRule.client.newBuilder()
+        .protocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
         .sslSocketFactory(
             handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
@@ -132,7 +142,7 @@ private static OkHttpClient buildHttp2Client() {
 
   @Before public void setUp() {
     if (protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
-      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE));
+      server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE));
     } else {
       server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     }
@@ -148,10 +158,6 @@ private static OkHttpClient buildHttp2Client() {
     Authenticator.setDefault(null);
     http2Logger.removeHandler(http2Handler);
     http2Logger.setLevel(previousLevel);
-
-    // Ensure a fresh connection pool for the next test.
-    client.connectionPool().evictAll();
-    assertEquals(0, client.connectionPool().connectionCount());
   }
 
   @Test public void get() throws Exception {
@@ -164,15 +170,16 @@ private static OkHttpClient buildHttp2Client() {
         .build());
     Response response = call.execute();
 
-    assertEquals("ABCDE", response.body().string());
-    assertEquals(200, response.code());
-    assertEquals("", response.message());
-    assertEquals(protocol, response.protocol());
+    assertThat(response.body().string()).isEqualTo("ABCDE");
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("");
+    assertThat(response.protocol()).isEqualTo(protocol);
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals(scheme, request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
+    assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(request.getHeader(":scheme")).isEqualTo(scheme);
+    assertThat(request.getHeader(":authority")).isEqualTo(
+        (server.getHostName() + ":" + server.getPort()));
   }
 
   @Test public void emptyResponse() throws IOException {
@@ -183,7 +190,7 @@ private static OkHttpClient buildHttp2Client() {
         .build());
     Response response = call.execute();
 
-    assertEquals(-1, response.body().byteStream().read());
+    assertThat(response.body().byteStream().read()).isEqualTo(-1);
     response.body().close();
   }
 
@@ -206,12 +213,12 @@ private static OkHttpClient buildHttp2Client() {
         .build());
 
     Response response = call.execute();
-    assertEquals("ABCDE", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABCDE");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertThat(request.getRequestLine()).isEqualTo("POST /foo HTTP/1.1");
     assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertNull(request.getHeader("Content-Length"));
+    assertThat(request.getHeader("Content-Length")).isNull();
   }
 
   @Test public void userSuppliedContentLengthHeader() throws Exception {
@@ -237,12 +244,13 @@ private static OkHttpClient buildHttp2Client() {
         .build());
 
     Response response = call.execute();
-    assertEquals("ABCDE", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABCDE");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertThat(request.getRequestLine()).isEqualTo("POST /foo HTTP/1.1");
     assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+    assertThat(Integer.parseInt(request.getHeader("Content-Length"))).isEqualTo(
+        (long) postBytes.length);
   }
 
   @Test public void closeAfterFlush() throws Exception {
@@ -270,12 +278,13 @@ private static OkHttpClient buildHttp2Client() {
         .build());
 
     Response response = call.execute();
-    assertEquals("ABCDE", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABCDE");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertThat(request.getRequestLine()).isEqualTo("POST /foo HTTP/1.1");
     assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+    assertThat(Integer.parseInt(request.getHeader("Content-Length"))).isEqualTo(
+        (long) postBytes.length);
   }
 
   @Test public void connectionReuse() throws Exception {
@@ -291,12 +300,12 @@ private static OkHttpClient buildHttp2Client() {
     Response response1 = call1.execute();
     Response response2 = call2.execute();
 
-    assertEquals("ABC", response1.body().source().readUtf8(3));
-    assertEquals("GHI", response2.body().source().readUtf8(3));
-    assertEquals("DEF", response1.body().source().readUtf8(3));
-    assertEquals("JKL", response2.body().source().readUtf8(3));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(response1.body().source().readUtf8(3)).isEqualTo("ABC");
+    assertThat(response2.body().source().readUtf8(3)).isEqualTo("GHI");
+    assertThat(response1.body().source().readUtf8(3)).isEqualTo("DEF");
+    assertThat(response2.body().source().readUtf8(3)).isEqualTo("JKL");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
 
     response1.close();
     response2.close();
@@ -318,14 +327,15 @@ private static OkHttpClient buildHttp2Client() {
     // Cancel the call and discard what we've buffered for the response body. This should free up
     // the connection flow-control window so new requests can proceed.
     call1.cancel();
-    assertFalse("Call should not have completed successfully.",
-        Util.discard(response1.body().source(), 1, TimeUnit.SECONDS));
+    assertThat(Util.discard(response1.body().source(), 1, TimeUnit.SECONDS))
+        .overridingErrorMessage("Call should not have completed successfully.")
+        .isFalse();
 
     Call call2 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("abc", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("abc");
   }
 
   /** Wait for the client to receive {@code dataLength} DATA frames. */
@@ -362,7 +372,7 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("abc", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("abc");
   }
 
   @Test public void concurrentRequestWithEmptyFlowControlWindow() throws Exception {
@@ -378,9 +388,10 @@ private void waitForDataFrames(int dataLength) throws Exception {
 
     waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
 
-    assertEquals(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE, response1.body().contentLength());
+    assertThat(response1.body().contentLength()).isEqualTo(
+        (long) Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
     int read = response1.body().source().read(new byte[8192]);
-    assertEquals(8192, read);
+    assertThat(read).isEqualTo(8192);
 
     // Make a second call that should transmit the response headers. The response body won't be
     // transmitted until the flow-control window is updated from the first request.
@@ -388,13 +399,13 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals(200, response2.code());
+    assertThat(response2.code()).isEqualTo(200);
 
     // Close the response body. This should discard the buffered data and update the connection
     // flow-control window.
     response1.close();
 
-    assertEquals("abc", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("abc");
   }
 
   /** https://github.com/square/okhttp/issues/373 */
@@ -407,8 +418,8 @@ private void waitForDataFrames(int dataLength) throws Exception {
     executor.execute(new AsyncRequest("/r1", countDownLatch));
     executor.execute(new AsyncRequest("/r2", countDownLatch));
     countDownLatch.await();
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void gzippedResponseBody() throws Exception {
@@ -421,7 +432,7 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .build());
 
     Response response = call.execute();
-    assertEquals("ABCABCABC", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABCABCABC");
   }
 
   @Test public void authenticate() throws Exception {
@@ -441,13 +452,13 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("Successful auth!", response.body().string());
+    assertThat(response.body().string()).isEqualTo("Successful auth!");
 
     RecordedRequest denied = server.takeRequest();
-    assertNull(denied.getHeader("Authorization"));
+    assertThat(denied.getHeader("Authorization")).isNull();
     RecordedRequest accepted = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", accepted.getRequestLine());
-    assertEquals(credential, accepted.getHeader("Authorization"));
+    assertThat(accepted.getRequestLine()).isEqualTo("GET / HTTP/1.1");
+    assertThat(accepted.getHeader("Authorization")).isEqualTo(credential);
   }
 
   @Test public void redirect() throws Exception {
@@ -461,12 +472,12 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .build());
 
     Response response = call.execute();
-    assertEquals("This is the new location!", response.body().string());
+    assertThat(response.body().string()).isEqualTo("This is the new location!");
 
     RecordedRequest request1 = server.takeRequest();
-    assertEquals("/", request1.getPath());
+    assertThat(request1.getPath()).isEqualTo("/");
     RecordedRequest request2 = server.takeRequest();
-    assertEquals("/foo", request2.getPath());
+    assertThat(request2.getPath()).isEqualTo("/foo");
   }
 
   @Test public void readAfterLastByte() throws Exception {
@@ -478,11 +489,11 @@ private void waitForDataFrames(int dataLength) throws Exception {
     Response response = call.execute();
 
     InputStream in = response.body().byteStream();
-    assertEquals('A', in.read());
-    assertEquals('B', in.read());
-    assertEquals('C', in.read());
-    assertEquals(-1, in.read());
-    assertEquals(-1, in.read());
+    assertThat(in.read()).isEqualTo('A');
+    assertThat(in.read()).isEqualTo('B');
+    assertThat(in.read()).isEqualTo('C');
+    assertThat(in.read()).isEqualTo(-1);
+    assertThat(in.read()).isEqualTo(-1);
 
     in.close();
   }
@@ -503,7 +514,7 @@ private void waitForDataFrames(int dataLength) throws Exception {
       call1.execute();
       fail("Should have timed out!");
     } catch (SocketTimeoutException expected) {
-      assertEquals("timeout", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("timeout");
     }
 
     // Confirm that a subsequent request on the same connection is not impacted.
@@ -511,11 +522,11 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("A", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("A");
 
     // Confirm that the connection was reused.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   /**
@@ -538,7 +549,7 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .build());
 
     Response response = call.execute();
-    assertEquals(new String(body), response.body().string());
+    assertThat(response.body().string()).isEqualTo(new String(body));
   }
 
   /**
@@ -568,7 +579,7 @@ private void waitForDataFrames(int dataLength) throws Exception {
       response1.body().string();
       fail("Should have timed out!");
     } catch (SocketTimeoutException expected) {
-      assertEquals("timeout", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("timeout");
     }
 
     // Confirm that a subsequent request on the same connection is not impacted.
@@ -576,11 +587,11 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals(body, response2.body().string());
+    assertThat(response2.body().string()).isEqualTo(body);
 
     // Confirm that the connection was reused.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void connectionTimeout() throws Exception {
@@ -605,7 +616,7 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .build());
 
     Response response1 = call1.execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
 
     try {
       call2.execute();
@@ -614,8 +625,8 @@ private void waitForDataFrames(int dataLength) throws Exception {
     }
 
     // Confirm that the connection was reused.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void responsesAreCached() throws IOException {
@@ -632,26 +643,26 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .build());
     Response response1 = call1.execute();
 
-    assertEquals("A", response1.body().string());
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
+    assertThat(response1.body().string()).isEqualTo("A");
+    assertThat(cache.requestCount()).isEqualTo(1);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(0);
 
     Call call2 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("A", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("A");
 
     Call call3 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response3 = call3.execute();
-    assertEquals("A", response3.body().string());
+    assertThat(response3.body().string()).isEqualTo("A");
 
-    assertEquals(3, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(2, cache.hitCount());
+    assertThat(cache.requestCount()).isEqualTo(3);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(2);
   }
 
   @Test public void conditionalCache() throws IOException {
@@ -669,21 +680,21 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .url(server.url("/"))
         .build());
     Response response1 = call1.execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
 
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
+    assertThat(cache.requestCount()).isEqualTo(1);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(0);
 
     Call call2 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("A", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("A");
 
-    assertEquals(2, cache.requestCount());
-    assertEquals(2, cache.networkCount());
-    assertEquals(1, cache.hitCount());
+    assertThat(cache.requestCount()).isEqualTo(2);
+    assertThat(cache.networkCount()).isEqualTo(2);
+    assertThat(cache.hitCount()).isEqualTo(1);
   }
 
   @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
@@ -702,14 +713,14 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .url(server.url("/"))
         .build());
     Response response1 = call1.execute();
-    assertEquals("AB", response1.body().source().readUtf8(2));
+    assertThat(response1.body().source().readUtf8(2)).isEqualTo("AB");
     response1.body().close();
 
     Call call2 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("ABCD", response2.body().source().readUtf8());
+    assertThat(response2.body().source().readUtf8()).isEqualTo("ABCD");
     response2.body().close();
   }
 
@@ -730,10 +741,10 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("", response.body().string());
+    assertThat(response.body().string()).isEqualTo("");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("a=b", request.getHeader("Cookie"));
+    assertThat(request.getHeader("Cookie")).isEqualTo("a=b");
   }
 
   @Test public void receiveResponseCookies() throws Exception {
@@ -749,7 +760,7 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("", response.body().string());
+    assertThat(response.body().string()).isEqualTo("");
 
     cookieJar.assertResponseCookies("a=b; path=/");
   }
@@ -768,13 +779,13 @@ private void waitForDataFrames(int dataLength) throws Exception {
     call1.cancel();
 
     // That connection is pooled, and it works.
-    assertEquals(1, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
     Call call2 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("def", response2.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(response2.body().string()).isEqualTo("def");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
 
     // Clean up the connection.
     response.close();
@@ -791,10 +802,12 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("abc", response.body().string());
+    assertThat(response.body().string()).isEqualTo("abc");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reused connection.
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Reused connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void recoverFromOneInternalErrorRequiresNewConnection() throws Exception {
@@ -812,10 +825,12 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("abc", response.body().string());
+    assertThat(response.body().string()).isEqualTo("abc");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void recoverFromMultipleRefusedStreamsRequiresNewConnection() throws Exception {
@@ -836,63 +851,120 @@ private void waitForDataFrames(int dataLength) throws Exception {
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("abc", response.body().string());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reused connection.
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertThat(response.body().string()).isEqualTo("abc");
+
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Reused connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void recoverFromCancelReusesConnection() throws Exception {
-    server.enqueue(new MockResponse()
+    List<CountDownLatch> responseDequeuedLatches = Arrays.asList(
+        new CountDownLatch(1),
+        // No synchronization is needed for the last request, which is not canceled.
+        new CountDownLatch(0));
+    List<CountDownLatch> requestCanceledLatches = Arrays.asList(
+        new CountDownLatch(1),
+        new CountDownLatch(0));
+
+    QueueDispatcher dispatcher =
+        new RespondAfterCancelDispatcher(responseDequeuedLatches, requestCanceledLatches);
+    dispatcher.enqueueResponse(new MockResponse()
         .setBodyDelay(10, TimeUnit.SECONDS)
         .setBody("abc"));
-    server.enqueue(new MockResponse()
+    dispatcher.enqueueResponse(new MockResponse()
         .setBody("def"));
+    server.setDispatcher(dispatcher);
 
     client = client.newBuilder()
         .dns(new DoubleInetAddressDns())
         .build();
 
-    callAndCancel(0);
+    callAndCancel(0, responseDequeuedLatches.get(0), requestCanceledLatches.get(0));
 
     // Make a second request to ensure the connection is reused.
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("def", response.body().string());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(response.body().string()).isEqualTo("def");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void recoverFromMultipleCancelReusesConnection() throws Exception {
-    server.enqueue(new MockResponse()
+    List<CountDownLatch> responseDequeuedLatches = Arrays.asList(
+        new CountDownLatch(1),
+        new CountDownLatch(1),
+        // No synchronization is needed for the last request, which is not canceled.
+        new CountDownLatch(0));
+    List<CountDownLatch> requestCanceledLatches = Arrays.asList(
+        new CountDownLatch(1),
+        new CountDownLatch(1),
+        new CountDownLatch(0));
+
+    QueueDispatcher dispatcher =
+        new RespondAfterCancelDispatcher(responseDequeuedLatches, requestCanceledLatches);
+    dispatcher.enqueueResponse(new MockResponse()
             .setBodyDelay(10, TimeUnit.SECONDS)
             .setBody("abc"));
-    server.enqueue(new MockResponse()
+    dispatcher.enqueueResponse(new MockResponse()
             .setBodyDelay(10, TimeUnit.SECONDS)
             .setBody("def"));
-    server.enqueue(new MockResponse()
+    dispatcher.enqueueResponse(new MockResponse()
             .setBody("ghi"));
+    server.setDispatcher(dispatcher);
 
     client = client.newBuilder()
             .dns(new DoubleInetAddressDns())
             .build();
 
-    callAndCancel(0);
-    callAndCancel(1);
+    callAndCancel(0, responseDequeuedLatches.get(0), requestCanceledLatches.get(0));
+    callAndCancel(1, responseDequeuedLatches.get(1), requestCanceledLatches.get(1));
 
     // Make a third request to ensure the connection is reused.
     Call call = client.newCall(new Request.Builder()
             .url(server.url("/"))
             .build());
     Response response = call.execute();
-    assertEquals("ghi", response.body().string());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
+    assertThat(response.body().string()).isEqualTo("ghi");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
+  }
+
+  private class RespondAfterCancelDispatcher extends QueueDispatcher {
+    final private List<CountDownLatch> responseDequeuedLatches;
+    final private List<CountDownLatch> requestCanceledLatches;
+    private int responseIndex = 0;
+
+    RespondAfterCancelDispatcher(
+        List<CountDownLatch> responseDequeuedLatches,
+        List<CountDownLatch> requestCanceledLatches) {
+      this.responseDequeuedLatches = responseDequeuedLatches;
+      this.requestCanceledLatches = requestCanceledLatches;
+    }
+
+    @Override
+    synchronized public MockResponse dispatch(RecordedRequest request)
+        throws InterruptedException {
+      // This guarantees a deterministic sequence when handling the canceled request:
+      // 1. Server reads request and dequeues first response
+      // 2. Client cancels request
+      // 3. Server tries to send response on the canceled stream
+      // Otherwise, there is no guarantee for the sequence. For example, the server may use the
+      // first mocked response to respond to the second request.
+      MockResponse response = super.dispatch(request);
+      responseDequeuedLatches.get(responseIndex).countDown();
+      requestCanceledLatches.get(responseIndex).await();
+      responseIndex++;
+      return response;
+    }
   }
 
   /** Make a call and canceling it as soon as it's accepted by the server. */
-  private void callAndCancel(int expectedSequenceNumber) throws Exception {
+  private void callAndCancel(int expectedSequenceNumber, CountDownLatch responseDequeuedLatch,
+      CountDownLatch requestCanceledLatch) throws Exception {
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
@@ -903,10 +975,14 @@ private void callAndCancel(int expectedSequenceNumber) throws Exception {
       }
 
       @Override public void onResponse(Call call1, Response response) {
+        fail();
       }
     });
-    assertEquals(expectedSequenceNumber, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(
+        (long) expectedSequenceNumber);
+    responseDequeuedLatch.await();
     call.cancel();
+    requestCanceledLatch.countDown();
     latch.await();
   }
 
@@ -936,7 +1012,7 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
       call.execute();
       fail();
     } catch (StreamResetException expected) {
-      assertEquals(errorCode, expected.errorCode);
+      assertThat(expected.errorCode).isEqualTo(errorCode);
     }
   }
 
@@ -986,24 +1062,24 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
         .build();
     blockingAuthClient.newCall(request).enqueue(callback);
     String response1 = responses.take();
-    assertEquals("", response1);
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(response1).isEqualTo("");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
 
     // Now make the second request which will restrict the first HTTP/2 connection from creating new
     // streams.
     client.newCall(request).enqueue(callback);
     String response2 = responses.take();
-    assertEquals("DEF", response2);
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(response2).isEqualTo("DEF");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
 
     // Let the first request proceed. It should discard the the held HTTP/2 connection and get a new
     // one.
     latch.countDown();
     String response3 = responses.take();
-    assertEquals("ABC", response3);
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
+    assertThat(response3).isEqualTo("ABC");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
   }
 
   @Test public void nonAsciiResponseHeader() throws Exception {
@@ -1017,8 +1093,8 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     Response response = call.execute();
     response.close();
 
-    assertEquals("", response.header("Alpha"));
-    assertEquals("Beta", response.header(""));
+    assertThat(response.header("Alpha")).isEqualTo("");
+    assertThat(response.header("")).isEqualTo("Beta");
   }
 
   @Test public void serverSendsPushPromise_GET() throws Exception {
@@ -1034,18 +1110,20 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
         .build());
     Response response = call.execute();
 
-    assertEquals("ABCDE", response.body().string());
-    assertEquals(200, response.code());
-    assertEquals("", response.message());
+    assertThat(response.body().string()).isEqualTo("ABCDE");
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals(scheme, request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
+    assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(request.getHeader(":scheme")).isEqualTo(scheme);
+    assertThat(request.getHeader(":authority")).isEqualTo(
+        (server.getHostName() + ":" + server.getPort()));
 
     RecordedRequest pushedRequest = server.takeRequest();
-    assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
-    assertEquals("bar", pushedRequest.getHeader("foo"));
+    assertThat(pushedRequest.getRequestLine()).isEqualTo(
+        "GET /foo/bar HTTP/1.1");
+    assertThat(pushedRequest.getHeader("foo")).isEqualTo("bar");
   }
 
   @Test public void serverSendsPushPromise_HEAD() throws Exception {
@@ -1060,18 +1138,20 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
         .url(server.url("/foo"))
         .build());
     Response response = call.execute();
-    assertEquals("ABCDE", response.body().string());
-    assertEquals(200, response.code());
-    assertEquals("", response.message());
+    assertThat(response.body().string()).isEqualTo("ABCDE");
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals(scheme, request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
+    assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(request.getHeader(":scheme")).isEqualTo(scheme);
+    assertThat(request.getHeader(":authority")).isEqualTo(
+        (server.getHostName() + ":" + server.getPort()));
 
     RecordedRequest pushedRequest = server.takeRequest();
-    assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
-    assertEquals("bar", pushedRequest.getHeader("foo"));
+    assertThat(pushedRequest.getRequestLine()).isEqualTo(
+        "HEAD /foo/bar HTTP/1.1");
+    assertThat(pushedRequest.getHeader("foo")).isEqualTo("bar");
   }
 
   @Test public void noDataFramesSentWithNullRequestBody() throws Exception {
@@ -1083,13 +1163,15 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
         .method("DELETE", null)
         .build());
     Response response = call.execute();
-    assertEquals("ABC", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABC");
 
-    assertEquals(protocol, response.protocol());
+    assertThat(response.protocol()).isEqualTo(protocol);
 
     List<String> logs = http2Handler.takeAll();
 
-    assertThat("header logged", firstFrame(logs, "HEADERS"), containsString("HEADERS       END_STREAM|END_HEADERS"));
+    assertThat(firstFrame(logs, "HEADERS"))
+        .overridingErrorMessage("header logged")
+        .contains("HEADERS       END_STREAM|END_HEADERS");
   }
 
   @Test public void emptyDataFrameSentWithEmptyBody() throws Exception {
@@ -1101,14 +1183,22 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
         .method("DELETE", Util.EMPTY_REQUEST)
         .build());
     Response response = call.execute();
-    assertEquals("ABC", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABC");
 
-    assertEquals(protocol, response.protocol());
+    assertThat(response.protocol()).isEqualTo(protocol);
 
     List<String> logs = http2Handler.takeAll();
 
-    assertThat("header logged", firstFrame(logs, "HEADERS"), containsString("HEADERS       END_HEADERS"));
-    assertThat("data logged", firstFrame(logs, "DATA"), containsString("0 DATA          END_STREAM"));
+    assertThat(firstFrame(logs, "HEADERS"))
+        .overridingErrorMessage("header logged")
+        .contains("HEADERS       END_HEADERS");
+    // While MockWebServer waits to read the client's HEADERS frame before sending the response, it
+    // doesn't wait to read the client's DATA frame and may send a DATA frame before the client
+    // does. So we can't assume the client's empty DATA will be logged first.
+    assertThat(countFrames(logs, "FINE: >> 0x00000003     0 DATA          END_STREAM"))
+        .isEqualTo((long) 2);
+    assertThat(countFrames(logs, "FINE: >> 0x00000003     3 DATA          "))
+        .isEqualTo((long) 1);
   }
 
   @Test public void pingsTransmitted() throws Exception {
@@ -1126,16 +1216,20 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("ABC", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABC");
 
-    assertEquals(protocol, response.protocol());
+    assertThat(response.protocol()).isEqualTo(protocol);
 
     // Confirm a single ping was sent and received, and its reply was sent and received.
     List<String> logs = http2Handler.takeAll();
-    assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          "));
-    assertEquals(1, countFrames(logs, "FINE: << 0x00000000     8 PING          "));
-    assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          ACK"));
-    assertEquals(1, countFrames(logs, "FINE: << 0x00000000     8 PING          ACK"));
+    assertThat(countFrames(logs, "FINE: >> 0x00000000     8 PING          ")).isEqualTo(
+        (long) 1);
+    assertThat(countFrames(logs, "FINE: << 0x00000000     8 PING          ")).isEqualTo(
+        (long) 1);
+    assertThat(countFrames(logs, "FINE: >> 0x00000000     8 PING          ACK")).isEqualTo(
+        (long) 1);
+    assertThat(countFrames(logs, "FINE: << 0x00000000     8 PING          ACK")).isEqualTo(
+        (long) 1);
   }
 
   @Test public void missingPongsFailsConnection() throws Exception {
@@ -1158,16 +1252,20 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
       call.execute();
       fail();
     } catch (StreamResetException expected) {
-      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "stream was reset: PROTOCOL_ERROR");
     }
 
     long elapsedUntilFailure = System.nanoTime() - executeAtNanos;
-    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo(
+        (double) 1000, offset(250d));
 
     // Confirm a single ping was sent but not acknowledged.
     List<String> logs = http2Handler.takeAll();
-    assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          "));
-    assertEquals(0, countFrames(logs, "FINE: << 0x00000000     8 PING          ACK"));
+    assertThat(countFrames(logs, "FINE: >> 0x00000000     8 PING          ")).isEqualTo(
+        (long) 1);
+    assertThat(countFrames(logs, "FINE: << 0x00000000     8 PING          ACK")).isEqualTo(
+        (long) 0);
   }
 
   private String firstFrame(List<String> logs, String type) {
@@ -1204,7 +1302,7 @@ private int countFrames(List<String> logs, String message) {
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("", response.body().string());
+    assertThat(response.body().string()).isEqualTo("");
 
     server.enqueue(new MockResponse()
         .setBody("ABC"));
@@ -1228,13 +1326,17 @@ private int countFrames(List<String> logs, String message) {
         .build());
     Response response3 = call3.execute();
 
-    assertEquals("ABC", response1.body().string());
-    assertEquals("DEF", response2.body().string());
-    assertEquals("GHI", response3.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // Settings connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
-    assertEquals(2, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection!
+    assertThat(response1.body().string()).isEqualTo("ABC");
+    assertThat(response2.body().string()).isEqualTo("DEF");
+    assertThat(response3.body().string()).isEqualTo("GHI");
+    // Settings connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Reuse settings connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    // Reuse settings connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
+    // New connection!
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void connectionNotReusedAfterShutdown() throws Exception {
@@ -1248,15 +1350,15 @@ private int countFrames(List<String> logs, String message) {
         .url(server.url("/"))
         .build());
     Response response1 = call1.execute();
-    assertEquals("ABC", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("ABC");
 
     Call call2 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("DEF", response2.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(response2.body().string()).isEqualTo("DEF");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   /**
@@ -1283,7 +1385,7 @@ private int countFrames(List<String> logs, String message) {
                   .url(server.url("/"))
                   .build());
               Response response = call.execute();
-              assertEquals("ABC", response.body().string());
+              assertThat(response.body().string()).isEqualTo("ABC");
               // Wait until the GOAWAY has been processed.
               RealConnection connection = (RealConnection) chain.connection();
               while (connection.isHealthy(false)) ;
@@ -1297,10 +1399,10 @@ private int countFrames(List<String> logs, String message) {
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("DEF", response.body().string());
+    assertThat(response.body().string()).isEqualTo("DEF");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void responseHeadersAfterGoaway() throws Exception {
@@ -1323,9 +1425,9 @@ private int countFrames(List<String> logs, String message) {
     client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
     client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
 
-    assertEquals("DEF", bodies.poll(2, SECONDS));
-    assertEquals("ABC", bodies.poll(2, SECONDS));
-    assertEquals(2, server.getRequestCount());
+    assertThat(bodies.poll(2, SECONDS)).isEqualTo("DEF");
+    assertThat(bodies.poll(2, SECONDS)).isEqualTo("ABC");
+    assertThat(server.getRequestCount()).isEqualTo(2);
   }
 
   /**
@@ -1367,7 +1469,7 @@ private int countFrames(List<String> logs, String message) {
                 .url("https://android.com/call2")
                 .build());
             Response response2 = call2.execute();
-            assertEquals("call2 response", response2.body().string());
+            assertThat(response2.body().string()).isEqualTo("call2 response");
           } catch (IOException e) {
             throw new RuntimeException(e);
           }
@@ -1393,27 +1495,27 @@ private int countFrames(List<String> logs, String message) {
         .url("https://android.com/call1")
         .build());
     Response response2 = call1.execute();
-    assertEquals("call1 response", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("call1 response");
 
     RecordedRequest call1Connect = server.takeRequest();
-    assertEquals("CONNECT", call1Connect.getMethod());
-    assertEquals(0, call1Connect.getSequenceNumber());
+    assertThat(call1Connect.getMethod()).isEqualTo("CONNECT");
+    assertThat(call1Connect.getSequenceNumber()).isEqualTo(0);
 
     RecordedRequest call2Connect = server.takeRequest();
-    assertEquals("CONNECT", call2Connect.getMethod());
-    assertEquals(0, call2Connect.getSequenceNumber());
+    assertThat(call2Connect.getMethod()).isEqualTo("CONNECT");
+    assertThat(call2Connect.getSequenceNumber()).isEqualTo(0);
 
     RecordedRequest call2Get = server.takeRequest();
-    assertEquals("GET", call2Get.getMethod());
-    assertEquals("/call2", call2Get.getPath());
-    assertEquals(0, call2Get.getSequenceNumber());
+    assertThat(call2Get.getMethod()).isEqualTo("GET");
+    assertThat(call2Get.getPath()).isEqualTo("/call2");
+    assertThat(call2Get.getSequenceNumber()).isEqualTo(0);
 
     RecordedRequest call1Get = server.takeRequest();
-    assertEquals("GET", call1Get.getMethod());
-    assertEquals("/call1", call1Get.getPath());
-    assertEquals(1, call1Get.getSequenceNumber());
+    assertThat(call1Get.getMethod()).isEqualTo("GET");
+    assertThat(call1Get.getPath()).isEqualTo("/call1");
+    assertThat(call1Get.getSequenceNumber()).isEqualTo(1);
 
-    assertEquals(1, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
   /** https://github.com/square/okhttp/issues/3103 */
@@ -1436,10 +1538,11 @@ private int countFrames(List<String> logs, String message) {
         .build());
 
     Response response = call.execute();
-    assertEquals("", response.body().string());
+    assertThat(response.body().string()).isEqualTo("");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("privateobject.com", recordedRequest.getHeader(":authority"));
+    assertThat(recordedRequest.getHeader(":authority")).isEqualTo(
+        "privateobject.com");
   }
 
   private Buffer gzip(String bytes) throws IOException {
@@ -1465,7 +1568,7 @@ private Buffer gzip(String bytes) throws IOException {
             .url(server.url(path))
             .build());
         Response response = call.execute();
-        assertEquals("A", response.body().string());
+        assertThat(response.body().string()).isEqualTo("A");
         countDownLatch.countDown();
       } catch (Exception e) {
         throw new RuntimeException(e);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java b/okhttp/src/test/java/okhttp3/internal/http2/HuffmanTest.java
similarity index 92%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
rename to okhttp/src/test/java/okhttp3/internal/http2/HuffmanTest.java
index e92445f266..b84d2de09f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/HuffmanTest.java
@@ -21,8 +21,8 @@
 import okio.ByteString;
 import org.junit.Test;
 
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
 
 /** Original version of this class was lifted from {@code com.twitter.hpack.HuffmanTest}. */
 public final class HuffmanTest {
@@ -41,7 +41,7 @@
   private void assertRoundTrip(ByteString data) throws IOException {
     Buffer buffer = new Buffer();
     Huffman.get().encode(data, buffer);
-    assertEquals(buffer.size(), Huffman.get().encodedLength(data));
+    assertThat(Huffman.get().encodedLength(data)).isEqualTo(buffer.size());
 
     byte[] decodedBytes = Huffman.get().decode(buffer.readByteArray());
     assertArrayEquals(data.toByteArray(), decodedBytes);
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java b/okhttp/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
rename to okhttp/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java b/okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java
similarity index 61%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java
rename to okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java
index 46ec0a82ab..8e2aa424b2 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java
@@ -19,43 +19,41 @@
 
 import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class SettingsTest {
   @Test public void unsetField() {
     Settings settings = new Settings();
-    assertEquals(-3, settings.getMaxConcurrentStreams(-3));
+    assertThat(settings.getMaxConcurrentStreams(-3)).isEqualTo(-3);
   }
 
   @Test public void setFields() {
     Settings settings = new Settings();
 
     settings.set(Settings.HEADER_TABLE_SIZE, 8096);
-    assertEquals(8096, settings.getHeaderTableSize());
+    assertThat(settings.getHeaderTableSize()).isEqualTo(8096);
 
-    assertTrue(settings.getEnablePush(true));
+    assertThat(settings.getEnablePush(true)).isTrue();
     settings.set(Settings.ENABLE_PUSH, 1);
-    assertTrue(settings.getEnablePush(false));
+    assertThat(settings.getEnablePush(false)).isTrue();
     settings.clear();
 
-    assertEquals(-3, settings.getMaxConcurrentStreams(-3));
+    assertThat(settings.getMaxConcurrentStreams(-3)).isEqualTo(-3);
     settings.set(MAX_CONCURRENT_STREAMS, 75);
-    assertEquals(75, settings.getMaxConcurrentStreams(-3));
+    assertThat(settings.getMaxConcurrentStreams(-3)).isEqualTo(75);
 
     settings.clear();
-    assertEquals(16384, settings.getMaxFrameSize(16384));
+    assertThat(settings.getMaxFrameSize(16384)).isEqualTo(16384);
     settings.set(Settings.MAX_FRAME_SIZE, 16777215);
-    assertEquals(16777215, settings.getMaxFrameSize(16384));
+    assertThat(settings.getMaxFrameSize(16384)).isEqualTo(16777215);
 
-    assertEquals(-1, settings.getMaxHeaderListSize(-1));
+    assertThat(settings.getMaxHeaderListSize(-1)).isEqualTo(-1);
     settings.set(Settings.MAX_HEADER_LIST_SIZE, 16777215);
-    assertEquals(16777215, settings.getMaxHeaderListSize(-1));
+    assertThat(settings.getMaxHeaderListSize(-1)).isEqualTo(16777215);
 
-    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE,
-        settings.getInitialWindowSize());
+    assertThat(settings.getInitialWindowSize()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
     settings.set(Settings.INITIAL_WINDOW_SIZE, 108);
-    assertEquals(108, settings.getInitialWindowSize());
+    assertThat(settings.getInitialWindowSize()).isEqualTo(108);
   }
 
   @Test public void merge() {
@@ -70,9 +68,9 @@
     b.set(Settings.MAX_CONCURRENT_STREAMS, 60000);
 
     a.merge(b);
-    assertEquals(10000, a.getHeaderTableSize());
-    assertEquals(40000, a.getMaxHeaderListSize(-1));
-    assertEquals(50000, a.getInitialWindowSize());
-    assertEquals(60000, a.getMaxConcurrentStreams(-1));
+    assertThat(a.getHeaderTableSize()).isEqualTo(10000);
+    assertThat(a.getMaxHeaderListSize(-1)).isEqualTo(40000);
+    assertThat(a.getInitialWindowSize()).isEqualTo(50000);
+    assertThat(a.getMaxConcurrentStreams(-1)).isEqualTo(60000);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java b/okhttp/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
rename to okhttp/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java b/okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
similarity index 56%
rename from okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
rename to okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
index bc981e9a36..95046f2237 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
@@ -15,17 +15,29 @@
  */
 package okhttp3.internal.platform;
 
+import okhttp3.PlatformRule;
+import org.junit.Rule;
 import org.junit.Test;
 
-import static okhttp3.internal.platform.PlatformTest.getPlatform;
-import static org.junit.Assert.assertNotNull;
+import static org.assertj.core.api.Java6Assertions.assertThat;
+import static org.junit.Assume.assumeFalse;
 import static org.junit.Assume.assumeTrue;
 
 public class Jdk8WithJettyBootPlatformTest {
+  @Rule public final PlatformRule platform = new PlatformRule();
+
   @Test
   public void testBuildsWithJettyBoot() {
-    assumeTrue(getPlatform().equals("jdk-with-jetty-boot"));
+    assumeTrue(System.getProperty("java.specification.version").equals("1.8"));
+    platform.assumeJettyBootEnabled();
+
+    assertThat(Jdk8WithJettyBootPlatform.buildIfSupported()).isNotNull();
+  }
+
+  @Test
+  public void testNotBuildWithOther() {
+    assumeFalse(System.getProperty("java.specification.version").equals("1.8"));
 
-    assertNotNull(Jdk8WithJettyBootPlatform.buildIfSupported());
+    assertThat(Jdk8WithJettyBootPlatform.buildIfSupported()).isNull();
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java b/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
similarity index 56%
rename from okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
rename to okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
index 2889911d52..ff00d8d654 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
@@ -15,33 +15,32 @@
  */
 package okhttp3.internal.platform;
 
+import java.lang.reflect.Method;
+import okhttp3.PlatformRule;
+import org.junit.Rule;
 import org.junit.Test;
 
-import static okhttp3.internal.platform.PlatformTest.getPlatform;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assume.assumeTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class Jdk9PlatformTest {
+  @Rule public final PlatformRule platform = new PlatformRule("jdk9");
+
   @Test
   public void buildsWhenJdk9() {
-    assumeTrue(getPlatform().equals("jdk9"));
-
-    assertNotNull(Jdk9Platform.buildIfSupported());
+    assertThat(Jdk9Platform.buildIfSupported()).isNotNull();
   }
 
   @Test
   public void findsAlpnMethods() {
-    assumeTrue(getPlatform().equals("jdk9"));
-
     Jdk9Platform platform = Jdk9Platform.buildIfSupported();
 
-    assertEquals("getApplicationProtocol", platform.getProtocolMethod.getName());
-    assertEquals("setApplicationProtocols", platform.setProtocolMethod.getName());
+    assertThat(platform.getProtocolMethod.getName()).isEqualTo("getApplicationProtocol");
+    assertThat(platform.setProtocolMethod.getName()).isEqualTo("setApplicationProtocols");
   }
 
   @Test
-  public void testToStringIsClassname() {
-    assertEquals("Jdk9Platform", new Jdk9Platform(null, null).toString());
+  public void testToStringIsClassname() throws NoSuchMethodException {
+    Method method = this.getClass().getMethod("toString");
+    assertThat(new Jdk9Platform(method, method).toString()).isEqualTo("Jdk9Platform");
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java b/okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java
similarity index 68%
rename from okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
rename to okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java
index 48504202b5..fe399a1f16 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java
@@ -15,26 +15,31 @@
  */
 package okhttp3.internal.platform;
 
+import okhttp3.PlatformRule;
+import org.junit.Rule;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class PlatformTest {
+  @Rule
+  public PlatformRule platform = new PlatformRule();
+
   @Test public void alwaysBuilds() {
     new Platform();
   }
 
   /** Guard against the default value changing by accident. */
   @Test public void defaultPrefix() {
-    assertEquals("OkHttp", new Platform().getPrefix());
+    assertThat(new Platform().getPrefix()).isEqualTo("OkHttp");
   }
 
-  public static String getPlatform() {
-    return System.getProperty("okhttp.platform", "platform");
+  public static String getJvmSpecVersion() {
+    return System.getProperty("java.specification.version", "unknown");
   }
 
   @Test
   public void testToStringIsClassname() {
-    assertEquals("Platform", new Platform().toString());
+    assertThat(new Platform().toString()).isEqualTo("Platform");
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
similarity index 80%
rename from okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
rename to okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
index e999890991..70d44bbe28 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
@@ -25,9 +25,7 @@
 import org.junit.Test;
 
 import static okhttp3.internal.publicsuffix.PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class PublicSuffixDatabaseTest {
@@ -40,12 +38,14 @@
         .writeUtf8("square.com\n");
     publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
 
-    assertEquals("example.com", publicSuffixDatabase.getEffectiveTldPlusOne("example.com"));
-    assertEquals("example.com", publicSuffixDatabase.getEffectiveTldPlusOne("foo.example.com"));
-    assertEquals("bar.square.com",
-        publicSuffixDatabase.getEffectiveTldPlusOne("foo.bar.square.com"));
-    assertEquals("foo.my.square.com",
-        publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com"));
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("example.com")).isEqualTo(
+        "example.com");
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.example.com")).isEqualTo(
+        "example.com");
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.bar.square.com")).isEqualTo(
+        "bar.square.com");
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com")).isEqualTo(
+        "foo.my.square.com");
   }
 
   @Test public void wildcardMatch() {
@@ -55,11 +55,11 @@
         .writeUtf8("example.com\n");
     publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
 
-    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("my.square.com"));
-    assertEquals("foo.my.square.com",
-        publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com"));
-    assertEquals("foo.my.square.com",
-        publicSuffixDatabase.getEffectiveTldPlusOne("bar.foo.my.square.com"));
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("my.square.com")).isNull();
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com")).isEqualTo(
+        "foo.my.square.com");
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("bar.foo.my.square.com")).isEqualTo(
+        "foo.my.square.com");
   }
 
   @Test public void boundarySearches() {
@@ -69,10 +69,10 @@
         .writeUtf8("fff\n");
     publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
 
-    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("aaa"));
-    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("ggg"));
-    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("ccc"));
-    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("eee"));
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("aaa")).isNull();
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("ggg")).isNull();
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("ccc")).isNull();
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("eee")).isNull();
   }
 
   @Test public void exceptionRule() {
@@ -85,9 +85,11 @@
         .writeUtf8("square.com\n");
     publicSuffixDatabase.setListBytes(buffer.readByteArray(), exception.readByteArray());
 
-    assertEquals("my.square.jp", publicSuffixDatabase.getEffectiveTldPlusOne("my.square.jp"));
-    assertEquals("my.square.jp", publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.jp"));
-    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("my1.square.jp"));
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("my.square.jp")).isEqualTo(
+        "my.square.jp");
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.jp")).isEqualTo(
+        "my.square.jp");
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("my1.square.jp")).isNull();
   }
 
   @Test public void noEffectiveTldPlusOne() {
@@ -100,8 +102,8 @@
         .writeUtf8("square.com\n");
     publicSuffixDatabase.setListBytes(buffer.readByteArray(), exception.readByteArray());
 
-    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("example.com"));
-    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("foo.square.jp"));
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("example.com")).isNull();
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.square.jp")).isNull();
   }
 
   @Test public void allPublicSuffixes() throws IOException {
@@ -119,10 +121,10 @@
         // A wildcard rule, let's replace the wildcard with a value.
         publicSuffix = publicSuffix.replaceAll("\\*", "square");
       }
-      assertNull(publicSuffixDatabase.getEffectiveTldPlusOne(publicSuffix));
+      assertThat(publicSuffixDatabase.getEffectiveTldPlusOne(publicSuffix)).isNull();
 
       String test = "foobar." + publicSuffix;
-      assertEquals(test, publicSuffixDatabase.getEffectiveTldPlusOne(test));
+      assertThat(publicSuffixDatabase.getEffectiveTldPlusOne(test)).isEqualTo(test);
     }
   }
 
@@ -140,10 +142,11 @@
 
     while (!buffer.exhausted()) {
       String exception = buffer.readUtf8LineStrict();
-      assertEquals(exception, publicSuffixDatabase.getEffectiveTldPlusOne(exception));
+      assertThat(publicSuffixDatabase.getEffectiveTldPlusOne(exception)).isEqualTo(
+          exception);
 
       String test = "foobar." + exception;
-      assertEquals(exception, publicSuffixDatabase.getEffectiveTldPlusOne(test));
+      assertThat(publicSuffixDatabase.getEffectiveTldPlusOne(test)).isEqualTo(exception);
     }
   }
 
@@ -151,9 +154,9 @@
     Thread.currentThread().interrupt();
     try {
       String result = publicSuffixDatabase.getEffectiveTldPlusOne("squareup.com");
-      assertEquals("squareup.com", result);
+      assertThat(result).isEqualTo("squareup.com");
     } finally {
-      assertTrue(Thread.interrupted());
+      assertThat(Thread.interrupted()).isTrue();
     }
   }
 
@@ -276,9 +279,9 @@ private void checkPublicSuffix(String domain, String registrablePart) {
 
     String result = publicSuffixDatabase.getEffectiveTldPlusOne(canonicalDomain);
     if (registrablePart == null) {
-      assertNull(result);
+      assertThat(result).isNull();
     } else {
-      assertEquals(Util.canonicalizeHost(registrablePart), result);
+      assertThat(result).isEqualTo(Util.canonicalizeHost(registrablePart));
     }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
similarity index 91%
rename from okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
rename to okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
index 256afe67fe..c64fb7323a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
@@ -30,6 +30,7 @@
 import okhttp3.Call;
 import okhttp3.CertificatePinner;
 import okhttp3.OkHttpClient;
+import okhttp3.PlatformRule;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
 import okhttp3.Response;
@@ -43,18 +44,23 @@
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.internal.platform.PlatformTest.getPlatform;
+import static okhttp3.internal.platform.PlatformTest.getJvmSpecVersion;
 import static okhttp3.tls.internal.TlsUtil.newKeyManager;
 import static okhttp3.tls.internal.TlsUtil.newTrustManager;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeFalse;
 
 public final class CertificatePinnerChainValidationTest {
+  @Rule public final PlatformRule platform = new PlatformRule();
+
   @Rule public final MockWebServer server = new MockWebServer();
 
   /** The pinner should pull the root certificate from the trust manager. */
   @Test public void pinRootNotPresentInChain() throws Exception {
+    // TODO https://github.com/square/okhttp/issues/4703
+    assumeFalse(getJvmSpecVersion().equals("11"));
+
     HeldCertificate rootCa = new HeldCertificate.Builder()
         .serialNumber(1L)
         .certificateAuthority(1)
@@ -97,7 +103,7 @@
         .url(server.url("/"))
         .build());
     Response response1 = call1.execute();
-    assertEquals("abc", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("abc");
 
     // Confirm that a second request also succeeds. This should detect caching problems.
     server.enqueue(new MockResponse()
@@ -107,11 +113,14 @@
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("def", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("def");
   }
 
   /** The pinner should accept an intermediate from the server's chain. */
   @Test public void pinIntermediatePresentInChain() throws Exception {
+    // TODO https://github.com/square/okhttp/issues/4703
+    assumeFalse(getJvmSpecVersion().equals("11"));
+
     HeldCertificate rootCa = new HeldCertificate.Builder()
         .serialNumber(1L)
         .certificateAuthority(1)
@@ -154,7 +163,7 @@
         .url(server.url("/"))
         .build());
     Response response1 = call1.execute();
-    assertEquals("abc", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("abc");
     response1.close();
 
     // Force a fresh connection for the next request.
@@ -168,11 +177,14 @@
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("def", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("def");
     response2.close();
   }
 
   @Test public void unrelatedPinnedLeafCertificateInChain() throws Exception {
+    // https://github.com/square/okhttp/issues/4729
+    assumeFalse(getJvmSpecVersion().equals("11"));
+
     // Start with a trusted root CA certificate.
     HeldCertificate rootCa = new HeldCertificate.Builder()
         .serialNumber(1L)
@@ -243,11 +255,14 @@
     } catch (SSLPeerUnverifiedException expected) {
       // Certificate pinning fails!
       String message = expected.getMessage();
-      assertTrue(message, message.startsWith("Certificate pinning failure!"));
+      assertThat(message).startsWith("Certificate pinning failure!");
     }
   }
 
   @Test public void unrelatedPinnedIntermediateCertificateInChain() throws Exception {
+    // https://github.com/square/okhttp/issues/4729
+    assumeFalse(getJvmSpecVersion().equals("11"));
+
     // Start with two root CA certificates, one is good and the other is compromised.
     HeldCertificate rootCa = new HeldCertificate.Builder()
         .serialNumber(1L)
@@ -318,11 +333,11 @@
     } catch (SSLHandshakeException expected) {
       // On Android, the handshake fails before the certificate pinner runs.
       String message = expected.getMessage();
-      assertTrue(message, message.contains("Could not validate certificate"));
+      assertThat(message).contains("Could not validate certificate");
     } catch (SSLPeerUnverifiedException expected) {
       // On OpenJDK, the handshake succeeds but the certificate pinner fails.
       String message = expected.getMessage();
-      assertTrue(message, message.startsWith("Certificate pinning failure!"));
+      assertThat(message).startsWith("Certificate pinning failure!");
     }
   }
 
@@ -333,10 +348,10 @@ private SSLSocketFactory newServerSocketFactory(HeldCertificate heldCertificate,
     // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
     // http://openjdk.java.net/jeps/229
     // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
-    String keystoreType = getPlatform().equals("jdk9") ? "JKS" : null;
+    String keystoreType = platform.isJdk9() ? "JKS" : null;
     X509KeyManager x509KeyManager = newKeyManager(keystoreType, heldCertificate, intermediates);
     X509TrustManager trustManager = newTrustManager(keystoreType, Collections.emptyList());
-    SSLContext sslContext = Platform.get().getSSLContext();
+    SSLContext sslContext = Platform.get().newSSLContext();
     sslContext.init(new KeyManager[] { x509KeyManager }, new TrustManager[] { trustManager },
         new SecureRandom());
     return sslContext.getSocketFactory();
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
similarity index 81%
rename from okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
rename to okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
index e88b9fef25..56e56ae08c 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
@@ -19,7 +19,6 @@
 import java.security.GeneralSecurityException;
 import java.security.SecureRandom;
 import java.security.cert.X509Certificate;
-import java.util.Arrays;
 import javax.net.ssl.KeyManager;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLException;
@@ -32,6 +31,7 @@
 import javax.security.auth.x500.X500Principal;
 import okhttp3.Call;
 import okhttp3.OkHttpClient;
+import okhttp3.PlatformRule;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.mockwebserver.MockResponse;
@@ -42,15 +42,18 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static java.util.Arrays.asList;
+import static okhttp3.PlatformRule.getPlatformSystemProperty;
 import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.internal.platform.PlatformTest.getPlatform;
+import static okhttp3.internal.platform.PlatformTest.getJvmSpecVersion;
 import static okhttp3.tls.internal.TlsUtil.newKeyManager;
 import static okhttp3.tls.internal.TlsUtil.newTrustManager;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeFalse;
 
 public final class ClientAuthTest {
+  @Rule public final PlatformRule platform = new PlatformRule();
   @Rule public final MockWebServer server = new MockWebServer();
 
   private HeldCertificate serverRootCa;
@@ -62,6 +65,8 @@
 
   @Before
   public void setUp() {
+    platform.assumeNotConscrypt();
+
     serverRootCa = new HeldCertificate.Builder()
         .serialNumber(1L)
         .certificateAuthority(1)
@@ -116,9 +121,11 @@ public void setUp() {
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
-    assertEquals(new X500Principal("CN=Jethro Willis"), response.handshake().localPrincipal());
-    assertEquals("abc", response.body().string());
+    assertThat(response.handshake().peerPrincipal()).isEqualTo(
+        new X500Principal("CN=Local Host"));
+    assertThat(response.handshake().localPrincipal()).isEqualTo(
+        new X500Principal("CN=Jethro Willis"));
+    assertThat(response.body().string()).isEqualTo("abc");
   }
 
   @Test public void clientAuthForNeeds() throws Exception {
@@ -132,9 +139,11 @@ public void setUp() {
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
-    assertEquals(new X500Principal("CN=Jethro Willis"), response.handshake().localPrincipal());
-    assertEquals("abc", response.body().string());
+    assertThat(response.handshake().peerPrincipal()).isEqualTo(
+        new X500Principal("CN=Local Host"));
+    assertThat(response.handshake().localPrincipal()).isEqualTo(
+        new X500Principal("CN=Jethro Willis"));
+    assertThat(response.body().string()).isEqualTo("abc");
   }
 
   @Test public void clientAuthSkippedForNone() throws Exception {
@@ -148,9 +157,10 @@ public void setUp() {
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
-    assertNull(response.handshake().localPrincipal());
-    assertEquals("abc", response.body().string());
+    assertThat(response.handshake().peerPrincipal()).isEqualTo(
+        new X500Principal("CN=Local Host"));
+    assertThat(response.handshake().localPrincipal()).isNull();
+    assertThat(response.body().string()).isEqualTo("abc");
   }
 
   @Test public void missingClientAuthSkippedForWantsOnly() throws Exception {
@@ -164,12 +174,17 @@ public void setUp() {
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
-    assertNull(response.handshake().localPrincipal());
-    assertEquals("abc", response.body().string());
+    assertThat(response.handshake().peerPrincipal()).isEqualTo(
+        new X500Principal("CN=Local Host"));
+    assertThat(response.handshake().localPrincipal()).isNull();
+    assertThat(response.body().string()).isEqualTo("abc");
   }
 
   @Test public void missingClientAuthFailsForNeeds() throws Exception {
+    // TODO https://github.com/square/okhttp/issues/4598
+    // StreamReset stream was reset: PROT...
+    assumeFalse(getJvmSpecVersion().equals("11"));
+
     OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
 
     SSLSocketFactory socketFactory = buildServerSslSocketFactory();
@@ -185,9 +200,9 @@ public void setUp() {
     } catch (SSLHandshakeException expected) {
     } catch (SSLException expected) {
       String jvmVersion = System.getProperty("java.specification.version");
-      assertEquals("11", jvmVersion);
+      assertThat(jvmVersion).isEqualTo("11");
     } catch (SocketException expected) {
-      assertEquals("jdk9", getPlatform());
+      assertThat(getPlatformSystemProperty()).isEqualTo("jdk9");
     }
   }
 
@@ -216,6 +231,10 @@ public void setUp() {
   }
 
   @Test public void invalidClientAuthFails() throws Throwable {
+    // TODO https://github.com/square/okhttp/issues/4598
+    // StreamReset stream was reset: PROT...
+    assumeFalse(getJvmSpecVersion().equals("11"));
+
     HeldCertificate clientCert2 = new HeldCertificate.Builder()
         .serialNumber(4L)
         .commonName("Jethro Willis")
@@ -237,9 +256,9 @@ public void setUp() {
     } catch (SSLException expected) {
       // javax.net.ssl.SSLException: readRecord
       String jvmVersion = System.getProperty("java.specification.version");
-      assertEquals("11", jvmVersion);
+      assertThat(jvmVersion).isEqualTo("11");
     } catch (SocketException expected) {
-      assertEquals("jdk9", getPlatform());
+      assertThat(getPlatformSystemProperty()).isEqualTo("jdk9");
     }
   }
 
@@ -266,7 +285,7 @@ private SSLSocketFactory buildServerSslSocketFactory() {
       X509KeyManager keyManager = newKeyManager(
           null, serverCert, serverIntermediateCa.certificate());
       X509TrustManager trustManager = newTrustManager(
-          null, Arrays.asList(serverRootCa.certificate(), clientRootCa.certificate()));
+          null, asList(serverRootCa.certificate(), clientRootCa.certificate()));
       SSLContext sslContext = SSLContext.getInstance("TLS");
       sslContext.init(new KeyManager[] {keyManager}, new TrustManager[] {trustManager},
           new SecureRandom());
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java b/okhttp/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
similarity index 96%
rename from okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
rename to okhttp/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
index 09c22b8594..099b8982b0 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
@@ -20,7 +20,7 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class DistinguishedNameParserTest {
@@ -120,7 +120,8 @@
   private void assertCn(String expected, String dn) {
     X500Principal principal = new X500Principal(dn);
     DistinguishedNameParser parser = new DistinguishedNameParser(principal);
-    assertEquals(dn, expected, parser.findMostSpecific("cn"));
+    assertThat(parser.findMostSpecific("cn")).overridingErrorMessage(dn).isEqualTo(
+        expected);
   }
 
   private void expectExceptionInPrincipal(String dn) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java b/okhttp/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
similarity index 85%
rename from okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
rename to okhttp/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
index 81f41b0442..9a878f1c41 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
@@ -29,9 +29,7 @@
 import org.junit.Test;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /**
  * Tests for our hostname verifier. Most of these tests are from AOSP, which itself includes tests
@@ -42,7 +40,7 @@
 
   @Test public void verify() throws Exception {
     FakeSSLSession session = new FakeSSLSession();
-    assertFalse(verifier.verify("localhost", session));
+    assertThat(verifier.verify("localhost", session)).isFalse();
   }
 
   @Test public void verifyCn() throws Exception {
@@ -73,9 +71,9 @@
         + "HwlNrAu8jlZ2UqSgskSWlhYdMTAP9CPHiUv9N7FcT58Itv/I4fKREINQYjDpvQcx\n"
         + "SaTYb9dr5sB4WLNglk7zxDtM80H518VvihTcP7FHL+Gn6g4j5fkI98+S\n"
         + "-----END CERTIFICATE-----\n");
-    assertFalse(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertFalse(verifier.verify("bar.com", session));
+    assertThat(verifier.verify("foo.com", session)).isFalse();
+    assertThat(verifier.verify("a.foo.com", session)).isFalse();
+    assertThat(verifier.verify("bar.com", session)).isFalse();
   }
 
   @Test public void verifyNonAsciiCn() throws Exception {
@@ -106,8 +104,8 @@
         + "9BsO7qe46hidgn39hKh1WjKK2VcL/3YRsC4wUi0PBtFW6ScMCuMhgIRXSPU55Rae\n"
         + "UIlOdPjjr1SUNWGId1rD7W16Scpwnknn310FNxFMHVI0GTGFkNdkilNCFJcIoRA=\n"
         + "-----END CERTIFICATE-----\n");
-    assertFalse(verifier.verify("\u82b1\u5b50.co.jp", session));
-    assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
+    assertThat(verifier.verify("\u82b1\u5b50.co.jp", session)).isFalse();
+    assertThat(verifier.verify("a.\u82b1\u5b50.co.jp", session)).isFalse();
   }
 
   @Test public void verifySubjectAlt() throws Exception {
@@ -139,10 +137,10 @@
         + "2xq+8bc6HojdtbCyug/fvBZvZqQXSmU8m8IVcMmWMz0ZQO8ee3QkBHMZfCy7P/kr\n"
         + "VbWx/uETImUu+NZg22ewEw==\n"
         + "-----END CERTIFICATE-----\n");
-    assertFalse(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertTrue(verifier.verify("bar.com", session));
-    assertFalse(verifier.verify("a.bar.com", session));
+    assertThat(verifier.verify("foo.com", session)).isFalse();
+    assertThat(verifier.verify("a.foo.com", session)).isFalse();
+    assertThat(verifier.verify("bar.com", session)).isTrue();
+    assertThat(verifier.verify("a.bar.com", session)).isFalse();
   }
 
   /**
@@ -180,8 +178,8 @@
         + "sWIKHYrmhCIRshUNohGXv50m2o+1w9oWmQ6Dkq7lCjfXfUB4wIbggJjpyEtbNqBt\n"
         + "j4MC2x5rfsLKKqToKmNE7pFEgqwe8//Aar1b+Qj+\n"
         + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
+    assertThat(verifier.verify("foo.com", session)).isTrue();
+    assertThat(verifier.verify("a.foo.com", session)).isFalse();
     // these checks test alternative subjects. The test data contains an
     // alternative subject starting with a japanese kanji character. This is
     // not supported by Android because the underlying implementation from
@@ -220,10 +218,10 @@
         + "qAVqixM+J0qJmQStgAc53i2aTMvAQu3A3snvH/PHTBo+5UL72n9S1kZyNCsVf1Qo\n"
         + "n8jKTiRriEM+fMFlcgQP284EBFzYHyCXFb9O/hMjK2+6mY9euMB1U1aFFzM/Bg==\n"
         + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertTrue(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
+    assertThat(verifier.verify("foo.com", session)).isTrue();
+    assertThat(verifier.verify("a.foo.com", session)).isFalse();
+    assertThat(verifier.verify("foo.com", session)).isTrue();
+    assertThat(verifier.verify("a.foo.com", session)).isFalse();
   }
 
   @Test public void verifyMultipleCn() throws Exception {
@@ -255,12 +253,12 @@
         + "SpQFCfo02NO0uNRDPUdJx2huycdNb+AXHaO7eXevDLJ+QnqImIzxWiY6zLOdzjjI\n"
         + "VBMkLHmnP7SjGSQ3XA4ByrQOxfOUTyLyE7NuemhHppuQPxE=\n"
         + "-----END CERTIFICATE-----\n");
-    assertFalse(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertFalse(verifier.verify("bar.com", session));
-    assertFalse(verifier.verify("a.bar.com", session));
-    assertFalse(verifier.verify("\u82b1\u5b50.co.jp", session));
-    assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
+    assertThat(verifier.verify("foo.com", session)).isFalse();
+    assertThat(verifier.verify("a.foo.com", session)).isFalse();
+    assertThat(verifier.verify("bar.com", session)).isFalse();
+    assertThat(verifier.verify("a.bar.com", session)).isFalse();
+    assertThat(verifier.verify("\u82b1\u5b50.co.jp", session)).isFalse();
+    assertThat(verifier.verify("a.\u82b1\u5b50.co.jp", session)).isFalse();
   }
 
   @Test public void verifyWilcardCn() throws Exception {
@@ -291,10 +289,10 @@
         + "G9Z6tyMbmfRY+dLSh3a9JwoEcBUso6EWYBakLbq4nG/nvYdYvG9ehrnLVwZFL82e\n"
         + "l3Q/RK95bnA6cuRClGusLad0e6bjkBzx/VQ3VarDEpAkTLUGVAa0CLXtnyc=\n"
         + "-----END CERTIFICATE-----\n");
-    assertFalse(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("www.foo.com", session));
-    assertFalse(verifier.verify("\u82b1\u5b50.foo.com", session));
-    assertFalse(verifier.verify("a.b.foo.com", session));
+    assertThat(verifier.verify("foo.com", session)).isFalse();
+    assertThat(verifier.verify("www.foo.com", session)).isFalse();
+    assertThat(verifier.verify("\u82b1\u5b50.foo.com", session)).isFalse();
+    assertThat(verifier.verify("a.b.foo.com", session)).isFalse();
   }
 
   @Test public void verifyWilcardCnOnTld() throws Exception {
@@ -326,8 +324,8 @@
         + "UGPLEUDzRHMPHLnSqT1n5UU5UDRytbjJPXzF+l/+WZIsanefWLsxnkgAuZe/oMMF\n"
         + "EJMryEzOjg4Tfuc5qM0EXoPcQ/JlheaxZ40p2IyHqbsWV4MRYuFH4bkM\n"
         + "-----END CERTIFICATE-----\n");
-    assertFalse(verifier.verify("foo.co.jp", session));
-    assertFalse(verifier.verify("\u82b1\u5b50.co.jp", session));
+    assertThat(verifier.verify("foo.co.jp", session)).isFalse();
+    assertThat(verifier.verify("\u82b1\u5b50.co.jp", session)).isFalse();
   }
 
   /**
@@ -366,10 +364,10 @@
         + "pgJsDbJtZfHnV1nd3M6zOtQPm1TIQpNmMMMd/DPrGcUQerD3\n"
         + "-----END CERTIFICATE-----\n");
     // try the foo.com variations
-    assertTrue(verifier.verify("foo.com", session));
-    assertTrue(verifier.verify("www.foo.com", session));
-    assertTrue(verifier.verify("\u82b1\u5b50.foo.com", session));
-    assertFalse(verifier.verify("a.b.foo.com", session));
+    assertThat(verifier.verify("foo.com", session)).isTrue();
+    assertThat(verifier.verify("www.foo.com", session)).isTrue();
+    assertThat(verifier.verify("\u82b1\u5b50.foo.com", session)).isTrue();
+    assertThat(verifier.verify("a.b.foo.com", session)).isFalse();
     // these checks test alternative subjects. The test data contains an
     // alternative subject starting with a japanese kanji character. This is
     // not supported by Android because the underlying implementation from
@@ -405,15 +403,16 @@
         + "DCzOCv9Ma6Lv5o5jcYWVxvBSTsnt22hsJpWD1K7iY9lbkLwl0ivn73pG2evsAn9G\n"
         + "X8YKH52fnHsCrhSD\n"
         + "-----END CERTIFICATE-----");
-    assertEquals(new X500Principal("CN=localhost"), certificate.getSubjectX500Principal());
+    assertThat(certificate.getSubjectX500Principal()).isEqualTo(
+        new X500Principal("CN=localhost"));
 
     FakeSSLSession session = new FakeSSLSession(certificate);
-    assertTrue(verifier.verify("localhost", session));
-    assertTrue(verifier.verify("localhost.localdomain", session));
-    assertFalse(verifier.verify("local.host", session));
+    assertThat(verifier.verify("localhost", session)).isTrue();
+    assertThat(verifier.verify("localhost.localdomain", session)).isTrue();
+    assertThat(verifier.verify("local.host", session)).isFalse();
 
-    assertTrue(verifier.verify("127.0.0.1", session));
-    assertFalse(verifier.verify("127.0.0.2", session));
+    assertThat(verifier.verify("127.0.0.1", session)).isTrue();
+    assertThat(verifier.verify("127.0.0.2", session)).isFalse();
   }
 
   @Test public void wildcardsCannotMatchIpAddresses() throws Exception {
@@ -430,7 +429,7 @@
         + "BQUAA0EAk9i88xdjWoewqvE+iMC9tD2obMchgFDaHH0ogxxiRaIKeEly3g0uGxIt\n"
         + "fl2WRY8hb4x+zRrwsFaLEpdEvqcjOQ==\n"
         + "-----END CERTIFICATE-----");
-    assertFalse(verifier.verify("127.0.0.1", session));
+    assertThat(verifier.verify("127.0.0.1", session)).isFalse();
   }
 
   /**
@@ -452,7 +451,7 @@
         + "U6LFxmZr31lFyis2/T68PpjAppc0DpNQuA2m/Y7oTHBDi55Fw6HVHCw3lucuWZ5d\n"
         + "qUYo4ES548JdpQtcLrW2sA==\n"
         + "-----END CERTIFICATE-----");
-    assertFalse(verifier.verify("google.com", session));
+    assertThat(verifier.verify("google.com", session)).isFalse();
   }
 
   @Test public void subjectAltName() throws Exception {
@@ -478,11 +477,11 @@
         + "DQYJKoZIhvcNAQEFBQADQQBXpZZPOY2Dy1lGG81JTr8L4or9jpKacD7n51eS8iqI\n"
         + "oTznPNuXHU5bFN0AAGX2ij47f/EahqTpo5RdS95P4sVm\n"
         + "-----END CERTIFICATE-----");
-    assertFalse(verifier.verify("foo.com", session));
-    assertTrue(verifier.verify("bar.com", session));
-    assertTrue(verifier.verify("baz.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertFalse(verifier.verify("quux.com", session));
+    assertThat(verifier.verify("foo.com", session)).isFalse();
+    assertThat(verifier.verify("bar.com", session)).isTrue();
+    assertThat(verifier.verify("baz.com", session)).isTrue();
+    assertThat(verifier.verify("a.foo.com", session)).isFalse();
+    assertThat(verifier.verify("quux.com", session)).isFalse();
   }
 
   @Test public void subjectAltNameWithWildcard() throws Exception {
@@ -508,39 +507,39 @@
         + "bTANBgkqhkiG9w0BAQUFAANBAB8yrSl8zqy07i0SNYx2B/FnvQY734pxioaqFWfO\n"
         + "Bqo1ZZl/9aPHEWIwBrxYNVB0SGu/kkbt/vxqOjzzrkXukmI=\n"
         + "-----END CERTIFICATE-----");
-    assertFalse(verifier.verify("foo.com", session));
-    assertTrue(verifier.verify("bar.com", session));
-    assertTrue(verifier.verify("a.baz.com", session));
-    assertFalse(verifier.verify("baz.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertFalse(verifier.verify("a.bar.com", session));
-    assertFalse(verifier.verify("quux.com", session));
+    assertThat(verifier.verify("foo.com", session)).isFalse();
+    assertThat(verifier.verify("bar.com", session)).isTrue();
+    assertThat(verifier.verify("a.baz.com", session)).isTrue();
+    assertThat(verifier.verify("baz.com", session)).isFalse();
+    assertThat(verifier.verify("a.foo.com", session)).isFalse();
+    assertThat(verifier.verify("a.bar.com", session)).isFalse();
+    assertThat(verifier.verify("quux.com", session)).isFalse();
   }
 
   @Test public void verifyAsIpAddress() {
     // IPv4
-    assertTrue(Util.verifyAsIpAddress("127.0.0.1"));
-    assertTrue(Util.verifyAsIpAddress("1.2.3.4"));
+    assertThat(Util.verifyAsIpAddress("127.0.0.1")).isTrue();
+    assertThat(Util.verifyAsIpAddress("1.2.3.4")).isTrue();
 
     // IPv6
-    assertTrue(Util.verifyAsIpAddress("::1"));
-    assertTrue(Util.verifyAsIpAddress("2001:db8::1"));
-    assertTrue(Util.verifyAsIpAddress("::192.168.0.1"));
-    assertTrue(Util.verifyAsIpAddress("::ffff:192.168.0.1"));
-    assertTrue(Util.verifyAsIpAddress("FEDC:BA98:7654:3210:FEDC:BA98:7654:3210"));
-    assertTrue(Util.verifyAsIpAddress("1080:0:0:0:8:800:200C:417A"));
-    assertTrue(Util.verifyAsIpAddress("1080::8:800:200C:417A"));
-    assertTrue(Util.verifyAsIpAddress("FF01::101"));
-    assertTrue(Util.verifyAsIpAddress("0:0:0:0:0:0:13.1.68.3"));
-    assertTrue(Util.verifyAsIpAddress("0:0:0:0:0:FFFF:129.144.52.38"));
-    assertTrue(Util.verifyAsIpAddress("::13.1.68.3"));
-    assertTrue(Util.verifyAsIpAddress("::FFFF:129.144.52.38"));
+    assertThat(Util.verifyAsIpAddress("::1")).isTrue();
+    assertThat(Util.verifyAsIpAddress("2001:db8::1")).isTrue();
+    assertThat(Util.verifyAsIpAddress("::192.168.0.1")).isTrue();
+    assertThat(Util.verifyAsIpAddress("::ffff:192.168.0.1")).isTrue();
+    assertThat(Util.verifyAsIpAddress("FEDC:BA98:7654:3210:FEDC:BA98:7654:3210")).isTrue();
+    assertThat(Util.verifyAsIpAddress("1080:0:0:0:8:800:200C:417A")).isTrue();
+    assertThat(Util.verifyAsIpAddress("1080::8:800:200C:417A")).isTrue();
+    assertThat(Util.verifyAsIpAddress("FF01::101")).isTrue();
+    assertThat(Util.verifyAsIpAddress("0:0:0:0:0:0:13.1.68.3")).isTrue();
+    assertThat(Util.verifyAsIpAddress("0:0:0:0:0:FFFF:129.144.52.38")).isTrue();
+    assertThat(Util.verifyAsIpAddress("::13.1.68.3")).isTrue();
+    assertThat(Util.verifyAsIpAddress("::FFFF:129.144.52.38")).isTrue();
 
     // Hostnames
-    assertFalse(Util.verifyAsIpAddress("go"));
-    assertFalse(Util.verifyAsIpAddress("localhost"));
-    assertFalse(Util.verifyAsIpAddress("squareup.com"));
-    assertFalse(Util.verifyAsIpAddress("www.nintendo.co.jp"));
+    assertThat(Util.verifyAsIpAddress("go")).isFalse();
+    assertThat(Util.verifyAsIpAddress("localhost")).isFalse();
+    assertThat(Util.verifyAsIpAddress("squareup.com")).isFalse();
+    assertThat(Util.verifyAsIpAddress("www.nintendo.co.jp")).isFalse();
   }
 
   private X509Certificate certificate(String certificate) throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
similarity index 84%
rename from okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
rename to okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index 38b2762e6a..044643cd4b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -32,9 +32,8 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 import static org.junit.Assert.fail;
 
 public final class RealWebSocketTest {
@@ -65,10 +64,11 @@
 
   @Test public void close() throws IOException {
     client.webSocket.close(1000, "Hello!");
-    assertFalse(server.processNextFrame()); // This will trigger a close response.
+    // This will trigger a close response.
+    assertThat(server.processNextFrame()).isFalse();
     server.listener.assertClosing(1000, "Hello!");
     server.webSocket.close(1000, "Goodbye!");
-    assertFalse(client.processNextFrame());
+    assertThat(client.processNextFrame()).isFalse();
     client.listener.assertClosing(1000, "Goodbye!");
     server.listener.assertClosed(1000, "Hello!");
     client.listener.assertClosed(1000, "Goodbye!");
@@ -77,8 +77,8 @@
   @Test public void clientCloseThenMethodsReturnFalse() throws IOException {
     client.webSocket.close(1000, "Hello!");
 
-    assertFalse(client.webSocket.close(1000, "Hello!"));
-    assertFalse(client.webSocket.send("Hello!"));
+    assertThat(client.webSocket.close(1000, "Hello!")).isFalse();
+    assertThat(client.webSocket.send("Hello!")).isFalse();
   }
 
   @Test public void clientCloseWith0Fails() throws IOException {
@@ -86,7 +86,7 @@
       client.webSocket.close(0, null);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals(expected.getMessage(), "Code must be in range [1000,5000): 0");
+      assertThat("Code must be in range [1000,5000): 0").isEqualTo(expected.getMessage());
     }
   }
 
@@ -95,18 +95,18 @@
     client.webSocket.pong(ByteString.encodeUtf8("Ping!"));
     client.listener.assertFailure(IOException.class, "source is closed");
 
-    assertFalse(client.webSocket.send("Hello!"));
+    assertThat(client.webSocket.send("Hello!")).isFalse();
   }
 
   @Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {
     client2Server.source().close();
 
-    assertTrue(client.webSocket.send("Hello!"));
+    assertThat(client.webSocket.send("Hello!")).isTrue();
     client.listener.assertFailure(IOException.class, "source is closed");
 
     // A failed write prevents further use of the WebSocket instance.
-    assertFalse(client.webSocket.send("Hello!"));
-    assertFalse(client.webSocket.pong(ByteString.encodeUtf8("Ping!")));
+    assertThat(client.webSocket.send("Hello!")).isFalse();
+    assertThat(client.webSocket.pong(ByteString.encodeUtf8("Ping!"))).isFalse();
   }
 
   @Test public void serverCloseThenWritingPingSucceeds() throws IOException {
@@ -114,7 +114,7 @@
     client.processNextFrame();
     client.listener.assertClosing(1000, "Hello!");
 
-    assertTrue(client.webSocket.pong(ByteString.encodeUtf8("Pong?")));
+    assertThat(client.webSocket.pong(ByteString.encodeUtf8("Pong?"))).isTrue();
   }
 
   @Test public void clientCanWriteMessagesAfterServerClose() throws IOException {
@@ -122,7 +122,7 @@
     client.processNextFrame();
     client.listener.assertClosing(1000, "Hello!");
 
-    assertTrue(client.webSocket.send("Hi!"));
+    assertThat(client.webSocket.send("Hi!")).isTrue();
     server.processNextFrame();
     server.listener.assertTextMessage("Hi!");
   }
@@ -131,7 +131,7 @@
     server.webSocket.close(1000, "Hello!");
     client.processNextFrame();
     client.listener.assertClosing(1000, "Hello!");
-    assertTrue(client.webSocket.close(1000, "Bye!"));
+    assertThat(client.webSocket.close(1000, "Bye!")).isTrue();
   }
 
   @Test public void emptyCloseInitiatesShutdown() throws IOException {
@@ -139,7 +139,7 @@
     client.processNextFrame();
     client.listener.assertClosing(1005, "");
 
-    assertTrue(client.webSocket.close(1000, "Bye!"));
+    assertThat(client.webSocket.close(1000, "Bye!")).isTrue();
     server.processNextFrame();
     server.listener.assertClosing(1000, "Bye!");
 
@@ -148,13 +148,13 @@
 
   @Test public void clientCloseClosesConnection() throws IOException {
     client.webSocket.close(1000, "Hello!");
-    assertFalse(client.closed);
+    assertThat(client.closed).isFalse();
     server.processNextFrame(); // Read client closing, send server close.
     server.listener.assertClosing(1000, "Hello!");
 
     server.webSocket.close(1000, "Goodbye!");
     client.processNextFrame(); // Read server closing, close connection.
-    assertTrue(client.closed);
+    assertThat(client.closed).isTrue();
     client.listener.assertClosing(1000, "Goodbye!");
 
     // Server and client both finished closing, connection is closed.
@@ -166,7 +166,7 @@
     server.webSocket.close(1000, "Hello!");
 
     client.processNextFrame(); // Read server close, send client close, close connection.
-    assertFalse(client.closed);
+    assertThat(client.closed).isFalse();
     client.listener.assertClosing(1000, "Hello!");
 
     client.webSocket.close(1000, "Hello!");
@@ -182,7 +182,7 @@
     server.webSocket.close(1000, "Hello!");
     client.processNextFrame(); // Read close, close connection close.
 
-    assertFalse(client.closed);
+    assertThat(client.closed).isFalse();
     client.webSocket.close(1000, "Hi!");
     server.processNextFrame();
 
@@ -191,7 +191,7 @@
     client.listener.assertClosed(1000, "Hello!");
     server.listener.assertClosed(1000, "Hi!");
     client.webSocket.awaitTermination(5, TimeUnit.SECONDS);
-    assertTrue(client.closed);
+    assertThat(client.closed).isTrue();
 
     server.listener.assertExhausted(); // Client should not have sent second close.
     client.listener.assertExhausted(); // Server should not have sent second close.
@@ -200,9 +200,9 @@
   @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
     server.webSocket.send("Hello!");
     server.webSocket.close(1000, "Bye!");
-    assertTrue(client.processNextFrame());
+    assertThat(client.processNextFrame()).isTrue();
     client.listener.assertTextMessage("Hello!");
-    assertFalse(client.processNextFrame());
+    assertThat(client.processNextFrame()).isFalse();
     client.listener.assertClosing(1000, "Bye!");
   }
 
@@ -210,7 +210,7 @@
     server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
 
     client.processNextFrame(); // Detects error, send close, close connection.
-    assertTrue(client.closed);
+    assertThat(client.closed).isTrue();
     client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
     server.processNextFrame();
@@ -220,13 +220,14 @@
   @Test public void protocolErrorInCloseResponseClosesConnection() throws IOException {
     client.webSocket.close(1000, "Hello");
     server.processNextFrame();
-    assertFalse(client.closed); // Not closed until close reply is received.
+    // Not closed until close reply is received.
+    assertThat(client.closed).isFalse();
 
     // Manually write an invalid masked close frame.
     server.sink.write(ByteString.decodeHex("888760b420bb635c68de0cd84f")).emit();
 
     client.processNextFrame();// Detects error, disconnects immediately since close already sent.
-    assertTrue(client.closed);
+    assertThat(client.closed).isTrue();
     client.listener.assertFailure(
         ProtocolException.class, "Server-sent frames must not be masked.");
 
@@ -238,11 +239,12 @@
     client.webSocket.close(1000, "Hello!");
     server.processNextFrame();
 
-    assertFalse(client.closed); // Not closed until close reply is received.
+    // Not closed until close reply is received.
+    assertThat(client.closed).isFalse();
     server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
 
     client.processNextFrame(); // Detects error, disconnects immediately since close already sent.
-    assertTrue(client.closed);
+    assertThat(client.closed).isTrue();
     client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
     server.listener.assertClosing(1000, "Hello!");
@@ -269,7 +271,7 @@
 
     client.webSocket.close(1000, "Bye!");
     client.listener.assertFailure(IOException.class, "failure");
-    assertTrue(client.closed);
+    assertThat(client.closed).isTrue();
   }
 
   @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
@@ -292,17 +294,20 @@
     server.processNextFrame(); // Ping.
     client.processNextFrame(); // Pong.
     long elapsedUntilPing1 = System.nanoTime() - startNanos;
-    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing1), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing1)).isCloseTo((double) 500, offset(
+        250d));
 
     server.processNextFrame(); // Ping.
     client.processNextFrame(); // Pong.
     long elapsedUntilPing2 = System.nanoTime() - startNanos;
-    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing2), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing2)).isCloseTo((double) 1000, offset(
+        250d));
 
     server.processNextFrame(); // Ping.
     client.processNextFrame(); // Pong.
     long elapsedUntilPing3 = System.nanoTime() - startNanos;
-    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing3), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing3)).isCloseTo((double) 1500, offset(
+        250d));
   }
 
   @Test public void unacknowledgedPingFailsConnection() throws IOException {
@@ -313,7 +318,8 @@
     client.listener.assertFailure(SocketTimeoutException.class,
         "sent ping but didn't receive pong within 500ms (after 0 successful ping/pongs)");
     long elapsedUntilFailure = System.nanoTime() - startNanos;
-    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 1000, offset(
+        250d));
   }
 
   @Test public void unexpectedPongsDoNotInterfereWithFailureDetection() throws IOException {
@@ -332,14 +338,16 @@
     server.processNextFrame(); // Ping.
     client.processNextFrame(); // Pong.
     long elapsedUntilPing = System.nanoTime() - startNanos;
-    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing)).isCloseTo((double) 500, offset(
+        250d));
 
     // After 1000ms the client will attempt a ping 2, but we don't process it. That'll cause the
     // client to fail at 1500ms when it's time to send ping 3 because pong 2 hasn't been received.
     client.listener.assertFailure(SocketTimeoutException.class,
         "sent ping but didn't receive pong within 500ms (after 1 successful ping/pongs)");
     long elapsedUntilFailure = System.nanoTime() - startNanos;
-    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 1500, offset(
+        250d));
   }
 
   /** One peer's streams, listener, and web socket in the test. */
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
similarity index 88%
rename from okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
rename to okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
index e4c29b8374..c1d110858c 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
@@ -17,11 +17,10 @@
 
 import java.io.EOFException;
 import java.io.IOException;
+import java.io.InterruptedIOException;
 import java.net.HttpURLConnection;
 import java.net.ProtocolException;
 import java.net.SocketTimeoutException;
-import java.util.Arrays;
-import java.util.Collections;
 import java.util.Random;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
@@ -49,14 +48,13 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static java.util.Arrays.asList;
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.TestUtil.ensureAllConnectionsReleased;
 import static okhttp3.TestUtil.repeat;
 import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 import static org.junit.Assert.fail;
 
 public final class WebSocketHttpTest {
@@ -71,7 +69,8 @@
       .readTimeout(500, TimeUnit.MILLISECONDS)
       .addInterceptor(chain -> {
         Response response = chain.proceed(chain.request());
-        assertNotNull(response.body()); // Ensure application interceptors never see a null body.
+        // Ensure application interceptors never see a null body.
+        assertThat(response.body()).isNotNull();
         return response;
       })
       .build();
@@ -118,7 +117,7 @@
       webSocket.send((String) null);
       fail();
     } catch (NullPointerException e) {
-      assertEquals("text == null", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("text == null");
     }
 
     closeWebSockets(webSocket, server);
@@ -134,7 +133,7 @@
       webSocket.send((ByteString) null);
       fail();
     } catch (NullPointerException e) {
-      assertEquals("bytes == null", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("bytes == null");
     }
 
     closeWebSockets(webSocket, server);
@@ -165,6 +164,7 @@
     newWebSocket();
 
     serverListener.assertOpen();
+    serverListener.assertFailure(EOFException.class);
     serverListener.assertExhausted();
     clientListener.assertFailure(e);
   }
@@ -186,7 +186,7 @@
 
     newWebSocket();
 
-    assertEquals("", logs.take());
+    assertThat(logs.take()).isEqualTo("");
     logger.removeHandler(logs);
   }
 
@@ -302,6 +302,8 @@
 
     clientListener.assertFailure(101, null, ProtocolException.class,
         "Expected 'Connection' header value 'Upgrade' but was 'null'");
+
+    ensureAllConnectionsReleased(client);
   }
 
   @Test public void wrongConnectionHeader() throws IOException {
@@ -367,10 +369,10 @@
 
     client = client.newBuilder()
         .addInterceptor(chain -> {
-          assertNull(chain.request().body());
+          assertThat(chain.request().body()).isNull();
           Response response = chain.proceed(chain.request());
-          assertEquals("Upgrade", response.header("Connection"));
-          assertTrue(response.body().source().exhausted());
+          assertThat(response.header("Connection")).isEqualTo("Upgrade");
+          assertThat(response.body().source().exhausted()).isTrue();
           interceptedCount.incrementAndGet();
           return response;
         })
@@ -380,13 +382,9 @@
 
     WebSocket webSocket = newWebSocket();
     clientListener.assertOpen();
-    assertEquals(1, interceptedCount.get());
-    webSocket.close(1000, null);
+    assertThat(interceptedCount.get()).isEqualTo(1);
 
-    WebSocket server = serverListener.assertOpen();
-    server.close(1000, null);
-    clientListener.assertClosing(1000, "");
-    clientListener.assertClosed(1000, "");
+    closeWebSockets(webSocket, serverListener.assertOpen());
   }
 
   @Test public void webSocketAndNetworkInterceptors() {
@@ -413,15 +411,16 @@
 
     // Send messages until the client's outgoing buffer overflows!
     ByteString message = ByteString.of(new byte[1024 * 1024]);
-    int messageCount = 0;
+    long messageCount = 0;
     while (true) {
       boolean success = webSocket.send(message);
       if (!success) break;
 
       messageCount++;
       long queueSize = webSocket.queueSize();
-      assertTrue(queueSize >= 0 && queueSize <= messageCount * message.size());
-      assertTrue(messageCount < 32); // Expect to fail before enqueueing 32 MiB.
+      assertThat(queueSize).isBetween(0L, messageCount * message.size());
+      // Expect to fail before enqueueing 32 MiB.
+      assertThat(messageCount).isLessThan(32L);
     }
 
     // Confirm all sent messages were received, followed by a client-initiated close.
@@ -470,7 +469,7 @@
       webSocket.close(1000, reason);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("reason.size() > 123: " + reason, expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(("reason.size() > 123: " + reason));
     }
 
     webSocket.close(1000, null);
@@ -520,7 +519,7 @@
     WebSocket webSocket = newWebSocket();
 
     clientListener.assertFailure(SocketTimeoutException.class, "timeout", "Read timed out");
-    assertFalse(webSocket.close(1000, null));
+    assertThat(webSocket.close(1000, null)).isFalse();
   }
 
   /**
@@ -542,7 +541,7 @@
     clientListener.assertOpen();
 
     clientListener.assertFailure(SocketTimeoutException.class, "timeout", "Read timed out");
-    assertFalse(webSocket.close(1000, null));
+    assertThat(webSocket.close(1000, null)).isFalse();
   }
 
   @Test public void readTimeoutDoesNotApplyAcrossFrames() throws Exception {
@@ -578,16 +577,17 @@
     }
 
     long elapsedUntilPong3 = System.nanoTime() - startNanos;
-    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3)).isCloseTo((double) 1500, offset(
+        250d));
 
     // The client pinged the server 3 times, and it has ponged back 3 times.
-    assertEquals(3, webSocket.sentPingCount());
-    assertEquals(3, server.receivedPingCount());
-    assertEquals(3, webSocket.receivedPongCount());
+    assertThat(webSocket.sentPingCount()).isEqualTo(3);
+    assertThat(server.receivedPingCount()).isEqualTo(3);
+    assertThat(webSocket.receivedPongCount()).isEqualTo(3);
 
     // The server has never pinged the client.
-    assertEquals(0, server.receivedPongCount());
-    assertEquals(0, webSocket.receivedPingCount());
+    assertThat(server.receivedPongCount()).isEqualTo(0);
+    assertThat(webSocket.receivedPingCount()).isEqualTo(0);
 
     closeWebSockets(webSocket, server);
   }
@@ -602,12 +602,12 @@
     Thread.sleep(1000);
 
     // No pings and no pongs.
-    assertEquals(0, webSocket.sentPingCount());
-    assertEquals(0, webSocket.receivedPingCount());
-    assertEquals(0, webSocket.receivedPongCount());
-    assertEquals(0, server.sentPingCount());
-    assertEquals(0, server.receivedPingCount());
-    assertEquals(0, server.receivedPongCount());
+    assertThat(webSocket.sentPingCount()).isEqualTo(0);
+    assertThat(webSocket.receivedPingCount()).isEqualTo(0);
+    assertThat(webSocket.receivedPongCount()).isEqualTo(0);
+    assertThat(server.sentPingCount()).isEqualTo(0);
+    assertThat(server.receivedPingCount()).isEqualTo(0);
+    assertThat(server.receivedPongCount()).isEqualTo(0);
 
     closeWebSockets(webSocket, server);
   }
@@ -642,7 +642,8 @@
     latch.countDown();
 
     long elapsedUntilFailure = System.nanoTime() - openAtNanos;
-    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 1000, offset(
+        250d));
   }
 
   /** https://github.com/square/okhttp/issues/2788 */
@@ -661,7 +662,8 @@
     // Confirm that the hard cancel occurred after 500 ms.
     clientListener.assertFailure();
     long elapsedUntilFailure = System.nanoTime() - closeAtNanos;
-    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 500, offset(
+        250d));
 
     // Close the server and confirm it saw what we expected.
     server.close(1000, null);
@@ -692,10 +694,24 @@
     clientListener.assertClosed(1000, "");
     serverListener.assertClosed(1000, "");
 
-    assertEquals(Collections.emptyList(), listener.recordedEventTypes());
+    assertThat(listener.recordedEventTypes()).isEmpty();
+  }
+
+  @Test public void callTimeoutAppliesToSetup() throws Exception {
+    webServer.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    client = client.newBuilder()
+        .readTimeout(0, TimeUnit.MILLISECONDS)
+        .writeTimeout(0, TimeUnit.MILLISECONDS)
+        .callTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    newWebSocket();
+    clientListener.assertFailure(InterruptedIOException.class, "timeout");
   }
 
-  @Test public void callTimeoutIsNotApplied() throws Exception {
+  @Test public void callTimeoutDoesNotApplyOnceConnected() throws Exception {
     client = client.newBuilder()
         .callTimeout(100, TimeUnit.MILLISECONDS)
         .build();
@@ -723,7 +739,7 @@
   @Test public void webSocketConnectionIsReleased() throws Exception {
     // This test assumes HTTP/1.1 pooling semantics.
     client = client.newBuilder()
-        .protocols(Arrays.asList(Protocol.HTTP_1_1))
+        .protocols(asList(Protocol.HTTP_1_1))
         .build();
 
     webServer.enqueue(new MockResponse()
@@ -740,8 +756,8 @@
     Response response = client.newCall(regularRequest).execute();
     response.close();
 
-    assertEquals(0, webServer.takeRequest().getSequenceNumber());
-    assertEquals(1, webServer.takeRequest().getSequenceNumber());
+    assertThat(webServer.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(webServer.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   private MockResponse upgradeResponse(RecordedRequest request) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
similarity index 86%
rename from okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
rename to okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index 9fa5d1d9dc..97514efa44 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -19,15 +19,13 @@
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
-import java.util.regex.Pattern;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.ByteString;
 import org.junit.After;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class WebSocketReaderTest {
@@ -44,38 +42,38 @@
   }
 
   @Test public void controlFramesMustBeFinal() throws IOException {
-    data.write(ByteString.decodeHex("0a00")); // Empty ping.
+    data.write(ByteString.decodeHex("0a00")); // Empty pong.
     try {
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Control frames must be final.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Control frames must be final.");
     }
   }
 
   @Test public void reservedFlagsAreUnsupported() throws IOException {
-    data.write(ByteString.decodeHex("9a00")); // Empty ping, flag 1 set.
+    data.write(ByteString.decodeHex("ca00")); // Empty pong, flag 1 set.
     try {
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Reserved flags are unsupported.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Reserved flags are unsupported.");
     }
     data.clear();
-    data.write(ByteString.decodeHex("aa00")); // Empty ping, flag 2 set.
+    data.write(ByteString.decodeHex("aa00")); // Empty pong, flag 2 set.
     try {
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Reserved flags are unsupported.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Reserved flags are unsupported.");
     }
     data.clear();
-    data.write(ByteString.decodeHex("ca00")); // Empty ping, flag 3 set.
+    data.write(ByteString.decodeHex("9a00")); // Empty pong, flag 3 set.
     try {
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Reserved flags are unsupported.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Reserved flags are unsupported.");
     }
   }
 
@@ -85,7 +83,7 @@
       serverReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Client-sent frames must be masked.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Client-sent frames must be masked.");
     }
   }
 
@@ -95,7 +93,7 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Server-sent frames must not be masked.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Server-sent frames must not be masked.");
     }
   }
 
@@ -105,7 +103,7 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Control frame must be less than 125B.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Control frame must be less than 125B.");
     }
   }
 
@@ -139,7 +137,8 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Frame length 0x8000000000000000 > 0x7FFFFFFFFFFFFFFF", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "Frame length 0x8000000000000000 > 0x7FFFFFFFFFFFFFFF");
     }
   }
 
@@ -233,7 +232,7 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Expected continuation opcode. Got: 2", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Expected continuation opcode. Got: 2");
     }
   }
 
@@ -261,7 +260,7 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Malformed close payload length of 1.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Malformed close payload length of 1.");
     }
   }
 
@@ -284,14 +283,14 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Code must be in range [1000,5000): 1", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Code must be in range [1000,5000): 1");
     }
     data.write(ByteString.decodeHex("88021388")); // Close with code 5000
     try {
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Code must be in range [1000,5000): 5000", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Code must be in range [1000,5000): 5000");
     }
   }
 
@@ -309,11 +308,10 @@
         clientReader.processNextFrame();
         fail();
       } catch (ProtocolException e) {
-        String message = e.getMessage();
-        assertTrue(message, Pattern.matches("Code \\d+ is reserved and may not be used.", message));
+        assertThat(e.getMessage()).matches("Code \\d+ is reserved and may not be used.");
       }
     }
-    assertEquals(1991, count);
+    assertThat(count).isEqualTo(1991);
   }
 
   private byte[] binaryData(int length) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
similarity index 91%
rename from okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
rename to okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
index e8d4353829..0ab1d1857b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
@@ -16,7 +16,6 @@
 package okhttp3.internal.ws;
 
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.Objects;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
@@ -28,10 +27,7 @@
 import okhttp3.internal.platform.Platform;
 import okio.ByteString;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class WebSocketRecorder extends WebSocketListener {
   private final String name;
@@ -135,36 +131,36 @@ private Object nextEvent() {
 
   public void assertTextMessage(String payload) {
     Object actual = nextEvent();
-    assertEquals(new Message(payload), actual);
+    assertThat(actual).isEqualTo(new Message(payload));
   }
 
   public void assertBinaryMessage(ByteString payload) {
     Object actual = nextEvent();
-    assertEquals(new Message(payload), actual);
+    assertThat(actual).isEqualTo(new Message(payload));
   }
 
   public void assertPing(ByteString payload) {
     Object actual = nextEvent();
-    assertEquals(new Ping(payload), actual);
+    assertThat(actual).isEqualTo(new Ping(payload));
   }
 
   public void assertPong(ByteString payload) {
     Object actual = nextEvent();
-    assertEquals(new Pong(payload), actual);
+    assertThat(actual).isEqualTo(new Pong(payload));
   }
 
   public void assertClosing(int code, String reason) {
     Object actual = nextEvent();
-    assertEquals(new Closing(code, reason), actual);
+    assertThat(actual).isEqualTo(new Closing(code, reason));
   }
 
   public void assertClosed(int code, String reason) {
     Object actual = nextEvent();
-    assertEquals(new Closed(code, reason), actual);
+    assertThat(actual).isEqualTo(new Closed(code, reason));
   }
 
   public void assertExhausted() {
-    assertTrue("Remaining events: " + events, events.isEmpty());
+    assertThat(events).isEmpty();
   }
 
   public WebSocket assertOpen() {
@@ -181,8 +177,8 @@ public void assertFailure(Throwable t) {
       throw new AssertionError("Expected Failure but was " + event);
     }
     Failure failure = (Failure) event;
-    assertNull(failure.response);
-    assertSame(t, failure.t);
+    assertThat(failure.response).isNull();
+    assertThat(failure.t).isSameAs(t);
   }
 
   public void assertFailure(Class<? extends IOException> cls, String... messages) {
@@ -191,10 +187,10 @@ public void assertFailure(Class<? extends IOException> cls, String... messages)
       throw new AssertionError("Expected Failure but was " + event);
     }
     Failure failure = (Failure) event;
-    assertNull(failure.response);
-    assertEquals(cls, failure.t.getClass());
+    assertThat(failure.response).isNull();
+    assertThat(failure.t.getClass()).isEqualTo(cls);
     if (messages.length > 0) {
-      assertTrue(failure.t.getMessage(), Arrays.asList(messages).contains(failure.t.getMessage()));
+      assertThat(messages).contains(failure.t.getMessage());
     }
   }
 
@@ -212,12 +208,12 @@ public void assertFailure(int code, String body, Class<? extends IOException> cl
       throw new AssertionError("Expected Failure but was " + event);
     }
     Failure failure = (Failure) event;
-    assertEquals(code, failure.response.code());
+    assertThat(failure.response.code()).isEqualTo(code);
     if (body != null) {
-      assertEquals(body, failure.responseBody);
+      assertThat(failure.responseBody).isEqualTo(body);
     }
-    assertEquals(cls, failure.t.getClass());
-    assertEquals(message, failure.t.getMessage());
+    assertThat(failure.t.getClass()).isEqualTo(cls);
+    assertThat(failure.t.getMessage()).isEqualTo(message);
   }
 
   /** Expose this recorder as a frame callback and shim in "ping" events. */
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
similarity index 91%
rename from okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
rename to okhttp/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
index 48684f553a..175df0ea7a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -35,8 +35,7 @@
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class WebSocketWriterTest {
@@ -50,7 +49,8 @@
   @Rule public final TestRule noDataLeftBehind = (base, description) -> new Statement() {
     @Override public void evaluate() throws Throwable {
       base.evaluate();
-      assertEquals("Data not empty", "", data.readByteString().hex());
+      assertThat(data.readByteString().hex()).overridingErrorMessage("Data not empty").isEqualTo(
+          "");
     }
   };
 
@@ -82,7 +82,7 @@
 
     assertData("8105");
     assertData(bytes);
-    assertTrue(data.exhausted());
+    assertThat(data.exhausted()).isTrue();
   }
 
   @Test public void serverLargeBufferedPayloadWrittenAsOneFrame() throws IOException {
@@ -97,7 +97,7 @@
     assertData("817e");
     assertData(Util.format("%04x", length));
     assertData(bytes);
-    assertTrue(data.exhausted());
+    assertThat(data.exhausted()).isTrue();
   }
 
   @Test public void serverLargeNonBufferedPayloadWrittenAsMultipleFrames() throws IOException {
@@ -125,7 +125,7 @@
     assertData(bytes.readByteArray(24_576));
     assertData("807e06a0");
     assertData(bytes.readByteArray(1_696));
-    assertTrue(data.exhausted());
+    assertThat(data.exhausted()).isTrue();
   }
 
   @Test public void closeFlushes() throws IOException {
@@ -150,7 +150,7 @@
       sink.write(payload, payload.size());
       fail();
     } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("closed");
     }
   }
 
@@ -288,7 +288,7 @@
       clientWriter.writeClose(98724976, ByteString.encodeUtf8("Hello"));
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("Code must be in range [1000,5000): 98724976", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Code must be in range [1000,5000): 98724976");
     }
   }
 
@@ -297,7 +297,7 @@
       clientWriter.writeClose(1005, ByteString.encodeUtf8("Hello"));
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("Code 1005 is reserved and may not be used.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Code 1005 is reserved and may not be used.");
     }
   }
 
@@ -346,7 +346,8 @@
       serverWriter.writePing(ByteString.of(binaryData(1000)));
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "Payload size must be less than or equal to 125");
     }
   }
 
@@ -355,7 +356,8 @@
       serverWriter.writePong(ByteString.of(binaryData(1000)));
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "Payload size must be less than or equal to 125");
     }
   }
 
@@ -365,7 +367,8 @@
       serverWriter.writeClose(1000, longReason);
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "Payload size must be less than or equal to 125");
     }
   }
 
@@ -375,7 +378,8 @@
       clientWriter.newMessageSink(OPCODE_TEXT, -1);
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Another message writer is active. Did you call close()?", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "Another message writer is active. Did you call close()?");
     }
   }
 
@@ -385,7 +389,7 @@ private void assertData(String hex) throws EOFException {
 
   private void assertData(ByteString expected) throws EOFException {
     ByteString actual = data.readByteString(expected.size());
-    assertEquals(expected, actual);
+    assertThat(actual).isEqualTo(expected);
   }
 
   private void assertData(byte[] data) throws IOException {
@@ -394,7 +398,8 @@ private void assertData(byte[] data) throws IOException {
       int count = Math.min(byteCount, data.length - i);
       Buffer expectedChunk = new Buffer();
       expectedChunk.write(data, i, count);
-      assertEquals("At " + i, expectedChunk.readByteString(), this.data.readByteString(count));
+      assertThat(this.data.readByteString(count)).overridingErrorMessage("At " + i).isEqualTo(
+          expectedChunk.readByteString());
     }
   }
 
diff --git a/okhttp-tests/src/test/resources/web-platform-test-urltestdata.txt b/okhttp/src/test/resources/web-platform-test-urltestdata.txt
similarity index 100%
rename from okhttp-tests/src/test/resources/web-platform-test-urltestdata.txt
rename to okhttp/src/test/resources/web-platform-test-urltestdata.txt
diff --git a/pom.xml b/pom.xml
deleted file mode 100644
index af6796f41a..0000000000
--- a/pom.xml
+++ /dev/null
@@ -1,683 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>7</version>
-  </parent>
-
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>parent</artifactId>
-  <version>3.13.0-SNAPSHOT</version>
-  <packaging>pom</packaging>
-
-  <name>OkHttp (Parent)</name>
-  <description>An HTTP+HTTP/2 client for Android and Java applications</description>
-  <url>https://github.com/square/okhttp</url>
-
-  <modules>
-    <module>okhttp</module>
-    <module>okhttp-tests</module>
-
-    <module>okhttp-android-support</module>
-
-    <module>okhttp-apache</module>
-    <module>okhttp-sse</module>
-    <module>okhttp-testing-support</module>
-    <module>okhttp-tls</module>
-    <module>okhttp-urlconnection</module>
-
-    <module>okhttp-logging-interceptor</module>
-
-    <module>okhttp-dnsoverhttps</module>
-
-    <module>okcurl</module>
-    <module>mockwebserver</module>
-    <module>bom</module>
-    <module>samples</module>
-  </modules>
-
-  <properties>
-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-
-    <!-- Compilation -->
-    <airlift.version>0.8</airlift.version>
-    <android.version>4.1.1.4</android.version>
-    <animal.sniffer.version>1.17</animal.sniffer.version>
-    <apache.http.version>4.5.6</apache.http.version>
-    <bouncycastle.version>1.60</bouncycastle.version>
-    <guava.version>27.0.1-jre</guava.version>
-    <java.version>1.8</java.version>
-    <moshi.version>1.8.0</moshi.version>
-    <jnr-unixsocket.version>0.21</jnr-unixsocket.version>
-    <okio.version>1.17.2</okio.version>
-    <conscrypt.version>1.4.2</conscrypt.version>
-
-    <!-- Test Dependencies -->
-    <junit.version>4.12</junit.version>
-
-    <!-- platform test mode -->
-    <okhttp.platform>platform</okhttp.platform>
-  </properties>
-
-  <scm>
-    <url>https://github.com/square/okhttp/</url>
-    <connection>scm:git:https://github.com/square/okhttp.git</connection>
-    <developerConnection>scm:git:git@github.com:square/okhttp.git</developerConnection>
-    <tag>HEAD</tag>
-  </scm>
-
-  <issueManagement>
-    <system>GitHub Issues</system>
-    <url>https://github.com/square/okhttp/issues</url>
-  </issueManagement>
-
-  <licenses>
-    <license>
-      <name>Apache 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-    </license>
-  </licenses>
-
-  <dependencyManagement>
-    <dependencies>
-      <dependency>
-        <groupId>com.squareup.okio</groupId>
-        <artifactId>okio</artifactId>
-        <version>${okio.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.code.findbugs</groupId>
-        <artifactId>jsr305</artifactId>
-        <version>3.0.2</version>
-        <scope>provided</scope>
-      </dependency>
-      <dependency>
-        <groupId>junit</groupId>
-        <artifactId>junit</artifactId>
-        <version>${junit.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.bouncycastle</groupId>
-        <artifactId>bcprov-jdk15on</artifactId>
-        <version>${bouncycastle.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.apache.httpcomponents</groupId>
-        <artifactId>httpclient</artifactId>
-        <version>${apache.http.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.airlift</groupId>
-        <artifactId>airline</artifactId>
-        <version>${airlift.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.guava</groupId>
-        <artifactId>guava</artifactId>
-        <version>${guava.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.android</groupId>
-        <artifactId>android</artifactId>
-        <version>${android.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.squareup.moshi</groupId>
-        <artifactId>moshi</artifactId>
-        <version>${moshi.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.github.jnr</groupId>
-        <artifactId>jnr-unixsocket</artifactId>
-        <version>${jnr-unixsocket.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.conscrypt</groupId>
-        <artifactId>conscrypt-openjdk-uber</artifactId>
-        <version>${conscrypt.version}</version>
-      </dependency>
-    </dependencies>
-  </dependencyManagement>
-
-  <build>
-    <pluginManagement>
-      <plugins>
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.8.0</version>
-          <configuration>
-            <compilerId>javac-with-errorprone</compilerId>
-            <forceJavacCompilerUse>true</forceJavacCompilerUse>
-            <source>${java.version}</source>
-            <target>${java.version}</target>
-          </configuration>
-          <dependencies>
-            <dependency>
-              <groupId>org.codehaus.plexus</groupId>
-              <artifactId>plexus-compiler-javac-errorprone</artifactId>
-              <version>2.8.5</version>
-            </dependency>
-            <dependency>
-              <groupId>com.google.errorprone</groupId>
-              <artifactId>error_prone_core</artifactId>
-              <version>2.3.2</version>
-            </dependency>
-          </dependencies>
-        </plugin>
-
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-surefire-plugin</artifactId>
-          <version>2.22.1</version>
-          <configuration>
-            <systemPropertyVariables>
-              <okhttp.platform>${okhttp.platform}</okhttp.platform>
-            </systemPropertyVariables>
-            <redirectTestOutputToFile>true</redirectTestOutputToFile>
-            <properties>
-              <!--
-                Configure a listener for enforcing that no uncaught exceptions issue from OkHttp
-                tests. Every test must have a <scope>test</scope> dependency on
-                okhttp-testing-support.
-                -->
-              <property>
-                <name>listener</name>
-                <value>okhttp3.testing.InstallUncaughtExceptionHandlerListener</value>
-              </property>
-            </properties>
-          </configuration>
-          <dependencies>
-            <dependency>
-              <groupId>org.apache.maven.surefire</groupId>
-              <artifactId>surefire-junit47</artifactId>
-              <version>2.22.1</version>
-            </dependency>
-          </dependencies>
-        </plugin>
-
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-javadoc-plugin</artifactId>
-          <version>3.0.1</version>
-        </plugin>
-      </plugins>
-    </pluginManagement>
-
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <version>2.5.3</version>
-        <dependencies>
-          <dependency>
-            <groupId>org.apache.maven.scm</groupId>
-            <artifactId>maven-scm-provider-gitexe</artifactId>
-            <version>1.11.1</version>
-          </dependency>
-        </dependencies>
-        <configuration>
-          <autoVersionSubmodules>true</autoVersionSubmodules>
-        </configuration>
-      </plugin>
-
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>3.0.0</version>
-        <dependencies>
-          <dependency>
-            <groupId>com.puppycrawl.tools</groupId>
-            <artifactId>checkstyle</artifactId>
-            <version>8.15</version>
-          </dependency>
-        </dependencies>
-        <configuration>
-          <failsOnError>true</failsOnError>
-          <configLocation>checkstyle.xml</configLocation>
-          <consoleOutput>true</consoleOutput>
-          <excludes>**/CipherSuite.java</excludes>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>verify</phase>
-            <goals>
-              <goal>checkstyle</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <version>${animal.sniffer.version}</version>
-        <executions>
-          <execution>
-            <id>sniff-java18</id>
-            <phase>test</phase>
-            <goals>
-              <goal>check</goal>
-            </goals>
-            <configuration>
-              <signature>
-                <groupId>org.codehaus.mojo.signature</groupId>
-                <artifactId>java18</artifactId>
-                <version>1.0</version>
-              </signature>
-            </configuration>
-          </execution>
-          <execution>
-            <id>sniff-android5</id>
-            <phase>test</phase>
-            <goals>
-              <goal>check</goal>
-            </goals>
-            <configuration>
-              <signature>
-                <groupId>net.sf.androidscents.signature</groupId>
-                <artifactId>android-api-level-21</artifactId>
-                <version>5.0.1_r2</version>
-              </signature>
-            </configuration>
-          </execution>
-        </executions>
-      </plugin>
-    </plugins>
-  </build>
-
-  <profiles>
-    <profile>
-      <id>alpn-when-jdk8</id>
-      <activation>
-        <jdk>1.8</jdk>
-      </activation>
-      <properties>
-        <bootclasspathPrefix>
-          ${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk8.version}/alpn-boot-${alpn.jdk8.version}.jar
-        </bootclasspathPrefix>
-        <okhttp.platform>jdk-with-jetty-boot</okhttp.platform>
-      </properties>
-      <build>
-        <pluginManagement>
-          <plugins>
-            <plugin>
-              <groupId>org.apache.maven.plugins</groupId>
-              <artifactId>maven-surefire-plugin</artifactId>
-              <configuration>
-                <argLine>-Xbootclasspath/p:${bootclasspathPrefix} -Xms512m -Xmx512m</argLine>
-              </configuration>
-              <dependencies>
-                <dependency>
-                  <groupId>org.mortbay.jetty.alpn</groupId>
-                  <artifactId>alpn-boot</artifactId>
-                  <version>${alpn.jdk8.version}</version>
-                </dependency>
-              </dependencies>
-            </plugin>
-          </plugins>
-        </pluginManagement>
-      </build>
-    </profile>
-    <profile>
-      <id>jdk9</id>
-      <activation>
-        <jdk>9</jdk>
-      </activation>
-      <properties>
-        <okhttp.platform>jdk9</okhttp.platform>
-      </properties>
-    </profile>
-    <profile>
-      <id>conscrypt</id>
-      <properties>
-        <okhttp.platform>conscrypt</okhttp.platform>
-      </properties>
-      <dependencies>
-        <dependency>
-          <groupId>org.conscrypt</groupId>
-          <artifactId>conscrypt-openjdk-uber</artifactId>
-        </dependency>
-      </dependencies>
-    </profile>
-    <!-- ALPN Versions targeted for each Java 8 minor release -->
-    <!-- Check versions with this page: -->
-    <!-- http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html#alpn-chapterchapterversions -->
-    <profile>
-      <id>alpn-when-jdk8_05</id>
-      <activation>
-        <jdk>1.8.0_05</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_11</id>
-      <activation>
-        <jdk>1.8.0_11</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_20</id>
-      <activation>
-        <jdk>1.8.0_20</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_25</id>
-      <activation>
-        <jdk>1.8.0_25</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.2.v20141202</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_31</id>
-      <activation>
-        <jdk>1.8.0_31</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_40</id>
-      <activation>
-        <jdk>1.8.0_40</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_45</id>
-      <activation>
-        <jdk>1.8.0_45</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_51</id>
-      <activation>
-        <jdk>1.8.0_51</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.4.v20150727</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_60</id>
-      <activation>
-        <jdk>1.8.0_60</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.5.v20150921</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_65</id>
-      <activation>
-        <jdk>1.8.0_65</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.6.v20151105</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_66</id>
-      <activation>
-        <jdk>1.8.0_66</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.6.v20151105</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_71</id>
-      <activation>
-        <jdk>1.8.0_71</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_72</id>
-      <activation>
-        <jdk>1.8.0_72</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_73</id>
-      <activation>
-        <jdk>1.8.0_73</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_74</id>
-      <activation>
-        <jdk>1.8.0_74</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_77</id>
-      <activation>
-        <jdk>1.8.0_77</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_91</id>
-      <activation>
-        <jdk>1.8.0_91</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_92</id>
-      <activation>
-        <jdk>1.8.0_92</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.8.v20160420</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_101</id>
-      <activation>
-        <jdk>1.8.0_101</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.8.v20160420</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_102</id>
-      <activation>
-        <jdk>1.8.0_102</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_111</id>
-      <activation>
-        <jdk>1.8.0_111</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_112</id>
-      <activation>
-        <jdk>1.8.0_112</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_121</id>
-      <activation>
-        <jdk>1.8.0_121</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_131</id>
-      <activation>
-        <jdk>1.8.0_131</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_141</id>
-      <activation>
-        <jdk>1.8.0_141</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_144</id>
-      <activation>
-        <jdk>1.8.0_144</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_151</id>
-      <activation>
-        <jdk>1.8.0_151</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_152</id>
-      <activation>
-        <jdk>1.8.0_152</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_161</id>
-      <activation>
-        <jdk>1.8.0_161</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_162</id>
-      <activation>
-        <jdk>1.8.0_162</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_171</id>
-      <activation>
-        <jdk>1.8.0_171</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_172</id>
-      <activation>
-        <jdk>1.8.0_172</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_181</id>
-      <activation>
-        <jdk>1.8.0_181</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_191</id>
-      <activation>
-        <jdk>1.8.0_191</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.13.v20181017</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_192</id>
-      <activation>
-        <jdk>1.8.0_192</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.13.v20181017</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_201</id>
-      <activation>
-        <jdk>1.8.0_201</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.13.v20181017</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_202</id>
-      <activation>
-        <jdk>1.8.0_202</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.13.v20181017</alpn.jdk8.version>
-      </properties>
-    </profile>
-  </profiles>
-</project>
diff --git a/samples/crawler/build.gradle b/samples/crawler/build.gradle
new file mode 100644
index 0000000000..d9f72bd9c2
--- /dev/null
+++ b/samples/crawler/build.gradle
@@ -0,0 +1,4 @@
+dependencies {
+  implementation project(':okhttp')
+  implementation deps.jsoup
+}
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
deleted file mode 100644
index e251e2054c..0000000000
--- a/samples/crawler/pom.xml
+++ /dev/null
@@ -1,27 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>crawler</artifactId>
-  <name>Sample: Crawler</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>org.jsoup</groupId>
-      <artifactId>jsoup</artifactId>
-      <version>1.11.3</version>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/samples/guide/build.gradle b/samples/guide/build.gradle
new file mode 100644
index 0000000000..7f2ef89506
--- /dev/null
+++ b/samples/guide/build.gradle
@@ -0,0 +1,6 @@
+dependencies {
+  implementation project(':okhttp')
+  implementation project(':mockwebserver')
+  implementation project(':okhttp-tls')
+  implementation deps.moshi
+}
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
deleted file mode 100644
index 85f5d36f73..0000000000
--- a/samples/guide/pom.xml
+++ /dev/null
@@ -1,36 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>guide</artifactId>
-  <name>Sample: Guide</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp-tls</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java b/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
index b568bdf01c..228956ec10 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
@@ -37,6 +37,8 @@
 import okhttp3.Request;
 import okhttp3.Response;
 
+import static java.util.Arrays.asList;
+
 public final class CustomCipherSuites {
   private final OkHttpClient client;
 
@@ -45,7 +47,7 @@ public CustomCipherSuites() throws GeneralSecurityException {
     // an OkHttp request. In order to be selected a cipher suite must be included in both OkHttp's
     // connection spec and in the SSLSocket's enabled cipher suites array. Most applications should
     // not customize the cipher suites list.
-    List<CipherSuite> customCipherSuites = Arrays.asList(
+    List<CipherSuite> customCipherSuites = asList(
         CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
         CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
         CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
index 1366a82f15..6c9f71279f 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
@@ -156,6 +156,10 @@ private void printEvent(String name) {
       printEvent("requestBodyEnd");
     }
 
+    @Override public void requestFailed(Call call, IOException ioe) {
+      printEvent("requestFailed");
+    }
+
     @Override public void responseHeadersStart(Call call) {
       printEvent("responseHeadersStart");
     }
@@ -172,6 +176,10 @@ private void printEvent(String name) {
       printEvent("responseBodyEnd");
     }
 
+    @Override public void responseFailed(Call call, IOException ioe) {
+      printEvent("responseFailed");
+    }
+
     @Override public void callEnd(Call call) {
       printEvent("callEnd");
     }
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
index 6acedb19e7..c88895b794 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
@@ -131,6 +131,10 @@ private void printEvent(String name) {
       printEvent("requestBodyEnd");
     }
 
+    @Override public void requestFailed(Call call, IOException ioe) {
+      printEvent("requestFailed");
+    }
+
     @Override public void responseHeadersStart(Call call) {
       printEvent("responseHeadersStart");
     }
@@ -147,6 +151,10 @@ private void printEvent(String name) {
       printEvent("responseBodyEnd");
     }
 
+    @Override public void responseFailed(Call call, IOException ioe) {
+      printEvent("responseFailed");
+    }
+
     @Override public void callEnd(Call call) {
       printEvent("callEnd");
     }
diff --git a/samples/pom.xml b/samples/pom.xml
deleted file mode 100644
index 4cb343bce2..0000000000
--- a/samples/pom.xml
+++ /dev/null
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <groupId>com.squareup.okhttp3.sample</groupId>
-  <artifactId>sample-parent</artifactId>
-  <packaging>pom</packaging>
-  <name>Samples (Parent)</name>
-
-  <modules>
-    <module>guide</module>
-    <module>crawler</module>
-    <module>simple-client</module>
-    <module>slack</module>
-    <module>static-server</module>
-    <module>unixdomainsockets</module>
-  </modules>
-
-  <build>
-    <plugins>
-      <plugin>
-        <!-- Fails on Throwable.addSuppressed() in ARM blocks. -->
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <executions>
-          <execution>
-            <phase>none</phase>
-          </execution>
-        </executions>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/samples/simple-client/build.gradle b/samples/simple-client/build.gradle
new file mode 100644
index 0000000000..f47e38b46c
--- /dev/null
+++ b/samples/simple-client/build.gradle
@@ -0,0 +1,4 @@
+dependencies {
+  implementation project(':okhttp')
+  implementation deps.moshi
+}
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
deleted file mode 100644
index 9b193b2033..0000000000
--- a/samples/simple-client/pom.xml
+++ /dev/null
@@ -1,27 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>simple-client</artifactId>
-  <name>Sample: Simple Client</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/samples/slack/build.gradle b/samples/slack/build.gradle
new file mode 100644
index 0000000000..b47f85b5a4
--- /dev/null
+++ b/samples/slack/build.gradle
@@ -0,0 +1,4 @@
+dependencies {
+  implementation project(':mockwebserver')
+  implementation deps.moshi
+}
diff --git a/samples/slack/pom.xml b/samples/slack/pom.xml
deleted file mode 100644
index ea003abc2e..0000000000
--- a/samples/slack/pom.xml
+++ /dev/null
@@ -1,26 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>slack</artifactId>
-  <name>Sample: Slack</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/samples/static-server/build.gradle b/samples/static-server/build.gradle
new file mode 100644
index 0000000000..1b1bb519c6
--- /dev/null
+++ b/samples/static-server/build.gradle
@@ -0,0 +1,15 @@
+apply plugin: 'com.github.johnrengelman.shadow'
+
+jar {
+  manifest {
+    attributes 'Main-Class': 'okhttp3.sample.SampleServer'
+  }
+}
+
+dependencies {
+  implementation project(':mockwebserver')
+}
+
+shadowJar {
+  mergeServiceFiles()
+}
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
deleted file mode 100644
index 5dd6cac971..0000000000
--- a/samples/static-server/pom.xml
+++ /dev/null
@@ -1,62 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>static-server</artifactId>
-  <name>Sample: Static Server</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-shade-plugin</artifactId>
-        <version>3.2.1</version>
-        <configuration>
-          <shadedArtifactAttached>true</shadedArtifactAttached>
-          <shadedClassifierName>shaded</shadedClassifierName>
-          <transformers>
-            <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
-              <manifestEntries>
-                <Main-Class>okhttp3.sample.SampleServer</Main-Class>
-              </manifestEntries>
-            </transformer>
-          </transformers>
-          <filters>
-            <filter>
-              <artifact>*:*</artifact>
-              <excludes>
-                <exclude>META-INF/*.SF</exclude>
-                <exclude>META-INF/*.DSA</exclude>
-                <exclude>META-INF/*.RSA</exclude>
-              </excludes>
-            </filter>
-          </filters>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>shade</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/samples/unixdomainsockets/build.gradle b/samples/unixdomainsockets/build.gradle
new file mode 100644
index 0000000000..ea86233a50
--- /dev/null
+++ b/samples/unixdomainsockets/build.gradle
@@ -0,0 +1,5 @@
+dependencies {
+  implementation project(':okhttp')
+  implementation project(':mockwebserver')
+  implementation deps.jnrUnixsocket
+}
diff --git a/samples/unixdomainsockets/pom.xml b/samples/unixdomainsockets/pom.xml
deleted file mode 100644
index 0f1c5459fb..0000000000
--- a/samples/unixdomainsockets/pom.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.13.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>unixdomainsockets</artifactId>
-  <name>Sample: UNIX domain sockets</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.github.jnr</groupId>
-      <artifactId>jnr-unixsocket</artifactId>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/BlockingUnixSocket.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/BlockingUnixSocket.java
deleted file mode 100644
index 3ba58448c2..0000000000
--- a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/BlockingUnixSocket.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.unixdomainsockets;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.SocketAddress;
-import java.nio.ByteBuffer;
-import java.nio.channels.Channels;
-import java.nio.channels.ReadableByteChannel;
-import java.nio.channels.SelectableChannel;
-import java.nio.channels.WritableByteChannel;
-import jnr.unixsocket.UnixSocket;
-import jnr.unixsocket.UnixSocketAddress;
-import jnr.unixsocket.UnixSocketChannel;
-
-/**
- * Subtype UNIX socket for a higher-fidelity impersonation of TCP sockets.
- *
- * <p>This class doesn't pass {@link SelectableChannel} implementations to create input and output
- * streams. Though that type isn't in the public API, if the channel passed in implements that
- * interface then additional synchronization is used. This additional synchronization harms
- * concurrency and can cause deadlocks.
- *
- * <p>This class remembers which socket address was connected so that a non-null value can be
- * returned on calls to {@link #getInetAddress}.
- */
-final class BlockingUnixSocket extends UnixSocket {
-  private final File path;
-  private final InputStream in;
-  private final OutputStream out;
-  private InetSocketAddress inetSocketAddress;
-
-  BlockingUnixSocket(File path, UnixSocketChannel channel) {
-    super(channel);
-    this.path = path;
-    this.in = Channels.newInputStream(new UnselectableReadableByteChannel());
-    this.out = Channels.newOutputStream(new UnselectableWritableByteChannel());
-  }
-
-  BlockingUnixSocket(File path, UnixSocketChannel channel, InetSocketAddress address) {
-    this(path, channel);
-    this.inetSocketAddress = address;
-  }
-
-  @Override public void connect(SocketAddress endpoint) throws IOException {
-    connect(endpoint, Integer.valueOf(0));
-  }
-
-  @Override public void connect(SocketAddress endpoint, int timeout) throws IOException {
-    connect(endpoint, Integer.valueOf(timeout));
-  }
-
-  @Override public void connect(SocketAddress endpoint, Integer timeout) throws IOException {
-    this.inetSocketAddress = (InetSocketAddress) endpoint;
-    super.connect(new UnixSocketAddress(path), timeout);
-  }
-
-  @Override public InetAddress getInetAddress() {
-    return inetSocketAddress.getAddress(); // TODO(jwilson): fake the remote address?
-  }
-
-  @Override public InputStream getInputStream() throws IOException {
-    if (!isConnected()) throw new IOException("not connected");
-    return in;
-  }
-
-  @Override public OutputStream getOutputStream() throws IOException {
-    if (!isConnected()) throw new IOException("not connected");
-    return out;
-  }
-
-  /** A readable byte channel that doesn't implement {@link SelectableChannel}. */
-  final class UnselectableReadableByteChannel implements ReadableByteChannel {
-    @Override public int read(ByteBuffer dst) throws IOException {
-      return getChannel().read(dst);
-    }
-
-    @Override public boolean isOpen() {
-      return getChannel().isOpen();
-    }
-
-    @Override public void close() throws IOException {
-      getChannel().close();
-    }
-  }
-
-  /** A writable byte channel that doesn't implement {@link SelectableChannel}. */
-  final class UnselectableWritableByteChannel implements WritableByteChannel {
-    @Override public int write(ByteBuffer src) throws IOException {
-      return getChannel().write(src);
-    }
-
-    @Override public boolean isOpen() {
-      return getChannel().isOpen();
-    }
-
-    @Override public void close() throws IOException {
-      getChannel().close();
-    }
-  }
-}
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/TunnelingUnixSocket.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/TunnelingUnixSocket.java
new file mode 100644
index 0000000000..678e04d4f7
--- /dev/null
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/TunnelingUnixSocket.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.unixdomainsockets;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import jnr.unixsocket.UnixSocket;
+import jnr.unixsocket.UnixSocketAddress;
+import jnr.unixsocket.UnixSocketChannel;
+
+/**
+ * Subtype UNIX socket for a higher-fidelity impersonation of TCP sockets. This is named "tunneling"
+ * because it assumes the ultimate destination has a hostname and port.
+ */
+final class TunnelingUnixSocket extends UnixSocket {
+  private final File path;
+  private InetSocketAddress inetSocketAddress;
+
+  TunnelingUnixSocket(File path, UnixSocketChannel channel) {
+    super(channel);
+    this.path = path;
+  }
+
+  TunnelingUnixSocket(File path, UnixSocketChannel channel, InetSocketAddress address) {
+    this(path, channel);
+    this.inetSocketAddress = address;
+  }
+
+  @Override public void connect(SocketAddress endpoint) throws IOException {
+    this.inetSocketAddress = (InetSocketAddress) endpoint;
+    super.connect(new UnixSocketAddress(path), 0);
+  }
+
+  @Override public void connect(SocketAddress endpoint, int timeout) throws IOException {
+    this.inetSocketAddress = (InetSocketAddress) endpoint;
+    super.connect(new UnixSocketAddress(path), timeout);
+  }
+
+  @Override public InetAddress getInetAddress() {
+    return inetSocketAddress.getAddress();
+  }
+}
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java
index c1d63b5a32..a96649e425 100644
--- a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java
@@ -22,6 +22,8 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketAddress;
+import java.net.SocketException;
+import java.nio.channels.ClosedChannelException;
 import javax.net.ServerSocketFactory;
 import jnr.unixsocket.UnixServerSocketChannel;
 import jnr.unixsocket.UnixSocketAddress;
@@ -35,25 +37,21 @@ public UnixDomainServerSocketFactory(File path) {
     this.path = path;
   }
 
-  private ServerSocket createUnixDomainSocket() throws IOException {
-    return new UnixDomainServerSocket();
-  }
-
   @Override public ServerSocket createServerSocket() throws IOException {
-    return createUnixDomainSocket();
+    return new UnixDomainServerSocket();
   }
 
   @Override public ServerSocket createServerSocket(int port) throws IOException {
-    return createUnixDomainSocket();
+    return createServerSocket();
   }
 
   @Override public ServerSocket createServerSocket(int port, int backlog) throws IOException {
-    return createUnixDomainSocket();
+    return createServerSocket();
   }
 
   @Override public ServerSocket createServerSocket(
       int port, int backlog, InetAddress inetAddress) throws IOException {
-    return createUnixDomainSocket();
+    return createServerSocket();
   }
 
   final class UnixDomainServerSocket extends ServerSocket {
@@ -81,8 +79,14 @@ private ServerSocket createUnixDomainSocket() throws IOException {
     }
 
     @Override public Socket accept() throws IOException {
-      UnixSocketChannel channel = serverSocketChannel.accept();
-      return new BlockingUnixSocket(path, channel, endpoint);
+      try {
+        UnixSocketChannel channel = serverSocketChannel.accept();
+        return new TunnelingUnixSocket(path, channel, endpoint);
+      } catch (ClosedChannelException e) {
+        SocketException exception = new SocketException();
+        exception.initCause(e);
+        throw exception;
+      }
     }
 
     @Override public void close() throws IOException {
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java
index e288dc5287..fc1c8e05a6 100644
--- a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java
@@ -18,6 +18,7 @@
 import java.io.File;
 import java.io.IOException;
 import java.net.InetAddress;
+import java.net.InetSocketAddress;
 import java.net.Socket;
 import javax.net.SocketFactory;
 import jnr.unixsocket.UnixSocketChannel;
@@ -30,30 +31,30 @@ public UnixDomainSocketFactory(File path) {
     this.path = path;
   }
 
-  private Socket createUnixDomainSocket() throws IOException {
-    UnixSocketChannel channel = UnixSocketChannel.open();
-    return new BlockingUnixSocket(path, channel);
-  }
-
   @Override public Socket createSocket() throws IOException {
-    return createUnixDomainSocket();
+    UnixSocketChannel channel = UnixSocketChannel.open();
+    return new TunnelingUnixSocket(path, channel);
   }
 
   @Override public Socket createSocket(String host, int port) throws IOException {
-    return createUnixDomainSocket();
+    Socket result = createSocket();
+    result.connect(new InetSocketAddress(host, port));
+    return result;
   }
 
   @Override public Socket createSocket(
       String host, int port, InetAddress localHost, int localPort) throws IOException {
-    return createUnixDomainSocket();
+    return createSocket(host, port);
   }
 
   @Override public Socket createSocket(InetAddress host, int port) throws IOException {
-    return createUnixDomainSocket();
+    Socket result = createSocket();
+    result.connect(new InetSocketAddress(host, port));
+    return result;
   }
 
   @Override public Socket createSocket(
-      InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
-    return createUnixDomainSocket();
+      InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException {
+    return createSocket(host, port);
   }
 }
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 0000000000..367bee6364
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1,16 @@
+include ':mockwebserver'
+include ':okcurl'
+include ':okhttp'
+include ':okhttp-dnsoverhttps'
+include ':okhttp-hpacktests'
+include ':okhttp-logging-interceptor'
+include ':okhttp-sse'
+include ':okhttp-testing-support'
+include ':okhttp-tls'
+include ':okhttp-urlconnection'
+include ':samples:crawler'
+include ':samples:guide'
+include ':samples:simple-client'
+include ':samples:slack'
+include ':samples:static-server'
+include ':samples:unixdomainsockets'
diff --git a/website/index.html b/website/index.html
index 2a32b6edc6..02c69c6c9c 100644
--- a/website/index.html
+++ b/website/index.html
@@ -124,7 +124,7 @@ <h4>Gradle</h4>
 
             <h3 id="contributing">Contributing</h3>
             <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
-            <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
+            <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>./gradlew check</code>.</p>
 
             <p>Some general advice</p>
             <ul>
