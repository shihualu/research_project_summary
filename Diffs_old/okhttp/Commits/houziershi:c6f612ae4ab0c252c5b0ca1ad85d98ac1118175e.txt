diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
index d9a8e909da..7dfe3f41bf 100755
--- a/.buildscript/deploy_snapshot.sh
+++ b/.buildscript/deploy_snapshot.sh
@@ -21,6 +21,6 @@ elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
   echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
 else
   echo "Deploying snapshot..."
-  mvn clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -DskipTests
+  ./gradlew clean uploadArchives
   echo "Snapshot deployed!"
 fi
diff --git a/.buildscript/settings.xml b/.buildscript/settings.xml
deleted file mode 100644
index 91f444b228..0000000000
--- a/.buildscript/settings.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<settings>
-  <servers>
-    <server>
-      <id>sonatype-nexus-snapshots</id>
-      <username>${env.CI_DEPLOY_USERNAME}</username>
-      <password>${env.CI_DEPLOY_PASSWORD}</password>
-    </server>
-  </servers>
-</settings>
diff --git a/.circleci/config.yml b/.circleci/config.yml
new file mode 100644
index 0000000000..26a5967a40
--- /dev/null
+++ b/.circleci/config.yml
@@ -0,0 +1,192 @@
+# Check https://circleci.com/docs/2.0/language-java/ for more details
+version: 2.1
+jobs:
+  compile:
+    docker:
+      - image: circleci/openjdk:8u171-jdk
+
+    working_directory: ~/repo
+
+    environment:
+      JVM_OPTS: -Xmx768m
+      TERM: dumb
+
+    steps:
+      - checkout
+
+      - restore_cache:
+          keys:
+            - v3-{{ checksum "build.gradle" }}-{{ .Branch }}
+            - v3-{{ checksum "build.gradle" }}-master
+            - v3-{{ checksum "build.gradle" }}
+
+      - run:
+          name: dependencies
+          command: ./gradlew --parallel --build-cache downloadDependencies testClasses
+          environment:
+            GRADLE_OPTS: -Dorg.gradle.daemon=false -Dorg.gradle.workers.max=3 -Xmx768m
+
+      - save_cache:
+          paths:
+            - ~/.gradle/caches
+            - ~/.gradle/wrapper
+          key: v3-{{ checksum "build.gradle" }}-{{ .Branch }}
+
+  checkjdk8:
+    docker:
+      - image: circleci/openjdk:8u171-jdk
+
+    working_directory: ~/repo
+
+    environment:
+      JVM_OPTS: -Xmx1g
+      TERM: dumb
+
+    steps:
+      - checkout
+
+      - restore_cache:
+          keys:
+            - v3-{{ checksum "build.gradle" }}-{{ .Branch }}
+            - v3-{{ checksum "build.gradle" }}-master
+            - v3-{{ checksum "build.gradle" }}
+
+      - run:
+          name: Run checks
+          command: ./gradlew --parallel --build-cache check -x test
+          environment:
+            GRADLE_OPTS: -Dorg.gradle.daemon=false -Dorg.gradle.workers.max=3 -Xmx1G
+
+      - run:
+          name: Save gradle reports
+          command: |
+            mkdir -p ~/reports/
+            tar cf - */build/reports | (cd ~/reports/; tar xf -)
+          when: always
+
+      - store_artifacts:
+          name: Store gradle reports
+          path: ~/reports
+
+  testjdk8:
+    docker:
+      - image: circleci/openjdk:8u171-jdk
+
+    working_directory: ~/testrepo
+
+    environment:
+      JVM_OPTS: -Xmx1g
+      TERM: dumb
+
+    steps:
+      - checkout
+
+      - restore_cache:
+          keys:
+            - v3-{{ checksum "build.gradle" }}-{{ .Branch }}-testjdk8
+            - v3-{{ checksum "build.gradle" }}-{{ .Branch }}
+            - v3-{{ checksum "build.gradle" }}-master
+            - v3-{{ checksum "build.gradle" }}
+
+      - run:
+          name: test
+          command: ./gradlew --parallel --build-cache test
+          environment:
+            GRADLE_OPTS: -Dorg.gradle.daemon=false -Dorg.gradle.workers.max=3 -Xmx1G
+
+      - save_cache:
+          paths:
+            - ~/.gradle/caches
+            - ~/.gradle/wrapper
+          key: v3-{{ checksum "build.gradle" }}-{{ .Branch }}-testjdk8
+
+      - run:
+          name: Save test results
+          command: |
+            mkdir -p ~/test-results/junit/
+            find . -type f -regex ".*/build/test-results/.*xml" -exec cp {} ~/test-results/junit/ \;
+          when: always
+
+      - store_test_results:
+          name: Store test results
+          path: ~/test-results
+
+      - run:
+          name: Save gradle reports
+          command: |
+            mkdir -p ~/reports/
+            tar cf - */build/reports | (cd ~/reports/; tar xf -)
+          when: always
+
+      - store_artifacts:
+          name: Store gradle reports
+          path: ~/reports
+
+  testjdk11:
+    docker:
+      - image: circleci/openjdk:11.0.2-jdk
+
+    working_directory: ~/testrepo11
+
+    environment:
+      JVM_OPTS: -Xmx1g
+      TERM: dumb
+
+    steps:
+      - checkout
+
+      - restore_cache:
+          keys:
+            - v3-{{ checksum "build.gradle" }}-{{ .Branch }}-testjdk11
+            - v3-{{ checksum "build.gradle" }}-{{ .Branch }}
+            - v3-{{ checksum "build.gradle" }}-master
+            - v3-{{ checksum "build.gradle" }}
+
+      - run:
+          name: test
+          command: ./gradlew --build-cache --parallel test
+          environment:
+            GRADLE_OPTS: -Dorg.gradle.daemon=false -Dorg.gradle.workers.max=3 -Xmx1G
+
+      - save_cache:
+          paths:
+            - ~/.gradle/caches
+            - ~/.gradle/wrapper
+          key: v3-{{ checksum "build.gradle" }}-{{ .Branch }}-testjdk11
+
+      - run:
+          name: Save test results
+          command: |
+            mkdir -p ~/testrepo11/test-results/junit/
+            find . -type f -regex ".*/build/test-results/.*xml" -exec cp {} ~/testrepo11/test-results/junit/ \;
+          when: always
+
+      - store_test_results:
+          name: Store test results
+          path: ~/testrepo11/test-results
+
+      - run:
+          name: Save gradle reports
+          command: |
+            mkdir -p ~/testrepo11/reports/
+            tar cf - */build/reports | (cd ~/testrepo11/reports/; tar xf -)
+          when: always
+
+      - store_artifacts:
+          name: Store gradle reports
+          path: ~/testrepo11/reports
+
+workflows:
+  version: 2
+  build-check-and-test:
+    jobs:
+      - compile
+      - checkjdk8:
+          requires:
+            - compile
+      - testjdk8:
+          requires:
+            - compile
+      - testjdk11:
+          requires:
+            - compile
\ No newline at end of file
diff --git a/.github/CONTRIBUTING.md b/.github/CONTRIBUTING.md
index 0b26b8467b..01431c6e87 100644
--- a/.github/CONTRIBUTING.md
+++ b/.github/CONTRIBUTING.md
@@ -6,10 +6,18 @@ forking the repository and sending a pull request.
 
 When submitting code, please make every effort to follow existing conventions
 and style in order to keep the code as readable as possible. Please also make
-sure your code compiles by running `mvn clean verify`. Checkstyle failures
+sure your code compiles by running `./gradlew check`. Checkstyle failures
 during compilation indicate errors in your style and can be viewed in the
 `checkstyle-result.xml` file.
 
+Some general advice
+
+- Don‚Äôt change public API lightly, avoid if possible, and include your reasoning in the PR if essential.  It causes pain for developers who use OkHttp and sometimes runtime errors.
+- Favour a working external library if appropriate.  There are many examples of OkHttp libraries that can sit on top or hook in via existing APIs.
+- Get working code on a personal branch with tests before you submit a PR.
+- OkHttp is a small and light dependency.  Don't introduce new dependencies or major new functionality.
+- OkHttp targets the intersection of RFC correct *and* widely implemented.  Incorrect implementations that are very widely implemented e.g. a bug in Apache, Nginx, Google, Firefox should also be handled.
+
 Before your code can be accepted into the project you must also sign the
 [Individual Contributor License Agreement (CLA)][1].
 
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
deleted file mode 100644
index e65d371715..0000000000
--- a/.github/ISSUE_TEMPLATE.md
+++ /dev/null
@@ -1,12 +0,0 @@
-What kind of issue is this?
-
- - [ ] Question. This issue tracker is not the place for questions. If you want to ask how to do
-       something, or to understand why something isn't working the way you expect it to, use Stack
-       Overflow. https://stackoverflow.com/questions/tagged/okhttp
-
- - [ ] Bug report. If you‚Äôve found a bug, spend the time to write a failing test. Bugs with tests
-       get fixed. Here‚Äôs an example: https://gist.github.com/swankjesse/981fcae102f513eb13ed
-
- - [ ] Feature Request. Start by telling us what problem you‚Äôre trying to solve. Often a solution
-       already exists! Don‚Äôt send pull requests to implement new features without first getting our
-       support. Sometimes we leave features out on purpose to keep the project small.
diff --git a/.github/ISSUE_TEMPLATE/bug_report.md b/.github/ISSUE_TEMPLATE/bug_report.md
new file mode 100644
index 0000000000..8b276c7dea
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/bug_report.md
@@ -0,0 +1,13 @@
+---
+name: Bug report
+about: A reproducible problem
+title: ''
+labels: bug
+assignees: ''
+
+---
+
+Good bug reports include a failing test! Writing a test helps you to isolate and describe the problem, and it helps us to fix it fast. Bug reports without a failing test or reproduction steps are likely to be closed.
+
+Here‚Äôs an example test to get you started.
+https://gist.github.com/swankjesse/981fcae102f513eb13ed
diff --git a/.github/ISSUE_TEMPLATE/feature_request.md b/.github/ISSUE_TEMPLATE/feature_request.md
new file mode 100644
index 0000000000..e320e37f4a
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/feature_request.md
@@ -0,0 +1,12 @@
+---
+name: Feature request
+about: Suggest an idea
+title: ''
+labels: enhancement
+assignees: ''
+
+---
+
+Start by telling us what problem you‚Äôre trying to solve. Often a solution already exists!
+
+Don‚Äôt send pull requests to implement new features without first getting our support. Sometimes we leave features out on purpose to keep the project small.
diff --git a/.github/ISSUE_TEMPLATE/question.md b/.github/ISSUE_TEMPLATE/question.md
new file mode 100644
index 0000000000..73f2b5c1af
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/question.md
@@ -0,0 +1,16 @@
+---
+name: Question
+about: Use Stack Overflow instead
+title: "\U0001F649"
+labels: ''
+assignees: ''
+
+---
+
+üõë ùôéùôèùôäùôã
+
+This issue tracker is not the place for questions!
+
+If you want to ask how to do something, or to understand why something isn't working the way you expect it to, use Stack Overflow. https://stackoverflow.com/questions/tagged/okhttp
+
+We close all questions without reading them.
diff --git a/.gitignore b/.gitignore
index 226a3f3d65..d2b9133572 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,6 +1,7 @@
 .classpath
 .project
 .settings
+.gradle
 eclipsebin
 
 bin
@@ -8,10 +9,12 @@ gen
 build
 out
 lib
+generated
 
 target
 pom.xml.*
 release.properties
+local.properties
 
 .idea
 *.iml
diff --git a/.travis.yml b/.travis.yml
index 050768bd34..d74b3927c2 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -2,21 +2,19 @@ language: java
 
 jdk:
   - oraclejdk8
+  - openjdk8
+  - openjdk11
 
-addons:
-  apt:
-    packages:
-      - oracle-java8-installer # Updates JDK 8 to the latest available.
-
-script: mvn test javadoc:jar source:jar -B
+script:
+ - ./gradlew check
 
 after_success:
   - .buildscript/deploy_snapshot.sh
 
 env:
   global:
-    - secure: "S0BTJVrF4fUCwhTdmoQY6LYr5r1wgXZ/p8lc5bIgUUsc1Ckalwt7s/GDwPuLJ4702sI5t56Eye2iEIMUjeFJKqebZRsX1C5oYsYFxGi3BGlepstYpmj0gLXuSWqCLniS9zmHXCxLhLkC6KxPVjhDlbq76XQx0o3K1J8oEIj/PCE="
-    - secure: "awV7yLXURjlPbTOladsNDZk74KYCNXoiZpAP0gQFfK4Sc0fc7+kg8z/yhdWXeTxjsIZ6m0dVDHTqnH8ytnydwXpBam8JdQJ+EAWA6R3Svq1BR1bzl/PcZUoz+Xn8lMXdU3yA1p4qtQlUhMxwsE3MOVe24HSDJPAu4XeWFj1j3qo="
+    - secure: "fELrorBJHDz+Xk9iSVMnamu0qC0+pYnFvjnEIcGnmKMMxLI/CIMACghIfSkqZhKAcU3hvxgWzyY8JBMnf5tykUjjOwmubAjZ9qIvwujtrUoUitUkpvVaPtqF0d1Yx0Xq4qt3NB9cOugPR/cPGnoEvSKfND3g+o5ta7KzdjwMBCY="
+    - secure: "WMkcWrsvzJNf48w7DJwipUNbhAoggCkC+NM31esq9/GDceGtVWj4hssQETynG4+ckxr0wGqUxsTRTz0uGhX6Fi58haG8yKp+g/HVClqI5EYjI44ptPcwlqlbYjuGbk65k1OGGZLctA6fQA3uT0zee05/yBjJx/jOqrN+PD1tW38="
 
 branches:
   except:
@@ -27,6 +25,11 @@ notifications:
 
 sudo: false
 
+before_cache:
+  - rm -f  $HOME/.gradle/caches/modules-2/modules-2.lock
+  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/
+
 cache:
   directories:
-    - $HOME/.m2
+    - $HOME/.gradle/caches/
+    - $HOME/.gradle/wrapper/
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 1b59cd0a3e..dec651a30d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,267 @@
 Change Log
 ==========
 
+## Version 3.14.0
+
+_2019-03-14_
+
+ *  **This release deletes the long-deprecated `OkUrlFactory` and `OkApacheClient` APIs.** These
+    facades hide OkHttp's implementation behind another client's API. If you still need this please
+    copy and paste [ObsoleteUrlFactory.java][obsolete_url_factory] or
+    [ObsoleteApacheClient.java][obsolete_apache_client] into your project.
+
+ *  **OkHttp now supports duplex calls over HTTP/2.** With normal HTTP calls the request must finish
+    before the response starts. With duplex, request and response bodies are transmitted
+    simultaneously. This can be used to implement interactive conversations within a single HTTP
+    call.
+
+    Create duplex calls by overriding the new `RequestBody.isDuplex()` method to return true.
+    This simple option dramatically changes the behavior of the request body and of the entire
+    call.
+
+    The `RequestBody.writeTo()` method may now retain a reference to the provided sink and
+    hand it off to another thread to write to it after `writeTo` returns.
+
+    The `EventListener` may now see requests and responses interleaved in ways not previously
+    permitted. For example, a listener may receive `responseHeadersStart()` followed by
+    `requestBodyEnd()`, both on the same call. Such events may be triggered by different threads
+    even for a single call.
+
+    Interceptors that rewrite or replace the request body may now inadvertently interfere with
+    duplex request bodies. Such interceptors should check `RequestBody.isDuplex()` and avoid
+    accessing the request body when it is.
+
+    Duplex calls require HTTP/2. If HTTP/1 is established instead the duplex call will fail. The
+    most common use of duplex calls is [gRPC][grpc_http2].
+
+ *  New: Prevent OkHttp from retransmitting a request body by overriding `RequestBody.isOneShot()`.
+    This is most useful when writing the request body is destructive.
+
+ *  New: We've added `requestFailed()` and `responseFailed()` methods to `EventListener`. These
+    are called instead of `requestBodyEnd()` and `responseBodyEnd()` in some failure situations.
+    They may also be fired in cases where no event was published previously. In this release we did
+    an internal rewrite of our event code to fix problems where events were lost or unbalanced.
+
+ *  Fix: Don't leak a connection when a call is canceled immediately preceding the `onFailure()`
+    callback.
+
+ *  Fix: Apply call timeouts when connecting duplex calls, web sockets, and server-sent events.
+    Once the streams are established no further timeout is enforced.
+
+ *  Fix: Retain the `Route` when a connection is reused on a redirect or other follow-up. This was
+    causing some `Authenticator` calls to see a null route when non-null was expected.
+
+ *  Fix: Use the correct key size in the name of `TLS_AES_128_CCM_8_SHA256` which is a TLS 1.3
+    cipher suite. We accidentally specified a key size of 256, preventing that cipher suite from
+    being selected for any TLS handshakes. We didn't notice because this cipher suite isn't
+    supported on Android, Java, or Conscrypt.
+
+    We removed this cipher suite and `TLS_AES_128_CCM_SHA256` from the restricted, modern, and
+    compatible sets of cipher suites. These two cipher suites aren't enabled by default in either
+    Firefox or Chrome.
+
+    See our [TLS Configuration History][tls_configuration_history] tracker for a log of all changes
+    to OkHttp's default TLS options.
+
+ *  New: Upgrade to Conscrypt 2.0.0. OkHttp works with other versions of Conscrypt but this is the
+    version we're testing against.
+
+    ```kotlin
+    implementation("org.conscrypt:conscrypt-openjdk-uber:2.0.0")
+    ```
+
+ *  New: Update the embedded public suffixes list.
+
+
+## Version 3.12.2
+
+_2019-03-14_
+
+ *  Fix: Don't crash if the HTTPS server returns no certificates in the TLS handshake.
+ *  Fix: Don't leak a connection when a call is canceled immediately preceding the `onFailure()`
+    callback.
+
+
+## Version 3.13.1
+
+_2019-02-05_
+
+ *  Fix: Don't crash when using a custom `X509TrustManager` or `SSLSocket` on Android. When we
+    removed obsolete code for Android 4.4 we inadvertently also removed support for custom
+    subclasses. We've restored that support!
+
+
+## Version 3.13.0
+
+_2019-02-04_
+
+ *  **This release bumps our minimum requirements to Java 8+ or Android 5+.** Cutting off old
+    devices is a serious change and we don't do it lightly! [This post][require_android_5] explains
+    why we're doing this and how to upgrade.
+
+    The OkHttp 3.12.x branch will be our long-term branch for Android 2.3+ (API level 9+) and Java
+    7+. These platforms lack support for TLS 1.2 and should not be used. But because upgrading is
+    difficult we will backport critical fixes to the 3.12.x branch through December 31, 2020.
+
+ *  **TLSv1 and TLSv1.1 are no longer enabled by default.** Major web browsers are working towards
+    removing these versions altogether in early 2020. If your servers aren't ready yet you can
+    configure OkHttp 3.13 to allow TLSv1 and TLSv1.1 connections:
+
+    ```
+    OkHttpClient client = new OkHttpClient.Builder()
+        .connectionSpecs(Arrays.asList(ConnectionSpec.COMPATIBLE_TLS))
+        .build();
+    ```
+
+ *  New: You can now access HTTP trailers with `Response.trailers()`. This method may only be called
+    after the entire HTTP response body has been read.
+
+ *  New: Upgrade to Okio 1.17.3. If you're on Kotlin-friendly Okio 2.x this release requires 2.2.2
+    or newer.
+
+    ```kotlin
+    implementation("com.squareup.okio:okio:1.17.3")
+    ```
+
+ *  Fix: Don't miss cancels when sending HTTP/2 request headers.
+ *  Fix: Don't miss whole operation timeouts when calls redirect.
+ *  Fix: Don't leak connections if web sockets have malformed responses or if `onOpen()` throws.
+ *  Fix: Don't retry when request bodies fail due to `FileNotFoundException`.
+ *  Fix: Don't crash when URLs have IPv4-mapped IPv6 addresses.
+ *  Fix: Don't crash when building `HandshakeCertificates` on Android API 28.
+ *  Fix: Permit multipart file names to contain non-ASCII characters.
+ *  New: API to get MockWebServer's dispatcher.
+ *  New: API to access headers as `java.time.Instant`.
+ *  New: Fail fast if a `SSLSocketFactory` is used as a `SocketFactory`.
+ *  New: Log the TLS handshake in `LoggingEventListener`.
+
+
+## Version 3.12.1
+
+_2018-12-23_
+
+ *  Fix: Remove overlapping `package-info.java`. This caused issues with some build tools.
+
+
+## Version 3.12.0
+
+_2018-11-16_
+
+ *  **OkHttp now supports TLS 1.3.** This requires either Conscrypt or Java 11+.
+
+ *  **Proxy authenticators are now asked for preemptive authentication.** OkHttp will now request
+    authentication credentials before creating TLS tunnels through HTTP proxies (HTTP `CONNECT`).
+    Authenticators should identify preemptive authentications by the presence of a challenge whose
+    scheme is "OkHttp-Preemptive".
+
+ *  **OkHttp now offers full-operation timeouts.** This sets a limit on how long the entire call may
+    take and covers resolving DNS, connecting, writing the request body, server processing, and
+    reading the full response body. If a call requires redirects or retries all must complete within
+    one timeout period.
+
+    Use `OkHttpClient.Builder.callTimeout()` to specify the default duration and `Call.timeout()` to
+    specify the timeout of an individual call.
+
+ *  New: Return values and fields are now non-null unless otherwise annotated.
+ *  New: `LoggingEventListener` makes it easy to get basic visibility into a call's performance.
+    This class is in the `logging-interceptor` artifact.
+ *  New: `Headers.Builder.addUnsafeNonAscii()` allows non-ASCII values to be added without an
+    immediate exception.
+ *  New: Headers can be redacted in `HttpLoggingInterceptor`.
+ *  New: `Headers.Builder` now accepts dates.
+ *  New: OkHttp now accepts `java.time.Duration` for timeouts on Java 8+ and Android 26+.
+ *  New: `Challenge` includes all authentication parameters.
+ *  New: Upgrade to BouncyCastle 1.60, Conscrypt 1.4.0, and Okio 1.15.0. We don't yet require
+    Kotlin-friendly Okio 2.x but OkHttp works fine with that series.
+
+    ```kotlin
+    implementation("org.bouncycastle:bcprov-jdk15on:1.60")
+    implementation("org.conscrypt:conscrypt-openjdk-uber:1.4.0")
+    implementation("com.squareup.okio:okio:1.15.0")
+    ```
+
+ *  Fix: Handle dispatcher executor shutdowns gracefully. When there aren't any threads to carry a
+    call its callback now gets a `RejectedExecutionException`.
+ *  Fix: Don't permanently cache responses with `Cache-Control: immutable`. We misunderstood the
+    original `immutable` proposal!
+ *  Fix: Change `Authenticator`'s `Route` parameter to be nullable. This was marked as non-null but
+    could be called with null in some cases.
+ *  Fix: Don't create malformed URLs when `MockWebServer` is reached via an IPv6 address.
+ *  Fix: Don't crash if the system default authenticator is null.
+ *  Fix: Don't crash generating elliptic curve certificates on Android.
+ *  Fix: Don't crash doing platform detection on RoboVM.
+ *  Fix: Don't leak socket connections when web socket upgrades fail.
+
+
+## Version 3.11.0
+
+_2018-07-12_
+
+ *  **OkHttp's new okhttp-tls submodule tames HTTPS and TLS.**
+
+    `HeldCertificate` is a TLS certificate and its private key. Generate a certificate with its
+    builder then use it to sign another certificate or perform a TLS handshake. The
+    `certificatePem()` method encodes the certificate in the familiar PEM format
+    (`--- BEGIN CERTIFICATE ---`); the `privateKeyPkcs8Pem()` does likewise for the private key.
+
+    `HandshakeCertificates` holds the TLS certificates required for a TLS handshake. On the server
+    it keeps your `HeldCertificate` and its chain. On the client it keeps the root certificates
+    that are trusted to sign a server's certificate chain. `HandshakeCertificates` also works with
+    mutual TLS where these roles are reversed.
+
+    These classes make it possible to enable HTTPS in MockWebServer in [just a few lines of
+    code][https_server_sample].
+
+ *  **OkHttp now supports prior knowledge cleartext HTTP/2.** Enable this by setting
+    `Protocol.H2_PRIOR_KNOWLEDGE` as the lone protocol on an `OkHttpClient.Builder`. This mode
+    only supports `http:` URLs and is best suited in closed environments where HTTPS is
+    inappropriate.
+
+ *  New: `HttpUrl.get(String)` is an alternative to `HttpUrl.parse(String)` that throws an exception
+    when the URL is malformed instead of returning null. Use this to avoid checking for null in
+    situations where the input is known to be well-formed. We've also added `MediaType.get(String)`
+    which is an exception-throwing alternative to `MediaType.parse(String)`.
+ *  New: The `EventListener` API previewed in OkHttp 3.9 has graduated to a stable API. Use this
+    interface to track metrics and monitor HTTP requests' size and duration.
+ *  New: `okhttp-dnsoverhttps` is an experimental API for doing DNS queries over HTTPS. Using HTTPS
+    for DNS offers better security and potentially better performance. This feature is a preview:
+    the API is subject to change.
+ *  New: `okhttp-sse` is an early preview of Server-Sent Events (SSE). This feature is incomplete
+    and is only suitable for experimental use.
+ *  New: MockWebServer now supports client authentication (mutual TLS). Call `requestClientAuth()`
+    to permit an optional client certificate or `requireClientAuth()` to require one.
+ *  New: `RecordedRequest.getHandshake()` returns the HTTPS handshake of a request sent to
+    `MockWebServer`.
+ *  Fix: Honor the `MockResponse` header delay in MockWebServer.
+ *  Fix: Don't release HTTP/2 connections that have multiple canceled calls. We had a bug where
+    canceling calls would cause the shared HTTP/2 connection to be unnecessarily released. This
+    harmed connection reuse.
+ *  Fix: Ensure canceled and discarded HTTP/2 data is not permanently counted against the limited
+    flow control window. We had a few bugs where window size accounting was broken when streams
+    were canceled or reset.
+ *  Fix: Recover gracefully if the TLS session returns an unexpected version (`NONE`) or cipher
+    suite (`SSL_NULL_WITH_NULL_NULL`).
+ *  Fix: Don't change Conscrypt configuration globally. We migrated from a process-wide setting to
+    configuring only OkHttp's TLS sockets.
+ *  Fix: Prefer TLSv1.2 where it is available. On certain older platforms it is necessary to opt-in
+    to TLSv1.2.
+ *  New: `Request.tag()` permits multiple tags. Use a `Class<?>` as a key to identify tags. Note
+    that `tag()` now returns null if the request has no tag. Previously this would return the
+    request itself.
+ *  New: `Headers.Builder.addAll(Headers)`.
+ *  New: `ResponseBody.create(MediaType, ByteString)`.
+ *  New: Embed R8/ProGuard rules in the jar. These will be applied automatically by R8.
+ *  Fix: Release the connection if `Authenticator` throws an exception.
+ *  Fix: Change the declaration of `OkHttpClient.cache()` to return a `@Nullable Cache`. The return
+    value has always been nullable but it wasn't declared properly.
+ *  Fix: Reverse suppression of connect exceptions. When both a call and its retry fail, we now
+    throw the initial exception which is most likely to be actionable.
+ *  Fix: Retain interrupted state when throwing `InterruptedIOException`. A single interrupt should
+    now be sufficient to break out an in-flight OkHttp call.
+ *  Fix: Don't drop a call to `EventListener.callEnd()` when the response body is consumed inside an
+    interceptor.
+
+
 ## Version 3.10.0
 
 _2018-02-24_
@@ -1479,4 +1740,10 @@ Initial release.
  [maven_provided]: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html
  [remove_cbc_ecdsa]: https://developers.google.com/web/updates/2016/12/chrome-56-deprecations#remove_cbc-mode_ecdsa_ciphers_in_tls
  [conscrypt]: https://github.com/google/conscrypt/
- [conscrypt_dependency]: https://github.com/google/conscrypt/#download
\ No newline at end of file
+ [conscrypt_dependency]: https://github.com/google/conscrypt/#download
+ [https_server_sample]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
+ [require_android_5]: https://medium.com/square-corner-blog/okhttp-3-13-requires-android-5-818bb78d07ce
+ [obsolete_apache_client]: https://gist.github.com/swankjesse/09721f72039e3a46cf50f94323deb82d
+ [obsolete_url_factory]: https://gist.github.com/swankjesse/dd91c0a8854e1559b00f5fc9c7bfae70
+ [tls_configuration_history]: https://github.com/square/okhttp/wiki/TLS-Configuration-History
+ [grpc_http2]: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md
diff --git a/README.md b/README.md
index 4576c79e71..6d378a9d5b 100644
--- a/README.md
+++ b/README.md
@@ -1,22 +1,42 @@
 OkHttp
 ======
 
-An HTTP & HTTP/2 client for Android and Java applications. For more information see [the website][1] and [the wiki][2].
+An HTTP & HTTP/2 client for Android and Java applications. For more information see [the
+website][website] and [the wiki][wiki].
+
+
+Requirements
+------------
+
+OkHttp works on Android 5.0+ (API level 21+) and on Java 8+.
+
+OkHttp has one library dependency on [Okio][okio], a small library for high-performance I/O. It
+works with either Okio 1.x (implemented in Java) or Okio 2.x (upgraded to Kotlin).
+
+We highly recommend you keep OkHttp up-to-date. As with auto-updating web browsers, staying current
+with HTTPS clients is an important defense against potential security problems. [We
+track][tls_history] the dynamic TLS ecosystem and adjust OkHttp to improve connectivity and
+security.
+
+OkHttp uses your platform's built-in TLS implementation. On Java platforms OkHttp also supports
+[Conscrypt][conscrypt], which integrates BoringSSL with Java. OkHttp will use Conscrypt if it is
+the first security provider:
+
+```java
+Security.insertProviderAt(Conscrypt.newProvider(), 1);
+```
+
+The OkHttp 3.12.x branch supports Android 2.3+ (API level 9+) and Java 7+. These platforms lack
+support for TLS 1.2 and should not be used. But because upgrading is difficult we will backport
+critical fixes to the [3.12.x branch][okhttp_312x] through December 31, 2020.
 
 Download
 --------
 
-Download [the latest JAR][3] or grab via Maven:
-```xml
-<dependency>
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>okhttp</artifactId>
-  <version>3.10.0</version>
-</dependency>
-```
-or Gradle:
-```groovy
-implementation 'com.squareup.okhttp3:okhttp:3.10.0'
+Download [the latest JAR][okhttp_latest_jar] or configure this dependency:
+
+```kotlin
+implementation("com.squareup.okhttp3:okhttp:3.14.0")
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -31,33 +51,18 @@ MockWebServer coupling with OkHttp is essential for proper testing of HTTP/2 so
 
 ### Download
 
-Download [the latest JAR][4] or grab via Maven:
+Download [the latest JAR][mockwebserver_latest_jar] or configure this dependency:
 ```xml
-<dependency>
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>mockwebserver</artifactId>
-  <version>3.10.0</version>
-  <scope>test</scope>
-</dependency>
-```
-or Gradle:
-```groovy
-testImplementation 'com.squareup.okhttp3:mockwebserver:3.10.0'
+testImplementation("com.squareup.okhttp3:mockwebserver:3.14.0")
 ```
 
-ProGuard
---------
+R8 / ProGuard
+-------------
 
-If you are using ProGuard you might need to add the following options:
+If you are using R8 or ProGuard add the options from [`okhttp3.pro`][okhttp3_pro].
+
+You might also need rules for Okio which is a dependency of this library.
 
-```
--dontwarn okhttp3.**
--dontwarn okio.**
--dontwarn javax.annotation.**
--dontwarn org.conscrypt.**
-# A resource is loaded with a relative path so the package of this class must be preserved.
--keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase
-```
 
 License
 -------
@@ -75,8 +80,13 @@ License
     limitations under the License.
 
 
- [1]: https://square.github.io/okhttp
- [2]: https://github.com/square/okhttp/wiki
- [3]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST
- [4]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=mockwebserver&v=LATEST
+ [conscrypt]: https://github.com/google/conscrypt/
+ [mockwebserver_latest_jar]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=mockwebserver&v=LATEST
+ [okhttp_312x]: https://github.com/square/okhttp/tree/okhttp_3.12.x
+ [okhttp_latest_jar]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST
+ [okio]: https://github.com/square/okio/
  [snap]: https://oss.sonatype.org/content/repositories/snapshots/
+ [tls_history]: https://github.com/square/okhttp/wiki/TLS-Configuration-History
+ [website]: https://square.github.io/okhttp
+ [wiki]: https://github.com/square/okhttp/wiki
+ [okhttp3_pro]: https://github.com/square/okhttp/blob/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
diff --git a/benchmarks/README.md b/benchmarks/README.md
deleted file mode 100644
index ee9be3ff47..0000000000
--- a/benchmarks/README.md
+++ /dev/null
@@ -1,8 +0,0 @@
-OkHttp Benchmarks
-=======================================
-
-This module allows you to test the performance of HTTP clients.
-
-### Running
-  1. If you made modifications to `Benchmark` run `mvn compile`.
-  2. Run `mvn exec:exec` to launch a new JVM, which will execute the benchmark.
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
deleted file mode 100644
index 7bf9ca0289..0000000000
--- a/benchmarks/pom.xml
+++ /dev/null
@@ -1,144 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.11.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>benchmarks</artifactId>
-  <name>Benchmarks</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.google.caliper</groupId>
-      <artifactId>caliper</artifactId>
-      <version>1.0-beta-1</version>
-    </dependency>
-    <!-- caliper needs to be updated to be compatible with guava 16 -->
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <version>14.0.1</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-urlconnection</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>org.bouncycastle</groupId>
-      <artifactId>bcprov-jdk15on</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.httpcomponents</groupId>
-      <artifactId>httpclient</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>io.netty</groupId>
-      <artifactId>netty-transport</artifactId>
-      <version>4.0.15.Final</version>
-    </dependency>
-    <dependency>
-      <groupId>io.netty</groupId>
-      <artifactId>netty-handler</artifactId>
-      <version>4.0.15.Final</version>
-    </dependency>
-    <dependency>
-      <groupId>io.netty</groupId>
-      <artifactId>netty-codec-http</artifactId>
-      <version>4.0.15.Final</version>
-    </dependency>
-    <!-- Netty needs this if gzip is enabled. -->
-    <dependency>
-      <groupId>com.jcraft</groupId>
-      <artifactId>jzlib</artifactId>
-      <version>1.1.2</version>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>exec-maven-plugin</artifactId>
-        <version>1.5.0</version>
-        <executions>
-          <execution>
-            <goals>
-              <goal>java</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <executable>java</executable>
-          <arguments>
-            <argument>-Xms512m</argument>
-            <argument>-Xmx512m</argument>
-            <commandlineArgs>-Xbootclasspath/p:${bootclasspath}</commandlineArgs>
-            <argument>-classpath</argument>
-            <classpath />
-            <argument>okhttp3.benchmarks.Benchmark</argument>
-          </arguments>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-  <profiles>
-    <profile>
-      <id>alpn-when-jdk7</id>
-      <activation>
-        <jdk>1.7</jdk>
-      </activation>
-      <dependencies>
-        <dependency>
-          <groupId>org.mortbay.jetty.alpn</groupId>
-          <artifactId>alpn-boot</artifactId>
-          <version>${alpn.jdk7.version}</version>
-          <scope>provided</scope>
-        </dependency>
-      </dependencies>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8</id>
-      <activation>
-        <jdk>1.8</jdk>
-      </activation>
-      <dependencies>
-        <dependency>
-          <groupId>org.mortbay.jetty.alpn</groupId>
-          <artifactId>alpn-boot</artifactId>
-          <version>${alpn.jdk8.version}</version>
-          <scope>provided</scope>
-        </dependency>
-      </dependencies>
-      <build>
-        <plugins>
-          <plugin>
-            <!-- Fails on caliper's ASM on OpenJDK 8. -->
-            <groupId>org.codehaus.mojo</groupId>
-            <artifactId>animal-sniffer-maven-plugin</artifactId>
-            <version>1.15</version>
-            <executions>
-              <execution>
-                <phase>none</phase>
-              </execution>
-            </executions>
-          </plugin>
-        </plugins>
-      </build>
-    </profile>
-  </profiles>
-</project>
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
deleted file mode 100644
index 6460aaa059..0000000000
--- a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.benchmarks;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.concurrent.TimeUnit;
-import java.util.zip.GZIPInputStream;
-import okhttp3.HttpUrl;
-import okhttp3.mockwebserver.internal.tls.SslClient;
-import org.apache.http.Header;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.conn.ClientConnectionManager;
-import org.apache.http.conn.scheme.Scheme;
-import org.apache.http.conn.ssl.SSLSocketFactory;
-import org.apache.http.impl.client.DefaultHttpClient;
-import org.apache.http.impl.conn.PoolingClientConnectionManager;
-
-/** Benchmark Apache HTTP client. */
-class ApacheHttpClient extends SynchronousHttpClient {
-  private static final boolean VERBOSE = false;
-
-  private HttpClient client;
-
-  @Override public void prepare(Benchmark benchmark) {
-    super.prepare(benchmark);
-    ClientConnectionManager connectionManager = new PoolingClientConnectionManager();
-    if (benchmark.tls) {
-      SslClient sslClient = SslClient.localhost();
-      connectionManager.getSchemeRegistry().register(
-          new Scheme("https", 443, new SSLSocketFactory(sslClient.sslContext)));
-    }
-    client = new DefaultHttpClient(connectionManager);
-  }
-
-  @Override public Runnable request(HttpUrl url) {
-    return new ApacheHttpClientRequest(url);
-  }
-
-  class ApacheHttpClientRequest implements Runnable {
-    private final HttpUrl url;
-
-    ApacheHttpClientRequest(HttpUrl url) {
-      this.url = url;
-    }
-
-    public void run() {
-      long start = System.nanoTime();
-      try {
-        HttpResponse response = client.execute(new HttpGet(url.toString()));
-        InputStream in = response.getEntity().getContent();
-        Header contentEncoding = response.getFirstHeader("Content-Encoding");
-        if (contentEncoding != null && contentEncoding.getValue().equals("gzip")) {
-          in = new GZIPInputStream(in);
-        }
-
-        long total = readAllAndClose(in);
-        long finish = System.nanoTime();
-
-        if (VERBOSE) {
-          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
-              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
-        }
-      } catch (IOException e) {
-        System.out.println("Failed: " + e);
-      }
-    }
-  }
-}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
deleted file mode 100644
index 5ab326cbfc..0000000000
--- a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
+++ /dev/null
@@ -1,216 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.benchmarks;
-
-import com.google.caliper.Param;
-import com.google.caliper.model.ArbitraryMeasurement;
-import com.google.caliper.runner.CaliperMain;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import okhttp3.HttpUrl;
-import okhttp3.Protocol;
-import okhttp3.mockwebserver.internal.tls.SslClient;
-import okhttp3.mockwebserver.Dispatcher;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okio.Buffer;
-import okio.GzipSink;
-
-/**
- * This benchmark is fake, but may be useful for certain relative comparisons. It uses a local
- * connection to a MockWebServer to measure how many identical requests per second can be carried
- * over a fixed number of threads.
- */
-public class Benchmark extends com.google.caliper.Benchmark {
-  private static final int NUM_REPORTS = 10;
-  private static final boolean VERBOSE = false;
-
-  private final Random random = new Random(0);
-
-  /** Which client to run. */
-  @Param
-  Client client;
-
-  /** How many concurrent requests to execute. */
-  @Param({"1", "10"})
-  int concurrencyLevel;
-
-  /** How many requests to enqueue to await threads to execute them. */
-  @Param({"10"})
-  int targetBacklog;
-
-  /** True to use TLS. */
-  // TODO: compare different ciphers?
-  @Param
-  boolean tls;
-
-  /** True to use gzip content-encoding for the response body. */
-  @Param
-  boolean gzip;
-
-  /** Don't combine chunked with HTTP_2; that's not allowed. */
-  @Param
-  boolean chunked;
-
-  /** The size of the HTTP response body, in uncompressed bytes. */
-  @Param({"128", "1048576"})
-  int bodyByteCount;
-
-  /** How many additional headers were included, beyond the built-in ones. */
-  @Param({"0", "20"})
-  int headerCount;
-
-  /** Which ALPN protocols are in use. Only useful with TLS. */
-  List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
-
-  public static void main(String[] args) {
-    List<String> allArgs = new ArrayList<>();
-    allArgs.add("--instrument");
-    allArgs.add("arbitrary");
-    allArgs.addAll(Arrays.asList(args));
-
-    CaliperMain.main(Benchmark.class, allArgs.toArray(new String[allArgs.size()]));
-  }
-
-  @ArbitraryMeasurement(description = "requests per second")
-  public double run() throws Exception {
-    if (VERBOSE) System.out.println(toString());
-    HttpClient httpClient = client.create();
-
-    // Prepare the client & server
-    httpClient.prepare(this);
-    MockWebServer server = startServer();
-    HttpUrl url = server.url("/");
-
-    int requestCount = 0;
-    long reportStart = System.nanoTime();
-    long reportPeriod = TimeUnit.SECONDS.toNanos(1);
-    int reports = 0;
-    double best = 0.0;
-
-    // Run until we've printed enough reports.
-    while (reports < NUM_REPORTS) {
-      // Print a report if we haven't recently.
-      long now = System.nanoTime();
-      double reportDuration = now - reportStart;
-      if (reportDuration > reportPeriod) {
-        double requestsPerSecond = requestCount / reportDuration * TimeUnit.SECONDS.toNanos(1);
-        if (VERBOSE) {
-          System.out.println(String.format("Requests per second: %.1f", requestsPerSecond));
-        }
-        best = Math.max(best, requestsPerSecond);
-        requestCount = 0;
-        reportStart = now;
-        reports++;
-      }
-
-      // Fill the job queue with work.
-      while (httpClient.acceptingJobs()) {
-        httpClient.enqueue(url);
-        requestCount++;
-      }
-
-      // The job queue is full. Take a break.
-      sleep(1);
-    }
-
-    return best;
-  }
-
-  @Override public String toString() {
-    List<Object> modifiers = new ArrayList<>();
-    if (tls) modifiers.add("tls");
-    if (gzip) modifiers.add("gzip");
-    if (chunked) modifiers.add("chunked");
-    modifiers.addAll(protocols);
-
-    return String.format("%s %s\nbodyByteCount=%s headerCount=%s concurrencyLevel=%s",
-        client, modifiers, bodyByteCount, headerCount, concurrencyLevel);
-  }
-
-  private void sleep(int millis) {
-    try {
-      Thread.sleep(millis);
-    } catch (InterruptedException ignored) {
-    }
-  }
-
-  private MockWebServer startServer() throws IOException {
-    Logger.getLogger(MockWebServer.class.getName()).setLevel(Level.WARNING);
-    MockWebServer server = new MockWebServer();
-
-    if (tls) {
-      SslClient sslClient = SslClient.localhost();
-      server.useHttps(sslClient.socketFactory, false);
-      server.setProtocols(protocols);
-    }
-
-    final MockResponse response = newResponse();
-    server.setDispatcher(new Dispatcher() {
-      @Override public MockResponse dispatch(RecordedRequest request) {
-        return response;
-      }
-    });
-
-    server.start();
-    return server;
-  }
-
-  private MockResponse newResponse() throws IOException {
-    byte[] bytes = new byte[bodyByteCount];
-    random.nextBytes(bytes);
-    Buffer body = new Buffer().write(bytes);
-
-    MockResponse result = new MockResponse();
-
-    if (gzip) {
-      Buffer gzipBody = new Buffer();
-      GzipSink gzipSink = new GzipSink(gzipBody);
-      gzipSink.write(body, body.size());
-      gzipSink.close();
-      body = gzipBody;
-      result.addHeader("Content-Encoding: gzip");
-    }
-
-    if (chunked) {
-      result.setChunkedBody(body, 1024);
-    } else {
-      result.setBody(body);
-    }
-
-    for (int i = 0; i < headerCount; i++) {
-      result.addHeader(randomString(12), randomString(20));
-    }
-
-    return result;
-  }
-
-  private String randomString(int length) {
-    String alphabet = "-abcdefghijklmnopqrstuvwxyz";
-    char[] result = new char[length];
-    for (int i = 0; i < length; i++) {
-      result[i] = alphabet.charAt(random.nextInt(alphabet.length()));
-    }
-    return new String(result);
-  }
-}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/Client.java b/benchmarks/src/main/java/okhttp3/benchmarks/Client.java
deleted file mode 100644
index b7c6b3f3b9..0000000000
--- a/benchmarks/src/main/java/okhttp3/benchmarks/Client.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.benchmarks;
-
-enum Client {
-  OkHttp {
-    @Override HttpClient create() {
-      return new OkHttp();
-    }
-  },
-
-  OkHttpAsync {
-    @Override HttpClient create() {
-      return new OkHttpAsync();
-    }
-  },
-
-  Apache {
-    @Override HttpClient create() {
-      return new ApacheHttpClient();
-    }
-  },
-
-  UrlConnection {
-    @Override HttpClient create() {
-      return new UrlConnection();
-    }
-  },
-
-  Netty {
-    @Override HttpClient create() {
-      return new NettyHttpClient();
-    }
-  };
-
-  abstract HttpClient create();
-}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
deleted file mode 100644
index 5186f41833..0000000000
--- a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.benchmarks;
-
-import io.netty.bootstrap.Bootstrap;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.PooledByteBufAllocator;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.ChannelPipeline;
-import io.netty.channel.SimpleChannelInboundHandler;
-import io.netty.channel.nio.NioEventLoopGroup;
-import io.netty.channel.socket.SocketChannel;
-import io.netty.channel.socket.nio.NioSocketChannel;
-import io.netty.handler.codec.http.DefaultFullHttpRequest;
-import io.netty.handler.codec.http.HttpClientCodec;
-import io.netty.handler.codec.http.HttpContent;
-import io.netty.handler.codec.http.HttpContentDecompressor;
-import io.netty.handler.codec.http.HttpHeaders;
-import io.netty.handler.codec.http.HttpMethod;
-import io.netty.handler.codec.http.HttpObject;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpResponse;
-import io.netty.handler.codec.http.HttpVersion;
-import io.netty.handler.codec.http.LastHttpContent;
-import io.netty.handler.ssl.SslHandler;
-import java.util.ArrayDeque;
-import java.util.Deque;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLEngine;
-import okhttp3.HttpUrl;
-import okhttp3.mockwebserver.internal.tls.SslClient;
-
-/** Netty isn't an HTTP client, but it's almost one. */
-class NettyHttpClient implements HttpClient {
-  private static final boolean VERBOSE = false;
-
-  // Guarded by this. Real apps need more capable connection management.
-  private final Deque<HttpChannel> freeChannels = new ArrayDeque<>();
-  private final Deque<HttpUrl> backlog = new ArrayDeque<>();
-
-  private int totalChannels = 0;
-  private int concurrencyLevel;
-  private int targetBacklog;
-  private Bootstrap bootstrap;
-
-  @Override public void prepare(final Benchmark benchmark) {
-    this.concurrencyLevel = benchmark.concurrencyLevel;
-    this.targetBacklog = benchmark.targetBacklog;
-
-    ChannelInitializer<SocketChannel> channelInitializer = new ChannelInitializer<SocketChannel>() {
-      @Override public void initChannel(SocketChannel channel) throws Exception {
-        ChannelPipeline pipeline = channel.pipeline();
-
-        if (benchmark.tls) {
-          SslClient sslClient = SslClient.localhost();
-          SSLEngine engine = sslClient.sslContext.createSSLEngine();
-          engine.setUseClientMode(true);
-          pipeline.addLast("ssl", new SslHandler(engine));
-        }
-
-        pipeline.addLast("codec", new HttpClientCodec());
-        pipeline.addLast("inflater", new HttpContentDecompressor());
-        pipeline.addLast("handler", new HttpChannel(channel));
-      }
-    };
-
-    bootstrap = new Bootstrap();
-    bootstrap.group(new NioEventLoopGroup(concurrencyLevel))
-        .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
-        .channel(NioSocketChannel.class)
-        .handler(channelInitializer);
-  }
-
-  @Override public void enqueue(HttpUrl url) throws Exception {
-    HttpChannel httpChannel = null;
-    synchronized (this) {
-      if (!freeChannels.isEmpty()) {
-        httpChannel = freeChannels.pop();
-      } else if (totalChannels < concurrencyLevel) {
-        totalChannels++; // Create a new channel. (outside of the synchronized block).
-      } else {
-        backlog.add(url); // Enqueue this for later, to be picked up when another request completes.
-        return;
-      }
-    }
-    if (httpChannel == null) {
-      Channel channel = bootstrap.connect(url.host(), url.port())
-          .sync().channel();
-      httpChannel = (HttpChannel) channel.pipeline().last();
-    }
-    httpChannel.sendRequest(url);
-  }
-
-  @Override public synchronized boolean acceptingJobs() {
-    return backlog.size() < targetBacklog || hasFreeChannels();
-  }
-
-  private boolean hasFreeChannels() {
-    int activeChannels = totalChannels - freeChannels.size();
-    return activeChannels < concurrencyLevel;
-  }
-
-  private void release(HttpChannel httpChannel) {
-    HttpUrl url;
-    synchronized (this) {
-      url = backlog.pop();
-      if (url == null) {
-        // There were no URLs in the backlog. Pool this channel for later.
-        freeChannels.push(httpChannel);
-        return;
-      }
-    }
-
-    // We removed a URL from the backlog. Schedule it right away.
-    httpChannel.sendRequest(url);
-  }
-
-  class HttpChannel extends SimpleChannelInboundHandler<HttpObject> {
-    private final SocketChannel channel;
-    byte[] buffer = new byte[1024];
-    int total;
-    long start;
-
-    HttpChannel(SocketChannel channel) {
-      this.channel = channel;
-    }
-
-    private void sendRequest(HttpUrl url) {
-      start = System.nanoTime();
-      total = 0;
-      HttpRequest request = new DefaultFullHttpRequest(
-          HttpVersion.HTTP_1_1, HttpMethod.GET, url.encodedPath());
-      request.headers().set(HttpHeaders.Names.HOST, url.host());
-      request.headers().set(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
-      channel.writeAndFlush(request);
-    }
-
-    @Override protected void channelRead0(
-        ChannelHandlerContext context, HttpObject message) throws Exception {
-      if (message instanceof HttpResponse) {
-        receive((HttpResponse) message);
-      }
-      if (message instanceof HttpContent) {
-        receive((HttpContent) message);
-        if (message instanceof LastHttpContent) {
-          release(this);
-        }
-      }
-    }
-
-    @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
-      super.channelInactive(ctx);
-    }
-
-    void receive(HttpResponse response) {
-      // Don't do anything with headers.
-    }
-
-    void receive(HttpContent content) {
-      // Consume the response body.
-      ByteBuf byteBuf = content.content();
-      for (int toRead; (toRead = byteBuf.readableBytes()) > 0; ) {
-        byteBuf.readBytes(buffer, 0, Math.min(buffer.length, toRead));
-        total += toRead;
-      }
-
-      if (VERBOSE && content instanceof LastHttpContent) {
-        long finish = System.nanoTime();
-        System.out.println(String.format("Transferred % 8d bytes in %4d ms",
-            total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
-      }
-    }
-
-    @Override public void exceptionCaught(ChannelHandlerContext context, Throwable cause) {
-      System.out.println("Failed: " + cause);
-    }
-  }
-}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
deleted file mode 100644
index e97509a67b..0000000000
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.benchmarks;
-
-import java.io.IOException;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Call;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.ResponseBody;
-import okhttp3.mockwebserver.internal.tls.SslClient;
-
-class OkHttp extends SynchronousHttpClient {
-  private static final boolean VERBOSE = false;
-
-  private OkHttpClient client;
-
-  @Override public void prepare(Benchmark benchmark) {
-    super.prepare(benchmark);
-    client = new OkHttpClient.Builder()
-        .protocols(benchmark.protocols)
-        .build();
-
-    if (benchmark.tls) {
-      SslClient sslClient = SslClient.localhost();
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
-      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
-        @Override public boolean verify(String s, SSLSession session) {
-          return true;
-        }
-      };
-      client = new OkHttpClient.Builder()
-          .sslSocketFactory(socketFactory, sslClient.trustManager)
-          .hostnameVerifier(hostnameVerifier)
-          .build();
-    }
-  }
-
-  @Override public Runnable request(HttpUrl url) {
-    Call call = client.newCall(new Request.Builder().url(url).build());
-    return new OkHttpRequest(call);
-  }
-
-  class OkHttpRequest implements Runnable {
-    private final Call call;
-
-    OkHttpRequest(Call call) {
-      this.call = call;
-    }
-
-    public void run() {
-      long start = System.nanoTime();
-      try {
-        ResponseBody body = call.execute().body();
-        long total = readAllAndClose(body.byteStream());
-        long finish = System.nanoTime();
-
-        if (VERBOSE) {
-          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
-              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
-        }
-      } catch (IOException e) {
-        System.out.println("Failed: " + e);
-      }
-    }
-  }
-}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
deleted file mode 100644
index c6bad2ba5f..0000000000
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.benchmarks;
-
-import java.io.IOException;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.Dispatcher;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.mockwebserver.internal.tls.SslClient;
-
-class OkHttpAsync implements HttpClient {
-  private static final boolean VERBOSE = false;
-
-  private final AtomicInteger requestsInFlight = new AtomicInteger();
-
-  private OkHttpClient client;
-  private Callback callback;
-  private int concurrencyLevel;
-  private int targetBacklog;
-
-  @Override public void prepare(final Benchmark benchmark) {
-    concurrencyLevel = benchmark.concurrencyLevel;
-    targetBacklog = benchmark.targetBacklog;
-
-    client = new OkHttpClient.Builder()
-        .protocols(benchmark.protocols)
-        .dispatcher(new Dispatcher(new ThreadPoolExecutor(benchmark.concurrencyLevel,
-            benchmark.concurrencyLevel, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>())))
-        .build();
-
-    if (benchmark.tls) {
-      SslClient sslClient = SslClient.localhost();
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
-      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
-        @Override public boolean verify(String s, SSLSession session) {
-          return true;
-        }
-      };
-      client = client.newBuilder()
-          .sslSocketFactory(socketFactory, sslClient.trustManager)
-          .hostnameVerifier(hostnameVerifier)
-          .build();
-    }
-
-    callback = new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        System.out.println("Failed: " + e);
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        ResponseBody body = response.body();
-        long total = SynchronousHttpClient.readAllAndClose(body.byteStream());
-        long finish = System.nanoTime();
-        if (VERBOSE) {
-          long start = (Long) response.request().tag();
-          System.out.printf("Transferred % 8d bytes in %4d ms%n",
-              total, TimeUnit.NANOSECONDS.toMillis(finish - start));
-        }
-        requestsInFlight.decrementAndGet();
-      }
-    };
-  }
-
-  @Override public void enqueue(HttpUrl url) throws Exception {
-    requestsInFlight.incrementAndGet();
-    client.newCall(new Request.Builder().tag(System.nanoTime()).url(url).build()).enqueue(callback);
-  }
-
-  @Override public synchronized boolean acceptingJobs() {
-    return requestsInFlight.get() < (concurrencyLevel + targetBacklog);
-  }
-}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java
deleted file mode 100644
index 4a17b8693d..0000000000
--- a/benchmarks/src/main/java/okhttp3/benchmarks/SynchronousHttpClient.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.benchmarks;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import okhttp3.HttpUrl;
-
-/** Any HTTP client with a blocking API. */
-abstract class SynchronousHttpClient implements HttpClient {
-  ThreadPoolExecutor executor;
-  int targetBacklog;
-
-  @Override public void prepare(Benchmark benchmark) {
-    this.targetBacklog = benchmark.targetBacklog;
-    executor = new ThreadPoolExecutor(benchmark.concurrencyLevel, benchmark.concurrencyLevel,
-        1, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
-  }
-
-  @Override public void enqueue(HttpUrl url) {
-    executor.execute(request(url));
-  }
-
-  @Override public boolean acceptingJobs() {
-    return executor.getQueue().size() < targetBacklog;
-  }
-
-  static long readAllAndClose(InputStream in) throws IOException {
-    byte[] buffer = new byte[1024];
-    long total = 0;
-    for (int count; (count = in.read(buffer)) != -1; ) {
-      total += count;
-    }
-    in.close();
-    return total;
-  }
-
-  abstract Runnable request(HttpUrl url);
-}
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
deleted file mode 100644
index 7aeb7582ed..0000000000
--- a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.benchmarks;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.util.concurrent.TimeUnit;
-import java.util.zip.GZIPInputStream;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.HttpUrl;
-import okhttp3.mockwebserver.internal.tls.SslClient;
-
-class UrlConnection extends SynchronousHttpClient {
-  private static final boolean VERBOSE = false;
-
-  @Override public void prepare(Benchmark benchmark) {
-    super.prepare(benchmark);
-    if (benchmark.tls) {
-      SslClient sslClient = SslClient.localhost();
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
-      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
-        @Override public boolean verify(String s, SSLSession session) {
-          return true;
-        }
-      };
-      HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);
-      HttpsURLConnection.setDefaultSSLSocketFactory(socketFactory);
-    }
-  }
-
-  @Override public Runnable request(HttpUrl url) {
-    return new UrlConnectionRequest(url);
-  }
-
-  static class UrlConnectionRequest implements Runnable {
-    private final HttpUrl url;
-
-    UrlConnectionRequest(HttpUrl url) {
-      this.url = url;
-    }
-
-    public void run() {
-      long start = System.nanoTime();
-      try {
-        HttpURLConnection urlConnection = (HttpURLConnection) url.url().openConnection();
-        InputStream in = urlConnection.getInputStream();
-        if ("gzip".equals(urlConnection.getHeaderField("Content-Encoding"))) {
-          in = new GZIPInputStream(in);
-        }
-
-        long total = readAllAndClose(in);
-        long finish = System.nanoTime();
-
-        if (VERBOSE) {
-          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
-              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
-        }
-      } catch (IOException e) {
-        System.out.println("Failed: " + e);
-      }
-    }
-  }
-}
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 0000000000..7a51f49eea
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,223 @@
+import net.ltgt.gradle.errorprone.CheckSeverity
+
+buildscript {
+  ext.versions = [
+      'airline': '0.8',
+      'android': '4.1.1.4',
+      'animalSniffer': '1.17',
+      'assertj': '3.11.0',
+      'bouncycastle': '1.60',
+      'checkstyle': '8.15',
+      'conscrypt': '2.0.0',
+      'findbugs': '3.0.2',
+      'guava': '27.0.1-jre',
+      'java': '1.8',
+      'jnrUnixsocket': '0.22',
+      'jsoup': '1.11.3',
+      'junit': '4.12',
+      'kotlin': '1.3.20',
+      'moshi': '1.8.0',
+      'okio': '2.2.2',
+  ]
+
+  ext.deps = [
+      'airline': "io.airlift:airline:${versions.airline}",
+      'android': "com.google.android:android:${versions.android}",
+      'animalSniffer': "org.codehaus.mojo:animal-sniffer-annotations:${versions.animalSniffer}",
+      'assertj': "org.assertj:assertj-core:${versions.assertj}",
+      'bouncycastle': "org.bouncycastle:bcprov-jdk15on:${versions.bouncycastle}",
+      'conscrypt': "org.conscrypt:conscrypt-openjdk-uber:${versions.conscrypt}",
+      'guava': "com.google.guava:guava:${versions.guava}",
+      'jnrUnixsocket': "com.github.jnr:jnr-unixsocket:${versions.jnrUnixsocket}",
+      'jsoup': "org.jsoup:jsoup:${versions.jsoup}",
+      'jsr305': "com.google.code.findbugs:jsr305:${versions.findbugs}",
+      'junit': "junit:junit:${versions.junit}",
+      'kotlinStdlib': "org.jetbrains.kotlin:kotlin-stdlib:${versions.kotlin}",
+      'moshi': "com.squareup.moshi:moshi:${versions.moshi}",
+      'okio': "com.squareup.okio:okio:${versions.okio}"
+  ]
+
+  dependencies {
+    // TODO(jwilson): configure maven-publish-plugin to limit which artifacts are published.
+    classpath 'com.vanniktech:gradle-maven-publish-plugin:0.8.0'
+    classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.7.1'
+    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:${versions.kotlin}"
+    classpath "org.jetbrains.dokka:dokka-gradle-plugin:0.9.18"
+  }
+
+  repositories {
+    mavenCentral()
+    gradlePluginPortal()
+  }
+}
+
+plugins {
+  id 'ru.vyarus.animalsniffer' version '1.5.0'
+  id 'com.github.johnrengelman.shadow' version '4.0.1'
+  id 'me.champeau.gradle.japicmp' version '0.2.6'
+}
+
+allprojects {
+  group = GROUP
+  version = VERSION_NAME
+
+  repositories {
+    mavenCentral()
+    maven {
+      url 'https://dl.bintray.com/kotlin/dokka'
+    }
+  }
+
+  task downloadDependencies() {
+    description 'Download all dependencies to the Gradle cache'
+    doLast {
+      configurations.findAll { it.canBeResolved }.files
+    }
+  }
+}
+
+subprojects { project ->
+  apply plugin: 'java'
+  apply plugin: 'java-library'
+  apply plugin: 'org.jetbrains.kotlin.platform.jvm'
+  sourceCompatibility = JavaVersion.VERSION_1_8
+  targetCompatibility = JavaVersion.VERSION_1_8
+
+  apply plugin: 'checkstyle'
+  checkstyleMain.exclude '**/CipherSuite.java'
+  afterEvaluate {
+    checkstyle {
+      configFile = rootProject.file('checkstyle.xml')
+      toolVersion "${versions.checkstyle}"
+      sourceSets = [project.sourceSets.main]
+    }
+  }
+
+  // Animal Sniffer confirms we don't use APIs not on both Java 8 and Android 5.
+  apply plugin: 'ru.vyarus.animalsniffer'
+  animalsniffer {
+    sourceSets = [sourceSets.main]
+  }
+  dependencies {
+    signature 'net.sf.androidscents.signature:android-api-level-21:5.0.1_r2@signature'
+    signature 'org.codehaus.mojo.signature:java18:1.0@signature'
+  }
+
+  test {
+    jvmArgs += "-Dlistener=okhttp3.testing.InstallUncaughtExceptionHandlerListener"
+    jvmArgs += "-Dokhttp.platform=platform"
+
+    testLogging {
+      exceptionFormat = 'full'
+    }
+  }
+
+  // Add alpn-boot on Java 8 so we can use HTTP/2 without a stable API.
+  def alpnBootVersion = alpnBootVersion()
+  if (alpnBootVersion != null) {
+    dependencies {
+      testCompile "org.mortbay.jetty.alpn:alpn-boot:$alpnBootVersion"
+    }
+    def alpnBootJar = configurations.testCompile.find { it.name.startsWith("alpn-boot-") }
+    test {
+      jvmArgs += "-Xbootclasspath/p:${alpnBootJar}"
+    }
+  }
+
+  apply plugin: 'net.ltgt.errorprone'
+  dependencies {
+    errorproneJavac 'com.google.errorprone:javac:9+181-r4173-1'
+    errorprone 'com.google.errorprone:error_prone_core:2.3.3'
+  }
+  tasks.withType(JavaCompile).configureEach {
+    options.errorprone {
+      check("MissingOverride", CheckSeverity.ERROR)
+    }
+  }
+
+  apply plugin: 'org.jetbrains.dokka'
+  dokka {
+    reportUndocumented = false 
+    skipDeprecated = true
+    jdkVersion = 8
+    packageOptions {
+      prefix = "okhttp3.internal"
+      suppress = true
+    }
+    if (project.file('Module.md').exists()) {
+      includes = ['Module.md']
+    }
+    externalDocumentationLink {
+      url = new URL("https://square.github.io/okio/2.x/okio/jvm/index.html")
+      packageListUrl = new URL("https://square.github.io/okio/2.x/okio/jvm/package-list")
+    }
+  }
+}
+
+tasks.wrapper {
+  distributionType = Wrapper.DistributionType.ALL
+}
+
+/**
+ * Returns the alpn-boot version specific to this OpenJDK 8 JVM, or null if this is not a Java 8 VM.
+ * https://github.com/xjdr/xio/blob/master/alpn-boot.gradle
+ */
+def alpnBootVersion() {
+  def javaVersion = System.getProperty("java.version")
+  def patchVersionMatcher = (javaVersion =~ /1\.8\.0_(\d+)(-.*)?/)
+  if (!patchVersionMatcher.find()) return null
+  def patchVersion = Integer.parseInt(patchVersionMatcher.group(1))
+  return alpnBootVersionForPatchVersion(javaVersion, patchVersion)
+}
+
+def alpnBootVersionForPatchVersion(String javaVersion, int patchVersion) {
+  switch (patchVersion) {
+    case 0..24:
+      return '8.1.0.v20141016'
+    case 25..30:
+      return '8.1.2.v20141202'
+    case 31..50:
+      return '8.1.3.v20150130'
+    case 51..59:
+      return '8.1.4.v20150727'
+    case 60..64:
+      return '8.1.5.v20150921'
+    case 65..70:
+      return '8.1.6.v20151105'
+    case 71..77:
+      return '8.1.7.v20160121'
+    case 78..101:
+      return '8.1.8.v20160420'
+    case 102..111:
+      return '8.1.9.v20160720'
+    case 112..120:
+      return '8.1.10.v20161026'
+    case 121..160:
+      return '8.1.11.v20170118'
+    case 161..181:
+      return '8.1.12.v20180117'
+    case 191..202:
+      return '8.1.13.v20181017'
+    default:
+      throw new IllegalStateException("Unexpected Java version: ${javaVersion}")
+  }
+}
+
+/**
+ * Returns a .jar file for the golden version of this project.
+ * https://github.com/Visistema/Groovy1/blob/ba5eb9b2f19ca0cc8927359ce414c4e1974b7016/gradle/binarycompatibility.gradle#L48
+ */
+ext.baselineJar = { project, version ->
+  def group = project.property("GROUP")
+  def artifactId = project.property("POM_ARTIFACT_ID")
+  try {
+    String jarFile = "$artifactId-${version}.jar"
+    project.group = 'virtual_group_for_japicmp' // Prevent it from resolving the current version.
+    def dependency = project.dependencies.create("$group:$artifactId:$version@jar")
+    return project.configurations.detachedConfiguration(dependency).files
+        .find { (it.name == jarFile) }
+  } finally {
+    project.group = group
+  }
+}
+ext.baselineVersion = "3.14.0"
diff --git a/checkstyle.xml b/checkstyle.xml
index 1e4d8e6d1d..f66aad53f8 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -28,8 +28,6 @@
   </module>
 
   <module name="TreeWalker">
-    <property name="cacheFile" value="${checkstyle.cache.file}"/>
-
     <!-- Checks for Javadoc comments.                     -->
     <!-- See http://checkstyle.sf.net/config_javadoc.html -->
     <!--module name="JavadocMethod"/-->
diff --git a/okhttp-tests/fuzzingserver-config.json b/fuzzing/fuzzingserver-config.json
similarity index 100%
rename from okhttp-tests/fuzzingserver-config.json
rename to fuzzing/fuzzingserver-config.json
diff --git a/okhttp-tests/fuzzingserver-expected.txt b/fuzzing/fuzzingserver-expected.txt
similarity index 100%
rename from okhttp-tests/fuzzingserver-expected.txt
rename to fuzzing/fuzzingserver-expected.txt
diff --git a/okhttp-tests/fuzzingserver-test.sh b/fuzzing/fuzzingserver-test.sh
similarity index 100%
rename from okhttp-tests/fuzzingserver-test.sh
rename to fuzzing/fuzzingserver-test.sh
diff --git a/okhttp-tests/fuzzingserver-update-expected.sh b/fuzzing/fuzzingserver-update-expected.sh
similarity index 100%
rename from okhttp-tests/fuzzingserver-update-expected.sh
rename to fuzzing/fuzzingserver-update-expected.sh
diff --git a/gradle.properties b/gradle.properties
new file mode 100644
index 0000000000..7c006bc8bb
--- /dev/null
+++ b/gradle.properties
@@ -0,0 +1,16 @@
+org.gradle.jvmargs='-Dfile.encoding=UTF-8'
+
+GROUP=com.squareup.okhttp3
+VERSION_NAME=4.0.0-SNAPSHOT
+
+POM_URL=https://github.com/square/okhttp
+POM_SCM_URL=https://github.com/square/okhttp
+POM_SCM_CONNECTION=scm:git:https://github.com/square/okhttp.git
+POM_SCM_DEV_CONNECTION=scm:git:ssh://git@github.com/square/okhttp.git
+
+POM_LICENCE_NAME=The Apache Software License, Version 2.0
+POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
+POM_LICENCE_DIST=repo
+
+POM_DEVELOPER_ID=square
+POM_DEVELOPER_NAME=Square, Inc.
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..5c2d1cf016
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000000..b8a51fe209
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,5 @@
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.3-all.zip
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
diff --git a/gradlew b/gradlew
new file mode 100755
index 0000000000..b0d6d0ab5d
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,188 @@
+#!/usr/bin/env sh
+
+#
+# Copyright 2015 the original author or authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn () {
+    echo "$*"
+}
+
+die () {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+nonstop=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
+esac
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
+}
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
+
+exec "$JAVACMD" "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
index 0000000000..15e1ee37a7
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,100 @@
+@rem
+@rem Copyright 2015 the original author or authors.
+@rem
+@rem Licensed under the Apache License, Version 2.0 (the "License");
+@rem you may not use this file except in compliance with the License.
+@rem You may obtain a copy of the License at
+@rem
+@rem      http://www.apache.org/licenses/LICENSE-2.0
+@rem
+@rem Unless required by applicable law or agreed to in writing, software
+@rem distributed under the License is distributed on an "AS IS" BASIS,
+@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@rem See the License for the specific language governing permissions and
+@rem limitations under the License.
+@rem
+
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windows variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/mockwebserver/Module.md b/mockwebserver/Module.md
new file mode 100644
index 0000000000..8493a4c347
--- /dev/null
+++ b/mockwebserver/Module.md
@@ -0,0 +1,3 @@
+# Module mockwebserver
+
+A scriptable web server for testing HTTP clients.
diff --git a/mockwebserver/build.gradle b/mockwebserver/build.gradle
new file mode 100644
index 0000000000..cf385ae85c
--- /dev/null
+++ b/mockwebserver/build.gradle
@@ -0,0 +1,28 @@
+apply plugin: 'com.vanniktech.maven.publish'
+
+jar {
+  manifest {
+    attributes('Automatic-Module-Name': 'okhttp3.mockwebserver')
+  }
+}
+
+dependencies {
+  api project(':okhttp')
+  api deps.junit
+
+  testImplementation project(':okhttp-testing-support')
+  testImplementation project(':okhttp-tls')
+  testImplementation deps.assertj
+}
+
+apply plugin: 'me.champeau.gradle.japicmp'
+task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
+  oldClasspath = files(baselineJar(project, baselineVersion))
+  newClasspath = files(jar.archivePath)
+  onlyBinaryIncompatibleModified = true
+  failOnModification = true
+  txtOutputFile = file("$buildDir/reports/japi.txt")
+  ignoreMissingClasses = true
+  includeSynthetic = true
+}
+check.dependsOn(japicmp)
diff --git a/mockwebserver/gradle.properties b/mockwebserver/gradle.properties
new file mode 100644
index 0000000000..640fcdf3d5
--- /dev/null
+++ b/mockwebserver/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=mockwebserver
+POM_NAME=mockwebserver
+POM_PACKAGING=jar
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
deleted file mode 100644
index a80b23ba5a..0000000000
--- a/mockwebserver/pom.xml
+++ /dev/null
@@ -1,82 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.11.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>mockwebserver</artifactId>
-  <name>MockWebServer</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.bouncycastle</groupId>
-      <artifactId>bcprov-jdk15on</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.10.4</version>
-        <configuration>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-            <link>http://square.github.io/okio/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <version>3.0.0</version>
-        <configuration>
-          <descriptorRefs>
-            <descriptorRef>jar-with-dependencies</descriptorRef>
-          </descriptorRefs>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>single</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.mockwebserver</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java b/mockwebserver/src/main/java/okhttp3/internal/duplex/MwsDuplexAccess.java
similarity index 55%
rename from okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
rename to mockwebserver/src/main/java/okhttp3/internal/duplex/MwsDuplexAccess.java
index d52cb0133d..d1eea00397 100644
--- a/okhttp-android-support/src/main/java/okhttp3/OkCacheContainer.java
+++ b/mockwebserver/src/main/java/okhttp3/internal/duplex/MwsDuplexAccess.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
+ * Copyright (C) 2018 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,12 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3;
+package okhttp3.internal.duplex;
+
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
 
 /**
- * An interface that allows OkHttp to detect that a {@link java.net.ResponseCache} contains a {@link
- * Cache}.
+ * Internal access to MockWebServer APIs. Don't use this, don't use internal, these APIs are not
+ * stable.
  */
-public interface OkCacheContainer {
-  Cache getCache();
+public abstract class MwsDuplexAccess {
+  public static MwsDuplexAccess instance;
+
+  public abstract void setBody(MockResponse mockResponse, DuplexResponseBody duplexResponseBody);
 }
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
index 36457229ed..51aba7624c 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
@@ -20,8 +20,9 @@
 import java.util.concurrent.TimeUnit;
 import okhttp3.Headers;
 import okhttp3.WebSocketListener;
-import okhttp3.internal.Internal;
+import okhttp3.internal.InternalKtKt;
 import okhttp3.internal.http2.Settings;
+import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
 import okio.Buffer;
 
 /** A scripted response to be replayed by the mock web server. */
@@ -30,6 +31,7 @@
 
   private String status;
   private Headers.Builder headers = new Headers.Builder();
+  private Headers.Builder trailers = new Headers.Builder();
 
   private Buffer body;
 
@@ -49,6 +51,7 @@
   private List<PushPromise> promises = new ArrayList<>();
   private Settings settings;
   private WebSocketListener webSocketListener;
+  private DuplexResponseBody duplexResponseBody;
 
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
@@ -98,6 +101,10 @@ public Headers getHeaders() {
     return headers.build();
   }
 
+  public Headers getTrailers() {
+    return trailers.build();
+  }
+
   /**
    * Removes all HTTP headers including any "Content-Length" and "Transfer-encoding" headers that
    * were added by default.
@@ -131,7 +138,7 @@ public MockResponse addHeader(String name, Object value) {
    * value.
    */
   public MockResponse addHeaderLenient(String name, Object value) {
-    Internal.instance.addLenient(headers, name, String.valueOf(value));
+    InternalKtKt.addHeaderLenient(headers, name, String.valueOf(value));
     return this;
   }
 
@@ -143,18 +150,32 @@ public MockResponse setHeader(String name, Object value) {
     return addHeader(name, value);
   }
 
-  /** Replaces all headers with those specified in {@code headers}. */
+  /** Replaces all headers with those specified. */
   public MockResponse setHeaders(Headers headers) {
     this.headers = headers.newBuilder();
     return this;
   }
 
+  /** Replaces all trailers with those specified. */
+  public MockResponse setTrailers(Headers trailers) {
+    this.trailers = trailers.newBuilder();
+    return this;
+  }
+
   /** Removes all headers named {@code name}. */
   public MockResponse removeHeader(String name) {
     headers.removeAll(name);
     return this;
   }
 
+  boolean isDuplex() {
+    return duplexResponseBody != null;
+  }
+
+  DuplexResponseBody getDuplexResponseBody() {
+    return duplexResponseBody;
+  }
+
   /** Returns a copy of the raw HTTP payload. */
   public Buffer getBody() {
     return body != null ? body.clone() : null;
@@ -171,6 +192,11 @@ public MockResponse setBody(String body) {
     return setBody(new Buffer().writeUtf8(body));
   }
 
+  MockResponse setBody(DuplexResponseBody duplexResponseBody) {
+    this.duplexResponseBody = duplexResponseBody;
+    return this;
+  }
+
   /**
    * Sets the response body to {@code body}, chunked every {@code maxChunkSize} bytes.
    */
@@ -186,7 +212,7 @@ public MockResponse setChunkedBody(Buffer body, int maxChunkSize) {
       bytesOut.write(body, chunkSize);
       bytesOut.writeUtf8("\r\n");
     }
-    bytesOut.writeUtf8("0\r\n\r\n"); // Last chunk + empty trailer + CRLF.
+    bytesOut.writeUtf8("0\r\n"); // Last chunk. Trailers follow!
 
     this.body = bytesOut;
     return this;
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 435d4e0984..4ff215096b 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -19,7 +19,6 @@
 
 import java.io.Closeable;
 import java.io.IOException;
-import java.io.InterruptedIOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.ProtocolException;
@@ -60,6 +59,7 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Util;
+import okhttp3.internal.duplex.MwsDuplexAccess;
 import okhttp3.internal.http.HttpMethod;
 import okhttp3.internal.http2.ErrorCode;
 import okhttp3.internal.http2.Header;
@@ -69,6 +69,7 @@
 import okhttp3.internal.platform.Platform;
 import okhttp3.internal.ws.RealWebSocket;
 import okhttp3.internal.ws.WebSocketProtocol;
+import okhttp3.mockwebserver.internal.duplex.DuplexResponseBody;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -78,6 +79,7 @@
 import okio.Timeout;
 import org.junit.rules.ExternalResource;
 
+import static okhttp3.internal.InternalKtKt.addHeaderLenient;
 import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.mockwebserver.SocketPolicy.CONTINUE_ALWAYS;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
@@ -91,6 +93,7 @@
 import static okhttp3.mockwebserver.SocketPolicy.RESET_STREAM_AT_START;
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE;
 import static okhttp3.mockwebserver.SocketPolicy.STALL_SOCKET_AT_START;
 import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
 
@@ -101,8 +104,18 @@
 public final class MockWebServer extends ExternalResource implements Closeable {
   static {
     Internal.initializeInstanceForTests();
+    MwsDuplexAccess.instance = new MwsDuplexAccess() {
+      @Override public void setBody(
+          MockResponse mockResponse, DuplexResponseBody duplexResponseBody) {
+        mockResponse.setBody(duplexResponseBody);
+      }
+    };
   }
 
+  private static final int CLIENT_AUTH_NONE = 0;
+  private static final int CLIENT_AUTH_REQUESTED = 1;
+  private static final int CLIENT_AUTH_REQUIRED = 2;
+
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
     @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
         throws CertificateException {
@@ -123,16 +136,17 @@
   private final BlockingQueue<RecordedRequest> requestQueue = new LinkedBlockingQueue<>();
 
   private final Set<Socket> openClientSockets =
-      Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
+      Collections.newSetFromMap(new ConcurrentHashMap<>());
   private final Set<Http2Connection> openConnections =
-      Collections.newSetFromMap(new ConcurrentHashMap<Http2Connection, Boolean>());
+      Collections.newSetFromMap(new ConcurrentHashMap<>());
   private final AtomicInteger requestCount = new AtomicInteger();
   private long bodyLimit = Long.MAX_VALUE;
-  private ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
+  private ServerSocketFactory serverSocketFactory;
   private ServerSocket serverSocket;
   private SSLSocketFactory sslSocketFactory;
   private ExecutorService executor;
   private boolean tunnelProxy;
+  private int clientAuth = CLIENT_AUTH_NONE;
   private Dispatcher dispatcher = new QueueDispatcher();
 
   private int port = -1;
@@ -214,11 +228,12 @@ public void setProtocolNegotiationEnabled(boolean protocolNegotiationEnabled) {
    */
   public void setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
-    if (protocols.contains(Protocol.H2C) && protocols.size() > 1) {
-      // when using h2c prior knowledge, no other protocol should be supported.
-      throw new IllegalArgumentException("protocols containing h2c cannot use other protocols: "
-              + protocols);
-    } else if (!protocols.contains(Protocol.H2C) && !protocols.contains(Protocol.HTTP_1_1)) {
+    if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
+      // when using h2_prior_knowledge, no other protocol should be supported.
+      throw new IllegalArgumentException(
+          "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
+    } else if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
+        && !protocols.contains(Protocol.HTTP_1_1)) {
       throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
     }
     if (protocols.contains(null)) {
@@ -241,6 +256,36 @@ public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
     this.tunnelProxy = tunnelProxy;
   }
 
+  /**
+   * Configure the server to not perform SSL authentication of the client. This leaves
+   * authentication to another layer such as in an HTTP cookie or header. This is the default and
+   * most common configuration.
+   */
+  public void noClientAuth() {
+    this.clientAuth = CLIENT_AUTH_NONE;
+  }
+
+  /**
+   * Configure the server to {@linkplain SSLSocket#setWantClientAuth want client auth}. If the
+   * client presents a certificate that is {@linkplain TrustManager trusted} the handshake will
+   * proceed normally. The connection will also proceed normally if the client presents no
+   * certificate at all! But if the client presents an untrusted certificate the handshake will fail
+   * and no connection will be established.
+   */
+  public void requestClientAuth() {
+    this.clientAuth = CLIENT_AUTH_REQUESTED;
+  }
+
+  /**
+   * Configure the server to {@linkplain SSLSocket#setNeedClientAuth need client auth}. If the
+   * client presents a certificate that is {@linkplain TrustManager trusted} the handshake will
+   * proceed normally. If the client presents an untrusted certificate or no certificate at all the
+   * handshake will fail and no connection will be established.
+   */
+  public void requireClientAuth() {
+    this.clientAuth = CLIENT_AUTH_REQUIRED;
+  }
+
   /**
    * Awaits the next HTTP request, removes it, and returns it. Callers should use this to verify the
    * request was sent as intended. This method will block until the request is available, possibly
@@ -322,7 +367,12 @@ private synchronized void start(InetSocketAddress inetSocketAddress) throws IOEx
 
     executor = Executors.newCachedThreadPool(Util.threadFactory("MockWebServer", false));
     this.inetSocketAddress = inetSocketAddress;
+
+    if (serverSocketFactory == null) {
+      serverSocketFactory = ServerSocketFactory.getDefault();
+    }
     serverSocket = serverSocketFactory.createServerSocket();
+
     // Reuse if the user specified a port
     serverSocket.setReuseAddress(inetSocketAddress.getPort() != 0);
     serverSocket.bind(inetSocketAddress, 50);
@@ -431,6 +481,11 @@ public void processConnection() throws Exception {
               raw.getPort(), true);
           SSLSocket sslSocket = (SSLSocket) socket;
           sslSocket.setUseClientMode(false);
+          if (clientAuth == CLIENT_AUTH_REQUIRED) {
+            sslSocket.setNeedClientAuth(true);
+          } else if (clientAuth == CLIENT_AUTH_REQUESTED) {
+            sslSocket.setWantClientAuth(true);
+          }
           openClientSockets.add(socket);
 
           if (protocolNegotiationEnabled) {
@@ -442,11 +497,12 @@ public void processConnection() throws Exception {
           if (protocolNegotiationEnabled) {
             String protocolString = Platform.get().getSelectedProtocol(sslSocket);
             protocol = protocolString != null ? Protocol.get(protocolString) : Protocol.HTTP_1_1;
+            Platform.get().afterHandshake(sslSocket);
           }
           openClientSockets.remove(raw);
-        } else if (protocols.contains(Protocol.H2C)) {
+        } else if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
           socket = raw;
-          protocol = Protocol.H2C;
+          protocol = Protocol.H2_PRIOR_KNOWLEDGE;
         } else {
           socket = raw;
         }
@@ -455,7 +511,7 @@ public void processConnection() throws Exception {
           return; // Ignore the socket until the server is shut down!
         }
 
-        if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2C) {
+        if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
           Http2SocketHandler http2SocketHandler = new Http2SocketHandler(socket, protocol);
           Http2Connection connection = new Http2Connection.Builder(false)
               .socket(socket)
@@ -549,6 +605,8 @@ private boolean processOneRequest(Socket socket, BufferedSource source, Buffered
           socket.shutdownInput();
         } else if (response.getSocketPolicy() == SHUTDOWN_OUTPUT_AT_END) {
           socket.shutdownOutput();
+        } else if (response.getSocketPolicy() == SHUTDOWN_SERVER_AFTER_RESPONSE) {
+          shutdown();
         }
 
         sequenceNumber++;
@@ -599,7 +657,7 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
     boolean expectContinue = false;
     String header;
     while ((header = source.readUtf8LineStrict()).length() != 0) {
-      Internal.instance.addLenient(headers, header);
+      addHeaderLenient(headers, header);
       String lowercaseHeader = header.toLowerCase(Locale.US);
       if (contentLength == -1 && lowercaseHeader.startsWith("content-length:")) {
         contentLength = Long.parseLong(header.substring(15).trim());
@@ -691,7 +749,8 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
       // Even if messages are no longer being read we need to wait for the connection close signal.
       try {
         connectionClose.await();
-      } catch (InterruptedException ignored) {
+      } catch (InterruptedException e) {
+        throw new AssertionError(e);
       }
 
     } catch (IOException e) {
@@ -703,11 +762,23 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
 
   private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse response)
       throws IOException {
-    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
+    sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS));
     sink.writeUtf8(response.getStatus());
     sink.writeUtf8("\r\n");
 
-    Headers headers = response.getHeaders();
+    writeHeaders(sink, response.getHeaders());
+
+    Buffer body = response.getBody();
+    if (body == null) return;
+    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
+    throttledTransfer(response, socket, body, sink, body.size(), false);
+
+    if ("chunked".equalsIgnoreCase(response.getHeaders().get("Transfer-Encoding"))) {
+      writeHeaders(sink, response.getTrailers());
+    }
+  }
+
+  private void writeHeaders(BufferedSink sink, Headers headers) throws IOException {
     for (int i = 0, size = headers.size(); i < size; i++) {
       sink.writeUtf8(headers.name(i));
       sink.writeUtf8(": ");
@@ -716,11 +787,6 @@ private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse re
     }
     sink.writeUtf8("\r\n");
     sink.flush();
-
-    Buffer body = response.getBody();
-    if (body == null) return;
-    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
-    throttledTransfer(response, socket, body, sink, body.size(), false);
   }
 
   private void sleepIfDelayed(long delayMs) {
@@ -780,7 +846,7 @@ private void throttledTransfer(MockResponse policy, Socket socket, BufferedSourc
         try {
           Thread.sleep(periodDelayMs);
         } catch (InterruptedException e) {
-          throw new AssertionError();
+          throw new AssertionError(e);
         }
       }
     }
@@ -791,6 +857,14 @@ private void readEmptyLine(BufferedSource source) throws IOException {
     if (line.length() != 0) throw new IllegalStateException("Expected empty but was: " + line);
   }
 
+  /**
+   * Returns the dispatcher used to respond to HTTP requests. The default dispatcher is a {@link
+   * QueueDispatcher} but other dispatchers can be configured.
+   */
+  public Dispatcher getDispatcher() {
+    return dispatcher;
+  }
+
   /**
    * Sets the dispatcher used to match incoming requests to mock responses. The default dispatcher
    * simply serves a fixed sequence of responses from a {@link #enqueue(MockResponse) queue}; custom
@@ -859,10 +933,10 @@ private Http2SocketHandler(Socket socket, Protocol protocol) {
       if (peekedResponse.getSocketPolicy() == RESET_STREAM_AT_START) {
         try {
           dispatchBookkeepingRequest(sequenceNumber.getAndIncrement(), socket);
-          stream.close(ErrorCode.fromHttp2(peekedResponse.getHttp2ErrorCode()));
+          stream.close(ErrorCode.fromHttp2(peekedResponse.getHttp2ErrorCode()), null);
           return;
         } catch (InterruptedException e) {
-          throw new InterruptedIOException();
+          throw new AssertionError(e);
         }
       }
 
@@ -880,7 +954,7 @@ private Http2SocketHandler(Socket socket, Protocol protocol) {
         socket.close();
         return;
       }
-      writeResponse(stream, response);
+      writeResponse(stream, request, response);
       if (logger.isLoggable(Level.INFO)) {
         logger.info(MockWebServer.this + " received request: " + request
             + " and responded: " + response + " protocol is " + protocol.toString());
@@ -893,24 +967,24 @@ private Http2SocketHandler(Socket socket, Protocol protocol) {
     }
 
     private RecordedRequest readRequest(Http2Stream stream) throws IOException {
-      List<Header> streamHeaders = stream.getRequestHeaders();
+      Headers streamHeaders = stream.takeHeaders();
       Headers.Builder httpHeaders = new Headers.Builder();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
       boolean readBody = true;
       for (int i = 0, size = streamHeaders.size(); i < size; i++) {
-        ByteString name = streamHeaders.get(i).name;
-        String value = streamHeaders.get(i).value.utf8();
-        if (name.equals(Header.TARGET_METHOD)) {
+        String name = streamHeaders.name(i);
+        String value = streamHeaders.value(i);
+        if (name.equals(Header.TARGET_METHOD_UTF8)) {
           method = value;
-        } else if (name.equals(Header.TARGET_PATH)) {
+        } else if (name.equals(Header.TARGET_PATH_UTF8)) {
           path = value;
-        } else if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2C) {
-          httpHeaders.add(name.utf8(), value);
+        } else if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
+          httpHeaders.add(name, value);
         } else {
           throw new IllegalStateException();
         }
-        if (name.utf8().equals("expect") && value.equalsIgnoreCase("100-continue")) {
+        if (name.equals("expect") && value.equalsIgnoreCase("100-continue")) {
           // Don't read the body unless we've invited the client to send it.
           readBody = false;
         }
@@ -919,14 +993,15 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
 
       MockResponse peek = dispatcher.peek();
       if (!readBody && peek.getSocketPolicy() == EXPECT_CONTINUE) {
-        stream.sendResponseHeaders(Collections.singletonList(
-            new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue"))), true);
+        List<Header> continueHeaders = Collections.singletonList(
+            new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue")));
+        stream.writeHeaders(continueHeaders, false, true);
         stream.getConnection().flush();
         readBody = true;
       }
 
       Buffer body = new Buffer();
-      if (readBody) {
+      if (readBody && !peek.isDuplex()) {
         String contentLengthString = headers.get("content-length");
         long byteCount = contentLengthString != null
             ? Long.parseLong(contentLengthString)
@@ -940,7 +1015,8 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
           sequenceNumber.getAndIncrement(), socket);
     }
 
-    private void writeResponse(Http2Stream stream, MockResponse response) throws IOException {
+    private void writeResponse(final Http2Stream stream,
+        final RecordedRequest request, final MockResponse response) throws IOException {
       Settings settings = response.getSettings();
       if (settings != null) {
         stream.getConnection().setSettings(settings);
@@ -960,24 +1036,41 @@ private void writeResponse(Http2Stream stream, MockResponse response) throws IOE
       for (int i = 0, size = headers.size(); i < size; i++) {
         http2Headers.add(new Header(headers.name(i), headers.value(i)));
       }
+      Headers trailers = response.getTrailers();
 
       sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS));
 
       Buffer body = response.getBody();
-      boolean closeStreamAfterHeaders = body != null || !response.getPushPromises().isEmpty();
-      stream.sendResponseHeaders(http2Headers, closeStreamAfterHeaders);
-      pushPromises(stream, response.getPushPromises());
+      boolean outFinished = body == null
+          && response.getPushPromises().isEmpty()
+          && !response.isDuplex();
+      boolean flushHeaders = body == null;
+      if (outFinished && trailers.size() > 0) {
+        throw new IllegalStateException("unsupported: no body and non-empty trailers " + trailers);
+      }
+      stream.writeHeaders(http2Headers, outFinished, flushHeaders);
+      if (trailers.size() > 0) {
+        stream.enqueueTrailers(trailers);
+      }
+      pushPromises(stream, request, response.getPushPromises());
       if (body != null) {
-        BufferedSink sink = Okio.buffer(stream.getSink());
-        sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
-        throttledTransfer(response, socket, body, sink, body.size(), false);
-        sink.close();
-      } else if (closeStreamAfterHeaders) {
-        stream.close(ErrorCode.NO_ERROR);
+        try (BufferedSink sink = Okio.buffer(stream.getSink())) {
+          sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
+          throttledTransfer(response, socket, body, sink, body.size(), false);
+        }
+      } else if (response.isDuplex()) {
+        try (BufferedSink sink = Okio.buffer(stream.getSink());
+             BufferedSource source = Okio.buffer(stream.getSource())) {
+          DuplexResponseBody duplexResponseBody = response.getDuplexResponseBody();
+          duplexResponseBody.onRequest(request, source, sink);
+        }
+      } else if (!outFinished) {
+        stream.close(ErrorCode.NO_ERROR, null);
       }
     }
 
-    private void pushPromises(Http2Stream stream, List<PushPromise> promises) throws IOException {
+    private void pushPromises(Http2Stream stream, RecordedRequest request,
+        List<PushPromise> promises) throws IOException {
       for (PushPromise pushPromise : promises) {
         List<Header> pushedHeaders = new ArrayList<>();
         pushedHeaders.add(new Header(Header.TARGET_AUTHORITY, url(pushPromise.path()).host()));
@@ -994,7 +1087,7 @@ private void pushPromises(Http2Stream stream, List<PushPromise> promises) throws
         boolean hasBody = pushPromise.response().getBody() != null;
         Http2Stream pushedStream =
             stream.getConnection().pushStream(stream.getId(), pushedHeaders, hasBody);
-        writeResponse(pushedStream, pushPromise.response());
+        writeResponse(pushedStream, request, pushPromise.response());
       }
     }
   }
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
index 672d42bc76..52beb79323 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
@@ -16,9 +16,13 @@
 
 package okhttp3.mockwebserver;
 
+import java.io.IOException;
+import java.net.Inet6Address;
+import java.net.InetAddress;
 import java.net.Socket;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
+import okhttp3.Handshake;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.TlsVersion;
@@ -30,11 +34,11 @@
   private final String method;
   private final String path;
   private final Headers headers;
+  private final Handshake handshake;
   private final List<Integer> chunkSizes;
   private final long bodySize;
   private final Buffer body;
   private final int sequenceNumber;
-  private final TlsVersion tlsVersion;
   private final HttpUrl requestUrl;
 
   public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkSizes,
@@ -45,20 +49,38 @@ public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkS
     this.bodySize = bodySize;
     this.body = body;
     this.sequenceNumber = sequenceNumber;
-    this.tlsVersion = socket instanceof SSLSocket
-        ? TlsVersion.forJavaName(((SSLSocket) socket).getSession().getProtocol())
-        : null;
+    if (socket instanceof SSLSocket) {
+      try {
+        this.handshake = Handshake.get(((SSLSocket) socket).getSession());
+      } catch (IOException e) {
+        throw new IllegalArgumentException(e);
+      }
+    } else {
+      this.handshake = null;
+    }
 
     if (requestLine != null) {
       int methodEnd = requestLine.indexOf(' ');
       int pathEnd = requestLine.indexOf(' ', methodEnd + 1);
       this.method = requestLine.substring(0, methodEnd);
-      this.path = requestLine.substring(methodEnd + 1, pathEnd);
+      String path = requestLine.substring(methodEnd + 1, pathEnd);
+      if (!path.startsWith("/")) {
+        path = "/";
+      }
+      this.path = path;
 
       String scheme = socket instanceof SSLSocket ? "https" : "http";
-      String hostname = socket.getInetAddress().getHostName();
-      int port = socket.getLocalPort();
-      this.requestUrl = HttpUrl.parse(String.format("%s://%s:%s%s", scheme, hostname, port, path));
+      InetAddress inetAddress = socket.getLocalAddress();
+
+      String hostname = inetAddress.getHostName();
+      if (inetAddress instanceof Inet6Address) {
+        hostname = "[" + hostname + "]";
+      }
+
+      int localPort = socket.getLocalPort();
+      // Allow null in failure case to allow for testing bad requests
+      this.requestUrl =
+          HttpUrl.parse(String.format("%s://%s:%s%s", scheme, hostname, localPort, path));
     } else {
       this.requestUrl = null;
       this.method = null;
@@ -128,7 +150,15 @@ public int getSequenceNumber() {
 
   /** Returns the connection's TLS version or null if the connection doesn't use SSL. */
   public TlsVersion getTlsVersion() {
-    return tlsVersion;
+    return handshake != null ? handshake.tlsVersion() : null;
+  }
+
+  /**
+   * Returns the TLS handshake of the connection that carried this request, or null if the request
+   * was received without TLS.
+   */
+  public Handshake getHandshake() {
+    return handshake;
   }
 
   @Override public String toString() {
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
index e92da7657f..beeb2c9a6d 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
@@ -31,6 +31,11 @@
  */
 public enum SocketPolicy {
 
+  /**
+   * Shutdown {@link MockWebServer} after writing response.
+   */
+  SHUTDOWN_SERVER_AFTER_RESPONSE,
+
   /**
    * Keep the socket open after the response. This is the default HTTP/1.1 behavior.
    */
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/DuplexResponseBody.java
similarity index 60%
rename from benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java
rename to mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/DuplexResponseBody.java
index 0c0986ffeb..79a8245e8f 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/HttpClient.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/DuplexResponseBody.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
+ * Copyright (C) 2018 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.benchmarks;
+package okhttp3.mockwebserver.internal.duplex;
 
-import okhttp3.HttpUrl;
+import java.io.IOException;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.BufferedSink;
+import okio.BufferedSource;
 
-/** An HTTP client to benchmark. */
-interface HttpClient {
-  void prepare(Benchmark benchmark);
-
-  void enqueue(HttpUrl url) throws Exception;
-
-  boolean acceptingJobs();
+public interface DuplexResponseBody {
+  void onRequest(RecordedRequest request, BufferedSource requestBody, BufferedSink responseBody)
+      throws IOException;
 }
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/MockDuplexResponseBody.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/MockDuplexResponseBody.java
new file mode 100644
index 0000000000..6f90d1710b
--- /dev/null
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/duplex/MockDuplexResponseBody.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.mockwebserver.internal.duplex;
+
+import java.io.IOException;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Utf8;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * A scriptable request/response conversation. Create the script by calling methods like {@link
+ * #receiveRequest} in the sequence they are run.
+ */
+public final class MockDuplexResponseBody implements DuplexResponseBody {
+  private final BlockingQueue<Action> actions = new LinkedBlockingQueue<>();
+  private final BlockingQueue<FutureTask<Void>> results = new LinkedBlockingQueue<>();
+
+  public MockDuplexResponseBody receiveRequest(String expected) {
+    actions.add((request, requestBody, responseBody) -> {
+      assertEquals(expected, requestBody.readUtf8(Utf8.size(expected)));
+    });
+    return this;
+  }
+
+  public MockDuplexResponseBody exhaustRequest() {
+    actions.add((request, requestBody, responseBody) -> {
+      assertTrue(requestBody.exhausted());
+    });
+    return this;
+  }
+
+  public MockDuplexResponseBody requestIOException() {
+    actions.add((request, requestBody, responseBody) -> {
+      try {
+        requestBody.exhausted();
+        fail();
+      } catch (IOException expected) {
+      }
+    });
+    return this;
+  }
+
+  public MockDuplexResponseBody sendResponse(String s) {
+    return sendResponse(s, new CountDownLatch(0));
+  }
+
+    public MockDuplexResponseBody sendResponse(String s, CountDownLatch responseSent) {
+    actions.add((request, requestBody, responseBody) -> {
+      responseBody.writeUtf8(s);
+      responseBody.flush();
+      responseSent.countDown();
+    });
+    return this;
+  }
+
+  public MockDuplexResponseBody exhaustResponse() {
+    actions.add((request, requestBody, responseBody) -> {
+      responseBody.close();
+    });
+    return this;
+  }
+
+  public MockDuplexResponseBody sleep(long duration, TimeUnit unit) {
+    actions.add((request, requestBody, responseBody) -> {
+      try {
+        Thread.sleep(unit.toMillis(duration));
+      } catch (InterruptedException e) {
+        throw new AssertionError(e);
+      }
+    });
+    return this;
+  }
+
+  @Override public void onRequest(RecordedRequest request, BufferedSource requestBody,
+      BufferedSink responseBody) {
+    FutureTask<Void> futureTask = new FutureTask<>(() -> {
+      for (Action action; (action = actions.poll()) != null; ) {
+        action.execute(request, requestBody, responseBody);
+      }
+      return null; // Success!
+    });
+    results.add(futureTask);
+    futureTask.run();
+  }
+
+  /** Returns once the duplex conversation completes successfully. */
+  public void awaitSuccess() throws Exception {
+    FutureTask<Void> futureTask = results.poll(5, TimeUnit.SECONDS);
+    if (futureTask == null) throw new AssertionError("no onRequest call received");
+    futureTask.get(5, TimeUnit.SECONDS);
+  }
+
+  private interface Action {
+    void execute(RecordedRequest request, BufferedSource requestBody, BufferedSink responseBody)
+        throws IOException;
+  }
+}
+
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/tls/HeldCertificate.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/tls/HeldCertificate.java
deleted file mode 100644
index 583c5335ba..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/tls/HeldCertificate.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver.internal.tls;
-
-import java.math.BigInteger;
-import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.KeyPairGenerator;
-import java.security.SecureRandom;
-import java.security.Security;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-import java.util.UUID;
-import javax.security.auth.x500.X500Principal;
-import org.bouncycastle.asn1.ASN1Encodable;
-import org.bouncycastle.asn1.DERSequence;
-import org.bouncycastle.asn1.x509.BasicConstraints;
-import org.bouncycastle.asn1.x509.GeneralName;
-import org.bouncycastle.asn1.x509.X509Extensions;
-import org.bouncycastle.jce.provider.BouncyCastleProvider;
-import org.bouncycastle.x509.X509V3CertificateGenerator;
-
-import static okhttp3.internal.Util.verifyAsIpAddress;
-
-/**
- * A certificate and its private key. This can be used on the server side by HTTPS servers, or on
- * the client side to verify those HTTPS servers. A held certificate can also be used to sign other
- * held certificates, as done in practice by certificate authorities.
- */
-public final class HeldCertificate {
-  public final X509Certificate certificate;
-  public final KeyPair keyPair;
-
-  public HeldCertificate(X509Certificate certificate, KeyPair keyPair) {
-    this.certificate = certificate;
-    this.keyPair = keyPair;
-  }
-
-  public static final class Builder {
-    static {
-      Security.addProvider(new BouncyCastleProvider());
-    }
-
-    private final long duration = 1000L * 60 * 60 * 24; // One day.
-    private String hostname;
-    private List<String> altNames = new ArrayList<>();
-    private String serialNumber = "1";
-    private KeyPair keyPair;
-    private HeldCertificate issuedBy;
-    private int maxIntermediateCas;
-
-    public Builder serialNumber(String serialNumber) {
-      this.serialNumber = serialNumber;
-      return this;
-    }
-
-    /**
-     * Set this certificate's name. Typically this is the URL hostname for TLS certificates. This is
-     * the CN (common name) in the certificate. Will be a random string if no value is provided.
-     */
-    public Builder commonName(String hostname) {
-      this.hostname = hostname;
-      return this;
-    }
-
-    public Builder keyPair(KeyPair keyPair) {
-      this.keyPair = keyPair;
-      return this;
-    }
-
-    /**
-     * Set the certificate that signs this certificate. If unset, a self-signed certificate will be
-     * generated.
-     */
-    public Builder issuedBy(HeldCertificate signedBy) {
-      this.issuedBy = signedBy;
-      return this;
-    }
-
-    /**
-     * Set this certificate to be a certificate authority, with up to {@code maxIntermediateCas}
-     * intermediate certificate authorities beneath it.
-     */
-    public Builder ca(int maxIntermediateCas) {
-      this.maxIntermediateCas = maxIntermediateCas;
-      return this;
-    }
-
-    /**
-     * Adds a subject alternative name to the certificate. This is usually a hostname or IP address.
-     * If no subject alternative names are added that extension will not be used.
-     */
-    public Builder subjectAlternativeName(String altName) {
-      altNames.add(altName);
-      return this;
-    }
-
-    public HeldCertificate build() throws GeneralSecurityException {
-      // Subject, public & private keys for this certificate.
-      KeyPair heldKeyPair = keyPair != null
-          ? keyPair
-          : generateKeyPair();
-      X500Principal subject = hostname != null
-          ? new X500Principal("CN=" + hostname)
-          : new X500Principal("CN=" + UUID.randomUUID());
-
-      // Subject, public & private keys for this certificate's signer. It may be self signed!
-      KeyPair signedByKeyPair;
-      X500Principal signedByPrincipal;
-      if (issuedBy != null) {
-        signedByKeyPair = issuedBy.keyPair;
-        signedByPrincipal = issuedBy.certificate.getSubjectX500Principal();
-      } else {
-        signedByKeyPair = heldKeyPair;
-        signedByPrincipal = subject;
-      }
-
-      // Generate & sign the certificate.
-      long now = System.currentTimeMillis();
-      X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
-      generator.setSerialNumber(new BigInteger(serialNumber));
-      generator.setIssuerDN(signedByPrincipal);
-      generator.setNotBefore(new Date(now));
-      generator.setNotAfter(new Date(now + duration));
-      generator.setSubjectDN(subject);
-      generator.setPublicKey(heldKeyPair.getPublic());
-      generator.setSignatureAlgorithm("SHA256WithRSAEncryption");
-
-      if (maxIntermediateCas > 0) {
-        generator.addExtension(X509Extensions.BasicConstraints, true,
-            new BasicConstraints(maxIntermediateCas));
-      }
-
-      if (!altNames.isEmpty()) {
-        ASN1Encodable[] encodableAltNames = new ASN1Encodable[altNames.size()];
-        for (int i = 0, size = altNames.size(); i < size; i++) {
-          String altName = altNames.get(i);
-          int tag = verifyAsIpAddress(altName)
-              ? GeneralName.iPAddress
-              : GeneralName.dNSName;
-          encodableAltNames[i] = new GeneralName(tag, altName);
-        }
-        generator.addExtension(X509Extensions.SubjectAlternativeName, true,
-            new DERSequence(encodableAltNames));
-      }
-
-      X509Certificate certificate = generator.generateX509Certificate(
-          signedByKeyPair.getPrivate(), "BC");
-      return new HeldCertificate(certificate, heldKeyPair);
-    }
-
-    public KeyPair generateKeyPair() throws GeneralSecurityException {
-      KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC");
-      keyPairGenerator.initialize(1024, new SecureRandom());
-      return keyPairGenerator.generateKeyPair();
-    }
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/tls/SslClient.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/tls/SslClient.java
deleted file mode 100644
index 076cc9011c..0000000000
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/tls/SslClient.java
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.mockwebserver.internal.tls;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.KeyStore;
-import java.security.SecureRandom;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.platform.Platform;
-
-/**
- * Combines an SSL socket factory and trust manager, a pairing enough for OkHttp or MockWebServer to
- * create a secure connection.
- */
-public final class SslClient {
-  private static SslClient localhost; // Lazily initialized.
-
-  public final SSLContext sslContext;
-  public final SSLSocketFactory socketFactory;
-  public final X509TrustManager trustManager;
-
-  private SslClient(SSLContext sslContext, X509TrustManager trustManager) {
-    this.sslContext = sslContext;
-    this.socketFactory = sslContext.getSocketFactory();
-    this.trustManager = trustManager;
-  }
-
-  /** Returns an SSL client for this host's localhost address. */
-  public static synchronized SslClient localhost() {
-    if (localhost != null) return localhost;
-
-    try {
-      // Generate a self-signed cert for the server to serve and the client to trust.
-      HeldCertificate heldCertificate = new HeldCertificate.Builder()
-          .serialNumber("1")
-          .commonName(InetAddress.getByName("localhost").getCanonicalHostName())
-          .build();
-
-      localhost = new Builder()
-          .certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
-          .addTrustedCertificate(heldCertificate.certificate)
-          .build();
-
-      return localhost;
-    } catch (GeneralSecurityException | UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  public static class Builder {
-    private final List<X509Certificate> chainCertificates = new ArrayList<>();
-    private final List<X509Certificate> certificates = new ArrayList<>();
-    private KeyPair keyPair;
-    private String keyStoreType = KeyStore.getDefaultType();
-    private SSLContext sslContext;
-
-    /**
-     * Configure the certificate chain to use when serving HTTPS responses. The first certificate is
-     * the server's certificate, further certificates are included in the handshake so the client
-     * can build a trusted path to a CA certificate.
-     */
-    public Builder certificateChain(HeldCertificate localCert, HeldCertificate... chain) {
-      X509Certificate[] certificates = new X509Certificate[chain.length];
-      for (int i = 0; i < chain.length; i++) {
-        certificates[i] = chain[i].certificate;
-      }
-      return certificateChain(localCert.keyPair, localCert.certificate, certificates);
-    }
-
-    public Builder certificateChain(KeyPair keyPair, X509Certificate keyCert,
-        X509Certificate... certificates) {
-      this.keyPair = keyPair;
-      this.chainCertificates.add(keyCert);
-      this.chainCertificates.addAll(Arrays.asList(certificates));
-      this.certificates.addAll(Arrays.asList(certificates));
-      return this;
-    }
-
-    /**
-     * Add a certificate authority that this client trusts. Servers that provide certificate chains
-     * signed by these roots (or their intermediates) will be accepted.
-     */
-    public Builder addTrustedCertificate(X509Certificate certificate) {
-      this.certificates.add(certificate);
-      return this;
-    }
-
-    public Builder keyStoreType(String keyStoreType) {
-      this.keyStoreType = keyStoreType;
-      return this;
-    }
-
-    public Builder sslContext(SSLContext sslContext) {
-      this.sslContext = sslContext;
-      return this;
-    }
-
-    public SslClient build() {
-      try {
-        // Put the certificate in a key store.
-        char[] password = "password".toCharArray();
-        KeyStore keyStore = newEmptyKeyStore(password);
-
-        if (keyPair != null) {
-          Certificate[] certificates = chainCertificates.toArray(
-              new Certificate[chainCertificates.size()]);
-          keyStore.setKeyEntry("private", keyPair.getPrivate(), password, certificates);
-        }
-
-        for (int i = 0; i < certificates.size(); i++) {
-          keyStore.setCertificateEntry("cert_" + i, certificates.get(i));
-        }
-
-        // Wrap it up in an SSL context.
-        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
-            KeyManagerFactory.getDefaultAlgorithm());
-        keyManagerFactory.init(keyStore, password);
-        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-            TrustManagerFactory.getDefaultAlgorithm());
-        trustManagerFactory.init(keyStore);
-        TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-
-        if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-          throw new IllegalStateException("Unexpected default trust managers:"
-              + Arrays.toString(trustManagers));
-        }
-
-        SSLContext activeSslContext =
-            this.sslContext != null ? this.sslContext : Platform.get().getSSLContext();
-        activeSslContext.init(keyManagerFactory.getKeyManagers(), trustManagers,
-            new SecureRandom());
-
-        return new SslClient(activeSslContext, (X509TrustManager) trustManagers[0]);
-      } catch (GeneralSecurityException gse) {
-        throw new AssertionError(gse);
-      }
-    }
-
-    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
-      try {
-        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
-        InputStream in = null; // By convention, 'null' creates an empty key store.
-        keyStore.load(in, password);
-        return keyStore;
-      } catch (IOException e) {
-        throw new AssertionError(e);
-      }
-    }
-  }
-}
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
index 5f189dc608..39b5df5d11 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
@@ -22,41 +22,38 @@
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
-import org.junit.After;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.Timeout;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class CustomDispatcherTest {
-  private MockWebServer mockWebServer = new MockWebServer();
+  @Rule public MockWebServer mockWebServer = new MockWebServer();
 
-  @After public void tearDown() throws Exception {
-    mockWebServer.shutdown();
-  }
+  @Rule public Timeout globalTimeout = Timeout.seconds(30);
 
   @Test public void simpleDispatch() throws Exception {
-    mockWebServer.start();
     final List<RecordedRequest> requestsMade = new ArrayList<>();
     final Dispatcher dispatcher = new Dispatcher() {
       @Override
-      public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+      public MockResponse dispatch(RecordedRequest request) {
         requestsMade.add(request);
         return new MockResponse();
       }
     };
-    assertEquals(0, requestsMade.size());
+    assertThat(requestsMade.size()).isEqualTo(0);
     mockWebServer.setDispatcher(dispatcher);
     final URL url = mockWebServer.url("/").url();
     final HttpURLConnection conn = (HttpURLConnection) url.openConnection();
     conn.getResponseCode(); // Force the connection to hit the "server".
     // Make sure our dispatcher got the request.
-    assertEquals(1, requestsMade.size());
+    assertThat(requestsMade.size()).isEqualTo(1);
   }
 
   @Test public void outOfOrderResponses() throws Exception {
     AtomicInteger firstResponseCode = new AtomicInteger();
     AtomicInteger secondResponseCode = new AtomicInteger();
-    mockWebServer.start();
     final String secondRequest = "/bar";
     final String firstRequest = "/foo";
     final CountDownLatch latch = new CountDownLatch(1);
@@ -75,24 +72,26 @@ public MockResponse dispatch(RecordedRequest request) throws InterruptedExceptio
     final Thread endsFirst = buildRequestThread(secondRequest, secondResponseCode);
     endsFirst.start();
     endsFirst.join();
-    assertEquals(0, firstResponseCode.get()); // First response is still waiting.
-    assertEquals(200, secondResponseCode.get()); // Second response is done.
+    // First response is still waiting.
+    assertThat(firstResponseCode.get()).isEqualTo(0);
+    // Second response is done.
+    assertThat(secondResponseCode.get()).isEqualTo(200);
     latch.countDown();
     startsFirst.join();
-    assertEquals(200, firstResponseCode.get()); // And now it's done!
-    assertEquals(200, secondResponseCode.get()); // (Still done).
+    // And now it's done!
+    assertThat(firstResponseCode.get()).isEqualTo(200);
+    // (Still done).
+    assertThat(secondResponseCode.get()).isEqualTo(200);
   }
 
-  private Thread buildRequestThread(final String path, final AtomicInteger responseCode) {
-    return new Thread(new Runnable() {
-      @Override public void run() {
-        final URL url = mockWebServer.url(path).url();
-        final HttpURLConnection conn;
-        try {
-          conn = (HttpURLConnection) url.openConnection();
-          responseCode.set(conn.getResponseCode()); // Force the connection to hit the "server".
-        } catch (IOException e) {
-        }
+  private Thread buildRequestThread(String path, AtomicInteger responseCode) {
+    return new Thread(() -> {
+      URL url = mockWebServer.url(path).url();
+      HttpURLConnection conn;
+      try {
+        conn = (HttpURLConnection) url.openConnection();
+        responseCode.set(conn.getResponseCode()); // Force the connection to hit the "server".
+      } catch (IOException ignored) {
       }
     });
   }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index e9d46b2a87..61d438707f 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -27,37 +27,42 @@
 import java.net.SocketTimeoutException;
 import java.net.URL;
 import java.net.URLConnection;
-import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import javax.net.ssl.HttpsURLConnection;
+import okhttp3.Handshake;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.Protocol;
-import okhttp3.internal.Util;
-import org.junit.After;
+import okhttp3.RecordingHostnameVerifier;
+import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.Timeout;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Arrays.asList;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 import static org.junit.Assert.fail;
 
 public final class MockWebServerTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
+  @Rule public Timeout globalTimeout = Timeout.seconds(30);
+
   @Test public void defaultMockResponse() {
     MockResponse response = new MockResponse();
-    assertEquals(Arrays.asList("Content-Length: 0"), headersToList(response));
-    assertEquals("HTTP/1.1 200 OK", response.getStatus());
+    assertThat(headersToList(response)).containsExactly("Content-Length: 0");
+    assertThat(response.getStatus()).isEqualTo("HTTP/1.1 200 OK");
   }
 
   @Test public void setResponseMockReason() {
@@ -73,21 +78,21 @@
     for (int i = 0; i < 600; i++) {
       MockResponse response = new MockResponse().setResponseCode(i);
       String expectedReason = reasons[i / 100];
-      assertEquals("HTTP/1.1 " + i + " " + expectedReason, response.getStatus());
-      assertEquals(Arrays.asList("Content-Length: 0"), headersToList(response));
+      assertThat(response.getStatus()).isEqualTo(("HTTP/1.1 " + i + " " + expectedReason));
+      assertThat(headersToList(response)).containsExactly("Content-Length: 0");
     }
   }
 
   @Test public void setStatusControlsWholeStatusLine() {
     MockResponse response = new MockResponse().setStatus("HTTP/1.1 202 That'll do pig");
-    assertEquals(Arrays.asList("Content-Length: 0"), headersToList(response));
-    assertEquals("HTTP/1.1 202 That'll do pig", response.getStatus());
+    assertThat(headersToList(response)).containsExactly("Content-Length: 0");
+    assertThat(response.getStatus()).isEqualTo("HTTP/1.1 202 That'll do pig");
   }
 
   @Test public void setBodyAdjustsHeaders() throws IOException {
     MockResponse response = new MockResponse().setBody("ABC");
-    assertEquals(Arrays.asList("Content-Length: 3"), headersToList(response));
-    assertEquals("ABC", response.getBody().readUtf8());
+    assertThat(headersToList(response)).containsExactly("Content-Length: 3");
+    assertThat(response.getBody().readUtf8()).isEqualTo("ABC");
   }
 
   @Test public void mockResponseAddHeader() {
@@ -95,7 +100,7 @@
         .clearHeaders()
         .addHeader("Cookie: s=square")
         .addHeader("Cookie", "a=android");
-    assertEquals(Arrays.asList("Cookie: s=square", "Cookie: a=android"), headersToList(response));
+    assertThat(headersToList(response)).containsExactly("Cookie: s=square", "Cookie: a=android");
   }
 
   @Test public void mockResponseSetHeader() {
@@ -105,7 +110,7 @@
         .addHeader("Cookie: a=android")
         .addHeader("Cookies: delicious");
     response.setHeader("cookie", "r=robot");
-    assertEquals(Arrays.asList("Cookies: delicious", "cookie: r=robot"), headersToList(response));
+    assertThat(headersToList(response)).containsExactly("Cookies: delicious", "cookie: r=robot");
   }
 
   @Test public void mockResponseSetHeaders() {
@@ -116,7 +121,7 @@
 
     response.setHeaders(new Headers.Builder().add("Cookie", "a=android").build());
 
-    assertEquals(Arrays.asList("Cookie: a=android"), headersToList(response));
+    assertThat(headersToList(response)).containsExactly("Cookie: a=android");
   }
 
   @Test public void regularResponse() throws Exception {
@@ -127,12 +132,12 @@
     connection.setRequestProperty("Accept-Language", "en-US");
     InputStream in = connection.getInputStream();
     BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
-    assertEquals("hello world", reader.readLine());
+    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
+    assertThat(reader.readLine()).isEqualTo("hello world");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", request.getRequestLine());
-    assertEquals("en-US", request.getHeader("Accept-Language"));
+    assertThat(request.getRequestLine()).isEqualTo("GET / HTTP/1.1");
+    assertThat(request.getHeader("Accept-Language")).isEqualTo("en-US");
   }
 
   @Test public void redirect() throws Exception {
@@ -145,12 +150,12 @@
     URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
     BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertEquals("This is the new location!", reader.readLine());
+    assertThat(reader.readLine()).isEqualTo("This is the new location!");
 
     RecordedRequest first = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", first.getRequestLine());
+    assertThat(first.getRequestLine()).isEqualTo("GET / HTTP/1.1");
     RecordedRequest redirect = server.takeRequest();
-    assertEquals("GET /new-path HTTP/1.1", redirect.getRequestLine());
+    assertThat(redirect.getRequestLine()).isEqualTo("GET /new-path HTTP/1.1");
   }
 
   /**
@@ -158,20 +163,18 @@
    * response is ready.
    */
   @Test public void dispatchBlocksWaitingForEnqueue() throws Exception {
-    new Thread() {
-      @Override public void run() {
-        try {
-          Thread.sleep(1000);
-        } catch (InterruptedException ignored) {
-        }
-        server.enqueue(new MockResponse().setBody("enqueued in the background"));
+    new Thread(() -> {
+      try {
+        Thread.sleep(1000);
+      } catch (InterruptedException ignored) {
       }
-    }.start();
+      server.enqueue(new MockResponse().setBody("enqueued in the background"));
+    }).start();
 
     URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
     BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertEquals("enqueued in the background", reader.readLine());
+    assertThat(reader.readLine()).isEqualTo("enqueued in the background");
   }
 
   @Test public void nonHexadecimalChunkSize() throws Exception {
@@ -199,9 +202,9 @@
     URLConnection urlConnection = server.url("/").url().openConnection();
     urlConnection.setReadTimeout(1000);
     InputStream in = urlConnection.getInputStream();
-    assertEquals('A', in.read());
-    assertEquals('B', in.read());
-    assertEquals('C', in.read());
+    assertThat(in.read()).isEqualTo('A');
+    assertThat(in.read()).isEqualTo('B');
+    assertThat(in.read()).isEqualTo('C');
     try {
       in.read(); // if Content-Length was accurate, this would return -1 immediately
       fail();
@@ -210,13 +213,13 @@
 
     URLConnection urlConnection2 = server.url("/").url().openConnection();
     InputStream in2 = urlConnection2.getInputStream();
-    assertEquals('D', in2.read());
-    assertEquals('E', in2.read());
-    assertEquals('F', in2.read());
-    assertEquals(-1, in2.read());
+    assertThat(in2.read()).isEqualTo('D');
+    assertThat(in2.read()).isEqualTo('E');
+    assertThat(in2.read()).isEqualTo('F');
+    assertThat(in2.read()).isEqualTo(-1);
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void disconnectAtStart() throws Exception {
@@ -241,14 +244,12 @@
     long startNanos = System.nanoTime();
     URLConnection connection = server.url("/").url().openConnection();
     connection.setDoOutput(true);
-    connection.getOutputStream().write("ABCDEF".getBytes("UTF-8"));
+    connection.getOutputStream().write("ABCDEF".getBytes(UTF_8));
     InputStream in = connection.getInputStream();
-    assertEquals(-1, in.read());
+    assertThat(in.read()).isEqualTo(-1);
     long elapsedNanos = System.nanoTime() - startNanos;
     long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-
-    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
-    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
+    assertThat(elapsedMillis).isBetween(500L, 1000L);
   }
 
   /**
@@ -263,18 +264,16 @@
     long startNanos = System.nanoTime();
     URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
-    assertEquals('A', in.read());
-    assertEquals('B', in.read());
-    assertEquals('C', in.read());
-    assertEquals('D', in.read());
-    assertEquals('E', in.read());
-    assertEquals('F', in.read());
-    assertEquals(-1, in.read());
+    assertThat(in.read()).isEqualTo('A');
+    assertThat(in.read()).isEqualTo('B');
+    assertThat(in.read()).isEqualTo('C');
+    assertThat(in.read()).isEqualTo('D');
+    assertThat(in.read()).isEqualTo('E');
+    assertThat(in.read()).isEqualTo('F');
+    assertThat(in.read()).isEqualTo(-1);
     long elapsedNanos = System.nanoTime() - startNanos;
     long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-
-    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 500);
-    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis < 1000);
+    assertThat(elapsedMillis).isBetween(500L, 1000L);
   }
 
   /** Delay the response body by sleeping 1s. */
@@ -286,15 +285,15 @@
     long startNanos = System.nanoTime();
     URLConnection connection = server.url("/").url().openConnection();
     InputStream in = connection.getInputStream();
-    assertEquals('A', in.read());
+    assertThat(in.read()).isEqualTo('A');
     long elapsedNanos = System.nanoTime() - startNanos;
     long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-    assertTrue(Util.format("Request + Response: %sms", elapsedMillis), elapsedMillis >= 1000);
+    assertThat(elapsedMillis).isGreaterThanOrEqualTo(1000L);
 
     in.close();
   }
 
-  @Test public void disconnectRequestHalfway() throws IOException {
+  @Test public void disconnectRequestHalfway() throws Exception {
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
     // Limit the size of the request body that the server holds in memory to an arbitrary
     // 3.5 MBytes so this test can pass on devices with little memory.
@@ -313,11 +312,16 @@
       try {
         out.write(data);
         out.flush();
+        if (i == 513) {
+          // pause slightly after half way to make result more predictable
+          Thread.sleep(100);
+        }
       } catch (IOException e) {
         break;
       }
     }
-    assertEquals(512f, i, 10f); // Halfway +/- 1%
+    // Halfway +/- 0.5%
+    assertThat((float) i).isCloseTo(512f, offset(5f));
   }
 
   @Test public void disconnectResponseHalfway() throws IOException {
@@ -326,13 +330,13 @@
         .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
 
     URLConnection connection = server.url("/").url().openConnection();
-    assertEquals(2, connection.getContentLength());
+    assertThat(connection.getContentLength()).isEqualTo(2);
     InputStream in = connection.getInputStream();
-    assertEquals('a', in.read());
+    assertThat(in.read()).isEqualTo('a');
     try {
       int byteRead = in.read();
       // OpenJDK behavior: end of stream.
-      assertEquals(-1, byteRead);
+      assertThat(byteRead).isEqualTo(-1);
     } catch (ProtocolException e) {
       // On Android, HttpURLConnection is implemented by OkHttp v2. OkHttp
       // treats an incomplete response body as a ProtocolException.
@@ -365,25 +369,21 @@
     server.shutdown();
   }
 
-  @After public void tearDown() throws IOException {
-    server.shutdown();
-  }
-
   @Test public void portImplicitlyStarts() throws IOException {
-    assertTrue(server.getPort() > 0);
+    assertThat(server.getPort()).isGreaterThan(0);
   }
 
   @Test public void hostnameImplicitlyStarts() throws IOException {
-    assertNotNull(server.getHostName());
+    assertThat(server.getHostName()).isNotNull();
   }
 
   @Test public void toProxyAddressImplicitlyStarts() throws IOException {
-    assertNotNull(server.toProxyAddress());
+    assertThat(server.toProxyAddress()).isNotNull();
   }
 
   @Test public void differentInstancesGetDifferentPorts() throws IOException {
     MockWebServer other = new MockWebServer();
-    assertNotEquals(server.getPort(), other.getPort());
+    assertThat(other.getPort()).isNotEqualTo(server.getPort());
     other.shutdown();
   }
 
@@ -398,7 +398,7 @@
 
     statement.evaluate();
 
-    assertTrue(called.get());
+    assertThat(called.get()).isTrue();
     try {
       server.url("/").url().openConnection().connect();
       fail();
@@ -427,18 +427,37 @@
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
     InputStream in = connection.getInputStream();
     BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
-    assertEquals("hello world", reader.readLine());
+    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
+    assertThat(reader.readLine()).isEqualTo("hello world");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("GET /a/deep/path?key=foo%20bar HTTP/1.1", request.getRequestLine());
+    assertThat(request.getRequestLine()).isEqualTo(
+        "GET /a/deep/path?key=foo%20bar HTTP/1.1");
 
     HttpUrl requestUrl = request.getRequestUrl();
-    assertEquals("http", requestUrl.scheme());
-    assertEquals(server.getHostName(), requestUrl.host());
-    assertEquals(server.getPort(), requestUrl.port());
-    assertEquals("/a/deep/path", requestUrl.encodedPath());
-    assertEquals("foo bar", requestUrl.queryParameter("key"));
+    assertThat(requestUrl.scheme()).isEqualTo("http");
+    assertThat(requestUrl.host()).isEqualTo(server.getHostName());
+    assertThat(requestUrl.port()).isEqualTo(server.getPort());
+    assertThat(requestUrl.encodedPath()).isEqualTo("/a/deep/path");
+    assertThat(requestUrl.queryParameter("key")).isEqualTo("foo bar");
+  }
+
+  @Test public void shutdownServerAfterRequest() throws Exception {
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE));
+
+    URL url = server.url("/").url();
+
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
+
+    HttpURLConnection refusedConnection = (HttpURLConnection) url.openConnection();
+
+    try {
+      refusedConnection.getResponseCode();
+      fail("Second connection should be refused");
+    } catch (ConnectException e) {
+      assertThat(e.getMessage()).contains("refused");
+    }
   }
 
   @Test public void http100Continue() throws Exception {
@@ -448,39 +467,116 @@
     HttpURLConnection connection = (HttpURLConnection) url.openConnection();
     connection.setDoOutput(true);
     connection.setRequestProperty("Expect", "100-Continue");
-    connection.getOutputStream().write("request".getBytes(StandardCharsets.UTF_8));
+    connection.getOutputStream().write("request".getBytes(UTF_8));
 
     InputStream in = connection.getInputStream();
     BufferedReader reader = new BufferedReader(new InputStreamReader(in));
-    assertEquals("response", reader.readLine());
+    assertThat(reader.readLine()).isEqualTo("response");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("request", request.getBody().readUtf8());
+    assertThat(request.getBody().readUtf8()).isEqualTo("request");
   }
 
-  @Test public void testH2CServerFallback() {
+  @Test public void testH2PriorKnowledgeServerFallback() {
     try {
-      server.setProtocols(Arrays.asList(Protocol.H2C, Protocol.HTTP_1_1));
-      fail("When H2C is specified, no other protocol can be specified");
+      server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
+      fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("protocols containing h2c cannot use other protocols: [h2c, http/1.1]", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("protocols containing h2_prior_knowledge cannot use other protocols: "
+              + "[h2_prior_knowledge, http/1.1]"));
     }
   }
 
-  @Test public void testH2CServerDuplicates() {
+  @Test public void testH2PriorKnowledgeServerDuplicates() {
     try {
       // Treating this use case as user error
-      server.setProtocols(Arrays.asList(Protocol.H2C, Protocol.H2C));
-      fail("When H2C is specified, no other protocol can be specified");
+      server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
+      fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("protocols containing h2c cannot use other protocols: [h2c, h2c]", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("protocols containing h2_prior_knowledge cannot use other protocols: "
+              + "[h2_prior_knowledge, h2_prior_knowledge]"));
     }
   }
 
-  @Test public void testMockWebServerH2CProtocol() {
-    server.setProtocols(Arrays.asList(Protocol.H2C));
+  @Test public void testMockWebServerH2PriorKnowledgeProtocol() {
+    server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE));
+
+    assertThat(server.protocols().size()).isEqualTo(1);
+    assertThat(server.protocols().get(0)).isEqualTo(Protocol.H2_PRIOR_KNOWLEDGE);
+  }
+
+  @Test public void https() throws Exception {
+    HandshakeCertificates handshakeCertificates = localhost();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    HttpUrl url = server.url("/");
+    HttpsURLConnection connection = (HttpsURLConnection) url.url().openConnection();
+    connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
+    connection.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
+    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+    assertThat(reader.readLine()).isEqualTo("abc");
 
-    assertEquals(1, server.protocols().size());
-    assertEquals(Protocol.H2C, server.protocols().get(0));
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getRequestUrl().scheme()).isEqualTo("https");
+    Handshake handshake = request.getHandshake();
+    assertThat(handshake.tlsVersion()).isNotNull();
+    assertThat(handshake.cipherSuite()).isNotNull();
+    assertThat(handshake.localPrincipal()).isNotNull();
+    assertThat(handshake.localCertificates().size()).isEqualTo(1);
+    assertThat(handshake.peerPrincipal()).isNull();
+    assertThat(handshake.peerCertificates().size()).isEqualTo(0);
+  }
+
+  @Test public void httpsWithClientAuth() throws Exception {
+    HeldCertificate clientCa = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .build();
+    HeldCertificate serverCa = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .build();
+    HeldCertificate serverCertificate = new HeldCertificate.Builder()
+        .signedBy(serverCa)
+        .addSubjectAlternativeName(server.getHostName())
+        .build();
+    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(clientCa.certificate())
+        .heldCertificate(serverCertificate)
+        .build();
+
+    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.requestClientAuth();
+
+    HeldCertificate clientCertificate = new HeldCertificate.Builder()
+        .signedBy(clientCa)
+        .build();
+    HandshakeCertificates clientHandshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(serverCa.certificate())
+        .heldCertificate(clientCertificate)
+        .build();
+
+    HttpUrl url = server.url("/");
+    HttpsURLConnection connection = (HttpsURLConnection) url.url().openConnection();
+    connection.setSSLSocketFactory(clientHandshakeCertificates.sslSocketFactory());
+    connection.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    assertThat(connection.getResponseCode()).isEqualTo(HttpURLConnection.HTTP_OK);
+    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+    assertThat(reader.readLine()).isEqualTo("abc");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getRequestUrl().scheme()).isEqualTo("https");
+    Handshake handshake = request.getHandshake();
+    assertThat(handshake.tlsVersion()).isNotNull();
+    assertThat(handshake.cipherSuite()).isNotNull();
+    assertThat(handshake.localPrincipal()).isNotNull();
+    assertThat(handshake.localCertificates().size()).isEqualTo(1);
+    assertThat(handshake.peerPrincipal()).isNotNull();
+    assertThat(handshake.peerCertificates().size()).isEqualTo(1);
   }
 }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
new file mode 100644
index 0000000000..4d498406a8
--- /dev/null
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/RecordedRequestTest.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.mockwebserver;
+
+import java.net.Inet4Address;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.net.UnknownHostException;
+import java.util.Collections;
+import okhttp3.Headers;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.Timeout;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class RecordedRequestTest {
+  Headers headers = Util.EMPTY_HEADERS;
+
+  private class FakeSocket extends Socket {
+    private final InetAddress localAddress;
+    private final int remotePort;
+    private final InetAddress remoteAddress;
+    private final int localPort;
+
+    private FakeSocket(int localPort) {
+      this(Inet4Address.getLoopbackAddress(), localPort);
+    }
+
+    private FakeSocket(InetAddress inetAddress, int localPort) {
+      this(inetAddress, localPort, inetAddress, 1234);
+    }
+
+    private FakeSocket(InetAddress localAddress, int localPort, InetAddress remoteAddress, int remotePort) {
+      this.localAddress = localAddress;
+      this.localPort = localPort;
+      this.remoteAddress = remoteAddress;
+      this.remotePort = remotePort;
+    }
+
+    @Override public InetAddress getInetAddress() {
+      return remoteAddress;
+    }
+
+    @Override public InetAddress getLocalAddress() {
+      return localAddress;
+    }
+
+    @Override public int getLocalPort() {
+      return localPort;
+    }
+
+    @Override public int getPort() {
+      return remotePort;
+    }
+  }
+
+  @Rule public Timeout globalTimeout = Timeout.seconds(30);
+
+  @Test public void testIPv4() throws UnknownHostException {
+    Socket socket =
+        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] { 127, 0, 0, 1 }), 80);
+
+    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
+        Collections.emptyList(), 0, new Buffer(), 0, socket);
+
+    assertThat(request.getRequestUrl().toString()).isEqualTo("http://127.0.0.1/");
+  }
+
+  @Test public void testIpv6() throws UnknownHostException {
+    Socket socket = new FakeSocket(InetAddress.getByAddress("::1",
+        new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }), 80);
+
+    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
+        Collections.emptyList(), 0, new Buffer(), 0, socket);
+
+    assertThat(request.getRequestUrl().toString()).isEqualTo("http://[::1]/");
+  }
+
+  @Test public void testUsesLocal() throws UnknownHostException {
+    Socket socket =
+        new FakeSocket(InetAddress.getByAddress("127.0.0.1", new byte[] { 127, 0, 0, 1 }), 80);
+
+    RecordedRequest request = new RecordedRequest("GET / HTTP/1.1", headers,
+        Collections.emptyList(), 0, new Buffer(), 0, socket);
+
+    assertThat(request.getRequestUrl().toString()).isEqualTo("http://127.0.0.1/");
+  }
+}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/http2/Http2Server.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
similarity index 87%
rename from mockwebserver/src/main/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
rename to mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
index cdd7d5a919..0bb19125e9 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
@@ -28,18 +28,20 @@
 import java.util.logging.Logger;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Headers;
 import okhttp3.Protocol;
 import okhttp3.internal.Util;
 import okhttp3.internal.http2.Header;
 import okhttp3.internal.http2.Http2Connection;
 import okhttp3.internal.http2.Http2Stream;
 import okhttp3.internal.platform.Platform;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okio.BufferedSink;
 import okio.Okio;
 import okio.Source;
 
+import static java.util.Arrays.asList;
 import static okhttp3.internal.platform.Platform.INFO;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 
 /** A basic HTTP/2 server that serves the contents of a local directory. */
 public final class Http2Server extends Http2Connection.Listener {
@@ -95,11 +97,11 @@ private SSLSocket doSsl(Socket socket) throws IOException {
 
   @Override public void onStream(Http2Stream stream) throws IOException {
     try {
-      List<Header> requestHeaders = stream.getRequestHeaders();
+      Headers requestHeaders = stream.takeHeaders();
       String path = null;
       for (int i = 0, size = requestHeaders.size(); i < size; i++) {
-        if (requestHeaders.get(i).name.equals(Header.TARGET_PATH)) {
-          path = requestHeaders.get(i).value.utf8();
+        if (requestHeaders.name(i).equals(Header.TARGET_PATH_UTF8)) {
+          path = requestHeaders.value(i);
           break;
         }
       }
@@ -124,24 +126,24 @@ private SSLSocket doSsl(Socket socket) throws IOException {
   }
 
   private void send404(Http2Stream stream, String path) throws IOException {
-    List<Header> responseHeaders = Arrays.asList(
+    List<Header> responseHeaders = asList(
         new Header(":status", "404"),
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", "text/plain")
     );
-    stream.sendResponseHeaders(responseHeaders, true);
+    stream.writeHeaders(responseHeaders, false, false);
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("Not found: " + path);
     out.close();
   }
 
   private void serveDirectory(Http2Stream stream, File[] files) throws IOException {
-    List<Header> responseHeaders = Arrays.asList(
+    List<Header> responseHeaders = asList(
         new Header(":status", "200"),
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", "text/html; charset=UTF-8")
     );
-    stream.sendResponseHeaders(responseHeaders, true);
+    stream.writeHeaders(responseHeaders, false, false);
     BufferedSink out = Okio.buffer(stream.getSink());
     for (File file : files) {
       String target = file.isDirectory() ? (file.getName() + "/") : file.getName();
@@ -151,19 +153,14 @@ private void serveDirectory(Http2Stream stream, File[] files) throws IOException
   }
 
   private void serveFile(Http2Stream stream, File file) throws IOException {
-    List<Header> responseHeaders = Arrays.asList(
+    List<Header> responseHeaders = asList(
         new Header(":status", "200"),
         new Header(":version", "HTTP/1.1"),
         new Header("content-type", contentType(file))
     );
-    stream.sendResponseHeaders(responseHeaders, true);
-    Source source = Okio.source(file);
-    try {
-      BufferedSink out = Okio.buffer(stream.getSink());
-      out.writeAll(source);
-      out.close();
-    } finally {
-      Util.closeQuietly(source);
+    stream.writeHeaders(responseHeaders, false, false);
+    try (Source source = Okio.source(file); BufferedSink sink = Okio.buffer(stream.getSink())) {
+      sink.writeAll(source);
     }
   }
 
@@ -185,7 +182,7 @@ public static void main(String... args) throws Exception {
     }
 
     Http2Server server = new Http2Server(new File(args[0]),
-        SslClient.localhost().sslContext.getSocketFactory());
+        localhost().sslContext().getSocketFactory());
     server.run();
   }
 }
diff --git a/okcurl/build.gradle b/okcurl/build.gradle
new file mode 100644
index 0000000000..955ab58295
--- /dev/null
+++ b/okcurl/build.gradle
@@ -0,0 +1,38 @@
+apply plugin: 'com.vanniktech.maven.publish'
+
+jar {
+  manifest {
+    attributes 'Automatic-Module-Name': 'okhttp3.curl'
+    attributes 'Main-Class': 'okhttp3.curl.Main'
+  }
+}
+
+// resources-templates.
+sourceSets {
+  main.resources.srcDirs += "$buildDir/generated/resources-templates"
+}
+compileJava {
+  dependsOn 'copyResourcesTemplates'
+}
+task copyResourcesTemplates(type: Copy) {
+  from 'src/main/resources-templates'
+  into "$buildDir/generated/resources-templates"
+  expand('projectVersion': "$VERSION_NAME")
+  filteringCharset = 'UTF-8'
+}
+
+dependencies {
+  api project(':okhttp')
+  api project(':okhttp-logging-interceptor')
+  implementation deps.airline
+  implementation deps.guava
+
+  testImplementation project(':okhttp-testing-support')
+  testImplementation deps.junit
+  testImplementation deps.assertj
+}
+
+apply plugin: 'com.github.johnrengelman.shadow'
+shadowJar {
+  mergeServiceFiles()
+}
diff --git a/okcurl/gradle.properties b/okcurl/gradle.properties
new file mode 100644
index 0000000000..ae701b79bd
--- /dev/null
+++ b/okcurl/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=okcurl
+POM_NAME=okcurl
+POM_PACKAGING=jar
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
deleted file mode 100644
index f6dfcd54ca..0000000000
--- a/okcurl/pom.xml
+++ /dev/null
@@ -1,109 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.11.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okcurl</artifactId>
-  <name>OkCurl</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.bouncycastle</groupId>
-      <artifactId>bcprov-jdk15on</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>io.airlift</groupId>
-      <artifactId>airline</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <resources>
-      <resource>
-        <directory>src/main/resources</directory>
-        <filtering>true</filtering>
-      </resource>
-    </resources>
-
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <version>3.0.0</version>
-        <configuration>
-          <descriptorRefs>
-            <descriptorRef>jar-with-dependencies</descriptorRef>
-          </descriptorRefs>
-          <archive>
-            <manifest>
-              <mainClass>okhttp3.curl.Main</mainClass>
-            </manifest>
-          </archive>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>single</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.skife.maven</groupId>
-        <artifactId>really-executable-jar-maven-plugin</artifactId>
-        <version>1.1.0</version>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>really-executable-jar</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <flags>-Xbootclasspath/p:$0</flags>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.curl</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okcurl/src/main/java/okhttp3/curl/Main.java b/okcurl/src/main/java/okhttp3/curl/Main.java
index cee2600619..22c8b5c45c 100644
--- a/okcurl/src/main/java/okhttp3/curl/Main.java
+++ b/okcurl/src/main/java/okhttp3/curl/Main.java
@@ -33,7 +33,6 @@
 import java.util.logging.SimpleFormatter;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
@@ -48,6 +47,8 @@
 import okhttp3.internal.http.StatusLine;
 import okhttp3.internal.http2.Http2;
 import okhttp3.internal.platform.Platform;
+import okhttp3.logging.HttpLoggingInterceptor;
+import okhttp3.logging.LoggingEventListener;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
@@ -102,6 +103,11 @@ private static String protocols() {
   @Option(name = "--read-timeout", description = "Maximum time allowed for reading data (seconds)")
   public int readTimeout = DEFAULT_TIMEOUT;
 
+  @Option(
+      name = "--call-timeout",
+      description = "Maximum time allowed for the entire call (seconds)")
+  public int callTimeout = DEFAULT_TIMEOUT;
+
   @Option(name = {"-L", "--location"}, description = "Follow redirects")
   public boolean followRedirects;
 
@@ -121,6 +127,11 @@ private static String protocols() {
   @Option(name = {"-V", "--version"}, description = "Show version number and quit")
   public boolean version;
 
+  @Option(
+      name = {"-v", "--verbose"},
+      description = "Makes " + NAME + " verbose during the operation")
+  public boolean verbose;
+
   @Arguments(title = "url", description = "Remote resource URL")
   public String url;
 
@@ -157,7 +168,7 @@ private static String protocols() {
       Sink out = Okio.sink(System.out);
       BufferedSource source = response.body().source();
       while (!source.exhausted()) {
-        out.write(source.buffer(), source.buffer().size());
+        out.write(source.getBuffer(), source.getBuffer().size());
         out.flush();
       }
 
@@ -178,12 +189,19 @@ private OkHttpClient createClient() {
     if (readTimeout != DEFAULT_TIMEOUT) {
       builder.readTimeout(readTimeout, SECONDS);
     }
+    if (callTimeout != DEFAULT_TIMEOUT) {
+      builder.callTimeout(callTimeout, SECONDS);
+    }
     if (allowInsecure) {
       X509TrustManager trustManager = createInsecureTrustManager();
       SSLSocketFactory sslSocketFactory = createInsecureSslSocketFactory(trustManager);
       builder.sslSocketFactory(sslSocketFactory, trustManager);
       builder.hostnameVerifier(createInsecureHostnameVerifier());
     }
+    if (verbose) {
+      HttpLoggingInterceptor.Logger logger = System.out::println;
+      builder.eventListenerFactory(new LoggingEventListener.Factory(logger));
+    }
     return builder.build();
   }
 
@@ -267,11 +285,7 @@ private static SSLSocketFactory createInsecureSslSocketFactory(TrustManager trus
   }
 
   private static HostnameVerifier createInsecureHostnameVerifier() {
-    return new HostnameVerifier() {
-      @Override public boolean verify(String s, SSLSession sslSession) {
-        return true;
-      }
-    };
+    return (name, session) -> true;
   }
 
   private static void enableHttp2FrameLogging() {
diff --git a/okcurl/src/main/resources-templates/okcurl-version.properties b/okcurl/src/main/resources-templates/okcurl-version.properties
new file mode 100644
index 0000000000..a15427847c
--- /dev/null
+++ b/okcurl/src/main/resources-templates/okcurl-version.properties
@@ -0,0 +1 @@
+version=${projectVersion}
diff --git a/okcurl/src/main/resources/okcurl-version.properties b/okcurl/src/main/resources/okcurl-version.properties
deleted file mode 100644
index defbd48204..0000000000
--- a/okcurl/src/main/resources/okcurl-version.properties
+++ /dev/null
@@ -1 +0,0 @@
-version=${project.version}
diff --git a/okcurl/src/test/java/okhttp3/curl/MainTest.java b/okcurl/src/test/java/okhttp3/curl/MainTest.java
index 12fe6d5ec4..6277c93f8a 100644
--- a/okcurl/src/test/java/okhttp3/curl/MainTest.java
+++ b/okcurl/src/test/java/okhttp3/curl/MainTest.java
@@ -22,72 +22,79 @@
 import org.junit.Test;
 
 import static okhttp3.curl.Main.fromArgs;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class MainTest {
   @Test public void simple() {
     Request request = fromArgs("http://example.com").createRequest();
-    assertEquals("GET", request.method());
-    assertEquals("http://example.com/", request.url().toString());
-    assertNull(request.body());
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void put() throws IOException {
     Request request = fromArgs("-X", "PUT", "-d", "foo", "http://example.com").createRequest();
-    assertEquals("PUT", request.method());
-    assertEquals("http://example.com/", request.url().toString());
-    assertEquals(3, request.body().contentLength());
+    assertThat(request.method()).isEqualTo("PUT");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/");
+    assertThat(request.body().contentLength()).isEqualTo(3);
   }
 
   @Test public void dataPost() {
     Request request = fromArgs("-d", "foo", "http://example.com").createRequest();
     RequestBody body = request.body();
-    assertEquals("POST", request.method());
-    assertEquals("http://example.com/", request.url().toString());
-    assertEquals("application/x-www-form-urlencoded; charset=utf-8", body.contentType().toString());
-    assertEquals("foo", bodyAsString(body));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/");
+    assertThat(body.contentType().toString()).isEqualTo(
+        "application/x-www-form-urlencoded; charset=utf-8");
+    assertThat(bodyAsString(body)).isEqualTo("foo");
   }
 
   @Test public void dataPut() {
     Request request = fromArgs("-d", "foo", "-X", "PUT", "http://example.com").createRequest();
     RequestBody body = request.body();
-    assertEquals("PUT", request.method());
-    assertEquals("http://example.com/", request.url().toString());
-    assertEquals("application/x-www-form-urlencoded; charset=utf-8", body.contentType().toString());
-    assertEquals("foo", bodyAsString(body));
+    assertThat(request.method()).isEqualTo("PUT");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/");
+    assertThat(body.contentType().toString()).isEqualTo(
+        "application/x-www-form-urlencoded; charset=utf-8");
+    assertThat(bodyAsString(body)).isEqualTo("foo");
   }
 
   @Test public void contentTypeHeader() {
     Request request = fromArgs("-d", "foo", "-H", "Content-Type: application/json",
         "http://example.com").createRequest();
     RequestBody body = request.body();
-    assertEquals("POST", request.method());
-    assertEquals("http://example.com/", request.url().toString());
-    assertEquals("application/json; charset=utf-8", body.contentType().toString());
-    assertEquals("foo", bodyAsString(body));
+    assertThat(request.method()).isEqualTo("POST");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/");
+    assertThat(body.contentType().toString()).isEqualTo("application/json; charset=utf-8");
+    assertThat(bodyAsString(body)).isEqualTo("foo");
   }
 
   @Test public void referer() {
     Request request = fromArgs("-e", "foo", "http://example.com").createRequest();
-    assertEquals("GET", request.method());
-    assertEquals("http://example.com/", request.url().toString());
-    assertEquals("foo", request.header("Referer"));
-    assertNull(request.body());
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/");
+    assertThat(request.header("Referer")).isEqualTo("foo");
+    assertThat(request.body()).isNull();
   }
 
   @Test public void userAgent() {
     Request request = fromArgs("-A", "foo", "http://example.com").createRequest();
-    assertEquals("GET", request.method());
-    assertEquals("http://example.com/", request.url().toString());
-    assertEquals("foo", request.header("User-Agent"));
-    assertNull(request.body());
+    assertThat(request.method()).isEqualTo("GET");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/");
+    assertThat(request.header("User-Agent")).isEqualTo("foo");
+    assertThat(request.body()).isNull();
+  }
+
+  @Test public void defaultUserAgent() {
+    Request request = fromArgs("http://example.com").createRequest();
+    assertThat(request.header("User-Agent")).startsWith("okcurl/");
   }
 
   @Test public void headerSplitWithDate() {
     Request request = fromArgs("-H", "If-Modified-Since: Mon, 18 Aug 2014 15:16:06 GMT",
         "http://example.com").createRequest();
-    assertEquals("Mon, 18 Aug 2014 15:16:06 GMT", request.header("If-Modified-Since"));
+    assertThat(request.header("If-Modified-Since")).isEqualTo(
+        "Mon, 18 Aug 2014 15:16:06 GMT");
   }
 
   private static String bodyAsString(RequestBody body) {
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
deleted file mode 100644
index e31fa73c85..0000000000
--- a/okhttp-android-support/pom.xml
+++ /dev/null
@@ -1,76 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.11.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-android-support</artifactId>
-  <name>OkHttp Android Platform Support</name>
-  <description>Classes to support the Android platform's use of OkHttp (not required for most
-    developers).
-  </description>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-urlconnection</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.10.4</version>
-        <configuration>
-          <excludePackageNames>okhttp3.internal.*</excludePackageNames>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.androidsupport</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java b/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
deleted file mode 100644
index de5788539a..0000000000
--- a/okhttp-android-support/src/main/java/okhttp3/AndroidInternal.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.ResponseCache;
-import okhttp3.internal.huc.CacheAdapter;
-
-/**
- * Back doors to enable the use of OkHttp within the Android platform libraries. OkHttp is used to
- * provide the default {@link java.net.HttpURLConnection} / {@link javax.net.ssl.HttpsURLConnection}
- * implementation including support for a custom {@link ResponseCache}.
- */
-public class AndroidInternal {
-
-  private AndroidInternal() {
-  }
-
-  /** Sets the response cache to be used to read and write cached responses. */
-  public static void setResponseCache(OkUrlFactory okUrlFactory, ResponseCache responseCache) {
-    OkHttpClient.Builder builder = okUrlFactory.client().newBuilder();
-    if (responseCache instanceof OkCacheContainer) {
-      // Avoid adding layers of wrappers. Rather than wrap the ResponseCache in yet another layer to
-      // make the ResponseCache look like an InternalCache, we can unwrap the Cache instead.
-      // This means that Cache stats will be correctly updated.
-      OkCacheContainer okCacheContainer = (OkCacheContainer) responseCache;
-      builder.cache(okCacheContainer.getCache());
-    } else {
-      builder.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
-    }
-    okUrlFactory.setClient(builder.build());
-  }
-}
diff --git a/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java b/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
deleted file mode 100644
index c46a0cb9fd..0000000000
--- a/okhttp-android-support/src/main/java/okhttp3/AndroidShimResponseCache.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-import okhttp3.internal.huc.JavaApiConverter;
-
-/**
- * A class provided for use by Android so that it can continue supporting a {@link ResponseCache}
- * with stats.
- */
-public class AndroidShimResponseCache extends ResponseCache {
-
-  private final Cache delegate;
-
-  private AndroidShimResponseCache(Cache delegate) {
-    this.delegate = delegate;
-  }
-
-  public static AndroidShimResponseCache create(File directory, long maxSize) throws IOException {
-    Cache cache = new Cache(directory, maxSize);
-    return new AndroidShimResponseCache(cache);
-  }
-
-  public boolean isEquivalent(File directory, long maxSize) {
-    Cache installedCache = getCache();
-    return (installedCache.directory().equals(directory)
-        && installedCache.maxSize() == maxSize
-        && !installedCache.isClosed());
-  }
-
-  public Cache getCache() {
-    return delegate;
-  }
-
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) throws IOException {
-    Request okRequest = JavaApiConverter.createOkRequest(uri, requestMethod, requestHeaders);
-    Response okResponse = delegate.internalCache.get(okRequest);
-    if (okResponse == null) {
-      return null;
-    }
-    return JavaApiConverter.createJavaCacheResponse(okResponse);
-  }
-
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    Response okResponse = JavaApiConverter.createOkResponseForCachePut(uri, urlConnection);
-    if (okResponse == null) {
-      // The URLConnection is not cacheable or could not be converted. Stop.
-      return null;
-    }
-    okhttp3.internal.cache.CacheRequest okCacheRequest =
-        delegate.internalCache.put(okResponse);
-    if (okCacheRequest == null) {
-      return null;
-    }
-    return JavaApiConverter.createJavaCacheRequest(okCacheRequest);
-  }
-
-  /**
-   * Returns the number of bytes currently being used to store the values in this cache. This may be
-   * greater than the {@link #maxSize} if a background deletion is pending.
-   */
-  public long size() throws IOException {
-    return delegate.size();
-  }
-
-  /**
-   * Returns the maximum number of bytes that this cache should use to store its data.
-   */
-  public long maxSize() {
-    return delegate.maxSize();
-  }
-
-  /**
-   * Force buffered operations to the filesystem. This ensures that responses written to the cache
-   * will be available the next time the cache is opened, even if this process is killed.
-   */
-  public void flush() throws IOException {
-    delegate.flush();
-  }
-
-  /**
-   * Returns the number of HTTP requests that required the network to either supply a response or
-   * validate a locally cached response.
-   */
-  public int getNetworkCount() {
-    return delegate.networkCount();
-  }
-
-  /**
-   * Returns the number of HTTP requests whose response was provided by the cache. This may include
-   * conditional {@code GET} requests that were validated over the network.
-   */
-  public int getHitCount() {
-    return delegate.hitCount();
-  }
-
-  /**
-   * Returns the total number of HTTP requests that were made. This includes both client requests
-   * and requests that were made on the client's behalf to handle a redirects and retries.
-   */
-  public int getRequestCount() {
-    return delegate.requestCount();
-  }
-
-  /**
-   * Uninstalls the cache and releases any active resources. Stored contents will remain on the
-   * filesystem.
-   */
-  public void close() throws IOException {
-    delegate.close();
-  }
-
-  /**
-   * Uninstalls the cache and deletes all of its stored contents.
-   */
-  public void delete() throws IOException {
-    delegate.delete();
-  }
-}
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
deleted file mode 100644
index 5bca95b937..0000000000
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/CacheAdapter.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.util.List;
-import java.util.Map;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.cache.CacheRequest;
-import okhttp3.internal.cache.CacheStrategy;
-import okhttp3.internal.cache.InternalCache;
-import okio.Okio;
-import okio.Sink;
-
-/** Adapts {@link ResponseCache} to {@link InternalCache}. */
-public final class CacheAdapter implements InternalCache {
-  private final ResponseCache delegate;
-
-  public CacheAdapter(ResponseCache delegate) {
-    this.delegate = delegate;
-  }
-
-  public ResponseCache getDelegate() {
-    return delegate;
-  }
-
-  @Override public Response get(Request request) throws IOException {
-    CacheResponse javaResponse = getJavaCachedResponse(request);
-    if (javaResponse == null) {
-      return null;
-    }
-    return JavaApiConverter.createOkResponseForCacheGet(request, javaResponse);
-  }
-
-  @Override public CacheRequest put(Response response) throws IOException {
-    URI uri = response.request().url().uri();
-    HttpURLConnection connection = JavaApiConverter.createJavaUrlConnectionForCachePut(response);
-    final java.net.CacheRequest request = delegate.put(uri, connection);
-    if (request == null) {
-      return null;
-    }
-    return new CacheRequest() {
-      @Override public Sink body() throws IOException {
-        OutputStream body = request.getBody();
-        return body != null ? Okio.sink(body) : null;
-      }
-
-      @Override public void abort() {
-        request.abort();
-      }
-    };
-  }
-
-  @Override public void remove(Request request) throws IOException {
-    // This method is treated as optional and there is no obvious way of implementing it with
-    // ResponseCache. Removing items from the cache due to modifications made from this client is
-    // not essential given that modifications could be made from any other client. We have to assume
-    // that it's ok to keep using the cached data. Otherwise the server shouldn't declare it as
-    // cacheable or the client should be careful about caching it.
-  }
-
-  @Override public void update(Response cached, Response network) {
-    // This method is treated as optional and there is no obvious way of implementing it with
-    // ResponseCache. Updating headers is useful if the server changes the metadata for a resource
-    // (e.g. max age) to extend or truncate the life of that resource in the cache. If the metadata
-    // is not updated the caching behavior may not be optimal, but will obey the metadata sent
-    // with the original cached response.
-  }
-
-  @Override public void trackConditionalCacheHit() {
-    // This method is optional.
-  }
-
-  @Override public void trackResponse(CacheStrategy cacheStrategy) {
-    // This method is optional.
-  }
-
-  /**
-   * Returns the {@link CacheResponse} from the delegate by converting the OkHttp {@link Request}
-   * into the arguments required by the {@link ResponseCache}.
-   */
-  private CacheResponse getJavaCachedResponse(Request request) throws IOException {
-    Map<String, List<String>> headers = JavaApiConverter.extractJavaHeaders(request);
-    return delegate.get(request.url().uri(), request.method(), headers);
-  }
-}
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
deleted file mode 100644
index 1dec85cdc0..0000000000
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
+++ /dev/null
@@ -1,892 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.SecureCacheResponse;
-import java.net.URI;
-import java.net.URLConnection;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.CipherSuite;
-import okhttp3.Handshake;
-import okhttp3.Headers;
-import okhttp3.MediaType;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.TlsVersion;
-import okhttp3.internal.Internal;
-import okhttp3.internal.JavaNetHeaders;
-import okhttp3.internal.Util;
-import okhttp3.internal.cache.CacheRequest;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.StatusLine;
-import okhttp3.internal.platform.Platform;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Sink;
-
-/**
- * Helper methods that convert between Java and OkHttp representations.
- */
-public final class JavaApiConverter {
-  /** Synthetic response header: the local time when the request was sent. */
-  private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
-
-  /** Synthetic response header: the local time when the response was received. */
-  private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
-
-  private JavaApiConverter() {
-  }
-
-  /**
-   * Creates an OkHttp {@link Response} using the supplied {@link URI} and {@link URLConnection} to
-   * supply the data. The URLConnection is assumed to already be connected. If this method returns
-   * {@code null} the response is uncacheable.
-   */
-  public static Response createOkResponseForCachePut(URI uri, URLConnection urlConnection)
-      throws IOException {
-
-    HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
-
-    Response.Builder okResponseBuilder = new Response.Builder();
-
-    // Request: Create one from the URL connection.
-    Headers responseHeaders = createHeaders(urlConnection.getHeaderFields());
-    // Some request headers are needed for Vary caching.
-    Headers varyHeaders = varyHeaders(urlConnection, responseHeaders);
-    if (varyHeaders == null) {
-      return null;
-    }
-
-    // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
-    String requestMethod = httpUrlConnection.getRequestMethod();
-    RequestBody placeholderBody = HttpMethod.requiresRequestBody(requestMethod)
-        ? Util.EMPTY_REQUEST
-        : null;
-
-    Request okRequest = new Request.Builder()
-        .url(uri.toString())
-        .method(requestMethod, placeholderBody)
-        .headers(varyHeaders)
-        .build();
-    okResponseBuilder.request(okRequest);
-
-    // Status line
-    StatusLine statusLine = StatusLine.parse(extractStatusLine(httpUrlConnection));
-    okResponseBuilder.protocol(statusLine.protocol);
-    okResponseBuilder.code(statusLine.code);
-    okResponseBuilder.message(statusLine.message);
-
-    // A network response is required for the Cache to find any Vary headers it needs.
-    Response networkResponse = okResponseBuilder.build();
-    okResponseBuilder.networkResponse(networkResponse);
-
-    // Response headers
-    Headers okHeaders = extractOkResponseHeaders(httpUrlConnection, okResponseBuilder);
-    okResponseBuilder.headers(okHeaders);
-
-    // Response body
-    ResponseBody okBody = createOkBody(urlConnection);
-    okResponseBuilder.body(okBody);
-
-    // Handle SSL handshake information as needed.
-    if (httpUrlConnection instanceof HttpsURLConnection) {
-      HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) httpUrlConnection;
-
-      Certificate[] peerCertificates;
-      try {
-        peerCertificates = httpsUrlConnection.getServerCertificates();
-      } catch (SSLPeerUnverifiedException e) {
-        peerCertificates = null;
-      }
-
-      Certificate[] localCertificates = httpsUrlConnection.getLocalCertificates();
-
-      String cipherSuiteString = httpsUrlConnection.getCipherSuite();
-      CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-      Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, cipherSuite,
-          nullSafeImmutableList(peerCertificates), nullSafeImmutableList(localCertificates));
-      okResponseBuilder.handshake(handshake);
-    }
-
-    return okResponseBuilder.build();
-  }
-
-  /**
-   * Returns headers for the header names and values in the {@link Map}.
-   */
-  private static Headers createHeaders(Map<String, List<String>> headers) {
-    Headers.Builder builder = new Headers.Builder();
-    for (Map.Entry<String, List<String>> header : headers.entrySet()) {
-      if (header.getKey() == null || header.getValue() == null) {
-        continue;
-      }
-      String name = header.getKey().trim();
-      for (String value : header.getValue()) {
-        String trimmedValue = value.trim();
-        Internal.instance.addLenient(builder, name, trimmedValue);
-      }
-    }
-    return builder.build();
-  }
-
-  private static Headers varyHeaders(URLConnection urlConnection, Headers responseHeaders) {
-    if (HttpHeaders.hasVaryAll(responseHeaders)) {
-      // "*" means that this will be treated as uncacheable anyway.
-      return null;
-    }
-    Set<String> varyFields = HttpHeaders.varyFields(responseHeaders);
-    if (varyFields.isEmpty()) {
-      return new Headers.Builder().build();
-    }
-
-    // This probably indicates another HTTP stack is trying to use the shared ResponseCache.
-    // We cannot guarantee this case will work properly because we cannot reliably extract *all*
-    // the request header values, and we can't get multiple Vary request header values.
-    // We also can't be sure about the Accept-Encoding behavior of other stacks.
-    if (!(urlConnection instanceof CacheHttpURLConnection
-        || urlConnection instanceof CacheHttpsURLConnection)) {
-      return null;
-    }
-
-    // This is the case we expect: The URLConnection is from a call to
-    // JavaApiConverter.createJavaUrlConnection() and we have access to the user's request headers.
-    Map<String, List<String>> requestProperties = urlConnection.getRequestProperties();
-    Headers.Builder result = new Headers.Builder();
-    for (String fieldName : varyFields) {
-      List<String> fieldValues = requestProperties.get(fieldName);
-      if (fieldValues == null) {
-        if (fieldName.equals("Accept-Encoding")) {
-          // Accept-Encoding is special. If OkHttp sees Accept-Encoding is unset it will add
-          // "gzip". We don't have access to the request that was actually made so we must do the
-          // same.
-          result.add("Accept-Encoding", "gzip");
-        }
-      } else {
-        for (String fieldValue : fieldValues) {
-          Internal.instance.addLenient(result, fieldName, fieldValue);
-        }
-      }
-    }
-    return result.build();
-  }
-
-  /**
-   * Creates an OkHttp {@link Response} using the supplied {@link Request} and {@link CacheResponse}
-   * to supply the data.
-   */
-  static Response createOkResponseForCacheGet(Request request, CacheResponse javaResponse)
-      throws IOException {
-
-    // Build a cache request for the response to use.
-    Headers responseHeaders = createHeaders(javaResponse.getHeaders());
-    Headers varyHeaders;
-    if (HttpHeaders.hasVaryAll(responseHeaders)) {
-      // "*" means that this will be treated as uncacheable anyway.
-      varyHeaders = new Headers.Builder().build();
-    } else {
-      varyHeaders = HttpHeaders.varyHeaders(request.headers(), responseHeaders);
-    }
-
-    Request cacheRequest = new Request.Builder()
-        .url(request.url())
-        .method(request.method(), null)
-        .headers(varyHeaders)
-        .build();
-
-    Response.Builder okResponseBuilder = new Response.Builder();
-
-    // Request: Use the cacheRequest we built.
-    okResponseBuilder.request(cacheRequest);
-
-    // Status line: Java has this as one of the headers.
-    StatusLine statusLine = StatusLine.parse(extractStatusLine(javaResponse));
-    okResponseBuilder.protocol(statusLine.protocol);
-    okResponseBuilder.code(statusLine.code);
-    okResponseBuilder.message(statusLine.message);
-
-    // Response headers
-    Headers okHeaders = extractOkHeaders(javaResponse, okResponseBuilder);
-    okResponseBuilder.headers(okHeaders);
-
-    // Response body
-    ResponseBody okBody = createOkBody(okHeaders, javaResponse);
-    okResponseBuilder.body(okBody);
-
-    // Handle SSL handshake information as needed.
-    if (javaResponse instanceof SecureCacheResponse) {
-      SecureCacheResponse javaSecureCacheResponse = (SecureCacheResponse) javaResponse;
-
-      // Handshake doesn't support null lists.
-      List<Certificate> peerCertificates;
-      try {
-        peerCertificates = javaSecureCacheResponse.getServerCertificateChain();
-      } catch (SSLPeerUnverifiedException e) {
-        peerCertificates = Collections.emptyList();
-      }
-      List<Certificate> localCertificates = javaSecureCacheResponse.getLocalCertificateChain();
-      if (localCertificates == null) {
-        localCertificates = Collections.emptyList();
-      }
-
-      String cipherSuiteString = javaSecureCacheResponse.getCipherSuite();
-      CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-      Handshake handshake = Handshake.get(
-          TlsVersion.SSL_3_0, cipherSuite, peerCertificates, localCertificates);
-      okResponseBuilder.handshake(handshake);
-    }
-
-    return okResponseBuilder.build();
-  }
-
-  /**
-   * Creates an OkHttp {@link Request} from the supplied information.
-   *
-   * <p>This method allows a {@code null} value for {@code requestHeaders} for situations where a
-   * connection is already connected and access to the headers has been lost. See {@link
-   * java.net.HttpURLConnection#getRequestProperties()} for details.
-   */
-  public static Request createOkRequest(
-      URI uri, String requestMethod, Map<String, List<String>> requestHeaders) {
-    // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
-    RequestBody placeholderBody = HttpMethod.requiresRequestBody(requestMethod)
-        ? Util.EMPTY_REQUEST
-        : null;
-
-    Request.Builder builder = new Request.Builder()
-        .url(uri.toString())
-        .method(requestMethod, placeholderBody);
-
-    if (requestHeaders != null) {
-      Headers headers = extractOkHeaders(requestHeaders, null);
-      builder.headers(headers);
-    }
-    return builder.build();
-  }
-
-  /**
-   * Creates a {@link java.net.CacheResponse} of the correct (sub)type using information gathered
-   * from the supplied {@link Response}.
-   */
-  public static CacheResponse createJavaCacheResponse(final Response response) {
-    final Headers headers = withSyntheticHeaders(response);
-    final ResponseBody body = response.body();
-    if (response.request().isHttps()) {
-      final Handshake handshake = response.handshake();
-      return new SecureCacheResponse() {
-        @Override
-        public String getCipherSuite() {
-          return handshake != null ? handshake.cipherSuite().javaName() : null;
-        }
-
-        @Override
-        public List<Certificate> getLocalCertificateChain() {
-          if (handshake == null) return null;
-          // Java requires null, not an empty list here.
-          List<Certificate> certificates = handshake.localCertificates();
-          return certificates.size() > 0 ? certificates : null;
-        }
-
-        @Override
-        public List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException {
-          if (handshake == null) return null;
-          // Java requires null, not an empty list here.
-          List<Certificate> certificates = handshake.peerCertificates();
-          return certificates.size() > 0 ? certificates : null;
-        }
-
-        @Override
-        public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-          if (handshake == null) return null;
-          return handshake.peerPrincipal();
-        }
-
-        @Override
-        public Principal getLocalPrincipal() {
-          if (handshake == null) return null;
-          return handshake.localPrincipal();
-        }
-
-        @Override
-        public Map<String, List<String>> getHeaders() throws IOException {
-          // Java requires that the entry with a null key be the status line.
-          return JavaNetHeaders.toMultimap(headers, StatusLine.get(response).toString());
-        }
-
-        @Override
-        public InputStream getBody() throws IOException {
-          if (body == null) return null;
-          return body.byteStream();
-        }
-      };
-    } else {
-      return new CacheResponse() {
-        @Override
-        public Map<String, List<String>> getHeaders() throws IOException {
-          // Java requires that the entry with a null key be the status line.
-          return JavaNetHeaders.toMultimap(headers, StatusLine.get(response).toString());
-        }
-
-        @Override
-        public InputStream getBody() throws IOException {
-          if (body == null) return null;
-          return body.byteStream();
-        }
-      };
-    }
-  }
-
-  public static java.net.CacheRequest createJavaCacheRequest(final CacheRequest okCacheRequest) {
-    return new java.net.CacheRequest() {
-      @Override
-      public void abort() {
-        okCacheRequest.abort();
-      }
-
-      @Override
-      public OutputStream getBody() throws IOException {
-        Sink body = okCacheRequest.body();
-        if (body == null) {
-          return null;
-        }
-        return Okio.buffer(body).outputStream();
-      }
-    };
-  }
-
-  /**
-   * Creates an {@link java.net.HttpURLConnection} of the correct subclass from the supplied OkHttp
-   * {@link Response}.
-   */
-  static HttpURLConnection createJavaUrlConnectionForCachePut(Response okResponse) {
-    okResponse = okResponse.newBuilder()
-        .body(null)
-        .headers(withSyntheticHeaders(okResponse))
-        .build();
-    Request request = okResponse.request();
-    // Create an object of the correct class in case the ResponseCache uses instanceof.
-    if (request.isHttps()) {
-      return new CacheHttpsURLConnection(new CacheHttpURLConnection(okResponse));
-    } else {
-      return new CacheHttpURLConnection(okResponse);
-    }
-  }
-
-  private static Headers withSyntheticHeaders(Response okResponse) {
-    return okResponse.headers().newBuilder()
-        .add(SENT_MILLIS, Long.toString(okResponse.sentRequestAtMillis()))
-        .add(RECEIVED_MILLIS, Long.toString(okResponse.receivedResponseAtMillis()))
-        .build();
-  }
-
-  /**
-   * Extracts an immutable request header map from the supplied {@link Headers}.
-   */
-  static Map<String, List<String>> extractJavaHeaders(Request request) {
-    return JavaNetHeaders.toMultimap(request.headers(), null);
-  }
-
-  /**
-   * Extracts OkHttp headers from the supplied {@link java.net.CacheResponse}. Only real headers are
-   * extracted. See {@link #extractStatusLine(java.net.CacheResponse)}.
-   */
-  private static Headers extractOkHeaders(
-      CacheResponse javaResponse, Response.Builder okResponseBuilder) throws IOException {
-    Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
-    return extractOkHeaders(javaResponseHeaders, okResponseBuilder);
-  }
-
-  /**
-   * Extracts OkHttp headers from the supplied {@link java.net.HttpURLConnection}. Only real headers
-   * are extracted. See {@link #extractStatusLine(java.net.HttpURLConnection)}.
-   */
-  private static Headers extractOkResponseHeaders(
-      HttpURLConnection httpUrlConnection, Response.Builder okResponseBuilder) {
-    Map<String, List<String>> javaResponseHeaders = httpUrlConnection.getHeaderFields();
-    return extractOkHeaders(javaResponseHeaders, okResponseBuilder);
-  }
-
-  /**
-   * Extracts OkHttp headers from the supplied {@link Map}. Only real headers are extracted. Any
-   * entry (one with a {@code null} key) is discarded. Special internal headers used to track cache
-   * metadata are omitted from the result and added to {@code okResponseBuilder} instead.
-   */
-  // @VisibleForTesting
-  static Headers extractOkHeaders(
-      Map<String, List<String>> javaHeaders, Response.Builder okResponseBuilder) {
-    Headers.Builder okHeadersBuilder = new Headers.Builder();
-    for (Map.Entry<String, List<String>> javaHeader : javaHeaders.entrySet()) {
-      String name = javaHeader.getKey();
-      if (name == null) {
-        // The Java API uses the null key to store the status line in responses.
-        // Earlier versions of OkHttp would use the null key to store the "request line" in
-        // requests. e.g. "GET / HTTP 1.1". Although this is no longer the case it must be
-        // explicitly ignored because Headers.Builder does not support null keys.
-        continue;
-      }
-      if (okResponseBuilder != null && javaHeader.getValue().size() == 1) {
-        if (name.equals(SENT_MILLIS)) {
-          okResponseBuilder.sentRequestAtMillis(Long.valueOf(javaHeader.getValue().get(0)));
-          continue;
-        }
-        if (name.equals(RECEIVED_MILLIS)) {
-          okResponseBuilder.receivedResponseAtMillis(Long.valueOf(javaHeader.getValue().get(0)));
-          continue;
-        }
-      }
-      for (String value : javaHeader.getValue()) {
-        Internal.instance.addLenient(okHeadersBuilder, name, value);
-      }
-    }
-    return okHeadersBuilder.build();
-  }
-
-  /**
-   * Extracts the status line from the supplied Java API {@link java.net.HttpURLConnection}. As per
-   * the spec, the status line is held as the header with the null key. Returns {@code null} if
-   * there is no status line.
-   */
-  private static String extractStatusLine(HttpURLConnection httpUrlConnection) {
-    // Java specifies that this will be be response header with a null key.
-    return httpUrlConnection.getHeaderField(null);
-  }
-
-  /**
-   * Extracts the status line from the supplied Java API {@link java.net.CacheResponse}. As per the
-   * spec, the status line is held as the header with the null key. Throws a {@link
-   * ProtocolException} if there is no status line.
-   */
-  private static String extractStatusLine(CacheResponse javaResponse) throws IOException {
-    Map<String, List<String>> javaResponseHeaders = javaResponse.getHeaders();
-    return extractStatusLine(javaResponseHeaders);
-  }
-
-  // VisibleForTesting
-  static String extractStatusLine(Map<String, List<String>> javaResponseHeaders)
-      throws ProtocolException {
-    List<String> values = javaResponseHeaders.get(null);
-    if (values == null || values.size() == 0) {
-      // The status line is missing. This suggests a badly behaving cache.
-      throw new ProtocolException(
-          "CacheResponse is missing a \'null\' header containing the status line. Headers="
-              + javaResponseHeaders);
-    }
-    return values.get(0);
-  }
-
-  /**
-   * Creates an OkHttp Response.Body containing the supplied information.
-   */
-  private static ResponseBody createOkBody(final Headers okHeaders,
-      final CacheResponse cacheResponse) throws IOException {
-    final BufferedSource body = Okio.buffer(Okio.source(cacheResponse.getBody()));
-    return new ResponseBody() {
-      @Override
-      public MediaType contentType() {
-        String contentTypeHeader = okHeaders.get("Content-Type");
-        return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);
-      }
-
-      @Override
-      public long contentLength() {
-        return HttpHeaders.contentLength(okHeaders);
-      }
-
-      @Override public BufferedSource source() {
-        return body;
-      }
-    };
-  }
-
-  /**
-   * Creates an OkHttp Response.Body containing the supplied information.
-   */
-  private static ResponseBody createOkBody(final URLConnection urlConnection) throws IOException {
-    if (!urlConnection.getDoInput()) {
-      return null;
-    }
-
-    final BufferedSource body = Okio.buffer(Okio.source(urlConnection.getInputStream()));
-    return new ResponseBody() {
-      @Override public MediaType contentType() {
-        String contentTypeHeader = urlConnection.getContentType();
-        return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);
-      }
-
-      @Override public long contentLength() {
-        String s = urlConnection.getHeaderField("Content-Length");
-        return stringToLong(s);
-      }
-
-      @Override public BufferedSource source() {
-        return body;
-      }
-    };
-  }
-
-  /**
-   * An {@link java.net.HttpURLConnection} that represents an HTTP request at the point where the
-   * request has been made, and the response headers have been received, but the body content, if
-   * present, has not been read yet. This intended to provide enough information for {@link
-   * java.net.ResponseCache} subclasses and no more.
-   *
-   * <p>Much of the method implementations are overrides to delegate to the OkHttp request and
-   * response, or to deny access to information as a real HttpURLConnection would after connection.
-   */
-  private static final class CacheHttpURLConnection extends HttpURLConnection {
-
-    private final Request request;
-    private final Response response;
-
-    CacheHttpURLConnection(Response response) {
-      super(response.request().url().url());
-      this.request = response.request();
-      this.response = response;
-
-      // Configure URLConnection inherited fields.
-      this.connected = true;
-      this.doOutput = request.body() != null;
-      this.doInput = true;
-      this.useCaches = true;
-
-      // Configure HttpUrlConnection inherited fields.
-      this.method = request.method();
-    }
-
-    // HTTP connection lifecycle methods
-
-    @Override
-    public void connect() throws IOException {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public void disconnect() {
-      throw throwRequestModificationException();
-    }
-
-    // HTTP Request methods
-
-    @Override
-    public void setRequestProperty(String key, String value) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public void addRequestProperty(String key, String value) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public String getRequestProperty(String key) {
-      return request.header(key);
-    }
-
-    @Override
-    public Map<String, List<String>> getRequestProperties() {
-      // The RI and OkHttp's HttpURLConnectionImpl fail this call after connect() as required by the
-      // spec. There seems no good reason why this should fail while getRequestProperty() is ok.
-      // We don't fail here, because we need all request header values for caching Vary responses
-      // correctly.
-      return JavaNetHeaders.toMultimap(request.headers(), null);
-    }
-
-    @Override
-    public void setFixedLengthStreamingMode(int contentLength) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public void setFixedLengthStreamingMode(long contentLength) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public void setChunkedStreamingMode(int chunklen) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public void setInstanceFollowRedirects(boolean followRedirects) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public boolean getInstanceFollowRedirects() {
-      // Return the platform default.
-      return super.getInstanceFollowRedirects();
-    }
-
-    @Override
-    public void setRequestMethod(String method) throws ProtocolException {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public String getRequestMethod() {
-      return request.method();
-    }
-
-    // HTTP Response methods
-
-    @Override
-    public String getHeaderFieldKey(int position) {
-      // Deal with index 0 meaning "status line"
-      if (position < 0) {
-        throw new IllegalArgumentException("Invalid header index: " + position);
-      }
-      if (position == 0 || position > response.headers().size()) {
-        return null;
-      }
-      return response.headers().name(position - 1);
-    }
-
-    @Override
-    public String getHeaderField(int position) {
-      // Deal with index 0 meaning "status line"
-      if (position < 0) {
-        throw new IllegalArgumentException("Invalid header index: " + position);
-      }
-      if (position == 0) {
-        return StatusLine.get(response).toString();
-      }
-      if (position > response.headers().size()) {
-        return null;
-      }
-      return response.headers().value(position - 1);
-    }
-
-    @Override
-    public String getHeaderField(String fieldName) {
-      return fieldName == null
-          ? StatusLine.get(response).toString()
-          : response.headers().get(fieldName);
-    }
-
-    @Override
-    public Map<String, List<String>> getHeaderFields() {
-      return JavaNetHeaders.toMultimap(response.headers(), StatusLine.get(response).toString());
-    }
-
-    @Override
-    public int getResponseCode() throws IOException {
-      return response.code();
-    }
-
-    @Override
-    public String getResponseMessage() throws IOException {
-      return response.message();
-    }
-
-    @Override
-    public InputStream getErrorStream() {
-      return null;
-    }
-
-    // HTTP miscellaneous methods
-
-    @Override
-    public boolean usingProxy() {
-      // It's safe to return false here, even if a proxy is in use. The problem is we don't
-      // necessarily know if we're going to use a proxy by the time we ask the cache for a response.
-      return false;
-    }
-
-    // URLConnection methods
-
-    @Override
-    public void setConnectTimeout(int timeout) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public int getConnectTimeout() {
-      // Impossible to say.
-      return 0;
-    }
-
-    @Override
-    public void setReadTimeout(int timeout) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public int getReadTimeout() {
-      // Impossible to say.
-      return 0;
-    }
-
-    @Override
-    public Object getContent() throws IOException {
-      throw throwResponseBodyAccessException();
-    }
-
-    @Override
-    public Object getContent(Class[] classes) throws IOException {
-      throw throwResponseBodyAccessException();
-    }
-
-    @Override
-    public InputStream getInputStream() throws IOException {
-      return new InputStream() {
-        @Override public int read() throws IOException {
-          throw throwResponseBodyAccessException();
-        }
-      };
-    }
-
-    @Override
-    public OutputStream getOutputStream() throws IOException {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public void setDoInput(boolean doInput) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public boolean getDoInput() {
-      return doInput;
-    }
-
-    @Override
-    public void setDoOutput(boolean doOutput) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public boolean getDoOutput() {
-      return doOutput;
-    }
-
-    @Override
-    public void setAllowUserInteraction(boolean allowUserInteraction) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public boolean getAllowUserInteraction() {
-      return false;
-    }
-
-    @Override
-    public void setUseCaches(boolean useCaches) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public boolean getUseCaches() {
-      return super.getUseCaches();
-    }
-
-    @Override
-    public void setIfModifiedSince(long ifModifiedSince) {
-      throw throwRequestModificationException();
-    }
-
-    @Override
-    public long getIfModifiedSince() {
-      return stringToLong(request.headers().get("If-Modified-Since"));
-    }
-
-    @Override
-    public boolean getDefaultUseCaches() {
-      return super.getDefaultUseCaches();
-    }
-
-    @Override
-    public void setDefaultUseCaches(boolean defaultUseCaches) {
-      super.setDefaultUseCaches(defaultUseCaches);
-    }
-  }
-
-  /** An HttpsURLConnection to offer to the cache. */
-  private static final class CacheHttpsURLConnection extends DelegatingHttpsURLConnection {
-    private final CacheHttpURLConnection delegate;
-
-    CacheHttpsURLConnection(CacheHttpURLConnection delegate) {
-      super(delegate);
-      this.delegate = delegate;
-    }
-
-    @Override protected Handshake handshake() {
-      return delegate.response.handshake();
-    }
-
-    @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
-      throw throwRequestModificationException();
-    }
-
-    @Override public HostnameVerifier getHostnameVerifier() {
-      throw throwRequestSslAccessException();
-    }
-
-    @Override public void setSSLSocketFactory(SSLSocketFactory socketFactory) {
-      throw throwRequestModificationException();
-    }
-
-    @Override public SSLSocketFactory getSSLSocketFactory() {
-      throw throwRequestSslAccessException();
-    }
-  }
-
-  private static RuntimeException throwRequestModificationException() {
-    throw new UnsupportedOperationException("ResponseCache cannot modify the request.");
-  }
-
-  private static RuntimeException throwRequestHeaderAccessException() {
-    throw new UnsupportedOperationException("ResponseCache cannot access request headers");
-  }
-
-  private static RuntimeException throwRequestSslAccessException() {
-    throw new UnsupportedOperationException("ResponseCache cannot access SSL internals");
-  }
-
-  private static RuntimeException throwResponseBodyAccessException() {
-    throw new UnsupportedOperationException("ResponseCache cannot access the response body.");
-  }
-
-  private static <T> List<T> nullSafeImmutableList(T[] elements) {
-    return elements == null ? Collections.<T>emptyList() : Util.immutableList(elements);
-  }
-
-  private static long stringToLong(String s) {
-    if (s == null) return -1;
-    try {
-      return Long.parseLong(s);
-    } catch (NumberFormatException e) {
-      return -1;
-    }
-  }
-}
diff --git a/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java b/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java
deleted file mode 100644
index d755487c92..0000000000
--- a/okhttp-android-support/src/test/java/okhttp3/AbstractResponseCache.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-
-public class AbstractResponseCache extends ResponseCache {
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) throws IOException {
-    return null;
-  }
-
-  @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-    return null;
-  }
-
-  public static URI toUri(URL serverUrl) {
-    try {
-      return serverUrl.toURI();
-    } catch (URISyntaxException e) {
-      throw new AssertionError(e);
-    }
-  }
-}
diff --git a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
deleted file mode 100644
index c569a3b365..0000000000
--- a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCache.java
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.android;
-
-import java.io.Closeable;
-import java.io.File;
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-import okhttp3.AndroidShimResponseCache;
-import okhttp3.Cache;
-import okhttp3.OkCacheContainer;
-
-/**
- * A copy of android.net.http.HttpResponseCache taken from AOSP. Android need to keep this code
- * working somehow. Dependencies on okhttp3 are com.android.okhttp on Android.
- *
- * <p>This class exists in okhttp-android-support to help keep the API as it always has been on
- * Android. The public API cannot be changed. This class delegates to {@link
- * AndroidShimResponseCache}, a class that exists in a package that enables it to interact with
- * non-public OkHttp classes.
- */
-public final class HttpResponseCache extends ResponseCache implements Closeable, OkCacheContainer {
-
-  private AndroidShimResponseCache shimResponseCache;
-
-  private HttpResponseCache(AndroidShimResponseCache shimResponseCache) {
-    this.shimResponseCache = shimResponseCache;
-  }
-
-  /**
-   * Returns the currently-installed {@code HttpResponseCache}, or null if there is no cache
-   * installed or it is not a {@code HttpResponseCache}.
-   */
-  public static HttpResponseCache getInstalled() {
-    ResponseCache installed = ResponseCache.getDefault();
-    if (installed instanceof HttpResponseCache) {
-      return (HttpResponseCache) installed;
-    }
-    return null;
-  }
-
-  /**
-   * Creates a new HTTP response cache and sets it as the system default cache.
-   *
-   * @param directory the directory to hold cache data.
-   * @param maxSize the maximum size of the cache in bytes.
-   * @return the newly-installed cache
-   * @throws java.io.IOException if {@code directory} cannot be used for this cache. Most
-   * applications should respond to this exception by logging a warning.
-   */
-  public static synchronized HttpResponseCache install(File directory, long maxSize) throws
-      IOException {
-    ResponseCache installed = ResponseCache.getDefault();
-
-    if (installed instanceof HttpResponseCache) {
-      HttpResponseCache installedResponseCache = (HttpResponseCache) installed;
-      // don't close and reopen if an equivalent cache is already installed
-      AndroidShimResponseCache trueResponseCache = installedResponseCache.shimResponseCache;
-      if (trueResponseCache.isEquivalent(directory, maxSize)) {
-        return installedResponseCache;
-      } else {
-        // The HttpResponseCache that owns this object is about to be replaced.
-        trueResponseCache.close();
-      }
-    }
-
-    AndroidShimResponseCache trueResponseCache =
-        AndroidShimResponseCache.create(directory, maxSize);
-    HttpResponseCache newResponseCache = new HttpResponseCache(trueResponseCache);
-    ResponseCache.setDefault(newResponseCache);
-    return newResponseCache;
-  }
-
-  @Override public CacheResponse get(URI uri, String requestMethod,
-      Map<String, List<String>> requestHeaders) throws IOException {
-    return shimResponseCache.get(uri, requestMethod, requestHeaders);
-  }
-
-  @Override public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
-    return shimResponseCache.put(uri, urlConnection);
-  }
-
-  /**
-   * Returns the number of bytes currently being used to store the values in this cache. This may be
-   * greater than the {@link #maxSize} if a background deletion is pending.
-   */
-  public long size() {
-    try {
-      return shimResponseCache.size();
-    } catch (IOException e) {
-      // This can occur if the cache failed to lazily initialize. Return -1 to mean "unknown".
-      return -1;
-    }
-  }
-
-  /**
-   * Returns the maximum number of bytes that this cache should use to store its data.
-   */
-  public long maxSize() {
-    return shimResponseCache.maxSize();
-  }
-
-  /**
-   * Force buffered operations to the filesystem. This ensures that responses written to the cache
-   * will be available the next time the cache is opened, even if this process is killed.
-   */
-  public void flush() {
-    try {
-      shimResponseCache.flush();
-    } catch (IOException ignored) {
-    }
-  }
-
-  /**
-   * Returns the number of HTTP requests that required the network to either supply a response or
-   * validate a locally cached response.
-   */
-  public int getNetworkCount() {
-    return shimResponseCache.getNetworkCount();
-  }
-
-  /**
-   * Returns the number of HTTP requests whose response was provided by the cache. This may include
-   * conditional {@code GET} requests that were validated over the network.
-   */
-  public int getHitCount() {
-    return shimResponseCache.getHitCount();
-  }
-
-  /**
-   * Returns the total number of HTTP requests that were made. This includes both client requests
-   * and requests that were made on the client's behalf to handle a redirects and retries.
-   */
-  public int getRequestCount() {
-    return shimResponseCache.getRequestCount();
-  }
-
-  /**
-   * Uninstalls the cache and releases any active resources. Stored contents will remain on the
-   * filesystem.
-   */
-  @Override public void close() throws IOException {
-    if (ResponseCache.getDefault() == this) {
-      ResponseCache.setDefault(null);
-    }
-    shimResponseCache.close();
-  }
-
-  /**
-   * Uninstalls the cache and deletes all of its stored contents.
-   */
-  public void delete() throws IOException {
-    if (ResponseCache.getDefault() == this) {
-      ResponseCache.setDefault(null);
-    }
-    shimResponseCache.delete();
-  }
-
-  @Override
-  public Cache getCache() {
-    return shimResponseCache.getCache();
-  }
-}
diff --git a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
deleted file mode 100644
index dcb1c01815..0000000000
--- a/okhttp-android-support/src/test/java/okhttp3/android/HttpResponseCacheTest.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.android;
-
-import java.io.File;
-import java.io.InputStream;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URLConnection;
-import java.util.List;
-import java.util.Map;
-import okhttp3.AndroidInternal;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.fail;
-
-/**
- * A port of Android's android.net.http.HttpResponseCacheTest to JUnit4.
- */
-public final class HttpResponseCacheTest {
-  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
-  @Rule public MockWebServer server = new MockWebServer();
-
-  private File cacheDir;
-  private OkUrlFactory urlFactory;
-
-  @Before public void setUp() throws Exception {
-    cacheDir = cacheRule.getRoot();
-    urlFactory = new OkUrlFactory(new OkHttpClient());
-  }
-
-  @After public void tearDown() throws Exception {
-    ResponseCache.setDefault(null);
-  }
-
-  @Test public void install() throws Exception {
-    HttpResponseCache installed = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    assertNotNull(installed);
-    assertSame(installed, ResponseCache.getDefault());
-    assertSame(installed, HttpResponseCache.getDefault());
-  }
-
-  @Test public void secondEquivalentInstallDoesNothing() throws Exception {
-    HttpResponseCache first = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    HttpResponseCache another = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    assertSame(first, another);
-  }
-
-  @Test public void installClosesPreviouslyInstalled() throws Exception {
-    HttpResponseCache first = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    initializeCache(first);
-
-    HttpResponseCache another = HttpResponseCache.install(cacheDir, 8 * 1024 * 1024);
-    initializeCache(another);
-
-    assertNotSame(first, another);
-    try {
-      first.flush();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void getInstalledWithWrongTypeInstalled() {
-    ResponseCache.setDefault(new ResponseCache() {
-      @Override
-      public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) {
-        return null;
-      }
-
-      @Override
-      public CacheRequest put(URI uri, URLConnection connection) {
-        return null;
-      }
-    });
-    assertNull(HttpResponseCache.getInstalled());
-  }
-
-  @Test public void closeCloses() throws Exception {
-    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    initializeCache(cache);
-
-    cache.close();
-    try {
-      cache.flush();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void closeUninstalls() throws Exception {
-    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    cache.close();
-    assertNull(ResponseCache.getDefault());
-  }
-
-  @Test public void deleteUninstalls() throws Exception {
-    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-    cache.delete();
-    assertNull(ResponseCache.getDefault());
-  }
-
-  /**
-   * Make sure that statistics tracking are wired all the way through the wrapper class.
-   * http://code.google.com/p/android/issues/detail?id=25418
-   */
-  @Test public void statisticsTracking() throws Exception {
-    HttpResponseCache cache = HttpResponseCache.install(cacheDir, 10 * 1024 * 1024);
-
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-
-    URLConnection c1 = openUrl(server.url("/"));
-
-    InputStream inputStream = c1.getInputStream();
-    assertEquals('A', inputStream.read());
-    inputStream.close();
-    assertEquals(1, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(0, cache.getHitCount());
-
-    URLConnection c2 = openUrl(server.url("/"));
-    assertEquals('A', c2.getInputStream().read());
-
-    URLConnection c3 = openUrl(server.url("/"));
-    assertEquals('A', c3.getInputStream().read());
-    assertEquals(3, cache.getRequestCount());
-    assertEquals(1, cache.getNetworkCount());
-    assertEquals(2, cache.getHitCount());
-  }
-
-  // This mimics the Android HttpHandler, which is found in the okhttp3 package.
-  private URLConnection openUrl(HttpUrl url) {
-    ResponseCache responseCache = ResponseCache.getDefault();
-    AndroidInternal.setResponseCache(urlFactory, responseCache);
-    return urlFactory.open(url.url());
-  }
-
-  private void initializeCache(HttpResponseCache cache) {
-    // Ensure the cache is initialized, otherwise various methods are no-ops.
-    cache.size();
-  }
-}
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
deleted file mode 100644
index cdbc21efda..0000000000
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
+++ /dev/null
@@ -1,295 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.URI;
-import java.net.URL;
-import java.net.URLConnection;
-import java.nio.charset.StandardCharsets;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import okhttp3.AbstractResponseCache;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.internal.Internal;
-import okhttp3.internal.cache.InternalCache;
-import okhttp3.mockwebserver.internal.tls.SslClient;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okio.Buffer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-/**
- * A white-box test for {@link CacheAdapter}. See also:
- * <ul>
- *     <li>{@link ResponseCacheTest} for black-box tests that check that {@link ResponseCache}
- *         classes are called correctly by OkHttp.
- *     <li>{@link JavaApiConverterTest} for tests that check Java API classes / OkHttp conversion
- *         logic.
- * </ul>
- */
-public class CacheAdapterTest {
-  private SslClient sslClient = SslClient.localhost();
-  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  private MockWebServer server;
-  private OkHttpClient client;
-  private HttpURLConnection connection;
-
-  @Before public void setUp() throws Exception {
-    server = new MockWebServer();
-    client = new OkHttpClient();
-  }
-
-  @After public void tearDown() throws Exception {
-    if (connection != null) {
-      connection.disconnect();
-    }
-    server.shutdown();
-  }
-
-  @Test public void get_httpGet() throws Exception {
-    final URL serverUrl = configureServer(new MockResponse());
-    assertEquals("http", serverUrl.getProtocol());
-
-    ResponseCache responseCache = new AbstractResponseCache() {
-      @Override public CacheResponse get(
-          URI uri, String method, Map<String, List<String>> headers) throws IOException {
-        try {
-          assertEquals(toUri(serverUrl), uri);
-          assertEquals("GET", method);
-          assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
-          assertEquals(Collections.singletonList("value1"), headers.get("key1"));
-          return null;
-        } catch (Throwable t) {
-          throw new IOException("unexpected cache failure", t);
-        }
-      }
-    };
-    setInternalCache(new CacheAdapter(responseCache));
-
-    connection = new OkUrlFactory(client).open(serverUrl);
-    connection.setRequestProperty("key1", "value1");
-
-    executeGet(connection);
-  }
-
-  @Test public void get_httpsGet() throws Exception {
-    final URL serverUrl = configureHttpsServer(new MockResponse());
-    assertEquals("https", serverUrl.getProtocol());
-
-    ResponseCache responseCache = new AbstractResponseCache() {
-      @Override public CacheResponse get(URI uri, String method, Map<String, List<String>> headers)
-          throws IOException {
-        try {
-          assertEquals("https", uri.getScheme());
-          assertEquals(toUri(serverUrl), uri);
-          assertEquals("GET", method);
-          assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
-          assertEquals(Collections.singletonList("value1"), headers.get("key1"));
-          return null;
-        } catch (Throwable t) {
-          throw new IOException("unexpected cache failure", t);
-        }
-      }
-    };
-    setInternalCache(new CacheAdapter(responseCache));
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-
-    connection = new OkUrlFactory(client).open(serverUrl);
-    connection.setRequestProperty("key1", "value1");
-
-    executeGet(connection);
-  }
-
-  @Test public void put_httpGet() throws Exception {
-    final String statusLine = "HTTP/1.1 200 Fantastic";
-    final byte[] response = "ResponseString".getBytes(StandardCharsets.UTF_8);
-    final URL serverUrl = configureServer(
-        new MockResponse()
-            .setStatus(statusLine)
-            .addHeader("A", "c")
-            .setBody(new Buffer().write(response)));
-
-    ResponseCache responseCache = new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        try {
-          assertTrue(connection instanceof HttpURLConnection);
-          assertFalse(connection instanceof HttpsURLConnection);
-
-          assertEquals(response.length, connection.getContentLength());
-
-          HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
-          assertEquals("GET", httpUrlConnection.getRequestMethod());
-          assertTrue(httpUrlConnection.getDoInput());
-          assertFalse(httpUrlConnection.getDoOutput());
-
-          assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
-          assertEquals(toUri(serverUrl), uri);
-          assertEquals(serverUrl, connection.getURL());
-          assertEquals("value", connection.getRequestProperty("key"));
-
-          // Check retrieval by string key.
-          assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
-          assertEquals("c", httpUrlConnection.getHeaderField("A"));
-          // The RI and OkHttp supports case-insensitive matching for this method.
-          assertEquals("c", httpUrlConnection.getHeaderField("a"));
-          return null;
-        } catch (Throwable t) {
-          throw new IOException("unexpected cache failure", t);
-        }
-      }
-    };
-    setInternalCache(new CacheAdapter(responseCache));
-
-    connection = new OkUrlFactory(client).open(serverUrl);
-    connection.setRequestProperty("key", "value");
-    executeGet(connection);
-  }
-
-  @Test public void put_httpPost() throws Exception {
-    final String statusLine = "HTTP/1.1 200 Fantastic";
-    final URL serverUrl = configureServer(
-        new MockResponse()
-            .setStatus(statusLine)
-            .addHeader("A", "c"));
-
-    ResponseCache responseCache = new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        try {
-          assertTrue(connection instanceof HttpURLConnection);
-          assertFalse(connection instanceof HttpsURLConnection);
-
-          assertEquals(0, connection.getContentLength());
-
-          HttpURLConnection httpUrlConnection = (HttpURLConnection) connection;
-          assertEquals("POST", httpUrlConnection.getRequestMethod());
-          assertTrue(httpUrlConnection.getDoInput());
-          assertTrue(httpUrlConnection.getDoOutput());
-
-          assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
-          assertEquals(toUri(serverUrl), uri);
-          assertEquals(serverUrl, connection.getURL());
-          assertEquals("value", connection.getRequestProperty("key"));
-
-          // Check retrieval by string key.
-          assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
-          assertEquals("c", httpUrlConnection.getHeaderField("A"));
-          // The RI and OkHttp supports case-insensitive matching for this method.
-          assertEquals("c", httpUrlConnection.getHeaderField("a"));
-          return null;
-        } catch (Throwable t) {
-          throw new IOException("unexpected cache failure", t);
-        }
-      }
-    };
-    setInternalCache(new CacheAdapter(responseCache));
-
-    connection = new OkUrlFactory(client).open(serverUrl);
-
-    executePost(connection);
-  }
-
-  @Test public void put_httpsGet() throws Exception {
-    final URL serverUrl = configureHttpsServer(new MockResponse());
-    assertEquals("https", serverUrl.getProtocol());
-
-    ResponseCache responseCache = new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        try {
-          assertTrue(connection instanceof HttpsURLConnection);
-          assertEquals(toUri(serverUrl), uri);
-          assertEquals(serverUrl, connection.getURL());
-
-          HttpsURLConnection cacheHttpsUrlConnection = (HttpsURLConnection) connection;
-          HttpsURLConnection realHttpsUrlConnection =
-              (HttpsURLConnection) CacheAdapterTest.this.connection;
-          assertEquals(realHttpsUrlConnection.getCipherSuite(),
-              cacheHttpsUrlConnection.getCipherSuite());
-          assertEquals(realHttpsUrlConnection.getPeerPrincipal(),
-              cacheHttpsUrlConnection.getPeerPrincipal());
-          assertArrayEquals(realHttpsUrlConnection.getLocalCertificates(),
-              cacheHttpsUrlConnection.getLocalCertificates());
-          assertArrayEquals(realHttpsUrlConnection.getServerCertificates(),
-              cacheHttpsUrlConnection.getServerCertificates());
-          assertEquals(realHttpsUrlConnection.getLocalPrincipal(),
-              cacheHttpsUrlConnection.getLocalPrincipal());
-          return null;
-        } catch (Throwable t) {
-          throw new IOException("unexpected cache failure", t);
-        }
-      }
-    };
-    setInternalCache(new CacheAdapter(responseCache));
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-
-    connection = new OkUrlFactory(client).open(serverUrl);
-    executeGet(connection);
-  }
-
-  private void executeGet(HttpURLConnection connection) throws IOException {
-    connection.connect();
-    connection.getHeaderFields();
-    connection.disconnect();
-  }
-
-  private void executePost(HttpURLConnection connection) throws IOException {
-    connection.setDoOutput(true);
-    connection.connect();
-    connection.getOutputStream().write("Hello World".getBytes());
-    connection.disconnect();
-  }
-
-  private URL configureServer(MockResponse mockResponse) throws Exception {
-    server.enqueue(mockResponse);
-    server.start();
-    return server.url("/").url();
-  }
-
-  private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
-    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);
-    server.enqueue(mockResponse);
-    server.start();
-    return server.url("/").url();
-  }
-
-  private void setInternalCache(InternalCache internalCache) {
-    OkHttpClient.Builder builder = client.newBuilder();
-    Internal.instance.setCache(builder, internalCache);
-    client = builder.build();
-  }
-}
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
deleted file mode 100644
index c14d6d57f4..0000000000
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
+++ /dev/null
@@ -1,693 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.CacheResponse;
-import java.net.HttpURLConnection;
-import java.net.SecureCacheResponse;
-import java.net.URI;
-import java.nio.charset.StandardCharsets;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.security.cert.CertificateException;
-import java.security.cert.CertificateFactory;
-import java.security.cert.X509Certificate;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import okhttp3.CipherSuite;
-import okhttp3.Handshake;
-import okhttp3.Headers;
-import okhttp3.MediaType;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.TlsVersion;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.mockwebserver.MockWebServer;
-import okio.Buffer;
-import okio.BufferedSource;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public class JavaApiConverterTest {
-
-  // $ openssl req -x509 -nodes -days 36500 -subj '/CN=localhost' -config ./cert.cnf \
-  //     -newkey rsa:512 -out cert.pem
-  private static final X509Certificate LOCAL_CERT = certificate(""
-      + "-----BEGIN CERTIFICATE-----\n"
-      + "MIIBWDCCAQKgAwIBAgIJANS1EtICX2AZMA0GCSqGSIb3DQEBBQUAMBQxEjAQBgNV\n"
-      + "BAMTCWxvY2FsaG9zdDAgFw0xMjAxMDIxOTA4NThaGA8yMTExMTIwOTE5MDg1OFow\n"
-      + "FDESMBAGA1UEAxMJbG9jYWxob3N0MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAPpt\n"
-      + "atK8r4/hf4hSIs0os/BSlQLbRBaK9AfBReM4QdAklcQqe6CHsStKfI8pp0zs7Ptg\n"
-      + "PmMdpbttL0O7mUboBC8CAwEAAaM1MDMwMQYDVR0RBCowKIIVbG9jYWxob3N0Lmxv\n"
-      + "Y2FsZG9tYWlugglsb2NhbGhvc3SHBH8AAAEwDQYJKoZIhvcNAQEFBQADQQD0ntfL\n"
-      + "DCzOCv9Ma6Lv5o5jcYWVxvBSTsnt22hsJpWD1K7iY9lbkLwl0ivn73pG2evsAn9G\n"
-      + "X8YKH52fnHsCrhSD\n"
-      + "-----END CERTIFICATE-----");
-
-  // openssl req -x509 -nodes -days 36500 -subj '/CN=*.0.0.1' -newkey rsa:512 -out cert.pem
-  private static final X509Certificate SERVER_CERT = certificate(""
-      + "-----BEGIN CERTIFICATE-----\n"
-      + "MIIBkjCCATygAwIBAgIJAMdemqOwd/BEMA0GCSqGSIb3DQEBBQUAMBIxEDAOBgNV\n"
-      + "BAMUByouMC4wLjEwIBcNMTAxMjIwMTY0NDI1WhgPMjExMDExMjYxNjQ0MjVaMBIx\n"
-      + "EDAOBgNVBAMUByouMC4wLjEwXDANBgkqhkiG9w0BAQEFAANLADBIAkEAqY8c9Qrt\n"
-      + "YPWCvb7lclI+aDHM6fgbJcHsS9Zg8nUOh5dWrS7AgeA25wyaokFl4plBbbHQe2j+\n"
-      + "cCjsRiJIcQo9HwIDAQABo3MwcTAdBgNVHQ4EFgQUJ436TZPJvwCBKklZZqIvt1Yt\n"
-      + "JjEwQgYDVR0jBDswOYAUJ436TZPJvwCBKklZZqIvt1YtJjGhFqQUMBIxEDAOBgNV\n"
-      + "BAMUByouMC4wLjGCCQDHXpqjsHfwRDAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEB\n"
-      + "BQUAA0EAk9i88xdjWoewqvE+iMC9tD2obMchgFDaHH0ogxxiRaIKeEly3g0uGxIt\n"
-      + "fl2WRY8hb4x+zRrwsFaLEpdEvqcjOQ==\n"
-      + "-----END CERTIFICATE-----");
-
-  @Rule public MockWebServer server = new MockWebServer();
-
-  @Before public void setUp() throws Exception {
-    Internal.initializeInstanceForTests();
-  }
-
-  @Test public void createOkResponseForCacheGet() throws Exception {
-    final String statusLine = "HTTP/1.1 200 Fantastic";
-    URI uri = new URI("http://foo/bar");
-    Request request = new Request.Builder().url(uri.toURL()).build();
-    CacheResponse cacheResponse = new CacheResponse() {
-      @Override public Map<String, List<String>> getHeaders() throws IOException {
-        Map<String, List<String>> headers = new LinkedHashMap<>();
-        headers.put(null, Collections.singletonList(statusLine));
-        headers.put("xyzzy", Arrays.asList("bar", "baz"));
-        return headers;
-      }
-
-      @Override public InputStream getBody() throws IOException {
-        return new ByteArrayInputStream("HelloWorld".getBytes(StandardCharsets.UTF_8));
-      }
-    };
-
-    Response response = JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
-    Request cacheRequest = response.request();
-    assertEquals(request.url(), cacheRequest.url());
-    assertEquals(request.method(), cacheRequest.method());
-    assertEquals(0, request.headers().size());
-
-    assertEquals(Protocol.HTTP_1_1, response.protocol());
-    assertEquals(200, response.code());
-    assertEquals("Fantastic", response.message());
-    Headers okResponseHeaders = response.headers();
-    assertEquals("baz", okResponseHeaders.get("xyzzy"));
-    assertEquals("HelloWorld", response.body().string());
-    assertNull(response.handshake());
-  }
-
-  /** Test for https://code.google.com/p/android/issues/detail?id=160522 */
-  @Test public void createOkResponseForCacheGet_withMissingStatusLine() throws Exception {
-    URI uri = new URI("http://foo/bar");
-    Request request = new Request.Builder().url(uri.toURL()).build();
-    CacheResponse cacheResponse = new CacheResponse() {
-      @Override public Map<String, List<String>> getHeaders() throws IOException {
-        Map<String, List<String>> headers = new LinkedHashMap<>();
-        // Headers is deliberately missing an entry with a null key.
-        headers.put("xyzzy", Arrays.asList("bar", "baz"));
-        return headers;
-      }
-
-      @Override public InputStream getBody() throws IOException {
-        return null; // Should never be called
-      }
-    };
-
-    try {
-      JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void createOkResponseForCacheGet_secure() throws Exception {
-    final String statusLine = "HTTP/1.1 200 Fantastic";
-    final Principal localPrincipal = LOCAL_CERT.getSubjectX500Principal();
-    final List<Certificate> localCertificates = Arrays.<Certificate>asList(LOCAL_CERT);
-    final Principal serverPrincipal = SERVER_CERT.getSubjectX500Principal();
-    final List<Certificate> serverCertificates = Arrays.<Certificate>asList(SERVER_CERT);
-    URI uri = new URI("https://foo/bar");
-    Request request = new Request.Builder().url(uri.toURL()).build();
-    SecureCacheResponse cacheResponse = new SecureCacheResponse() {
-      @Override public Map<String, List<String>> getHeaders() throws IOException {
-        Map<String, List<String>> headers = new LinkedHashMap<>();
-        headers.put(null, Collections.singletonList(statusLine));
-        headers.put("xyzzy", Arrays.asList("bar", "baz"));
-        return headers;
-      }
-
-      @Override public InputStream getBody() throws IOException {
-        return new ByteArrayInputStream("HelloWorld".getBytes(StandardCharsets.UTF_8));
-      }
-
-      @Override public String getCipherSuite() {
-        return "SSL_RSA_WITH_NULL_MD5";
-      }
-
-      @Override public List<Certificate> getLocalCertificateChain() {
-        return localCertificates;
-      }
-
-      @Override public List<Certificate> getServerCertificateChain()
-          throws SSLPeerUnverifiedException {
-        return serverCertificates;
-      }
-
-      @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-        return serverPrincipal;
-      }
-
-      @Override public Principal getLocalPrincipal() {
-        return localPrincipal;
-      }
-    };
-
-    Response response = JavaApiConverter.createOkResponseForCacheGet(request, cacheResponse);
-    Request cacheRequest = response.request();
-    assertEquals(request.url(), cacheRequest.url());
-    assertEquals(request.method(), cacheRequest.method());
-    assertEquals(0, request.headers().size());
-
-    assertEquals(Protocol.HTTP_1_1, response.protocol());
-    assertEquals(200, response.code());
-    assertEquals("Fantastic", response.message());
-    Headers okResponseHeaders = response.headers();
-    assertEquals("baz", okResponseHeaders.get("xyzzy"));
-    assertEquals("HelloWorld", response.body().string());
-
-    Handshake handshake = response.handshake();
-    assertNotNull(handshake);
-    assertNotNullAndEquals(CipherSuite.TLS_RSA_WITH_NULL_MD5, handshake.cipherSuite());
-    assertEquals(localPrincipal, handshake.localPrincipal());
-    assertEquals(serverPrincipal, handshake.peerPrincipal());
-    assertEquals(serverCertificates, handshake.peerCertificates());
-    assertEquals(localCertificates, handshake.localCertificates());
-  }
-
-  @Test public void createOkRequest_nullRequestHeaders() throws Exception {
-    URI uri = new URI("http://foo/bar");
-
-    Map<String, List<String>> javaRequestHeaders = null;
-    Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
-    assertFalse(request.isHttps());
-    assertEquals(uri, request.url().uri());
-    Headers okRequestHeaders = request.headers();
-    assertEquals(0, okRequestHeaders.size());
-    assertEquals("POST", request.method());
-  }
-
-  @Test public void createOkRequest_nonNullRequestHeaders() throws Exception {
-    URI uri = new URI("https://foo/bar");
-
-    Map<String, List<String>> javaRequestHeaders = new LinkedHashMap<>();
-    javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
-    Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
-    assertTrue(request.isHttps());
-    assertEquals(uri, request.url().uri());
-    Headers okRequestHeaders = request.headers();
-    assertEquals(1, okRequestHeaders.size());
-    assertEquals("Bar", okRequestHeaders.get("Foo"));
-    assertEquals("POST", request.method());
-  }
-
-  // Older versions of OkHttp would store the "request line" as a header with a
-  // null key. To support the Android usecase where an old version of OkHttp uses
-  // a newer, Android-bundled, version of HttpResponseCache the null key must be
-  // explicitly ignored.
-  @Test public void createOkRequest_nullRequestHeaderKey() throws Exception {
-    URI uri = new URI("https://foo/bar");
-
-    Map<String, List<String>> javaRequestHeaders = new LinkedHashMap<>();
-    javaRequestHeaders.put(null, Arrays.asList("GET / HTTP 1.1"));
-    javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
-    Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
-    assertTrue(request.isHttps());
-    assertEquals(uri, request.url().uri());
-    Headers okRequestHeaders = request.headers();
-    assertEquals(1, okRequestHeaders.size());
-    assertEquals("Bar", okRequestHeaders.get("Foo"));
-    assertEquals("POST", request.method());
-  }
-
-  @Test public void createJavaUrlConnection_requestChangesForbidden() throws Exception {
-    Response okResponse = createArbitraryOkResponse();
-    HttpURLConnection httpUrlConnection =
-        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
-    // Check an arbitrary (not complete) set of methods that can be used to modify the
-    // request.
-    try {
-      httpUrlConnection.setRequestProperty("key", "value");
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.setFixedLengthStreamingMode(1234);
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.setRequestMethod("PUT");
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.getHeaderFields().put("key", Collections.singletonList("value"));
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.getOutputStream();
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-
-  @Test public void createJavaUrlConnection_connectionChangesForbidden() throws Exception {
-    Response okResponse = createArbitraryOkResponse();
-    HttpURLConnection httpUrlConnection =
-        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
-    try {
-      httpUrlConnection.connect();
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.disconnect();
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-
-  @Test public void createJavaUrlConnection_responseChangesForbidden() throws Exception {
-    Response okResponse = createArbitraryOkResponse();
-    HttpURLConnection httpUrlConnection =
-        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
-    // Check an arbitrary (not complete) set of methods that can be used to access the response
-    // body.
-    InputStream is = httpUrlConnection.getInputStream();
-    try {
-      is.read();
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.getContent();
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.setFixedLengthStreamingMode(1234);
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.setRequestMethod("PUT");
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpUrlConnection.getHeaderFields().put("key", Collections.singletonList("value"));
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-
-  @Test public void createJavaUrlConnection_responseHeadersOk() throws Exception {
-    ResponseBody responseBody = createResponseBody("BodyText");
-    Response okResponse = new Response.Builder()
-        .request(createArbitraryOkRequest())
-        .protocol(Protocol.HTTP_1_1)
-        .code(200)
-        .message("Fantastic")
-        .addHeader("A", "c")
-        .addHeader("B", "d")
-        .addHeader("A", "e")
-        .addHeader("Content-Length", Long.toString(responseBody.contentLength()))
-        .body(responseBody)
-        .build();
-
-    HttpURLConnection httpUrlConnection =
-        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
-    assertEquals(200, httpUrlConnection.getResponseCode());
-    assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
-    assertEquals(responseBody.contentLength(), httpUrlConnection.getContentLength());
-
-    // Check retrieval by string key.
-    assertEquals("HTTP/1.1 200 Fantastic", httpUrlConnection.getHeaderField(null));
-    assertEquals("e", httpUrlConnection.getHeaderField("A"));
-    // The RI and OkHttp supports case-insensitive matching for this method.
-    assertEquals("e", httpUrlConnection.getHeaderField("a"));
-
-    // Check retrieval using a Map.
-    Map<String, List<String>> responseHeaders = httpUrlConnection.getHeaderFields();
-    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), responseHeaders.get(null));
-    assertEquals(newSet("c", "e"), newSet(responseHeaders.get("A")));
-    // OkHttp supports case-insensitive matching here. The RI does not.
-    assertEquals(newSet("c", "e"), newSet(responseHeaders.get("a")));
-
-    // Check the Map iterator contains the expected mappings.
-    assertHeadersContainsMapping(responseHeaders, null, "HTTP/1.1 200 Fantastic");
-    assertHeadersContainsMapping(responseHeaders, "A", "c", "e");
-    assertHeadersContainsMapping(responseHeaders, "B", "d");
-
-    // Check immutability of the headers Map.
-    try {
-      responseHeaders.put("N", Arrays.asList("o"));
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      responseHeaders.get("A").add("f");
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-
-    // Check retrieval of headers by index.
-    assertEquals(null, httpUrlConnection.getHeaderFieldKey(0));
-    assertEquals("HTTP/1.1 200 Fantastic", httpUrlConnection.getHeaderField(0));
-    // After header zero there may be additional entries provided at the beginning or end by the
-    // implementation. It's probably important that the relative ordering of the headers is
-    // preserved, particularly if there are multiple value for the same key.
-    int i = 1;
-    while (!httpUrlConnection.getHeaderFieldKey(i).equals("A")) {
-      i++;
-    }
-    // Check the ordering of the headers set by app code.
-    assertResponseHeaderAtIndex(httpUrlConnection, i++, "A", "c");
-    assertResponseHeaderAtIndex(httpUrlConnection, i++, "B", "d");
-    assertResponseHeaderAtIndex(httpUrlConnection, i++, "A", "e");
-    // There may be some additional headers provided by the implementation.
-    while (httpUrlConnection.getHeaderField(i) != null) {
-      assertNotNull(httpUrlConnection.getHeaderFieldKey(i));
-      i++;
-    }
-    // Confirm the correct behavior when the index is out-of-range.
-    assertNull(httpUrlConnection.getHeaderFieldKey(i));
-  }
-
-  private static void assertResponseHeaderAtIndex(HttpURLConnection httpUrlConnection,
-      int headerIndex, String expectedKey, String expectedValue) {
-    assertEquals(expectedKey, httpUrlConnection.getHeaderFieldKey(headerIndex));
-    assertEquals(expectedValue, httpUrlConnection.getHeaderField(headerIndex));
-  }
-
-  private void assertHeadersContainsMapping(Map<String, List<String>> headers, String expectedKey,
-      String... expectedValues) {
-    assertTrue(headers.containsKey(expectedKey));
-    assertEquals(newSet(expectedValues), newSet(headers.get(expectedKey)));
-  }
-
-  @Test public void createJavaUrlConnection_accessibleRequestInfo_GET() throws Exception {
-    Request okRequest = createArbitraryOkRequest().newBuilder()
-        .get()
-        .build();
-    Response okResponse = createArbitraryOkResponse(okRequest);
-    HttpURLConnection httpUrlConnection =
-        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
-
-    assertEquals("GET", httpUrlConnection.getRequestMethod());
-    assertTrue(httpUrlConnection.getDoInput());
-    assertFalse(httpUrlConnection.getDoOutput());
-  }
-
-  @Test public void createJavaUrlConnection_accessibleRequestInfo_POST() throws Exception {
-    Request okRequest = createArbitraryOkRequest().newBuilder()
-        .post(createRequestBody("PostBody"))
-        .build();
-    Response okResponse = createArbitraryOkResponse(okRequest);
-    HttpURLConnection httpUrlConnection =
-        JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
-
-    assertEquals("POST", httpUrlConnection.getRequestMethod());
-    assertTrue(httpUrlConnection.getDoInput());
-    assertTrue(httpUrlConnection.getDoOutput());
-  }
-
-  @Test public void createJavaUrlConnection_https_extraHttpsMethods() throws Exception {
-    Request okRequest = createArbitraryOkRequest().newBuilder()
-        .get()
-        .url("https://secure/request")
-        .build();
-    Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, CipherSuite.TLS_RSA_WITH_NULL_MD5,
-        Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
-    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
-        .handshake(handshake)
-        .build();
-    HttpsURLConnection httpsUrlConnection =
-        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
-
-    assertEquals("SSL_RSA_WITH_NULL_MD5", httpsUrlConnection.getCipherSuite());
-    assertEquals(SERVER_CERT.getSubjectX500Principal(), httpsUrlConnection.getPeerPrincipal());
-    assertArrayEquals(new Certificate[] {LOCAL_CERT}, httpsUrlConnection.getLocalCertificates());
-    assertArrayEquals(new Certificate[] {SERVER_CERT},
-        httpsUrlConnection.getServerCertificates());
-    assertEquals(LOCAL_CERT.getSubjectX500Principal(), httpsUrlConnection.getLocalPrincipal());
-  }
-
-  @Test public void createJavaUrlConnection_https_forbiddenFields() throws Exception {
-    Request okRequest = createArbitraryOkRequest().newBuilder()
-        .url("https://secure/request")
-        .build();
-    Response okResponse = createArbitraryOkResponse(okRequest);
-    HttpsURLConnection httpsUrlConnection =
-        (HttpsURLConnection) JavaApiConverter.createJavaUrlConnectionForCachePut(okResponse);
-
-    try {
-      httpsUrlConnection.getHostnameVerifier();
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      httpsUrlConnection.getSSLSocketFactory();
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-
-  @Test public void createJavaCacheResponse_httpGet() throws Exception {
-    Request okRequest =
-        createArbitraryOkRequest().newBuilder()
-            .url("http://insecure/request")
-            .get()
-            .build();
-    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
-        .protocol(Protocol.HTTP_1_1)
-        .code(200)
-        .message("Fantastic")
-        .addHeader("key1", "value1_1")
-        .addHeader("key2", "value2")
-        .addHeader("key1", "value1_2")
-        .body(null)
-        .build();
-    CacheResponse javaCacheResponse = JavaApiConverter.createJavaCacheResponse(okResponse);
-    assertFalse(javaCacheResponse instanceof SecureCacheResponse);
-    Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
-    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
-    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
-    assertNull(javaCacheResponse.getBody());
-  }
-
-  @Test public void createJavaCacheResponse_httpPost() throws Exception {
-    Request okRequest =
-        createArbitraryOkRequest().newBuilder()
-            .url("http://insecure/request")
-            .post(createRequestBody("RequestBody"))
-            .build();
-    ResponseBody responseBody = createResponseBody("ResponseBody");
-    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
-        .protocol(Protocol.HTTP_1_1)
-        .code(200)
-        .message("Fantastic")
-        .addHeader("key1", "value1_1")
-        .addHeader("key2", "value2")
-        .addHeader("key1", "value1_2")
-        .body(responseBody)
-        .build();
-    CacheResponse javaCacheResponse = JavaApiConverter.createJavaCacheResponse(okResponse);
-    assertFalse(javaCacheResponse instanceof SecureCacheResponse);
-    Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
-    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
-    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
-    assertEquals("ResponseBody", readAll(javaCacheResponse.getBody()));
-  }
-
-  @Test public void createJavaCacheResponse_httpsPost() throws Exception {
-    Request okRequest =
-        createArbitraryOkRequest().newBuilder()
-            .url("https://secure/request")
-            .post(createRequestBody("RequestBody"))
-            .build();
-    ResponseBody responseBody = createResponseBody("ResponseBody");
-    Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, CipherSuite.TLS_RSA_WITH_NULL_MD5,
-        Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
-    Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
-        .protocol(Protocol.HTTP_1_1)
-        .code(200)
-        .message("Fantastic")
-        .addHeader("key1", "value1_1")
-        .addHeader("key2", "value2")
-        .addHeader("key1", "value1_2")
-        .body(responseBody)
-        .handshake(handshake)
-        .build();
-    SecureCacheResponse javaCacheResponse =
-        (SecureCacheResponse) JavaApiConverter.createJavaCacheResponse(okResponse);
-    Map<String, List<String>> javaHeaders = javaCacheResponse.getHeaders();
-    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
-    assertEquals(Arrays.asList("HTTP/1.1 200 Fantastic"), javaHeaders.get(null));
-    assertEquals("ResponseBody", readAll(javaCacheResponse.getBody()));
-    assertEquals(handshake.cipherSuite().javaName(), javaCacheResponse.getCipherSuite());
-    assertEquals(handshake.localCertificates(), javaCacheResponse.getLocalCertificateChain());
-    assertEquals(handshake.peerCertificates(), javaCacheResponse.getServerCertificateChain());
-    assertEquals(handshake.localPrincipal(), javaCacheResponse.getLocalPrincipal());
-    assertEquals(handshake.peerPrincipal(), javaCacheResponse.getPeerPrincipal());
-  }
-
-  @Test public void extractJavaHeaders() throws Exception {
-    Request okRequest = createArbitraryOkRequest().newBuilder()
-        .addHeader("key1", "value1_1")
-        .addHeader("key2", "value2")
-        .addHeader("key1", "value1_2")
-        .build();
-    Map<String, List<String>> javaHeaders = JavaApiConverter.extractJavaHeaders(okRequest);
-
-    assertEquals(Arrays.asList("value1_1", "value1_2"), javaHeaders.get("key1"));
-    assertEquals(Arrays.asList("value2"), javaHeaders.get("key2"));
-  }
-
-  @Test public void extractOkHeaders() {
-    Map<String, List<String>> javaResponseHeaders = new LinkedHashMap<>();
-    javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
-    javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
-    javaResponseHeaders.put("key2", Arrays.asList("value2"));
-
-    Headers okHeaders = JavaApiConverter.extractOkHeaders(javaResponseHeaders, null);
-    assertEquals(3, okHeaders.size()); // null entry should be stripped out
-    assertEquals(Arrays.asList("value1_1", "value1_2"), okHeaders.values("key1"));
-    assertEquals(Arrays.asList("value2"), okHeaders.values("key2"));
-  }
-
-  @Test public void extractStatusLine() throws Exception {
-    Map<String, List<String>> javaResponseHeaders = new LinkedHashMap<>();
-    javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
-    javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
-    javaResponseHeaders.put("key2", Arrays.asList("value2"));
-    assertEquals("StatusLine", JavaApiConverter.extractStatusLine(javaResponseHeaders));
-
-    try {
-      JavaApiConverter.extractStatusLine(Collections.<String, List<String>>emptyMap());
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  private static <T> void assertNotNullAndEquals(T expected, T actual) {
-    assertNotNull(actual);
-    assertEquals(expected, actual);
-  }
-
-  private static X509Certificate certificate(String certificate) {
-    try {
-      return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(
-          new ByteArrayInputStream(certificate.getBytes(Util.UTF_8)));
-    } catch (CertificateException e) {
-      fail();
-      return null;
-    }
-  }
-
-  @SafeVarargs
-  private static <T> Set<T> newSet(T... elements) {
-    return newSet(Arrays.asList(elements));
-  }
-
-  private static <T> Set<T> newSet(List<T> elements) {
-    return new LinkedHashSet<>(elements);
-  }
-
-  private static Request createArbitraryOkRequest() {
-    return new Request.Builder().url("http://arbitrary/url").build();
-  }
-
-  private static Response createArbitraryOkResponse(Request request) {
-    return new Response.Builder()
-        .request(request)
-        .protocol(Protocol.HTTP_1_1)
-        .code(200)
-        .message("Arbitrary")
-        .build();
-  }
-
-  private static Response createArbitraryOkResponse() {
-    return createArbitraryOkResponse(createArbitraryOkRequest());
-  }
-
-  private static RequestBody createRequestBody(String bodyText) {
-    return RequestBody.create(MediaType.parse("text/plain"), bodyText);
-  }
-
-  private static ResponseBody createResponseBody(String bodyText) {
-    final Buffer source = new Buffer().writeUtf8(bodyText);
-    final long contentLength = source.size();
-    return new ResponseBody() {
-      @Override public MediaType contentType() {
-        return MediaType.parse("text/plain; charset=utf-8");
-      }
-
-      @Override public long contentLength() {
-        return contentLength;
-      }
-
-      @Override public BufferedSource source() {
-        return source;
-      }
-    };
-  }
-
-  private String readAll(InputStream in) throws IOException {
-    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
-    int value;
-    while ((value = in.read()) != -1) {
-      buffer.write(value);
-    }
-    in.close();
-    return buffer.toString("UTF-8");
-  }
-}
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
deleted file mode 100644
index 17bd2d14b8..0000000000
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
+++ /dev/null
@@ -1,2200 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.internal.huc;
-
-import java.io.BufferedReader;
-import java.io.ByteArrayInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.net.CacheRequest;
-import java.net.CacheResponse;
-import java.net.CookieManager;
-import java.net.HttpCookie;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.ResponseCache;
-import java.net.SecureCacheResponse;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.net.URLConnection;
-import java.nio.charset.StandardCharsets;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.TimeZone;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import okhttp3.AbstractResponseCache;
-import okhttp3.AndroidInternal;
-import okhttp3.AndroidShimResponseCache;
-import okhttp3.Headers;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.internal.Internal;
-import okhttp3.internal.cache.InternalCache;
-import okhttp3.mockwebserver.internal.tls.SslClient;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeFalse;
-
-/**
- * Tests the interaction between OkHttp and {@link ResponseCache}. Based on okhttp3.CacheTest with
- * changes for ResponseCache and HttpURLConnection.
- */
-public final class ResponseCacheTest {
-  @Rule public TemporaryFolder cacheRule = new TemporaryFolder();
-  @Rule public MockWebServer server = new MockWebServer();
-  @Rule public MockWebServer server2 = new MockWebServer();
-
-  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  private SslClient sslClient = SslClient.localhost();
-  private ResponseCache cache;
-  private CookieManager cookieManager;
-  private OkUrlFactory urlFactory;
-
-  @Before public void setUp() throws Exception {
-    server.setProtocolNegotiationEnabled(false);
-
-    cache = AndroidShimResponseCache.create(cacheRule.getRoot(), 10 * 1024 * 1024);
-    urlFactory = new OkUrlFactory(new OkHttpClient());
-    AndroidInternal.setResponseCache(urlFactory, cache);
-
-    cookieManager = new CookieManager();
-  }
-
-  @After public void tearDown() throws Exception {
-    ResponseCache.setDefault(null);
-  }
-
-  private HttpURLConnection openConnection(URL url) {
-    return urlFactory.open(url);
-  }
-
-  /**
-   * Test that response caching is consistent with the RI and the spec.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
-   */
-  @Test public void responseCachingByResponseCode() throws Exception {
-    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
-    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
-
-    // We can't test 100 because it's not really a response.
-    // assertCached(false, 100);
-    assertCached(false, 101);
-    assertCached(false, 102);
-    assertCached(true, 200);
-    assertCached(false, 201);
-    assertCached(false, 202);
-    assertCached(true, 203);
-    assertCached(true, 204);
-    assertCached(false, 205);
-    assertCached(false, 206); //Electing to not cache partial responses
-    assertCached(false, 207);
-    assertCached(true, 300);
-    assertCached(true, 301);
-    assertCached(true, 302);
-    assertCached(false, 303);
-    assertCached(false, 304);
-    assertCached(false, 305);
-    assertCached(false, 306);
-    assertCached(true, 307);
-    assertCached(true, 308);
-    assertCached(false, 400);
-    assertCached(false, 401);
-    assertCached(false, 402);
-    assertCached(false, 403);
-    assertCached(true, 404);
-    assertCached(true, 405);
-    assertCached(false, 406);
-    assertCached(false, 408);
-    assertCached(false, 409);
-    // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true, 410);
-    assertCached(false, 411);
-    assertCached(false, 412);
-    assertCached(false, 413);
-    assertCached(true, 414);
-    assertCached(false, 415);
-    assertCached(false, 416);
-    assertCached(false, 417);
-    assertCached(false, 418);
-
-    assertCached(false, 500);
-    assertCached(true, 501);
-    assertCached(false, 502);
-    assertCached(false, 503);
-    assertCached(false, 504);
-    assertCached(false, 505);
-    assertCached(false, 506);
-  }
-
-  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
-    int expectedResponseCode = responseCode;
-
-    server = new MockWebServer();
-    MockResponse mockResponse = new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(responseCode)
-        .setBody("ABCDE")
-        .addHeader("WWW-Authenticate: challenge");
-    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
-      mockResponse.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
-      mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
-        || responseCode == HttpURLConnection.HTTP_RESET) {
-      mockResponse.setBody(""); // We forbid bodies for 204 and 205.
-    }
-    server.enqueue(mockResponse);
-
-    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
-      // 408's are a bit of an outlier because we may repeat the request if we encounter this
-      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
-      // because of the retry. We just want to ensure the initial 408 isn't cached.
-      expectedResponseCode = 200;
-      server.enqueue(new MockResponse()
-          .setHeader("Cache-Control", "no-store")
-          .setBody("FGHIJ"));
-    }
-
-    server.start();
-
-    URL url = server.url("/").url();
-    HttpURLConnection connection = openConnection(url);
-    assertEquals(expectedResponseCode, connection.getResponseCode());
-
-    // Exhaust the content stream.
-    readAscii(connection);
-
-    CacheResponse cached = cache.get(url.toURI(), "GET", null);
-    if (shouldPut) {
-      assertNotNull(Integer.toString(responseCode), cached);
-    } else {
-      assertNull(Integer.toString(responseCode), cached);
-    }
-    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
-    testResponseCaching(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
-    testResponseCaching(TransferKind.CHUNKED);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
-    testResponseCaching(TransferKind.END_OF_STREAM);
-  }
-
-  /**
-   * HttpURLConnection.getInputStream().skip(long) causes ResponseCache corruption
-   * http://code.google.com/p/android/issues/detail?id=8175
-   */
-  private void testResponseCaching(TransferKind transferKind) throws IOException {
-    MockResponse mockResponse = new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setStatus("HTTP/1.1 200 Fantastic");
-    transferKind.setBody(mockResponse, "I love puppies but hate spiders", 1);
-    server.enqueue(mockResponse);
-
-    // Make sure that calling skip() doesn't omit bytes from the cache.
-    HttpURLConnection urlConnection = openConnection(server.url("/").url());
-    InputStream in = urlConnection.getInputStream();
-    assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
-    reliableSkip(in, "puppies but hate ".length());
-    assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
-    assertEquals(-1, in.read());
-    in.close();
-
-    urlConnection = openConnection(server.url("/").url()); // cached!
-    in = urlConnection.getInputStream();
-    assertEquals("I love puppies but hate spiders",
-        readAscii(urlConnection, "I love puppies but hate spiders".length()));
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-
-    assertEquals(-1, in.read());
-    in.close();
-  }
-
-  @Test public void secureResponseCaching() throws IOException {
-    assumeFalse(getPlatform().equals("jdk9"));
-
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-
-    HttpsURLConnection c1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    c1.setSSLSocketFactory(sslClient.socketFactory);
-    c1.setHostnameVerifier(hostnameVerifier);
-    assertEquals("ABC", readAscii(c1));
-
-    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    String suite = c1.getCipherSuite();
-    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
-    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
-    Principal peerPrincipal = c1.getPeerPrincipal();
-    Principal localPrincipal = c1.getLocalPrincipal();
-
-    HttpsURLConnection c2 = (HttpsURLConnection) openConnection(server.url("/").url()); // cached!
-    c2.setSSLSocketFactory(sslClient.socketFactory);
-    c2.setHostnameVerifier(hostnameVerifier);
-    assertEquals("ABC", readAscii(c2));
-
-    assertEquals(suite, c2.getCipherSuite());
-    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
-    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
-    assertEquals(peerPrincipal, c2.getPeerPrincipal());
-    assertEquals(localPrincipal, c2.getLocalPrincipal());
-  }
-
-  @Test public void responseCachingAndRedirects() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    assertEquals("ABC", readAscii(connection));
-
-    connection = openConnection(server.url("/").url()); // cached!
-    assertEquals("ABC", readAscii(connection));
-  }
-
-  @Test public void redirectToCachedResult() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    assertEquals("ABC", readAscii(openConnection(server.url("/foo").url())));
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
-    assertEquals(0, request1.getSequenceNumber());
-
-    assertEquals("ABC", readAscii(openConnection(server.url("/bar").url())));
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
-    assertEquals(1, request2.getSequenceNumber());
-
-    // an unrelated request should reuse the pooled connection
-    assertEquals("DEF", readAscii(openConnection(server.url("/baz").url())));
-    RecordedRequest request3 = server.takeRequest();
-    assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
-    assertEquals(2, request3.getSequenceNumber());
-  }
-
-  @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-
-    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    assertEquals("ABC", readAscii(connection1));
-    assertNotNull(connection1.getCipherSuite());
-
-    // Cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.url("/").url());
-    assertEquals("ABC", readAscii(connection2));
-    assertNotNull(connection2.getCipherSuite());
-
-    assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
-  }
-
-  /**
-   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
-   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
-   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
-   *
-   * https://github.com/square/okhttp/issues/214
-   */
-  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslClient.socketFactory, false);
-    server2.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server2.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: " + server2.url("/").url()));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-
-    HttpURLConnection connection1 = openConnection(server.url("/").url());
-    assertEquals("ABC", readAscii(connection1));
-
-    // Cached!
-    HttpURLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("ABC", readAscii(connection2));
-  }
-
-  @Test public void foundCachedWithExpiresHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(302, "Expires", formatDate(1, TimeUnit.HOURS));
-  }
-
-  @Test public void foundCachedWithCacheControlHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(302, "Cache-Control", "max-age=60");
-  }
-
-  @Test public void temporaryRedirectCachedWithExpiresHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(307, "Expires", formatDate(1, TimeUnit.HOURS));
-  }
-
-  @Test public void temporaryRedirectCachedWithCacheControlHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(307, "Cache-Control", "max-age=60");
-  }
-
-  @Test public void foundNotCachedWithoutCacheHeader() throws Exception {
-    temporaryRedirectNotCachedWithoutCachingHeader(302);
-  }
-
-  @Test public void temporaryRedirectNotCachedWithoutCacheHeader() throws Exception {
-    temporaryRedirectNotCachedWithoutCachingHeader(307);
-  }
-
-  private void temporaryRedirectCachedWithCachingHeader(
-      int responseCode, String headerName, String headerValue) throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader(headerName, headerValue)
-        .addHeader("Location", "/a"));
-    server.enqueue(new MockResponse()
-        .addHeader(headerName, headerValue)
-        .setBody("a"));
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-    server.enqueue(new MockResponse()
-        .setBody("c"));
-
-    URL url = server.url("/").url();
-    assertEquals("a", readAscii(openConnection(url)));
-    assertEquals("a", readAscii(openConnection(url)));
-  }
-
-  private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader("Location", "/a"));
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-
-    URL url = server.url("/").url();
-    assertEquals("a", readAscii(openConnection(url)));
-    assertEquals("b", readAscii(openConnection(url)));
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
-    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
-    testServerPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
-    // Intentionally empty. This case doesn't make sense because there's no
-    // such thing as a premature disconnect when the disconnect itself
-    // indicates the end of the data stream.
-  }
-
-  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
-    server.enqueue(truncateViolently(response, 16));
-    server.enqueue(new MockResponse()
-        .setBody("Request #2"));
-
-    BufferedReader reader = new BufferedReader(
-        new InputStreamReader(openConnection(server.url("/").url()).getInputStream()));
-    assertEquals("ABCDE", reader.readLine());
-    try {
-      reader.readLine();
-      fail("This implementation silently ignored a truncated HTTP body.");
-    } catch (IOException expected) {
-    } finally {
-      reader.close();
-    }
-
-    URLConnection connection = openConnection(server.url("/").url());
-    assertEquals("Request #2", readAscii(connection));
-  }
-
-  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
-    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
-    testClientPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
-    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
-  }
-
-  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
-    // Setting a low transfer speed ensures that stream discarding will time out.
-    MockResponse response = new MockResponse()
-        .throttleBody(6, 1, TimeUnit.SECONDS);
-    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(response);
-    server.enqueue(new MockResponse()
-        .setBody("Request #2"));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals("ABCDE", readAscii(connection, 5));
-    in.close();
-    try {
-      in.read();
-      fail("Expected an IOException because the stream is closed.");
-    } catch (IOException expected) {
-    }
-
-    connection = openConnection(server.url("/").url());
-    assertEquals("Request #2", readAscii(connection));
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
-    //      last modified: 105 seconds ago
-    //             served:   5 seconds ago
-    //   default lifetime: (105 - 5) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds from now
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-        .setBody("A"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
-    assertEquals("A", readAscii(connection));
-    assertNull(connection.getHeaderField("Warning"));
-  }
-
-  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
-    //      last modified: 115 seconds ago
-    //             served:  15 seconds ago
-    //   default lifetime: (115 - 15) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds ago
-    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
-    //      last modified: 105 days ago
-    //             served:   5 days ago
-    //   default lifetime: (105 - 5) / 10 = 10 days
-    //            expires:  10 days from served date = 5 days from now
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
-        .setBody("A"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    URLConnection connection = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection));
-    assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
-        connection.getHeaderField("Warning"));
-  }
-
-  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/?foo=bar").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
-  }
-
-  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void expirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Cache-Control: max-age=60"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
-    // Chrome interprets max-age relative to the local clock. Both our cache
-    // and Firefox both use the earlier of the local and server's clock.
-    assertNotCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=60")
-        .addHeader("Cache-Control: max-age=180"));
-  }
-
-  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=180")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void requestMethodOptionsIsNotCached() throws Exception {
-    testRequestMethod("OPTIONS", false);
-  }
-
-  @Test public void requestMethodGetIsCached() throws Exception {
-    testRequestMethod("GET", true);
-  }
-
-  @Test public void requestMethodHeadIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("HEAD", false);
-  }
-
-  @Test public void requestMethodPostIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("POST", false);
-  }
-
-  @Test public void requestMethodPutIsNotCached() throws Exception {
-    testRequestMethod("PUT", false);
-  }
-
-  @Test public void requestMethodDeleteIsNotCached() throws Exception {
-    testRequestMethod("DELETE", false);
-  }
-
-  @Test public void requestMethodTraceIsNotCached() throws Exception {
-    testRequestMethod("TRACE", false);
-  }
-
-  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
-    // 1. seed the cache (potentially)
-    // 2. expect a cache hit or miss
-    server.enqueue(new MockResponse()
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("X-Response-ID: 1"));
-    server.enqueue(new MockResponse()
-        .addHeader("X-Response-ID: 2"));
-
-    URL url = server.url("/").url();
-
-    HttpURLConnection request1 = openConnection(url);
-    request1.setRequestMethod(requestMethod);
-    addRequestBodyIfNecessary(requestMethod, request1);
-    request1.getInputStream().close();
-    assertEquals("1", request1.getHeaderField("X-Response-ID"));
-
-    URLConnection request2 = openConnection(url);
-    request2.getInputStream().close();
-    if (expectCached) {
-      assertEquals("1", request2.getHeaderField("X-Response-ID"));
-    } else {
-      assertEquals("2", request2.getHeaderField("X-Response-ID"));
-    }
-  }
-
-  private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection connection)
-      throws IOException {
-    if (requestMethod.equals("POST") || requestMethod.equals("PUT")) {
-      connection.setDoOutput(true);
-      OutputStream requestBody = connection.getOutputStream();
-      requestBody.write('x');
-      requestBody.close();
-    }
-  }
-
-  @Test public void postInvalidatesCache() throws Exception {
-    testMethodInvalidates("POST");
-  }
-
-  @Test public void putInvalidatesCache() throws Exception {
-    testMethodInvalidates("PUT");
-  }
-
-  @Test public void deleteMethodInvalidatesCache() throws Exception {
-    testMethodInvalidates("DELETE");
-  }
-
-  private void testMethodInvalidates(String requestMethod) throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it
-    // 3. expect a cache miss
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    URL url = server.url("/").url();
-
-    assertEquals("A", readAscii(openConnection(url)));
-
-    HttpURLConnection invalidateConnection = openConnection(url);
-    invalidateConnection.setRequestMethod(requestMethod);
-    assertEquals("B", readAscii(invalidateConnection));
-
-    assertEquals("C", readAscii(openConnection(url)));
-  }
-
-  /**
-   * Equivalent to {@code CacheTest.postInvalidatesCacheWithUncacheableResponse()} but demonstrating
-   * that {@link ResponseCache} provides no mechanism for cache invalidation as the result of
-   * locally-made requests. In reality invalidation could take place from other clients at any
-   * time.
-   */
-  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it with uncacheable response
-    // 3. the cache to return the original value
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .setResponseCode(500));
-
-    URL url = server.url("/").url();
-
-    assertEquals("A", readAscii(openConnection(url)));
-
-    HttpURLConnection invalidate = openConnection(url);
-    invalidate.setRequestMethod("POST");
-    addRequestBodyIfNecessary("POST", invalidate);
-    assertEquals("B", readAscii(invalidate));
-
-    assertEquals("A", readAscii(openConnection(url)));
-  }
-
-  @Test public void etag() throws Exception {
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("ETag: v1"));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-  }
-
-  /** If both If-Modified-Since and If-None-Match conditions apply, send only If-None-Match. */
-  @Test public void etagAndExpirationDateInThePast() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void cacheControlNoCache() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Cache-Control: no-cache"));
-  }
-
-  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void pragmaNoCache() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Pragma: no-cache"));
-  }
-
-  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Pragma: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void cacheControlNoStore() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
-    // 1. request a range
-    // 2. request a full document, expecting a cache miss
-    server.enqueue(new MockResponse()
-        .setBody("AA")
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 1000-1001/2000"));
-    server.enqueue(new MockResponse()
-        .setBody("BB"));
-
-    URL url = server.url("/").url();
-
-    HttpURLConnection range = openConnection(url);
-    range.addRequestProperty("Range", "bytes=1000-1001");
-    assertEquals("AA", readAscii(range));
-
-    assertEquals("BB", readAscii(openConnection(url)));
-  }
-
-  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
-
-    URL url = server.url("/").url();
-
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
-  }
-
-  @Test public void clientSideNoStore() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("B"));
-
-    HttpURLConnection connection1 = openConnection(server.url("/").url());
-    connection1.setRequestProperty("Cache-Control", "no-store");
-    assertEquals("A", readAscii(connection1));
-
-    HttpURLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("B", readAscii(connection2));
-  }
-
-  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
-    assertNonIdentityEncodingCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
-    assertNonIdentityEncodingCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
-    server.enqueue(response
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // At least three request/response pairs are required because after the first request is cached
-    // a different execution path might be taken. Thus modifications to the cache applied during
-    // the second request might not be visible until another request is performed.
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void notModifiedSpecifiesEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setBody("DEFDEFDEF"));
-
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-    assertEquals("DEFDEFDEF", readAscii(openConnection(server.url("/").url())));
-  }
-
-  /** https://github.com/square/okhttp/issues/947 */
-  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Vary: Accept-Encoding")
-        .addHeader("Cache-Control: max-age=60"));
-    server.enqueue(new MockResponse()
-        .setBody("FAIL"));
-
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void expiresDateBeforeModifiedDate() throws Exception {
-    assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
-  }
-
-  @Test public void requestMaxAge() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "max-age=30");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestMinFresh() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "min-fresh=120");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestMaxStale() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "max-stale=180");
-    assertEquals("A", readAscii(connection));
-    assertEquals("110 HttpURLConnection \"Response is stale\"",
-        connection.getHeaderField("Warning"));
-  }
-
-  @Test public void requestMaxStaleDirectiveWithNoValue() throws IOException {
-    // Add a stale response to the cache.
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    // With max-stale, we'll return that stale response.
-    URLConnection maxStaleConnection = openConnection(server.url("/").url());
-    maxStaleConnection.setRequestProperty("Cache-Control", "max-stale");
-    assertEquals("A", readAscii(maxStaleConnection));
-    assertEquals("110 HttpURLConnection \"Response is stale\"",
-        maxStaleConnection.getHeaderField("Warning"));
-  }
-
-  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120, must-revalidate")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "max-stale=180");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
-    // (no responses enqueued)
-
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-  }
-
-  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-  }
-
-  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-  }
-
-  @Test public void requestCacheControlNoCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
-    connection.setRequestProperty("Cache-Control", "no-cache");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestPragmaNoCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    URLConnection connection = openConnection(url);
-    connection.setRequestProperty("Pragma", "no-cache");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
-    MockResponse response = new MockResponse()
-        .addHeader("ETag: v3")
-        .addHeader("Cache-Control: max-age=0");
-    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
-    RecordedRequest request =
-        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
-    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
-    assertNull(request.getHeader("If-None-Match"));
-  }
-
-  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
-    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
-    MockResponse response = new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: max-age=0");
-    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
-    assertEquals("v1", request.getHeader("If-None-Match"));
-    assertNull(request.getHeader("If-Modified-Since"));
-  }
-
-  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
-      String conditionValue) throws Exception {
-    server.enqueue(seed.setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-
-    HttpURLConnection connection = openConnection(url);
-    connection.addRequestProperty(conditionName, conditionValue);
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
-    assertEquals("", readAscii(connection));
-
-    server.takeRequest(); // seed
-    return server.takeRequest();
-  }
-
-  /**
-   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
-   * served.
-   */
-  @Test public void retainServedDateFormat() throws Exception {
-    // Serve a response with a non-standard date format that OkHttp supports.
-    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
-    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
-    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
-    String lastModifiedString = dateFormat.format(lastModifiedDate);
-    String servedString = dateFormat.format(servedDate);
-
-    // This response should be conditionally cached.
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedString)
-        .addHeader("Expires: " + servedString)
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-
-    // The first request has no conditions.
-    RecordedRequest request1 = server.takeRequest();
-    assertNull(request1.getHeader("If-Modified-Since"));
-
-    // The 2nd request uses the server's date format.
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
-    connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
-    assertEquals("", readAscii(connection));
-  }
-
-  @Test public void authorizationRequestFullyCached() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection connection = openConnection(url);
-    connection.addRequestProperty("Authorization", "password");
-    assertEquals("A", readAscii(connection));
-    assertEquals("A", readAscii(openConnection(url)));
-  }
-
-  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Content-Location: /bar")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/foo").url())));
-    assertEquals("B", readAscii(openConnection(server.url("/bar").url())));
-  }
-
-  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/a").url())));
-    assertEquals("A", readAscii(openConnection(server.url("/a").url())));
-    assertEquals("B", readAscii(openConnection(server.url("/b").url())));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frenchConnection = openConnection(url);
-    frenchConnection.setRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(frenchConnection));
-
-    HttpURLConnection englishConnection = openConnection(url);
-    englishConnection.setRequestProperty("Accept-Language", "en-US");
-    assertEquals("B", readAscii(englishConnection));
-  }
-
-  @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frenchConnection1 = openConnection(url);
-    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(frenchConnection1));
-
-    HttpURLConnection frenchConnection2 = openConnection(url);
-    frenchConnection2.setRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(frenchConnection2));
-  }
-
-  @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    HttpURLConnection connection2 = openConnection(server.url("/").url());
-    connection2.setRequestProperty("Foo", "bar");
-    assertEquals("B", readAscii(connection2));
-  }
-
-  @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpURLConnection connection1 = openConnection(server.url("/").url());
-    connection1.setRequestProperty("Foo", "bar");
-    assertEquals("A", readAscii(connection1));
-    assertEquals("B", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void varyFieldsAreCaseInsensitive() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: ACCEPT-LANGUAGE")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frenchConnection1 = openConnection(url);
-    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(frenchConnection1));
-    HttpURLConnection frenchConnection2 = openConnection(url);
-    frenchConnection2.setRequestProperty("accept-language", "fr-CA");
-    assertEquals("A", readAscii(frenchConnection2));
-  }
-
-  @Test public void varyMultipleFieldsWithMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frenchConnection1 = openConnection(url);
-    frenchConnection1.setRequestProperty("Accept-Language", "fr-CA");
-    frenchConnection1.setRequestProperty("Accept-Charset", "UTF-8");
-    frenchConnection1.setRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(frenchConnection1));
-    HttpURLConnection frenchConnection2 = openConnection(url);
-    frenchConnection2.setRequestProperty("Accept-Language", "fr-CA");
-    frenchConnection2.setRequestProperty("Accept-Charset", "UTF-8");
-    frenchConnection2.setRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(frenchConnection2));
-  }
-
-  @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frenchConnection = openConnection(url);
-    frenchConnection.setRequestProperty("Accept-Language", "fr-CA");
-    frenchConnection.setRequestProperty("Accept-Charset", "UTF-8");
-    frenchConnection.setRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(frenchConnection));
-    HttpURLConnection englishConnection = openConnection(url);
-    englishConnection.setRequestProperty("Accept-Language", "en-CA");
-    englishConnection.setRequestProperty("Accept-Charset", "UTF-8");
-    englishConnection.setRequestProperty("Accept-Encoding", "identity");
-    assertEquals("B", readAscii(englishConnection));
-  }
-
-  @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection multiConnection1 = openConnection(url);
-    multiConnection1.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    multiConnection1.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(multiConnection1));
-
-    HttpURLConnection multiConnection2 = openConnection(url);
-    multiConnection2.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    multiConnection2.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(multiConnection2));
-  }
-
-  @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection multiConnection = openConnection(url);
-    multiConnection.setRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    multiConnection.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(multiConnection));
-
-    HttpURLConnection notFrenchConnection = openConnection(url);
-    notFrenchConnection.setRequestProperty("Accept-Language", "fr-CA");
-    notFrenchConnection.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("B", readAscii(notFrenchConnection));
-  }
-
-  @Test public void varyAsterisk() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: *")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    assertEquals("B", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void varyAndHttps() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-
-    URL url = server.url("/").url();
-    HttpURLConnection connection1 = openConnection(url);
-    connection1.setRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection1));
-
-    HttpURLConnection connection2 = openConnection(url);
-    connection2.setRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Allow: GET, HEAD")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Allow: GET, HEAD, PUT")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
-
-    URLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
-  }
-
-  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Transfer-Encoding: identity")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Transfer-Encoding: none")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
-
-    URLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
-  }
-
-  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Warning: 199 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("199 test danger", connection1.getHeaderField("Warning"));
-
-    URLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals(null, connection2.getHeaderField("Warning"));
-  }
-
-  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Warning: 299 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("299 test danger", connection1.getHeaderField("Warning"));
-
-    URLConnection connection2 = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("299 test danger", connection2.getHeaderField("Warning"));
-  }
-
-  public void assertCookies(URL url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<>();
-    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
-      actualCookies.add(cookie.toString());
-    }
-    assertEquals(Arrays.asList(expectedCookies), actualCookies);
-  }
-
-  @Test public void doNotCachePartialResponse() throws Exception {
-    assertNotCached(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 100-100/200")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  /**
-   * Equivalent to {@code CacheTest.conditionalHitUpdatesCache()}, except a Java standard cache has
-   * no means to update the headers for an existing entry so the behavior is different.
-   */
-  @Test public void conditionalHitDoesNotUpdateCache() throws Exception {
-    // A response that is cacheable, but with a short life.
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    // A response that refers to the previous response, but is cacheable with a long life.
-    // Contains a header we can recognize as having come from the server.
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Allow: GET, HEAD")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    // A response that is cacheable with a long life.
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .addHeader("Cache-Control: max-age=30"));
-    // A response that should never be requested.
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    // cache miss; seed the cache with an entry that will require a network hit to be sure it is
-    // still valid
-    HttpURLConnection connection1 = openConnection(server.url("/a").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals(null, connection1.getHeaderField("Allow"));
-
-    // conditional cache hit; The cached data should be returned, but the cache is not updated.
-    HttpURLConnection connection2 = openConnection(server.url("/a").url());
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
-
-    // conditional cache hit; The server responds with new data. The cache is updated.
-    HttpURLConnection connection3 = openConnection(server.url("/a").url());
-    assertEquals("B", readAscii(connection3));
-
-    // full cache hit; The data from connection3 has now replaced that from connection 1.
-    HttpURLConnection connection4 = openConnection(server.url("/a").url());
-    assertEquals("B", readAscii(connection4));
-
-    assertEquals(3, server.getRequestCount());
-  }
-
-  @Test public void responseSourceHeaderCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=0")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(304));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
-    Headers.Builder headers = new Headers.Builder()
-        .add("Cache-Control: max-age=120");
-    Internal.instance.addLenient(headers, ": A");
-    server.enqueue(new MockResponse()
-        .setHeaders(headers.build())
-        .setBody("body"));
-
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    assertEquals("A", connection.getHeaderField(""));
-  }
-
-  /**
-   * @param delta the offset from the current date to use. Negative values yield dates in the past;
-   * positive values yield dates in the future.
-   */
-  private String formatDate(long delta, TimeUnit timeUnit) {
-    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private String formatDate(Date date) {
-    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
-    return rfc1123.format(date);
-  }
-
-  private void assertNotCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("B", readAscii(openConnection(url)));
-  }
-
-  /** @return the request with the conditional get headers. */
-  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
-    // scenario 1: condition succeeds
-    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // scenario 2: condition fails
-    server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
-
-    URL valid = server.url("/valid").url();
-    HttpURLConnection connection1 = openConnection(valid);
-    assertEquals("A", readAscii(connection1));
-    assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
-    assertEquals("A-OK", connection1.getResponseMessage());
-    HttpURLConnection connection2 = openConnection(valid);
-    assertEquals("A", readAscii(connection2));
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertEquals("A-OK", connection2.getResponseMessage());
-
-    URL invalid = server.url("/invalid").url();
-    HttpURLConnection connection3 = openConnection(invalid);
-    assertEquals("B", readAscii(connection3));
-    assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
-    assertEquals("B-OK", connection3.getResponseMessage());
-    HttpURLConnection connection4 = openConnection(invalid);
-    assertEquals("C", readAscii(connection4));
-    assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
-    assertEquals("C-OK", connection4.getResponseMessage());
-
-    server.takeRequest(); // regular get
-    return server.takeRequest(); // conditional get
-  }
-
-  private void assertFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(response.setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(openConnection(url)));
-    assertEquals("A", readAscii(openConnection(url)));
-  }
-
-  /**
-   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
-   * how clients respond to the premature conclusion of the HTTP body.
-   */
-  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
-    response.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
-    Headers headers = response.getHeaders();
-    Buffer truncatedBody = new Buffer();
-    truncatedBody.write(response.getBody(), numBytesToKeep);
-    response.setBody(truncatedBody);
-    response.setHeaders(headers);
-    return response;
-  }
-
-  enum TransferKind {
-    CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
-        response.setChunkedBody(content, chunkSize);
-      }
-    },
-    FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-      }
-    },
-    END_OF_STREAM() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(SocketPolicy.DISCONNECT_AT_END);
-        response.removeHeader("Content-Length");
-      }
-    };
-
-    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, new Buffer().writeUtf8(content), chunkSize);
-    }
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(result));
-    sink.writeUtf8(data);
-    sink.close();
-    return result;
-  }
-
-  /**
-   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
-   * characters can be read, the remaining characters are returned and the stream is closed.
-   */
-  private String readAscii(URLConnection connection, int count) throws IOException {
-    HttpURLConnection httpConnection = (HttpURLConnection) connection;
-    InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
-        ? connection.getInputStream() : httpConnection.getErrorStream();
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  private String readAscii(URLConnection connection) throws IOException {
-    return readAscii(connection, Integer.MAX_VALUE);
-  }
-
-  private void reliableSkip(InputStream in, int length) throws IOException {
-    while (length > 0) {
-      length -= in.skip(length);
-    }
-  }
-
-  private void assertGatewayTimeout(HttpURLConnection connection) throws IOException {
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (FileNotFoundException expected) {
-    }
-    assertEquals(504, connection.getResponseCode());
-    assertEquals(-1, connection.getErrorStream().read());
-  }
-
-  private static <T> List<T> toListOrNull(T[] arrayOrNull) {
-    return arrayOrNull != null ? Arrays.asList(arrayOrNull) : null;
-  }
-
-  // Android-added tests.
-
-  /**
-   * Test that we can interrogate the response when the cache is being populated.
-   * http://code.google.com/p/android/issues/detail?id=7787
-   */
-  @Test public void responseCacheCallbackApis() throws Exception {
-    final String body = "ABCDE";
-    final AtomicInteger cacheCount = new AtomicInteger();
-
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 200 Fantastic")
-        .addHeader("Content-Type: text/plain")
-        .addHeader("fgh: ijk")
-        .setBody(body));
-
-    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        HttpURLConnection httpURLConnection = (HttpURLConnection) connection;
-        assertEquals(server.url("/").url(), uri.toURL());
-        assertEquals(200, httpURLConnection.getResponseCode());
-        InputStream is = httpURLConnection.getInputStream();
-        try {
-          is.read();
-          fail();
-        } catch (UnsupportedOperationException expected) {
-        }
-        assertEquals("5", connection.getHeaderField("Content-Length"));
-        assertEquals("text/plain", connection.getHeaderField("Content-Type"));
-        assertEquals("ijk", connection.getHeaderField("fgh"));
-        cacheCount.incrementAndGet();
-        return null;
-      }
-    }));
-
-    URL url = server.url("/").url();
-    HttpURLConnection connection = openConnection(url);
-    assertEquals(body, readAscii(connection));
-    assertEquals(1, cacheCount.get());
-  }
-
-  /** Don't explode if the cache returns a null body. http://b/3373699 */
-  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
-    final AtomicBoolean aborted = new AtomicBoolean();
-    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
-      @Override public CacheRequest put(URI uri, URLConnection connection) {
-        return new CacheRequest() {
-          @Override public void abort() {
-            aborted.set(true);
-          }
-
-          @Override public OutputStream getBody() throws IOException {
-            return null;
-          }
-        };
-      }
-    }));
-
-    server.enqueue(new MockResponse().setBody("abcdef"));
-
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    assertEquals("abc", readAscii(connection, 3));
-    connection.getInputStream().close();
-    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
-  }
-
-  /**
-   * Fail if a badly-behaved cache returns a null status line header.
-   * https://code.google.com/p/android/issues/detail?id=160522
-   */
-  @Test public void responseCacheReturnsNullStatusLine() throws Exception {
-    String cachedContentString = "Hello";
-    final byte[] cachedContent = cachedContentString.getBytes(StandardCharsets.US_ASCII);
-
-    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
-      @Override
-      public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders)
-          throws IOException {
-        return new CacheResponse() {
-          @Override public Map<String, List<String>> getHeaders() throws IOException {
-            String contentType = "text/plain";
-            Map<String, List<String>> headers = new LinkedHashMap<>();
-            headers.put("Content-Length", Arrays.asList(Integer.toString(cachedContent.length)));
-            headers.put("Content-Type", Arrays.asList(contentType));
-            headers.put("Expires", Arrays.asList(formatDate(-1, TimeUnit.HOURS)));
-            headers.put("Cache-Control", Arrays.asList("max-age=60"));
-            // Crucially, the header with a null key is missing, which renders the cache response
-            // unusable because OkHttp only caches responses with cacheable response codes.
-            return headers;
-          }
-
-          @Override public InputStream getBody() throws IOException {
-            return new ByteArrayInputStream(cachedContent);
-          }
-        };
-      }
-    }));
-    HttpURLConnection connection = openConnection(server.url("/").url());
-    // If there was no status line from the cache an exception will be thrown. No network request
-    // should be made.
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  private static class InsecureResponseCache extends ResponseCache {
-
-    private final ResponseCache delegate;
-
-    private InsecureResponseCache(ResponseCache delegate) {
-      this.delegate = delegate;
-    }
-
-    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-      return delegate.put(uri, connection);
-    }
-
-    @Override public CacheResponse get(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) throws IOException {
-      final CacheResponse response = delegate.get(uri, requestMethod, requestHeaders);
-      if (response instanceof SecureCacheResponse) {
-        return new CacheResponse() {
-          @Override public InputStream getBody() throws IOException {
-            return response.getBody();
-          }
-
-          @Override public Map<String, List<String>> getHeaders() throws IOException {
-            return response.getHeaders();
-          }
-        };
-      }
-      return response;
-    }
-  }
-
-  @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
-    assumeFalse(getPlatform().equals("jdk9"));
-
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-
-    AndroidInternal.setResponseCache(urlFactory, new InsecureResponseCache(cache));
-
-    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    connection1.setSSLSocketFactory(sslClient.socketFactory);
-    connection1.setHostnameVerifier(hostnameVerifier);
-    assertEquals("ABC", readAscii(connection1));
-
-    // Not cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.url("/").url());
-    connection2.setSSLSocketFactory(sslClient.socketFactory);
-    connection2.setHostnameVerifier(hostnameVerifier);
-    assertEquals("DEF", readAscii(connection2));
-  }
-
-  @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    final AtomicReference<Map<String, List<String>>> requestHeadersRef = new AtomicReference<>();
-    setInternalCache(new CacheAdapter(new AbstractResponseCache() {
-      @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
-        requestHeadersRef.set(requestHeaders);
-        return null;
-      }
-    }));
-
-    URL url = server.url("/").url();
-    URLConnection urlConnection = openConnection(url);
-    urlConnection.addRequestProperty("A", "android");
-    readAscii(urlConnection);
-    assertEquals(Arrays.asList("android"), requestHeadersRef.get().get("A"));
-  }
-
-  @Test public void responseCachingWithoutBody() throws IOException {
-    MockResponse response =
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .setStatus("HTTP/1.1 200 Fantastic");
-    server.enqueue(response);
-
-    HttpURLConnection urlConnection = openConnection(server.url("/").url());
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-    assertTrue(urlConnection.getDoInput());
-    InputStream is = urlConnection.getInputStream();
-    assertEquals(-1, is.read());
-    is.close();
-
-    urlConnection = openConnection(server.url("/").url()); // cached!
-    assertTrue(urlConnection.getDoInput());
-    InputStream cachedIs = urlConnection.getInputStream();
-    assertEquals(-1, cachedIs.read());
-    cachedIs.close();
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-  }
-
-  @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.setUseCaches(false);
-    assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(openConnection(server.url("/").url())));
-  }
-
-  @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertEquals("A", readAscii(openConnection(server.url("/").url())));
-    URLConnection connection = openConnection(server.url("/").url());
-    connection.setUseCaches(false);
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
-    URL url = new URL("http://localhost/");
-    URLConnection c1 = openConnection(url);
-    URLConnection c2 = openConnection(url);
-    assertTrue(c1.getDefaultUseCaches());
-    c1.setDefaultUseCaches(false);
-    try {
-      assertTrue(c1.getUseCaches());
-      assertTrue(c2.getUseCaches());
-      URLConnection c3 = openConnection(url);
-      assertFalse(c3.getUseCaches());
-    } finally {
-      c1.setDefaultUseCaches(true);
-    }
-  }
-
-  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
-  // default ResponseCache. We try to keep this case working as much as possible because apps break
-  // if we don't.
-  @Test public void otherStacks_cacheHitWithoutVary() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("FAIL"));
-
-    // Set the cache as the shared cache.
-    ResponseCache.setDefault(cache);
-
-    // Use the platform's HTTP stack.
-    URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof OkHttpURLConnection);
-    assertEquals("A", readAscii(connection));
-
-    URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof OkHttpURLConnection);
-    assertEquals("A", readAscii(connection2));
-  }
-
-  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
-  // default ResponseCache. We can't keep the Vary case working because we can't get to the Vary
-  // request headers after connect(). Accept-Encoding has special behavior so we test it explicitly.
-  @Test public void otherStacks_cacheMissWithVaryAcceptEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    // Set the cache as the shared cache.
-    ResponseCache.setDefault(cache);
-
-    // Use the platform's HTTP stack.
-    URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof OkHttpURLConnection);
-    assertEquals("A", readAscii(connection));
-
-    URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof OkHttpURLConnection);
-    assertEquals("B", readAscii(connection2));
-  }
-
-  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
-  // default ResponseCache. We can't keep the Vary case working because we can't get to the Vary
-  // request headers after connect().
-  @Test public void otherStacks_cacheMissWithVary() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    // Set the cache as the shared cache.
-    ResponseCache.setDefault(cache);
-
-    // Use the platform's HTTP stack.
-    URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof OkHttpURLConnection);
-    connection.setRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection));
-
-    URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof OkHttpURLConnection);
-    assertEquals("B", readAscii(connection2));
-  }
-
-  // Other stacks (e.g. older versions of OkHttp bundled inside Android apps) can interact with the
-  // default ResponseCache. We can't keep the Vary case working, because we can't get to the Vary
-  // request headers after connect().
-  @Test public void otherStacks_cacheMissWithVaryAsterisk() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: *")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    // Set the cache as the shared cache.
-    ResponseCache.setDefault(cache);
-
-    // Use the platform's HTTP stack.
-    URLConnection connection = server.url("/").url().openConnection();
-    assertFalse(connection instanceof OkHttpURLConnection);
-    assertEquals("A", readAscii(connection));
-
-    URLConnection connection2 = server.url("/").url().openConnection();
-    assertFalse(connection2 instanceof OkHttpURLConnection);
-    assertEquals("B", readAscii(connection2));
-  }
-
-  private void setInternalCache(InternalCache internalCache) {
-    OkHttpClient.Builder builder = urlFactory.client().newBuilder();
-    Internal.instance.setCache(builder, internalCache);
-    urlFactory.setClient(builder.build());
-  }
-
-  private String getPlatform() {
-    return System.getProperty("okhttp.platform", "platform");
-  }
-}
diff --git a/okhttp-apache/README.md b/okhttp-apache/README.md
deleted file mode 100644
index ac71ec215a..0000000000
--- a/okhttp-apache/README.md
+++ /dev/null
@@ -1,7 +0,0 @@
-OkHttp Apache HttpClient Implementation
-=======================================
-
-This module is an implementation of the Apache `HttpClient` interface that is backed by OkHttp.
-
-**Warning**: Many core features of Apache HTTP client are not implemented by this API. This includes
-the keep-alive strategy, cookie store, credentials provider, route planner and others.
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
deleted file mode 100644
index ad3883e427..0000000000
--- a/okhttp-apache/pom.xml
+++ /dev/null
@@ -1,74 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.11.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-apache</artifactId>
-  <name>OkHttp Apache HttpClient</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.apache.httpcomponents</groupId>
-      <artifactId>httpclient</artifactId>
-      <scope>provided</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.10.4</version>
-        <configuration>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-            <link>http://hc.apache.org/httpcomponents-client-4.3.x/httpclient/apidocs/</link>
-            <link>https://hc.apache.org/httpcomponents-core-4.3.x/httpcore/apidocs/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.apache</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java b/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
deleted file mode 100644
index 45d27aafd1..0000000000
--- a/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package okhttp3.apache;
-
-import java.io.IOException;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okio.BufferedSink;
-import org.apache.http.HttpEntity;
-
-/** Adapts an {@link HttpEntity} to OkHttp's {@link RequestBody}. */
-final class HttpEntityBody extends RequestBody {
-  private static final MediaType DEFAULT_MEDIA_TYPE = MediaType.parse("application/octet-stream");
-
-  private final HttpEntity entity;
-  private final MediaType mediaType;
-
-  HttpEntityBody(HttpEntity entity, String contentTypeHeader) {
-    this.entity = entity;
-
-    if (contentTypeHeader != null) {
-      mediaType = MediaType.parse(contentTypeHeader);
-    } else if (entity.getContentType() != null) {
-      mediaType = MediaType.parse(entity.getContentType().getValue());
-    } else {
-      // Apache is forgiving and lets you skip specifying a content type with an entity. OkHttp is
-      // not forgiving so we fall back to a generic type if it's missing.
-      mediaType = DEFAULT_MEDIA_TYPE;
-    }
-  }
-
-  @Override public long contentLength() {
-    return entity.getContentLength();
-  }
-
-  @Override public MediaType contentType() {
-    return mediaType;
-  }
-
-  @Override public void writeTo(BufferedSink sink) throws IOException {
-    entity.writeTo(sink.outputStream());
-  }
-}
diff --git a/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
deleted file mode 100644
index d1241d3d01..0000000000
--- a/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
+++ /dev/null
@@ -1,208 +0,0 @@
-// Copyright 2013 Square, Inc.
-package okhttp3.apache;
-
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import okhttp3.Headers;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Util;
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpEntityEnclosingRequest;
-import org.apache.http.HttpHost;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpResponse;
-import org.apache.http.RequestLine;
-import org.apache.http.client.HttpClient;
-import org.apache.http.client.ResponseHandler;
-import org.apache.http.client.methods.HttpUriRequest;
-import org.apache.http.conn.ClientConnectionManager;
-import org.apache.http.conn.params.ConnRouteParams;
-import org.apache.http.entity.InputStreamEntity;
-import org.apache.http.message.BasicHttpResponse;
-import org.apache.http.params.AbstractHttpParams;
-import org.apache.http.params.HttpParams;
-import org.apache.http.protocol.HttpContext;
-
-import static java.net.Proxy.Type.HTTP;
-import static org.apache.http.HttpVersion.HTTP_1_1;
-
-/**
- * @deprecated OkHttp will be dropping its ability to be used with {@link HttpClient} in an upcoming
- * release. Applications that need this should either downgrade to the Apache implementation or
- * upgrade to OkHttp's Request/Response API.
- */
-public final class OkApacheClient implements HttpClient {
-  private static Request transformRequest(HttpRequest request) {
-    Request.Builder builder = new Request.Builder();
-
-    RequestLine requestLine = request.getRequestLine();
-    String method = requestLine.getMethod();
-    builder.url(requestLine.getUri());
-
-    String contentType = null;
-    for (Header header : request.getAllHeaders()) {
-      String name = header.getName();
-      if ("Content-Type".equalsIgnoreCase(name)) {
-        contentType = header.getValue();
-      } else {
-        builder.header(name, header.getValue());
-      }
-    }
-
-    RequestBody body = null;
-    if (request instanceof HttpEntityEnclosingRequest) {
-      HttpEntity entity = ((HttpEntityEnclosingRequest) request).getEntity();
-      if (entity != null) {
-        // Wrap the entity in a custom Body which takes care of the content, length, and type.
-        body = new HttpEntityBody(entity, contentType);
-
-        Header encoding = entity.getContentEncoding();
-        if (encoding != null) {
-          builder.header(encoding.getName(), encoding.getValue());
-        }
-      } else {
-        body = Util.EMPTY_REQUEST;
-      }
-    }
-    builder.method(method, body);
-
-    return builder.build();
-  }
-
-  private static HttpResponse transformResponse(Response response) {
-    int code = response.code();
-    String message = response.message();
-    BasicHttpResponse httpResponse = new BasicHttpResponse(HTTP_1_1, code, message);
-
-    ResponseBody body = response.body();
-    InputStreamEntity entity = new InputStreamEntity(body.byteStream(), body.contentLength());
-    httpResponse.setEntity(entity);
-
-    Headers headers = response.headers();
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      String name = headers.name(i);
-      String value = headers.value(i);
-      httpResponse.addHeader(name, value);
-      if ("Content-Type".equalsIgnoreCase(name)) {
-        entity.setContentType(value);
-      } else if ("Content-Encoding".equalsIgnoreCase(name)) {
-        entity.setContentEncoding(value);
-      }
-    }
-
-    return httpResponse;
-  }
-
-  private final HttpParams params = new AbstractHttpParams() {
-    @Override public Object getParameter(String name) {
-      if (name.equals(ConnRouteParams.DEFAULT_PROXY)) {
-        Proxy proxy = client.proxy();
-        if (proxy == null) {
-          return null;
-        }
-        InetSocketAddress address = (InetSocketAddress) proxy.address();
-        return new HttpHost(address.getHostName(), address.getPort());
-      }
-      throw new IllegalArgumentException(name);
-    }
-
-    @Override public HttpParams setParameter(String name, Object value) {
-      if (name.equals(ConnRouteParams.DEFAULT_PROXY)) {
-        HttpHost host = (HttpHost) value;
-        Proxy proxy = null;
-        if (host != null) {
-          proxy = new Proxy(HTTP, new InetSocketAddress(host.getHostName(), host.getPort()));
-        }
-        client = client.newBuilder()
-            .proxy(proxy)
-            .build();
-        return this;
-      }
-      throw new IllegalArgumentException(name);
-    }
-
-    @Override public HttpParams copy() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public boolean removeParameter(String name) {
-      throw new UnsupportedOperationException();
-    }
-  };
-
-  private OkHttpClient client;
-
-  public OkApacheClient() {
-    this(new OkHttpClient());
-  }
-
-  public OkApacheClient(OkHttpClient client) {
-    this.client = client;
-  }
-
-  @Override public HttpParams getParams() {
-    return params;
-  }
-
-  @Override public ClientConnectionManager getConnectionManager() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override public HttpResponse execute(HttpUriRequest request) throws IOException {
-    return execute(null, request, (HttpContext) null);
-  }
-
-  @Override public HttpResponse execute(HttpUriRequest request, HttpContext context)
-      throws IOException {
-    return execute(null, request, context);
-  }
-
-  @Override public HttpResponse execute(HttpHost host, HttpRequest request) throws IOException {
-    return execute(host, request, (HttpContext) null);
-  }
-
-  @Override public HttpResponse execute(HttpHost host, HttpRequest request, HttpContext context)
-      throws IOException {
-    Request okRequest = transformRequest(request);
-    Response okResponse = client.newCall(okRequest).execute();
-    return transformResponse(okResponse);
-  }
-
-  @Override public <T> T execute(HttpUriRequest request, ResponseHandler<? extends T> handler)
-      throws IOException {
-    return execute(null, request, handler, null);
-  }
-
-  @Override public <T> T execute(HttpUriRequest request, ResponseHandler<? extends T> handler,
-      HttpContext context) throws IOException {
-    return execute(null, request, handler, context);
-  }
-
-  @Override public <T> T execute(HttpHost host, HttpRequest request,
-      ResponseHandler<? extends T> handler) throws IOException {
-    return execute(host, request, handler, null);
-  }
-
-  @Override public <T> T execute(HttpHost host, HttpRequest request,
-      ResponseHandler<? extends T> handler, HttpContext context) throws IOException {
-    HttpResponse response = execute(host, request, context);
-    try {
-      return handler.handleResponse(response);
-    } finally {
-      consumeContentQuietly(response);
-    }
-  }
-
-  private static void consumeContentQuietly(HttpResponse response) {
-    try {
-      response.getEntity().consumeContent();
-    } catch (Throwable ignored) {
-    }
-  }
-}
diff --git a/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java b/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
deleted file mode 100644
index 77493a2540..0000000000
--- a/okhttp-apache/src/test/java/okhttp3/apache/OkApacheClientTest.java
+++ /dev/null
@@ -1,281 +0,0 @@
-package okhttp3.apache;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.URISyntaxException;
-import java.util.zip.GZIPInputStream;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okio.Buffer;
-import okio.GzipSink;
-import okio.Okio;
-import org.apache.http.Header;
-import org.apache.http.HttpEntity;
-import org.apache.http.HttpResponse;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.client.methods.HttpPost;
-import org.apache.http.client.methods.HttpPut;
-import org.apache.http.entity.ByteArrayEntity;
-import org.apache.http.entity.InputStreamEntity;
-import org.apache.http.entity.StringEntity;
-import org.apache.http.util.EntityUtils;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static okhttp3.internal.Util.UTF_8;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-
-public class OkApacheClientTest {
-  private MockWebServer server;
-  private OkApacheClient client;
-
-  @Before public void setUp() throws IOException {
-    client = new OkApacheClient();
-    server = new MockWebServer();
-    server.start();
-  }
-
-  @After public void tearDown() throws IOException {
-    server.shutdown();
-  }
-
-  @Test public void success() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hello, World!"));
-
-    HttpGet request = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response = client.execute(request);
-    String actual = EntityUtils.toString(response.getEntity());
-    assertEquals("Hello, World!", actual);
-  }
-
-  @Test public void redirect() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(302).addHeader("Location", "/foo"));
-    server.enqueue(new MockResponse().setBody("Hello, Redirect!"));
-
-    HttpGet request = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response = client.execute(request);
-    String actual = EntityUtils.toString(response.getEntity(), UTF_8);
-    assertEquals("Hello, Redirect!", actual);
-  }
-
-  @Test public void sessionExpired() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(422));
-
-    HttpGet request = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response = client.execute(request);
-    assertEquals(422, response.getStatusLine().getStatusCode());
-  }
-
-  @Test public void headers() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Foo", "Bar"));
-    server.enqueue(new MockResponse().addHeader("Foo", "Bar").addHeader("Foo", "Baz"));
-
-    HttpGet request1 = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response1 = client.execute(request1);
-    Header[] headers1 = response1.getHeaders("Foo");
-    assertEquals(1, headers1.length);
-    assertEquals("Bar", headers1[0].getValue());
-
-    HttpGet request2 = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response2 = client.execute(request2);
-    Header[] headers2 = response2.getHeaders("Foo");
-    assertEquals(2, headers2.length);
-    assertEquals("Bar", headers2[0].getValue());
-    assertEquals("Baz", headers2[1].getValue());
-  }
-
-  @Test public void postByteEntity() throws Exception {
-    server.enqueue(new MockResponse());
-
-    final HttpPost post = new HttpPost(server.url("/").url().toURI());
-    byte[] body = "Hello, world!".getBytes(UTF_8);
-    post.setEntity(new ByteArrayEntity(body));
-    client.execute(post);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("Hello, world!", request.getBody().readUtf8());
-    assertEquals(request.getHeader("Content-Length"), "13");
-  }
-
-  @Test public void postInputStreamEntity() throws Exception {
-    server.enqueue(new MockResponse());
-
-    final HttpPost post = new HttpPost(server.url("/").url().toURI());
-    byte[] body = "Hello, world!".getBytes(UTF_8);
-    post.setEntity(new InputStreamEntity(new ByteArrayInputStream(body), body.length));
-    client.execute(post);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("Hello, world!", request.getBody().readUtf8());
-    assertEquals(request.getHeader("Content-Length"), "13");
-  }
-
-  @Test public void postEmptyEntity() throws Exception {
-    server.enqueue(new MockResponse());
-    final HttpPost post = new HttpPost(server.url("/").url().toURI());
-    client.execute(post);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(0, request.getBodySize());
-    assertNotNull(request.getBody());
-  }
-
-  @Test public void putEmptyEntity() throws Exception {
-    server.enqueue(new MockResponse());
-    final HttpPut put = new HttpPut(server.url("/").url().toURI());
-    client.execute(put);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(0, request.getBodySize());
-    assertNotNull(request.getBody());
-  }
-
-  @Test public void postOverrideContentType() throws Exception {
-    server.enqueue(new MockResponse());
-
-    HttpPost httpPost = new HttpPost();
-    httpPost.setURI(server.url("/").url().toURI());
-    httpPost.addHeader("Content-Type", "application/xml");
-    httpPost.setEntity(new StringEntity("<yo/>"));
-    client.execute(httpPost);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(request.getHeader("Content-Type"), "application/xml");
-  }
-
-  @Test public void contentType() throws Exception {
-    server.enqueue(new MockResponse().setBody("<html><body><h1>Hello, World!</h1></body></html>")
-        .setHeader("Content-Type", "text/html"));
-    server.enqueue(new MockResponse().setBody("{\"Message\": { \"text\": \"Hello, World!\" } }")
-        .setHeader("Content-Type", "application/json"));
-    server.enqueue(new MockResponse().setBody("Hello, World!"));
-
-    HttpGet request1 = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response1 = client.execute(request1);
-    Header[] headers1 = response1.getHeaders("Content-Type");
-    assertEquals(1, headers1.length);
-    assertEquals("text/html", headers1[0].getValue());
-    assertNotNull(response1.getEntity().getContentType());
-    assertEquals("text/html", response1.getEntity().getContentType().getValue());
-
-    HttpGet request2 = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response2 = client.execute(request2);
-    Header[] headers2 = response2.getHeaders("Content-Type");
-    assertEquals(1, headers2.length);
-    assertEquals("application/json", headers2[0].getValue());
-    assertNotNull(response2.getEntity().getContentType());
-    assertEquals("application/json", response2.getEntity().getContentType().getValue());
-
-    HttpGet request3 = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response3 = client.execute(request3);
-    Header[] headers3 = response3.getHeaders("Content-Type");
-    assertEquals(0, headers3.length);
-    assertNull(response3.getEntity().getContentType());
-  }
-
-  @Test public void contentTypeIsCaseInsensitive() throws URISyntaxException, IOException {
-    server.enqueue(new MockResponse().setBody("{\"Message\": { \"text\": \"Hello, World!\" } }")
-        .setHeader("cONTENT-tYPE", "application/json"));
-
-    HttpGet request = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response = client.execute(request);
-    assertEquals("application/json", response.getEntity().getContentType().getValue());
-  }
-
-  @Test public void contentEncoding() throws Exception {
-    String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
-    server.enqueue(new MockResponse().setBody(gzip(text))
-        .setHeader("Content-Encoding", "gzip"));
-
-    HttpGet request = new HttpGet(server.url("/").url().toURI());
-    request.setHeader("Accept-encoding", "gzip"); // Not transparent gzip.
-    HttpResponse response = client.execute(request);
-    HttpEntity entity = response.getEntity();
-
-    Header[] encodingHeaders = response.getHeaders("Content-Encoding");
-    assertEquals(1, encodingHeaders.length);
-    assertEquals("gzip", encodingHeaders[0].getValue());
-    assertNotNull(entity.getContentEncoding());
-    assertEquals("gzip", entity.getContentEncoding().getValue());
-
-    assertEquals(text, gunzip(entity));
-  }
-
-  @Test public void jsonGzipResponse() throws Exception {
-    String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
-    server.enqueue(new MockResponse().setBody(gzip(text))
-        .setHeader("Content-Encoding", "gzip")
-        .setHeader("Content-Type", "application/json"));
-
-    HttpGet request1 = new HttpGet(server.url("/").url().toURI());
-    request1.setHeader("Accept-encoding", "gzip"); // Not transparent gzip.
-
-    HttpResponse response = client.execute(request1);
-    HttpEntity entity = response.getEntity();
-
-    Header[] encodingHeaders = response.getHeaders("Content-Encoding");
-    assertEquals(1, encodingHeaders.length);
-    assertEquals("gzip", encodingHeaders[0].getValue());
-    assertNotNull(entity.getContentEncoding());
-    assertEquals("gzip", entity.getContentEncoding().getValue());
-
-    Header[] typeHeaders = response.getHeaders("Content-Type");
-    assertEquals(1, typeHeaders.length);
-    assertEquals("application/json", typeHeaders[0].getValue());
-    assertNotNull(entity.getContentType());
-    assertEquals("application/json", entity.getContentType().getValue());
-
-    assertEquals(text, gunzip(entity));
-  }
-
-  @Test public void jsonTransparentGzipResponse() throws Exception {
-    String text = "{\"Message\": { \"text\": \"Hello, World!\" } }";
-    server.enqueue(new MockResponse().setBody(gzip(text))
-        .setHeader("Content-Encoding", "gzip")
-        .setHeader("Content-Type", "application/json"));
-
-    HttpGet request = new HttpGet(server.url("/").url().toURI());
-    HttpResponse response = client.execute(request);
-    HttpEntity entity = response.getEntity();
-
-    // Expecting transparent gzip response by not adding header "Accept-encoding: gzip"
-    Header[] encodingHeaders = response.getHeaders("Content-Encoding");
-    assertEquals(0, encodingHeaders.length);
-    assertNull(entity.getContentEncoding());
-
-    // Content length should be absent.
-    Header[] lengthHeaders = response.getHeaders("Content-Length");
-    assertEquals(0, lengthHeaders.length);
-    assertEquals(-1, entity.getContentLength());
-
-    Header[] typeHeaders = response.getHeaders("Content-Type");
-    assertEquals(1, typeHeaders.length);
-    assertEquals("application/json", typeHeaders[0].getValue());
-    assertNotNull(entity.getContentType());
-    assertEquals("application/json", entity.getContentType().getValue());
-
-    assertEquals(text, EntityUtils.toString(entity, UTF_8));
-  }
-
-  private static Buffer gzip(String body) throws IOException {
-    Buffer buffer = new Buffer();
-    Okio.buffer(new GzipSink(buffer)).writeUtf8(body).close();
-    return buffer;
-  }
-
-  private static String gunzip(HttpEntity body) throws IOException {
-    InputStream in = new GZIPInputStream(body.getContent());
-    Buffer buffer = new Buffer();
-    byte[] temp = new byte[1024];
-    int read;
-    while ((read = in.read(temp)) != -1) {
-      buffer.write(temp, 0, read);
-    }
-    return buffer.readUtf8();
-  }
-}
diff --git a/okhttp-dnsoverhttps/README.md b/okhttp-dnsoverhttps/README.md
new file mode 100644
index 0000000000..30132b47c8
--- /dev/null
+++ b/okhttp-dnsoverhttps/README.md
@@ -0,0 +1,5 @@
+OkHttp DNS over HTTPS Implementation
+====================================
+
+This module is an experimental implementation of DNS over HTTPS using OkHttp.
+API is not considered stable and may change at any time.
diff --git a/okhttp-dnsoverhttps/build.gradle b/okhttp-dnsoverhttps/build.gradle
new file mode 100644
index 0000000000..1a9f104092
--- /dev/null
+++ b/okhttp-dnsoverhttps/build.gradle
@@ -0,0 +1,18 @@
+apply plugin: 'com.vanniktech.maven.publish'
+
+jar {
+  manifest {
+    attributes('Automatic-Module-Name': 'okhttp3.dnsoverhttps')
+  }
+}
+
+dependencies {
+  api project(':okhttp')
+  compileOnly deps.jsr305
+
+  testImplementation project(':okhttp-testing-support')
+  testImplementation project(':mockwebserver')
+  testImplementation deps.conscrypt
+  testImplementation deps.junit
+  testImplementation deps.assertj
+}
diff --git a/okhttp-dnsoverhttps/gradle.properties b/okhttp-dnsoverhttps/gradle.properties
new file mode 100644
index 0000000000..bd908aaa26
--- /dev/null
+++ b/okhttp-dnsoverhttps/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=okhttp-dnsoverhttps
+POM_NAME=okhttp-dnsoverhttps
+POM_PACKAGING=jar
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.kt
new file mode 100644
index 0000000000..5523487838
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.kt
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps
+
+import okhttp3.Dns
+import java.net.InetAddress
+import java.net.UnknownHostException
+
+/**
+ * Internal Bootstrap DNS implementation for handling initial connection to DNS over HTTPS server.
+ *
+ * Returns hardcoded results for the known host.
+ */
+internal class BootstrapDns(
+  private val dnsHostname: String,
+  private val dnsServers: List<InetAddress>
+) : Dns {
+  @Throws(UnknownHostException::class)
+  override fun lookup(hostname: String): List<InetAddress> {
+    if (this.dnsHostname != hostname) {
+      throw UnknownHostException(
+          "BootstrapDns called for $hostname instead of $dnsHostname"
+      )
+    }
+
+    return dnsServers
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt
new file mode 100644
index 0000000000..9b97d4b4ac
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt
@@ -0,0 +1,325 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps
+
+import okhttp3.CacheControl
+import okhttp3.Call
+import okhttp3.Callback
+import okhttp3.Dns
+import okhttp3.HttpUrl
+import okhttp3.MediaType
+import okhttp3.OkHttpClient
+import okhttp3.Protocol
+import okhttp3.Request
+import okhttp3.RequestBody
+import okhttp3.Response
+import okhttp3.internal.platform.Platform
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase
+import java.io.IOException
+import java.net.InetAddress
+import java.net.UnknownHostException
+import java.util.ArrayList
+import java.util.concurrent.CountDownLatch
+
+/**
+ * [DNS over HTTPS implementation][[doh_spec]].
+ *
+ * <blockquote>A DNS API client encodes a single DNS query into an HTTP request
+ * using either the HTTP GET or POST method and the other requirements
+ * of this section.  The DNS API server defines the URI used by the
+ * request through the use of a URI Template.</blockquote>
+ *
+ * <h3>Warning: This is a non-final API.</h3>
+ *
+ * As of OkHttp 3.14, this feature is an unstable preview: the API is subject to change,
+ * and the implementation is incomplete. We expect that OkHttp 4.0 or 4.1 will finalize this API.
+ * Until then, expect API and behavior changes when you update your OkHttp dependency.**
+ *
+ * [doh_spec]: https://tools.ietf.org/html/draft-ietf-doh-dns-over-https-13
+ */
+class DnsOverHttps internal constructor(builder: Builder) : Dns {
+  private val client: OkHttpClient =
+      builder.client?.newBuilder()?.dns(buildBootstrapClient(builder))?.build()
+          ?: throw NullPointerException("client not set")
+  private val url: HttpUrl = builder.url ?: throw NullPointerException("url not set")
+  private val includeIPv6: Boolean = builder.includeIPv6
+  private val post: Boolean = builder.post
+  private val resolvePrivateAddresses: Boolean = builder.resolvePrivateAddresses
+  private val resolvePublicAddresses: Boolean = builder.resolvePublicAddresses
+
+  fun url(): HttpUrl = url
+
+  fun post(): Boolean = post
+
+  fun includeIPv6(): Boolean = includeIPv6
+
+  fun client(): OkHttpClient = client
+
+  fun resolvePrivateAddresses(): Boolean = resolvePrivateAddresses
+
+  fun resolvePublicAddresses(): Boolean = resolvePublicAddresses
+
+  @Throws(UnknownHostException::class)
+  override fun lookup(hostname: String): List<InetAddress> {
+    if (!resolvePrivateAddresses || !resolvePublicAddresses) {
+      val privateHost = isPrivateHost(hostname)
+
+      if (privateHost && !resolvePrivateAddresses) {
+        throw UnknownHostException("private hosts not resolved")
+      }
+
+      if (!privateHost && !resolvePublicAddresses) {
+        throw UnknownHostException("public hosts not resolved")
+      }
+    }
+
+    return lookupHttps(hostname)
+  }
+
+  @Throws(UnknownHostException::class)
+  private fun lookupHttps(hostname: String): List<InetAddress> {
+    val networkRequests = ArrayList<Call>(2)
+    val failures = ArrayList<Exception>(2)
+    val results = ArrayList<InetAddress>(5)
+
+    buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_A)
+
+    if (includeIPv6) {
+      buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_AAAA)
+    }
+
+    executeRequests(hostname, networkRequests, results, failures)
+
+    return if (!results.isEmpty()) {
+      results
+    } else {
+      throwBestFailure(hostname, failures)
+    }
+  }
+
+  private fun buildRequest(
+    hostname: String, networkRequests: MutableList<Call>, results: MutableList<InetAddress>,
+    failures: MutableList<Exception>, type: Int
+  ) {
+    val request = buildRequest(hostname, type)
+    val response = getCacheOnlyResponse(request)
+
+    response?.let { processResponse(it, hostname, results, failures) } ?: networkRequests.add(
+        client.newCall(request))
+  }
+
+  private fun executeRequests(
+    hostname: String, networkRequests: List<Call>,
+    responses: MutableList<InetAddress>, failures: MutableList<Exception>
+  ) {
+    val latch = CountDownLatch(networkRequests.size)
+
+    for (call in networkRequests) {
+      call.enqueue(object : Callback {
+        override fun onFailure(call: Call, e: IOException) {
+          synchronized(failures) {
+            failures.add(e)
+          }
+          latch.countDown()
+        }
+
+        override fun onResponse(call: Call, response: Response) {
+          processResponse(response, hostname, responses, failures)
+          latch.countDown()
+        }
+      })
+    }
+
+    try {
+      latch.await()
+    } catch (e: InterruptedException) {
+      failures.add(e)
+    }
+  }
+
+  private fun processResponse(
+    response: Response, hostname: String, results: MutableList<InetAddress>,
+    failures: MutableList<Exception>
+  ) {
+    try {
+      val addresses = readResponse(hostname, response)
+      synchronized(results) {
+        results.addAll(addresses)
+      }
+    } catch (e: Exception) {
+      synchronized(failures) {
+        failures.add(e)
+      }
+    }
+  }
+
+  @Throws(UnknownHostException::class)
+  private fun throwBestFailure(hostname: String, failures: List<Exception>): List<InetAddress> {
+    if (failures.isEmpty()) {
+      throw UnknownHostException(hostname)
+    }
+
+    val failure = failures[0]
+
+    if (failure is UnknownHostException) {
+      throw failure
+    }
+
+    val unknownHostException = UnknownHostException(hostname)
+    unknownHostException.initCause(failure)
+
+    for (i in 1 until failures.size) {
+      unknownHostException.addSuppressed(failures[i])
+    }
+
+    throw unknownHostException
+  }
+
+  private fun getCacheOnlyResponse(request: Request): Response? {
+    if (!post && client.cache() != null) {
+      try {
+        val cacheRequest = request.newBuilder().cacheControl(CacheControl.FORCE_CACHE).build()
+
+        val cacheResponse = client.newCall(cacheRequest).execute()
+
+        if (cacheResponse.code() != 504) {
+          return cacheResponse
+        }
+      } catch (ioe: IOException) {
+        // Failures are ignored as we can fallback to the network
+        // and hopefully repopulate the cache.
+      }
+    }
+
+    return null
+  }
+
+  @Throws(Exception::class)
+  private fun readResponse(hostname: String, response: Response): List<InetAddress> {
+    if (response.cacheResponse() == null && response.protocol() !== Protocol.HTTP_2) {
+      Platform.get().log(Platform.WARN, "Incorrect protocol: ${response.protocol()}", null)
+    }
+
+    response.use {
+      if (!response.isSuccessful) {
+        throw IOException("response: " + response.code() + " " + response.message())
+      }
+
+      val body = response.body()
+
+      if (body!!.contentLength() > MAX_RESPONSE_SIZE) {
+        throw IOException(
+            "response size exceeds limit ($MAX_RESPONSE_SIZE bytes): ${body.contentLength()} bytes"
+        )
+      }
+
+      val responseBytes = body.source().readByteString()
+
+      return DnsRecordCodec.decodeAnswers(hostname, responseBytes)
+    }
+  }
+
+  private fun buildRequest(hostname: String, type: Int): Request =
+      Request.Builder().header("Accept", DNS_MESSAGE.toString()).apply {
+        val query = DnsRecordCodec.encodeQuery(hostname, type)
+
+        if (post) {
+          url(url).post(RequestBody.create(DNS_MESSAGE, query))
+        } else {
+          val encoded = query.base64Url().replace("=", "")
+          val requestUrl = url.newBuilder().addQueryParameter("dns", encoded).build()
+
+          url(requestUrl)
+        }
+
+      }.build()
+
+  class Builder {
+    internal var client: OkHttpClient? = null
+    internal var url: HttpUrl? = null
+    internal var includeIPv6 = true
+    internal var post = false
+    internal var systemDns = Dns.SYSTEM
+    internal var bootstrapDnsHosts: List<InetAddress>? = null
+    internal var resolvePrivateAddresses = false
+    internal var resolvePublicAddresses = true
+
+    fun build(): DnsOverHttps = DnsOverHttps(this)
+
+    fun client(client: OkHttpClient): Builder {
+      this.client = client
+      return this
+    }
+
+    fun url(url: HttpUrl): Builder {
+      this.url = url
+      return this
+    }
+
+    fun includeIPv6(includeIPv6: Boolean): Builder {
+      this.includeIPv6 = includeIPv6
+      return this
+    }
+
+    fun post(post: Boolean): Builder {
+      this.post = post
+      return this
+    }
+
+    fun resolvePrivateAddresses(resolvePrivateAddresses: Boolean): Builder {
+      this.resolvePrivateAddresses = resolvePrivateAddresses
+      return this
+    }
+
+    fun resolvePublicAddresses(resolvePublicAddresses: Boolean): Builder {
+      this.resolvePublicAddresses = resolvePublicAddresses
+      return this
+    }
+
+    fun bootstrapDnsHosts(bootstrapDnsHosts: List<InetAddress>?): Builder {
+      this.bootstrapDnsHosts = bootstrapDnsHosts
+      return this
+    }
+
+    fun bootstrapDnsHosts(vararg bootstrapDnsHosts: InetAddress): Builder {
+      return bootstrapDnsHosts(bootstrapDnsHosts.toList())
+    }
+
+    fun systemDns(systemDns: Dns): Builder {
+      this.systemDns = systemDns
+      return this
+    }
+  }
+
+  companion object {
+    val DNS_MESSAGE: MediaType = MediaType.get("application/dns-message")
+    const val MAX_RESPONSE_SIZE = 64 * 1024
+
+    private fun buildBootstrapClient(builder: Builder): Dns {
+      val hosts = builder.bootstrapDnsHosts
+
+      return if (hosts != null) {
+        BootstrapDns(builder.url!!.host(), hosts)
+      } else {
+        builder.systemDns
+      }
+    }
+
+    internal fun isPrivateHost(host: String): Boolean {
+      return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host) == null
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt
new file mode 100644
index 0000000000..0551d39f6f
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package okhttp3.dnsoverhttps
+
+import okio.Buffer
+import okio.ByteString
+import okio.utf8Size
+import java.io.EOFException
+import java.net.InetAddress
+import java.net.UnknownHostException
+import java.nio.charset.StandardCharsets
+import java.util.ArrayList
+
+/**
+ * Trivial Dns Encoder/Decoder, basically ripped from Netty full implementation.
+ */
+object DnsRecordCodec {
+  private const val SERVFAIL = 2
+  private const val NXDOMAIN = 3
+  const val TYPE_A = 0x0001
+  const val TYPE_AAAA = 0x001c
+  private const val TYPE_PTR = 0x000c
+  private val ASCII = StandardCharsets.US_ASCII
+
+  @JvmStatic
+  fun encodeQuery(host: String, type: Int): ByteString = Buffer().apply {
+    writeShort(0) // query id
+    writeShort(256) // flags with recursion
+    writeShort(1) // question count
+    writeShort(0) // answerCount
+    writeShort(0) // authorityResourceCount
+    writeShort(0) // additional
+
+    val nameBuf = Buffer()
+    val labels = host.split('.').dropLastWhile { it.isEmpty() }.toTypedArray()
+    for (label in labels) {
+      val utf8ByteCount = label.utf8Size()
+      if (utf8ByteCount != label.length.toLong()) {
+        throw IllegalArgumentException("non-ascii hostname: $host")
+      }
+      nameBuf.writeByte(utf8ByteCount.toInt())
+      nameBuf.writeUtf8(label)
+    }
+    nameBuf.writeByte(0) // end
+
+    nameBuf.copyTo(this, 0, nameBuf.size)
+    writeShort(type)
+    writeShort(1) // CLASS_IN
+  }.readByteString()
+
+  @Throws(Exception::class)
+  @JvmStatic
+  fun decodeAnswers(hostname: String, byteString: ByteString): List<InetAddress> {
+    val result = ArrayList<InetAddress>()
+
+    val buf = Buffer()
+    buf.write(byteString)
+    buf.readShort() // query id
+
+    val flags = buf.readShort().toInt() and 0xffff
+    if (flags shr 15 == 0) {
+      throw IllegalArgumentException("not a response")
+    }
+
+    val responseCode = flags and 0xf
+
+    if (responseCode == NXDOMAIN) {
+      throw UnknownHostException("$hostname: NXDOMAIN")
+    } else if (responseCode == SERVFAIL) {
+      throw UnknownHostException("$hostname: SERVFAIL")
+    }
+
+    val questionCount = buf.readShort().toInt() and 0xffff
+    val answerCount = buf.readShort().toInt() and 0xffff
+    buf.readShort() // authority record count
+    buf.readShort() // additional record count
+
+    for (i in 0 until questionCount) {
+      skipName(buf) // name
+      buf.readShort() // type
+      buf.readShort() // class
+    }
+
+    for (i in 0 until answerCount) {
+      skipName(buf) // name
+
+      val type = buf.readShort().toInt() and 0xffff
+      buf.readShort() // class
+      val ttl = buf.readInt().toLong() and 0xffffffffL // ttl
+      val length = buf.readShort().toInt() and 0xffff
+
+      if (type == TYPE_A || type == TYPE_AAAA) {
+        val bytes = ByteArray(length)
+        buf.read(bytes)
+        result.add(InetAddress.getByAddress(bytes))
+      } else {
+        buf.skip(length.toLong())
+      }
+    }
+
+    return result
+  }
+
+  @Throws(EOFException::class)
+  private fun skipName(source: Buffer) {
+    // 0 - 63 bytes
+    var length = source.readByte().toInt()
+
+    if (length < 0) {
+      // compressed name pointer, first two bits are 1
+      // drop second byte of compression offset
+      source.skip(1)
+    } else {
+      while (length > 0) {
+        // skip each part of the domain name
+        source.skip(length.toLong())
+        length = source.readByte().toInt()
+      }
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.kt
new file mode 100644
index 0000000000..f0f89d115b
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.kt
@@ -0,0 +1,2 @@
+/** A DNS over HTTPS implementation for OkHttp.  */
+package okhttp3.dnsoverhttps
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
new file mode 100644
index 0000000000..8b750f018c
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.io.EOFException;
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.List;
+import okhttp3.Cache;
+import okhttp3.Dns;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static java.util.Arrays.asList;
+import static java.util.Collections.singletonList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public class DnsOverHttpsTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final OkHttpClient bootstrapClient =
+      new OkHttpClient.Builder().protocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1)).build();
+  private Dns dns = buildLocalhost(bootstrapClient, false);
+
+  @Before public void setUp() {
+    server.setProtocols(bootstrapClient.protocols());
+  }
+
+  @Test public void getOne() throws Exception {
+    server.enqueue(dnsResponse(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
+            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
+            + "0010000003b00049df00112"));
+
+    List<InetAddress> result = dns.lookup("google.com");
+
+    assertThat(result).isEqualTo(singletonList(address("157.240.1.18")));
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertThat(recordedRequest.getMethod()).isEqualTo("GET");
+    assertThat(recordedRequest.getPath()).isEqualTo(
+        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ");
+  }
+
+  @Test public void getIpv6() throws Exception {
+    server.enqueue(dnsResponse(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
+            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
+            + "0010000003b00049df00112"));
+    server.enqueue(dnsResponse(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d00001c0001c00c00050001"
+            + "00000a1b000603617069c012c0300005000100000b1f000c04737461720463313072c012c042001c0"
+            + "0010000003b00102a032880f0290011faceb00c00000002"));
+
+    dns = buildLocalhost(bootstrapClient, true);
+
+    List<InetAddress> result = dns.lookup("google.com");
+
+    assertThat(result.size()).isEqualTo(2);
+    assertThat(result).contains(address("157.240.1.18"));
+    assertThat(result).contains(address("2a03:2880:f029:11:face:b00c:0:2"));
+
+    RecordedRequest request1 = server.takeRequest();
+    assertThat(request1.getMethod()).isEqualTo("GET");
+
+    RecordedRequest request2 = server.takeRequest();
+    assertThat(request2.getMethod()).isEqualTo("GET");
+
+    assertThat(asList(request1.getPath(), request2.getPath())).containsExactlyInAnyOrder(
+        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
+        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AABwAAQ");
+  }
+
+  @Test public void failure() throws Exception {
+    server.enqueue(dnsResponse(
+        "0000818300010000000100000e7364666c6b686673646c6b6a64660265650000010001c01b00060001"
+            + "000007070038026e7303746c64c01b0a686f73746d61737465720d6565737469696e7465726e657"
+            + "4c01b5adb12c100000e10000003840012750000000e10"));
+
+    try {
+      dns.lookup("google.com");
+      fail();
+    } catch (UnknownHostException uhe) {
+      uhe.printStackTrace();
+      assertThat(uhe.getMessage()).isEqualTo("google.com: NXDOMAIN");
+    }
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertThat(recordedRequest.getMethod()).isEqualTo("GET");
+    assertThat(recordedRequest.getPath()).isEqualTo(
+        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ");
+  }
+
+  @Test public void failOnExcessiveResponse() {
+    char[] array = new char[128 * 1024 + 2];
+    Arrays.fill(array, '0');
+    server.enqueue(dnsResponse(new String(array)));
+
+    try {
+      dns.lookup("google.com");
+      fail();
+    } catch (IOException ioe) {
+      assertThat(ioe.getMessage()).isEqualTo("google.com");
+      Throwable cause = ioe.getCause();
+      assertThat(cause).isInstanceOf(IOException.class);
+      assertThat(cause).hasMessage("response size exceeds limit (65536 bytes): 65537 bytes");
+    }
+  }
+
+  @Test public void failOnBadResponse() {
+    server.enqueue(dnsResponse("00"));
+
+    try {
+      dns.lookup("google.com");
+      fail();
+    } catch (IOException ioe) {
+      assertThat(ioe).hasMessage("google.com");
+      assertThat(ioe.getCause()).isInstanceOf(EOFException.class);
+    }
+  }
+
+  // TODO GET preferred order - with tests to confirm this
+  // 1. successful fresh cached GET response
+  // 2. unsuccessful (404, 500) fresh cached GET response
+  // 3. successful network response
+  // 4. successful stale cached GET response
+  // 5. unsuccessful response
+
+  // TODO how closely to follow POST rules on caching?
+
+  @Test public void usesCache() throws Exception {
+    Cache cache = new Cache(new File("./target/DnsOverHttpsTest.cache"), 100 * 1024);
+    OkHttpClient cachedClient = bootstrapClient.newBuilder().cache(cache).build();
+    DnsOverHttps cachedDns = buildLocalhost(cachedClient, false);
+
+    server.enqueue(dnsResponse(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
+            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
+            + "0010000003b00049df00112").setHeader("cache-control", "private, max-age=298"));
+
+    List<InetAddress> result = cachedDns.lookup("google.com");
+
+    assertThat(result).containsExactly(address("157.240.1.18"));
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertThat(recordedRequest.getMethod()).isEqualTo("GET");
+    assertThat(recordedRequest.getPath()).isEqualTo(
+        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ");
+
+    result = cachedDns.lookup("google.com");
+    assertThat(result).isEqualTo(singletonList(address("157.240.1.18")));
+  }
+
+  private MockResponse dnsResponse(String s) {
+    return new MockResponse().setBody(new Buffer().write(ByteString.decodeHex(s)))
+        .addHeader("content-type", "application/dns-message")
+        .addHeader("content-length", s.length() / 2);
+  }
+
+  private DnsOverHttps buildLocalhost(OkHttpClient bootstrapClient, boolean includeIPv6) {
+    HttpUrl url = server.url("/lookup?ct");
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .includeIPv6(includeIPv6)
+        .resolvePrivateAddresses(true)
+        .url(url)
+        .build();
+  }
+
+  private static InetAddress address(String host) {
+    try {
+      return InetAddress.getByName(host);
+    } catch (UnknownHostException e) {
+      // impossible for IP addresses
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
new file mode 100644
index 0000000000..8eea96c7bd
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.List;
+import okio.ByteString;
+import org.junit.Test;
+
+import static okhttp3.dnsoverhttps.DnsRecordCodec.TYPE_A;
+import static okhttp3.dnsoverhttps.DnsRecordCodec.TYPE_AAAA;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public class DnsRecordCodecTest {
+  @Test public void testGoogleDotComEncoding() {
+    String encoded = encodeQuery("google.com", TYPE_A);
+
+    assertThat(encoded).isEqualTo("AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ");
+  }
+
+  private String encodeQuery(String host, int type) {
+    return DnsRecordCodec.encodeQuery(host, type).base64Url().replace("=", "");
+  }
+
+  @Test public void testGoogleDotComEncodingWithIPv6() {
+    String encoded = encodeQuery("google.com", TYPE_AAAA);
+
+    assertThat(encoded).isEqualTo("AAABAAABAAAAAAAABmdvb2dsZQNjb20AABwAAQ");
+  }
+
+  @Test public void testGoogleDotComDecodingFromCloudflare() throws Exception {
+    List<InetAddress> encoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
+        "00008180000100010000000006676f6f676c6503636f6d0000010001c00c00010001000000430004d83ad54e"));
+
+    assertThat(encoded).containsExactly(InetAddress.getByName("216.58.213.78"));
+  }
+
+  @Test public void testGoogleDotComDecodingFromGoogle() throws Exception {
+    List<InetAddress> decoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c0005000100000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c042000100010000003b00049df00112"));
+
+    assertThat(decoded).containsExactly(InetAddress.getByName("157.240.1.18"));
+  }
+
+  @Test public void testGoogleDotComDecodingFromGoogleIPv6() throws Exception {
+    List<InetAddress> decoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d00001c0001c00c0005000100000a1b000603617069c012c0300005000100000b1f000c04737461720463313072c012c042001c00010000003b00102a032880f0290011faceb00c00000002"));
+
+    assertThat(decoded).containsExactly(InetAddress.getByName("2a03:2880:f029:11:face:b00c:0:2"));
+  }
+
+  @Test public void testGoogleDotComDecodingNxdomainFailure() throws Exception {
+    try {
+      DnsRecordCodec.decodeAnswers("sdflkhfsdlkjdf.ee", ByteString.decodeHex(
+          "0000818300010000000100000e7364666c6b686673646c6b6a64660265650000010001c01b00060001000007070038026e7303746c64c01b0a686f73746d61737465720d6565737469696e7465726e6574c01b5adb12c100000e10000003840012750000000e10"));
+      fail();
+    } catch (UnknownHostException uhe) {
+      assertThat(uhe.getMessage()).isEqualTo("sdflkhfsdlkjdf.ee: NXDOMAIN");
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java
new file mode 100644
index 0000000000..301eee57ca
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.List;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+
+/**
+ * Temporary registry of known DNS over HTTPS providers.
+ *
+ * https://github.com/curl/curl/wiki/DNS-over-HTTPS
+ */
+public class DohProviders {
+  static DnsOverHttps buildGoogle(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://dns.google.com/experimental"))
+        .bootstrapDnsHosts(getByIp("216.58.204.78"), getByIp("2a00:1450:4009:814:0:0:0:200e"))
+        .build();
+  }
+
+  static DnsOverHttps buildGooglePost(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://dns.google.com/experimental"))
+        .bootstrapDnsHosts(getByIp("216.58.204.78"), getByIp("2a00:1450:4009:814:0:0:0:200e"))
+        .post(true)
+        .build();
+  }
+
+  static DnsOverHttps buildCloudflareIp(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://1.1.1.1/dns-query"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  static DnsOverHttps buildCloudflare(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://cloudflare-dns.com/dns-query"))
+        .bootstrapDnsHosts(getByIp("1.1.1.1"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  static DnsOverHttps buildCloudflarePost(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://cloudflare-dns.com/dns-query"))
+        .bootstrapDnsHosts(getByIp("104.16.111.25"), getByIp("104.16.112.25"),
+            getByIp("2400:cb00:2048:1:0:0:6810:7019"), getByIp("2400:cb00:2048:1:0:0:6810:6f19"))
+        .includeIPv6(false)
+        .post(true)
+        .build();
+  }
+
+  static DnsOverHttps buildCleanBrowsing(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://doh.cleanbrowsing.org/doh/family-filter/"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  static DnsOverHttps buildChantra(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://dns.dnsoverhttps.net/dns-query"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  static DnsOverHttps buildCryptoSx(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://doh.crypto.sx/dns-query"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  public static List<DnsOverHttps> providers(OkHttpClient client, boolean http2Only,
+      boolean workingOnly, boolean getOnly) {
+
+    List<DnsOverHttps> result = new ArrayList<>();
+
+    result.add(buildGoogle(client));
+    if (!getOnly) {
+      result.add(buildGooglePost(client));
+    }
+    result.add(buildCloudflare(client));
+    result.add(buildCloudflareIp(client));
+    if (!getOnly) {
+      result.add(buildCloudflarePost(client));
+    }
+    if (!workingOnly) {
+      //result.add(buildCleanBrowsing(client)); // timeouts
+      result.add(buildCryptoSx(client)); // 521 - server down
+    }
+    result.add(buildChantra(client));
+
+    return result;
+  }
+
+  private static InetAddress getByIp(String host) {
+    try {
+      return InetAddress.getByName(host);
+    } catch (UnknownHostException e) {
+      // unlikely
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
new file mode 100644
index 0000000000..cfd76af0e3
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.Security;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import okhttp3.Cache;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+
+import static java.util.Arrays.asList;
+
+public class TestDohMain {
+  public static void main(String[] args) throws IOException {
+    Security.insertProviderAt(new org.conscrypt.OpenSSLProvider(), 1);
+
+    OkHttpClient bootstrapClient = new OkHttpClient.Builder().build();
+
+    List<String> names = asList("google.com", "graph.facebook.com", "sdflkhfsdlkjdf.ee");
+
+    try {
+      System.out.println("uncached\n********\n");
+      List<DnsOverHttps> dnsProviders =
+          DohProviders.providers(bootstrapClient, false, false, false);
+      runBatch(dnsProviders, names);
+
+      Cache dnsCache =
+          new Cache(new File("./target/TestDohMain.cache." + System.currentTimeMillis()),
+              10 * 1024 * 1024);
+
+      System.out.println("Bad targets\n***********\n");
+
+      HttpUrl url = HttpUrl.get("https://dns.cloudflare.com/.not-so-well-known/run-dmc-query");
+      List<DnsOverHttps> badProviders = Collections.singletonList(
+          new DnsOverHttps.Builder().client(bootstrapClient).url(url).post(true).build());
+      runBatch(badProviders, names);
+
+      System.out.println("cached first run\n****************\n");
+      names = asList("google.com", "graph.facebook.com");
+      bootstrapClient = bootstrapClient.newBuilder().cache(dnsCache).build();
+      dnsProviders = DohProviders.providers(bootstrapClient, true, true, true);
+      runBatch(dnsProviders, names);
+
+      System.out.println("cached second run\n*****************\n");
+      dnsProviders = DohProviders.providers(bootstrapClient, true, true, true);
+      runBatch(dnsProviders, names);
+    } finally {
+      bootstrapClient.connectionPool().evictAll();
+      bootstrapClient.dispatcher().executorService().shutdownNow();
+      Cache cache = bootstrapClient.cache();
+      if (cache != null) {
+        cache.close();
+      }
+    }
+  }
+
+  private static void runBatch(List<DnsOverHttps> dnsProviders, List<String> names) {
+    long time = System.currentTimeMillis();
+
+    for (DnsOverHttps dns : dnsProviders) {
+      System.out.println("Testing " + dns.url());
+
+      for (String host : names) {
+        System.out.print(host + ": ");
+        System.out.flush();
+
+        try {
+          List<InetAddress> results = dns.lookup(host);
+          System.out.println(results);
+        } catch (UnknownHostException uhe) {
+          Throwable e = uhe;
+
+          while (e != null) {
+            System.out.println(e.toString());
+
+            e = e.getCause();
+          }
+        }
+      }
+
+      System.out.println();
+    }
+
+    time = System.currentTimeMillis() - time;
+
+    System.out.println("Time: " + (((double) time) / 1000) + " seconds\n");
+  }
+}
diff --git a/okhttp-hpacktests/build.gradle b/okhttp-hpacktests/build.gradle
new file mode 100644
index 0000000000..cc38a49483
--- /dev/null
+++ b/okhttp-hpacktests/build.gradle
@@ -0,0 +1,9 @@
+dependencies {
+  testImplementation deps.okio
+  testImplementation deps.moshi
+  testImplementation project(':okhttp')
+  testImplementation project(':okhttp-testing-support')
+  testImplementation project(':mockwebserver')
+  testImplementation deps.junit
+  testImplementation deps.assertj
+}
diff --git a/okhttp-hpacktests/pom.xml b/okhttp-hpacktests/pom.xml
deleted file mode 100644
index 12bc4e4b49..0000000000
--- a/okhttp-hpacktests/pom.xml
+++ /dev/null
@@ -1,62 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-hpacktests</artifactId>
-  <name>OkHttp HPACK Tests</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okio</groupId>
-      <artifactId>okio</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <!-- Do not deploy this as an artifact to Maven central. -->
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-deploy-plugin</artifactId>
-        <configuration>
-          <skip>true</skip>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java
index dbcc99f55f..06bcbdf8ca 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeInteropTest.java
@@ -17,6 +17,7 @@
 
 import java.util.Collection;
 import okhttp3.internal.http2.hpackjson.Story;
+import org.junit.Assume;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -37,6 +38,8 @@ public HpackDecodeInteropTest(Story story) {
 
   @Test
   public void testGoodDecoderInterop() throws Exception {
+    Assume.assumeFalse("Test stories missing, checkout git submodule", getStory() == Story.MISSING);
+
     testDecoder();
   }
 }
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java
index a3f69da38c..8cbb7a0e68 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackDecodeTestBase.java
@@ -17,6 +17,7 @@
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
 import okhttp3.internal.http2.hpackjson.Case;
@@ -24,8 +25,8 @@
 import okhttp3.internal.http2.hpackjson.Story;
 import okio.Buffer;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
+import static okhttp3.internal.http2.hpackjson.Story.MISSING;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /**
  * Tests Hpack implementation using https://github.com/http2jp/hpack-test-case/
@@ -37,12 +38,13 @@
    */
   protected static Collection<Story[]> createStories(String[] interopTests)
       throws Exception {
+    if (interopTests.length == 0) {
+      return Collections.singletonList(new Story[] {MISSING});
+    }
+
     List<Story[]> result = new ArrayList<>();
     for (String interopTestName : interopTests) {
       List<Story> stories = HpackJsonUtil.readStories(interopTestName);
-      if (stories.isEmpty()) {
-        fail("No stories for: " + interopTestName);
-      }
       for (Story story : stories) {
         result.add(new Story[] {story});
       }
@@ -67,10 +69,10 @@ protected void testDecoder() throws Exception {
   }
 
   protected void testDecoder(Story story) throws Exception {
-    for (Case caze : story.getCases()) {
-      bytesIn.write(caze.getWire());
+    for (Case testCase : story.getCases()) {
+      bytesIn.write(testCase.getWire());
       hpackReader.readHeaders();
-      assertSetEquals(String.format("seqno=%d", caze.getSeqno()), caze.getHeaders(),
+      assertSetEquals(String.format("seqno=%d", testCase.getSeqno()), testCase.getHeaders(),
           hpackReader.getAndResetHeaderList());
     }
   }
@@ -83,7 +85,8 @@ protected void testDecoder(Story story) throws Exception {
    */
   private static void assertSetEquals(
       String message, List<Header> expected, List<Header> observed) {
-    assertEquals(message, new LinkedHashSet<>(expected), new LinkedHashSet<>(observed));
+    assertThat(new LinkedHashSet<>(observed)).overridingErrorMessage(message).isEqualTo(
+        new LinkedHashSet<>(expected));
   }
 
   protected Story getStory() {
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java
index 55325ce53d..00371f05ad 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/HpackRoundTripTest.java
@@ -19,6 +19,7 @@
 import okhttp3.internal.http2.hpackjson.Case;
 import okhttp3.internal.http2.hpackjson.Story;
 import okio.Buffer;
+import org.junit.Assume;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -49,6 +50,8 @@ public HpackRoundTripTest(Story story) {
 
   @Test
   public void testRoundTrip() throws Exception {
+    Assume.assumeFalse("Test stories missing, checkout git submodule", getStory() == Story.MISSING);
+
     Story story = getStory().clone();
     // Mutate cases in base class.
     for (Case caze : story.getCases()) {
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java
index 39b1489d4b..68c0aa99bc 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/HpackJsonUtil.java
@@ -21,11 +21,15 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URISyntaxException;
+import java.net.URL;
 import java.util.ArrayList;
-import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import okio.Okio;
 
+import static java.util.Arrays.asList;
+import static okhttp3.internal.http2.hpackjson.Story.MISSING;
+
 /**
  * Utilities for reading HPACK tests.
  */
@@ -48,10 +52,14 @@ private static Story readStory(File file) throws IOException {
 
   /** Iterate through the hpack-test-case resources, only picking stories for the current draft. */
   public static String[] storiesForCurrentDraft() throws URISyntaxException {
-    File testCaseDirectory = new File(HpackJsonUtil.class.getResource("/hpack-test-case").toURI());
+    URL resource = HpackJsonUtil.class.getResource("/hpack-test-case");
+    if (resource == null) {
+      return new String[0];
+    }
+    File testCaseDirectory = new File(resource.toURI());
     List<String> storyNames = new ArrayList<>();
     for (File path : testCaseDirectory.listFiles()) {
-      if (path.isDirectory() && Arrays.asList(path.list()).contains("story_00.json")) {
+      if (path.isDirectory() && asList(path.list()).contains("story_00.json")) {
         try {
           Story firstStory = readStory(new File(path, "story_00.json"));
           if (firstStory.getDraft() >= BASE_DRAFT) {
@@ -86,6 +94,12 @@ private static Story readStory(File file) throws IOException {
         storyInputStream.close();
       }
     }
+
+    if (result.isEmpty()) {
+      // missing files
+      return Collections.singletonList(MISSING);
+    }
+
     return result;
   }
 
diff --git a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java
index 288a87b81f..25a63a073b 100644
--- a/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java
+++ b/okhttp-hpacktests/src/test/java/okhttp3/internal/http2/hpackjson/Story.java
@@ -23,6 +23,11 @@
  * reflectively with Moshi to parse stories from files.
  */
 public class Story implements Cloneable {
+  public final static Story MISSING = new Story();
+
+  static {
+    MISSING.setFileName("missing");
+  }
 
   private transient String fileName;
   private List<Case> cases;
diff --git a/okhttp-logging-interceptor/Module.md b/okhttp-logging-interceptor/Module.md
new file mode 100644
index 0000000000..d018b76711
--- /dev/null
+++ b/okhttp-logging-interceptor/Module.md
@@ -0,0 +1,3 @@
+# Module okhttp-logging-interceptor
+
+An OkHttp interceptor which logs HTTP request and response data.
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
index f312938fd1..fae2f6e6ca 100644
--- a/okhttp-logging-interceptor/README.md
+++ b/okhttp-logging-interceptor/README.md
@@ -11,7 +11,7 @@ OkHttpClient client = new OkHttpClient.Builder()
   .build();
 ```
 
-You can change the log level at any time by calling `setLevel`.
+You can change the log level at any time by calling `setLevel()`.
 
 To log to a custom location, pass a `Logger` instance to the constructor.
 ```java
@@ -22,11 +22,16 @@ HttpLoggingInterceptor logging = new HttpLoggingInterceptor(new Logger() {
 });
 ```
 
-**Warning**: The logs generated by this interceptor when using the `HEADERS` or `BODY` levels has
+**Warning**: The logs generated by this interceptor when using the `HEADERS` or `BODY` levels have
 the potential to leak sensitive information such as "Authorization" or "Cookie" headers and the
 contents of request and response bodies. This data should only be logged in a controlled way or in
 a non-production environment.
 
+You can redact headers that may contain sensitive information by calling `redactHeader()`.
+```java
+logging.redactHeader("Authorization");
+logging.redactHeader("Cookie");
+```
 
 Download
 --------
diff --git a/okhttp-logging-interceptor/build.gradle b/okhttp-logging-interceptor/build.gradle
new file mode 100644
index 0000000000..05c666b94a
--- /dev/null
+++ b/okhttp-logging-interceptor/build.gradle
@@ -0,0 +1,37 @@
+apply plugin: 'com.vanniktech.maven.publish'
+
+jar {
+  manifest {
+    attributes('Automatic-Module-Name': 'okhttp3.logging')
+  }
+}
+
+dependencies {
+  api project(':okhttp')
+  compileOnly deps.jsr305
+
+  testCompileOnly deps.jsr305
+  testImplementation deps.junit
+  testImplementation project(':mockwebserver')
+  testImplementation project(':okhttp-testing-support')
+  testImplementation project(':okhttp-tls')
+  testImplementation deps.assertj
+}
+
+apply plugin: 'me.champeau.gradle.japicmp'
+task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
+  oldClasspath = files(baselineJar(project, baselineVersion))
+  newClasspath = files(jar.archivePath)
+  onlyBinaryIncompatibleModified = true
+  failOnModification = true
+  txtOutputFile = file("$buildDir/reports/japi.txt")
+  ignoreMissingClasses = true
+  includeSynthetic = true
+  methodExcludes = [
+    // Became 'final' in 4.0.0:
+    'okhttp3.logging.HttpLoggingInterceptor#redactHeader(java.lang.String)',
+    'okhttp3.logging.HttpLoggingInterceptor#getLevel()',
+    'okhttp3.logging.HttpLoggingInterceptor#setLevel(okhttp3.logging.HttpLoggingInterceptor$Level)'
+  ]
+}
+check.dependsOn(japicmp)
diff --git a/okhttp-logging-interceptor/gradle.properties b/okhttp-logging-interceptor/gradle.properties
new file mode 100644
index 0000000000..e0fec2973b
--- /dev/null
+++ b/okhttp-logging-interceptor/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=logging-interceptor
+POM_NAME=logging-interceptor
+POM_PACKAGING=jar
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
deleted file mode 100644
index 7e8eb5cfb3..0000000000
--- a/okhttp-logging-interceptor/pom.xml
+++ /dev/null
@@ -1,62 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.11.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>logging-interceptor</artifactId>
-  <name>OkHttp Logging Interceptor</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.logging</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
deleted file mode 100644
index e088ea7c64..0000000000
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+++ /dev/null
@@ -1,318 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.logging;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Connection;
-import okhttp3.Headers;
-import okhttp3.Interceptor;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.platform.Platform;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.GzipSource;
-
-import static okhttp3.internal.platform.Platform.INFO;
-
-/**
- * An OkHttp interceptor which logs request and response information. Can be applied as an
- * {@linkplain OkHttpClient#interceptors() application interceptor} or as a {@linkplain
- * OkHttpClient#networkInterceptors() network interceptor}. <p> The format of the logs created by
- * this class should not be considered stable and may change slightly between releases. If you need
- * a stable logging format, use your own interceptor.
- */
-public final class HttpLoggingInterceptor implements Interceptor {
-  private static final Charset UTF8 = Charset.forName("UTF-8");
-
-  public enum Level {
-    /** No logs. */
-    NONE,
-    /**
-     * Logs request and response lines.
-     *
-     * <p>Example:
-     * <pre>{@code
-     * --> POST /greeting http/1.1 (3-byte body)
-     *
-     * <-- 200 OK (22ms, 6-byte body)
-     * }</pre>
-     */
-    BASIC,
-    /**
-     * Logs request and response lines and their respective headers.
-     *
-     * <p>Example:
-     * <pre>{@code
-     * --> POST /greeting http/1.1
-     * Host: example.com
-     * Content-Type: plain/text
-     * Content-Length: 3
-     * --> END POST
-     *
-     * <-- 200 OK (22ms)
-     * Content-Type: plain/text
-     * Content-Length: 6
-     * <-- END HTTP
-     * }</pre>
-     */
-    HEADERS,
-    /**
-     * Logs request and response lines and their respective headers and bodies (if present).
-     *
-     * <p>Example:
-     * <pre>{@code
-     * --> POST /greeting http/1.1
-     * Host: example.com
-     * Content-Type: plain/text
-     * Content-Length: 3
-     *
-     * Hi?
-     * --> END POST
-     *
-     * <-- 200 OK (22ms)
-     * Content-Type: plain/text
-     * Content-Length: 6
-     *
-     * Hello!
-     * <-- END HTTP
-     * }</pre>
-     */
-    BODY
-  }
-
-  public interface Logger {
-    void log(String message);
-
-    /** A {@link Logger} defaults output appropriate for the current platform. */
-    Logger DEFAULT = new Logger() {
-      @Override public void log(String message) {
-        Platform.get().log(INFO, message, null);
-      }
-    };
-  }
-
-  public HttpLoggingInterceptor() {
-    this(Logger.DEFAULT);
-  }
-
-  public HttpLoggingInterceptor(Logger logger) {
-    this.logger = logger;
-  }
-
-  private final Logger logger;
-
-  private volatile Level level = Level.NONE;
-
-  /** Change the level at which this interceptor logs. */
-  public HttpLoggingInterceptor setLevel(Level level) {
-    if (level == null) throw new NullPointerException("level == null. Use Level.NONE instead.");
-    this.level = level;
-    return this;
-  }
-
-  public Level getLevel() {
-    return level;
-  }
-
-  @Override public Response intercept(Chain chain) throws IOException {
-    Level level = this.level;
-
-    Request request = chain.request();
-    if (level == Level.NONE) {
-      return chain.proceed(request);
-    }
-
-    boolean logBody = level == Level.BODY;
-    boolean logHeaders = logBody || level == Level.HEADERS;
-
-    RequestBody requestBody = request.body();
-    boolean hasRequestBody = requestBody != null;
-
-    Connection connection = chain.connection();
-    String requestStartMessage = "--> "
-        + request.method()
-        + ' ' + request.url()
-        + (connection != null ? " " + connection.protocol() : "");
-    if (!logHeaders && hasRequestBody) {
-      requestStartMessage += " (" + requestBody.contentLength() + "-byte body)";
-    }
-    logger.log(requestStartMessage);
-
-    if (logHeaders) {
-      if (hasRequestBody) {
-        // Request body headers are only present when installed as a network interceptor. Force
-        // them to be included (when available) so there values are known.
-        if (requestBody.contentType() != null) {
-          logger.log("Content-Type: " + requestBody.contentType());
-        }
-        if (requestBody.contentLength() != -1) {
-          logger.log("Content-Length: " + requestBody.contentLength());
-        }
-      }
-
-      Headers headers = request.headers();
-      for (int i = 0, count = headers.size(); i < count; i++) {
-        String name = headers.name(i);
-        // Skip headers from the request body as they are explicitly logged above.
-        if (!"Content-Type".equalsIgnoreCase(name) && !"Content-Length".equalsIgnoreCase(name)) {
-          logger.log(name + ": " + headers.value(i));
-        }
-      }
-
-      if (!logBody || !hasRequestBody) {
-        logger.log("--> END " + request.method());
-      } else if (bodyHasUnknownEncoding(request.headers())) {
-        logger.log("--> END " + request.method() + " (encoded body omitted)");
-      } else {
-        Buffer buffer = new Buffer();
-        requestBody.writeTo(buffer);
-
-        Charset charset = UTF8;
-        MediaType contentType = requestBody.contentType();
-        if (contentType != null) {
-          charset = contentType.charset(UTF8);
-        }
-
-        logger.log("");
-        if (isPlaintext(buffer)) {
-          logger.log(buffer.readString(charset));
-          logger.log("--> END " + request.method()
-              + " (" + requestBody.contentLength() + "-byte body)");
-        } else {
-          logger.log("--> END " + request.method() + " (binary "
-              + requestBody.contentLength() + "-byte body omitted)");
-        }
-      }
-    }
-
-    long startNs = System.nanoTime();
-    Response response;
-    try {
-      response = chain.proceed(request);
-    } catch (Exception e) {
-      logger.log("<-- HTTP FAILED: " + e);
-      throw e;
-    }
-    long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);
-
-    ResponseBody responseBody = response.body();
-    long contentLength = responseBody.contentLength();
-    String bodySize = contentLength != -1 ? contentLength + "-byte" : "unknown-length";
-    logger.log("<-- "
-        + response.code()
-        + (response.message().isEmpty() ? "" : ' ' + response.message())
-        + ' ' + response.request().url()
-        + " (" + tookMs + "ms" + (!logHeaders ? ", " + bodySize + " body" : "") + ')');
-
-    if (logHeaders) {
-      Headers headers = response.headers();
-      for (int i = 0, count = headers.size(); i < count; i++) {
-        logger.log(headers.name(i) + ": " + headers.value(i));
-      }
-
-      if (!logBody || !HttpHeaders.hasBody(response)) {
-        logger.log("<-- END HTTP");
-      } else if (bodyHasUnknownEncoding(response.headers())) {
-        logger.log("<-- END HTTP (encoded body omitted)");
-      } else {
-        BufferedSource source = responseBody.source();
-        source.request(Long.MAX_VALUE); // Buffer the entire body.
-        Buffer buffer = source.buffer();
-
-        Long gzippedLength = null;
-        if ("gzip".equalsIgnoreCase(headers.get("Content-Encoding"))) {
-          gzippedLength = buffer.size();
-          GzipSource gzippedResponseBody = null;
-          try {
-            gzippedResponseBody = new GzipSource(buffer.clone());
-            buffer = new Buffer();
-            buffer.writeAll(gzippedResponseBody);
-          } finally {
-            if (gzippedResponseBody != null) {
-              gzippedResponseBody.close();
-            }
-          }
-        }
-
-        Charset charset = UTF8;
-        MediaType contentType = responseBody.contentType();
-        if (contentType != null) {
-          charset = contentType.charset(UTF8);
-        }
-
-        if (!isPlaintext(buffer)) {
-          logger.log("");
-          logger.log("<-- END HTTP (binary " + buffer.size() + "-byte body omitted)");
-          return response;
-        }
-
-        if (contentLength != 0) {
-          logger.log("");
-          logger.log(buffer.clone().readString(charset));
-        }
-
-        if (gzippedLength != null) {
-            logger.log("<-- END HTTP (" + buffer.size() + "-byte, "
-                + gzippedLength + "-gzipped-byte body)");
-        } else {
-            logger.log("<-- END HTTP (" + buffer.size() + "-byte body)");
-        }
-      }
-    }
-
-    return response;
-  }
-
-  /**
-   * Returns true if the body in question probably contains human readable text. Uses a small sample
-   * of code points to detect unicode control characters commonly used in binary file signatures.
-   */
-  static boolean isPlaintext(Buffer buffer) {
-    try {
-      Buffer prefix = new Buffer();
-      long byteCount = buffer.size() < 64 ? buffer.size() : 64;
-      buffer.copyTo(prefix, 0, byteCount);
-      for (int i = 0; i < 16; i++) {
-        if (prefix.exhausted()) {
-          break;
-        }
-        int codePoint = prefix.readUtf8CodePoint();
-        if (Character.isISOControl(codePoint) && !Character.isWhitespace(codePoint)) {
-          return false;
-        }
-      }
-      return true;
-    } catch (EOFException e) {
-      return false; // Truncated UTF-8 sequence.
-    }
-  }
-
-  private boolean bodyHasUnknownEncoding(Headers headers) {
-    String contentEncoding = headers.get("Content-Encoding");
-    return contentEncoding != null
-        && !contentEncoding.equalsIgnoreCase("identity")
-        && !contentEncoding.equalsIgnoreCase("gzip");
-  }
-}
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
new file mode 100644
index 0000000000..a68ae661ba
--- /dev/null
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
@@ -0,0 +1,312 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging
+
+import okhttp3.Headers
+import okhttp3.Interceptor
+import okhttp3.OkHttpClient
+import okhttp3.Response
+import okhttp3.internal.http.HttpHeaders
+import okhttp3.internal.platform.Platform
+import okhttp3.internal.platform.Platform.Companion.INFO
+import okio.Buffer
+import okio.GzipSource
+import java.io.EOFException
+import java.io.IOException
+import java.nio.charset.Charset
+import java.nio.charset.StandardCharsets
+import java.util.TreeSet
+import java.util.concurrent.TimeUnit
+
+/**
+ * An OkHttp interceptor which logs request and response information. Can be applied as an
+ * [application interceptor][OkHttpClient.interceptors] or as a [OkHttpClient.networkInterceptors].
+ *
+ * The format of the logs created by this class should not be considered stable and may
+ * change slightly between releases. If you need a stable logging format, use your own interceptor.
+ */
+class HttpLoggingInterceptor @JvmOverloads constructor(
+  private val logger: Logger = Logger.DEFAULT
+) : Interceptor {
+
+  @Volatile private var headersToRedact = emptySet<String>()
+
+  @Volatile private var level = Level.NONE
+
+  enum class Level {
+    /** No logs. */
+    NONE,
+
+    /**
+     * Logs request and response lines.
+     *
+     * Example:
+     * ```
+     * --> POST /greeting http/1.1 (3-byte body)
+     *
+     * <-- 200 OK (22ms, 6-byte body)
+     * ```
+     */
+    BASIC,
+
+    /**
+     * Logs request and response lines and their respective headers.
+     *
+     * Example:
+     * ```
+     * --> POST /greeting http/1.1
+     * Host: example.com
+     * Content-Type: plain/text
+     * Content-Length: 3
+     * --> END POST
+     *
+     * <-- 200 OK (22ms)
+     * Content-Type: plain/text
+     * Content-Length: 6
+     * <-- END HTTP
+     * ```
+     */
+    HEADERS,
+
+    /**
+     * Logs request and response lines and their respective headers and bodies (if present).
+     *
+     * Example:
+     * ```
+     * --> POST /greeting http/1.1
+     * Host: example.com
+     * Content-Type: plain/text
+     * Content-Length: 3
+     *
+     * Hi?
+     * --> END POST
+     *
+     * <-- 200 OK (22ms)
+     * Content-Type: plain/text
+     * Content-Length: 6
+     *
+     * Hello!
+     * <-- END HTTP
+     * ```
+     */
+    BODY
+  }
+
+  interface Logger {
+    fun log(message: String)
+
+    companion object {
+      /** A [Logger] defaults output appropriate for the current platform.  */
+      @JvmField
+      val DEFAULT: Logger = object : Logger {
+        override fun log(message: String) {
+          Platform.get().log(INFO, message, null)
+        }
+      }
+    }
+  }
+
+  fun redactHeader(name: String) {
+    val newHeadersToRedact = TreeSet(String.CASE_INSENSITIVE_ORDER)
+    newHeadersToRedact.addAll(headersToRedact)
+    newHeadersToRedact.add(name)
+    headersToRedact = newHeadersToRedact
+  }
+
+  /** Change the level at which this interceptor logs.  */
+  fun setLevel(level: Level) = apply {
+    this.level = level
+  }
+
+  fun getLevel(): Level = level
+
+  @Throws(IOException::class)
+  override fun intercept(chain: Interceptor.Chain): Response {
+    val level = this.level
+
+    val request = chain.request()
+    if (level == Level.NONE) {
+      return chain.proceed(request)
+    }
+
+    val logBody = level == Level.BODY
+    val logHeaders = logBody || level == Level.HEADERS
+
+    val requestBody = request.body()
+
+    val connection = chain.connection()
+    var requestStartMessage = ("--> ${request.method()} ${request.url()}${if (connection != null) " " + connection.protocol() else ""}")
+    if (!logHeaders && requestBody != null) {
+      requestStartMessage += " (${requestBody.contentLength()}-byte body)"
+    }
+    logger.log(requestStartMessage)
+
+    if (logHeaders) {
+      if (requestBody != null) {
+        // Request body headers are only present when installed as a network interceptor. Force
+        // them to be included (when available) so there values are known.
+        requestBody.contentType()?.let {
+          logger.log("Content-Type: $it")
+        }
+        if (requestBody.contentLength() != -1L) {
+          logger.log("Content-Length: ${requestBody.contentLength()}")
+        }
+      }
+
+      val headers = request.headers()
+      var i = 0
+      val count = headers.size()
+      while (i < count) {
+        val name = headers.name(i)
+        // Skip headers from the request body as they are explicitly logged above.
+        if (!"Content-Type".equals(name, ignoreCase = true) && !"Content-Length".equals(name,
+                ignoreCase = true)) {
+          logHeader(headers, i)
+        }
+        i++
+      }
+
+      if (!logBody || requestBody == null) {
+        logger.log("--> END ${request.method()}")
+      } else if (bodyHasUnknownEncoding(request.headers())) {
+        logger.log("--> END ${request.method()} (encoded body omitted)")
+      } else if (requestBody.isDuplex) {
+        logger.log("--> END ${request.method()} (duplex request body omitted)")
+      } else {
+        val buffer = Buffer()
+        requestBody.writeTo(buffer)
+
+        val contentType = requestBody.contentType()
+        val charset: Charset = contentType?.charset(UTF8) ?: UTF8
+
+        logger.log("")
+        if (isPlaintext(buffer)) {
+          logger.log(buffer.readString(charset))
+          logger.log("--> END ${request.method()} (${requestBody.contentLength()}-byte body)")
+        } else {
+          logger.log(
+              "--> END ${request.method()} (binary ${requestBody.contentLength()}-byte body omitted)")
+        }
+      }
+    }
+
+    val startNs = System.nanoTime()
+    val response: Response
+    try {
+      response = chain.proceed(request)
+    } catch (e: Exception) {
+      logger.log("<-- HTTP FAILED: $e")
+      throw e
+    }
+
+    val tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs)
+
+    val responseBody = response.body()!!
+    val contentLength = responseBody.contentLength()
+    val bodySize = if (contentLength != -1L) "$contentLength-byte" else "unknown-length"
+    logger.log(
+        "<-- ${response.code()}${if (response.message().isEmpty()) "" else ' ' + response.message()} ${response.request().url()} (${tookMs}ms${if (!logHeaders) ", $bodySize body" else ""})")
+
+    if (logHeaders) {
+      val headers = response.headers()
+      for (i in 0 until headers.size()) {
+        logHeader(headers, i)
+      }
+
+      if (!logBody || !HttpHeaders.hasBody(response)) {
+        logger.log("<-- END HTTP")
+      } else if (bodyHasUnknownEncoding(response.headers())) {
+        logger.log("<-- END HTTP (encoded body omitted)")
+      } else {
+        val source = responseBody.source()
+        source.request(java.lang.Long.MAX_VALUE) // Buffer the entire body.
+        var buffer = source.buffer
+
+        var gzippedLength: Long? = null
+        if ("gzip".equals(headers["Content-Encoding"], ignoreCase = true)) {
+          gzippedLength = buffer.size
+          GzipSource(buffer.clone()).use { gzippedResponseBody ->
+            buffer = Buffer()
+            buffer.writeAll(gzippedResponseBody)
+          }
+        }
+
+        val contentType = responseBody.contentType()
+        val charset: Charset = contentType?.charset(UTF8) ?: UTF8
+
+        if (!isPlaintext(buffer)) {
+          logger.log("")
+          logger.log("<-- END HTTP (binary ${buffer.size}-byte body omitted)")
+          return response
+        }
+
+        if (contentLength != 0L) {
+          logger.log("")
+          logger.log(buffer.clone().readString(charset))
+        }
+
+        if (gzippedLength != null) {
+          logger.log("<-- END HTTP (${buffer.size}-byte, $gzippedLength-gzipped-byte body)")
+        } else {
+          logger.log("<-- END HTTP (${buffer.size}-byte body)")
+        }
+      }
+    }
+
+    return response
+  }
+
+  private fun logHeader(headers: Headers, i: Int) {
+    val value = if (headersToRedact.contains(headers.name(i))) "‚ñà‚ñà" else headers.value(i)
+    logger.log(headers.name(i) + ": " + value)
+  }
+
+  companion object {
+    private val UTF8 = StandardCharsets.UTF_8
+
+    /**
+     * Returns true if the body in question probably contains human readable text. Uses a small sample
+     * of code points to detect unicode control characters commonly used in binary file signatures.
+     */
+    @JvmStatic
+    fun isPlaintext(buffer: Buffer): Boolean {
+      try {
+        val prefix = Buffer()
+        val byteCount = if (buffer.size < 64) buffer.size else 64
+        buffer.copyTo(prefix, 0, byteCount)
+        for (i in 0..15) {
+          if (prefix.exhausted()) {
+            break
+          }
+          val codePoint = prefix.readUtf8CodePoint()
+          if (Character.isISOControl(codePoint) && !Character.isWhitespace(codePoint)) {
+            return false
+          }
+        }
+        return true
+      } catch (e: EOFException) {
+        return false // Truncated UTF-8 sequence.
+      }
+    }
+
+    private fun bodyHasUnknownEncoding(headers: Headers): Boolean {
+      val contentEncoding = headers["Content-Encoding"]
+      return (contentEncoding != null
+          && !contentEncoding.equals("identity", ignoreCase = true)
+          && !contentEncoding.equals("gzip", ignoreCase = true))
+    }
+  }
+}
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt
new file mode 100644
index 0000000000..0538f6d19c
--- /dev/null
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging
+
+import okhttp3.Call
+import okhttp3.Connection
+import okhttp3.EventListener
+import okhttp3.Handshake
+import okhttp3.OkHttpClient
+import okhttp3.Protocol
+import okhttp3.Request
+import okhttp3.Response
+import java.io.IOException
+import java.net.InetAddress
+import java.net.InetSocketAddress
+import java.net.Proxy
+import java.util.concurrent.TimeUnit
+
+/**
+ * An OkHttp EventListener, which logs call events. Can be applied as an
+ * [event listener factory][OkHttpClient.eventListenerFactory].
+ *
+ * The format of the logs created by this class should not be considered stable and may change
+ * slightly between releases. If you need a stable logging format, use your own event listener.
+ */
+class LoggingEventListener private constructor(
+  private val logger: HttpLoggingInterceptor.Logger
+) : EventListener() {
+  private var startNs: Long = 0
+
+  override fun callStart(call: Call) {
+    startNs = System.nanoTime()
+
+    logWithTime("callStart: ${call.request()}")
+  }
+
+  override fun dnsStart(call: Call, domainName: String) {
+    logWithTime("dnsStart: $domainName")
+  }
+
+  override fun dnsEnd(call: Call, domainName: String, inetAddressList: List<InetAddress>) {
+    logWithTime("dnsEnd: $inetAddressList")
+  }
+
+  override fun connectStart(call: Call, inetSocketAddress: InetSocketAddress, proxy: Proxy) {
+    logWithTime("connectStart: $inetSocketAddress $proxy")
+  }
+
+  override fun secureConnectStart(call: Call) {
+    logWithTime("secureConnectStart")
+  }
+
+  override fun secureConnectEnd(call: Call, handshake: Handshake?) {
+    logWithTime("secureConnectEnd: $handshake")
+  }
+
+  override fun connectEnd(
+    call: Call, inetSocketAddress: InetSocketAddress, proxy: Proxy, protocol: Protocol?
+  ) {
+    logWithTime("connectEnd: $protocol")
+  }
+
+  override fun connectFailed(
+    call: Call,
+    inetSocketAddress: InetSocketAddress,
+    proxy: Proxy,
+    protocol: Protocol?,
+    ioe: IOException
+  ) {
+    logWithTime("connectFailed: $protocol $ioe")
+  }
+
+  override fun connectionAcquired(call: Call, connection: Connection) {
+    logWithTime("connectionAcquired: $connection")
+  }
+
+  override fun connectionReleased(call: Call, connection: Connection) {
+    logWithTime("connectionReleased")
+  }
+
+  override fun requestHeadersStart(call: Call) {
+    logWithTime("requestHeadersStart")
+  }
+
+  override fun requestHeadersEnd(call: Call, request: Request) {
+    logWithTime("requestHeadersEnd")
+  }
+
+  override fun requestBodyStart(call: Call) {
+    logWithTime("requestBodyStart")
+  }
+
+  override fun requestBodyEnd(call: Call, byteCount: Long) {
+    logWithTime("requestBodyEnd: byteCount=$byteCount")
+  }
+
+  override fun requestFailed(call: Call, ioe: IOException) {
+    logWithTime("requestFailed: $ioe")
+  }
+
+  override fun responseHeadersStart(call: Call) {
+    logWithTime("responseHeadersStart")
+  }
+
+  override fun responseHeadersEnd(call: Call, response: Response) {
+    logWithTime("responseHeadersEnd: $response")
+  }
+
+  override fun responseBodyStart(call: Call) {
+    logWithTime("responseBodyStart")
+  }
+
+  override fun responseBodyEnd(call: Call, byteCount: Long) {
+    logWithTime("responseBodyEnd: byteCount=$byteCount")
+  }
+
+  override fun responseFailed(call: Call, ioe: IOException) {
+    logWithTime("responseFailed: $ioe")
+  }
+
+  override fun callEnd(call: Call) {
+    logWithTime("callEnd")
+  }
+
+  override fun callFailed(call: Call, ioe: IOException) {
+    logWithTime("callFailed: $ioe")
+  }
+
+  private fun logWithTime(message: String) {
+    val timeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs)
+    logger.log("[$timeMs ms] $message")
+  }
+
+  open class Factory @JvmOverloads constructor(
+    private val logger: HttpLoggingInterceptor.Logger = HttpLoggingInterceptor.Logger.DEFAULT
+  ) : EventListener.Factory {
+    override fun create(call: Call): EventListener = LoggingEventListener(logger)
+  }
+}
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
deleted file mode 100644
index 39904701cf..0000000000
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
+++ /dev/null
@@ -1,3 +0,0 @@
-/** An OkHttp interceptor which logs HTTP request and response data. */
-@javax.annotation.ParametersAreNonnullByDefault
-package okhttp3.logging;
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index 613aed1341..79c7e6f0c2 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -16,13 +16,11 @@
 package okhttp3.logging;
 
 import java.io.IOException;
-import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.regex.Pattern;
+import javax.annotation.Nullable;
 import javax.net.ssl.HostnameVerifier;
-import okhttp3.Dns;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
@@ -32,33 +30,30 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okhttp3.logging.HttpLoggingInterceptor.Level;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
-import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.junit.Assume.assumeThat;
 
 public final class HttpLoggingInterceptorTest {
-  private static final MediaType PLAIN = MediaType.parse("text/plain; charset=utf-8");
+  private static final MediaType PLAIN = MediaType.get("text/plain; charset=utf-8");
 
   @Rule public final MockWebServer server = new MockWebServer();
 
-  private SslClient sslClient = SslClient.localhost();
-  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+  private final HandshakeCertificates handshakeCertificates = localhost();
+  private final HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private OkHttpClient client;
   private String host;
   private HttpUrl url;
@@ -80,7 +75,8 @@ private void setLevel(Level level) {
     client = new OkHttpClient.Builder()
         .addNetworkInterceptor(networkInterceptor)
         .addInterceptor(applicationInterceptor)
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build();
 
@@ -90,11 +86,11 @@ private void setLevel(Level level) {
 
   @Test public void levelGetter() {
     // The default is NONE.
-    Assert.assertEquals(Level.NONE, applicationInterceptor.getLevel());
+    assertThat(applicationInterceptor.getLevel()).isEqualTo(Level.NONE);
 
     for (Level level : Level.values()) {
       applicationInterceptor.setLevel(level);
-      assertEquals(level, applicationInterceptor.getLevel());
+      assertThat(applicationInterceptor.getLevel()).isEqualTo(level);
     }
   }
 
@@ -102,14 +98,13 @@ private void setLevel(Level level) {
     try {
       applicationInterceptor.setLevel(null);
       fail();
-    } catch (NullPointerException expected) {
-      assertEquals("level == null. Use Level.NONE instead.", expected.getMessage());
+    } catch (IllegalArgumentException expected) {
     }
   }
 
   @Test public void setLevelShouldReturnSameInstanceOfInterceptor() {
     for (Level level : Level.values()) {
-      assertSame(applicationInterceptor, applicationInterceptor.setLevel(level));
+      assertThat(applicationInterceptor.setLevel(level)).isSameAs(applicationInterceptor);
     }
   }
 
@@ -544,7 +539,8 @@ private void bodyGetNoBody(int code) throws IOException {
     Response response = client.newCall(request().build()).execute();
 
     ResponseBody responseBody = response.body();
-    assertEquals("Expected response body to be valid","Hello, Hello, Hello", responseBody.string());
+    assertThat(responseBody.string()).overridingErrorMessage(
+        "Expected response body to be valid").isEqualTo("Hello, Hello, Hello");
     responseBody.close();
 
     networkLogs
@@ -647,14 +643,14 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
   }
 
-  @Test public void isPlaintext() throws IOException {
-    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer()));
-    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("abc")));
-    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("new\r\nlines")));
-    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("white\t space")));
-    assertTrue(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x80)));
-    assertFalse(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x00)));
-    assertFalse(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0xc0)));
+  @Test public void isPlaintext() {
+    assertThat(HttpLoggingInterceptor.isPlaintext(new Buffer())).isTrue();
+    assertThat(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("abc"))).isTrue();
+    assertThat(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("new\r\nlines"))).isTrue();
+    assertThat(HttpLoggingInterceptor.isPlaintext(new Buffer().writeUtf8("white\t space"))).isTrue();
+    assertThat(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x80))).isTrue();
+    assertThat(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0x00))).isFalse();
+    assertThat(HttpLoggingInterceptor.isPlaintext(new Buffer().writeByte(0xc0))).isFalse();
   }
 
   @Test public void responseBodyIsBinary() throws IOException {
@@ -702,11 +698,7 @@ private void bodyGetNoBody(int code) throws IOException {
   @Test public void connectFail() throws IOException {
     setLevel(Level.BASIC);
     client = new OkHttpClient.Builder()
-        .dns(new Dns() {
-          @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-            throw new UnknownHostException("reason");
-          }
-        })
+        .dns(hostname -> { throw new UnknownHostException("reason"); })
         .addInterceptor(applicationInterceptor)
         .build();
 
@@ -723,7 +715,7 @@ private void bodyGetNoBody(int code) throws IOException {
   }
 
   @Test public void http2() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     url = server.url("/");
 
     setLevel(Level.BASIC);
@@ -743,31 +735,131 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
   }
 
+  @Test
+  public void headersAreRedacted() throws Exception {
+    HttpLoggingInterceptor networkInterceptor =
+        new HttpLoggingInterceptor(networkLogs).setLevel(Level.HEADERS);
+    networkInterceptor.redactHeader("sEnSiTiVe");
+
+    HttpLoggingInterceptor applicationInterceptor =
+        new HttpLoggingInterceptor(applicationLogs).setLevel(Level.HEADERS);
+    applicationInterceptor.redactHeader("sEnSiTiVe");
+
+    client =
+        new OkHttpClient.Builder()
+            .addNetworkInterceptor(networkInterceptor)
+            .addInterceptor(applicationInterceptor)
+            .build();
+
+    server.enqueue(
+        new MockResponse().addHeader("SeNsItIvE", "Value").addHeader("Not-Sensitive", "Value"));
+    Response response =
+        client
+            .newCall(
+                request()
+                    .addHeader("SeNsItIvE", "Value")
+                    .addHeader("Not-Sensitive", "Value")
+                    .build())
+            .execute();
+    response.body().close();
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogEqual("SeNsItIvE: ‚ñà‚ñà")
+        .assertLogEqual("Not-Sensitive: Value")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("SeNsItIvE: ‚ñà‚ñà")
+        .assertLogEqual("Not-Sensitive: Value")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("SeNsItIvE: ‚ñà‚ñà")
+        .assertLogEqual("Not-Sensitive: Value")
+        .assertLogEqual("Host: " + host)
+        .assertLogEqual("Connection: Keep-Alive")
+        .assertLogEqual("Accept-Encoding: gzip")
+        .assertLogMatch("User-Agent: okhttp/.+")
+        .assertLogEqual("--> END GET")
+        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("Content-Length: 0")
+        .assertLogEqual("SeNsItIvE: ‚ñà‚ñà")
+        .assertLogEqual("Not-Sensitive: Value")
+        .assertLogEqual("<-- END HTTP")
+        .assertNoMoreLogs();
+  }
+
+  @Test public void duplexRequestsAreNotLogged() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false); // HTTP/2
+    url = server.url("/");
+
+    setLevel(Level.BODY);
+
+    server.enqueue(new MockResponse()
+        .setBody("Hello response!"));
+
+    RequestBody asyncRequestBody = new RequestBody() {
+      @Override public @Nullable MediaType contentType() {
+        return null;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Hello request!");
+        sink.close();
+      }
+
+      @Override public boolean isDuplex() {
+        return true;
+      }
+    };
+
+    Request request = request()
+        .post(asyncRequestBody)
+        .build();
+    Response response = client.newCall(request).execute();
+    assumeThat(response.protocol(), equalTo(Protocol.HTTP_2));
+
+    assertThat(response.body().string()).isEqualTo("Hello response!");
+
+    applicationLogs
+        .assertLogEqual("--> POST " + url)
+        .assertLogEqual("--> END POST (duplex request body omitted)")
+        .assertLogMatch("<-- 200 " + url + " \\(\\d+ms\\)")
+        .assertLogEqual("content-length: 15")
+        .assertLogEqual("")
+        .assertLogEqual("Hello response!")
+        .assertLogEqual("<-- END HTTP (15-byte body)")
+        .assertNoMoreLogs();
+  }
+
   private Request.Builder request() {
     return new Request.Builder().url(url);
   }
 
-  private static class LogRecorder implements HttpLoggingInterceptor.Logger {
+  static class LogRecorder implements HttpLoggingInterceptor.Logger {
     private final List<String> logs = new ArrayList<>();
     private int index;
 
     LogRecorder assertLogEqual(String expected) {
-      assertTrue("No more messages found", index < logs.size());
+      assertThat(index).overridingErrorMessage("No more messages found").isLessThan(logs.size());
       String actual = logs.get(index++);
-      assertEquals(expected, actual);
+      assertThat(actual).isEqualTo(expected);
       return this;
     }
 
     LogRecorder assertLogMatch(String pattern) {
-      assertTrue("No more messages found", index < logs.size());
+      assertThat(index).overridingErrorMessage("No more messages found").isLessThan(logs.size());
       String actual = logs.get(index++);
-      assertTrue("<" + actual + "> did not match pattern <" + pattern + ">",
-          Pattern.matches(pattern, actual));
+      assertThat(actual).matches(pattern);
       return this;
     }
 
     void assertNoMoreLogs() {
-      assertTrue("More messages remain: " + logs.subList(index, logs.size()), index == logs.size());
+      assertThat(logs.size()).overridingErrorMessage(
+          "More messages remain: " + logs.subList(index, logs.size())).isEqualTo(index);
     }
 
     @Override public void log(String message) {
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
new file mode 100644
index 0000000000..9a61c457bb
--- /dev/null
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.logging;
+
+import java.io.IOException;
+import java.net.UnknownHostException;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static java.util.Arrays.asList;
+import static okhttp3.Protocol.HTTP_1_1;
+import static okhttp3.Protocol.HTTP_2;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class LoggingEventListenerTest {
+  private static final MediaType PLAIN = MediaType.get("text/plain");
+
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final HandshakeCertificates handshakeCertificates = localhost();
+  private final LogRecorder logRecorder = new LogRecorder();
+  private final LoggingEventListener.Factory loggingEventListenerFactory =
+      new LoggingEventListener.Factory(logRecorder);
+  private OkHttpClient client;
+  private HttpUrl url;
+
+  @Before
+  public void setUp() {
+    client =
+        new OkHttpClient.Builder()
+            .eventListenerFactory(loggingEventListenerFactory)
+            .sslSocketFactory(
+                handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+            .retryOnConnectionFailure(false)
+            .build();
+
+    url = server.url("/");
+  }
+
+  @Test
+  public void get() throws Exception {
+    server.enqueue(new MockResponse().setBody("Hello!").setHeader("Content-Type", PLAIN));
+    Response response = client.newCall(request().build()).execute();
+    assertThat(response.body()).isNotNull();
+    response.body().bytes();
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("dnsEnd: \\[.+\\]")
+        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
+        .assertLogMatch("connectEnd: http/1.1")
+        .assertLogMatch(
+            "connectionAcquired: Connection\\{"
+                + url.host()
+                + ":\\d+, proxy=DIRECT hostAddress="
+                + url.host()
+                + "/.+ cipherSuite=none protocol=http/1\\.1\\}")
+        .assertLogMatch("requestHeadersStart")
+        .assertLogMatch("requestHeadersEnd")
+        .assertLogMatch("responseHeadersStart")
+        .assertLogMatch(
+            "responseHeadersEnd: Response\\{protocol=http/1\\.1, code=200, message=OK, url="
+                + url
+                + "}")
+        .assertLogMatch("responseBodyStart")
+        .assertLogMatch("responseBodyEnd: byteCount=6")
+        .assertLogMatch("connectionReleased")
+        .assertLogMatch("callEnd")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void post() throws IOException {
+    server.enqueue(new MockResponse());
+    client.newCall(request().post(RequestBody.create(PLAIN, "Hello!")).build()).execute();
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=POST, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("dnsEnd: \\[.+\\]")
+        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
+        .assertLogMatch("connectEnd: http/1.1")
+        .assertLogMatch(
+            "connectionAcquired: Connection\\{"
+                + url.host()
+                + ":\\d+, proxy=DIRECT hostAddress="
+                + url.host()
+                + "/.+ cipherSuite=none protocol=http/1\\.1\\}")
+        .assertLogMatch("requestHeadersStart")
+        .assertLogMatch("requestHeadersEnd")
+        .assertLogMatch("requestBodyStart")
+        .assertLogMatch("requestBodyEnd: byteCount=6")
+        .assertLogMatch("responseHeadersStart")
+        .assertLogMatch(
+            "responseHeadersEnd: Response\\{protocol=http/1\\.1, code=200, message=OK, url="
+                + url
+                + "}")
+        .assertLogMatch("responseBodyStart")
+        .assertLogMatch("responseBodyEnd: byteCount=0")
+        .assertLogMatch("connectionReleased")
+        .assertLogMatch("callEnd")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void secureGet() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    url = server.url("/");
+
+    server.enqueue(new MockResponse());
+    Response response = client.newCall(request().build()).execute();
+    assertThat(response.body()).isNotNull();
+    response.body().bytes();
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("dnsEnd: \\[.+\\]")
+        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
+        .assertLogMatch("secureConnectStart")
+        .assertLogMatch("secureConnectEnd: Handshake\\{"
+            + "tlsVersion=TLS_1_[23] "
+            + "cipherSuite=TLS_.* "
+            + "peerCertificates=\\[CN=localhost\\] "
+            + "localCertificates=\\[\\]}")
+        .assertLogMatch("connectEnd: h2")
+        .assertLogMatch(
+            "connectionAcquired: Connection\\{"
+                + url.host()
+                + ":\\d+, proxy=DIRECT hostAddress="
+                + url.host()
+                + "/.+ cipherSuite=.+ protocol=h2}")
+        .assertLogMatch("requestHeadersStart")
+        .assertLogMatch("requestHeadersEnd")
+        .assertLogMatch("responseHeadersStart")
+        .assertLogMatch(
+            "responseHeadersEnd: Response\\{protocol=h2, code=200, message=, url=" + url + "}")
+        .assertLogMatch("responseBodyStart")
+        .assertLogMatch("responseBodyEnd: byteCount=0")
+        .assertLogMatch("connectionReleased")
+        .assertLogMatch("callEnd")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void dnsFail() throws IOException {
+    client = new OkHttpClient.Builder()
+        .dns(hostname -> { throw new UnknownHostException("reason"); })
+        .eventListenerFactory(loggingEventListenerFactory)
+        .build();
+
+    try {
+      client.newCall(request().build()).execute();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("callFailed: java.net.UnknownHostException: reason")
+        .assertNoMoreLogs();
+  }
+
+  @Test
+  public void connectFail() {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.setProtocols(asList(HTTP_2, HTTP_1_1));
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    url = server.url("/");
+
+    try {
+      client.newCall(request().build()).execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    logRecorder
+        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + ", tags=\\{\\}\\}")
+        .assertLogMatch("dnsStart: " + url.host())
+        .assertLogMatch("dnsEnd: \\[.+\\]")
+        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
+        .assertLogMatch("secureConnectStart")
+        .assertLogMatch(
+            "connectFailed: null javax\\.net\\.ssl\\.SSLProtocolException: (?:Unexpected handshake message: client_hello|Handshake message sequence violation, 1)")
+        .assertLogMatch(
+            "callFailed: javax\\.net\\.ssl\\.SSLProtocolException: (?:Unexpected handshake message: client_hello|Handshake message sequence violation, 1)")
+        .assertNoMoreLogs();
+  }
+
+  private Request.Builder request() {
+    return new Request.Builder().url(url);
+  }
+
+  private static class LogRecorder extends HttpLoggingInterceptorTest.LogRecorder {
+    @Override LogRecorder assertLogMatch(String pattern) {
+      return (LogRecorder) super.assertLogMatch("\\[\\d+ ms] " + pattern);
+    }
+  }
+}
diff --git a/okhttp-sse/Module.md b/okhttp-sse/Module.md
new file mode 100644
index 0000000000..1802142d80
--- /dev/null
+++ b/okhttp-sse/Module.md
@@ -0,0 +1,3 @@
+# Module okhttp-sse
+
+Support for server-sent events.
diff --git a/okhttp-sse/README.md b/okhttp-sse/README.md
new file mode 100644
index 0000000000..2b1bc42830
--- /dev/null
+++ b/okhttp-sse/README.md
@@ -0,0 +1,5 @@
+OkHttp Server-Sent Events
+=========================
+
+Experimental support for server-sent events.
+API is not considered stable and may change at any time.
diff --git a/okhttp-sse/build.gradle b/okhttp-sse/build.gradle
new file mode 100644
index 0000000000..9cf45a998d
--- /dev/null
+++ b/okhttp-sse/build.gradle
@@ -0,0 +1,18 @@
+apply plugin: 'com.vanniktech.maven.publish'
+
+jar {
+  manifest {
+    attributes('Automatic-Module-Name': 'okhttp3.sse')
+  }
+}
+
+dependencies {
+  api project(':okhttp')
+  compileOnly deps.jsr305
+
+  testImplementation project(':okhttp-testing-support')
+  testImplementation project(':mockwebserver')
+  testImplementation deps.junit
+  testImplementation deps.assertj
+  testCompileOnly deps.jsr305
+}
diff --git a/okhttp-sse/gradle.properties b/okhttp-sse/gradle.properties
new file mode 100644
index 0000000000..497287dfc0
--- /dev/null
+++ b/okhttp-sse/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=okhttp-sse
+POM_NAME=okhttp-sse
+POM_PACKAGING=jar
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java
new file mode 100644
index 0000000000..d1261077a4
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.EventListener;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.connection.Exchange;
+import okhttp3.sse.EventSource;
+import okhttp3.sse.EventSourceListener;
+
+public final class RealEventSource
+    implements EventSource, ServerSentEventReader.Callback, Callback {
+
+  private final Request request;
+  private final EventSourceListener listener;
+
+  private @Nullable Call call;
+
+  public RealEventSource(Request request, EventSourceListener listener) {
+    this.request = request;
+    this.listener = listener;
+  }
+
+  public void connect(OkHttpClient client) {
+    client = client.newBuilder()
+        .eventListener(EventListener.NONE)
+        .build();
+    call = client.newCall(request);
+    call.enqueue(this);
+  }
+
+  @Override public void onResponse(Call call, Response response) {
+    processResponse(response);
+  }
+
+  public void processResponse(Response response) {
+    try {
+      if (!response.isSuccessful()) {
+        listener.onFailure(this, null, response);
+        return;
+      }
+
+      ResponseBody body = response.body();
+
+      //noinspection ConstantConditions main body is never null
+      MediaType contentType = body.contentType();
+      if (!isEventStream(contentType)) {
+        listener.onFailure(this,
+            new IllegalStateException("Invalid content-type: " + contentType), response);
+        return;
+      }
+
+      // This is a long-lived response. Cancel full-call timeouts.
+      Exchange exchange = Internal.instance.exchange(response);
+      if (exchange != null) exchange.timeoutEarlyExit();
+
+      // Replace the body with an empty one so the callbacks can't see real data.
+      response = response.newBuilder().body(Util.EMPTY_RESPONSE).build();
+
+      ServerSentEventReader reader = new ServerSentEventReader(body.source(), this);
+      try {
+        listener.onOpen(this, response);
+        while (reader.processNextEvent()) {
+        }
+      } catch (Exception e) {
+        listener.onFailure(this, e, response);
+        return;
+      }
+
+      listener.onClosed(this);
+    } finally {
+      response.close();
+    }
+  }
+
+  private static boolean isEventStream(@Nullable MediaType contentType) {
+    return contentType != null && contentType.type().equals("text") && contentType.subtype()
+        .equals("event-stream");
+  }
+
+  @Override public void onFailure(Call call, IOException e) {
+    listener.onFailure(this, e, null);
+  }
+
+  @Override public Request request() {
+    return request;
+  }
+
+  @Override public void cancel() {
+    call.cancel();
+  }
+
+  @Override public void onEvent(@Nullable String id, @Nullable String type, String data) {
+    listener.onEvent(this, id, type, data);
+  }
+
+  @Override public void onRetryChange(long timeMs) {
+    // Ignored. We do not auto-retry.
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
new file mode 100644
index 0000000000..ae19d3745e
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+
+public final class ServerSentEventReader {
+  private static final ByteString CRLF = ByteString.encodeUtf8("\r\n");
+  private static final ByteString DATA = ByteString.encodeUtf8("data");
+  private static final ByteString ID = ByteString.encodeUtf8("id");
+  private static final ByteString EVENT = ByteString.encodeUtf8("event");
+  private static final ByteString RETRY = ByteString.encodeUtf8("retry");
+
+  public interface Callback {
+    void onEvent(@Nullable String id, @Nullable String type, String data);
+    void onRetryChange(long timeMs);
+  }
+
+  private final BufferedSource source;
+  private final Callback callback;
+
+  private String lastId = null;
+
+  public ServerSentEventReader(BufferedSource source, Callback callback) {
+    if (source == null) throw new NullPointerException("source == null");
+    if (callback == null) throw new NullPointerException("callback == null");
+    this.source = source;
+    this.callback = callback;
+  }
+
+  /**
+   * Process the next event. This will result in a single call to {@link Callback#onEvent}
+   * <em>unless</em> the data section was empty. Any number of calls to
+   * {@link Callback#onRetryChange} may occur while processing an event.
+   *
+   * @return false when EOF is reached
+   */
+  boolean processNextEvent() throws IOException {
+    String id = lastId;
+    String type = null;
+    Buffer data = new Buffer();
+
+    while (true) {
+      long lineEnd = source.indexOfElement(CRLF);
+      if (lineEnd == -1L) {
+        return false;
+      }
+
+      switch (source.getBuffer().getByte(0)) {
+        case '\r':
+        case '\n':
+          completeEvent(id, type, data);
+          return true;
+
+        case 'd':
+          if (isKey(DATA)) {
+            parseData(data, lineEnd);
+            continue;
+          }
+          break;
+
+        case 'e':
+          if (isKey(EVENT)) {
+            type = parseEvent(lineEnd);
+            continue;
+          }
+          break;
+
+        case 'i':
+          if (isKey(ID)) {
+            id = parseId(lineEnd);
+            continue;
+          }
+          break;
+
+        case 'r':
+          if (isKey(RETRY)) {
+            parseRetry(lineEnd);
+            continue;
+          }
+          break;
+      }
+
+      source.skip(lineEnd);
+      skipCrAndOrLf();
+    }
+  }
+
+  private void completeEvent(String id, String type, Buffer data) throws IOException {
+    skipCrAndOrLf();
+
+    if (data.size() != 0L) {
+      lastId = id;
+      data.skip(1L); // Leading newline.
+      callback.onEvent(id, type, data.readUtf8());
+    }
+  }
+
+  private void parseData(Buffer data, long end) throws IOException {
+    data.writeByte('\n');
+    end -= skipNameAndDivider(4L);
+    source.readFully(data, end);
+    skipCrAndOrLf();
+  }
+
+  private String parseEvent(long end) throws IOException {
+    String type = null;
+    end -= skipNameAndDivider(5L);
+    if (end != 0L) {
+      type = source.readUtf8(end);
+    }
+    skipCrAndOrLf();
+    return type;
+  }
+
+  private String parseId(long end) throws IOException {
+    String id;
+    end -= skipNameAndDivider(2L);
+    if (end != 0L) {
+      id = source.readUtf8(end);
+    } else {
+      id = null;
+    }
+    skipCrAndOrLf();
+    return id;
+  }
+
+  private void parseRetry(long end) throws IOException {
+    end -= skipNameAndDivider(5L);
+    String retryString = source.readUtf8(end);
+    long retryMs = -1L;
+    try {
+      retryMs = Long.parseLong(retryString);
+    } catch (NumberFormatException ignored) {
+    }
+    if (retryMs != -1L) {
+      callback.onRetryChange(retryMs);
+    }
+    skipCrAndOrLf();
+  }
+
+  /**
+   * Returns true if the first bytes of {@link #source} are {@code key} followed by a colon or
+   * a newline.
+   */
+  private boolean isKey(ByteString key) throws IOException {
+    if (source.rangeEquals(0, key)) {
+      byte nextByte = source.getBuffer().getByte(key.size());
+      return nextByte == ':'
+          || nextByte == '\r'
+          || nextByte == '\n';
+    }
+    return false;
+  }
+
+  /** Consumes {@code \r}, {@code \r\n}, or {@code \n} from {@link #source}. */
+  private void skipCrAndOrLf() throws IOException {
+    if ((source.readByte() & 0xff) == '\r'
+        && source.request(1)
+        && source.getBuffer().getByte(0) == '\n') {
+      source.skip(1);
+    }
+  }
+
+  /**
+   * Consumes the field name of the specified length and the optional colon and its optional
+   * trailing space. Returns the number of bytes skipped.
+   */
+  private long skipNameAndDivider(long length) throws IOException {
+    source.skip(length);
+
+    if (source.getBuffer().getByte(0) == ':') {
+      source.skip(1L);
+      length++;
+
+      if (source.getBuffer().getByte(0) == ' ') {
+        source.skip(1);
+        length++;
+      }
+    }
+
+    return length;
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java
new file mode 100644
index 0000000000..afcf5f4f9d
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java
@@ -0,0 +1,3 @@
+/** Private support classes for server-sent events. */
+@okhttp3.internal.annotations.EverythingIsNonNull
+package okhttp3.internal.sse;
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java
new file mode 100644
index 0000000000..fe703dc8c0
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.sse;
+
+import okhttp3.Request;
+
+public interface EventSource {
+  /** Returns the original request that initiated this event source. */
+  Request request();
+
+  /**
+   * Immediately and violently release resources held by this event source. This does nothing if
+   * the event source has already been closed or canceled.
+   */
+  void cancel();
+
+  interface Factory {
+    /**
+     * Creates a new event source and immediately returns it. Creating an event source initiates an
+     * asynchronous process to connect the socket. Once that succeeds or fails, {@code listener}
+     * will be notified. The caller must cancel the returned event source when it is no longer
+     * in use.
+     */
+    EventSource newEventSource(Request request, EventSourceListener listener);
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java
new file mode 100644
index 0000000000..4246625eca
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.sse;
+
+import javax.annotation.Nullable;
+import okhttp3.Response;
+
+public abstract class EventSourceListener {
+  /**
+   * Invoked when an event source has been accepted by the remote peer and may begin transmitting
+   * events.
+   */
+  public void onOpen(EventSource eventSource, Response response) {
+  }
+
+  /**
+   * TODO description.
+   */
+  public void onEvent(EventSource eventSource, @Nullable String id, @Nullable String type,
+      String data) {
+  }
+
+  /**
+   * TODO description.
+   * No further calls to this listener will be made.
+   */
+  public void onClosed(EventSource eventSource) {
+  }
+
+  /**
+   * Invoked when an event source has been closed due to an error reading from or writing to the
+   * network. Incoming events may have been lost. No further calls to this listener will be made.
+   */
+  public void onFailure(EventSource eventSource, @Nullable Throwable t,
+      @Nullable Response response) {
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java
new file mode 100644
index 0000000000..db0c818d54
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.sse;
+
+import okhttp3.OkHttpClient;
+import okhttp3.Response;
+import okhttp3.internal.sse.RealEventSource;
+
+public final class EventSources {
+  public static EventSource.Factory createFactory(final OkHttpClient client) {
+    return (request, listener) -> {
+      RealEventSource eventSource = new RealEventSource(request, listener);
+      eventSource.connect(client);
+      return eventSource;
+    };
+  }
+
+  public static void processResponse(Response response, EventSourceListener listener) {
+    RealEventSource eventSource = new RealEventSource(response.request(), listener);
+    eventSource.processResponse(response);
+  }
+
+  private EventSources() {
+    throw new AssertionError();
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/package-info.java b/okhttp-sse/src/main/java/okhttp3/sse/package-info.java
new file mode 100644
index 0000000000..2a5f883883
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/package-info.java
@@ -0,0 +1,3 @@
+/** Support for server-sent events. */
+@okhttp3.internal.annotations.EverythingIsNonNull
+package okhttp3.sse;
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
new file mode 100644
index 0000000000..fade2b978a
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.util.Objects;
+import javax.annotation.Nullable;
+
+final class Event {
+  final @Nullable String id;
+  final @Nullable String type;
+  final String data;
+
+  Event(@Nullable String id, @Nullable String type, String data) {
+    if (data == null) throw new NullPointerException("data == null");
+    this.id = id;
+    this.type = type;
+    this.data = data;
+  }
+
+  @Override public String toString() {
+    return "Event{id='" + id + "', type='" + type + "', data='" + data + "'}";
+  }
+
+  @Override public boolean equals(Object o) {
+    if (this == o) return true;
+    if (!(o instanceof Event)) return false;
+    Event other = (Event) o;
+    return Objects.equals(id, other.id)
+        && Objects.equals(type, other.type)
+        && data.equals(other.data);
+  }
+
+  @Override public int hashCode() {
+    int result = Objects.hashCode(id);
+    result = 31 * result + Objects.hashCode(type);
+    result = 31 * result + data.hashCode();
+    return result;
+  }
+}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
new file mode 100644
index 0000000000..0dbec41be1
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.util.concurrent.TimeUnit;
+import okhttp3.OkHttpClient;
+import okhttp3.OkHttpClientTestRule;
+import okhttp3.Request;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.sse.EventSource;
+import okhttp3.sse.EventSources;
+import org.junit.After;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class EventSourceHttpTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+
+  private final EventSourceRecorder listener = new EventSourceRecorder();
+  private OkHttpClient client = clientTestRule.client;
+
+  @After public void after() {
+    listener.assertExhausted();
+  }
+
+  @Test public void event() {
+    server.enqueue(new MockResponse().setBody(""
+        + "data: hey\n"
+        + "\n").setHeader("content-type", "text/event-stream"));
+
+    EventSource source = newEventSource();
+
+    assertThat(source.request().url().encodedPath()).isEqualTo("/");
+
+    listener.assertOpen();
+    listener.assertEvent(null, null, "hey");
+    listener.assertClose();
+  }
+
+  @Test public void badContentType() {
+    server.enqueue(new MockResponse().setBody(""
+        + "data: hey\n"
+        + "\n").setHeader("content-type", "text/plain"));
+
+    EventSource source = newEventSource();
+    listener.assertFailure("Invalid content-type: text/plain");
+  }
+
+  @Test public void badResponseCode() {
+    server.enqueue(new MockResponse().setBody(""
+        + "data: hey\n"
+        + "\n").setHeader("content-type", "text/event-stream").setResponseCode(401));
+
+    EventSource source = newEventSource();
+    listener.assertFailure(null);
+  }
+
+  @Test public void fullCallTimeoutDoesNotApplyOnceConnected() throws Exception {
+    client = client.newBuilder()
+        .callTimeout(250, TimeUnit.MILLISECONDS)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setBodyDelay(500, TimeUnit.MILLISECONDS)
+        .setHeader("content-type", "text/event-stream")
+        .setBody("data: hey\n\n"));
+
+    EventSource source = newEventSource();
+
+    assertThat(source.request().url().encodedPath()).isEqualTo("/");
+
+    listener.assertOpen();
+    listener.assertEvent(null, null, "hey");
+    listener.assertClose();
+  }
+
+  @Test public void fullCallTimeoutAppliesToSetup() throws Exception {
+    client = client.newBuilder()
+        .callTimeout(250, TimeUnit.MILLISECONDS)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS)
+        .setHeader("content-type", "text/event-stream")
+        .setBody("data: hey\n\n"));
+
+    newEventSource();
+    listener.assertFailure("timeout");
+  }
+
+  private EventSource newEventSource() {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    EventSource.Factory factory = EventSources.createFactory(client);
+    return factory.newEventSource(request, listener);
+  }
+}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
new file mode 100644
index 0000000000..bc87c5a644
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingDeque;
+import javax.annotation.Nullable;
+import okhttp3.Response;
+import okhttp3.internal.platform.Platform;
+import okhttp3.sse.EventSource;
+import okhttp3.sse.EventSourceListener;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class EventSourceRecorder extends EventSourceListener {
+  private final BlockingQueue<Object> events = new LinkedBlockingDeque<>();
+
+  @Override public void onOpen(EventSource eventSource, Response response) {
+    Platform.get().log(Platform.INFO, "[ES] onOpen", null);
+    events.add(new Open(eventSource, response));
+  }
+
+  @Override public void onEvent(EventSource eventSource, @Nullable String id, @Nullable String type,
+      String data) {
+    Platform.get().log(Platform.INFO, "[ES] onEvent", null);
+    events.add(new Event(id, type, data));
+  }
+
+  @Override public void onClosed(EventSource eventSource) {
+    Platform.get().log(Platform.INFO, "[ES] onClosed", null);
+    events.add(new Closed());
+  }
+
+  @Override
+  public void onFailure(EventSource eventSource, @Nullable Throwable t, @Nullable Response response) {
+    Platform.get().log(Platform.INFO, "[ES] onFailure", t);
+    events.add(new Failure(t, response));
+  }
+
+  private Object nextEvent() {
+    try {
+      Object event = events.poll(10, SECONDS);
+      if (event == null) {
+        throw new AssertionError("Timed out waiting for event.");
+      }
+      return event;
+    } catch (InterruptedException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public void assertExhausted() {
+    assertThat(events).isEmpty();
+  }
+
+  public void assertEvent(@Nullable String id, @Nullable String type, String data) {
+    Object actual = nextEvent();
+    assertThat(actual).isEqualTo(new Event(id, type, data));
+  }
+
+  public EventSource assertOpen() {
+    Object event = nextEvent();
+    if (!(event instanceof Open)) {
+      throw new AssertionError("Expected Open but was " + event);
+    }
+    return ((Open) event).eventSource;
+  }
+
+  public void assertClose() {
+    Object event = nextEvent();
+    if (!(event instanceof Closed)) {
+      throw new AssertionError("Expected Open but was " + event);
+    }
+  }
+
+  public void assertFailure(@Nullable String message) {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    if (message != null) {
+      assertThat(((Failure) event).t.getMessage()).isEqualTo(message);
+    } else {
+      assertThat(((Failure) event).t).isNull();
+    }
+  }
+
+  static final class Open {
+    final EventSource eventSource;
+    final Response response;
+
+    Open(EventSource eventSource, Response response) {
+      this.eventSource = eventSource;
+      this.response = response;
+    }
+
+    @Override public String toString() {
+      return "Open[" + response + ']';
+    }
+  }
+
+  static final class Failure {
+    final Throwable t;
+    final Response response;
+    final String responseBody;
+
+    Failure(Throwable t, Response response) {
+      this.t = t;
+      this.response = response;
+      String responseBody = null;
+      if (response != null) {
+        try {
+          responseBody = response.body().string();
+        } catch (IOException ignored) {
+        }
+      }
+      this.responseBody = responseBody;
+    }
+
+    @Override public String toString() {
+      if (response == null) {
+        return "Failure[" + t + "]";
+      }
+      return "Failure[" + response + "]";
+    }
+  }
+
+  static final class Closed {
+    @Override public String toString() {
+      return "Closed[]";
+    }
+  }
+}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
new file mode 100644
index 0000000000..8959e31687
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import javax.annotation.Nullable;
+import okio.Buffer;
+import org.junit.After;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ServerSentEventIteratorTest {
+  /** Either {@link Event} or {@link Long} items for events and retry changes, respectively. */
+  private final Deque<Object> callbacks = new ArrayDeque<>();
+
+  @After public void after() {
+    assertThat(callbacks).isEmpty();
+  }
+
+  @Test public void multiline() throws IOException {
+    consumeEvents(""
+        + "data: YHOO\n"
+        + "data: +2\n"
+        + "data: 10\n"
+        + "\n");
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "YHOO\n+2\n10"));
+  }
+
+  @Test public void multilineCr() throws IOException {
+    consumeEvents(""
+        + "data: YHOO\r"
+        + "data: +2\r"
+        + "data: 10\r"
+        + "\r");
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "YHOO\n+2\n10"));
+  }
+
+  @Test public void multilineCrLf() throws IOException {
+    consumeEvents(""
+        + "data: YHOO\r\n"
+        + "data: +2\r\n"
+        + "data: 10\r\n"
+        + "\r\n");
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "YHOO\n+2\n10"));
+  }
+
+  @Test public void eventType() throws IOException {
+    consumeEvents(""
+        + "event: add\n"
+        + "data: 73857293\n"
+        + "\n"
+        + "event: remove\n"
+        + "data: 2153\n"
+        + "\n"
+        + "event: add\n"
+        + "data: 113411\n"
+        + "\n");
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, "add", "73857293"));
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, "remove", "2153"));
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, "add", "113411"));
+  }
+
+  @Test public void commentsIgnored() throws IOException {
+    consumeEvents(""
+        + ": test stream\n"
+        + "\n"
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n");
+    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
+  }
+
+  @Test public void idCleared() throws IOException {
+    consumeEvents(""
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n"
+        + "data: second event\n"
+        + "id\n"
+        + "\n"
+        + "data: third event\n"
+        + "\n");
+    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "second event"));
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "third event"));
+  }
+
+  @Test public void nakedFieldNames() throws IOException {
+    consumeEvents(""
+        + "data\n"
+        + "\n"
+        + "data\n"
+        + "data\n"
+        + "\n"
+        + "data:\n");
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, ""));
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "\n"));
+  }
+
+  @Test public void colonSpaceOptional() throws IOException {
+    consumeEvents(""
+        + "data:test\n"
+        + "\n"
+        + "data: test\n"
+        + "\n");
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "test"));
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "test"));
+  }
+
+  @Test public void leadingWhitespace() throws IOException {
+    consumeEvents(""
+        + "data:  test\n"
+        + "\n");
+    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, " test"));
+  }
+
+  @Test public void idReusedAcrossEvents() throws IOException {
+    consumeEvents(""
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n"
+        + "data: second event\n"
+        + "\n"
+        + "id: 2\n"
+        + "data: third event\n"
+        + "\n");
+    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
+    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "second event"));
+    assertThat(callbacks.remove()).isEqualTo(new Event("2", null, "third event"));
+  }
+
+  @Test public void idIgnoredFromEmptyEvent() throws IOException {
+    consumeEvents(""
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n"
+        + "id: 2\n"
+        + "\n"
+        + "data: second event\n"
+        + "\n");
+    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
+    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "second event"));
+  }
+
+  @Test public void retry() throws IOException {
+    consumeEvents(""
+        + "retry: 22\n"
+        + "\n"
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n");
+    assertThat(callbacks.remove()).isEqualTo(22L);
+    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
+  }
+
+  @Test public void retryInvalidFormatIgnored() throws IOException {
+    consumeEvents(""
+        + "retry: 22\n"
+        + "\n"
+        + "retry: hey"
+        + "\n");
+    assertThat(callbacks.remove()).isEqualTo(22L);
+  }
+
+  private void consumeEvents(String source) throws IOException {
+    ServerSentEventReader.Callback callback = new ServerSentEventReader.Callback() {
+      @Override public void onEvent(@Nullable String id, @Nullable String type, String data) {
+        callbacks.add(new Event(id, type, data));
+      }
+      @Override public void onRetryChange(long timeMs) {
+        callbacks.add(timeMs);
+      }
+    };
+    Buffer buffer = new Buffer().writeUtf8(source);
+    ServerSentEventReader reader = new ServerSentEventReader(buffer, callback);
+    while (reader.processNextEvent());
+    assertThat(buffer.size()).overridingErrorMessage("Unconsumed buffer: " + buffer.readUtf8())
+        .isEqualTo(0);
+  }
+}
diff --git a/okhttp-testing-support/build.gradle b/okhttp-testing-support/build.gradle
new file mode 100644
index 0000000000..ec110821fe
--- /dev/null
+++ b/okhttp-testing-support/build.gradle
@@ -0,0 +1,6 @@
+dependencies {
+  api project(':okhttp')
+  api deps.junit
+  api deps.assertj
+  compileOnly deps.jsr305
+}
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
deleted file mode 100644
index a52279d9d1..0000000000
--- a/okhttp-testing-support/pom.xml
+++ /dev/null
@@ -1,49 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.11.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-testing-support</artifactId>
-  <name>OkHttp test support classes</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <optional>true</optional>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.testing</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
index e12ea9c622..82cacacbac 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
@@ -18,12 +18,11 @@
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class FakeDns implements Dns {
   private final Map<String, List<InetAddress>> hostAddresses = new LinkedHashMap<>();
@@ -56,7 +55,7 @@ public InetAddress lookup(String hostname, int index) throws UnknownHostExceptio
   }
 
   public void assertRequests(String... expectedHosts) {
-    assertEquals(Arrays.asList(expectedHosts), requestedHosts);
+    assertThat(requestedHosts).containsExactly(expectedHosts);
     requestedHosts.clear();
   }
 
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java b/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
index ab67a9f06e..3851ca3351 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeSSLSession.java
@@ -30,38 +30,47 @@ public FakeSSLSession(Certificate... certificates) throws Exception {
     this.certificates = certificates;
   }
 
+  @Override
   public int getApplicationBufferSize() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public String getCipherSuite() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public long getCreationTime() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public byte[] getId() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public long getLastAccessedTime() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public Certificate[] getLocalCertificates() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public Principal getLocalPrincipal() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public int getPacketBufferSize() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException {
     if (certificates.length == 0) {
       throw new SSLPeerUnverifiedException("peer not authenticated");
@@ -70,50 +79,62 @@ public int getPacketBufferSize() {
     }
   }
 
+  @Override
   public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public String getPeerHost() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public int getPeerPort() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public String getProtocol() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public SSLSessionContext getSessionContext() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public void putValue(String s, Object obj) {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public void removeValue(String s) {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public Object getValue(String s) {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public String[] getValueNames() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public void invalidate() {
     throw new UnsupportedOperationException();
   }
 
+  @Override
   public boolean isValid() {
     throw new UnsupportedOperationException();
   }
diff --git a/okhttp-testing-support/src/main/java/okhttp3/ForwardingRequestBody.java b/okhttp-testing-support/src/main/java/okhttp3/ForwardingRequestBody.java
new file mode 100644
index 0000000000..4aa144c6be
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/ForwardingRequestBody.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+import okio.BufferedSink;
+
+public class ForwardingRequestBody extends RequestBody {
+  private final RequestBody delegate;
+
+  public ForwardingRequestBody(RequestBody delegate) {
+    if (delegate == null) throw new IllegalArgumentException("delegate == null");
+    this.delegate = delegate;
+  }
+
+  public final RequestBody delegate() {
+    return delegate;
+  }
+
+  @Override public @Nullable MediaType contentType() {
+    return delegate.contentType();
+  }
+
+  @Override public long contentLength() throws IOException {
+    return delegate.contentLength();
+  }
+
+  @Override public void writeTo(BufferedSink sink) throws IOException {
+    delegate.writeTo(sink);
+  }
+
+  @Override public boolean isDuplex() {
+    return delegate.isDuplex();
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName() + "(" + delegate.toString() + ")";
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/ForwardingResponseBody.java b/okhttp-testing-support/src/main/java/okhttp3/ForwardingResponseBody.java
new file mode 100644
index 0000000000..2cc067ac0c
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/ForwardingResponseBody.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import javax.annotation.Nullable;
+import okio.BufferedSource;
+
+public class ForwardingResponseBody extends ResponseBody {
+  private final ResponseBody delegate;
+
+  public ForwardingResponseBody(ResponseBody delegate) {
+    if (delegate == null) throw new IllegalArgumentException("delegate == null");
+    this.delegate = delegate;
+  }
+
+  public final ResponseBody delegate() {
+    return delegate;
+  }
+
+  @Override public @Nullable MediaType contentType() {
+    return delegate.contentType();
+  }
+
+  @Override public long contentLength() {
+    return delegate.contentLength();
+  }
+
+  @Override public BufferedSource source() {
+    return delegate.source();
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName() + "(" + delegate.toString() + ")";
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.java b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.java
new file mode 100644
index 0000000000..41dacf9b13
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/OkHttpClientTestRule.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import static okhttp3.TestUtil.defaultClient;
+
+public class OkHttpClientTestRule implements TestRule {
+  public OkHttpClient client = defaultClient();
+
+  @Override
+  public Statement apply(Statement base, Description description) {
+    return statement(base);
+  }
+
+  private Statement statement(final Statement base) {
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        try {
+          base.evaluate();
+        } finally {
+          TestUtil.ensureAllConnectionsReleased(client);
+        }
+      }
+    };
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
index bd4f9be142..eb9e46d9e4 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/RecordingCookieJar.java
@@ -17,19 +17,19 @@
 
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Deque;
 import java.util.List;
 
-import static org.junit.Assert.assertEquals;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class RecordingCookieJar implements CookieJar {
   private final Deque<List<Cookie>> requestCookies = new ArrayDeque<>();
   private final Deque<List<Cookie>> responseCookies = new ArrayDeque<>();
 
   public void enqueueRequestCookies(Cookie... cookies) {
-    requestCookies.add(Arrays.asList(cookies));
+    requestCookies.add(asList(cookies));
   }
 
   public List<Cookie> takeResponseCookies() {
@@ -42,7 +42,7 @@ public void assertResponseCookies(String... cookies) {
     for (Cookie cookie : actualCookies) {
       actualCookieStrings.add(cookie.toString());
     }
-    assertEquals(Arrays.asList(cookies), actualCookieStrings);
+    assertThat(actualCookieStrings).containsExactly(cookies);
   }
 
   @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
diff --git a/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java b/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
index 568b7c518c..0b883ee027 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/RecordingHostnameVerifier.java
@@ -23,6 +23,7 @@
 public final class RecordingHostnameVerifier implements HostnameVerifier {
   public final List<String> calls = new ArrayList<>();
 
+  @Override
   public boolean verify(String hostname, SSLSession session) {
     calls.add("verify " + hostname);
     return true;
diff --git a/okhttp-tests/src/test/java/okhttp3/TestUtil.java b/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
similarity index 56%
rename from okhttp-tests/src/test/java/okhttp3/TestUtil.java
rename to okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
index fa7435ffc3..f3038c090a 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestUtil.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/TestUtil.java
@@ -1,16 +1,43 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package okhttp3;
 
+import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
-import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.http2.Header;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 public final class TestUtil {
   public static final InetSocketAddress UNREACHABLE_ADDRESS
       = new InetSocketAddress("198.51.100.1", 8080);
 
+  /**
+   * A network that resolves only one IP address per host. Use this when testing route selection
+   * fallbacks to prevent the host machine's various IP addresses from interfering.
+   */
+  private static final Dns SINGLE_INET_ADDRESS_DNS = hostname -> {
+    List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
+    return Collections.singletonList(addresses.get(0));
+  };
+
   private TestUtil() {
   }
 
@@ -30,7 +57,7 @@ public static OkHttpClient defaultClient() {
     return new OkHttpClient.Builder()
         .connectionPool(connectionPool)
         .dispatcher(dispatcher)
-        .dns(new SingleInetAddressDns()) // Prevent unexpected fallback addresses.
+        .dns(SINGLE_INET_ADDRESS_DNS) // Prevent unexpected fallback addresses.
         .build();
   }
 
@@ -53,9 +80,14 @@ public static String repeat(char c, int count) {
    * https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
    * java/lang/ref/FinalizationTester.java
    */
-  public static void awaitGarbageCollection() throws InterruptedException {
+  public static void awaitGarbageCollection() throws Exception {
     Runtime.getRuntime().gc();
     Thread.sleep(100);
     System.runFinalization();
   }
+
+  public static void ensureAllConnectionsReleased(OkHttpClient client) {
+    client.connectionPool().evictAll();
+    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(0);
+  }
 }
diff --git a/okhttp-testing-support/src/main/java/okhttp3/UppercaseRequestInterceptor.java b/okhttp-testing-support/src/main/java/okhttp3/UppercaseRequestInterceptor.java
new file mode 100644
index 0000000000..490c266116
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/UppercaseRequestInterceptor.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+import okio.ForwardingSink;
+import okio.Okio;
+import okio.Sink;
+
+/** Rewrites the request body sent to the server to be all uppercase. */
+public final class UppercaseRequestInterceptor implements Interceptor {
+  @Override public Response intercept(Chain chain) throws IOException {
+    return chain.proceed(uppercaseRequest(chain.request()));
+  }
+
+  /** Returns a request that transforms {@code request} to be all uppercase. */
+  private Request uppercaseRequest(Request request) {
+    RequestBody uppercaseBody = new ForwardingRequestBody(request.body()) {
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        delegate().writeTo(Okio.buffer(uppercaseSink(sink)));
+      }
+    };
+    return request.newBuilder()
+        .method(request.method(), uppercaseBody)
+        .build();
+  }
+
+  private Sink uppercaseSink(Sink sink) {
+    return new ForwardingSink(sink) {
+      @Override public void write(Buffer source, long byteCount) throws IOException {
+        ByteString bytes = source.readByteString(byteCount);
+        delegate().write(new Buffer().write(bytes.toAsciiUppercase()), byteCount);
+      }
+    };
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/UppercaseResponseInterceptor.java b/okhttp-testing-support/src/main/java/okhttp3/UppercaseResponseInterceptor.java
new file mode 100644
index 0000000000..7fbf8ef479
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/UppercaseResponseInterceptor.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
+
+/** Rewrites the response body returned from the server to be all uppercase. */
+public final class UppercaseResponseInterceptor implements Interceptor {
+  @Override public Response intercept(Chain chain) throws IOException {
+    return uppercaseResponse(chain.proceed(chain.request()));
+  }
+
+  private Response uppercaseResponse(Response response) {
+    ResponseBody uppercaseBody = new ForwardingResponseBody(response.body()) {
+      @Override public BufferedSource source() {
+        return Okio.buffer(uppercaseSource(delegate().source()));
+      }
+    };
+    return response.newBuilder()
+        .body(uppercaseBody)
+        .build();
+  }
+
+  private ForwardingSource uppercaseSource(BufferedSource source) {
+    return new ForwardingSource(source) {
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        Buffer buffer = new Buffer();
+        long read = delegate().read(buffer, byteCount);
+        if (read != -1L) sink.write(buffer.readByteString().toAsciiUppercase());
+        return read;
+      }
+    };
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/internal/duplex/AsyncRequestBody.java b/okhttp-testing-support/src/main/java/okhttp3/internal/duplex/AsyncRequestBody.java
new file mode 100644
index 0000000000..a6b554adcb
--- /dev/null
+++ b/okhttp-testing-support/src/main/java/okhttp3/internal/duplex/AsyncRequestBody.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.duplex;
+
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okio.BufferedSink;
+
+import static junit.framework.TestCase.assertTrue;
+
+/** A duplex request body that keeps the provided sinks so they can be written to later. */
+public final class AsyncRequestBody extends RequestBody {
+  private final BlockingQueue<BufferedSink> requestBodySinks = new LinkedBlockingQueue<>();
+
+  @Override public @Nullable MediaType contentType() {
+    return null;
+  }
+
+  @Override public void writeTo(BufferedSink sink) {
+    requestBodySinks.add(sink);
+  }
+
+  @Override public boolean isDuplex() {
+    return true;
+  }
+
+  public BufferedSink takeSink() throws InterruptedException {
+    BufferedSink result = requestBodySinks.poll(5, TimeUnit.SECONDS);
+    if (result == null) throw new AssertionError("no sink to take");
+    return result;
+  }
+
+  public void assertNoMoreSinks() {
+    assertTrue(requestBodySinks.isEmpty());
+  }
+}
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
index ae034cd9a6..c1768dcd4b 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
@@ -38,24 +38,22 @@
   @Override public void testRunStarted(Description description) {
     System.err.println("Installing aggressive uncaught exception handler");
     oldDefaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
-    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
-      @Override public void uncaughtException(Thread thread, Throwable throwable) {
-        StringWriter errorText = new StringWriter(256);
-        errorText.append("Uncaught exception in OkHttp thread \"");
-        errorText.append(thread.getName());
-        errorText.append("\"\n");
-        throwable.printStackTrace(new PrintWriter(errorText));
+    Thread.setDefaultUncaughtExceptionHandler((thread, throwable) -> {
+      StringWriter errorText = new StringWriter(256);
+      errorText.append("Uncaught exception in OkHttp thread \"");
+      errorText.append(thread.getName());
+      errorText.append("\"\n");
+      throwable.printStackTrace(new PrintWriter(errorText));
+      errorText.append("\n");
+      if (lastTestStarted != null) {
+        errorText.append("Last test to start was: ");
+        errorText.append(lastTestStarted.getDisplayName());
         errorText.append("\n");
-        if (lastTestStarted != null) {
-          errorText.append("Last test to start was: ");
-          errorText.append(lastTestStarted.getDisplayName());
-          errorText.append("\n");
-        }
-        System.err.print(errorText.toString());
+      }
+      System.err.print(errorText.toString());
 
-        synchronized (exceptions) {
-          exceptions.put(throwable, lastTestStarted.getDisplayName());
-        }
+      synchronized (exceptions) {
+        exceptions.put(throwable, lastTestStarted.getDisplayName());
       }
     });
   }
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
deleted file mode 100644
index 4247ce14d5..0000000000
--- a/okhttp-tests/pom.xml
+++ /dev/null
@@ -1,96 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.11.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-tests</artifactId>
-  <name>OkHttp Tests</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okio</groupId>
-      <artifactId>okio</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-urlconnection</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>org.conscrypt</groupId>
-      <artifactId>conscrypt-openjdk-uber</artifactId>
-      <version>1.0.1</version>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <version>3.1.0</version>
-        <configuration>
-          <descriptorRefs>
-            <descriptorRef>jar-with-dependencies</descriptorRef>
-          </descriptorRefs>
-          <archive>
-            <manifest>
-              <mainClass>okhttp3.AutobahnTester</mainClass>
-            </manifest>
-          </archive>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>single</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <!-- Do not deploy this as an artifact to Maven central. -->
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-deploy-plugin</artifactId>
-        <version>2.7</version>
-        <configuration>
-          <skip>true</skip>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java b/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
deleted file mode 100644
index 356f96ab46..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.concurrent.TimeUnit;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class CacheControlTest {
-  @Test public void emptyBuilderIsEmpty() throws Exception {
-    CacheControl cacheControl = new CacheControl.Builder().build();
-    assertEquals("", cacheControl.toString());
-    assertFalse(cacheControl.noCache());
-    assertFalse(cacheControl.noStore());
-    assertEquals(-1, cacheControl.maxAgeSeconds());
-    assertEquals(-1, cacheControl.sMaxAgeSeconds());
-    assertFalse(cacheControl.isPrivate());
-    assertFalse(cacheControl.isPublic());
-    assertFalse(cacheControl.mustRevalidate());
-    assertEquals(-1, cacheControl.maxStaleSeconds());
-    assertEquals(-1, cacheControl.minFreshSeconds());
-    assertFalse(cacheControl.onlyIfCached());
-    assertFalse(cacheControl.mustRevalidate());
-  }
-
-  @Test public void completeBuilder() throws Exception {
-    CacheControl cacheControl = new CacheControl.Builder()
-        .noCache()
-        .noStore()
-        .maxAge(1, TimeUnit.SECONDS)
-        .maxStale(2, TimeUnit.SECONDS)
-        .minFresh(3, TimeUnit.SECONDS)
-        .onlyIfCached()
-        .noTransform()
-        .immutable()
-        .build();
-    assertEquals("no-cache, no-store, max-age=1, max-stale=2, min-fresh=3, only-if-cached, "
-        + "no-transform, immutable", cacheControl.toString());
-    assertTrue(cacheControl.noCache());
-    assertTrue(cacheControl.noStore());
-    assertEquals(1, cacheControl.maxAgeSeconds());
-    assertEquals(2, cacheControl.maxStaleSeconds());
-    assertEquals(3, cacheControl.minFreshSeconds());
-    assertTrue(cacheControl.onlyIfCached());
-    assertTrue(cacheControl.noTransform());
-    assertTrue(cacheControl.immutable());
-
-    // These members are accessible to response headers only.
-    assertEquals(-1, cacheControl.sMaxAgeSeconds());
-    assertFalse(cacheControl.isPrivate());
-    assertFalse(cacheControl.isPublic());
-    assertFalse(cacheControl.mustRevalidate());
-  }
-
-  @Test public void parseEmpty() throws Exception {
-    CacheControl cacheControl = CacheControl.parse(
-        new Headers.Builder().set("Cache-Control", "").build());
-    assertEquals("", cacheControl.toString());
-    assertFalse(cacheControl.noCache());
-    assertFalse(cacheControl.noStore());
-    assertEquals(-1, cacheControl.maxAgeSeconds());
-    assertEquals(-1, cacheControl.sMaxAgeSeconds());
-    assertFalse(cacheControl.isPublic());
-    assertFalse(cacheControl.mustRevalidate());
-    assertEquals(-1, cacheControl.maxStaleSeconds());
-    assertEquals(-1, cacheControl.minFreshSeconds());
-    assertFalse(cacheControl.onlyIfCached());
-    assertFalse(cacheControl.mustRevalidate());
-  }
-
-  @Test public void parse() throws Exception {
-    String header = "no-cache, no-store, max-age=1, s-maxage=2, private, public, must-revalidate, "
-        + "max-stale=3, min-fresh=4, only-if-cached, no-transform";
-    CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
-        .set("Cache-Control", header)
-        .build());
-    assertTrue(cacheControl.noCache());
-    assertTrue(cacheControl.noStore());
-    assertEquals(1, cacheControl.maxAgeSeconds());
-    assertEquals(2, cacheControl.sMaxAgeSeconds());
-    assertTrue(cacheControl.isPrivate());
-    assertTrue(cacheControl.isPublic());
-    assertTrue(cacheControl.mustRevalidate());
-    assertEquals(3, cacheControl.maxStaleSeconds());
-    assertEquals(4, cacheControl.minFreshSeconds());
-    assertTrue(cacheControl.onlyIfCached());
-    assertTrue(cacheControl.noTransform());
-    assertEquals(header, cacheControl.toString());
-  }
-
-  @Test public void parseIgnoreCacheControlExtensions() throws Exception {
-    // Example from http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.6
-    String header = "private, community=\"UCI\"";
-    CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
-        .set("Cache-Control", header)
-        .build());
-    assertFalse(cacheControl.noCache());
-    assertFalse(cacheControl.noStore());
-    assertEquals(-1, cacheControl.maxAgeSeconds());
-    assertEquals(-1, cacheControl.sMaxAgeSeconds());
-    assertTrue(cacheControl.isPrivate());
-    assertFalse(cacheControl.isPublic());
-    assertFalse(cacheControl.mustRevalidate());
-    assertEquals(-1, cacheControl.maxStaleSeconds());
-    assertEquals(-1, cacheControl.minFreshSeconds());
-    assertFalse(cacheControl.onlyIfCached());
-    assertFalse(cacheControl.noTransform());
-    assertFalse(cacheControl.immutable());
-    assertEquals(header, cacheControl.toString());
-  }
-
-  @Test public void parseCacheControlAndPragmaAreCombined() {
-    Headers headers =
-        Headers.of("Cache-Control", "max-age=12", "Pragma", "must-revalidate", "Pragma", "public");
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertEquals("max-age=12, public, must-revalidate", cacheControl.toString());
-  }
-
-  @SuppressWarnings("RedundantStringConstructorCall") // Testing instance equality.
-  @Test public void parseCacheControlHeaderValueIsRetained() {
-    String value = new String("max-age=12");
-    Headers headers = Headers.of("Cache-Control", value);
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertSame(value, cacheControl.toString());
-  }
-
-  @Test public void parseCacheControlHeaderValueInvalidatedByPragma() {
-    Headers headers = Headers.of("Cache-Control", "max-age=12", "Pragma", "must-revalidate");
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertNull(cacheControl.headerValue);
-  }
-
-  @Test public void parseCacheControlHeaderValueInvalidatedByTwoValues() {
-    Headers headers = Headers.of("Cache-Control", "max-age=12", "Cache-Control", "must-revalidate");
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertNull(cacheControl.headerValue);
-  }
-
-  @Test public void parsePragmaHeaderValueIsNotRetained() {
-    Headers headers = Headers.of("Pragma", "must-revalidate");
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertNull(cacheControl.headerValue);
-  }
-
-  @Test public void computedHeaderValueIsCached() {
-    CacheControl cacheControl = new CacheControl.Builder()
-        .maxAge(2, TimeUnit.DAYS)
-        .build();
-    assertNull(cacheControl.headerValue);
-    assertEquals("max-age=172800", cacheControl.toString());
-    assertEquals("max-age=172800", cacheControl.headerValue);
-    cacheControl.headerValue = "Hi";
-    assertEquals("Hi", cacheControl.toString());
-  }
-
-  @Test public void timeDurationTruncatedToMaxValue() throws Exception {
-    CacheControl cacheControl = new CacheControl.Builder()
-        .maxAge(365 * 100, TimeUnit.DAYS) // Longer than Integer.MAX_VALUE seconds.
-        .build();
-    assertEquals(Integer.MAX_VALUE, cacheControl.maxAgeSeconds());
-  }
-
-  @Test public void secondsMustBeNonNegative() throws Exception {
-    CacheControl.Builder builder = new CacheControl.Builder();
-    try {
-      builder.maxAge(-1, TimeUnit.SECONDS);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void timePrecisionIsTruncatedToSeconds() throws Exception {
-    CacheControl cacheControl = new CacheControl.Builder()
-        .maxAge(4999, TimeUnit.MILLISECONDS)
-        .build();
-    assertEquals(4, cacheControl.maxAgeSeconds());
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
deleted file mode 100644
index 4de1f37f52..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
+++ /dev/null
@@ -1,306 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.security.GeneralSecurityException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import okhttp3.CertificatePinner.Pin;
-import okhttp3.mockwebserver.internal.tls.HeldCertificate;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class CertificatePinnerTest {
-  static HeldCertificate certA1;
-  static String certA1Sha256Pin;
-
-  static HeldCertificate certB1;
-  static String certB1Sha256Pin;
-
-  static HeldCertificate certC1;
-  static String certC1Sha256Pin;
-
-  static {
-    try {
-      certA1 = new HeldCertificate.Builder()
-          .serialNumber("100")
-          .build();
-      certA1Sha256Pin = "sha256/" + CertificatePinner.sha256(certA1.certificate).base64();
-
-      certB1 = new HeldCertificate.Builder()
-          .serialNumber("200")
-          .build();
-      certB1Sha256Pin = "sha256/" + CertificatePinner.sha256(certB1.certificate).base64();
-
-      certC1 = new HeldCertificate.Builder()
-          .serialNumber("300")
-          .build();
-      certC1Sha256Pin = "sha256/" + CertificatePinner.sha256(certC1.certificate).base64();
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  @Test public void malformedPin() throws Exception {
-    CertificatePinner.Builder builder = new CertificatePinner.Builder();
-    try {
-      builder.add("example.com", "md5/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void malformedBase64() throws Exception {
-    CertificatePinner.Builder builder = new CertificatePinner.Builder();
-    try {
-      builder.add("example.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw*");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  /** Multiple certificates generated from the same keypair have the same pin. */
-  @Test public void sameKeypairSamePin() throws Exception {
-    HeldCertificate heldCertificateA2 = new HeldCertificate.Builder()
-        .keyPair(certA1.keyPair)
-        .serialNumber("101")
-        .build();
-    String keypairACertificate2Pin = CertificatePinner.pin(heldCertificateA2.certificate);
-
-    HeldCertificate heldCertificateB2 = new HeldCertificate.Builder()
-        .keyPair(certB1.keyPair)
-        .serialNumber("201")
-        .build();
-    String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate);
-
-    assertTrue(certA1Sha256Pin.equals(keypairACertificate2Pin));
-    assertTrue(certB1Sha256Pin.equals(keypairBCertificate2Pin));
-    assertFalse(certA1Sha256Pin.equals(certB1Sha256Pin));
-  }
-
-  @Test public void successfulCheck() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Sha256Pin)
-        .build();
-
-    certificatePinner.check("example.com", certA1.certificate);
-  }
-
-  @Test public void successfulCheckSha1Pin() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate).base64())
-        .build();
-
-    certificatePinner.check("example.com", certA1.certificate);
-  }
-
-  @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certB1Sha256Pin)
-        .build();
-
-    certificatePinner.check("example.com", certA1.certificate, certB1.certificate);
-  }
-
-  @Test public void unsuccessfulCheck() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Sha256Pin)
-        .build();
-
-    try {
-      certificatePinner.check("example.com", certB1.certificate);
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void multipleCertificatesForOneHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Sha256Pin, certB1Sha256Pin)
-        .build();
-
-    certificatePinner.check("example.com", certA1.certificate);
-    certificatePinner.check("example.com", certB1.certificate);
-  }
-
-  @Test public void multipleHostnamesForOneCertificate() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Sha256Pin)
-        .add("www.example.com", certA1Sha256Pin)
-        .build();
-
-    certificatePinner.check("example.com", certA1.certificate);
-    certificatePinner.check("www.example.com", certA1.certificate);
-  }
-
-  @Test public void absentHostnameMatches() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder().build();
-    certificatePinner.check("example.com", certA1.certificate);
-  }
-
-  @Test public void successfulCheckForWildcardHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .build();
-
-    certificatePinner.check("a.example.com", certA1.certificate);
-  }
-
-  @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname()
-      throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certB1Sha256Pin)
-        .build();
-
-    certificatePinner.check("a.example.com", certA1.certificate, certB1.certificate);
-  }
-
-  @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .build();
-
-    try {
-      certificatePinner.check("a.example.com", certB1.certificate);
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void multipleCertificatesForOneWildcardHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin, certB1Sha256Pin)
-        .build();
-
-    certificatePinner.check("a.example.com", certA1.certificate);
-    certificatePinner.check("a.example.com", certB1.certificate);
-  }
-
-  @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate()
-      throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .add("a.example.com", certB1Sha256Pin)
-        .build();
-
-    certificatePinner.check("a.example.com", certA1.certificate);
-    certificatePinner.check("a.example.com", certB1.certificate);
-  }
-
-  @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate()
-      throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .add("a.example.com", certB1Sha256Pin)
-        .build();
-
-    try {
-      certificatePinner.check("a.example.com", certC1.certificate);
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void successfulFindMatchingPins() {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("first.com", certA1Sha256Pin, certB1Sha256Pin)
-        .add("second.com", certC1Sha256Pin)
-        .build();
-
-    List<Pin> expectedPins = Arrays.asList(
-        new Pin("first.com", certA1Sha256Pin),
-        new Pin("first.com", certB1Sha256Pin));
-    assertEquals(expectedPins, certificatePinner.findMatchingPins("first.com"));
-  }
-
-  @Test public void successfulFindMatchingPinsForWildcardAndDirectCertificates() {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .add("a.example.com", certB1Sha256Pin)
-        .add("b.example.com", certC1Sha256Pin)
-        .build();
-
-    List<Pin> expectedPins = Arrays.asList(
-        new Pin("*.example.com", certA1Sha256Pin),
-        new Pin("a.example.com", certB1Sha256Pin));
-    assertEquals(expectedPins, certificatePinner.findMatchingPins("a.example.com"));
-  }
-
-  @Test public void wildcardHostnameShouldNotMatchThroughDot() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .build();
-
-    assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("example.com"));
-    assertEquals(Collections.emptyList(), certificatePinner.findMatchingPins("a.b.example.com"));
-  }
-
-  @Test public void successfulFindMatchingPinsIgnoresCase() {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("EXAMPLE.com", certA1Sha256Pin)
-        .add("*.MyExample.Com", certB1Sha256Pin)
-        .build();
-
-    List<Pin> expectedPin1 = Arrays.asList(new Pin("EXAMPLE.com", certA1Sha256Pin));
-    assertEquals(expectedPin1, certificatePinner.findMatchingPins("example.com"));
-
-    List<Pin> expectedPin2 = Arrays.asList(new Pin("*.MyExample.Com", certB1Sha256Pin));
-    assertEquals(expectedPin2, certificatePinner.findMatchingPins("a.myexample.com"));
-  }
-
-  @Test public void successfulFindMatchingPinPunycode() {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("œÉkhttp.com", certA1Sha256Pin)
-        .build();
-
-    List<Pin> expectedPin = Arrays.asList(new Pin("œÉkhttp.com", certA1Sha256Pin));
-    assertEquals(expectedPin, certificatePinner.findMatchingPins("xn--khttp-fde.com"));
-  }
-
-  /** https://github.com/square/okhttp/issues/3324 */
-  @Test public void checkSubstringMatch() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .build();
-
-    assertEquals(Collections.emptyList(),
-        certificatePinner.findMatchingPins("a.example.com.notexample.com"));
-    assertEquals(Collections.emptyList(),
-        certificatePinner.findMatchingPins("example.com.notexample.com"));
-    assertEquals(Collections.emptyList(),
-        certificatePinner.findMatchingPins("notexample.com"));
-    assertEquals(Collections.emptyList(),
-        certificatePinner.findMatchingPins("example.com"));
-    assertEquals(Collections.emptyList(),
-        certificatePinner.findMatchingPins("a.b.example.com"));
-    assertEquals(Collections.emptyList(),
-        certificatePinner.findMatchingPins("ple.com"));
-    assertEquals(Collections.emptyList(),
-        certificatePinner.findMatchingPins("com"));
-
-    Pin expectedPin = new Pin("*.example.com", certA1Sha256Pin);
-    assertEquals(Collections.singletonList(expectedPin),
-        certificatePinner.findMatchingPins("a.example.com"));
-    assertEquals(Collections.singletonList(expectedPin),
-        certificatePinner.findMatchingPins("example.example.com"));
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
deleted file mode 100644
index ae8b0a2f6c..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.Socket;
-import java.util.Collections;
-import java.util.concurrent.TimeUnit;
-import javax.net.SocketFactory;
-import okhttp3.internal.Internal;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.connection.StreamAllocation;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.awaitGarbageCollection;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-public final class ConnectionPoolTest {
-  private final Address addressA = newAddress("a");
-  private final Route routeA1 = newRoute(addressA);
-  private final Address addressB = newAddress("b");
-  private final Route routeB1 = newRoute(addressB);
-  private final Address addressC = newAddress("c");
-  private final Route routeC1 = newRoute(addressC);
-
-  static {
-    Internal.initializeInstanceForTests();
-  }
-
-  @Test public void connectionsEvictedWhenIdleLongEnough() throws Exception {
-    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
-
-    RealConnection c1 = newConnection(pool, routeA1, 50L);
-
-    // Running at time 50, the pool returns that nothing can be evicted until time 150.
-    assertEquals(100L, pool.cleanup(50L));
-    assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket().isClosed());
-
-    // Running at time 60, the pool returns that nothing can be evicted until time 150.
-    assertEquals(90L, pool.cleanup(60L));
-    assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket().isClosed());
-
-    // Running at time 149, the pool returns that nothing can be evicted until time 150.
-    assertEquals(1L, pool.cleanup(149L));
-    assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket().isClosed());
-
-    // Running at time 150, the pool evicts.
-    assertEquals(0, pool.cleanup(150L));
-    assertEquals(0, pool.connectionCount());
-    assertTrue(c1.socket().isClosed());
-
-    // Running again, the pool reports that no further runs are necessary.
-    assertEquals(-1, pool.cleanup(150L));
-    assertEquals(0, pool.connectionCount());
-    assertTrue(c1.socket().isClosed());
-  }
-
-  @Test public void inUseConnectionsNotEvicted() throws Exception {
-    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
-
-    RealConnection c1 = newConnection(pool, routeA1, 50L);
-    synchronized (pool) {
-      StreamAllocation streamAllocation = new StreamAllocation(pool, addressA, null,
-          EventListener.NONE, null);
-      streamAllocation.acquire(c1, true);
-    }
-
-    // Running at time 50, the pool returns that nothing can be evicted until time 150.
-    assertEquals(100L, pool.cleanup(50L));
-    assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket().isClosed());
-
-    // Running at time 60, the pool returns that nothing can be evicted until time 160.
-    assertEquals(100L, pool.cleanup(60L));
-    assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket().isClosed());
-
-    // Running at time 160, the pool returns that nothing can be evicted until time 260.
-    assertEquals(100L, pool.cleanup(160L));
-    assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket().isClosed());
-  }
-
-  @Test public void cleanupPrioritizesEarliestEviction() throws Exception {
-    ConnectionPool pool = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
-
-    RealConnection c1 = newConnection(pool, routeA1, 75L);
-    RealConnection c2 = newConnection(pool, routeB1, 50L);
-
-    // Running at time 75, the pool returns that nothing can be evicted until time 150.
-    assertEquals(75L, pool.cleanup(75L));
-    assertEquals(2, pool.connectionCount());
-
-    // Running at time 149, the pool returns that nothing can be evicted until time 150.
-    assertEquals(1L, pool.cleanup(149L));
-    assertEquals(2, pool.connectionCount());
-
-    // Running at time 150, the pool evicts c2.
-    assertEquals(0L, pool.cleanup(150L));
-    assertEquals(1, pool.connectionCount());
-    assertFalse(c1.socket().isClosed());
-    assertTrue(c2.socket().isClosed());
-
-    // Running at time 150, the pool returns that nothing can be evicted until time 175.
-    assertEquals(25L, pool.cleanup(150L));
-    assertEquals(1, pool.connectionCount());
-
-    // Running at time 175, the pool evicts c1.
-    assertEquals(0L, pool.cleanup(175L));
-    assertEquals(0, pool.connectionCount());
-    assertTrue(c1.socket().isClosed());
-    assertTrue(c2.socket().isClosed());
-  }
-
-  @Test public void oldestConnectionsEvictedIfIdleLimitExceeded() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
-    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
-
-    RealConnection c1 = newConnection(pool, routeA1, 50L);
-    RealConnection c2 = newConnection(pool, routeB1, 75L);
-
-    // With 2 connections, there's no need to evict until the connections time out.
-    assertEquals(50L, pool.cleanup(100L));
-    assertEquals(2, pool.connectionCount());
-    assertFalse(c1.socket().isClosed());
-    assertFalse(c2.socket().isClosed());
-
-    // Add a third connection
-    RealConnection c3 = newConnection(pool, routeC1, 75L);
-
-    // The third connection bounces the first.
-    assertEquals(0L, pool.cleanup(100L));
-    assertEquals(2, pool.connectionCount());
-    assertTrue(c1.socket().isClosed());
-    assertFalse(c2.socket().isClosed());
-    assertFalse(c3.socket().isClosed());
-  }
-
-  @Test public void leakedAllocation() throws Exception {
-    ConnectionPool pool = new ConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
-    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
-
-    RealConnection c1 = newConnection(pool, routeA1, 0L);
-    allocateAndLeakAllocation(pool, c1);
-
-    awaitGarbageCollection();
-    assertEquals(0L, pool.cleanup(100L));
-    assertEquals(Collections.emptyList(), c1.allocations);
-
-    assertTrue(c1.noNewStreams); // Can't allocate once a leak has been detected.
-  }
-
-  /** Use a helper method so there's no hidden reference remaining on the stack. */
-  private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
-    synchronized (pool) {
-      StreamAllocation leak = new StreamAllocation(pool, connection.route().address(), null,
-          EventListener.NONE, null);
-      leak.acquire(connection, true);
-    }
-  }
-
-  private RealConnection newConnection(ConnectionPool pool, Route route, long idleAtNanos) {
-    RealConnection result = RealConnection.testConnection(pool, route, new Socket(), idleAtNanos);
-    synchronized (pool) {
-      pool.put(result);
-    }
-    return result;
-  }
-
-  private Address newAddress(String name) {
-    return new Address(name, 1, Dns.SYSTEM, SocketFactory.getDefault(), null, null, null,
-        new RecordingOkAuthenticator("password"), null, Collections.<Protocol>emptyList(),
-        Collections.<ConnectionSpec>emptyList(),
-        ProxySelector.getDefault());
-  }
-
-  private Route newRoute(Address address) {
-    return new Route(address, Proxy.NO_PROXY,
-        InetSocketAddress.createUnresolved(address.url().host(), address.url().port()));
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/CookieTest.java b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
deleted file mode 100644
index 12f543fac0..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/CookieTest.java
+++ /dev/null
@@ -1,579 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-import java.util.Objects;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpDate;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class CookieTest {
-  HttpUrl url = HttpUrl.parse("https://example.com/");
-
-  @Test public void simpleCookie() throws Exception {
-    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42");
-    assertEquals("SID=31d4d96e407aad42; path=/", cookie.toString());
-  }
-
-  @Test public void noEqualsSign() throws Exception {
-    assertNull(Cookie.parse(url, "foo"));
-    assertNull(Cookie.parse(url, "foo; Path=/"));
-  }
-
-  @Test public void emptyName() throws Exception {
-    assertNull(Cookie.parse(url, "=b"));
-    assertNull(Cookie.parse(url, " =b"));
-    assertNull(Cookie.parse(url, "\r\t \n=b"));
-  }
-
-  @Test public void spaceInName() throws Exception {
-    assertEquals("a b", Cookie.parse(url, "a b=cd").name());
-  }
-
-  @Test public void spaceInValue() throws Exception {
-    assertEquals("c d", Cookie.parse(url, "ab=c d").value());
-  }
-
-  @Test public void trimLeadingAndTrailingWhitespaceFromName() throws Exception {
-    assertEquals("a", Cookie.parse(url, " a=b").name());
-    assertEquals("a", Cookie.parse(url, "a =b").name());
-    assertEquals("a", Cookie.parse(url, "\r\t \na\n\t \n=b").name());
-  }
-
-  @Test public void emptyValue() throws Exception {
-    assertEquals("", Cookie.parse(url, "a=").value());
-    assertEquals("", Cookie.parse(url, "a= ").value());
-    assertEquals("", Cookie.parse(url, "a=\r\t \n").value());
-  }
-
-  @Test public void trimLeadingAndTrailingWhitespaceFromValue() throws Exception {
-    assertEquals("", Cookie.parse(url, "a= ").value());
-    assertEquals("b", Cookie.parse(url, "a= b").value());
-    assertEquals("b", Cookie.parse(url, "a=b ").value());
-    assertEquals("b", Cookie.parse(url, "a=\r\t \nb\n\t \n").value());
-  }
-
-  @Test public void invalidCharacters() throws Exception {
-    assertEquals(null, Cookie.parse(url, "a\u0000b=cd"));
-    assertEquals(null, Cookie.parse(url, "ab=c\u0000d"));
-    assertEquals(null, Cookie.parse(url, "a\u0001b=cd"));
-    assertEquals(null, Cookie.parse(url, "ab=c\u0001d"));
-    assertEquals(null, Cookie.parse(url, "a\u0009b=cd"));
-    assertEquals(null, Cookie.parse(url, "ab=c\u0009d"));
-    assertEquals(null, Cookie.parse(url, "a\u001fb=cd"));
-    assertEquals(null, Cookie.parse(url, "ab=c\u001fd"));
-    assertEquals(null, Cookie.parse(url, "a\u007fb=cd"));
-    assertEquals(null, Cookie.parse(url, "ab=c\u007fd"));
-    assertEquals(null, Cookie.parse(url, "a\u0080b=cd"));
-    assertEquals(null, Cookie.parse(url, "ab=c\u0080d"));
-    assertEquals(null, Cookie.parse(url, "a\u00ffb=cd"));
-    assertEquals(null, Cookie.parse(url, "ab=c\u00ffd"));
-  }
-
-  @Test public void maxAge() throws Exception {
-    assertEquals(51000L,
-        Cookie.parse(50000L, url, "a=b; Max-Age=1").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854724").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854725").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=9223372036854726").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=1").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=2").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(9223372036854773807L, url, "a=b; Max-Age=3").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=10000000000000000000").expiresAt());
-  }
-
-  @Test public void maxAgeNonPositive() throws Exception {
-    assertEquals(Long.MIN_VALUE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=-1").expiresAt());
-    assertEquals(Long.MIN_VALUE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=0").expiresAt());
-    assertEquals(Long.MIN_VALUE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=-9223372036854775808").expiresAt());
-    assertEquals(Long.MIN_VALUE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=-9223372036854775809").expiresAt());
-    assertEquals(Long.MIN_VALUE,
-        Cookie.parse(50000L, url, "a=b; Max-Age=-10000000000000000000").expiresAt());
-  }
-
-  @Test public void domainAndPath() throws Exception {
-    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Domain=example.com");
-    assertEquals("example.com", cookie.domain());
-    assertEquals("/", cookie.path());
-    assertFalse(cookie.hostOnly());
-    assertEquals("SID=31d4d96e407aad42; domain=example.com; path=/", cookie.toString());
-  }
-
-  @Test public void secureAndHttpOnly() throws Exception {
-    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Secure; HttpOnly");
-    assertTrue(cookie.secure());
-    assertTrue(cookie.httpOnly());
-    assertEquals("SID=31d4d96e407aad42; path=/; secure; httponly", cookie.toString());
-  }
-
-  @Test public void expiresDate() throws Exception {
-    assertEquals(date("1970-01-01T00:00:00.000+0000"), new Date(
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT").expiresAt()));
-    assertEquals(date("2021-06-09T10:18:14.000+0000"), new Date(
-        Cookie.parse(url, "a=b; Expires=Wed, 09 Jun 2021 10:18:14 GMT").expiresAt()));
-    assertEquals(date("1994-11-06T08:49:37.000+0000"), new Date(
-        Cookie.parse(url, "a=b; Expires=Sun, 06 Nov 1994 08:49:37 GMT").expiresAt()));
-  }
-
-  @Test public void awkwardDates() throws Exception {
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 70 00:00:00 GMT").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 January 1970 00:00:00 GMT").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Janucember 1970 00:00:00 GMT").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=Thu, 1 Jan 1970 00:00:00 GMT").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 0:00:00 GMT").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:0:00 GMT").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:0 GMT").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=00:00:00 Thu, 01 Jan 1970 GMT").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 01").expiresAt());
-    assertEquals(0L,
-        Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 1").expiresAt());
-  }
-
-  @Test public void invalidYear() throws Exception {
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1600 00:00:00 GMT").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 19999 00:00:00 GMT").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 00:00:00 GMT").expiresAt());
-  }
-
-  @Test public void invalidMonth() throws Exception {
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Foo 1970 00:00:00 GMT").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Foocember 1970 00:00:00 GMT").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 1970 00:00:00 GMT").expiresAt());
-  }
-
-  @Test public void invalidDayOfMonth() throws Exception {
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 32 Jan 1970 00:00:00 GMT").expiresAt());
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, Jan 1970 00:00:00 GMT").expiresAt());
-  }
-
-  @Test public void invalidHour() throws Exception {
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 24:00:00 GMT").expiresAt());
-  }
-
-  @Test public void invalidMinute() throws Exception {
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:60:00 GMT").expiresAt());
-  }
-
-  @Test public void invalidSecond() throws Exception {
-    assertEquals(HttpDate.MAX_DATE,
-        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:60 GMT").expiresAt());
-  }
-
-  @Test public void domainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com");
-    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
-  }
-
-  /** If no domain is present, match only the origin domain. */
-  @Test public void domainMatchesNoDomain() throws Exception {
-    Cookie cookie = Cookie.parse(url, "a=b");
-    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
-  }
-
-  /** Ignore an optional leading `.` in the domain. */
-  @Test public void domainMatchesIgnoresLeadingDot() throws Exception {
-    Cookie cookie = Cookie.parse(url, "a=b; domain=.example.com");
-    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
-  }
-
-  /** Ignore the entire attribute if the domain ends with `.`. */
-  @Test public void domainIgnoredWithTrailingDot() throws Exception {
-    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com.");
-    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
-  }
-
-  @Test public void idnDomainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.parse("http://‚òÉ.net/"), "a=b; domain=‚òÉ.net");
-    assertTrue(cookie.matches(HttpUrl.parse("http://‚òÉ.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://xn--n3h.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.‚òÉ.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.xn--n3h.net/")));
-  }
-
-  @Test public void punycodeDomainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.parse("http://xn--n3h.net/"), "a=b; domain=xn--n3h.net");
-    assertTrue(cookie.matches(HttpUrl.parse("http://‚òÉ.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://xn--n3h.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.‚òÉ.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.xn--n3h.net/")));
-  }
-
-  @Test public void domainMatchesIpAddress() throws Exception {
-    HttpUrl urlWithIp = HttpUrl.parse("http://123.45.234.56/");
-    assertNull(Cookie.parse(urlWithIp, "a=b; domain=234.56"));
-    assertEquals("123.45.234.56", Cookie.parse(urlWithIp, "a=b; domain=123.45.234.56").domain());
-  }
-
-  @Test public void domainMatchesIpv6Address() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.parse("http://[::1]/"), "a=b; domain=::1");
-    assertEquals("::1", cookie.domain());
-    assertTrue(cookie.matches(HttpUrl.parse("http://[::1]/")));
-  }
-
-  @Test public void domainMatchesIpv6AddressWithCompression() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.parse("http://[0001:0000::]/"), "a=b; domain=0001:0000::");
-    assertEquals("1::", cookie.domain());
-    assertTrue(cookie.matches(HttpUrl.parse("http://[1::]/")));
-  }
-
-  @Test public void domainMatchesIpv6AddressWithIpv4Suffix() throws Exception {
-    Cookie cookie = Cookie.parse(
-        HttpUrl.parse("http://[::1:ffff:ffff]/"), "a=b; domain=::1:255.255.255.255");
-    assertEquals("::1:ffff:ffff", cookie.domain());
-    assertTrue(cookie.matches(HttpUrl.parse("http://[::1:ffff:ffff]/")));
-  }
-
-  @Test public void ipv6AddressDoesntMatch() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.parse("http://[::1]/"), "a=b; domain=::2");
-    assertNull(cookie);
-  }
-
-  @Test public void ipv6AddressMalformed() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.parse("http://[::1]/"), "a=b; domain=::2::2");
-    assertEquals("::1", cookie.domain());
-  }
-
-  /**
-   * These public suffixes were selected by inspecting the publicsuffix.org list. It's possible they
-   * may change in the future. If this test begins to fail, please double check they are still
-   * present in the public suffix list.
-   */
-  @Test public void domainIsPublicSuffix() {
-    HttpUrl ascii = HttpUrl.parse("https://foo1.foo.bar.elb.amazonaws.com");
-    assertNotNull(Cookie.parse(ascii, "a=b; domain=foo.bar.elb.amazonaws.com"));
-    assertNull(Cookie.parse(ascii, "a=b; domain=bar.elb.amazonaws.com"));
-    assertNull(Cookie.parse(ascii, "a=b; domain=com"));
-
-    HttpUrl unicode = HttpUrl.parse("https://Èï∑.Èï∑.Èï∑Â¥é.jp");
-    assertNotNull(Cookie.parse(unicode, "a=b; domain=Èï∑.Èï∑Â¥é.jp"));
-    assertNull(Cookie.parse(unicode, "a=b; domain=Èï∑Â¥é.jp"));
-
-    HttpUrl punycode = HttpUrl.parse("https://xn--ue5a.xn--ue5a.xn--8ltr62k.jp");
-    assertNotNull(Cookie.parse(punycode, "a=b; domain=xn--ue5a.xn--8ltr62k.jp"));
-    assertNull(Cookie.parse(punycode, "a=b; domain=xn--8ltr62k.jp"));
-  }
-
-  @Test public void hostOnly() throws Exception {
-    assertTrue(Cookie.parse(url, "a=b").hostOnly());
-    assertFalse(Cookie.parse(url, "a=b; domain=example.com").hostOnly());
-  }
-
-  @Test public void defaultPath() throws Exception {
-    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"), "a=b").path());
-    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/"), "a=b").path());
-    assertEquals("/", Cookie.parse(HttpUrl.parse("http://example.com/foo"), "a=b").path());
-    assertEquals("/", Cookie.parse(HttpUrl.parse("http://example.com/"), "a=b").path());
-  }
-
-  @Test public void defaultPathIsUsedIfPathDoesntHaveLeadingSlash() throws Exception {
-    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
-        "a=b; path=quux").path());
-    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
-        "a=b; path=").path());
-  }
-
-  @Test public void pathAttributeDoesntNeedToMatch() throws Exception {
-    assertEquals("/quux", Cookie.parse(HttpUrl.parse("http://example.com/"),
-        "a=b; path=/quux").path());
-    assertEquals("/quux", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
-        "a=b; path=/quux").path());
-  }
-
-  @Test public void httpOnly() throws Exception {
-    assertFalse(Cookie.parse(url, "a=b").httpOnly());
-    assertTrue(Cookie.parse(url, "a=b; HttpOnly").httpOnly());
-  }
-
-  @Test public void secure() throws Exception {
-    assertFalse(Cookie.parse(url, "a=b").secure());
-    assertTrue(Cookie.parse(url, "a=b; Secure").secure());
-  }
-
-  @Test public void maxAgeTakesPrecedenceOverExpires() throws Exception {
-    // Max-Age = 1, Expires = 2. In either order.
-    assertEquals(1000L, Cookie.parse(
-        0L, url, "a=b; Max-Age=1; Expires=Thu, 01 Jan 1970 00:00:02 GMT").expiresAt());
-    assertEquals(1000L, Cookie.parse(
-        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:02 GMT; Max-Age=1").expiresAt());
-    // Max-Age = 2, Expires = 1. In either order.
-    assertEquals(2000L, Cookie.parse(
-        0L, url, "a=b; Max-Age=2; Expires=Thu, 01 Jan 1970 00:00:01 GMT").expiresAt());
-    assertEquals(2000L, Cookie.parse(
-        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Max-Age=2").expiresAt());
-  }
-
-  /** If a cookie incorrectly defines multiple 'Max-Age' attributes, the last one defined wins. */
-  @Test public void lastMaxAgeWins() throws Exception {
-    assertEquals(3000L, Cookie.parse(
-        0L, url, "a=b; Max-Age=2; Max-Age=4; Max-Age=1; Max-Age=3").expiresAt());
-  }
-
-  /** If a cookie incorrectly defines multiple 'Expires' attributes, the last one defined wins. */
-  @Test public void lastExpiresAtWins() throws Exception {
-    assertEquals(3000L, Cookie.parse(0L, url, "a=b; "
-        + "Expires=Thu, 01 Jan 1970 00:00:02 GMT; "
-        + "Expires=Thu, 01 Jan 1970 00:00:04 GMT; "
-        + "Expires=Thu, 01 Jan 1970 00:00:01 GMT; "
-        + "Expires=Thu, 01 Jan 1970 00:00:03 GMT").expiresAt());
-  }
-
-  @Test public void maxAgeOrExpiresMakesCookiePersistent() throws Exception {
-    assertFalse(Cookie.parse(0L, url, "a=b").persistent());
-    assertTrue(Cookie.parse(0L, url, "a=b; Max-Age=1").persistent());
-    assertTrue(Cookie.parse(0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT").persistent());
-  }
-
-  @Test public void parseAll() throws Exception {
-    Headers headers = new Headers.Builder()
-        .add("Set-Cookie: a=b")
-        .add("Set-Cookie: c=d")
-        .build();
-    List<Cookie> cookies = Cookie.parseAll(url, headers);
-    assertEquals(2, cookies.size());
-    assertEquals("a=b; path=/", cookies.get(0).toString());
-    assertEquals("c=d; path=/", cookies.get(1).toString());
-  }
-
-  @Test public void builder() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .domain("example.com")
-        .build();
-    assertEquals("a", cookie.name());
-    assertEquals("b", cookie.value());
-    assertEquals(HttpDate.MAX_DATE, cookie.expiresAt());
-    assertEquals("example.com", cookie.domain());
-    assertEquals("/", cookie.path());
-    assertFalse(cookie.secure());
-    assertFalse(cookie.httpOnly());
-    assertFalse(cookie.persistent());
-    assertFalse(cookie.hostOnly());
-  }
-
-  @Test public void builderNameValidation() throws Exception {
-    try {
-      new Cookie.Builder().name(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      new Cookie.Builder().name(" a ");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void builderValueValidation() throws Exception {
-    try {
-      new Cookie.Builder().value(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      new Cookie.Builder().value(" b ");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void builderClampsMaxDate() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .expiresAt(Long.MAX_VALUE)
-        .build();
-    assertEquals("a=b; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/", cookie.toString());
-  }
-
-  @Test public void builderExpiresAt() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .expiresAt(date("1970-01-01T00:00:01.000+0000").getTime())
-        .build();
-    assertEquals("a=b; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/", cookie.toString());
-  }
-
-  @Test public void builderClampsMinDate() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .expiresAt(date("1970-01-01T00:00:00.000+0000").getTime())
-        .build();
-    assertEquals("a=b; max-age=0; path=/", cookie.toString());
-  }
-
-  @Test public void builderDomainValidation() throws Exception {
-    try {
-      new Cookie.Builder().hostOnlyDomain(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      new Cookie.Builder().hostOnlyDomain("a/b");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void builderDomain() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("squareup.com")
-        .build();
-    assertEquals("squareup.com", cookie.domain());
-    assertTrue(cookie.hostOnly());
-  }
-
-  @Test public void builderPath() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .path("/foo")
-        .build();
-    assertEquals("/foo", cookie.path());
-  }
-
-  @Test public void builderPathValidation() throws Exception {
-    try {
-      new Cookie.Builder().path(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      new Cookie.Builder().path("foo");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void builderSecure() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .secure()
-        .build();
-    assertEquals(true, cookie.secure());
-  }
-
-  @Test public void builderHttpOnly() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .httpOnly()
-        .build();
-    assertEquals(true, cookie.httpOnly());
-  }
-
-  @Test public void builderIpv6() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .domain("0:0:0:0:0:0:0:1")
-        .build();
-    assertEquals("::1", cookie.domain());
-  }
-
-  @Test public void equalsAndHashCode() throws Exception {
-    List<String> cookieStrings = Arrays.asList(
-        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
-        "a= ; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
-        "a=b;          Domain=example.com; Max-Age=5; Secure; HttpOnly",
-        "a=b; Path=/c;                     Max-Age=5; Secure; HttpOnly",
-        "a=b; Path=/c; Domain=example.com;            Secure; HttpOnly",
-        "a=b; Path=/c; Domain=example.com; Max-Age=5;         HttpOnly",
-        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure;         "
-    );
-    for (String stringA : cookieStrings) {
-      Cookie cookieA = Cookie.parse(0, url, stringA);
-      for (String stringB : cookieStrings) {
-        Cookie cookieB = Cookie.parse(0, url, stringB);
-        if (Objects.equals(stringA, stringB)) {
-          assertEquals(cookieA.hashCode(), cookieB.hashCode());
-          assertEquals(cookieA, cookieB);
-        } else {
-          assertFalse(cookieA.hashCode() == cookieB.hashCode());
-          assertFalse(cookieA.equals(cookieB));
-        }
-      }
-      assertFalse(cookieA.equals(null));
-    }
-  }
-
-  private Date date(String s) throws ParseException {
-    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
-    format.setTimeZone(Util.UTC);
-    return format.parse(s);
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
deleted file mode 100644
index b0cb8a6d0f..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import okio.Buffer;
-import org.junit.Test;
-import java.nio.charset.Charset;
-
-import static org.junit.Assert.assertEquals;
-
-public final class FormBodyTest {
-  @Test public void urlEncoding() throws Exception {
-    FormBody body = new FormBody.Builder()
-        .add("a+=& b", "c+=& d")
-        .add("space, the", "final frontier")
-        .add("%25", "%25")
-        .build();
-
-    assertEquals(3, body.size());
-
-    assertEquals("a%2B%3D%26%20b", body.encodedName(0));
-    assertEquals("space%2C%20the", body.encodedName(1));
-    assertEquals("%2525", body.encodedName(2));
-
-    assertEquals("a+=& b", body.name(0));
-    assertEquals("space, the", body.name(1));
-    assertEquals("%25", body.name(2));
-
-    assertEquals("c%2B%3D%26%20d", body.encodedValue(0));
-    assertEquals("final%20frontier", body.encodedValue(1));
-    assertEquals("%2525", body.encodedValue(2));
-
-    assertEquals("c+=& d", body.value(0));
-    assertEquals("final frontier", body.value(1));
-    assertEquals("%25", body.value(2));
-
-    assertEquals("application/x-www-form-urlencoded", body.contentType().toString());
-
-    String expected = "a%2B%3D%26%20b=c%2B%3D%26%20d&space%2C%20the=final%20frontier&%2525=%2525";
-    assertEquals(expected.length(), body.contentLength());
-
-    Buffer out = new Buffer();
-    body.writeTo(out);
-    assertEquals(expected, out.readUtf8());
-  }
-
-  @Test public void addEncoded() throws Exception {
-    FormBody body = new FormBody.Builder()
-        .addEncoded("a+=& b", "c+=& d")
-        .addEncoded("e+=& f", "g+=& h")
-        .addEncoded("%25", "%25")
-        .build();
-
-    String expected = "a+%3D%26%20b=c+%3D%26%20d&e+%3D%26%20f=g+%3D%26%20h&%25=%25";
-    Buffer out = new Buffer();
-    body.writeTo(out);
-    assertEquals(expected, out.readUtf8());
-  }
-
-  @Test public void encodedPair() throws Exception {
-    FormBody body = new FormBody.Builder()
-        .add("sim", "ple")
-        .build();
-
-    String expected = "sim=ple";
-    assertEquals(expected.length(), body.contentLength());
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertEquals(expected, buffer.readUtf8());
-  }
-
-  @Test public void encodeMultiplePairs() throws Exception {
-    FormBody body = new FormBody.Builder()
-        .add("sim", "ple")
-        .add("hey", "there")
-        .add("help", "me")
-        .build();
-
-    String expected = "sim=ple&hey=there&help=me";
-    assertEquals(expected.length(), body.contentLength());
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertEquals(expected, buffer.readUtf8());
-  }
-
-  @Test public void buildEmptyForm() throws Exception {
-    FormBody body = new FormBody.Builder().build();
-
-    String expected = "";
-    assertEquals(expected.length(), body.contentLength());
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertEquals(expected, buffer.readUtf8());
-  }
-
-  @Test public void characterEncoding() throws Exception {
-    assertEquals("%00", formEncode(0)); // Browsers convert '\u0000' to '%EF%BF%BD'.
-    assertEquals("%01", formEncode(1));
-    assertEquals("%02", formEncode(2));
-    assertEquals("%03", formEncode(3));
-    assertEquals("%04", formEncode(4));
-    assertEquals("%05", formEncode(5));
-    assertEquals("%06", formEncode(6));
-    assertEquals("%07", formEncode(7));
-    assertEquals("%08", formEncode(8));
-    assertEquals("%09", formEncode(9));
-    assertEquals("%0A", formEncode(10)); // Browsers convert '\n' to '\r\n'
-    assertEquals("%0B", formEncode(11));
-    assertEquals("%0C", formEncode(12));
-    assertEquals("%0D", formEncode(13)); // Browsers convert '\r' to '\r\n'
-    assertEquals("%0E", formEncode(14));
-    assertEquals("%0F", formEncode(15));
-    assertEquals("%10", formEncode(16));
-    assertEquals("%11", formEncode(17));
-    assertEquals("%12", formEncode(18));
-    assertEquals("%13", formEncode(19));
-    assertEquals("%14", formEncode(20));
-    assertEquals("%15", formEncode(21));
-    assertEquals("%16", formEncode(22));
-    assertEquals("%17", formEncode(23));
-    assertEquals("%18", formEncode(24));
-    assertEquals("%19", formEncode(25));
-    assertEquals("%1A", formEncode(26));
-    assertEquals("%1B", formEncode(27));
-    assertEquals("%1C", formEncode(28));
-    assertEquals("%1D", formEncode(29));
-    assertEquals("%1E", formEncode(30));
-    assertEquals("%1F", formEncode(31));
-    assertEquals("%20", formEncode(32)); // Browsers use '+' for space.
-    assertEquals("%21", formEncode(33));
-    assertEquals("%22", formEncode(34));
-    assertEquals("%23", formEncode(35));
-    assertEquals("%24", formEncode(36));
-    assertEquals("%25", formEncode(37));
-    assertEquals("%26", formEncode(38));
-    assertEquals("%27", formEncode(39));
-    assertEquals("%28", formEncode(40));
-    assertEquals("%29", formEncode(41));
-    assertEquals("*", formEncode(42));
-    assertEquals("%2B", formEncode(43));
-    assertEquals("%2C", formEncode(44));
-    assertEquals("-", formEncode(45));
-    assertEquals(".", formEncode(46));
-    assertEquals("%2F", formEncode(47));
-    assertEquals("0", formEncode(48));
-    assertEquals("9", formEncode(57));
-    assertEquals("%3A", formEncode(58));
-    assertEquals("%3B", formEncode(59));
-    assertEquals("%3C", formEncode(60));
-    assertEquals("%3D", formEncode(61));
-    assertEquals("%3E", formEncode(62));
-    assertEquals("%3F", formEncode(63));
-    assertEquals("%40", formEncode(64));
-    assertEquals("A", formEncode(65));
-    assertEquals("Z", formEncode(90));
-    assertEquals("%5B", formEncode(91));
-    assertEquals("%5C", formEncode(92));
-    assertEquals("%5D", formEncode(93));
-    assertEquals("%5E", formEncode(94));
-    assertEquals("_", formEncode(95));
-    assertEquals("%60", formEncode(96));
-    assertEquals("a", formEncode(97));
-    assertEquals("z", formEncode(122));
-    assertEquals("%7B", formEncode(123));
-    assertEquals("%7C", formEncode(124));
-    assertEquals("%7D", formEncode(125));
-    assertEquals("%7E", formEncode(126));
-    assertEquals("%7F", formEncode(127));
-    assertEquals("%C2%80", formEncode(128));
-    assertEquals("%C3%BF", formEncode(255));
-  }
-
-  private String formEncode(int codePoint) throws IOException {
-    // Wrap the codepoint with regular printable characters to prevent trimming.
-    FormBody body = new FormBody.Builder()
-        .add("a", new String(new int[] {'b', codePoint, 'c'}, 0, 3))
-        .build();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    buffer.skip(3); // Skip "a=b" prefix.
-    return buffer.readUtf8(buffer.size() - 1); // Skip the "c" suffix.
-  }
-
-  @Test public void manualCharset() throws Exception {
-    FormBody body = new FormBody.Builder(Charset.forName("ISO-8859-1"))
-        .add("name", "Nicol√°s")
-        .build();
-
-    String expected = "name=Nicol%E1s";
-    assertEquals(expected.length(), body.contentLength());
-
-    Buffer out = new Buffer();
-    body.writeTo(out);
-    assertEquals(expected, out.readUtf8());
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
deleted file mode 100644
index 0dfcee31b9..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
+++ /dev/null
@@ -1,474 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http2.Header;
-import okhttp3.internal.http2.Http2Codec;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.headerEntries;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class HeadersTest {
-  static {
-    Internal.initializeInstanceForTests();
-  }
-
-  @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
-    List<Header> headerBlock = headerEntries(
-        ":status", "200 OK",
-        ":version", "HTTP/1.1",
-        "connection", "close");
-    Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = Http2Codec.readHttp2HeadersList(headerBlock, Protocol.HTTP_2).request(request).build();
-    Headers headers = response.headers();
-    assertEquals(1, headers.size());
-    assertEquals(":version", headers.name(0));
-    assertEquals("HTTP/1.1", headers.value(0));
-  }
-
-  @Test public void http2HeadersListDropsForbiddenHeadersHttp2() {
-    Request request = new Request.Builder()
-        .url("http://square.com/")
-        .header("Connection", "upgrade")
-        .header("Upgrade", "websocket")
-        .header("Host", "square.com")
-        .build();
-    List<Header> expected = headerEntries(
-        ":method", "GET",
-        ":path", "/",
-        ":authority", "square.com",
-        ":scheme", "http");
-    assertEquals(expected, Http2Codec.http2HeadersList(request));
-  }
-
-  @Test public void ofTrims() {
-    Headers headers = Headers.of("\t User-Agent \n", " \r OkHttp ");
-    assertEquals("User-Agent", headers.name(0));
-    assertEquals("OkHttp", headers.value(0));
-  }
-
-  @Test public void addParsing() {
-    Headers headers = new Headers.Builder()
-        .add("foo: bar")
-        .add(" foo: baz") // Name leading whitespace is trimmed.
-        .add("foo : bak") // Name trailing whitespace is trimmed.
-        .add("\tkey\t:\tvalue\t") // '\t' also counts as whitespace
-        .add("ping:  pong  ") // Value whitespace is trimmed.
-        .add("kit:kat") // Space after colon is not required.
-        .build();
-    assertEquals(Arrays.asList("bar", "baz", "bak"), headers.values("foo"));
-    assertEquals(Arrays.asList("value"), headers.values("key"));
-    assertEquals(Arrays.asList("pong"), headers.values("ping"));
-    assertEquals(Arrays.asList("kat"), headers.values("kit"));
-  }
-
-  @Test public void addThrowsOnEmptyName() {
-    try {
-      new Headers.Builder().add(": bar");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Headers.Builder().add(" : bar");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void addThrowsOnNoColon() {
-    try {
-      new Headers.Builder().add("foo bar");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void addThrowsOnMultiColon() {
-    try {
-      new Headers.Builder().add(":status: 200 OK");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofThrowsOddNumberOfHeaders() {
-    try {
-      Headers.of("User-Agent", "OkHttp", "Content-Length");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofThrowsOnNull() {
-    try {
-      Headers.of("User-Agent", null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofThrowsOnEmptyName() {
-    try {
-      Headers.of("", "OkHttp");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofAcceptsEmptyValue() {
-    Headers headers = Headers.of("User-Agent", "");
-    assertEquals("", headers.value(0));
-  }
-
-  @Test public void ofMakesDefensiveCopy() {
-    String[] namesAndValues = {
-        "User-Agent",
-        "OkHttp"
-    };
-    Headers headers = Headers.of(namesAndValues);
-    namesAndValues[1] = "Chrome";
-    assertEquals("OkHttp", headers.value(0));
-  }
-
-  @Test public void ofRejectsNullChar() {
-    try {
-      Headers.of("User-Agent", "Square\u0000OkHttp");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofMapThrowsOnNull() {
-    try {
-      Headers.of(Collections.<String, String>singletonMap("User-Agent", null));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofMapThrowsOnEmptyName() {
-    try {
-      Headers.of(Collections.singletonMap("", "OkHttp"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofMapThrowsOnBlankName() {
-    try {
-      Headers.of(Collections.singletonMap(" ", "OkHttp"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofMapAcceptsEmptyValue() {
-    Headers headers = Headers.of(Collections.singletonMap("User-Agent", ""));
-    assertEquals("", headers.value(0));
-  }
-
-  @Test public void ofMapTrimsKey() {
-    Headers headers = Headers.of(Collections.singletonMap(" User-Agent ", "OkHttp"));
-    assertEquals("User-Agent", headers.name(0));
-  }
-
-  @Test public void ofMapTrimsValue() {
-    Headers headers = Headers.of(Collections.singletonMap("User-Agent", " OkHttp "));
-    assertEquals("OkHttp", headers.value(0));
-  }
-
-  @Test public void ofMapMakesDefensiveCopy() {
-    Map<String, String> namesAndValues = new LinkedHashMap<>();
-    namesAndValues.put("User-Agent", "OkHttp");
-
-    Headers headers = Headers.of(namesAndValues);
-    namesAndValues.put("User-Agent", "Chrome");
-    assertEquals("OkHttp", headers.value(0));
-  }
-
-  @Test public void ofMapRejectsNullCharInName() {
-    try {
-      Headers.of(Collections.singletonMap("User-\u0000Agent", "OkHttp"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofMapRejectsNullCharInValue() {
-    try {
-      Headers.of(Collections.singletonMap("User-Agent", "Square\u0000OkHttp"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void toMultimapGroupsHeaders() {
-    Headers headers = Headers.of(
-        "cache-control", "no-cache",
-        "cache-control", "no-store",
-        "user-agent", "OkHttp");
-    Map<String, List<String>> headerMap = headers.toMultimap();
-    assertEquals(2, headerMap.get("cache-control").size());
-    assertEquals(1, headerMap.get("user-agent").size());
-  }
-
-  @Test public void toMultimapUsesCanonicalCase() {
-    Headers headers = Headers.of(
-        "cache-control", "no-store",
-        "Cache-Control", "no-cache",
-        "User-Agent", "OkHttp");
-    Map<String, List<String>> headerMap = headers.toMultimap();
-    assertEquals(2, headerMap.get("cache-control").size());
-    assertEquals(1, headerMap.get("user-agent").size());
-  }
-
-  @Test public void toMultimapAllowsCaseInsensitiveGet() {
-    Headers headers = Headers.of(
-        "cache-control", "no-store",
-        "Cache-Control", "no-cache");
-    Map<String, List<String>> headerMap = headers.toMultimap();
-    assertEquals(2, headerMap.get("cache-control").size());
-    assertEquals(2, headerMap.get("Cache-Control").size());
-  }
-
-  @Test public void nameIndexesAreStrict() {
-    Headers headers = Headers.of("a", "b", "c", "d");
-    try {
-      headers.name(-1);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-    assertEquals("a", headers.name(0));
-    assertEquals("c", headers.name(1));
-    try {
-      headers.name(2);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void valueIndexesAreStrict() {
-    Headers headers = Headers.of("a", "b", "c", "d");
-    try {
-      headers.value(-1);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-    assertEquals("b", headers.value(0));
-    assertEquals("d", headers.value(1));
-    try {
-      headers.value(2);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void builderRejectsUnicodeInHeaderName() {
-    try {
-      new Headers.Builder().add("h√©ader1", "value1");
-      fail("Should have complained about invalid name");
-    } catch (IllegalArgumentException expected) {
-      assertEquals("Unexpected char 0xe9 at 1 in header name: h√©ader1",
-          expected.getMessage());
-    }
-  }
-
-  @Test public void builderRejectsUnicodeInHeaderValue() {
-    try {
-      new Headers.Builder().add("header1", "valu√©1");
-      fail("Should have complained about invalid value");
-    } catch (IllegalArgumentException expected) {
-      assertEquals("Unexpected char 0xe9 at 4 in header1 value: valu√©1",
-          expected.getMessage());
-    }
-  }
-
-  @Test public void headersEquals() {
-    Headers headers1 = new Headers.Builder()
-        .add("Connection", "close")
-        .add("Transfer-Encoding", "chunked")
-        .build();
-    Headers headers2 = new Headers.Builder()
-        .add("Connection", "close")
-        .add("Transfer-Encoding", "chunked")
-        .build();
-    assertTrue(headers1.equals(headers2));
-    assertEquals(headers1.hashCode(), headers2.hashCode());
-  }
-
-  @Test public void headersNotEquals() {
-    Headers headers1 = new Headers.Builder()
-        .add("Connection", "close")
-        .add("Transfer-Encoding", "chunked")
-        .build();
-    Headers headers2 = new Headers.Builder()
-        .add("Connection", "keep-alive")
-        .add("Transfer-Encoding", "chunked")
-        .build();
-    assertFalse(headers1.equals(headers2));
-    assertFalse(headers1.hashCode() == headers2.hashCode());
-  }
-
-  @Test public void headersToString() {
-    Headers headers = new Headers.Builder()
-        .add("A", "a")
-        .add("B", "bb")
-        .build();
-    assertEquals("A: a\nB: bb\n", headers.toString());
-  }
-
-  /** See https://github.com/square/okhttp/issues/2780. */
-  @Test public void testDigestChallenges() {
-    // Strict RFC 2617 header.
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
-            + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("Digest", challenges.get(0).scheme());
-    assertEquals("myrealm", challenges.get(0).realm());
-
-    // Not strict RFC 2617 header.
-    headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest qop=\"auth\", realm=\"myrealm\", nonce=\"fjalskdflwejrlask"
-            + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
-        .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("Digest", challenges.get(0).scheme());
-    assertEquals("myrealm", challenges.get(0).realm());
-
-    // Not strict RFC 2617 header #2.
-    headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest qop=\"auth\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaksjdflk"
-            + "asdf\", realm=\"myrealm\", stale=\"FALSE\"")
-        .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("Digest", challenges.get(0).scheme());
-    assertEquals("myrealm", challenges.get(0).realm());
-
-    // Wrong header.
-    headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest qop=\"auth\", underrealm=\"myrealm\", nonce=\"fjalskdflwej"
-            + "rlaskdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
-        .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(0, challenges.size());
-
-    // Not strict RFC 2617 header with some spaces.
-    headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest qop=\"auth\",    realm=\"myrealm\", nonce=\"fjalskdflwejrl"
-            + "askdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
-        .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("Digest", challenges.get(0).scheme());
-    assertEquals("myrealm", challenges.get(0).realm());
-
-    // Strict RFC 2617 header with some spaces.
-    headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest    realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjfl"
-            + "aksjdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
-        .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("Digest", challenges.get(0).scheme());
-    assertEquals("myrealm", challenges.get(0).realm());
-
-    // Not strict RFC 2617 camelcased.
-    headers = new Headers.Builder()
-        .add("WWW-Authenticate", "DiGeSt qop=\"auth\", rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlask"
-            + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
-        .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("DiGeSt", challenges.get(0).scheme());
-    assertEquals("myrealm", challenges.get(0).realm());
-
-    // Strict RFC 2617 camelcased.
-    headers = new Headers.Builder()
-        .add("WWW-Authenticate", "DIgEsT rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
-            + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
-        .build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(1, challenges.size());
-    assertEquals("DIgEsT", challenges.get(0).scheme());
-    assertEquals("myrealm", challenges.get(0).realm());
-
-    // Unquoted.
-    headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest realm=myrealm").build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(0, challenges.size());
-
-    // Scheme only.
-    headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest").build();
-    challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertEquals(0, challenges.size());
-  }
-
-  @Test public void basicChallenge() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate: Basic realm=\"protected area\"")
-        .build();
-    assertEquals(Arrays.asList(new Challenge("Basic", "protected area")),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
-  }
-
-  @Test public void basicChallengeWithCharset() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
-        .build();
-    assertEquals(Arrays.asList(new Challenge("Basic", "protected area").withCharset(Util.UTF_8)),
-        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
-  }
-
-  @Test public void basicChallengeWithUnexpectedCharset() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"US-ASCII\"")
-        .build();
-    assertEquals(Collections.emptyList(), HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
-  }
-
-  @Test public void byteCount() {
-    assertEquals(0L, new Headers.Builder().build().byteCount());
-    assertEquals(10L, new Headers.Builder()
-        .add("abc", "def")
-        .build()
-        .byteCount());
-    assertEquals(20L, new Headers.Builder()
-        .add("abc", "def")
-        .add("ghi", "jkl")
-        .build()
-        .byteCount());
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
deleted file mode 100644
index bae6dce2da..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ /dev/null
@@ -1,1568 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.MalformedURLException;
-import java.net.URI;
-import java.net.URL;
-import java.net.UnknownHostException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import okhttp3.UrlComponentEncodingTester.Component;
-import okhttp3.UrlComponentEncodingTester.Encoding;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import static java.util.Collections.singletonList;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-
-public final class HttpUrlTest {
-  @Test public void parseTrimsAsciiWhitespace() throws Exception {
-    HttpUrl expected = HttpUrl.parse("http://host/");
-    assertEquals(expected, HttpUrl.parse("http://host/\f\n\t \r")); // Leading.
-    assertEquals(expected, HttpUrl.parse("\r\n\f \thttp://host/")); // Trailing.
-    assertEquals(expected, HttpUrl.parse(" http://host/ ")); // Both.
-    assertEquals(expected, HttpUrl.parse("    http://host/    ")); // Both.
-    assertEquals(expected, HttpUrl.parse("http://host/").resolve("   "));
-    assertEquals(expected, HttpUrl.parse("http://host/").resolve("  .  "));
-  }
-
-  @Test public void parseHostAsciiNonPrintable() throws Exception {
-    String host = "host\u0001";
-    assertNull(HttpUrl.parse("http://" + host + "/"));
-  }
-
-  @Test public void parseDoesNotTrimOtherWhitespaceCharacters() throws Exception {
-    // Whitespace characters list from Google's Guava team: http://goo.gl/IcR9RD
-    assertEquals("/%0B", HttpUrl.parse("http://h/\u000b").encodedPath()); // line tabulation
-    assertEquals("/%1C", HttpUrl.parse("http://h/\u001c").encodedPath()); // information separator 4
-    assertEquals("/%1D", HttpUrl.parse("http://h/\u001d").encodedPath()); // information separator 3
-    assertEquals("/%1E", HttpUrl.parse("http://h/\u001e").encodedPath()); // information separator 2
-    assertEquals("/%1F", HttpUrl.parse("http://h/\u001f").encodedPath()); // information separator 1
-    assertEquals("/%C2%85", HttpUrl.parse("http://h/\u0085").encodedPath()); // next line
-    assertEquals("/%C2%A0", HttpUrl.parse("http://h/\u00a0").encodedPath()); // non-breaking space
-    assertEquals("/%E1%9A%80", HttpUrl.parse("http://h/\u1680").encodedPath()); // ogham space mark
-    assertEquals("/%E1%A0%8E", HttpUrl.parse("http://h/\u180e").encodedPath()); // mongolian vowel separator
-    assertEquals("/%E2%80%80", HttpUrl.parse("http://h/\u2000").encodedPath()); // en quad
-    assertEquals("/%E2%80%81", HttpUrl.parse("http://h/\u2001").encodedPath()); // em quad
-    assertEquals("/%E2%80%82", HttpUrl.parse("http://h/\u2002").encodedPath()); // en space
-    assertEquals("/%E2%80%83", HttpUrl.parse("http://h/\u2003").encodedPath()); // em space
-    assertEquals("/%E2%80%84", HttpUrl.parse("http://h/\u2004").encodedPath()); // three-per-em space
-    assertEquals("/%E2%80%85", HttpUrl.parse("http://h/\u2005").encodedPath()); // four-per-em space
-    assertEquals("/%E2%80%86", HttpUrl.parse("http://h/\u2006").encodedPath()); // six-per-em space
-    assertEquals("/%E2%80%87", HttpUrl.parse("http://h/\u2007").encodedPath()); // figure space
-    assertEquals("/%E2%80%88", HttpUrl.parse("http://h/\u2008").encodedPath()); // punctuation space
-    assertEquals("/%E2%80%89", HttpUrl.parse("http://h/\u2009").encodedPath()); // thin space
-    assertEquals("/%E2%80%8A", HttpUrl.parse("http://h/\u200a").encodedPath()); // hair space
-    assertEquals("/%E2%80%8B", HttpUrl.parse("http://h/\u200b").encodedPath()); // zero-width space
-    assertEquals("/%E2%80%8C", HttpUrl.parse("http://h/\u200c").encodedPath()); // zero-width non-joiner
-    assertEquals("/%E2%80%8D", HttpUrl.parse("http://h/\u200d").encodedPath()); // zero-width joiner
-    assertEquals("/%E2%80%8E", HttpUrl.parse("http://h/\u200e").encodedPath()); // left-to-right mark
-    assertEquals("/%E2%80%8F", HttpUrl.parse("http://h/\u200f").encodedPath()); // right-to-left mark
-    assertEquals("/%E2%80%A8", HttpUrl.parse("http://h/\u2028").encodedPath()); // line separator
-    assertEquals("/%E2%80%A9", HttpUrl.parse("http://h/\u2029").encodedPath()); // paragraph separator
-    assertEquals("/%E2%80%AF", HttpUrl.parse("http://h/\u202f").encodedPath()); // narrow non-breaking space
-    assertEquals("/%E2%81%9F", HttpUrl.parse("http://h/\u205f").encodedPath()); // medium mathematical space
-    assertEquals("/%E3%80%80", HttpUrl.parse("http://h/\u3000").encodedPath()); // ideographic space
-  }
-
-  @Test public void scheme() throws Exception {
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host/"));
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("Http://host/"));
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host/"));
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("HTTP://host/"));
-    assertEquals(HttpUrl.parse("https://host/"), HttpUrl.parse("https://host/"));
-    assertEquals(HttpUrl.parse("https://host/"), HttpUrl.parse("HTTPS://host/"));
-    assertEquals(HttpUrl.Builder.ParseResult.UNSUPPORTED_SCHEME,
-        new HttpUrl.Builder().parse(null, "image640://480.png"));
-    assertEquals(null, HttpUrl.parse("httpp://host/"));
-    assertEquals(null, HttpUrl.parse("0ttp://host/"));
-    assertEquals(null, HttpUrl.parse("ht+tp://host/"));
-    assertEquals(null, HttpUrl.parse("ht.tp://host/"));
-    assertEquals(null, HttpUrl.parse("ht-tp://host/"));
-    assertEquals(null, HttpUrl.parse("ht1tp://host/"));
-    assertEquals(null, HttpUrl.parse("httpss://host/"));
-  }
-
-  @Test public void parseNoScheme() throws Exception {
-    assertEquals(null, HttpUrl.parse("//host"));
-    assertEquals(null, HttpUrl.parse("/path"));
-    assertEquals(null, HttpUrl.parse("path"));
-    assertEquals(null, HttpUrl.parse("?query"));
-    assertEquals(null, HttpUrl.parse("#fragment"));
-  }
-
-  @Test public void newBuilderResolve() throws Exception {
-    // Non-exhaustive tests because implementation is the same as resolve.
-    HttpUrl base = HttpUrl.parse("http://host/a/b");
-    assertEquals(HttpUrl.parse("https://host2/"), base.newBuilder("https://host2").build());
-    assertEquals(HttpUrl.parse("http://host2/"), base.newBuilder("//host2").build());
-    assertEquals(HttpUrl.parse("http://host/path"), base.newBuilder("/path").build());
-    assertEquals(HttpUrl.parse("http://host/a/path"), base.newBuilder("path").build());
-    assertEquals(HttpUrl.parse("http://host/a/b?query"), base.newBuilder("?query").build());
-    assertEquals(HttpUrl.parse("http://host/a/b#fragment"), base.newBuilder("#fragment").build());
-    assertEquals(HttpUrl.parse("http://host/a/b"), base.newBuilder("").build());
-    assertEquals(null, base.newBuilder("ftp://b"));
-    assertEquals(null, base.newBuilder("ht+tp://b"));
-    assertEquals(null, base.newBuilder("ht-tp://b"));
-    assertEquals(null, base.newBuilder("ht.tp://b"));
-  }
-
-  @Test public void redactedUrl() {
-    HttpUrl baseWithPasswordAndUsername = HttpUrl.parse("http://username:password@host/a/b#fragment");
-    HttpUrl baseWithUsernameOnly = HttpUrl.parse("http://username@host/a/b#fragment");
-    HttpUrl baseWithPasswordOnly = HttpUrl.parse("http://password@host/a/b#fragment");
-    assertEquals("http://host/...", baseWithPasswordAndUsername.redact());
-    assertEquals("http://host/...", baseWithUsernameOnly.redact());
-    assertEquals("http://host/...", baseWithPasswordOnly.redact());
-  }
-
-  @Test public void resolveNoScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b");
-    assertEquals(HttpUrl.parse("http://host2/"), base.resolve("//host2"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("/path"));
-    assertEquals(HttpUrl.parse("http://host/a/path"), base.resolve("path"));
-    assertEquals(HttpUrl.parse("http://host/a/b?query"), base.resolve("?query"));
-    assertEquals(HttpUrl.parse("http://host/a/b#fragment"), base.resolve("#fragment"));
-    assertEquals(HttpUrl.parse("http://host/a/b"), base.resolve(""));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("\\path"));
-  }
-
-  @Test public void resolveUnsupportedScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://a/");
-    assertEquals(null, base.resolve("ftp://b"));
-    assertEquals(null, base.resolve("ht+tp://b"));
-    assertEquals(null, base.resolve("ht-tp://b"));
-    assertEquals(null, base.resolve("ht.tp://b"));
-  }
-
-  @Test public void resolveSchemeLikePath() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://a/");
-    assertEquals(HttpUrl.parse("http://a/http//b/"), base.resolve("http//b/"));
-    assertEquals(HttpUrl.parse("http://a/ht+tp//b/"), base.resolve("ht+tp//b/"));
-    assertEquals(HttpUrl.parse("http://a/ht-tp//b/"), base.resolve("ht-tp//b/"));
-    assertEquals(HttpUrl.parse("http://a/ht.tp//b/"), base.resolve("ht.tp//b/"));
-  }
-
-  /** https://tools.ietf.org/html/rfc3986#section-5.4.1 */
-  @Test public void rfc3886NormalExamples() {
-    HttpUrl url = HttpUrl.parse("http://a/b/c/d;p?q");
-    assertEquals(null, url.resolve("g:h")); // No 'g:' scheme in HttpUrl.
-    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("./g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g/"), url.resolve("g/"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/g"));
-    assertEquals(HttpUrl.parse("http://g"), url.resolve("//g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/d;p?y"), url.resolve("?y"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g?y"), url.resolve("g?y"));
-    assertEquals(HttpUrl.parse("http://a/b/c/d;p?q#s"), url.resolve("#s"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g#s"), url.resolve("g#s"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g?y#s"), url.resolve("g?y#s"));
-    assertEquals(HttpUrl.parse("http://a/b/c/;x"), url.resolve(";x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g;x"), url.resolve("g;x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g;x?y#s"), url.resolve("g;x?y#s"));
-    assertEquals(HttpUrl.parse("http://a/b/c/d;p?q"), url.resolve(""));
-    assertEquals(HttpUrl.parse("http://a/b/c/"), url.resolve("."));
-    assertEquals(HttpUrl.parse("http://a/b/c/"), url.resolve("./"));
-    assertEquals(HttpUrl.parse("http://a/b/"), url.resolve(".."));
-    assertEquals(HttpUrl.parse("http://a/b/"), url.resolve("../"));
-    assertEquals(HttpUrl.parse("http://a/b/g"), url.resolve("../g"));
-    assertEquals(HttpUrl.parse("http://a/"), url.resolve("../.."));
-    assertEquals(HttpUrl.parse("http://a/"), url.resolve("../../"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../g"));
-  }
-
-  /** https://tools.ietf.org/html/rfc3986#section-5.4.2 */
-  @Test public void rfc3886AbnormalExamples() {
-    HttpUrl url = HttpUrl.parse("http://a/b/c/d;p?q");
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../../g"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../../../g"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/./g"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/../g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g."), url.resolve("g."));
-    assertEquals(HttpUrl.parse("http://a/b/c/.g"), url.resolve(".g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g.."), url.resolve("g.."));
-    assertEquals(HttpUrl.parse("http://a/b/c/..g"), url.resolve("..g"));
-    assertEquals(HttpUrl.parse("http://a/b/g"), url.resolve("./../g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g/"), url.resolve("./g/."));
-    assertEquals(HttpUrl.parse("http://a/b/c/g/h"), url.resolve("g/./h"));
-    assertEquals(HttpUrl.parse("http://a/b/c/h"), url.resolve("g/../h"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g;x=1/y"), url.resolve("g;x=1/./y"));
-    assertEquals(HttpUrl.parse("http://a/b/c/y"), url.resolve("g;x=1/../y"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g?y/./x"), url.resolve("g?y/./x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g?y/../x"), url.resolve("g?y/../x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g#s/./x"), url.resolve("g#s/./x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g#s/../x"), url.resolve("g#s/../x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("http:g")); // "http:g" also okay.
-  }
-
-  @Test public void parseAuthoritySlashCountDoesntMatter() throws Exception {
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:///host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\//host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:////host/path"));
-  }
-
-  @Test public void resolveAuthoritySlashCountDoesntMatterWithDifferentScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("https://a/b/c");
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:///host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\//host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:////host/path"));
-  }
-
-  @Test public void resolveAuthoritySlashCountMattersWithSameScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://a/b/c");
-    assertEquals(HttpUrl.parse("http://a/b/host/path"), base.resolve("http:host/path"));
-    assertEquals(HttpUrl.parse("http://a/host/path"), base.resolve("http:/host/path"));
-    assertEquals(HttpUrl.parse("http://a/host/path"), base.resolve("http:\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:///host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\//host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:////host/path"));
-  }
-
-  @Test public void username() throws Exception {
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://@host/path"));
-    assertEquals(HttpUrl.parse("http://user@host/path"), HttpUrl.parse("http://user@host/path"));
-  }
-
-  /** Given multiple '@' characters, the last one is the delimiter. */
-  @Test public void authorityWithMultipleAtSigns() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://foo@bar@baz/path");
-    assertEquals("foo@bar", httpUrl.username());
-    assertEquals("", httpUrl.password());
-    assertEquals(HttpUrl.parse("http://foo%40bar@baz/path"), httpUrl);
-  }
-
-  /** Given multiple ':' characters, the first one is the delimiter. */
-  @Test public void authorityWithMultipleColons() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://foo:pass1@bar:pass2@baz/path");
-    assertEquals("foo", httpUrl.username());
-    assertEquals("pass1@bar:pass2", httpUrl.password());
-    assertEquals(HttpUrl.parse("http://foo:pass1%40bar%3Apass2@baz/path"), httpUrl);
-  }
-
-  @Test public void usernameAndPassword() throws Exception {
-    assertEquals(HttpUrl.parse("http://username:password@host/path"),
-        HttpUrl.parse("http://username:password@host/path"));
-    assertEquals(HttpUrl.parse("http://username@host/path"),
-        HttpUrl.parse("http://username:@host/path"));
-  }
-
-  @Test public void passwordWithEmptyUsername() throws Exception {
-    // Chrome doesn't mind, but Firefox rejects URLs with empty usernames and non-empty passwords.
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://:@host/path"));
-    assertEquals("password%40", HttpUrl.parse("http://:password@@host/path").encodedPassword());
-  }
-
-  @Test public void unprintableCharactersArePercentEncoded() throws Exception {
-    assertEquals("/%00", HttpUrl.parse("http://host/\u0000").encodedPath());
-    assertEquals("/%08", HttpUrl.parse("http://host/\u0008").encodedPath());
-    assertEquals("/%EF%BF%BD", HttpUrl.parse("http://host/\ufffd").encodedPath());
-  }
-
-  @Test public void usernameCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.PERCENT, '[', ']', '{', '}', '|', '^', '\'', ';', '=', '@')
-        .override(Encoding.SKIP, ':', '/', '\\', '?', '#')
-        .skipForUri('%')
-        .test(Component.USER);
-  }
-
-  @Test public void passwordCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.PERCENT, '[', ']', '{', '}', '|', '^', '\'', ':', ';', '=', '@')
-        .override(Encoding.SKIP, '/', '\\', '?', '#')
-        .skipForUri('%')
-        .test(Component.PASSWORD);
-  }
-
-  @Test public void hostContainsIllegalCharacter() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://\n/"));
-    assertEquals(null, HttpUrl.parse("http:// /"));
-    assertEquals(null, HttpUrl.parse("http://%20/"));
-  }
-
-  @Test public void hostnameLowercaseCharactersMappedDirectly() throws Exception {
-    assertEquals("abcd", HttpUrl.parse("http://abcd").host());
-    assertEquals("xn--4xa", HttpUrl.parse("http://œÉ").host());
-  }
-
-  @Test public void hostnameUppercaseCharactersConvertedToLowercase() throws Exception {
-    assertEquals("abcd", HttpUrl.parse("http://ABCD").host());
-    assertEquals("xn--4xa", HttpUrl.parse("http://Œ£").host());
-  }
-
-  @Test public void hostnameIgnoredCharacters() throws Exception {
-    // The soft hyphen (¬≠) should be ignored.
-    assertEquals("abcd", HttpUrl.parse("http://AB\u00adCD").host());
-  }
-
-  @Test public void hostnameMultipleCharacterMapping() throws Exception {
-    // Map the single character telephone symbol (‚Ñ°) to the string "tel".
-    assertEquals("tel", HttpUrl.parse("http://\u2121").host());
-  }
-
-  @Test public void hostnameMappingLastMappedCodePoint() throws Exception {
-    assertEquals("xn--pu5l", HttpUrl.parse("http://\uD87E\uDE1D").host());
-  }
-
-  @Ignore("The java.net.IDN implementation doesn't ignore characters that it should.")
-  @Test public void hostnameMappingLastIgnoredCodePoint() throws Exception {
-    assertEquals("abcd", HttpUrl.parse("http://ab\uDB40\uDDEFcd").host());
-  }
-
-  @Test public void hostnameMappingLastDisallowedCodePoint() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://\uDBFF\uDFFF"));
-  }
-
-  @Test public void hostIpv6() throws Exception {
-    // Square braces are absent from host()...
-    assertEquals("::1", HttpUrl.parse("http://[::1]/").host());
-
-    // ... but they're included in toString().
-    assertEquals("http://[::1]/", HttpUrl.parse("http://[::1]/").toString());
-
-    // IPv6 colons don't interfere with port numbers or passwords.
-    assertEquals(8080, HttpUrl.parse("http://[::1]:8080/").port());
-    assertEquals("password", HttpUrl.parse("http://user:password@[::1]/").password());
-    assertEquals("::1", HttpUrl.parse("http://user:password@[::1]:8080/").host());
-
-    // Permit the contents of IPv6 addresses to be percent-encoded...
-    assertEquals("::1", HttpUrl.parse("http://[%3A%3A%31]/").host());
-
-    // Including the Square braces themselves! (This is what Chrome does.)
-    assertEquals("::1", HttpUrl.parse("http://%5B%3A%3A1%5D/").host());
-  }
-
-  @Test public void hostIpv6AddressDifferentFormats() throws Exception {
-    // Multiple representations of the same address; see http://tools.ietf.org/html/rfc5952.
-    String a3 = "2001:db8::1:0:0:1";
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0:0:1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:0db8:0:0:1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8::1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8::0:1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:0db8::1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0:0:1::1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0000:0:1::1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:DB8:0:0:1::1]").host());
-  }
-
-  @Test public void hostIpv6AddressLeadingCompression() throws Exception {
-    assertEquals("::1", HttpUrl.parse("http://[::0001]").host());
-    assertEquals("::1", HttpUrl.parse("http://[0000::0001]").host());
-    assertEquals("::1", HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001]").host());
-    assertEquals("::1", HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000::0001]").host());
-  }
-
-  @Test public void hostIpv6AddressTrailingCompression() throws Exception {
-    assertEquals("1::", HttpUrl.parse("http://[0001:0000::]").host());
-    assertEquals("1::", HttpUrl.parse("http://[0001::0000]").host());
-    assertEquals("1::", HttpUrl.parse("http://[0001::]").host());
-    assertEquals("1::", HttpUrl.parse("http://[1::]").host());
-  }
-
-  @Test public void hostIpv6AddressTooManyDigitsInGroup() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000:0000:0000:0000:0001]"));
-    assertEquals(null, HttpUrl.parse("http://[::00001]"));
-  }
-
-  @Test public void hostIpv6AddressMisplacedColons() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[:0000:0000:0000:0000:0000:0000:0000:0001]"));
-    assertEquals(null, HttpUrl.parse("http://[:::0000:0000:0000:0000:0000:0000:0000:0001]"));
-    assertEquals(null, HttpUrl.parse("http://[:1]"));
-    assertEquals(null, HttpUrl.parse("http://[:::1]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0001:]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001:]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001::]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001:::]"));
-    assertEquals(null, HttpUrl.parse("http://[1:]"));
-    assertEquals(null, HttpUrl.parse("http://[1:::]"));
-    assertEquals(null, HttpUrl.parse("http://[1:::1]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000::0000:0000:0000:0001]"));
-  }
-
-  @Test public void hostIpv6AddressTooManyGroups() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0000:0001]"));
-  }
-
-  @Test public void hostIpv6AddressTooMuchCompression() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[0000::0000:0000:0000:0000::0001]"));
-    assertEquals(null, HttpUrl.parse("http://[::0000:0000:0000:0000::0001]"));
-  }
-
-  @Test public void hostIpv6ScopedAddress() throws Exception {
-    // java.net.InetAddress parses scoped addresses. These aren't valid in URLs.
-    assertEquals(null, HttpUrl.parse("http://[::1%2544]"));
-  }
-
-  @Test public void hostIpv6WithIpv4Suffix() throws Exception {
-    assertEquals("::1:ffff:ffff", HttpUrl.parse("http://[::1:255.255.255.255]/").host());
-    assertEquals("::1:0:0", HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.0]/").host());
-  }
-
-  @Test public void hostIpv6WithIpv4SuffixWithOctalPrefix() throws Exception {
-    // Chrome interprets a leading '0' as octal; Firefox rejects them. (We reject them.)
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.000000]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.010.0.010]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.000001]/"));
-  }
-
-  @Test public void hostIpv6WithIpv4SuffixWithHexadecimalPrefix() throws Exception {
-    // Chrome interprets a leading '0x' as hexadecimal; Firefox rejects them. (We reject them.)
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0x10.0.0x10]/"));
-  }
-
-  @Test public void hostIpv6WithMalformedIpv4Suffix() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0:0.0]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0-0.0]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255..255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255..255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:0:1:255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:256.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:ff.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:0:1:255.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:1:255.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:1:0.0.0.0:1]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0.0.0.0:1:0:0:0:0:1]/"));
-    assertEquals(null, HttpUrl.parse("http://[0.0.0.0:0:0:0:0:0:1]/"));
-  }
-
-  @Test public void hostIpv6WithIncompleteIpv4Suffix() throws Exception {
-    // To Chrome & Safari these are well-formed; Firefox disagrees. (We're consistent with Firefox).
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255.255.]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255.255]/"));
-  }
-
-  @Test public void hostIpv6CanonicalForm() throws Exception {
-    assertEquals("abcd:ef01:2345:6789:abcd:ef01:2345:6789",
-        HttpUrl.parse("http://[abcd:ef01:2345:6789:abcd:ef01:2345:6789]/").host());
-    assertEquals("a::b:0:0:0", HttpUrl.parse("http://[a:0:0:0:b:0:0:0]/").host());
-    assertEquals("a:b:0:0:c::", HttpUrl.parse("http://[a:b:0:0:c:0:0:0]/").host());
-    assertEquals("a:b::c:0:0", HttpUrl.parse("http://[a:b:0:0:0:c:0:0]/").host());
-    assertEquals("a::b:0:0:0", HttpUrl.parse("http://[a:0:0:0:b:0:0:0]/").host());
-    assertEquals("::a:b:0:0:0", HttpUrl.parse("http://[0:0:0:a:b:0:0:0]/").host());
-    assertEquals("::a:0:0:0:b", HttpUrl.parse("http://[0:0:0:a:0:0:0:b]/").host());
-    assertEquals("0:a:b:c:d:e:f:1", HttpUrl.parse("http://[0:a:b:c:d:e:f:1]/").host());
-    assertEquals("a:b:c:d:e:f:1:0", HttpUrl.parse("http://[a:b:c:d:e:f:1:0]/").host());
-    assertEquals("ff01::101", HttpUrl.parse("http://[FF01:0:0:0:0:0:0:101]/").host());
-    assertEquals("2001:db8::1", HttpUrl.parse("http://[2001:db8::1]/").host());
-    assertEquals("2001:db8::2:1", HttpUrl.parse("http://[2001:db8:0:0:0:0:2:1]/").host());
-    assertEquals("2001:db8:0:1:1:1:1:1", HttpUrl.parse("http://[2001:db8:0:1:1:1:1:1]/").host());
-    assertEquals("2001:db8::1:0:0:1", HttpUrl.parse("http://[2001:db8:0:0:1:0:0:1]/").host());
-    assertEquals("2001:0:0:1::1", HttpUrl.parse("http://[2001:0:0:1:0:0:0:1]/").host());
-    assertEquals("1::", HttpUrl.parse("http://[1:0:0:0:0:0:0:0]/").host());
-    assertEquals("::1", HttpUrl.parse("http://[0:0:0:0:0:0:0:1]/").host());
-    assertEquals("::", HttpUrl.parse("http://[0:0:0:0:0:0:0:0]/").host());
-  }
-
-  /** The builder permits square braces but does not require them. */
-  @Test public void hostIPv6Builder() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://example.com/");
-    assertEquals("http://[::1]/", base.newBuilder().host("[::1]").build().toString());
-    assertEquals("http://[::1]/", base.newBuilder().host("[::0001]").build().toString());
-    assertEquals("http://[::1]/", base.newBuilder().host("::1").build().toString());
-    assertEquals("http://[::1]/", base.newBuilder().host("::0001").build().toString());
-  }
-
-  @Test public void hostIpv4CanonicalForm() throws Exception {
-    assertEquals("255.255.255.255", HttpUrl.parse("http://255.255.255.255/").host());
-    assertEquals("1.2.3.4", HttpUrl.parse("http://1.2.3.4/").host());
-    assertEquals("0.0.0.0", HttpUrl.parse("http://0.0.0.0/").host());
-  }
-
-  @Ignore("java.net.IDN strips trailing trailing dots on Java 7, but not on Java 8.")
-  @Test public void hostWithTrailingDot() throws Exception {
-    assertEquals("host.", HttpUrl.parse("http://host./").host());
-  }
-
-  @Test public void port() throws Exception {
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host:80/"));
-    assertEquals(HttpUrl.parse("http://host:99/"), HttpUrl.parse("http://host:99/"));
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host:/"));
-    assertEquals(65535, HttpUrl.parse("http://host:65535/").port());
-    assertEquals(null, HttpUrl.parse("http://host:0/"));
-    assertEquals(null, HttpUrl.parse("http://host:65536/"));
-    assertEquals(null, HttpUrl.parse("http://host:-1/"));
-    assertEquals(null, HttpUrl.parse("http://host:a/"));
-    assertEquals(null, HttpUrl.parse("http://host:%39%39/"));
-  }
-
-  @Test public void pathCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.PERCENT, '^', '{', '}', '|')
-        .override(Encoding.SKIP, '\\', '?', '#')
-        .skipForUri('%', '[', ']')
-        .test(Component.PATH);
-  }
-
-  @Test public void queryCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.IDENTITY, '?', '`')
-        .override(Encoding.PERCENT, '\'')
-        .override(Encoding.SKIP, '#', '+')
-        .skipForUri('%', '\\', '^', '`', '{', '|', '}')
-        .test(Component.QUERY);
-  }
-
-  @Test public void queryValueCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.IDENTITY, '?', '`')
-        .override(Encoding.PERCENT, '\'')
-        .override(Encoding.SKIP, '#', '+')
-        .skipForUri('%', '\\', '^', '`', '{', '|', '}')
-        .test(Component.QUERY_VALUE);
-  }
-
-  @Test public void fragmentCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.IDENTITY, ' ', '"', '#', '<', '>', '?', '`')
-        .skipForUri('%', ' ', '"', '#', '<', '>', '\\', '^', '`', '{', '|', '}')
-        .identityForNonAscii()
-        .test(Component.FRAGMENT);
-  }
-
-  @Test public void fragmentNonAscii() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#Œ£");
-    assertEquals("http://host/#Œ£", url.toString());
-    assertEquals("Œ£", url.fragment());
-    assertEquals("Œ£", url.encodedFragment());
-    assertEquals("http://host/#Œ£", url.uri().toString());
-  }
-
-  @Test public void fragmentNonAsciiThatOffendsJavaNetUri() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#\u0080");
-    assertEquals("http://host/#\u0080", url.toString());
-    assertEquals("\u0080", url.fragment());
-    assertEquals("\u0080", url.encodedFragment());
-    assertEquals(new URI("http://host/#"), url.uri()); // Control characters may be stripped!
-  }
-
-  @Test public void fragmentPercentEncodedNonAscii() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#%C2%80");
-    assertEquals("http://host/#%C2%80", url.toString());
-    assertEquals("\u0080", url.fragment());
-    assertEquals("%C2%80", url.encodedFragment());
-    assertEquals("http://host/#%C2%80", url.uri().toString());
-  }
-
-  @Test public void fragmentPercentEncodedPartialCodePoint() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#%80");
-    assertEquals("http://host/#%80", url.toString());
-    assertEquals("\ufffd", url.fragment()); // Unicode replacement character.
-    assertEquals("%80", url.encodedFragment());
-    assertEquals("http://host/#%80", url.uri().toString());
-  }
-
-  @Test public void relativePath() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("d/e/f"));
-    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("../../d/e/f"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".."));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../.."));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../.."));
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("././.."));
-    assertEquals(HttpUrl.parse("http://host/a/b/c/"), base.resolve("c/d/../e/../"));
-    assertEquals(HttpUrl.parse("http://host/a/b/..e/"), base.resolve("..e/"));
-    assertEquals(HttpUrl.parse("http://host/a/b/e/f../"), base.resolve("e/f../"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2E."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".%2E"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2E%2E"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2e."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".%2e"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2e%2e"));
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("%2E"));
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("%2e"));
-  }
-
-  @Test public void relativePathWithTrailingSlash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c/");
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve(".."));
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("../"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../.."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../../"));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../.."));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../"));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../.."));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../../"));
-    assertEquals(HttpUrl.parse("http://host/a"), base.resolve("../../../../a"));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../../a/.."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../../../../a/b/.."));
-  }
-
-  @Test public void pathWithBackslash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("d\\e\\f"));
-    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("../..\\d\\e\\f"));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("..\\.."));
-  }
-
-  @Test public void relativePathWithSameScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("http:d/e/f"));
-    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("http:../../d/e/f"));
-  }
-
-  @Test public void decodeUsername() {
-    assertEquals("user", HttpUrl.parse("http://user@host/").username());
-    assertEquals("\uD83C\uDF69", HttpUrl.parse("http://%F0%9F%8D%A9@host/").username());
-  }
-
-  @Test public void decodePassword() {
-    assertEquals("password", HttpUrl.parse("http://user:password@host/").password());
-    assertEquals("", HttpUrl.parse("http://user:@host/").password());
-    assertEquals("\uD83C\uDF69", HttpUrl.parse("http://user:%F0%9F%8D%A9@host/").password());
-  }
-
-  @Test public void decodeSlashCharacterInDecodedPathSegment() {
-    assertEquals(Arrays.asList("a/b/c"),
-        HttpUrl.parse("http://host/a%2Fb%2Fc").pathSegments());
-  }
-
-  @Test public void decodeEmptyPathSegments() {
-    assertEquals(Arrays.asList(""),
-        HttpUrl.parse("http://host/").pathSegments());
-  }
-
-  @Test public void percentDecode() throws Exception {
-    assertEquals(Arrays.asList("\u0000"),
-        HttpUrl.parse("http://host/%00").pathSegments());
-    assertEquals(Arrays.asList("a", "\u2603", "c"),
-        HttpUrl.parse("http://host/a/%E2%98%83/c").pathSegments());
-    assertEquals(Arrays.asList("a", "\uD83C\uDF69", "c"),
-        HttpUrl.parse("http://host/a/%F0%9F%8D%A9/c").pathSegments());
-    assertEquals(Arrays.asList("a", "b", "c"),
-        HttpUrl.parse("http://host/a/%62/c").pathSegments());
-    assertEquals(Arrays.asList("a", "z", "c"),
-        HttpUrl.parse("http://host/a/%7A/c").pathSegments());
-    assertEquals(Arrays.asList("a", "z", "c"),
-        HttpUrl.parse("http://host/a/%7a/c").pathSegments());
-  }
-
-  @Test public void malformedPercentEncoding() {
-    assertEquals(Arrays.asList("a%f", "b"),
-        HttpUrl.parse("http://host/a%f/b").pathSegments());
-    assertEquals(Arrays.asList("%", "b"),
-        HttpUrl.parse("http://host/%/b").pathSegments());
-    assertEquals(Arrays.asList("%"),
-        HttpUrl.parse("http://host/%").pathSegments());
-    assertEquals(Arrays.asList("%00"),
-        HttpUrl.parse("http://github.com/%%30%30").pathSegments());
-  }
-
-  @Test public void malformedUtf8Encoding() {
-    // Replace a partial UTF-8 sequence with the Unicode replacement character.
-    assertEquals(Arrays.asList("a", "\ufffdx", "c"),
-        HttpUrl.parse("http://host/a/%E2%98x/c").pathSegments());
-  }
-
-  @Test public void incompleteUrlComposition() throws Exception {
-    try {
-      new HttpUrl.Builder().scheme("http").build();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertEquals("host == null", expected.getMessage());
-    }
-    try {
-      new HttpUrl.Builder().host("host").build();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertEquals("scheme == null", expected.getMessage());
-    }
-  }
-
-  @Test public void minimalUrlComposition() throws Exception {
-    HttpUrl url = new HttpUrl.Builder().scheme("http").host("host").build();
-    assertEquals("http://host/", url.toString());
-    assertEquals("http", url.scheme());
-    assertEquals("", url.username());
-    assertEquals("", url.password());
-    assertEquals("host", url.host());
-    assertEquals(80, url.port());
-    assertEquals("/", url.encodedPath());
-    assertEquals(null, url.query());
-    assertEquals(null, url.fragment());
-  }
-
-  @Test public void fullUrlComposition() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .username("username")
-        .password("password")
-        .host("host")
-        .port(8080)
-        .addPathSegment("path")
-        .query("query")
-        .fragment("fragment")
-        .build();
-    assertEquals("http://username:password@host:8080/path?query#fragment", url.toString());
-    assertEquals("http", url.scheme());
-    assertEquals("username", url.username());
-    assertEquals("password", url.password());
-    assertEquals("host", url.host());
-    assertEquals(8080, url.port());
-    assertEquals("/path", url.encodedPath());
-    assertEquals("query", url.query());
-    assertEquals("fragment", url.fragment());
-  }
-
-  @Test public void changingSchemeChangesDefaultPort() throws Exception {
-    assertEquals(443, HttpUrl.parse("http://example.com")
-        .newBuilder()
-        .scheme("https")
-        .build().port());
-
-    assertEquals(80, HttpUrl.parse("https://example.com")
-        .newBuilder()
-        .scheme("http")
-        .build().port());
-
-    assertEquals(1234, HttpUrl.parse("https://example.com:1234")
-        .newBuilder()
-        .scheme("http")
-        .build().port());
-  }
-
-  @Test public void composeEncodesWhitespace() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .username("a\r\n\f\t b")
-        .password("c\r\n\f\t d")
-        .host("host")
-        .addPathSegment("e\r\n\f\t f")
-        .query("g\r\n\f\t h")
-        .fragment("i\r\n\f\t j")
-        .build();
-    assertEquals("http://a%0D%0A%0C%09%20b:c%0D%0A%0C%09%20d@host"
-        + "/e%0D%0A%0C%09%20f?g%0D%0A%0C%09%20h#i%0D%0A%0C%09 j", url.toString());
-    assertEquals("a\r\n\f\t b", url.username());
-    assertEquals("c\r\n\f\t d", url.password());
-    assertEquals("e\r\n\f\t f", url.pathSegments().get(0));
-    assertEquals("g\r\n\f\t h", url.query());
-    assertEquals("i\r\n\f\t j", url.fragment());
-  }
-
-  @Test public void composeFromUnencodedComponents() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .username("a:\u0001@/\\?#%b")
-        .password("c:\u0001@/\\?#%d")
-        .host("ef")
-        .port(8080)
-        .addPathSegment("g:\u0001@/\\?#%h")
-        .query("i:\u0001@/\\?#%j")
-        .fragment("k:\u0001@/\\?#%l")
-        .build();
-    assertEquals("http://a%3A%01%40%2F%5C%3F%23%25b:c%3A%01%40%2F%5C%3F%23%25d@ef:8080/"
-        + "g:%01@%2F%5C%3F%23%25h?i:%01@/\\?%23%25j#k:%01@/\\?#%25l", url.toString());
-    assertEquals("http", url.scheme());
-    assertEquals("a:\u0001@/\\?#%b", url.username());
-    assertEquals("c:\u0001@/\\?#%d", url.password());
-    assertEquals(Arrays.asList("g:\u0001@/\\?#%h"), url.pathSegments());
-    assertEquals("i:\u0001@/\\?#%j", url.query());
-    assertEquals("k:\u0001@/\\?#%l", url.fragment());
-    assertEquals("a%3A%01%40%2F%5C%3F%23%25b", url.encodedUsername());
-    assertEquals("c%3A%01%40%2F%5C%3F%23%25d", url.encodedPassword());
-    assertEquals("/g:%01@%2F%5C%3F%23%25h", url.encodedPath());
-    assertEquals("i:%01@/\\?%23%25j", url.encodedQuery());
-    assertEquals("k:%01@/\\?#%25l", url.encodedFragment());
-  }
-
-  @Test public void composeFromEncodedComponents() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .encodedUsername("a:\u0001@/\\?#%25b")
-        .encodedPassword("c:\u0001@/\\?#%25d")
-        .host("ef")
-        .port(8080)
-        .addEncodedPathSegment("g:\u0001@/\\?#%25h")
-        .encodedQuery("i:\u0001@/\\?#%25j")
-        .encodedFragment("k:\u0001@/\\?#%25l")
-        .build();
-    assertEquals("http://a%3A%01%40%2F%5C%3F%23%25b:c%3A%01%40%2F%5C%3F%23%25d@ef:8080/"
-        + "g:%01@%2F%5C%3F%23%25h?i:%01@/\\?%23%25j#k:%01@/\\?#%25l", url.toString());
-    assertEquals("http", url.scheme());
-    assertEquals("a:\u0001@/\\?#%b", url.username());
-    assertEquals("c:\u0001@/\\?#%d", url.password());
-    assertEquals(Arrays.asList("g:\u0001@/\\?#%h"), url.pathSegments());
-    assertEquals("i:\u0001@/\\?#%j", url.query());
-    assertEquals("k:\u0001@/\\?#%l", url.fragment());
-    assertEquals("a%3A%01%40%2F%5C%3F%23%25b", url.encodedUsername());
-    assertEquals("c%3A%01%40%2F%5C%3F%23%25d", url.encodedPassword());
-    assertEquals("/g:%01@%2F%5C%3F%23%25h", url.encodedPath());
-    assertEquals("i:%01@/\\?%23%25j", url.encodedQuery());
-    assertEquals("k:%01@/\\?#%25l", url.encodedFragment());
-  }
-
-  @Test public void composeWithEncodedPath() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .encodedPath("/a%2Fb/c")
-        .build();
-    assertEquals("http://host/a%2Fb/c", url.toString());
-    assertEquals("/a%2Fb/c", url.encodedPath());
-    assertEquals(Arrays.asList("a/b", "c"), url.pathSegments());
-  }
-
-  @Test public void composeMixingPathSegments() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .encodedPath("/a%2fb/c")
-        .addPathSegment("d%25e")
-        .addEncodedPathSegment("f%25g")
-        .build();
-    assertEquals("http://host/a%2fb/c/d%2525e/f%25g", url.toString());
-    assertEquals("/a%2fb/c/d%2525e/f%25g", url.encodedPath());
-    assertEquals(Arrays.asList("a%2fb", "c", "d%2525e", "f%25g"), url.encodedPathSegments());
-    assertEquals(Arrays.asList("a/b", "c", "d%25e", "f%g"), url.pathSegments());
-  }
-
-  @Test public void composeWithAddSegment() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals("/a/b/c/", base.newBuilder().addPathSegment("").build().encodedPath());
-    assertEquals("/a/b/c/d",
-        base.newBuilder().addPathSegment("").addPathSegment("d").build().encodedPath());
-    assertEquals("/a/b/", base.newBuilder().addPathSegment("..").build().encodedPath());
-    assertEquals("/a/b/", base.newBuilder().addPathSegment("").addPathSegment("..").build()
-        .encodedPath());
-    assertEquals("/a/b/c/", base.newBuilder().addPathSegment("").addPathSegment("").build()
-        .encodedPath());
-  }
-
-  @Test public void pathSize() throws Exception {
-    assertEquals(1, HttpUrl.parse("http://host/").pathSize());
-    assertEquals(3, HttpUrl.parse("http://host/a/b/c").pathSize());
-  }
-
-  @Test public void addPathSegments() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-
-    // Add a string with zero slashes: resulting URL gains one slash.
-    assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
-    assertEquals("/a/b/c/d", base.newBuilder().addPathSegments("d").build().encodedPath());
-
-    // Add a string with one slash: resulting URL gains two slashes.
-    assertEquals("/a/b/c//", base.newBuilder().addPathSegments("/").build().encodedPath());
-    assertEquals("/a/b/c/d/", base.newBuilder().addPathSegments("d/").build().encodedPath());
-    assertEquals("/a/b/c//d", base.newBuilder().addPathSegments("/d").build().encodedPath());
-
-    // Add a string with two slashes: resulting URL gains three slashes.
-    assertEquals("/a/b/c///", base.newBuilder().addPathSegments("//").build().encodedPath());
-    assertEquals("/a/b/c//d/", base.newBuilder().addPathSegments("/d/").build().encodedPath());
-    assertEquals("/a/b/c/d//", base.newBuilder().addPathSegments("d//").build().encodedPath());
-    assertEquals("/a/b/c///d", base.newBuilder().addPathSegments("//d").build().encodedPath());
-    assertEquals("/a/b/c/d/e/f", base.newBuilder().addPathSegments("d/e/f").build().encodedPath());
-  }
-
-  @Test public void addPathSegmentsOntoTrailingSlash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c/");
-
-    // Add a string with zero slashes: resulting URL gains zero slashes.
-    assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
-    assertEquals("/a/b/c/d", base.newBuilder().addPathSegments("d").build().encodedPath());
-
-    // Add a string with one slash: resulting URL gains one slash.
-    assertEquals("/a/b/c//", base.newBuilder().addPathSegments("/").build().encodedPath());
-    assertEquals("/a/b/c/d/", base.newBuilder().addPathSegments("d/").build().encodedPath());
-    assertEquals("/a/b/c//d", base.newBuilder().addPathSegments("/d").build().encodedPath());
-
-    // Add a string with two slashes: resulting URL gains two slashes.
-    assertEquals("/a/b/c///", base.newBuilder().addPathSegments("//").build().encodedPath());
-    assertEquals("/a/b/c//d/", base.newBuilder().addPathSegments("/d/").build().encodedPath());
-    assertEquals("/a/b/c/d//", base.newBuilder().addPathSegments("d//").build().encodedPath());
-    assertEquals("/a/b/c///d", base.newBuilder().addPathSegments("//d").build().encodedPath());
-    assertEquals("/a/b/c/d/e/f", base.newBuilder().addPathSegments("d/e/f").build().encodedPath());
-  }
-
-  @Test public void addPathSegmentsWithBackslash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/");
-    assertEquals("/d/e", base.newBuilder().addPathSegments("d\\e").build().encodedPath());
-    assertEquals("/d/e", base.newBuilder().addEncodedPathSegments("d\\e").build().encodedPath());
-  }
-
-  @Test public void addPathSegmentsWithEmptyPaths() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals("/a/b/c//d/e///f",
-        base.newBuilder().addPathSegments("/d/e///f").build().encodedPath());
-  }
-
-  @Test public void addEncodedPathSegments() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals("/a/b/c/d/e/%20/",
-        base.newBuilder().addEncodedPathSegments("d/e/%20/\n").build().encodedPath());
-  }
-
-  @Test public void addPathSegmentDotDoesNothing() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals("/a/b/c", base.newBuilder().addPathSegment(".").build().encodedPath());
-  }
-
-  @Test public void addPathSegmentEncodes() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals("/a/b/c/%252e",
-        base.newBuilder().addPathSegment("%2e").build().encodedPath());
-    assertEquals("/a/b/c/%252e%252e",
-        base.newBuilder().addPathSegment("%2e%2e").build().encodedPath());
-  }
-
-  @Test public void addPathSegmentDotDotPopsDirectory() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals("/a/b/", base.newBuilder().addPathSegment("..").build().encodedPath());
-  }
-
-  @Test public void addPathSegmentDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals("/a/b/c/.%0A", base.newBuilder().addPathSegment(".\n").build().encodedPath());
-  }
-
-  @Test public void addEncodedPathSegmentDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals("/a/b/c", base.newBuilder().addEncodedPathSegment(".\n").build().encodedPath());
-  }
-
-  @Test public void addEncodedPathSegmentDotDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals("/a/b/", base.newBuilder().addEncodedPathSegment("..\n").build().encodedPath());
-  }
-
-  @Test public void setPathSegment() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals("/d/b/c", base.newBuilder().setPathSegment(0, "d").build().encodedPath());
-    assertEquals("/a/d/c", base.newBuilder().setPathSegment(1, "d").build().encodedPath());
-    assertEquals("/a/b/d", base.newBuilder().setPathSegment(2, "d").build().encodedPath());
-  }
-
-  @Test public void setPathSegmentEncodes() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals("/%2525/b/c", base.newBuilder().setPathSegment(0, "%25").build().encodedPath());
-    assertEquals("/.%0A/b/c", base.newBuilder().setPathSegment(0, ".\n").build().encodedPath());
-    assertEquals("/%252e/b/c", base.newBuilder().setPathSegment(0, "%2e").build().encodedPath());
-  }
-
-  @Test public void setPathSegmentAcceptsEmpty() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals("//b/c", base.newBuilder().setPathSegment(0, "").build().encodedPath());
-    assertEquals("/a/b/", base.newBuilder().setPathSegment(2, "").build().encodedPath());
-  }
-
-  @Test public void setPathSegmentRejectsDot() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setPathSegment(0, ".");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setPathSegmentRejectsDotDot() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setPathSegment(0, "..");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setPathSegmentWithSlash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    HttpUrl url = base.newBuilder().setPathSegment(1, "/").build();
-    assertEquals("/a/%2F/c", url.encodedPath());
-  }
-
-  @Test public void setPathSegmentOutOfBounds() throws Exception {
-    try {
-      new HttpUrl.Builder().setPathSegment(1, "a");
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void setEncodedPathSegmentEncodes() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals("/%25/b/c",
-        base.newBuilder().setEncodedPathSegment(0, "%25").build().encodedPath());
-  }
-
-  @Test public void setEncodedPathSegmentRejectsDot() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setEncodedPathSegment(0, ".");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setEncodedPathSegmentRejectsDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setEncodedPathSegment(0, ".\n");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setEncodedPathSegmentRejectsDotDot() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setEncodedPathSegment(0, "..");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setEncodedPathSegmentRejectsDotDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setEncodedPathSegment(0, "..\n");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setEncodedPathSegmentWithSlash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    HttpUrl url = base.newBuilder().setEncodedPathSegment(1, "/").build();
-    assertEquals("/a/%2F/c", url.encodedPath());
-  }
-
-  @Test public void setEncodedPathSegmentOutOfBounds() throws Exception {
-    try {
-      new HttpUrl.Builder().setEncodedPathSegment(1, "a");
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void removePathSegment() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    HttpUrl url = base.newBuilder()
-        .removePathSegment(0)
-        .build();
-    assertEquals("/b/c", url.encodedPath());
-  }
-
-  @Test public void removePathSegmentDoesntRemovePath() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    HttpUrl url = base.newBuilder()
-        .removePathSegment(0)
-        .removePathSegment(0)
-        .removePathSegment(0)
-        .build();
-    assertEquals(Arrays.asList(""), url.pathSegments());
-    assertEquals("/", url.encodedPath());
-  }
-
-  @Test public void removePathSegmentOutOfBounds() throws Exception {
-    try {
-      new HttpUrl.Builder().removePathSegment(1);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void toJavaNetUrl() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://username:password@host/path?query#fragment");
-    URL javaNetUrl = httpUrl.url();
-    assertEquals("http://username:password@host/path?query#fragment", javaNetUrl.toString());
-  }
-
-  @Test public void toUri() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://username:password@host/path?query#fragment");
-    URI uri = httpUrl.uri();
-    assertEquals("http://username:password@host/path?query#fragment", uri.toString());
-  }
-
-  @Test public void toUriSpecialQueryCharacters() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://host/?d=abc!@[]^`{}|\\");
-    URI uri = httpUrl.uri();
-    assertEquals("http://host/?d=abc!@[]%5E%60%7B%7D%7C%5C", uri.toString());
-  }
-
-  @Test public void toUriWithUsernameNoPassword() throws Exception {
-    HttpUrl httpUrl = new HttpUrl.Builder()
-        .scheme("http")
-        .username("user")
-        .host("host")
-        .build();
-    assertEquals("http://user@host/", httpUrl.toString());
-    assertEquals("http://user@host/", httpUrl.uri().toString());
-  }
-
-  @Test public void toUriUsernameSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .username("=[]:;\"~|?#@^/$%*")
-        .build();
-    assertEquals("http://%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/", url.toString());
-    assertEquals("http://%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/", url.uri().toString());
-  }
-
-  @Test public void toUriPasswordSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .username("user")
-        .password("=[]:;\"~|?#@^/$%*")
-        .build();
-    assertEquals("http://user:%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/", url.toString());
-    assertEquals("http://user:%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/",
-        url.uri().toString());
-  }
-
-  @Test public void toUriPathSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .addPathSegment("=[]:;\"~|?#@^/$%*")
-        .build();
-    assertEquals("http://host/=[]:;%22~%7C%3F%23@%5E%2F$%25*", url.toString());
-    assertEquals("http://host/=%5B%5D:;%22~%7C%3F%23@%5E%2F$%25*", url.uri().toString());
-  }
-
-  @Test public void toUriQueryParameterNameSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .addQueryParameter("=[]:;\"~|?#@^/$%*", "a")
-        .build();
-    assertEquals("http://host/?%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*=a",
-        url.toString());
-    assertEquals("http://host/?%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*=a",
-        url.uri().toString());
-    assertEquals("a", url.queryParameter("=[]:;\"~|?#@^/$%*"));
-  }
-
-  @Test public void toUriQueryParameterValueSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .addQueryParameter("a", "=[]:;\"~|?#@^/$%*")
-        .build();
-    assertEquals("http://host/?a=%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*",
-        url.toString());
-    assertEquals("http://host/?a=%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*",
-        url.uri().toString());
-    assertEquals("=[]:;\"~|?#@^/$%*", url.queryParameter("a"));
-  }
-
-  @Test public void toUriQueryValueSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .query("=[]:;\"~|?#@^/$%*")
-        .build();
-    assertEquals("http://host/?=[]:;%22~|?%23@^/$%25*", url.toString());
-    assertEquals("http://host/?=[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
-  }
-
-  @Test public void queryCharactersEncodedWhenComposed() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .addQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
-        .build();
-    assertEquals("http://host/?a=%21%24%28%29%2C%2F%3A%3B%3F%40%5B%5D%5C%5E%60%7B%7C%7D%7E",
-        url.toString());
-    assertEquals("!$(),/:;?@[]\\^`{|}~", url.queryParameter("a"));
-  }
-
-  /**
-   * When callers use {@code addEncodedQueryParameter()} we only encode what's strictly required.
-   * We retain the encoded (or non-encoded) state of the input.
-   */
-  @Test public void queryCharactersNotReencodedWhenComposedWithAddEncoded() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .addEncodedQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
-        .build();
-    assertEquals("http://host/?a=!$(),/:;?@[]\\^`{|}~",
-        url.toString());
-    assertEquals("!$(),/:;?@[]\\^`{|}~", url.queryParameter("a"));
-  }
-
-  /**
-   * When callers parse a URL with query components that aren't encoded, we shouldn't convert them
-   * into a canonical form because doing so could be semantically different.
-   */
-  @Test public void queryCharactersNotReencodedWhenParsed() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?a=!$(),/:;?@[]\\^`{|}~");
-    assertEquals("http://host/?a=!$(),/:;?@[]\\^`{|}~", url.toString());
-    assertEquals("!$(),/:;?@[]\\^`{|}~", url.queryParameter("a"));
-  }
-
-  @Test public void toUriFragmentSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .fragment("=[]:;\"~|?#@^/$%*")
-        .build();
-    assertEquals("http://host/#=[]:;\"~|?#@^/$%25*", url.toString());
-    assertEquals("http://host/#=[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
-  }
-
-  @Test public void toUriWithControlCharacters() throws Exception {
-    // Percent-encoded in the path.
-    assertEquals(new URI("http://host/a%00b"), HttpUrl.parse("http://host/a\u0000b").uri());
-    assertEquals(new URI("http://host/a%C2%80b"), HttpUrl.parse("http://host/a\u0080b").uri());
-    assertEquals(new URI("http://host/a%C2%9Fb"), HttpUrl.parse("http://host/a\u009fb").uri());
-    // Percent-encoded in the query.
-    assertEquals(new URI("http://host/?a%00b"), HttpUrl.parse("http://host/?a\u0000b").uri());
-    assertEquals(new URI("http://host/?a%C2%80b"), HttpUrl.parse("http://host/?a\u0080b").uri());
-    assertEquals(new URI("http://host/?a%C2%9Fb"), HttpUrl.parse("http://host/?a\u009fb").uri());
-    // Stripped from the fragment.
-    assertEquals(new URI("http://host/#a%00b"), HttpUrl.parse("http://host/#a\u0000b").uri());
-    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u0080b").uri());
-    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u009fb").uri());
-  }
-
-  @Test public void toUriWithSpaceCharacters() throws Exception {
-    // Percent-encoded in the path.
-    assertEquals(new URI("http://host/a%0Bb"), HttpUrl.parse("http://host/a\u000bb").uri());
-    assertEquals(new URI("http://host/a%20b"), HttpUrl.parse("http://host/a b").uri());
-    assertEquals(new URI("http://host/a%E2%80%89b"), HttpUrl.parse("http://host/a\u2009b").uri());
-    assertEquals(new URI("http://host/a%E3%80%80b"), HttpUrl.parse("http://host/a\u3000b").uri());
-    // Percent-encoded in the query.
-    assertEquals(new URI("http://host/?a%0Bb"), HttpUrl.parse("http://host/?a\u000bb").uri());
-    assertEquals(new URI("http://host/?a%20b"), HttpUrl.parse("http://host/?a b").uri());
-    assertEquals(new URI("http://host/?a%E2%80%89b"), HttpUrl.parse("http://host/?a\u2009b").uri());
-    assertEquals(new URI("http://host/?a%E3%80%80b"), HttpUrl.parse("http://host/?a\u3000b").uri());
-    // Stripped from the fragment.
-    assertEquals(new URI("http://host/#a%0Bb"), HttpUrl.parse("http://host/#a\u000bb").uri());
-    assertEquals(new URI("http://host/#a%20b"), HttpUrl.parse("http://host/#a b").uri());
-    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u2009b").uri());
-    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u3000b").uri());
-  }
-
-  @Test public void toUriWithNonHexPercentEscape() throws Exception {
-    assertEquals(new URI("http://host/%25xx"), HttpUrl.parse("http://host/%xx").uri());
-  }
-
-  @Test public void toUriWithTruncatedPercentEscape() throws Exception {
-    assertEquals(new URI("http://host/%25a"), HttpUrl.parse("http://host/%a").uri());
-    assertEquals(new URI("http://host/%25"), HttpUrl.parse("http://host/%").uri());
-  }
-
-  @Test public void fromJavaNetUrl() throws Exception {
-    URL javaNetUrl = new URL("http://username:password@host/path?query#fragment");
-    HttpUrl httpUrl = HttpUrl.get(javaNetUrl);
-    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
-  }
-
-  @Test public void fromJavaNetUrlUnsupportedScheme() throws Exception {
-    URL javaNetUrl = new URL("mailto:user@example.com");
-    assertEquals(null, HttpUrl.get(javaNetUrl));
-  }
-
-  @Test public void fromUri() throws Exception {
-    URI uri = new URI("http://username:password@host/path?query#fragment");
-    HttpUrl httpUrl = HttpUrl.get(uri);
-    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
-  }
-
-  @Test public void fromUriUnsupportedScheme() throws Exception {
-    URI uri = new URI("mailto:user@example.com");
-    assertEquals(null, HttpUrl.get(uri));
-  }
-
-  @Test public void fromUriPartial() throws Exception {
-    URI uri = new URI("/path");
-    assertEquals(null, HttpUrl.get(uri));
-  }
-
-  @Test public void fromJavaNetUrl_checked() throws Exception {
-    HttpUrl httpUrl = HttpUrl.getChecked("http://username:password@host/path?query#fragment");
-    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
-  }
-
-  @Test public void fromJavaNetUrlUnsupportedScheme_checked() throws Exception {
-    try {
-      HttpUrl.getChecked("mailto:user@example.com");
-      fail();
-    } catch (MalformedURLException e) {
-    }
-  }
-
-  @Test public void fromJavaNetUrlBadHost_checked() throws Exception {
-    try {
-      HttpUrl.getChecked("http://hostw ithspace/");
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void composeQueryWithComponents() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/");
-    HttpUrl url = base.newBuilder().addQueryParameter("a+=& b", "c+=& d").build();
-    assertEquals("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d", url.toString());
-    assertEquals("c+=& d", url.queryParameterValue(0));
-    assertEquals("a+=& b", url.queryParameterName(0));
-    assertEquals("c+=& d", url.queryParameter("a+=& b"));
-    assertEquals(Collections.singleton("a+=& b"), url.queryParameterNames());
-    assertEquals(singletonList("c+=& d"), url.queryParameterValues("a+=& b"));
-    assertEquals(1, url.querySize());
-    assertEquals("a+=& b=c+=& d", url.query()); // Ambiguous! (Though working as designed.)
-    assertEquals("a%2B%3D%26%20b=c%2B%3D%26%20d", url.encodedQuery());
-  }
-
-  @Test public void composeQueryWithEncodedComponents() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/");
-    HttpUrl url = base.newBuilder().addEncodedQueryParameter("a+=& b", "c+=& d").build();
-    assertEquals("http://host/?a+%3D%26%20b=c+%3D%26%20d", url.toString());
-    assertEquals("c =& d", url.queryParameter("a =& b"));
-  }
-
-  @Test public void composeQueryRemoveQueryParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
-        .addQueryParameter("a+=& b", "c+=& d")
-        .removeAllQueryParameters("a+=& b")
-        .build();
-    assertEquals("http://host/", url.toString());
-    assertEquals(null, url.queryParameter("a+=& b"));
-  }
-
-  @Test public void composeQueryRemoveEncodedQueryParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
-        .addEncodedQueryParameter("a+=& b", "c+=& d")
-        .removeAllEncodedQueryParameters("a+=& b")
-        .build();
-    assertEquals("http://host/", url.toString());
-    assertEquals(null, url.queryParameter("a =& b"));
-  }
-
-  @Test public void composeQuerySetQueryParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
-        .addQueryParameter("a+=& b", "c+=& d")
-        .setQueryParameter("a+=& b", "ef")
-        .build();
-    assertEquals("http://host/?a%2B%3D%26%20b=ef", url.toString());
-    assertEquals("ef", url.queryParameter("a+=& b"));
-  }
-
-  @Test public void composeQuerySetEncodedQueryParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
-        .addEncodedQueryParameter("a+=& b", "c+=& d")
-        .setEncodedQueryParameter("a+=& b", "ef")
-        .build();
-    assertEquals("http://host/?a+%3D%26%20b=ef", url.toString());
-    assertEquals("ef", url.queryParameter("a =& b"));
-  }
-
-  @Test public void composeQueryMultipleEncodedValuesForParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
-        .addQueryParameter("a+=& b", "c+=& d")
-        .addQueryParameter("a+=& b", "e+=& f")
-        .build();
-    assertEquals("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d&a%2B%3D%26%20b=e%2B%3D%26%20f",
-        url.toString());
-    assertEquals(2, url.querySize());
-    assertEquals(Collections.singleton("a+=& b"), url.queryParameterNames());
-    assertEquals(Arrays.asList("c+=& d", "e+=& f"), url.queryParameterValues("a+=& b"));
-  }
-
-  @Test public void absentQueryIsZeroNameValuePairs() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
-        .query(null)
-        .build();
-    assertEquals(0, url.querySize());
-  }
-
-  @Test public void emptyQueryIsSingleNameValuePairWithEmptyKey() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
-        .query("")
-        .build();
-    assertEquals(1, url.querySize());
-    assertEquals("", url.queryParameterName(0));
-    assertEquals(null, url.queryParameterValue(0));
-  }
-
-  @Test public void ampersandQueryIsTwoNameValuePairsWithEmptyKeys() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
-        .query("&")
-        .build();
-    assertEquals(2, url.querySize());
-    assertEquals("", url.queryParameterName(0));
-    assertEquals(null, url.queryParameterValue(0));
-    assertEquals("", url.queryParameterName(1));
-    assertEquals(null, url.queryParameterValue(1));
-  }
-
-  @Test public void removeAllDoesNotRemoveQueryIfNoParametersWereRemoved() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
-        .query("")
-        .removeAllQueryParameters("a")
-        .build();
-    assertEquals("http://host/?", url.toString());
-  }
-
-  @Test public void queryParametersWithoutValues() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?foo&bar&baz");
-    assertEquals(3, url.querySize());
-    assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
-        url.queryParameterNames());
-    assertEquals(null, url.queryParameterValue(0));
-    assertEquals(null, url.queryParameterValue(1));
-    assertEquals(null, url.queryParameterValue(2));
-    assertEquals(singletonList((String) null), url.queryParameterValues("foo"));
-    assertEquals(singletonList((String) null), url.queryParameterValues("bar"));
-    assertEquals(singletonList((String) null), url.queryParameterValues("baz"));
-  }
-
-  @Test public void queryParametersWithEmptyValues() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?foo=&bar=&baz=");
-    assertEquals(3, url.querySize());
-    assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
-        url.queryParameterNames());
-    assertEquals("", url.queryParameterValue(0));
-    assertEquals("", url.queryParameterValue(1));
-    assertEquals("", url.queryParameterValue(2));
-    assertEquals(singletonList(""), url.queryParameterValues("foo"));
-    assertEquals(singletonList(""), url.queryParameterValues("bar"));
-    assertEquals(singletonList(""), url.queryParameterValues("baz"));
-  }
-
-  @Test public void queryParametersWithRepeatedName() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?foo[]=1&foo[]=2&foo[]=3");
-    assertEquals(3, url.querySize());
-    assertEquals(Collections.singleton("foo[]"), url.queryParameterNames());
-    assertEquals("1", url.queryParameterValue(0));
-    assertEquals("2", url.queryParameterValue(1));
-    assertEquals("3", url.queryParameterValue(2));
-    assertEquals(Arrays.asList("1", "2", "3"), url.queryParameterValues("foo[]"));
-  }
-
-  @Test public void queryParameterLookupWithNonCanonicalEncoding() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?%6d=m&+=%20");
-    assertEquals("m", url.queryParameterName(0));
-    assertEquals(" ", url.queryParameterName(1));
-    assertEquals("m", url.queryParameter("m"));
-    assertEquals(" ", url.queryParameter(" "));
-  }
-
-  @Test public void parsedQueryDoesntIncludeFragment() {
-    HttpUrl url = HttpUrl.parse("http://host/?#fragment");
-    assertEquals("fragment", url.fragment());
-    assertEquals("", url.query());
-    assertEquals("", url.encodedQuery());
-  }
-
-  @Test public void roundTripBuilder() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .username("%")
-        .password("%")
-        .host("host")
-        .addPathSegment("%")
-        .query("%")
-        .fragment("%")
-        .build();
-    assertEquals("http://%25:%25@host/%25?%25#%25", url.toString());
-    assertEquals("http://%25:%25@host/%25?%25#%25", url.newBuilder().build().toString());
-    assertEquals("http://%25:%25@host/%25?%25", url.resolve("").toString());
-  }
-
-  /**
-   * Although HttpUrl prefers percent-encodings in uppercase, it should preserve the exact structure
-   * of the original encoding.
-   */
-  @Test public void rawEncodingRetained() throws Exception {
-    String urlString = "http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D#%6d%6D";
-    HttpUrl url = HttpUrl.parse(urlString);
-    assertEquals("%6d%6D", url.encodedUsername());
-    assertEquals("%6d%6D", url.encodedPassword());
-    assertEquals("/%6d%6D", url.encodedPath());
-    assertEquals(Arrays.asList("%6d%6D"), url.encodedPathSegments());
-    assertEquals("%6d%6D", url.encodedQuery());
-    assertEquals("%6d%6D", url.encodedFragment());
-    assertEquals(urlString, url.toString());
-    assertEquals(urlString, url.newBuilder().build().toString());
-    assertEquals("http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D", url.resolve("").toString());
-  }
-
-  @Test public void clearFragment() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#fragment")
-        .newBuilder()
-        .fragment(null)
-        .build();
-    assertEquals("http://host/", url.toString());
-    assertEquals(null, url.fragment());
-    assertEquals(null, url.encodedFragment());
-  }
-
-  @Test public void clearEncodedFragment() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#fragment")
-        .newBuilder()
-        .encodedFragment(null)
-        .build();
-    assertEquals("http://host/", url.toString());
-    assertEquals(null, url.fragment());
-    assertEquals(null, url.encodedFragment());
-  }
-
-  @Test public void topPrivateDomain() {
-    assertEquals("google.com", HttpUrl.parse("https://google.com").topPrivateDomain());
-    assertEquals("google.co.uk", HttpUrl.parse("https://adwords.google.co.uk").topPrivateDomain());
-    assertEquals("xn--ewv.xn--4pvxs.jp", HttpUrl.parse("https://Ê†É.Ê†ÉÊú®.jp").topPrivateDomain());
-    assertEquals("xn--ewv.xn--4pvxs.jp",
-        HttpUrl.parse("https://xn--ewv.xn--4pvxs.jp").topPrivateDomain());
-
-    assertNull(HttpUrl.parse("https://co.uk").topPrivateDomain());
-    assertNull(HttpUrl.parse("https://square").topPrivateDomain());
-    assertNull(HttpUrl.parse("https://Ê†ÉÊú®.jp").topPrivateDomain());
-    assertNull(HttpUrl.parse("https://xn--4pvxs.jp").topPrivateDomain());
-    assertNull(HttpUrl.parse("https://localhost").topPrivateDomain());
-    assertNull(HttpUrl.parse("https://127.0.0.1").topPrivateDomain());
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
deleted file mode 100644
index b2d3f396fa..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- * Copyright (C) 2011 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.nio.charset.Charset;
-import okhttp3.internal.Util;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-
-/**
- * Test MediaType API and parsing.
- *
- * <p>This test includes tests from <a href="https://code.google.com/p/guava-libraries/">Guava's</a>
- * MediaTypeTest.
- */
-public class MediaTypeTest {
-  @Test public void testParse() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;boundary=foo;charset=utf-8");
-    assertEquals("text", mediaType.type());
-    assertEquals("plain", mediaType.subtype());
-    assertEquals("UTF-8", mediaType.charset().name());
-    assertEquals("text/plain;boundary=foo;charset=utf-8", mediaType.toString());
-    assertTrue(mediaType.equals(MediaType.parse("text/plain;boundary=foo;charset=utf-8")));
-    assertEquals(mediaType.hashCode(),
-        MediaType.parse("text/plain;boundary=foo;charset=utf-8").hashCode());
-  }
-
-  @Test public void testValidParse() throws Exception {
-    assertMediaType("text/plain");
-    assertMediaType("application/atom+xml; charset=utf-8");
-    assertMediaType("application/atom+xml; a=1; a=2; b=3");
-    assertMediaType("image/gif; foo=bar");
-    assertMediaType("text/plain; a=1");
-    assertMediaType("text/plain; a=1; a=2; b=3");
-    assertMediaType("text/plain; charset=utf-16");
-    assertMediaType("text/plain; \t \n \r a=b");
-    assertMediaType("text/plain;");
-    assertMediaType("text/plain; ");
-    assertMediaType("text/plain; a=1;");
-    assertMediaType("text/plain; a=1; ");
-    assertMediaType("text/plain; a=1;; b=2");
-    assertMediaType("text/plain;;");
-    assertMediaType("text/plain; ;");
-  }
-
-  @Test public void testInvalidParse() throws Exception {
-    assertInvalid("");
-    assertInvalid("/");
-    assertInvalid("/");
-    assertInvalid("text");
-    assertInvalid("text/");
-    assertInvalid("te<t/plain");
-    assertInvalid("text/pl@in");
-    assertInvalid("text/plain; a");
-    assertInvalid("text/plain; a=");
-    assertInvalid("text/plain; a=@");
-    assertInvalid("text/plain; a=\"@");
-    assertInvalid("text/plain; a=1; b");
-    assertInvalid("text/plain; a=1; b=");
-    assertInvalid("text/plain; a=\u2025");
-    assertInvalid(" text/plain");
-    assertInvalid("te xt/plain");
-    assertInvalid("text /plain");
-    assertInvalid("text/ plain");
-    assertInvalid("text/pl ain");
-    assertInvalid("text/plain ");
-    assertInvalid("text/plain ; a=1");
-  }
-
-  @Test public void testDoubleQuotesAreSpecial() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;a=\";charset=utf-8;b=\"");
-    assertNull(mediaType.charset());
-  }
-
-  @Test public void testSingleQuotesAreNotSpecial() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;a=';charset=utf-8;b='");
-    assertEquals("UTF-8", mediaType.charset().name());
-  }
-
-  @Test public void testParseWithSpecialCharacters() throws Exception {
-    MediaType mediaType = MediaType.parse(
-        "!#$%&'*+-.{|}~/!#$%&'*+-.{|}~; !#$%&'*+-.{|}~=!#$%&'*+-.{|}~");
-    assertEquals("!#$%&'*+-.{|}~", mediaType.type());
-    assertEquals("!#$%&'*+-.{|}~", mediaType.subtype());
-  }
-
-  @Test public void testCharsetIsOneOfManyParameters() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;a=1;b=2;charset=utf-8;c=3");
-    assertEquals("text", mediaType.type());
-    assertEquals("plain", mediaType.subtype());
-    assertEquals("UTF-8", mediaType.charset().name());
-  }
-
-  @Test public void testCharsetAndQuoting() throws Exception {
-    MediaType mediaType = MediaType.parse(
-        "text/plain;a=\";charset=us-ascii\";charset=\"utf-8\";b=\"iso-8859-1\"");
-    assertEquals("UTF-8", mediaType.charset().name());
-  }
-
-  @Test public void testDuplicatedCharsets() {
-    MediaType mediaType = MediaType.parse("text/plain; charset=utf-8; charset=UTF-8");
-    assertEquals("UTF-8", mediaType.charset().name());
-  }
-
-  @Test public void testMultipleCharsets() {
-    assertNull(MediaType.parse("text/plain; charset=utf-8; charset=utf-16"));
-  }
-
-  @Test public void testIllegalCharsetName() {
-    MediaType mediaType = MediaType.parse("text/plain; charset=\"!@#$%^&*()\"");
-    assertNull(mediaType.charset());
-  }
-
-  @Test public void testUnsupportedCharset() {
-    MediaType mediaType = MediaType.parse("text/plain; charset=utf-wtf");
-    assertNull(mediaType.charset());
-  }
-
-  /**
-   * This is invalid according to RFC 822. But it's what Chrome does and it avoids a potentially
-   * unpleasant IllegalCharsetNameException.
-   */
-  @Test public void testCharsetNameIsSingleQuoted() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;charset='utf-8'");
-    assertEquals("UTF-8", mediaType.charset().name());
-  }
-
-  @Test public void testCharsetNameIsDoubleQuotedAndSingleQuoted() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;charset=\"'utf-8'\"");
-    assertNull(mediaType.charset());
-  }
-
-  @Test public void testCharsetNameIsDoubleQuotedSingleQuote() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;charset=\"'\"");
-    assertNull(mediaType.charset());
-  }
-
-  @Test public void testDefaultCharset() throws Exception {
-    MediaType noCharset = MediaType.parse("text/plain");
-    assertEquals("UTF-8", noCharset.charset(Util.UTF_8).name());
-    assertEquals("US-ASCII", noCharset.charset(Charset.forName("US-ASCII")).name());
-
-    MediaType charset = MediaType.parse("text/plain; charset=iso-8859-1");
-    assertEquals("ISO-8859-1", charset.charset(Util.UTF_8).name());
-    assertEquals("ISO-8859-1", charset.charset(Charset.forName("US-ASCII")).name());
-  }
-
-  @Test public void testParseDanglingSemicolon() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;");
-    assertEquals("text", mediaType.type());
-    assertEquals("plain", mediaType.subtype());
-    assertNull(mediaType.charset());
-    assertEquals("text/plain;", mediaType.toString());
-  }
-
-  private void assertMediaType(String string) {
-    MediaType mediaType = MediaType.parse(string);
-    assertEquals(string, mediaType.toString());
-  }
-
-  private void assertInvalid(String string) {
-    assertNull(string, MediaType.parse(string));
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java b/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java
deleted file mode 100644
index f16a2a5c89..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import org.junit.Test;
-
-import java.io.IOException;
-
-import static org.junit.Assert.assertEquals;
-
-public class ProtocolTest {
-  @Test
-  public void testGetKnown() throws IOException {
-    assertEquals(Protocol.HTTP_1_0, Protocol.get("http/1.0"));
-    assertEquals(Protocol.HTTP_1_1, Protocol.get("http/1.1"));
-    assertEquals(Protocol.SPDY_3, Protocol.get("spdy/3.1"));
-    assertEquals(Protocol.HTTP_2, Protocol.get("h2"));
-    assertEquals(Protocol.H2C, Protocol.get("h2c"));
-    assertEquals(Protocol.QUIC, Protocol.get("quic"));
-  }
-
-  @Test(expected = IOException.class)
-  public void testGetUnknown() throws IOException {
-    Protocol.get("tcp");
-  }
-
-  @Test
-  public void testToString() throws IOException {
-    assertEquals("http/1.0", Protocol.HTTP_1_0.toString());
-    assertEquals("http/1.1", Protocol.HTTP_1_1.toString());
-    assertEquals("spdy/3.1", Protocol.SPDY_3.toString());
-    assertEquals("h2", Protocol.HTTP_2.toString());
-    assertEquals("h2c", Protocol.H2C.toString());
-    assertEquals("quic", Protocol.QUIC.toString());
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
deleted file mode 100644
index 5c205d7031..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/RequestTest.java
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.net.URI;
-import java.util.Arrays;
-import java.util.Collections;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-
-public final class RequestTest {
-  @Test public void string() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain; charset=utf-8");
-    RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
-    assertEquals(contentType, body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("616263", bodyToHex(body));
-    assertEquals("Retransmit body", "616263", bodyToHex(body));
-  }
-
-  @Test public void stringWithDefaultCharsetAdded() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain");
-    RequestBody body = RequestBody.create(contentType, "\u0800");
-    assertEquals(MediaType.parse("text/plain; charset=utf-8"), body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("e0a080", bodyToHex(body));
-  }
-
-  @Test public void stringWithNonDefaultCharsetSpecified() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain; charset=utf-16be");
-    RequestBody body = RequestBody.create(contentType, "\u0800");
-    assertEquals(contentType, body.contentType());
-    assertEquals(2, body.contentLength());
-    assertEquals("0800", bodyToHex(body));
-  }
-
-  @Test public void byteArray() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain");
-    RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
-    assertEquals(contentType, body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("616263", bodyToHex(body));
-    assertEquals("Retransmit body", "616263", bodyToHex(body));
-  }
-
-  @Test public void byteArrayRange() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain");
-    RequestBody body = RequestBody.create(contentType, ".abcd".getBytes(Util.UTF_8), 1, 3);
-    assertEquals(contentType, body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("616263", bodyToHex(body));
-    assertEquals("Retransmit body", "616263", bodyToHex(body));
-  }
-
-  @Test public void file() throws Exception {
-    File file = File.createTempFile("RequestTest", "tmp");
-    FileWriter writer = new FileWriter(file);
-    writer.write("abc");
-    writer.close();
-
-    MediaType contentType = MediaType.parse("text/plain");
-    RequestBody body = RequestBody.create(contentType, file);
-    assertEquals(contentType, body.contentType());
-    assertEquals(3, body.contentLength());
-    assertEquals("616263", bodyToHex(body));
-    assertEquals("Retransmit body", "616263", bodyToHex(body));
-  }
-
-  /** Common verbs used for apis such as GitHub, AWS, and Google Cloud. */
-  @Test public void crudVerbs() throws IOException {
-    MediaType contentType = MediaType.parse("application/json");
-    RequestBody body = RequestBody.create(contentType, "{}");
-
-    Request get = new Request.Builder().url("http://localhost/api").get().build();
-    assertEquals("GET", get.method());
-    assertNull(get.body());
-
-    Request head = new Request.Builder().url("http://localhost/api").head().build();
-    assertEquals("HEAD", head.method());
-    assertNull(head.body());
-
-    Request delete = new Request.Builder().url("http://localhost/api").delete().build();
-    assertEquals("DELETE", delete.method());
-    assertEquals(0L, delete.body().contentLength());
-
-    Request post = new Request.Builder().url("http://localhost/api").post(body).build();
-    assertEquals("POST", post.method());
-    assertEquals(body, post.body());
-
-    Request put = new Request.Builder().url("http://localhost/api").put(body).build();
-    assertEquals("PUT", put.method());
-    assertEquals(body, put.body());
-
-    Request patch = new Request.Builder().url("http://localhost/api").patch(body).build();
-    assertEquals("PATCH", patch.method());
-    assertEquals(body, patch.body());
-  }
-
-  @Test public void uninitializedURI() throws Exception {
-    Request request = new Request.Builder().url("http://localhost/api").build();
-    assertEquals(new URI("http://localhost/api"), request.url().uri());
-    assertEquals(HttpUrl.parse("http://localhost/api"), request.url());
-  }
-
-  @Test public void newBuilderUrlResetsUrl() throws Exception {
-    Request requestWithoutCache = new Request.Builder().url("http://localhost/api").build();
-    Request builtRequestWithoutCache =
-        requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
-    assertEquals(HttpUrl.parse("http://localhost/api/foo"), builtRequestWithoutCache.url());
-
-    Request requestWithCache = new Request.Builder().url("http://localhost/api").build();
-    // cache url object
-    requestWithCache.url();
-    Request builtRequestWithCache = requestWithCache.newBuilder().url(
-        "http://localhost/api/foo").build();
-    assertEquals(HttpUrl.parse("http://localhost/api/foo"), builtRequestWithCache.url());
-  }
-
-  @Test public void cacheControl() throws Exception {
-    Request request = new Request.Builder()
-        .cacheControl(new CacheControl.Builder().noCache().build())
-        .url("https://square.com")
-        .build();
-    assertEquals(Arrays.asList("no-cache"), request.headers("Cache-Control"));
-  }
-
-  @Test public void emptyCacheControlClearsAllCacheControlHeaders() throws Exception {
-    Request request = new Request.Builder()
-        .header("Cache-Control", "foo")
-        .cacheControl(new CacheControl.Builder().build())
-        .url("https://square.com")
-        .build();
-    assertEquals(Collections.<String>emptyList(), request.headers("Cache-Control"));
-  }
-
-  @Test public void headerAcceptsPermittedCharacters() throws Exception {
-    Request.Builder builder = new Request.Builder();
-    builder.header("AZab09~", "AZab09 ~");
-    builder.addHeader("AZab09~", "AZab09 ~");
-  }
-
-  @Test public void emptyNameForbidden() throws Exception {
-    Request.Builder builder = new Request.Builder();
-    try {
-      builder.header("", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      builder.addHeader("", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void headerForbidsNullArguments() throws Exception {
-    Request.Builder builder = new Request.Builder();
-    try {
-      builder.header(null, "Value");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      builder.addHeader(null, "Value");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      builder.header("Name", null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      builder.addHeader("Name", null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-  }
-
-  @Test public void headerAllowsTabOnlyInValues() throws Exception {
-    Request.Builder builder = new Request.Builder();
-    builder.header("key", "sample\tvalue");
-    try {
-      builder.header("sample\tkey", "value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void headerForbidsControlCharacters() throws Exception {
-    assertForbiddenHeader("\u0000");
-    assertForbiddenHeader("\r");
-    assertForbiddenHeader("\n");
-    assertForbiddenHeader("\u001f");
-    assertForbiddenHeader("\u007f");
-    assertForbiddenHeader("\u0080");
-    assertForbiddenHeader("\ud83c\udf69");
-  }
-
-  private void assertForbiddenHeader(String s) {
-    Request.Builder builder = new Request.Builder();
-    try {
-      builder.header(s, "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      builder.addHeader(s, "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      builder.header("Name", s);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      builder.addHeader("Name", s);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  private String bodyToHex(RequestBody body) throws IOException {
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    return buffer.readByteString().hex();
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
deleted file mode 100644
index 119c186911..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ /dev/null
@@ -1,3893 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.Authenticator;
-import java.net.ConnectException;
-import java.net.CookieManager;
-import java.net.HttpRetryException;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.PasswordAuthentication;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.net.SocketException;
-import java.net.SocketTimeoutException;
-import java.net.URI;
-import java.net.URL;
-import java.net.URLConnection;
-import java.net.UnknownHostException;
-import java.security.KeyStore;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.zip.GZIPInputStream;
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLProtocolException;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.DoubleInetAddressDns;
-import okhttp3.internal.Internal;
-import okhttp3.internal.RecordingAuthenticator;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.internal.Util;
-import okhttp3.internal.Version;
-import okhttp3.internal.huc.OkHttpURLConnection;
-import okhttp3.internal.platform.Platform;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.mockwebserver.internal.tls.SslClient;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-import static okhttp3.TestUtil.defaultClient;
-import static okhttp3.internal.Util.UTF_8;
-import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-import static okhttp3.internal.huc.OkHttpURLConnection.SELECTED_PROTOCOL;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
-import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeTrue;
-
-/** Android's URLConnectionTest. */
-public final class URLConnectionTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final MockWebServer server2 = new MockWebServer();
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-
-  private SslClient sslClient = SslClient.localhost();
-  private OkUrlFactory urlFactory;
-  private HttpURLConnection connection;
-  private Cache cache;
-
-  @Before public void setUp() throws Exception {
-    server.setProtocolNegotiationEnabled(false);
-    urlFactory = new OkUrlFactory(defaultClient());
-  }
-
-  @After public void tearDown() throws Exception {
-    Authenticator.setDefault(null);
-    System.clearProperty("proxyHost");
-    System.clearProperty("proxyPort");
-    System.clearProperty("http.agent");
-    System.clearProperty("http.proxyHost");
-    System.clearProperty("http.proxyPort");
-    System.clearProperty("https.proxyHost");
-    System.clearProperty("https.proxyPort");
-    if (cache != null) {
-      cache.delete();
-    }
-  }
-
-  @Test public void requestHeaders() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse());
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("D", "e");
-    connection.addRequestProperty("D", "f");
-    assertEquals("f", connection.getRequestProperty("D"));
-    assertEquals("f", connection.getRequestProperty("d"));
-    Map<String, List<String>> requestHeaders = connection.getRequestProperties();
-    assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("D")));
-    assertEquals(newSet("e", "f"), new LinkedHashSet<>(requestHeaders.get("d")));
-    try {
-      requestHeaders.put("G", Arrays.asList("h"));
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      requestHeaders.get("D").add("i");
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      connection.setRequestProperty(null, "j");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      connection.addRequestProperty(null, "k");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    connection.setRequestProperty("NullValue", null);
-    assertNull(connection.getRequestProperty("NullValue"));
-    connection.addRequestProperty("AnotherNullValue", null);
-    assertNull(connection.getRequestProperty("AnotherNullValue"));
-
-    connection.getResponseCode();
-    RecordedRequest request = server.takeRequest();
-    assertEquals(Arrays.asList("e", "f"), request.getHeaders().values("D"));
-    assertNull(request.getHeader("NullValue"));
-    assertNull(request.getHeader("AnotherNullValue"));
-    assertNull(request.getHeader("G"));
-    assertNull(request.getHeader("null"));
-
-    try {
-      connection.addRequestProperty("N", "o");
-      fail("Set header after connect");
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      connection.setRequestProperty("P", "q");
-      fail("Set header after connect");
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      connection.getRequestProperties();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void getRequestPropertyReturnsLastValue() throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("A", "value1");
-    connection.addRequestProperty("A", "value2");
-    assertEquals("value2", connection.getRequestProperty("A"));
-  }
-
-  @Test public void responseHeaders() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 Fantastic")
-        .addHeader("A: c")
-        .addHeader("B: d")
-        .addHeader("A: e")
-        .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
-
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Fantastic", connection.getResponseMessage());
-    assertEquals("HTTP/1.0 200 Fantastic", connection.getHeaderField(null));
-    Map<String, List<String>> responseHeaders = connection.getHeaderFields();
-    assertEquals(Arrays.asList("HTTP/1.0 200 Fantastic"), responseHeaders.get(null));
-    assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("A")));
-    assertEquals(newSet("c", "e"), new LinkedHashSet<>(responseHeaders.get("a")));
-    try {
-      responseHeaders.put("N", Arrays.asList("o"));
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    try {
-      responseHeaders.get("A").add("f");
-      fail("Modified an unmodifiable view.");
-    } catch (UnsupportedOperationException expected) {
-    }
-    assertEquals("A", connection.getHeaderFieldKey(0));
-    assertEquals("c", connection.getHeaderField(0));
-    assertEquals("B", connection.getHeaderFieldKey(1));
-    assertEquals("d", connection.getHeaderField(1));
-    assertEquals("A", connection.getHeaderFieldKey(2));
-    assertEquals("e", connection.getHeaderField(2));
-    connection.getInputStream().close();
-  }
-
-  @Test public void serverSendsInvalidResponseHeaders() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
-    server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void connectRetriesUntilConnectedOrFailed() throws Exception {
-    URL url = server.url("/foo").url();
-    server.shutdown();
-
-    connection = urlFactory.open(url);
-    try {
-      connection.connect();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void requestBodySurvivesRetriesWithFixedLength() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void requestBodySurvivesRetriesWithChunkedStreaming() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.CHUNKED);
-  }
-
-  @Test public void requestBodySurvivesRetriesWithBufferedBody() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.END_OF_STREAM);
-  }
-
-  private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    // Use a misconfigured proxy to guarantee that the request is retried.
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxySelector(new FakeProxySelector()
-            .addProxy(server2.toProxyAddress())
-            .addProxy(Proxy.NO_PROXY))
-        .build());
-    server2.shutdown();
-
-    connection = urlFactory.open(server.url("/def").url());
-    connection.setDoOutput(true);
-    transferKind.setForRequest(connection, 4);
-    connection.getOutputStream().write("body".getBytes("UTF-8"));
-    assertContent("abc", connection);
-
-    assertEquals("body", server.takeRequest().getBody().readUtf8());
-  }
-
-  @Test public void streamedBodyIsNotRetried() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-
-    urlFactory = new OkUrlFactory(defaultClient().newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build());
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    connection.setChunkedStreamingMode(100);
-    OutputStream os = connection.getOutputStream();
-    os.write("OutputStream is no fun.".getBytes("UTF-8"));
-    os.close();
-
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    assertEquals(1, server.getRequestCount());
-  }
-
-  @Test public void getErrorStreamOnSuccessfulRequest() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    assertNull(connection.getErrorStream());
-    connection.getInputStream().close();
-  }
-
-  @Test public void getErrorStreamOnUnsuccessfulRequest() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection.getErrorStream(), Integer.MAX_VALUE));
-  }
-
-  // Check that if we don't read to the end of a response, the next request on the
-  // recycled connection doesn't get the unread tail of the first request's response.
-  // http://code.google.com/p/android/issues/detail?id=2939
-  @Test public void bug2939() throws Exception {
-    MockResponse response = new MockResponse().setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8);
-
-    server.enqueue(response);
-    server.enqueue(response);
-
-    HttpURLConnection c1 = urlFactory.open(server.url("/").url());
-    assertContent("ABCDE", c1, 5);
-    HttpURLConnection c2 = urlFactory.open(server.url("/").url());
-    assertContent("ABCDE", c2, 5);
-
-    c1.getInputStream().close();
-    c2.getInputStream().close();
-  }
-
-  // Check that we recognize a few basic mime types by extension.
-  // http://code.google.com/p/android/issues/detail?id=10100
-  @Test public void bug10100() throws Exception {
-    assertEquals("image/jpeg", URLConnection.guessContentTypeFromName("someFile.jpg"));
-    assertEquals("application/pdf", URLConnection.guessContentTypeFromName("stuff.pdf"));
-  }
-
-  @Test public void connectionsArePooled() throws Exception {
-    MockResponse response = new MockResponse().setBody("ABCDEFGHIJKLMNOPQR");
-
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/foo").url()));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/bar?baz=quux").url()));
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/z").url()));
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void chunkedConnectionsArePooled() throws Exception {
-    MockResponse response = new MockResponse().setChunkedBody("ABCDEFGHIJKLMNOPQR", 5);
-
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/foo").url()));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/bar?baz=quux").url()));
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertContent("ABCDEFGHIJKLMNOPQR", urlFactory.open(server.url("/z").url()));
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void serverClosesSocket() throws Exception {
-    testServerClosesOutput(DISCONNECT_AT_END);
-  }
-
-  @Test public void serverShutdownInput() throws Exception {
-    testServerClosesOutput(SHUTDOWN_INPUT_AT_END);
-  }
-
-  @Test public void serverShutdownOutput() throws Exception {
-    testServerClosesOutput(SHUTDOWN_OUTPUT_AT_END);
-  }
-
-  @Test public void invalidHost() throws Exception {
-    // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
-    URL url = new URL("http://1234.1.1.1/index.html");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new FakeDns())
-        .build());
-    HttpURLConnection connection = urlFactory.open(url);
-    try {
-      connection.connect();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception {
-    server.enqueue(new MockResponse().setBody("This connection won't pool properly")
-        .setSocketPolicy(socketPolicy));
-    MockResponse responseAfter = new MockResponse().setBody("This comes after a busted connection");
-    server.enqueue(responseAfter);
-    server.enqueue(responseAfter); // Enqueue 2x because the broken connection may be reused.
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/a").url());
-    connection1.setReadTimeout(100);
-    assertContent("This connection won't pool properly", connection1);
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-
-    // Give the server time to enact the socket policy if it's one that could happen after the
-    // client has received the response.
-    Thread.sleep(500);
-
-    HttpURLConnection connection2 = urlFactory.open(server.url("/b").url());
-    connection2.setReadTimeout(100);
-    assertContent("This comes after a busted connection", connection2);
-
-    // Check that a fresh connection was created, either immediately or after attempting reuse.
-    RecordedRequest requestAfter = server.takeRequest();
-    if (server.getRequestCount() == 3) {
-      requestAfter = server.takeRequest(); // The failure consumed a response.
-    }
-    // sequence number 0 means the HTTP socket connection was not reused
-    assertEquals(0, requestAfter.getSequenceNumber());
-  }
-
-  enum WriteKind {BYTE_BY_BYTE, SMALL_BUFFERS, LARGE_BUFFERS}
-
-  @Test public void chunkedUpload_byteByByte() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.BYTE_BY_BYTE);
-  }
-
-  @Test public void chunkedUpload_smallBuffers() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.SMALL_BUFFERS);
-  }
-
-  @Test public void chunkedUpload_largeBuffers() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.LARGE_BUFFERS);
-  }
-
-  @Test public void fixedLengthUpload_byteByByte() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.BYTE_BY_BYTE);
-  }
-
-  @Test public void fixedLengthUpload_smallBuffers() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.SMALL_BUFFERS);
-  }
-
-  @Test public void fixedLengthUpload_largeBuffers() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.LARGE_BUFFERS);
-  }
-
-  private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Exception {
-    int n = 512 * 1024;
-    server.setBodyLimit(0);
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection conn = urlFactory.open(server.url("/").url());
-    conn.setDoOutput(true);
-    conn.setRequestMethod("POST");
-    if (uploadKind == TransferKind.CHUNKED) {
-      conn.setChunkedStreamingMode(-1);
-    } else {
-      conn.setFixedLengthStreamingMode(n);
-    }
-    OutputStream out = conn.getOutputStream();
-    if (writeKind == WriteKind.BYTE_BY_BYTE) {
-      for (int i = 0; i < n; ++i) {
-        out.write('x');
-      }
-    } else {
-      byte[] buf = new byte[writeKind == WriteKind.SMALL_BUFFERS ? 256 : 64 * 1024];
-      Arrays.fill(buf, (byte) 'x');
-      for (int i = 0; i < n; i += buf.length) {
-        out.write(buf, 0, Math.min(buf.length, n - i));
-      }
-    }
-    out.close();
-    assertEquals(200, conn.getResponseCode());
-    RecordedRequest request = server.takeRequest();
-    assertEquals(n, request.getBodySize());
-    if (uploadKind == TransferKind.CHUNKED) {
-      assertTrue(request.getChunkSizes().size() > 0);
-    } else {
-      assertTrue(request.getChunkSizes().isEmpty());
-    }
-  }
-
-  @Test public void getResponseCodeNoResponseBody() throws Exception {
-    server.enqueue(new MockResponse().addHeader("abc: def"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection conn = urlFactory.open(url);
-    conn.setDoInput(false);
-    assertEquals("def", conn.getHeaderField("abc"));
-    assertEquals(200, conn.getResponseCode());
-    try {
-      conn.getInputStream();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void connectViaHttps() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    connection = urlFactory.open(server.url("/foo").url());
-
-    assertContent("this response comes via HTTPS", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-  }
-
-  @Test public void inspectHandshakeThroughoutRequestLifecycle() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse());
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-
-    HttpsURLConnection httpsConnection
-        = (HttpsURLConnection) urlFactory.open(server.url("/foo").url());
-
-    // Prior to calling connect(), getting the cipher suite is forbidden.
-    try {
-      httpsConnection.getCipherSuite();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    // Calling connect establishes a handshake...
-    httpsConnection.connect();
-    assertNotNull(httpsConnection.getCipherSuite());
-
-    // ...which remains after we read the response body...
-    assertContent("", httpsConnection);
-    assertNotNull(httpsConnection.getCipherSuite());
-
-    // ...and after we disconnect.
-    httpsConnection.disconnect();
-    assertNotNull(httpsConnection.getCipherSuite());
-  }
-
-  @Test public void connectViaHttpsReusingConnections() throws Exception {
-    connectViaHttpsReusingConnections(false);
-  }
-
-  @Test public void connectViaHttpsReusingConnectionsAfterRebuildingClient() throws Exception {
-    connectViaHttpsReusingConnections(true);
-  }
-
-  private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-    server.enqueue(new MockResponse().setBody("another response via HTTPS"));
-
-    // The pool will only reuse sockets if the SSL socket factories are the same.
-    SSLSocketFactory clientSocketFactory = sslClient.socketFactory;
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    CookieJar cookieJar = new JavaNetCookieJar(new CookieManager());
-    ConnectionPool connectionPool = new ConnectionPool();
-
-    urlFactory.setClient(new OkHttpClient.Builder()
-        .cache(cache)
-        .connectionPool(connectionPool)
-        .cookieJar(cookieJar)
-        .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertContent("this response comes via HTTPS", connection);
-
-    if (rebuildClient) {
-      urlFactory.setClient(new OkHttpClient.Builder()
-          .cache(cache)
-          .connectionPool(connectionPool)
-          .cookieJar(cookieJar)
-          .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
-          .hostnameVerifier(hostnameVerifier)
-          .build());
-    }
-
-    connection = urlFactory.open(server.url("/").url());
-    assertContent("another response via HTTPS", connection);
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectViaHttpsReusingConnectionsDifferentFactories() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-    server.enqueue(new MockResponse().setBody("another response via HTTPS"));
-
-    // install a custom SSL socket factory so the server can be authorized
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    assertContent("this response comes via HTTPS", connection1);
-
-    SSLContext sslContext2 = Platform.get().getSSLContext();
-    sslContext2.init(null, null, null);
-    SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
-
-    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-        TrustManagerFactory.getDefaultAlgorithm());
-    trustManagerFactory.init((KeyStore) null);
-    X509TrustManager trustManager = (X509TrustManager) trustManagerFactory.getTrustManagers()[0];
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslSocketFactory2, trustManager)
-        .build());
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    try {
-      readAscii(connection2.getInputStream(), Integer.MAX_VALUE);
-      fail("without an SSL socket factory, the connection should fail");
-    } catch (SSLException expected) {
-    }
-  }
-
-  // TODO(jwilson): tests below this marker need to be migrated to OkHttp's request/response API.
-
-  @Test public void connectViaHttpsWithSSLFallback() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("this response comes via SSL"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
-        .build());
-    connection = urlFactory.open(server.url("/foo").url());
-
-    assertContent("this response comes via SSL", connection);
-
-    RecordedRequest failHandshakeRequest = server.takeRequest();
-    assertNull(failHandshakeRequest.getRequestLine());
-
-    RecordedRequest fallbackRequest = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", fallbackRequest.getRequestLine());
-    assertEquals(TlsVersion.TLS_1_0, fallbackRequest.getTlsVersion());
-  }
-
-  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new SingleInetAddressDns())
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
-        .build());
-    connection = urlFactory.open(server.url("/foo").url());
-
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IOException expected) {
-      assertEquals(1, expected.getSuppressed().length);
-    }
-  }
-
-  /**
-   * When a pooled connection fails, don't blame the route. Otherwise pooled connection failures can
-   * cause unnecessary SSL fallbacks.
-   *
-   * https://github.com/square/okhttp/issues/515
-   */
-  @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .setSocketPolicy(DISCONNECT_AT_END));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
-        .build());
-
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-
-    // Give the server time to disconnect.
-    Thread.sleep(500);
-
-    assertContent("def", urlFactory.open(server.url("/").url()));
-
-    Set<TlsVersion> tlsVersions =
-        EnumSet.of(TlsVersion.TLS_1_0, TlsVersion.TLS_1_2); // v1.2 on OpenJDK 8.
-
-    RecordedRequest request1 = server.takeRequest();
-    assertTrue(tlsVersions.contains(request1.getTlsVersion()));
-
-    RecordedRequest request2 = server.takeRequest();
-    assertTrue(tlsVersions.contains(request2.getTlsVersion()));
-  }
-
-  /**
-   * Verify that we don't retry connections on certificate verification errors.
-   *
-   * http://code.google.com/p/android/issues/detail?id=13178
-   */
-  @Test public void connectViaHttpsToUntrustedServer() throws IOException, InterruptedException {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse()); // unused
-
-    connection = urlFactory.open(server.url("/foo").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (SSLHandshakeException expected) {
-      assertTrue(expected.getCause() instanceof CertificateException);
-    }
-    assertEquals(0, server.getRequestCount());
-  }
-
-  @Test public void connectViaProxyUsingProxyArg() throws Exception {
-    testConnectViaProxy(ProxyConfig.CREATE_ARG);
-  }
-
-  @Test public void connectViaProxyUsingProxySystemProperty() throws Exception {
-    testConnectViaProxy(ProxyConfig.PROXY_SYSTEM_PROPERTY);
-  }
-
-  @Test public void connectViaProxyUsingHttpProxySystemProperty() throws Exception {
-    testConnectViaProxy(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
-  }
-
-  private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
-    MockResponse mockResponse = new MockResponse().setBody("this response comes via a proxy");
-    server.enqueue(mockResponse);
-
-    URL url = new URL("http://android.com/foo");
-    connection = proxyConfig.connect(server, urlFactory, url);
-    assertContent("this response comes via a proxy", connection);
-    assertTrue(connection.usingProxy());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET http://android.com/foo HTTP/1.1", request.getRequestLine());
-    assertEquals("android.com", request.getHeader("Host"));
-  }
-
-  @Test public void contentDisagreesWithContentLengthHeaderBodyTooLong() throws IOException {
-    server.enqueue(new MockResponse().setBody("abc\r\nYOU SHOULD NOT SEE THIS")
-        .clearHeaders()
-        .addHeader("Content-Length: 3"));
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-  }
-
-  @Test public void contentDisagreesWithContentLengthHeaderBodyTooShort() throws IOException {
-    server.enqueue(new MockResponse().setBody("abc")
-        .setHeader("Content-Length", "5")
-        .setSocketPolicy(DISCONNECT_AT_END));
-    try {
-      readAscii(urlFactory.open(server.url("/").url()).getInputStream(), 5);
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  public void testConnectViaSocketFactory(boolean useHttps) throws IOException {
-    SocketFactory uselessSocketFactory = new SocketFactory() {
-      public Socket createSocket() {
-        throw new IllegalArgumentException("useless");
-      }
-
-      public Socket createSocket(InetAddress host, int port) {
-        return null;
-      }
-
-      public Socket createSocket(InetAddress address, int port, InetAddress localAddress,
-          int localPort) {
-        return null;
-      }
-
-      public Socket createSocket(String host, int port) {
-        return null;
-      }
-
-      public Socket createSocket(String host, int port, InetAddress localHost, int localPort) {
-        return null;
-      }
-    };
-
-    if (useHttps) {
-      server.useHttps(sslClient.socketFactory, false);
-      urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-          .hostnameVerifier(new RecordingHostnameVerifier())
-          .build());
-    }
-
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .socketFactory(uselessSocketFactory)
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode();
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .socketFactory(SocketFactory.getDefault())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(200, connection.getResponseCode());
-  }
-
-  @Test public void connectHttpViaSocketFactory() throws Exception {
-    testConnectViaSocketFactory(false);
-  }
-
-  @Test public void connectHttpsViaSocketFactory() throws Exception {
-    testConnectViaSocketFactory(true);
-  }
-
-  @Test public void contentDisagreesWithChunkedHeaderBodyTooLong() throws IOException {
-    MockResponse mockResponse = new MockResponse();
-    mockResponse.setChunkedBody("abc", 3);
-    Buffer buffer = mockResponse.getBody();
-    buffer.writeUtf8("\r\nYOU SHOULD NOT SEE THIS");
-    mockResponse.setBody(buffer);
-    mockResponse.clearHeaders();
-    mockResponse.addHeader("Transfer-encoding: chunked");
-
-    server.enqueue(mockResponse);
-
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-  }
-
-  @Test public void contentDisagreesWithChunkedHeaderBodyTooShort() throws IOException {
-    MockResponse mockResponse = new MockResponse();
-    mockResponse.setChunkedBody("abcde", 5);
-
-    Buffer truncatedBody = new Buffer();
-    Buffer fullBody = mockResponse.getBody();
-    truncatedBody.write(fullBody, fullBody.indexOf((byte) 'e'));
-    mockResponse.setBody(truncatedBody);
-
-    mockResponse.clearHeaders();
-    mockResponse.addHeader("Transfer-encoding: chunked");
-    mockResponse.setSocketPolicy(DISCONNECT_AT_END);
-
-    server.enqueue(mockResponse);
-
-    try {
-      readAscii(urlFactory.open(server.url("/").url()).getInputStream(), 5);
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingProxyArgWithNoProxy() throws Exception {
-    testConnectViaDirectProxyToHttps(ProxyConfig.NO_PROXY);
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingHttpProxySystemProperty() throws Exception {
-    // https should not use http proxy
-    testConnectViaDirectProxyToHttps(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
-  }
-
-  private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
-
-    URL url = server.url("/foo").url();
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    connection = proxyConfig.connect(server, urlFactory, url);
-
-    assertContent("this response comes via HTTPS", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingProxyArg() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.CREATE_ARG);
-  }
-
-  /**
-   * We weren't honoring all of the appropriate proxy system properties when connecting via HTTPS.
-   * http://b/3097518
-   */
-  @Test public void connectViaHttpProxyToHttpsUsingProxySystemProperty() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.PROXY_SYSTEM_PROPERTY);
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingHttpsProxySystemProperty() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.HTTPS_PROXY_SYSTEM_PROPERTY);
-  }
-
-  /**
-   * We were verifying the wrong hostname when connecting to an HTTPS site through a proxy.
-   * http://b/3097277
-   */
-  private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(sslClient.socketFactory, true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
-
-    URL url = new URL("https://android.com/foo");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-    connection = proxyConfig.connect(server, urlFactory, url);
-
-    assertContent("this response comes via a secure proxy", connection);
-
-    RecordedRequest connect = server.takeRequest();
-    assertEquals("Connect line failure on proxy", "CONNECT android.com:443 HTTP/1.1",
-        connect.getRequestLine());
-    assertEquals("android.com:443", connect.getHeader("Host"));
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
-    assertEquals("android.com", get.getHeader("Host"));
-    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
-  }
-
-  /** Tolerate bad https proxy response when using HttpResponseCache. Android bug 6754912. */
-  @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
-    initResponseCache();
-
-    server.useHttps(sslClient.socketFactory, true);
-    // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
-    MockResponse badProxyResponse = new MockResponse()
-        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
-        .setBody("bogus proxy connect response content");
-    server.enqueue(badProxyResponse);
-    server.enqueue(new MockResponse().setBody("response"));
-
-    // Configure a single IP address for the host and a single configuration, so we only need one
-    // failure to fail permanently.
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new SingleInetAddressDns())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .proxy(server.toProxyAddress())
-        .build());
-
-    URL url = new URL("https://android.com/foo");
-    connection = urlFactory.open(url);
-    assertContent("response", connection);
-
-    RecordedRequest connect = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect.getRequestLine());
-    assertEquals("android.com:443", connect.getHeader("Host"));
-  }
-
-  private void initResponseCache() throws IOException {
-    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .cache(cache)
-        .build());
-  }
-
-  /** Test which headers are sent unencrypted to the HTTP proxy. */
-  @Test public void proxyConnectIncludesProxyHeadersOnly()
-      throws IOException, InterruptedException {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(sslClient.socketFactory, true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-
-    URL url = new URL("https://android.com/foo");
-    connection = urlFactory.open(url);
-    connection.addRequestProperty("Private", "Secret");
-    connection.addRequestProperty("Proxy-Authorization", "bar");
-    connection.addRequestProperty("User-Agent", "baz");
-    assertContent("encrypted response from the origin server", connection);
-
-    RecordedRequest connect = server.takeRequest();
-    assertNull(connect.getHeader("Private"));
-    assertNull(connect.getHeader("Proxy-Authorization"));
-    assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
-    assertEquals("android.com:443", connect.getHeader("Host"));
-    assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("Secret", get.getHeader("Private"));
-    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
-  }
-
-  @Test public void proxyAuthenticateOnConnect() throws Exception {
-    Authenticator.setDefault(new RecordingAuthenticator());
-    server.useHttps(sslClient.socketFactory, true);
-    server.enqueue(new MockResponse().setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
-    server.enqueue(
-        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("A"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxyAuthenticator(new JavaNetAuthenticator())
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-
-    URL url = new URL("https://android.com/foo");
-    connection = urlFactory.open(url);
-    assertContent("A", connection);
-
-    RecordedRequest connect1 = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect1.getRequestLine());
-    assertNull(connect1.getHeader("Proxy-Authorization"));
-
-    RecordedRequest connect2 = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect2.getRequestLine());
-    assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-        connect2.getHeader("Proxy-Authorization"));
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
-    assertNull(get.getHeader("Proxy-Authorization"));
-  }
-
-  // Don't disconnect after building a tunnel with CONNECT
-  // http://code.google.com/p/android/issues/detail?id=37221
-  @Test public void proxyWithConnectionClose() throws IOException {
-    server.useHttps(sslClient.socketFactory, true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-
-    URL url = new URL("https://android.com/foo");
-    connection = urlFactory.open(url);
-    connection.setRequestProperty("Connection", "close");
-
-    assertContent("this response comes via a proxy", connection);
-  }
-
-  @Test public void proxyWithConnectionReuse() throws IOException {
-    SSLSocketFactory socketFactory = sslClient.socketFactory;
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(socketFactory, true);
-    server.enqueue(
-        new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
-    server.enqueue(new MockResponse().setBody("response 1"));
-    server.enqueue(new MockResponse().setBody("response 2"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
-        .build());
-    URL url = new URL("https://android.com/foo");
-    assertContent("response 1", urlFactory.open(url));
-    assertContent("response 2", urlFactory.open(url));
-  }
-
-  @Test public void disconnectedConnection() throws IOException {
-    server.enqueue(new MockResponse()
-        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
-        .setBody("ABCD"));
-
-    connection = urlFactory.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals('A', (char) in.read());
-    connection.disconnect();
-    try {
-      // Reading 'B' may succeed if it's buffered.
-      in.read();
-
-      // But 'C' shouldn't be buffered (the response is throttled) and this should fail.
-      in.read();
-      fail("Expected a connection closed exception");
-    } catch (IOException expected) {
-    }
-    in.close();
-  }
-
-  @Test public void disconnectDuringConnect_cookieJar() throws Exception {
-    final AtomicReference<HttpURLConnection> connectionHolder = new AtomicReference<>();
-    class DisconnectingCookieJar implements CookieJar {
-      @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) { }
-      @Override
-      public List<Cookie> loadForRequest(HttpUrl url) {
-        connectionHolder.get().disconnect();
-        return Collections.emptyList();
-      }
-    }
-    OkHttpClient client = new okhttp3.OkHttpClient.Builder()
-            .cookieJar(new DisconnectingCookieJar())
-            .build();
-
-    URL url = server.url("path that should never be accessed").url();
-    HttpURLConnection connection = new OkHttpURLConnection(url, client);
-    connectionHolder.set(connection);
-    try {
-      connection.getInputStream();
-      fail("Connection should not be established");
-    } catch (IOException expected) {
-      assertEquals("Canceled", expected.getMessage());
-    } finally {
-      connection.disconnect();
-    }
-  }
-
-  @Test public void disconnectBeforeConnect() throws IOException {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.disconnect();
-    assertContent("A", connection);
-    assertEquals(200, connection.getResponseCode());
-  }
-
-  @SuppressWarnings("deprecation") @Test public void defaultRequestProperty() throws Exception {
-    URLConnection.setDefaultRequestProperty("X-testSetDefaultRequestProperty", "A");
-    assertNull(URLConnection.getDefaultRequestProperty("X-setDefaultRequestProperty"));
-  }
-
-  /**
-   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
-   * characters can be read, the remaining characters are returned and the stream is closed.
-   */
-  private String readAscii(InputStream in, int count) throws IOException {
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  @Test public void markAndResetWithContentLengthHeader() throws IOException {
-    testMarkAndReset(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void markAndResetWithChunkedEncoding() throws IOException {
-    testMarkAndReset(TransferKind.CHUNKED);
-  }
-
-  @Test public void markAndResetWithNoLengthHeaders() throws IOException {
-    testMarkAndReset(TransferKind.END_OF_STREAM);
-  }
-
-  private void testMarkAndReset(TransferKind transferKind) throws IOException {
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    InputStream in = urlFactory.open(server.url("/").url()).getInputStream();
-    assertFalse("This implementation claims to support mark().", in.markSupported());
-    in.mark(5);
-    assertEquals("ABCDE", readAscii(in, 5));
-    try {
-      in.reset();
-      fail();
-    } catch (IOException expected) {
-    }
-    assertEquals("FGHIJKLMNOPQRSTUVWXYZ", readAscii(in, Integer.MAX_VALUE));
-    in.close();
-    assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", urlFactory.open(server.url("/").url()));
-  }
-
-  /**
-   * We've had a bug where we forget the HTTP response when we see response code 401. This causes a
-   * new HTTP request to be issued for every call into the URLConnection.
-   */
-  @Test public void unauthorizedResponseHandling() throws IOException {
-    MockResponse response = new MockResponse().addHeader("WWW-Authenticate: challenge")
-        .setResponseCode(401) // UNAUTHORIZED
-        .setBody("Unauthorized");
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    URL url = server.url("/").url();
-    HttpURLConnection conn = urlFactory.open(url);
-
-    assertEquals(401, conn.getResponseCode());
-    assertEquals(401, conn.getResponseCode());
-    assertEquals(401, conn.getResponseCode());
-    assertEquals(1, server.getRequestCount());
-    conn.getErrorStream().close();
-  }
-
-  @Test public void nonHexChunkSize() throws IOException {
-    server.enqueue(new MockResponse().setBody("5\r\nABCDE\r\nG\r\nFGHIJKLMNOPQRSTU\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException e) {
-    }
-    connection.getInputStream().close();
-  }
-
-  @Test public void malformedChunkSize() throws IOException {
-    server.enqueue(new MockResponse().setBody("5:x\r\nABCDE\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException e) {
-    } finally {
-      connection.getInputStream().close();
-    }
-  }
-
-  @Test public void extensionAfterChunkSize() throws IOException {
-    server.enqueue(new MockResponse().setBody("5;x\r\nABCDE\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertContent("ABCDE", connection);
-  }
-
-  @Test public void missingChunkBody() throws IOException {
-    server.enqueue(new MockResponse().setBody("5")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked")
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException e) {
-    } finally {
-      connection.getInputStream().close();
-    }
-  }
-
-  /**
-   * This test checks whether connections are gzipped by default. This behavior in not required by
-   * the API, so a failure of this test does not imply a bug in the implementation.
-   */
-  @Test public void gzipEncodingEnabledByDefault() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("ABCABCABC", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    assertNull(connection.getContentEncoding());
-    assertEquals(-1, connection.getContentLength());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("gzip", request.getHeader("Accept-Encoding"));
-  }
-
-  @Test public void clientConfiguredGzipContentEncoding() throws Exception {
-    Buffer bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
-    server.enqueue(new MockResponse()
-        .setBody(bodyBytes)
-        .addHeader("Content-Encoding: gzip"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Accept-Encoding", "gzip");
-    InputStream gunzippedIn = new GZIPInputStream(connection.getInputStream());
-    assertEquals("ABCDEFGHIJKLMNOPQRSTUVWXYZ", readAscii(gunzippedIn, Integer.MAX_VALUE));
-    assertEquals(bodyBytes.size(), connection.getContentLength());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("gzip", request.getHeader("Accept-Encoding"));
-  }
-
-  @Test public void gzipAndConnectionReuseWithFixedLength() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, false);
-  }
-
-  @Test public void gzipAndConnectionReuseWithChunkedEncoding() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, false);
-  }
-
-  @Test public void gzipAndConnectionReuseWithFixedLengthAndTls() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, true);
-  }
-
-  @Test public void gzipAndConnectionReuseWithChunkedEncodingAndTls() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, true);
-  }
-
-  @Test public void clientConfiguredCustomContentEncoding() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDE").addHeader("Content-Encoding: custom"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Accept-Encoding", "custom");
-    assertEquals("ABCDE", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("custom", request.getHeader("Accept-Encoding"));
-  }
-
-  /**
-   * Test a bug where gzip input streams weren't exhausting the input stream, which corrupted the
-   * request that followed or prevented connection reuse.
-   * http://code.google.com/p/android/issues/detail?id=7059
-   * http://code.google.com/p/android/issues/detail?id=38817
-   */
-  private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind transferKind,
-      boolean tls) throws Exception {
-    if (tls) {
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
-      RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-      server.useHttps(socketFactory, false);
-      urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(socketFactory, sslClient.trustManager)
-          .hostnameVerifier(hostnameVerifier)
-          .build());
-    }
-
-    MockResponse responseOne = new MockResponse();
-    responseOne.addHeader("Content-Encoding: gzip");
-    transferKind.setBody(responseOne, gzip("one (gzipped)"), 5);
-    server.enqueue(responseOne);
-    MockResponse responseTwo = new MockResponse();
-    transferKind.setBody(responseTwo, "two (identity)", 5);
-    server.enqueue(responseTwo);
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    connection1.addRequestProperty("Accept-Encoding", "gzip");
-    InputStream gunzippedIn = new GZIPInputStream(connection1.getInputStream());
-    assertEquals("one (gzipped)", readAscii(gunzippedIn, Integer.MAX_VALUE));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertEquals("two (identity)", readAscii(connection2.getInputStream(), Integer.MAX_VALUE));
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void transparentGzipWorksAfterExceptionRecovery() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("a")
-        .setSocketPolicy(SHUTDOWN_INPUT_AT_END));
-    server.enqueue(new MockResponse()
-        .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("b")));
-
-    // Seed the pool with a bad connection.
-    assertContent("a", urlFactory.open(server.url("/").url()));
-
-    // Give the server time to disconnect.
-    Thread.sleep(500);
-
-    // This connection will need to be recovered. When it is, transparent gzip should still work!
-    assertContent("b", urlFactory.open(server.url("/").url()));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
-  }
-
-  @Test public void endOfStreamResponseIsNotPooled() throws Exception {
-    urlFactory.client().connectionPool().evictAll();
-    server.enqueue(new MockResponse()
-        .setBody("{}")
-        .clearHeaders()
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertContent("{}", connection);
-    assertEquals(0, urlFactory.client().connectionPool().idleConnectionCount());
-  }
-
-  @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
-    testEarlyDisconnectDoesntHarmPooling(TransferKind.CHUNKED);
-  }
-
-  @Test public void earlyDisconnectDoesntHarmPoolingWithFixedLengthEncoding() throws Exception {
-    testEarlyDisconnectDoesntHarmPooling(TransferKind.FIXED_LENGTH);
-  }
-
-  private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) throws Exception {
-    MockResponse response1 = new MockResponse();
-    transferKind.setBody(response1, "ABCDEFGHIJK", 1024);
-    server.enqueue(response1);
-
-    MockResponse response2 = new MockResponse();
-    transferKind.setBody(response2, "LMNOPQRSTUV", 1024);
-    server.enqueue(response2);
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    InputStream in1 = connection1.getInputStream();
-    assertEquals("ABCDE", readAscii(in1, 5));
-    in1.close();
-    connection1.disconnect();
-
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    InputStream in2 = connection2.getInputStream();
-    assertEquals("LMNOP", readAscii(in2, 5));
-    in2.close();
-    connection2.disconnect();
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection is pooled!
-  }
-
-  @Test public void streamDiscardingIsTimely() throws Exception {
-    // This response takes at least a full second to serve: 10,000 bytes served 100 bytes at a time.
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[10000]))
-        .throttleBody(100, 10, MILLISECONDS));
-    server.enqueue(new MockResponse().setBody("A"));
-
-    long startNanos = System.nanoTime();
-    URLConnection connection1 = urlFactory.open(server.url("/").url());
-    InputStream in = connection1.getInputStream();
-    in.close();
-    long elapsedNanos = System.nanoTime() - startNanos;
-    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-
-    // If we're working correctly, this should be greater than 100ms, but less than double that.
-    // Previously we had a bug where we would download the entire response body as long as no
-    // individual read took longer than 100ms.
-    assertTrue(Util.format("Time to close: %sms", elapsedMillis), elapsedMillis < 500);
-
-    // Do another request to confirm that the discarded connection was not pooled.
-    assertContent("A", urlFactory.open(server.url("/").url()));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
-  }
-
-  @Test public void setChunkedStreamingMode() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse());
-
-    String body = "ABCDEFGHIJKLMNOPQ";
-    connection = urlFactory.open(server.url("/").url());
-    connection.setChunkedStreamingMode(0); // OkHttp does not honor specific chunk sizes.
-    connection.setDoOutput(true);
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(body.getBytes("US-ASCII"));
-    assertEquals(200, connection.getResponseCode());
-    connection.getInputStream().close();
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(body, request.getBody().readUtf8());
-    assertEquals(Arrays.asList(body.length()), request.getChunkSizes());
-  }
-
-  @Test public void authenticateWithFixedLengthStreaming() throws Exception {
-    testAuthenticateWithStreamingPost(StreamingMode.FIXED_LENGTH);
-  }
-
-  @Test public void authenticateWithChunkedStreaming() throws Exception {
-    testAuthenticateWithStreamingPost(StreamingMode.CHUNKED);
-  }
-
-  private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    byte[] requestBody = {'A', 'B', 'C', 'D'};
-    if (streamingMode == StreamingMode.FIXED_LENGTH) {
-      connection.setFixedLengthStreamingMode(requestBody.length);
-    } else if (streamingMode == StreamingMode.CHUNKED) {
-      connection.setChunkedStreamingMode(0);
-    }
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (HttpRetryException expected) {
-    }
-
-    // no authorization header for the request...
-    RecordedRequest request = server.takeRequest();
-    assertNull(request.getHeader("Authorization"));
-    assertEquals("ABCD", request.getBody().readUtf8());
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(401));
-    server.enqueue(new MockResponse());
-
-    String credential = Credentials.basic("jesse", "secret");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
-        .build());
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(body.getBytes("UTF-8"));
-    outputStream.close();
-    assertEquals(200, connection.getResponseCode());
-    connection.getInputStream().close();
-
-    RecordedRequest recordedRequest1 = server.takeRequest();
-    assertEquals("POST", recordedRequest1.getMethod());
-    assertEquals(body, recordedRequest1.getBody().readUtf8());
-    assertNull(recordedRequest1.getHeader("Authorization"));
-
-    RecordedRequest recordedRequest2 = server.takeRequest();
-    assertEquals("POST", recordedRequest2.getMethod());
-    assertEquals(body, recordedRequest2.getBody().readUtf8());
-    assertEquals(credential, recordedRequest2.getHeader("Authorization"));
-  }
-
-  @Test public void nonStandardAuthenticationScheme() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo");
-    assertEquals(Collections.<String>emptyList(), calls);
-  }
-
-  @Test public void nonStandardAuthenticationSchemeWithRealm() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo realm=\"Bar\"");
-    assertEquals(0, calls.size());
-  }
-
-  // Digest auth is currently unsupported. Test that digest requests should fail reasonably.
-  // http://code.google.com/p/android/issues/detail?id=11140
-  @Test public void digestAuthentication() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Digest "
-        + "realm=\"testrealm@host.com\", qop=\"auth,auth-int\", "
-        + "nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", "
-        + "opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"");
-    assertEquals(0, calls.size());
-  }
-
-  @Test public void allAttributesSetInServerAuthenticationCallbacks() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Basic realm=\"Bar\"");
-    assertEquals(1, calls.size());
-    URL url = server.url("/").url();
-    String call = calls.get(0);
-    assertTrue(call, call.contains("host=" + url.getHost()));
-    assertTrue(call, call.contains("port=" + url.getPort()));
-    assertTrue(call, call.contains("site=" + url.getHost()));
-    assertTrue(call, call.contains("url=" + url));
-    assertTrue(call, call.contains("type=" + Authenticator.RequestorType.SERVER));
-    assertTrue(call, call.contains("prompt=Bar"));
-    assertTrue(call, call.contains("protocol=http"));
-    assertTrue(call, call.toLowerCase().contains("scheme=basic")); // lowercase for the RI.
-  }
-
-  @Test public void allAttributesSetInProxyAuthenticationCallbacks() throws Exception {
-    List<String> calls = authCallsForHeader("Proxy-Authenticate: Basic realm=\"Bar\"");
-    assertEquals(1, calls.size());
-    URL url = server.url("/").url();
-    String call = calls.get(0);
-    assertTrue(call, call.contains("host=" + url.getHost()));
-    assertTrue(call, call.contains("port=" + url.getPort()));
-    assertTrue(call, call.contains("site=" + url.getHost()));
-    assertTrue(call, call.contains("url=http://android.com"));
-    assertTrue(call, call.contains("type=" + Authenticator.RequestorType.PROXY));
-    assertTrue(call, call.contains("prompt=Bar"));
-    assertTrue(call, call.contains("protocol=http"));
-    assertTrue(call, call.toLowerCase().contains("scheme=basic")); // lowercase for the RI.
-  }
-
-  private List<String> authCallsForHeader(String authHeader) throws IOException {
-    boolean proxy = authHeader.startsWith("Proxy-");
-    int responseCode = proxy ? 407 : 401;
-    RecordingAuthenticator authenticator = new RecordingAuthenticator(null);
-    Authenticator.setDefault(authenticator);
-    MockResponse pleaseAuthenticate = new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader(authHeader)
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-
-    if (proxy) {
-      urlFactory.setClient(urlFactory.client().newBuilder()
-          .proxy(server.toProxyAddress())
-          .proxyAuthenticator(new JavaNetAuthenticator())
-          .build());
-      connection = urlFactory.open(new URL("http://android.com/"));
-    } else {
-      urlFactory.setClient(urlFactory.client().newBuilder()
-          .authenticator(new JavaNetAuthenticator())
-          .build());
-      connection = urlFactory.open(server.url("/").url());
-    }
-    assertEquals(responseCode, connection.getResponseCode());
-    connection.getErrorStream().close();
-    return authenticator.calls;
-  }
-
-  @Test public void setValidRequestMethod() throws Exception {
-    assertValidRequestMethod("GET");
-    assertValidRequestMethod("DELETE");
-    assertValidRequestMethod("HEAD");
-    assertValidRequestMethod("OPTIONS");
-    assertValidRequestMethod("POST");
-    assertValidRequestMethod("PUT");
-    assertValidRequestMethod("TRACE");
-    assertValidRequestMethod("PATCH");
-  }
-
-  private void assertValidRequestMethod(String requestMethod) throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    connection.setRequestMethod(requestMethod);
-    assertEquals(requestMethod, connection.getRequestMethod());
-  }
-
-  @Test public void setInvalidRequestMethodLowercase() throws Exception {
-    assertInvalidRequestMethod("get");
-  }
-
-  @Test public void setInvalidRequestMethodConnect() throws Exception {
-    assertInvalidRequestMethod("CONNECT");
-  }
-
-  private void assertInvalidRequestMethod(String requestMethod) throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.setRequestMethod(requestMethod);
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void shoutcast() throws Exception {
-    server.enqueue(new MockResponse().setStatus("ICY 200 OK")
-        // .addHeader("HTTP/1.0 200 OK")
-        .addHeader("Accept-Ranges: none")
-        .addHeader("Content-Type: audio/mpeg")
-        .addHeader("icy-br:128")
-        .addHeader("ice-audio-info: bitrate=128;samplerate=44100;channels=2")
-        .addHeader("icy-br:128")
-        .addHeader("icy-description:Rock")
-        .addHeader("icy-genre:riders")
-        .addHeader("icy-name:A2RRock")
-        .addHeader("icy-pub:1")
-        .addHeader("icy-url:http://www.A2Rradio.com")
-        .addHeader("Server: Icecast 2.3.3-kh8")
-        .addHeader("Cache-Control: no-cache")
-        .addHeader("Pragma: no-cache")
-        .addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT")
-        .addHeader("icy-metaint:16000")
-        .setBody("mp3 data"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("OK", connection.getResponseMessage());
-    assertContent("mp3 data", connection);
-  }
-
-  @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.setFixedLengthStreamingMode(-2);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void canSetNegativeChunkedStreamingMode() throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    connection.setChunkedStreamingMode(-2);
-  }
-
-  @Test public void cannotSetFixedLengthStreamingModeAfterConnect() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    try {
-      connection.setFixedLengthStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cannotSetChunkedStreamingModeAfterConnect() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    try {
-      connection.setChunkedStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    connection.setChunkedStreamingMode(1);
-    try {
-      connection.setFixedLengthStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    connection.setFixedLengthStreamingMode(1);
-    try {
-      connection.setChunkedStreamingMode(1);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void secureFixedLengthStreaming() throws Exception {
-    testSecureStreamingPost(StreamingMode.FIXED_LENGTH);
-  }
-
-  @Test public void secureChunkedStreaming() throws Exception {
-    testSecureStreamingPost(StreamingMode.CHUNKED);
-  }
-
-  /**
-   * Users have reported problems using HTTPS with streaming request bodies.
-   * http://code.google.com/p/android/issues/detail?id=12860
-   */
-  private void testSecureStreamingPost(StreamingMode streamingMode) throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    byte[] requestBody = {'A', 'B', 'C', 'D'};
-    if (streamingMode == StreamingMode.FIXED_LENGTH) {
-      connection.setFixedLengthStreamingMode(requestBody.length);
-    } else if (streamingMode == StreamingMode.CHUNKED) {
-      connection.setChunkedStreamingMode(0);
-    }
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    assertEquals("Success!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("POST / HTTP/1.1", request.getRequestLine());
-    if (streamingMode == StreamingMode.FIXED_LENGTH) {
-      assertEquals(Collections.<Integer>emptyList(), request.getChunkSizes());
-    } else if (streamingMode == StreamingMode.CHUNKED) {
-      assertEquals(Arrays.asList(4), request.getChunkSizes());
-    }
-    assertEquals("ABCD", request.getBody().readUtf8());
-  }
-
-  enum StreamingMode {
-    FIXED_LENGTH, CHUNKED
-  }
-
-  @Test public void authenticateWithPost() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    byte[] requestBody = {'A', 'B', 'C', 'D'};
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    // no authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertNull(request.getHeader("Authorization"));
-
-    // ...but the three requests that follow include an authorization header
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertEquals("POST / HTTP/1.1", request.getRequestLine());
-      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-          request.getHeader("Authorization"));
-      assertEquals("ABCD", request.getBody().readUtf8());
-    }
-  }
-
-  @Test public void authenticateWithGet() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    // no authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertNull(request.getHeader("Authorization"));
-
-    // ...but the three requests that follow requests include an authorization header
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertEquals("GET / HTTP/1.1", request.getRequestLine());
-      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-          request.getHeader("Authorization"));
-    }
-  }
-
-  @Test public void authenticateWithCharset() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
-        .setBody("Please authenticate with UTF-8."));
-    server.enqueue(new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate with ISO-8859-1."));
-    server.enqueue(new MockResponse()
-        .setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator(
-        new PasswordAuthentication("username", "m√∂torhead".toCharArray())));
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    // No authorization header for the first request...
-    RecordedRequest request1 = server.takeRequest();
-    assertNull(request1.getHeader("Authorization"));
-
-    // UTF-8 encoding for the first credential.
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("Basic dXNlcm5hbWU6bcO2dG9yaGVhZA==", request2.getHeader("Authorization"));
-
-    // ISO-8859-1 encoding for the second credential.
-    RecordedRequest request3 = server.takeRequest();
-    assertEquals("Basic dXNlcm5hbWU6bfZ0b3JoZWFk", request3.getHeader("Authorization"));
-  }
-
-  /** https://code.google.com/p/android/issues/detail?id=74026 */
-  @Test public void authenticateWithGetAndTransparentGzip() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time
-    MockResponse successfulResponse = new MockResponse()
-        .addHeader("Content-Encoding", "gzip")
-        .setBody(gzip("Successful auth!"));
-    server.enqueue(successfulResponse);
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    // no authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertNull(request.getHeader("Authorization"));
-
-    // ...but the three requests that follow requests include an authorization header
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertEquals("GET / HTTP/1.1", request.getRequestLine());
-      assertEquals("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS,
-          request.getHeader("Authorization"));
-    }
-  }
-
-  /** https://github.com/square/okhttp/issues/342 */
-  @Test public void authenticateRealmUppercase() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(401)
-        .addHeader("wWw-aUtHeNtIcAtE: bAsIc rEaLm=\"pRoTeCtEd aReA\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse().setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  @Test public void redirectedWithChunkedEncoding() throws Exception {
-    testRedirected(TransferKind.CHUNKED, true);
-  }
-
-  @Test public void redirectedWithContentLengthHeader() throws Exception {
-    testRedirected(TransferKind.FIXED_LENGTH, true);
-  }
-
-  @Test public void redirectedWithNoLengthHeaders() throws Exception {
-    testRedirected(TransferKind.END_OF_STREAM, false);
-  }
-
-  private void testRedirected(TransferKind transferKind, boolean reuse) throws Exception {
-    MockResponse response = new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo");
-    transferKind.setBody(response, "This page has moved!", 10);
-    server.enqueue(response);
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("This is the new location!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest first = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", first.getRequestLine());
-    RecordedRequest retry = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", retry.getRequestLine());
-    if (reuse) {
-      assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
-    }
-  }
-
-  @Test public void redirectedOnHttps() throws IOException, InterruptedException {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("This is the new location!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest first = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", first.getRequestLine());
-    RecordedRequest retry = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", retry.getRequestLine());
-    assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
-  }
-
-  @Test public void notRedirectedFromHttpsToHttp() throws IOException, InterruptedException {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: http://anyhost/foo")
-        .setBody("This page has moved!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .followSslRedirects(false)
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  @Test public void notRedirectedFromHttpToHttps() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: https://anyhost/foo")
-        .setBody("This page has moved!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .followSslRedirects(false)
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
-    server2.enqueue(new MockResponse().setBody("This is insecure HTTP!"));
-
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url())
-        .setBody("This page has moved!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .followSslRedirects(true)
-        .build());
-    HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(server.url("/").url());
-    assertContent("This is insecure HTTP!", connection);
-    assertNull(connection.getCipherSuite());
-    assertNull(connection.getLocalCertificates());
-    assertNull(connection.getServerCertificates());
-    assertNull(connection.getPeerPrincipal());
-    assertNull(connection.getLocalPrincipal());
-  }
-
-  @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
-    server2.useHttps(sslClient.socketFactory, false);
-    server2.enqueue(new MockResponse().setBody("This is secure HTTPS!"));
-
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url())
-        .setBody("This page has moved!"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .followSslRedirects(true)
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertContent("This is secure HTTPS!", connection);
-    assertFalse(connection instanceof HttpsURLConnection);
-  }
-
-  @Test public void redirectToAnotherOriginServer() throws Exception {
-    redirectToAnotherOriginServer(false);
-  }
-
-  @Test public void redirectToAnotherOriginServerWithHttps() throws Exception {
-    redirectToAnotherOriginServer(true);
-  }
-
-  private void redirectToAnotherOriginServer(boolean https) throws Exception {
-    if (https) {
-      server.useHttps(sslClient.socketFactory, false);
-      server2.useHttps(sslClient.socketFactory, false);
-      server2.setProtocolNegotiationEnabled(false);
-      urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-          .hostnameVerifier(new RecordingHostnameVerifier())
-          .build());
-    }
-
-    server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
-    server2.enqueue(new MockResponse().setBody("This is the 2nd server, again!"));
-
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url().toString())
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the first server again!"));
-
-    connection = urlFactory.open(server.url("/").url());
-    assertContent("This is the 2nd server!", connection);
-    assertEquals(server2.url("/").url(), connection.getURL());
-
-    // make sure the first server was careful to recycle the connection
-    assertContent("This is the first server again!", urlFactory.open(server.url("/").url()));
-    assertContent("This is the 2nd server, again!", urlFactory.open(server2.url("/").url()));
-
-    String server1Host = server.getHostName() + ":" + server.getPort();
-    String server2Host = server2.getHostName() + ":" + server2.getPort();
-    assertEquals(server1Host, server.takeRequest().getHeader("Host"));
-    assertEquals(server2Host, server2.takeRequest().getHeader("Host"));
-    assertEquals("Expected connection reuse", 1, server.takeRequest().getSequenceNumber());
-    assertEquals("Expected connection reuse", 1, server2.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void redirectWithProxySelector() throws Exception {
-    final List<URI> proxySelectionRequests = new ArrayList<>();
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .proxySelector(new ProxySelector() {
-          @Override public List<Proxy> select(URI uri) {
-            proxySelectionRequests.add(uri);
-            MockWebServer proxyServer = (uri.getPort() == server.getPort())
-                ? server
-                : server2;
-            return Arrays.asList(proxyServer.toProxyAddress());
-          }
-
-          @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
-            throw new AssertionError();
-          }
-        })
-        .build());
-
-    server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
-
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/b").url().toString())
-        .setBody("This page has moved!"));
-
-    assertContent("This is the 2nd server!", urlFactory.open(server.url("/a").url()));
-
-    assertEquals(Arrays.asList(server.url("/").url().toURI(), server2.url("/").url().toURI()),
-        proxySelectionRequests);
-  }
-
-  @Test public void redirectWithAuthentication() throws Exception {
-    server2.enqueue(new MockResponse().setBody("Page 2"));
-
-    server.enqueue(new MockResponse().setResponseCode(401));
-    server.enqueue(new MockResponse().setResponseCode(302)
-        .addHeader("Location: " + server2.url("/b").url()));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
-        .build());
-    assertContent("Page 2", urlFactory.open(server.url("/a").url()));
-
-    RecordedRequest redirectRequest = server2.takeRequest();
-    assertNull(redirectRequest.getHeader("Authorization"));
-    assertEquals("/b", redirectRequest.getPath());
-  }
-
-  @Test public void response300MultipleChoiceWithPost() throws Exception {
-    // Chrome doesn't follow the redirect, but Firefox and the RI both do
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MULT_CHOICE, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response301MovedPermanentlyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_PERM, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response302MovedTemporarilyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response303SeeOtherWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_SEE_OTHER, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void postRedirectToGetWithChunkedRequest() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.CHUNKED);
-  }
-
-  @Test public void postRedirectToGetWithStreamedRequest() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.FIXED_LENGTH);
-  }
-
-  private void testResponseRedirectedWithPost(int redirectCode, TransferKind transferKind)
-      throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(redirectCode)
-        .addHeader("Location: /page2")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    connection = urlFactory.open(server.url("/page1").url());
-    connection.setDoOutput(true);
-    transferKind.setForRequest(connection, 4);
-    byte[] requestBody = {'A', 'B', 'C', 'D'};
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write(requestBody);
-    outputStream.close();
-    assertEquals("Page 2", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    assertTrue(connection.getDoOutput());
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
-    assertEquals("ABCD", page1.getBody().readUtf8());
-
-    RecordedRequest page2 = server.takeRequest();
-    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
-  }
-
-  @Test public void redirectedPostStripsRequestBodyHeaders() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /page2"));
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    connection = urlFactory.open(server.url("/page1").url());
-    connection.setDoOutput(true);
-    connection.addRequestProperty("Content-Length", "4");
-    connection.addRequestProperty("Content-Type", "text/plain; charset=utf-8");
-    connection.addRequestProperty("Transfer-Encoding", "identity");
-    OutputStream outputStream = connection.getOutputStream();
-    outputStream.write("ABCD".getBytes("UTF-8"));
-    outputStream.close();
-    assertEquals("Page 2", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    assertEquals("POST /page1 HTTP/1.1", server.takeRequest().getRequestLine());
-
-    RecordedRequest page2 = server.takeRequest();
-    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
-    assertNull(page2.getHeader("Content-Length"));
-    assertNull(page2.getHeader("Content-Type"));
-    assertNull(page2.getHeader("Transfer-Encoding"));
-  }
-
-  @Test public void response305UseProxy() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_USE_PROXY)
-        .addHeader("Location: " + server.url("/").url())
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("Proxy Response"));
-
-    connection = urlFactory.open(server.url("/foo").url());
-    // Fails on the RI, which gets "Proxy Response"
-    assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", page1.getRequestLine());
-    assertEquals(1, server.getRequestCount());
-  }
-
-  @Test public void response307WithGet() throws Exception {
-    testRedirect(true, "GET");
-  }
-
-  @Test public void response307WithHead() throws Exception {
-    testRedirect(true, "HEAD");
-  }
-
-  @Test public void response307WithOptions() throws Exception {
-    testRedirect(true, "OPTIONS");
-  }
-
-  @Test public void response307WithPost() throws Exception {
-    testRedirect(true, "POST");
-  }
-
-  @Test public void response308WithGet() throws Exception {
-    testRedirect(false, "GET");
-  }
-
-  @Test public void response308WithHead() throws Exception {
-    testRedirect(false, "HEAD");
-  }
-
-  @Test public void response308WithOptions() throws Exception {
-    testRedirect(false, "OPTIONS");
-  }
-
-  @Test public void response308WithPost() throws Exception {
-    testRedirect(false, "POST");
-  }
-
-  private void testRedirect(boolean temporary, String method) throws Exception {
-    MockResponse response1 = new MockResponse()
-        .setResponseCode(temporary ? HTTP_TEMP_REDIRECT : HTTP_PERM_REDIRECT)
-        .addHeader("Location: /page2");
-    if (!method.equals("HEAD")) {
-      response1.setBody("This page has moved!");
-    }
-    server.enqueue(response1);
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    connection = urlFactory.open(server.url("/page1").url());
-    connection.setRequestMethod(method);
-    byte[] requestBody = {'A', 'B', 'C', 'D'};
-    if (method.equals("POST")) {
-      connection.setDoOutput(true);
-      OutputStream outputStream = connection.getOutputStream();
-      outputStream.write(requestBody);
-      outputStream.close();
-    }
-
-    String response = readAscii(connection.getInputStream(), Integer.MAX_VALUE);
-
-    RecordedRequest page1 = server.takeRequest();
-    assertEquals(method + " /page1 HTTP/1.1", page1.getRequestLine());
-
-    if (method.equals("GET")) {
-      assertEquals("Page 2", response);
-    } else if (method.equals("HEAD")) {
-      assertEquals("", response);
-    } else {
-      // Methods other than GET/HEAD shouldn't follow the redirect
-      if (method.equals("POST")) {
-        assertTrue(connection.getDoOutput());
-        assertEquals("ABCD", page1.getBody().readUtf8());
-      }
-      assertEquals(1, server.getRequestCount());
-      assertEquals("This page has moved!", response);
-      return;
-    }
-
-    // GET/HEAD requests should have followed the redirect with the same method
-    assertFalse(connection.getDoOutput());
-    assertEquals(2, server.getRequestCount());
-    RecordedRequest page2 = server.takeRequest();
-    assertEquals(method + " /page2 HTTP/1.1", page2.getRequestLine());
-  }
-
-  @Test public void follow20Redirects() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    connection = urlFactory.open(server.url("/0").url());
-    assertContent("Success!", connection);
-    assertEquals(server.url("/20").url(), connection.getURL());
-  }
-
-  @Test public void doesNotFollow21Redirects() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-
-    connection = urlFactory.open(server.url("/0").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (ProtocolException expected) {
-      assertEquals(HttpURLConnection.HTTP_MOVED_TEMP, connection.getResponseCode());
-      assertEquals("Too many follow-up requests: 21", expected.getMessage());
-      assertEquals(server.url("/20").url(), connection.getURL());
-    }
-  }
-
-  @Test public void httpsWithCustomTrustManager() throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    RecordingTrustManager trustManager = new RecordingTrustManager(sslClient.trustManager);
-    SSLContext sslContext = Platform.get().getSSLContext();
-    sslContext.init(null, new TrustManager[] { trustManager }, null);
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .hostnameVerifier(hostnameVerifier)
-        .sslSocketFactory(sslContext.getSocketFactory(), trustManager)
-        .build());
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-    server.enqueue(new MockResponse().setBody("GHI"));
-
-    URL url = server.url("/").url();
-    assertContent("ABC", urlFactory.open(url));
-    assertContent("DEF", urlFactory.open(url));
-    assertContent("GHI", urlFactory.open(url));
-
-    assertEquals(Arrays.asList("verify " + server.getHostName()), hostnameVerifier.calls);
-    assertEquals(Arrays.asList("checkServerTrusted [CN=" + server.getHostName() + " 1]"),
-        trustManager.calls);
-  }
-
-  @Test public void getClientRequestTimeout() throws Exception {
-    enqueueClientRequestTimeoutResponses();
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Body", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-  }
-
-  private void enqueueClientRequestTimeoutResponses() {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(HttpURLConnection.HTTP_CLIENT_TIMEOUT)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse().setBody("Body"));
-  }
-
-  @Test public void bufferedBodyWithClientRequestTimeout() throws Exception {
-    enqueueClientRequestTimeoutResponses();
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setRequestMethod("POST");
-    connection.getOutputStream().write("Hello".getBytes("UTF-8"));
-
-    assertEquals(200, connection.getResponseCode());
-    assertEquals("Body", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("Hello", request1.getBody().readUtf8());
-
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("Hello", request2.getBody().readUtf8());
-  }
-
-  @Test public void streamedBodyWithClientRequestTimeout() throws Exception {
-    enqueueClientRequestTimeoutResponses();
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setRequestMethod("POST");
-    connection.setChunkedStreamingMode(0);
-    connection.getOutputStream().write("Hello".getBytes("UTF-8"));
-
-    assertEquals(408, connection.getResponseCode());
-    assertEquals(1, server.getRequestCount());
-    connection.getErrorStream().close();
-  }
-
-  @Test public void readTimeouts() throws IOException {
-    // This relies on the fact that MockWebServer doesn't close the
-    // connection after a response has been sent. This causes the client to
-    // try to read more bytes than are sent, which results in a timeout.
-    MockResponse timeout =
-        new MockResponse().setBody("ABC").clearHeaders().addHeader("Content-Length: 4");
-    server.enqueue(timeout);
-    server.enqueue(new MockResponse().setBody("unused")); // to keep the server alive
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setReadTimeout(1000);
-    InputStream in = connection.getInputStream();
-    assertEquals('A', in.read());
-    assertEquals('B', in.read());
-    assertEquals('C', in.read());
-    try {
-      in.read(); // if Content-Length was accurate, this would return -1 immediately
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-    in.close();
-  }
-
-  /** Confirm that an unacknowledged write times out. */
-  @Test public void writeTimeouts() throws IOException {
-    MockWebServer server = new MockWebServer();
-    // Sockets on some platforms can have large buffers that mean writes do not block when
-    // required. These socket factories explicitly set the buffer sizes on sockets created.
-    final int SOCKET_BUFFER_SIZE = 4 * 1024;
-    server.setServerSocketFactory(
-        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
-          @Override
-          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
-              throws IOException {
-            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            return serverSocket;
-          }
-        });
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-          @Override protected Socket configureSocket(Socket socket) throws IOException {
-            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-            return socket;
-          }
-        })
-        .writeTimeout(500, TimeUnit.MILLISECONDS)
-        .build());
-
-    server.start();
-    server.enqueue(new MockResponse()
-        .throttleBody(1, 1, TimeUnit.SECONDS)); // Prevent the server from reading!
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    connection.setChunkedStreamingMode(0);
-    OutputStream out = connection.getOutputStream();
-    try {
-      byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
-      out.write(data);
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-  }
-
-  @Test public void setChunkedEncodingAsRequestProperty() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse());
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setRequestProperty("Transfer-encoding", "chunked");
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("ABC".getBytes("UTF-8"));
-    assertEquals(200, connection.getResponseCode());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("ABC", request.getBody().readUtf8());
-  }
-
-  @Test public void connectionCloseInRequest() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse()); // server doesn't honor the connection: close header!
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection a = urlFactory.open(server.url("/").url());
-    a.setRequestProperty("Connection", "close");
-    assertEquals(200, a.getResponseCode());
-
-    HttpURLConnection b = urlFactory.open(server.url("/").url());
-    assertEquals(200, b.getResponseCode());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals("When connection: close is used, each request should get its own connection", 0,
-        server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectionCloseInResponse() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().addHeader("Connection: close"));
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection a = urlFactory.open(server.url("/").url());
-    assertEquals(200, a.getResponseCode());
-
-    HttpURLConnection b = urlFactory.open(server.url("/").url());
-    assertEquals(200, b.getResponseCode());
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals("When connection: close is used, each request should get its own connection", 0,
-        server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void connectionCloseWithRedirect() throws IOException, InterruptedException {
-    MockResponse response = new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .addHeader("Connection: close");
-    server.enqueue(response);
-    server.enqueue(new MockResponse()
-        .setBody("This is the new location!"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("This is the new location!",
-        readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals("When connection: close is used, each request should get its own connection", 0,
-        server.takeRequest().getSequenceNumber());
-  }
-
-  /**
-   * Retry redirects if the socket is closed.
-   * https://code.google.com/p/android/issues/detail?id=41576
-   */
-  @Test public void sameConnectionRedirectAndReuse() throws Exception {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new SingleInetAddressDns())
-        .build());
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .setBody("This is the new page!"));
-
-    assertContent("This is the new page!", urlFactory.open(server.url("/").url()));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void responseCodeDisagreesWithHeaders() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
-        .setBody("This body is not allowed!"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (IOException expected) {
-      assertEquals("HTTP 204 had non-zero Content-Length: 25", expected.getMessage());
-    }
-  }
-
-  @Test public void singleByteReadIsSigned() throws IOException {
-    server.enqueue(new MockResponse().setBody(new Buffer().writeByte(-2).writeByte(-1)));
-
-    connection = urlFactory.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals(254, in.read());
-    assertEquals(255, in.read());
-    assertEquals(-1, in.read());
-  }
-
-  @Test public void flushAfterStreamTransmittedWithChunkedEncoding() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.CHUNKED);
-  }
-
-  @Test public void flushAfterStreamTransmittedWithFixedLength() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void flushAfterStreamTransmittedWithNoLengthHeaders() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.END_OF_STREAM);
-  }
-
-  /**
-   * We explicitly permit apps to close the upload stream even after it has been transmitted.  We
-   * also permit flush so that buffered streams can do a no-op flush when they are closed.
-   * http://b/3038470
-   */
-  private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws IOException {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    byte[] upload = "def".getBytes("UTF-8");
-
-    if (transferKind == TransferKind.CHUNKED) {
-      connection.setChunkedStreamingMode(0);
-    } else if (transferKind == TransferKind.FIXED_LENGTH) {
-      connection.setFixedLengthStreamingMode(upload.length);
-    }
-
-    OutputStream out = connection.getOutputStream();
-    out.write(upload);
-    assertEquals("abc", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-
-    out.flush(); // Dubious but permitted.
-    try {
-      out.write("ghi".getBytes("UTF-8"));
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void getHeadersThrows() throws IOException {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void dnsFailureThrowsIOException() throws IOException {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new FakeDns())
-        .build());
-    connection = urlFactory.open(new URL("http://host.unlikelytld"));
-    try {
-      connection.connect();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
-    connection = urlFactory.open(new URL("http://./foo.html"));
-    try {
-      connection.connect();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void getKeepAlive() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC"));
-
-    // The request should work once and then fail
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    connection1.setReadTimeout(100);
-    InputStream input = connection1.getInputStream();
-    assertEquals("ABC", readAscii(input, Integer.MAX_VALUE));
-    server.shutdown();
-    try {
-      HttpURLConnection connection2 = urlFactory.open(server.url("").url());
-      connection2.setReadTimeout(100);
-      connection2.getInputStream();
-      fail();
-    } catch (ConnectException expected) {
-    }
-  }
-
-  /** http://code.google.com/p/android/issues/detail?id=14562 */
-  @Test public void readAfterLastByte() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC")
-        .clearHeaders()
-        .addHeader("Connection: close")
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    connection = urlFactory.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals("ABC", readAscii(in, 3));
-    assertEquals(-1, in.read());
-    assertEquals(-1, in.read()); // throws IOException in Gingerbread
-  }
-
-  @Test public void getContent() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    InputStream in = (InputStream) connection.getContent();
-    assertEquals("A", readAscii(in, Integer.MAX_VALUE));
-  }
-
-  @Test public void getContentOfType() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getContent(null);
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    try {
-      connection.getContent(new Class[] {null});
-      fail();
-    } catch (NullPointerException expected) {
-    }
-    assertNull(connection.getContent(new Class[] {getClass()}));
-    connection.getInputStream().close();
-  }
-
-  @Test public void getOutputStreamOnGetFails() throws Exception {
-    server.enqueue(new MockResponse());
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getOutputStream();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-    connection.getInputStream().close();
-  }
-
-  @Test public void getOutputAfterGetInputStreamFails() throws Exception {
-    server.enqueue(new MockResponse());
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    try {
-      connection.getInputStream();
-      connection.getOutputStream();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void setDoOutputOrDoInputAfterConnectFails() throws Exception {
-    server.enqueue(new MockResponse());
-    connection = urlFactory.open(server.url("/").url());
-    connection.connect();
-    try {
-      connection.setDoOutput(true);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      connection.setDoInput(true);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    connection.getInputStream().close();
-  }
-
-  @Test public void clientSendsContentLength() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    OutputStream out = connection.getOutputStream();
-    out.write(new byte[] {'A', 'B', 'C'});
-    out.close();
-    assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
-    RecordedRequest request = server.takeRequest();
-    assertEquals("3", request.getHeader("Content-Length"));
-    connection.getInputStream().close();
-  }
-
-  @Test public void getContentLengthConnects() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(3, connection.getContentLength());
-    connection.getInputStream().close();
-  }
-
-  @Test public void getContentTypeConnects() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("ABC"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("text/plain", connection.getContentType());
-    connection.getInputStream().close();
-  }
-
-  @Test public void getContentEncodingConnects() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Encoding: identity").setBody("ABC"));
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("identity", connection.getContentEncoding());
-    connection.getInputStream().close();
-  }
-
-  // http://b/4361656
-  @Test public void urlContainsQueryButNoPath() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    URL url = new URL("http", server.getHostName(), server.getPort(), "?query");
-    assertEquals("A", readAscii(urlFactory.open(url).getInputStream(), Integer.MAX_VALUE));
-    RecordedRequest request = server.takeRequest();
-    assertEquals("GET /?query HTTP/1.1", request.getRequestLine());
-  }
-
-  @Test public void doOutputForMethodThatDoesntSupportOutput() throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    connection.setRequestMethod("HEAD");
-    connection.setDoOutput(true);
-    try {
-      connection.connect();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  // http://code.google.com/p/android/issues/detail?id=20442
-  @Test public void inputStreamAvailableWithChunkedEncoding() throws Exception {
-    testInputStreamAvailable(TransferKind.CHUNKED);
-  }
-
-  @Test public void inputStreamAvailableWithContentLengthHeader() throws Exception {
-    testInputStreamAvailable(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void inputStreamAvailableWithNoLengthHeaders() throws Exception {
-    testInputStreamAvailable(TransferKind.END_OF_STREAM);
-  }
-
-  private void testInputStreamAvailable(TransferKind transferKind) throws IOException {
-    String body = "ABCDEFGH";
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, body, 4);
-    server.enqueue(response);
-    connection = urlFactory.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    for (int i = 0; i < body.length(); i++) {
-      assertTrue(in.available() >= 0);
-      assertEquals(body.charAt(i), in.read());
-    }
-    assertEquals(0, in.available());
-    assertEquals(-1, in.read());
-  }
-
-  @Test public void postFailsWithBufferedRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 1024);
-  }
-
-  @Test public void postFailsWithBufferedRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 16384);
-  }
-
-  @Test public void postFailsWithChunkedRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 1024);
-  }
-
-  @Test public void postFailsWithChunkedRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 16384);
-  }
-
-  @Test public void postFailsWithFixedLengthRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 1024);
-  }
-
-  @Test public void postFailsWithFixedLengthRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 16384);
-  }
-
-  private void reusedConnectionFailsWithPost(TransferKind transferKind, int requestSize)
-      throws Exception {
-    server.enqueue(new MockResponse().setBody("A").setSocketPolicy(DISCONNECT_AT_END));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    assertContent("A", urlFactory.open(server.url("/a").url()));
-
-    // Give the server time to disconnect.
-    Thread.sleep(500);
-
-    // If the request body is larger than OkHttp's replay buffer, the failure may still occur.
-    byte[] requestBody = new byte[requestSize];
-    new Random(0).nextBytes(requestBody);
-
-    for (int j = 0; j < 2; j++) {
-      try {
-        connection = urlFactory.open(server.url("/b").url());
-        connection.setRequestMethod("POST");
-        transferKind.setForRequest(connection, requestBody.length);
-        for (int i = 0; i < requestBody.length; i += 1024) {
-          connection.getOutputStream().write(requestBody, i, 1024);
-        }
-        connection.getOutputStream().close();
-        assertContent("B", connection);
-        break;
-      } catch (IOException socketException) {
-        // If there's a socket exception, this must have a streamed request body.
-        assertEquals(0, j);
-        assertTrue(transferKind == TransferKind.CHUNKED
-            || transferKind == TransferKind.FIXED_LENGTH);
-      }
-    }
-
-    RecordedRequest requestA = server.takeRequest();
-    assertEquals("/a", requestA.getPath());
-    RecordedRequest requestB = server.takeRequest();
-    assertEquals("/b", requestB.getPath());
-    assertEquals(Arrays.toString(requestBody), Arrays.toString(requestB.getBody().readByteArray()));
-  }
-
-  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    // Seed the connection pool so we have something that can fail.
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-
-    HttpURLConnection post = urlFactory.open(server.url("/").url());
-    post.setDoOutput(true);
-    post.getOutputStream().write("body!".getBytes(UTF_8));
-    assertContent("def", post);
-
-    RecordedRequest get = server.takeRequest();
-    assertEquals(0, get.getSequenceNumber());
-
-    RecordedRequest post1 = server.takeRequest();
-    assertEquals("body!", post1.getBody().readUtf8());
-    assertEquals(1, post1.getSequenceNumber());
-
-    RecordedRequest post2 = server.takeRequest();
-    assertEquals("body!", post2.getBody().readUtf8());
-    assertEquals(0, post2.getSequenceNumber());
-  }
-
-  @Test public void fullyBufferedPostIsTooShort() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    connection = urlFactory.open(server.url("/b").url());
-    connection.setRequestProperty("Content-Length", "4");
-    connection.setRequestMethod("POST");
-    OutputStream out = connection.getOutputStream();
-    out.write('a');
-    out.write('b');
-    out.write('c');
-    try {
-      out.close();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void fullyBufferedPostIsTooLong() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    connection = urlFactory.open(server.url("/b").url());
-    connection.setRequestProperty("Content-Length", "3");
-    connection.setRequestMethod("POST");
-    OutputStream out = connection.getOutputStream();
-    out.write('a');
-    out.write('b');
-    out.write('c');
-    try {
-      out.write('d');
-      out.flush();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test @Ignore public void testPooledConnectionsDetectHttp10() {
-    // TODO: write a test that shows pooled connections detect HTTP/1.0 (vs. HTTP/1.1)
-    fail("TODO");
-  }
-
-  @Test @Ignore public void postBodiesRetransmittedOnAuthProblems() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void cookiesAndTrailers() {
-    // Do cookie headers get processed too many times?
-    fail("TODO");
-  }
-
-  @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
-    server.enqueue(new MockResponse().setBody("body"));
-    connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("B", "");
-    assertContent("body", connection);
-    assertEquals("", connection.getRequestProperty("B"));
-  }
-
-  @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
-    server.enqueue(new MockResponse().addHeader("A:").setBody("body"));
-    connection = urlFactory.open(server.url("/").url());
-    assertContent("body", connection);
-    assertEquals("", connection.getHeaderField("A"));
-  }
-
-  @Test public void emptyRequestHeaderNameIsStrict() throws Exception {
-    server.enqueue(new MockResponse().setBody("body"));
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.setRequestProperty("", "A");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void emptyResponseHeaderNameIsLenient() throws Exception {
-    Headers.Builder headers = new Headers.Builder();
-    Internal.instance.addLenient(headers, ":A");
-    server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
-    connection = urlFactory.open(server.url("/").url());
-    connection.getResponseCode();
-    assertEquals("A", connection.getHeaderField(""));
-    connection.getInputStream().close();
-  }
-
-  @Test public void requestHeaderValidationIsStrict() throws Exception {
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.addRequestProperty("a\tb", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      connection.addRequestProperty("Name", "c\u007fd");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      connection.addRequestProperty("", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      connection.addRequestProperty("\ud83c\udf69", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      connection.addRequestProperty("Name", "\u2615\ufe0f");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void responseHeaderParsingIsLenient() throws Exception {
-    Headers headers = new Headers.Builder()
-        .add("Content-Length", "0")
-        .addLenient("a\tb: c\u007fd")
-        .addLenient(": ef")
-        .addLenient("\ud83c\udf69: \u2615\ufe0f")
-        .build();
-    server.enqueue(new MockResponse().setHeaders(headers));
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.getResponseCode();
-    assertEquals("c\u007fd", connection.getHeaderField("a\tb"));
-    assertEquals("\u2615\ufe0f", connection.getHeaderField("\ud83c\udf69"));
-    assertEquals("ef", connection.getHeaderField(""));
-  }
-
-  @Test @Ignore public void deflateCompression() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void postBodiesRetransmittedOnIpAddressProblems() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void pooledConnectionProblemsNotReportedToProxySelector() {
-    fail("TODO");
-  }
-
-  @Test public void customBasicAuthenticator() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(new MockResponse().setBody("A"));
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential);
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(authenticator)
-        .build());
-    assertContent("A", urlFactory.open(server.url("/private").url()));
-
-    assertNull(server.takeRequest().getHeader("Authorization"));
-    assertEquals(credential, server.takeRequest().getHeader("Authorization"));
-
-    assertEquals(Proxy.NO_PROXY, authenticator.onlyRoute().proxy());
-    Response response = authenticator.onlyResponse();
-    assertEquals("/private", response.request().url().url().getPath());
-    assertEquals(Arrays.asList(new Challenge("Basic", "protected area")), response.challenges());
-  }
-
-  @Test public void customTokenAuthenticator() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
-        .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
-        .setBody("Please authenticate.");
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(new MockResponse().setBody("A"));
-
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator("oauthed abc123");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(authenticator)
-        .build());
-    assertContent("A", urlFactory.open(server.url("/private").url()));
-
-    assertNull(server.takeRequest().getHeader("Authorization"));
-    assertEquals("oauthed abc123", server.takeRequest().getHeader("Authorization"));
-
-    Response response = authenticator.onlyResponse();
-    assertEquals("/private", response.request().url().url().getPath());
-    assertEquals(Arrays.asList(new Challenge("Bearer", "oauthed")), response.challenges());
-  }
-
-  @Test public void authenticateCallsTrackedAsRedirects() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /b"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\""));
-    server.enqueue(new MockResponse().setBody("c"));
-
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
-        Credentials.basic("jesse", "peanutbutter"));
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(authenticator)
-        .build());
-    assertContent("c", urlFactory.open(server.url("/a").url()));
-
-    Response challengeResponse = authenticator.responses.get(0);
-    assertEquals("/b", challengeResponse.request().url().url().getPath());
-
-    Response redirectedBy = challengeResponse.priorResponse();
-    assertEquals("/a", redirectedBy.request().url().url().getPath());
-  }
-
-  @Test public void attemptAuthorization20Times() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse().setResponseCode(401));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
-        .build());
-
-    connection = urlFactory.open(server.url("/0").url());
-    assertContent("Success!", connection);
-  }
-
-  @Test public void doesNotAttemptAuthorization21Times() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse().setResponseCode(401));
-    }
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
-        .build());
-
-    connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (ProtocolException expected) {
-      assertEquals(401, connection.getResponseCode());
-      assertEquals("Too many follow-up requests: 21", expected.getMessage());
-    }
-  }
-
-  @Test public void setsNegotiatedProtocolHeader_HTTP_2() throws Exception {
-    setsNegotiatedProtocolHeader(Protocol.HTTP_2);
-  }
-
-  private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException {
-    enableProtocol(protocol);
-    server.enqueue(new MockResponse().setBody("A"));
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    assertEquals(Arrays.asList(protocol.toString()), protocolValues);
-    assertContent("A", connection);
-  }
-
-  @Test public void http10SelectedProtocol() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 OK"));
-    connection = urlFactory.open(server.url("/").url());
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    assertEquals(Arrays.asList("http/1.0"), protocolValues);
-  }
-
-  @Test public void http11SelectedProtocol() throws Exception {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
-    connection = urlFactory.open(server.url("/").url());
-    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
-    assertEquals(Arrays.asList("http/1.1"), protocolValues);
-  }
-
-  /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
-  @Test public void zeroLengthPost() throws IOException, InterruptedException {
-    zeroLengthPayload("POST");
-  }
-
-  @Test public void zeroLengthPost_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    zeroLengthPost();
-  }
-
-  /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
-  @Test public void zeroLengthPut() throws IOException, InterruptedException {
-    zeroLengthPayload("PUT");
-  }
-
-  @Test public void zeroLengthPut_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    zeroLengthPut();
-  }
-
-  private void zeroLengthPayload(String method)
-      throws IOException, InterruptedException {
-    server.enqueue(new MockResponse());
-    connection = urlFactory.open(server.url("/").url());
-    connection.setRequestProperty("Content-Length", "0");
-    connection.setRequestMethod(method);
-    connection.setFixedLengthStreamingMode(0);
-    connection.setDoOutput(true);
-    assertContent("", connection);
-    RecordedRequest zeroLengthPayload = server.takeRequest();
-    assertEquals(method, zeroLengthPayload.getMethod());
-    assertEquals("0", zeroLengthPayload.getHeader("content-length"));
-    assertEquals(0L, zeroLengthPayload.getBodySize());
-  }
-
-  @Test public void unspecifiedRequestBodyContentTypeGetsDefault() throws Exception {
-    server.enqueue(new MockResponse());
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("abc".getBytes(UTF_8));
-    assertEquals(200, connection.getResponseCode());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("application/x-www-form-urlencoded", request.getHeader("Content-Type"));
-    assertEquals("3", request.getHeader("Content-Length"));
-    assertEquals("abc", request.getBody().readUtf8());
-  }
-
-  @Test public void setProtocols() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .protocols(Arrays.asList(Protocol.HTTP_1_1))
-        .build());
-    assertContent("A", urlFactory.open(server.url("/").url()));
-  }
-
-  @Test public void setProtocolsWithoutHttp11() throws Exception {
-    try {
-      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_2));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setProtocolsWithNull() throws Exception {
-    try {
-      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_1_1, null));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void veryLargeFixedLengthRequest() throws Exception {
-    server.setBodyLimit(0);
-    server.enqueue(new MockResponse());
-
-    connection = urlFactory.open(server.url("/").url());
-    connection.setDoOutput(true);
-    long contentLength = Integer.MAX_VALUE + 1L;
-    connection.setFixedLengthStreamingMode(contentLength);
-    OutputStream out = connection.getOutputStream();
-    byte[] buffer = new byte[1024 * 1024];
-    for (long bytesWritten = 0; bytesWritten < contentLength; ) {
-      int byteCount = (int) Math.min(buffer.length, contentLength - bytesWritten);
-      out.write(buffer, 0, byteCount);
-      bytesWritten += byteCount;
-    }
-    assertContent("", connection);
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(Long.toString(contentLength), request.getHeader("Content-Length"));
-  }
-
-  @Test public void testNoSslFallback() throws Exception {
-    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);
-    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("Response that would have needed fallbacks"));
-
-    HttpsURLConnection connection = (HttpsURLConnection) server.url("/").url().openConnection();
-    connection.setSSLSocketFactory(sslClient.socketFactory);
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (SSLProtocolException expected) {
-      // RI response to the FAIL_HANDSHAKE
-    } catch (SSLHandshakeException expected) {
-      // Android's response to the FAIL_HANDSHAKE
-    } catch (SocketException expected) {
-      // Conscrypt's response to the FAIL_HANDSHAKE
-    }
-  }
-
-  /**
-   * We had a bug where we attempted to gunzip responses that didn't have a body. This only came up
-   * with 304s since that response code can include headers (like "Content-Encoding") without any
-   * content to go along with it. https://github.com/square/okhttp/issues/358
-   */
-  @Test public void noTransparentGzipFor304NotModified() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection1.getResponseCode());
-    assertContent("", connection1);
-
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertContent("b", connection2);
-
-    RecordedRequest requestA = server.takeRequest();
-    assertEquals(0, requestA.getSequenceNumber());
-
-    RecordedRequest requestB = server.takeRequest();
-    assertEquals(1, requestB.getSequenceNumber());
-  }
-
-  @Test public void nullSSLSocketFactory_throws() throws Exception {
-    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);
-    HttpsURLConnection connection = (HttpsURLConnection) server.url("/").url().openConnection();
-    try {
-      connection.setSSLSocketFactory(null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  /**
-   * We had a bug where we weren't closing Gzip streams on redirects.
-   * https://github.com/square/okhttp/issues/441
-   */
-  @Test public void gzipWithRedirectAndConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("Moved! Moved! Moved!")));
-    server.enqueue(new MockResponse().setBody("This is the new page!"));
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertContent("This is the new page!", connection);
-
-    RecordedRequest requestA = server.takeRequest();
-    assertEquals(0, requestA.getSequenceNumber());
-
-    RecordedRequest requestB = server.takeRequest();
-    assertEquals(1, requestB.getSequenceNumber());
-  }
-
-  /**
-   * The RFC is unclear in this regard as it only specifies that this should invalidate the cache
-   * entry (if any).
-   */
-  @Test public void bodyPermittedOnDelete() throws Exception {
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setRequestMethod("DELETE");
-    connection.setDoOutput(true);
-    connection.getOutputStream().write("BODY".getBytes(UTF_8));
-    assertEquals(200, connection.getResponseCode());
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("DELETE", request.getMethod());
-    assertEquals("BODY", request.getBody().readUtf8());
-  }
-
-  @Test public void userAgentPicksUpHttpAgentSystemProperty() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    System.setProperty("http.agent", "foo");
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("foo", request.getHeader("User-Agent"));
-  }
-
-  /** https://github.com/square/okhttp/issues/891 */
-  @Test public void userAgentSystemPropertyIsNotAscii() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    System.setProperty("http.agent", "a\nb\ud83c\udf69c\ud83c\udf68d\u007fe");
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals("a?b?c?d?e", request.getHeader("User-Agent"));
-  }
-
-  @Test public void userAgentDefaultsToOkHttpVersion() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-
-    RecordedRequest request = server.takeRequest();
-    assertEquals(Version.userAgent(), request.getHeader("User-Agent"));
-  }
-
-  @Test public void interceptorsNotInvoked() throws Exception {
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        throw new AssertionError();
-      }
-    };
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .addInterceptor(interceptor)
-        .addNetworkInterceptor(interceptor)
-        .build());
-
-    server.enqueue(new MockResponse().setBody("abc"));
-    assertContent("abc", urlFactory.open(server.url("/").url()));
-  }
-
-  @Test public void urlWithSpaceInHost() throws Exception {
-    URLConnection urlConnection = urlFactory.open(new URL("http://and roid.com/"));
-    try {
-      urlConnection.getInputStream();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void urlWithSpaceInHostViaHttpProxy() throws Exception {
-    server.enqueue(new MockResponse());
-    URLConnection urlConnection =
-        urlFactory.open(new URL("http://and roid.com/"), server.toProxyAddress());
-
-    try {
-      // This test is to check that a NullPointerException is not thrown.
-      urlConnection.getInputStream();
-      fail(); // the RI makes a bogus proxy request for "GET http://and roid.com/ HTTP/1.1"
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void urlHostWithNul() throws Exception {
-    URLConnection urlConnection = urlFactory.open(new URL("http://host\u0000/"));
-    try {
-      urlConnection.getInputStream();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void urlRedirectToHostWithNul() throws Exception {
-    String redirectUrl = "http://host\u0000/";
-    server.enqueue(new MockResponse().setResponseCode(302)
-        .addHeaderLenient("Location", redirectUrl));
-
-    HttpURLConnection urlConnection = urlFactory.open(server.url("/").url());
-    assertEquals(302, urlConnection.getResponseCode());
-    assertEquals(redirectUrl, urlConnection.getHeaderField("Location"));
-  }
-
-  @Test public void urlWithBadAsciiHost() throws Exception {
-    URLConnection urlConnection = urlFactory.open(new URL("http://host\u0001/"));
-    try {
-      urlConnection.getInputStream();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void instanceFollowsRedirects() throws Exception {
-    testInstanceFollowsRedirects("http://www.google.com/");
-    testInstanceFollowsRedirects("https://www.google.com/");
-  }
-
-  @Test public void setSslSocketFactoryFailsOnJdk9() throws Exception {
-    assumeTrue(getPlatform().equals("jdk9"));
-
-    enableProtocol(Protocol.HTTP_2);
-    URL url = server.url("/").url();
-    HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(url);
-    try {
-      connection.setSSLSocketFactory(sslClient.socketFactory);
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-
-  /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
-  @Test public void unexpectedExceptionSync() throws Exception {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new Dns() {
-          @Override public List<InetAddress> lookup(String hostname) {
-            throw new RuntimeException("boom!");
-          }
-        })
-        .build());
-
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.getResponseCode(); // Use the synchronous implementation.
-      fail();
-    } catch (RuntimeException expected) {
-      assertEquals("boom!", expected.getMessage());
-    }
-  }
-
-  /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
-  @Test public void unexpectedExceptionAsync() throws Exception {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .dns(new Dns() {
-          @Override public List<InetAddress> lookup(String hostname) {
-            throw new RuntimeException("boom!");
-          }
-        })
-        .build());
-
-    server.enqueue(new MockResponse());
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    try {
-      connection.connect(); // Force the async implementation.
-      fail();
-    } catch (RuntimeException expected) {
-      assertEquals("boom!", expected.getMessage());
-    }
-  }
-
-  @Test public void callsNotManagedByDispatcher() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Dispatcher dispatcher = urlFactory.client().dispatcher();
-    assertEquals(0, dispatcher.runningCallsCount());
-
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(0, dispatcher.runningCallsCount());
-
-    connection.connect();
-    assertEquals(0, dispatcher.runningCallsCount());
-
-    assertContent("abc", connection);
-    assertEquals(0, dispatcher.runningCallsCount());
-  }
-
-  @Test public void streamedBodyIsRetriedOnHttp2Shutdown() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setBody("abc"));
-    server.enqueue(new MockResponse()
-        .setBody("def"));
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    connection1.setChunkedStreamingMode(4096);
-    connection1.setRequestMethod("POST");
-    connection1.connect(); // Establish healthy HTTP/2 connection, but don't write yet.
-
-    // Send a separate request which will trigger a GOAWAY frame on the healthy connection.
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertContent("abc", connection2);
-
-    // Ensure the GOAWAY frame has time to be read and processed.
-    Thread.sleep(500);
-
-    OutputStream os = connection1.getOutputStream();
-    os.write(new byte[] { '1', '2', '3' });
-    os.close();
-    assertContent("def", connection1);
-
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals(0, request1.getSequenceNumber());
-
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("123", request2.getBody().readUtf8());
-    assertEquals(0, request2.getSequenceNumber());
-  }
-
-  @Test public void authenticateNoConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Connection: close")
-        .setResponseCode(401)
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-
-    Authenticator.setDefault(new RecordingAuthenticator(null));
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals(401, connection.getResponseCode());
-  }
-
-  private void testInstanceFollowsRedirects(String spec) throws Exception {
-    URL url = new URL(spec);
-    HttpURLConnection urlConnection = urlFactory.open(url);
-    urlConnection.setInstanceFollowRedirects(true);
-    assertTrue(urlConnection.getInstanceFollowRedirects());
-    urlConnection.setInstanceFollowRedirects(false);
-    assertFalse(urlConnection.getInstanceFollowRedirects());
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink gzipSink = Okio.buffer(new GzipSink(result));
-    gzipSink.writeUtf8(data);
-    gzipSink.close();
-    return result;
-  }
-
-  /**
-   * Reads at most {@code limit} characters from {@code in} and asserts that content equals {@code
-   * expected}.
-   */
-  private void assertContent(String expected, HttpURLConnection connection, int limit)
-      throws IOException {
-    connection.connect();
-    assertEquals(expected, readAscii(connection.getInputStream(), limit));
-  }
-
-  private void assertContent(String expected, HttpURLConnection connection) throws IOException {
-    assertContent(expected, connection, Integer.MAX_VALUE);
-  }
-
-  private Set<String> newSet(String... elements) {
-    return new LinkedHashSet<>(Arrays.asList(elements));
-  }
-
-  enum TransferKind {
-    CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
-        response.setChunkedBody(content, chunkSize);
-      }
-
-      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
-        connection.setChunkedStreamingMode(5);
-      }
-    },
-    FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-      }
-
-      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
-        connection.setFixedLengthStreamingMode(contentLength);
-      }
-    },
-    END_OF_STREAM() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(DISCONNECT_AT_END);
-        response.removeHeader("Content-Length");
-      }
-
-      @Override void setForRequest(HttpURLConnection connection, int contentLength) {
-      }
-    };
-
-    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
-
-    abstract void setForRequest(HttpURLConnection connection, int contentLength);
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, new Buffer().writeUtf8(content), chunkSize);
-    }
-  }
-
-  enum ProxyConfig {
-    NO_PROXY() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
-        streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
-            .proxy(Proxy.NO_PROXY)
-            .build());
-        return streamHandlerFactory.open(url);
-      }
-    },
-
-    CREATE_ARG() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
-        streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
-            .proxy(server.toProxyAddress())
-            .build());
-        return streamHandlerFactory.open(url);
-      }
-    },
-
-    PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
-        System.setProperty("proxyHost", server.getHostName());
-        System.setProperty("proxyPort", Integer.toString(server.getPort()));
-        return streamHandlerFactory.open(url);
-      }
-    },
-
-    HTTP_PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
-        System.setProperty("http.proxyHost", server.getHostName());
-        System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
-        return streamHandlerFactory.open(url);
-      }
-    },
-
-    HTTPS_PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
-        System.setProperty("https.proxyHost", server.getHostName());
-        System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
-        return streamHandlerFactory.open(url);
-      }
-    };
-
-    public abstract HttpURLConnection connect(
-        MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-        throws IOException;
-  }
-
-  private static class RecordingTrustManager implements X509TrustManager {
-    private final List<String> calls = new ArrayList<>();
-    private final X509TrustManager delegate;
-
-    public RecordingTrustManager(X509TrustManager delegate) {
-      this.delegate = delegate;
-    }
-
-    public X509Certificate[] getAcceptedIssuers() {
-      return delegate.getAcceptedIssuers();
-    }
-
-    public void checkClientTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
-      calls.add("checkClientTrusted " + certificatesToString(chain));
-    }
-
-    public void checkServerTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
-      calls.add("checkServerTrusted " + certificatesToString(chain));
-    }
-
-    private String certificatesToString(X509Certificate[] certificates) {
-      List<String> result = new ArrayList<>();
-      for (X509Certificate certificate : certificates) {
-        result.add(certificate.getSubjectDN() + " " + certificate.getSerialNumber());
-      }
-      return result.toString();
-    }
-  }
-
-  /**
-   * Tests that use this will fail unless boot classpath is set. Ex. {@code
-   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
-   */
-  private void enableProtocol(Protocol protocol) {
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
-        .build());
-    server.useHttps(sslClient.socketFactory, false);
-    server.setProtocolNegotiationEnabled(true);
-    server.setProtocols(urlFactory.client().protocols());
-  }
-
-  /**
-   * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
-   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
-   * for details.
-   */
-  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(sslClient.socketFactory);
-  }
-
-  private String getPlatform() {
-    return System.getProperty("okhttp.platform", "platform");
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java b/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
deleted file mode 100644
index 47c97fff2d..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
+++ /dev/null
@@ -1,31 +0,0 @@
- /*
-  * Copyright (C) 2012 The Android Open Source Project
-  *
-  * Licensed under the Apache License, Version 2.0 (the "License");
-  * you may not use this file except in compliance with the License.
-  * You may obtain a copy of the License at
-  *
-  *      http://www.apache.org/licenses/LICENSE-2.0
-  *
-  * Unless required by applicable law or agreed to in writing, software
-  * distributed under the License is distributed on an "AS IS" BASIS,
-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  * See the License for the specific language governing permissions and
-  * limitations under the License.
-  */
-package okhttp3.internal;
-
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertSame;
-
-public class UtilTest {
-  @Test
-  public void testAssertionError() {
-    NullPointerException nullPointerException = new NullPointerException();
-    AssertionError ae = Util.assertionError("npe", nullPointerException);
-    assertSame(nullPointerException, ae.getCause());
-    assertEquals("npe", ae.getMessage());
-  }
-}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
deleted file mode 100644
index 7e249bd61f..0000000000
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
+++ /dev/null
@@ -1,347 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package okhttp3.internal.platform;
-
-import java.io.IOException;
-import java.lang.reflect.InvocationTargetException;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-/**
- * Tests for {@link OptionalMethod}.
- */
-public class OptionalMethodTest {
-  @SuppressWarnings("unused")
-  private static class BaseClass {
-    public String stringMethod() {
-      return "string";
-    }
-
-    public void voidMethod() {
-    }
-  }
-
-  @SuppressWarnings("unused")
-  private static class SubClass1 extends BaseClass {
-    public String subclassMethod() {
-      return "subclassMethod1";
-    }
-
-    public String methodWithArgs(String arg) {
-      return arg;
-    }
-  }
-
-  @SuppressWarnings("unused")
-  private static class SubClass2 extends BaseClass {
-    public int subclassMethod() {
-      return 1234;
-    }
-
-    public String methodWithArgs(String arg) {
-      return arg;
-    }
-
-    public void throwsException() throws IOException {
-      throw new IOException();
-    }
-
-    public void throwsRuntimeException() throws Exception {
-      throw new NumberFormatException();
-    }
-
-    protected void nonPublic() {
-    }
-  }
-
-  private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_ANY =
-      new OptionalMethod<>(null, "stringMethod");
-  private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_STRING =
-      new OptionalMethod<>(String.class, "stringMethod");
-  private final static OptionalMethod<BaseClass> STRING_METHOD_RETURNS_INT =
-      new OptionalMethod<>(Integer.TYPE, "stringMethod");
-  private final static OptionalMethod<BaseClass> VOID_METHOD_RETURNS_ANY =
-      new OptionalMethod<>(null, "voidMethod");
-  private final static OptionalMethod<BaseClass> VOID_METHOD_RETURNS_VOID =
-      new OptionalMethod<>(Void.TYPE, "voidMethod");
-  private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_ANY =
-      new OptionalMethod<>(null, "subclassMethod");
-  private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_STRING =
-      new OptionalMethod<>(String.class, "subclassMethod");
-  private final static OptionalMethod<BaseClass> SUBCLASS_METHOD_RETURNS_INT =
-      new OptionalMethod<>(Integer.TYPE, "subclassMethod");
-  private final static OptionalMethod<BaseClass> METHOD_WITH_ARGS_WRONG_PARAMS =
-      new OptionalMethod<>(null, "methodWithArgs", Integer.class);
-  private final static OptionalMethod<BaseClass> METHOD_WITH_ARGS_CORRECT_PARAMS =
-      new OptionalMethod<>(null, "methodWithArgs", String.class);
-
-  private final static OptionalMethod<BaseClass> THROWS_EXCEPTION =
-      new OptionalMethod<>(null, "throwsException");
-  private final static OptionalMethod<BaseClass> THROWS_RUNTIME_EXCEPTION =
-      new OptionalMethod<>(null, "throwsRuntimeException");
-  private final static OptionalMethod<BaseClass> NON_PUBLIC =
-      new OptionalMethod<>(null, "nonPublic");
-
-  @Test
-  public void isSupported() throws Exception {
-    {
-      BaseClass base = new BaseClass();
-      assertTrue(STRING_METHOD_RETURNS_ANY.isSupported(base));
-      assertTrue(STRING_METHOD_RETURNS_STRING.isSupported(base));
-      assertFalse(STRING_METHOD_RETURNS_INT.isSupported(base));
-      assertTrue(VOID_METHOD_RETURNS_ANY.isSupported(base));
-      assertTrue(VOID_METHOD_RETURNS_VOID.isSupported(base));
-      assertFalse(SUBCLASS_METHOD_RETURNS_ANY.isSupported(base));
-      assertFalse(SUBCLASS_METHOD_RETURNS_STRING.isSupported(base));
-      assertFalse(SUBCLASS_METHOD_RETURNS_INT.isSupported(base));
-      assertFalse(METHOD_WITH_ARGS_WRONG_PARAMS.isSupported(base));
-      assertFalse(METHOD_WITH_ARGS_CORRECT_PARAMS.isSupported(base));
-    }
-    {
-      SubClass1 subClass1 = new SubClass1();
-      assertTrue(STRING_METHOD_RETURNS_ANY.isSupported(subClass1));
-      assertTrue(STRING_METHOD_RETURNS_STRING.isSupported(subClass1));
-      assertFalse(STRING_METHOD_RETURNS_INT.isSupported(subClass1));
-      assertTrue(VOID_METHOD_RETURNS_ANY.isSupported(subClass1));
-      assertTrue(VOID_METHOD_RETURNS_VOID.isSupported(subClass1));
-      assertTrue(SUBCLASS_METHOD_RETURNS_ANY.isSupported(subClass1));
-      assertTrue(SUBCLASS_METHOD_RETURNS_STRING.isSupported(subClass1));
-      assertFalse(SUBCLASS_METHOD_RETURNS_INT.isSupported(subClass1));
-      assertFalse(METHOD_WITH_ARGS_WRONG_PARAMS.isSupported(subClass1));
-      assertTrue(METHOD_WITH_ARGS_CORRECT_PARAMS.isSupported(subClass1));
-    }
-    {
-      SubClass2 subClass2 = new SubClass2();
-      assertTrue(STRING_METHOD_RETURNS_ANY.isSupported(subClass2));
-      assertTrue(STRING_METHOD_RETURNS_STRING.isSupported(subClass2));
-      assertFalse(STRING_METHOD_RETURNS_INT.isSupported(subClass2));
-      assertTrue(VOID_METHOD_RETURNS_ANY.isSupported(subClass2));
-      assertTrue(VOID_METHOD_RETURNS_VOID.isSupported(subClass2));
-      assertTrue(SUBCLASS_METHOD_RETURNS_ANY.isSupported(subClass2));
-      assertFalse(SUBCLASS_METHOD_RETURNS_STRING.isSupported(subClass2));
-      assertTrue(SUBCLASS_METHOD_RETURNS_INT.isSupported(subClass2));
-      assertFalse(METHOD_WITH_ARGS_WRONG_PARAMS.isSupported(subClass2));
-      assertTrue(METHOD_WITH_ARGS_CORRECT_PARAMS.isSupported(subClass2));
-    }
-  }
-
-  @Test
-  public void invoke() throws Exception {
-    {
-      BaseClass base = new BaseClass();
-      assertEquals("string", STRING_METHOD_RETURNS_STRING.invoke(base));
-      assertEquals("string", STRING_METHOD_RETURNS_ANY.invoke(base));
-      assertErrorOnInvoke(STRING_METHOD_RETURNS_INT, base);
-      assertNull(VOID_METHOD_RETURNS_ANY.invoke(base));
-      assertNull(VOID_METHOD_RETURNS_VOID.invoke(base));
-      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_ANY, base);
-      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_STRING, base);
-      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_INT, base);
-      assertErrorOnInvoke(METHOD_WITH_ARGS_WRONG_PARAMS, base);
-      assertErrorOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, base);
-    }
-    {
-      SubClass1 subClass1 = new SubClass1();
-      assertEquals("string", STRING_METHOD_RETURNS_STRING.invoke(subClass1));
-      assertEquals("string", STRING_METHOD_RETURNS_ANY.invoke(subClass1));
-      assertErrorOnInvoke(STRING_METHOD_RETURNS_INT, subClass1);
-      assertNull(VOID_METHOD_RETURNS_ANY.invoke(subClass1));
-      assertNull(VOID_METHOD_RETURNS_VOID.invoke(subClass1));
-      assertEquals("subclassMethod1", SUBCLASS_METHOD_RETURNS_ANY.invoke(subClass1));
-      assertEquals("subclassMethod1", SUBCLASS_METHOD_RETURNS_STRING.invoke(subClass1));
-      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_INT, subClass1);
-      assertErrorOnInvoke(METHOD_WITH_ARGS_WRONG_PARAMS, subClass1);
-      assertEquals("arg", METHOD_WITH_ARGS_CORRECT_PARAMS.invoke(subClass1, "arg"));
-    }
-
-    {
-      SubClass2 subClass2 = new SubClass2();
-      assertEquals("string", STRING_METHOD_RETURNS_STRING.invoke(subClass2));
-      assertEquals("string", STRING_METHOD_RETURNS_ANY.invoke(subClass2));
-      assertErrorOnInvoke(STRING_METHOD_RETURNS_INT, subClass2);
-      assertNull(VOID_METHOD_RETURNS_ANY.invoke(subClass2));
-      assertNull(VOID_METHOD_RETURNS_VOID.invoke(subClass2));
-      assertEquals(1234, SUBCLASS_METHOD_RETURNS_ANY.invoke(subClass2));
-      assertErrorOnInvoke(SUBCLASS_METHOD_RETURNS_STRING, subClass2);
-      assertEquals(1234, SUBCLASS_METHOD_RETURNS_INT.invoke(subClass2));
-      assertErrorOnInvoke(METHOD_WITH_ARGS_WRONG_PARAMS, subClass2);
-      assertEquals("arg", METHOD_WITH_ARGS_CORRECT_PARAMS.invoke(subClass2, "arg"));
-    }
-  }
-
-  @Test
-  public void invokeBadArgs() throws Exception {
-    SubClass1 subClass1 = new SubClass1();
-    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1); // no args
-    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, 123);
-    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, true);
-    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
-        new Object());
-    assertIllegalArgumentExceptionOnInvoke(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, "one",
-        "two");
-  }
-
-  @Test
-  public void invokeWithException() throws Exception {
-    SubClass2 subClass2 = new SubClass2();
-    try {
-      THROWS_EXCEPTION.invoke(subClass2);
-    } catch (InvocationTargetException expected) {
-      assertTrue(expected.getTargetException() instanceof IOException);
-    }
-
-    try {
-      THROWS_RUNTIME_EXCEPTION.invoke(subClass2);
-    } catch (InvocationTargetException expected) {
-      assertTrue(expected.getTargetException() instanceof NumberFormatException);
-    }
-  }
-
-  @Test
-  public void invokeNonPublic() throws Exception {
-    SubClass2 subClass2 = new SubClass2();
-    assertFalse(NON_PUBLIC.isSupported(subClass2));
-    assertErrorOnInvoke(NON_PUBLIC, subClass2);
-  }
-
-  @Test
-  public void invokeOptional() throws Exception {
-    {
-      BaseClass base = new BaseClass();
-      assertEquals("string", STRING_METHOD_RETURNS_STRING.invokeOptional(base));
-      assertEquals("string", STRING_METHOD_RETURNS_ANY.invokeOptional(base));
-      assertNull(STRING_METHOD_RETURNS_INT.invokeOptional(base));
-      assertNull(VOID_METHOD_RETURNS_ANY.invokeOptional(base));
-      assertNull(VOID_METHOD_RETURNS_VOID.invokeOptional(base));
-      assertNull(SUBCLASS_METHOD_RETURNS_ANY.invokeOptional(base));
-      assertNull(SUBCLASS_METHOD_RETURNS_STRING.invokeOptional(base));
-      assertNull(SUBCLASS_METHOD_RETURNS_INT.invokeOptional(base));
-      assertNull(METHOD_WITH_ARGS_WRONG_PARAMS.invokeOptional(base));
-      assertNull(METHOD_WITH_ARGS_CORRECT_PARAMS.invokeOptional(base));
-    }
-    {
-      SubClass1 subClass1 = new SubClass1();
-      assertEquals("string", STRING_METHOD_RETURNS_STRING.invokeOptional(subClass1));
-      assertEquals("string", STRING_METHOD_RETURNS_ANY.invokeOptional(subClass1));
-      assertNull(STRING_METHOD_RETURNS_INT.invokeOptional(subClass1));
-      assertNull(VOID_METHOD_RETURNS_ANY.invokeOptional(subClass1));
-      assertNull(VOID_METHOD_RETURNS_VOID.invokeOptional(subClass1));
-      assertEquals("subclassMethod1", SUBCLASS_METHOD_RETURNS_ANY.invokeOptional(subClass1));
-      assertEquals("subclassMethod1", SUBCLASS_METHOD_RETURNS_STRING.invokeOptional(subClass1));
-      assertNull(SUBCLASS_METHOD_RETURNS_INT.invokeOptional(subClass1));
-      assertNull(METHOD_WITH_ARGS_WRONG_PARAMS.invokeOptional(subClass1));
-      assertEquals("arg", METHOD_WITH_ARGS_CORRECT_PARAMS.invokeOptional(subClass1, "arg"));
-    }
-
-    {
-      SubClass2 subClass2 = new SubClass2();
-      assertEquals("string", STRING_METHOD_RETURNS_STRING.invokeOptional(subClass2));
-      assertEquals("string", STRING_METHOD_RETURNS_ANY.invokeOptional(subClass2));
-      assertNull(STRING_METHOD_RETURNS_INT.invokeOptional(subClass2));
-      assertNull(VOID_METHOD_RETURNS_ANY.invokeOptional(subClass2));
-      assertNull(VOID_METHOD_RETURNS_VOID.invokeOptional(subClass2));
-      assertEquals(1234, SUBCLASS_METHOD_RETURNS_ANY.invokeOptional(subClass2));
-      assertNull(SUBCLASS_METHOD_RETURNS_STRING.invokeOptional(subClass2));
-      assertEquals(1234, SUBCLASS_METHOD_RETURNS_INT.invokeOptional(subClass2));
-      assertNull(METHOD_WITH_ARGS_WRONG_PARAMS.invokeOptional(subClass2));
-      assertEquals("arg", METHOD_WITH_ARGS_CORRECT_PARAMS.invokeOptional(subClass2, "arg"));
-    }
-  }
-
-  @Test
-  public void invokeOptionalBadArgs() throws Exception {
-    SubClass1 subClass1 = new SubClass1();
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS,
-        subClass1); // no args
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1, 123);
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
-        true);
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
-        new Object());
-    assertIllegalArgumentExceptionOnInvokeOptional(METHOD_WITH_ARGS_CORRECT_PARAMS, subClass1,
-        "one", "two");
-  }
-
-  @Test
-  public void invokeOptionalWithException() throws Exception {
-    SubClass2 subClass2 = new SubClass2();
-    try {
-      THROWS_EXCEPTION.invokeOptional(subClass2);
-    } catch (InvocationTargetException expected) {
-      assertTrue(expected.getTargetException() instanceof IOException);
-    }
-
-    try {
-      THROWS_RUNTIME_EXCEPTION.invokeOptional(subClass2);
-    } catch (InvocationTargetException expected) {
-      assertTrue(expected.getTargetException() instanceof NumberFormatException);
-    }
-  }
-
-  @Test
-  @Ignore("Despite returning false for isSupported, invocation actually succeeds.")
-  public void invokeOptionalNonPublic() throws Exception {
-    SubClass2 subClass2 = new SubClass2();
-    assertFalse(NON_PUBLIC.isSupported(subClass2));
-    assertErrorOnInvokeOptional(NON_PUBLIC, subClass2);
-  }
-
-  private static <T> void assertErrorOnInvoke(
-      OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
-    try {
-      optionalMethod.invoke(base, args);
-    } catch (Error expected) {
-      return;
-    }
-    fail();
-  }
-
-  private static <T> void assertIllegalArgumentExceptionOnInvoke(
-      OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
-    try {
-      optionalMethod.invoke(base, args);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  private static <T> void assertErrorOnInvokeOptional(
-      OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
-    try {
-      optionalMethod.invokeOptional(base, args);
-    } catch (Error expected) {
-      return;
-    }
-    fail();
-  }
-
-  private static <T> void assertIllegalArgumentExceptionOnInvokeOptional(
-      OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
-    try {
-      optionalMethod.invokeOptional(base, args);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-}
diff --git a/okhttp-tls/Module.md b/okhttp-tls/Module.md
new file mode 100644
index 0000000000..b97773f31b
--- /dev/null
+++ b/okhttp-tls/Module.md
@@ -0,0 +1,3 @@
+# Module okhttp-tls
+
+OkHttp Transport Layer Security (TLS) library.
diff --git a/okhttp-tls/README.md b/okhttp-tls/README.md
new file mode 100644
index 0000000000..2ecaa5c3bf
--- /dev/null
+++ b/okhttp-tls/README.md
@@ -0,0 +1,246 @@
+OkHttp TLS
+==========
+
+Approachable APIs for using TLS.
+
+A [`HeldCertificate`][held_certificate] is a certificate and its private key. Use the
+[builder][held_certificate_builder] to create a self-signed certificate that a test server can use
+for HTTPS:
+
+```java
+String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
+HeldCertificate localhostCertificate = new HeldCertificate.Builder()
+    .addSubjectAlternativeName(localhost)
+    .build();
+```
+
+[`HandshakeCertificates`][handshake_certificates] keeps the certificates for a TLS handshake.
+Use its [builder][handshake_certificates_builder] to define which certificates the HTTPS server
+returns to its clients. The returned instance can create an `SSLSocketFactory` that implements this
+policy:
+
+```java
+HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+    .heldCertificate(localhostCertificate)
+    .build();
+MockWebServer server = new MockWebServer();
+server.useHttps(serverCertificates.sslSocketFactory(), false);
+```
+
+`HandshakeCertificates` also works for clients where its job is to define which root certificates
+to trust. In this simplified example we trust the server's self-signed certificate:
+
+```java
+HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+    .addTrustedCertificate(localhostCertificate.certificate())
+    .build();
+OkHttpClient client = new OkHttpClient.Builder()
+    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+    .build();
+```
+
+With a server that holds a certificate and a client that trusts it we have enough for an HTTPS
+handshake. The best part of this example is that we don't need to make our test code insecure with a
+a fake `HostnameVerifier` or `X509TrustManager`.
+
+Certificate Authorities
+-----------------------
+
+The above example uses a self-signed certificate. This is convenient for testing but not
+representative of real-world HTTPS deployment. To get closer to that we can use `HeldCertificate`
+to generate a trusted root certificate, an intermediate certificate, and a server certificate.
+We use `certificateAuthority(int)` to create certificates that can sign other certificates. The
+int specifies how many intermediate certificates are allowed beneath it in the chain.
+
+```java
+HeldCertificate rootCertificate = new HeldCertificate.Builder()
+    .certificateAuthority(1)
+    .build();
+
+HeldCertificate intermediateCertificate = new HeldCertificate.Builder()
+    .certificateAuthority(0)
+    .signedBy(rootCertificate)
+    .build();
+
+String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
+HeldCertificate serverCertificate = new HeldCertificate.Builder()
+    .addSubjectAlternativeName(localhost)
+    .signedBy(intermediateCertificate)
+    .build();
+```
+
+To serve this configuration the server needs to provide its clients with a chain of certificates
+starting with its own and including everything up-to but not including the root. We don't need to
+include root certificates because the client already has them.
+
+```java
+HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+    .heldCertificate(serverCertificate, intermediateCertificate.certificate())
+    .build();
+```
+
+The client only needs to know the trusted root certificate. It checks the server's certificate by
+validating the signatures within the chain.
+
+```java
+HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+    .addTrustedCertificate(rootCertificate.certificate())
+    .build();
+OkHttpClient client = new OkHttpClient.Builder()
+    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+    .build();
+```
+
+Client Authentication
+---------------------
+
+The above scenario is representative of most TLS set ups: the client uses certificates to validate
+the identity of a server. The converse is also possible. Here we create a server that authenticates
+a client and a client that authenticates a server.
+
+```java
+// Create the root for client and server to trust. We could also use different roots for each!
+HeldCertificate rootCertificate = new HeldCertificate.Builder()
+    .certificateAuthority(0)
+    .build();
+
+// Create a server certificate and a server that uses it.
+HeldCertificate serverCertificate = new HeldCertificate.Builder()
+    .commonName("ingen")
+    .addSubjectAlternativeName(server.getHostName())
+    .signedBy(rootCertificate)
+    .build();
+HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+    .addTrustedCertificate(rootCertificate.certificate())
+    .heldCertificate(serverCertificate)
+    .build();
+MockWebServer server = new MockWebServer();
+server.useHttps(serverCertificates.sslSocketFactory(), false);
+server.requestClientAuth();
+server.enqueue(new MockResponse());
+
+// Create a client certificate and a client that uses it.
+HeldCertificate clientCertificate = new HeldCertificate.Builder()
+    .commonName("ianmalcolm")
+    .signedBy(rootCertificate)
+    .build();
+HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+    .addTrustedCertificate(rootCertificate.certificate())
+    .heldCertificate(clientCertificate)
+    .build();
+OkHttpClient client = new OkHttpClient.Builder()
+    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+    .build();
+
+// Connect 'em all together. Certificates are exchanged in the handshake.
+Call call = client.newCall(new Request.Builder()
+    .url(server.url("/"))
+    .build());
+Response response = call.execute();
+System.out.println(response.handshake().peerPrincipal());
+RecordedRequest recordedRequest = server.takeRequest();
+System.out.println(recordedRequest.getHandshake().peerPrincipal());
+```
+
+This handshake is successful because each party has prearranged to trust the root certificate that
+signs the other party's chain.
+
+Well-Known Certificate Authorities
+----------------------------------
+
+In these examples we've prearranged which root certificates to trust. But for regular HTTPS on the
+Internet this set of trusted root certificates is usually provided by default by the host platform.
+Such a set typically includes many root certificates from well-known certificate authorities like
+Entrust and Verisign.
+
+This is the behavior you'll get with your OkHttpClient if you don't specifically configure
+`HandshakeCertificates`. Or you can do it explicitly with `addPlatformTrustedCertificates()`:
+
+```java
+HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+    .addPlatformTrustedCertificates()
+    .build();
+OkHttpClient client = new OkHttpClient.Builder()
+    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+    .build();
+```
+
+PEM files
+---------
+
+You can encode a `HeldCertificate` in PEM format:
+
+```java
+HeldCertificate heldCertificate = ...
+System.out.println(heldCertificate.certificatePem())
+```
+
+```
+-----BEGIN CERTIFICATE-----
+MIIBSjCB8aADAgECAgEBMAoGCCqGSM49BAMCMC8xLTArBgNVBAMTJDJiYWY3NzVl
+LWE4MzUtNDM5ZS1hYWE2LTgzNmNiNDlmMGM3MTAeFw0xODA3MTMxMjA0MzJaFw0x
+ODA3MTQxMjA0MzJaMC8xLTArBgNVBAMTJDJiYWY3NzVlLWE4MzUtNDM5ZS1hYWE2
+LTgzNmNiNDlmMGM3MTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDmlOiZ3dxA2
+zw1KwqGNsKVUZbkUVj5cxV1jDbSTvTlOjSj6LR0Ovys9RFdrjcbbMLWvSvMQgHch
+k8Q50c6Kb34wCgYIKoZIzj0EAwIDSAAwRQIhAJkXiCbIR3zxuH5SQR5PEAPJ+ntg
+msOSMaAKwAePESf+AiBlxbEu6YpHt1ZJoAhMAv6raYnwSp/A94eJGlJynQ0igQ==
+-----END CERTIFICATE-----
+```
+
+You can also do so with the private key. Be careful with these!
+
+```java
+HeldCertificate heldCertificate = ...
+System.out.println(heldCertificate.privateKeyPkcs8Pem())
+```
+
+```
+-----BEGIN PRIVATE KEY-----
+MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgQbYDQiewSnregm9e
+IjXEHQgc6w3ELHdnH1houEUom9CgCgYIKoZIzj0DAQehRANCAAQ5pTomd3cQNs8N
+SsKhjbClVGW5FFY+XMVdYw20k705To0o+i0dDr8rPURXa43G2zC1r0rzEIB3IZPE
+OdHOim9+
+-----END PRIVATE KEY-----
+```
+
+Recommendations
+---------------
+
+Typically servers need a held certificate plus a chain of intermediates. Servers only need the
+private key for their own certificate. The chain served by a server doesn't need the root
+certificate.
+
+The trusted roots don't need to be the same for client and server when using client authentication.
+Clients might rely on the platform certificates and servers might use a private
+organization-specific certificate authority.
+
+By default `HeldCertificate` instances expire after 24 hours. Use `duration()` to adjust.
+
+By default server certificates need to identify which hostnames they're trusted for. You may add as
+many as necessary with `addSubjectAlternativeName()`. This mechanism also supports a very limited
+form of wildcards `*.example.com` where the `*` must be first and doesn't match nested subdomains.
+
+By default certificates use fast and secure 256-bit ECDSA keys. For interoperability with very old
+clients use `HeldCertificate.Builder.rsa2048()`.
+
+Download
+--------
+
+Get via Maven:
+```xml
+<dependency>
+  <groupId>com.squareup.okhttp3</groupId>
+  <artifactId>okhttp-tls</artifactId>
+  <version>(insert latest version)</version>
+</dependency>
+```
+
+or via Gradle
+```groovy
+implementation 'com.squareup.okhttp3:okhttp-tls:(insert latest version)'
+```
+
+ [held_certificate]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HeldCertificate.html
+ [held_certificate_builder]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HeldCertificate.Builder.html
+ [handshake_certificates]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HandshakeCertificates.html
+ [handshake_certificates_builder]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HandshakeCertificates.Builder.html
diff --git a/okhttp-tls/build.gradle b/okhttp-tls/build.gradle
new file mode 100644
index 0000000000..1b86efcfcc
--- /dev/null
+++ b/okhttp-tls/build.gradle
@@ -0,0 +1,30 @@
+apply plugin: 'com.vanniktech.maven.publish'
+
+jar {
+  manifest {
+    attributes('Automatic-Module-Name': 'okhttp3.tls')
+  }
+}
+
+dependencies {
+  api deps.okio
+  implementation project(':okhttp')
+  implementation deps.bouncycastle
+  compileOnly deps.jsr305
+
+  testImplementation project(':okhttp-testing-support')
+  testImplementation deps.junit
+  testImplementation deps.assertj
+}
+
+apply plugin: 'me.champeau.gradle.japicmp'
+task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
+  oldClasspath = files(baselineJar(project, baselineVersion))
+  newClasspath = files(jar.archivePath)
+  onlyBinaryIncompatibleModified = true
+  failOnModification = true
+  txtOutputFile = file("$buildDir/reports/japi.txt")
+  ignoreMissingClasses = true
+  includeSynthetic = true
+}
+check.dependsOn(japicmp)
diff --git a/okhttp-tls/gradle.properties b/okhttp-tls/gradle.properties
new file mode 100644
index 0000000000..7ed0a3b63a
--- /dev/null
+++ b/okhttp-tls/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=okhttp-tls
+POM_NAME=okhttp-tls
+POM_PACKAGING=jar
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java
new file mode 100644
index 0000000000..34e9e9a497
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls;
+
+import java.security.GeneralSecurityException;
+import java.security.KeyManagementException;
+import java.security.SecureRandom;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import javax.annotation.Nullable;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.CertificatePinner;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+
+import static okhttp3.tls.internal.TlsUtil.newKeyManager;
+import static okhttp3.tls.internal.TlsUtil.newTrustManager;
+
+/**
+ * Certificates to identify which peers to trust and also to earn the trust of those peers in kind.
+ * Client and server exchange these certificates during the handshake phase of a TLS connection.
+ *
+ * <h3>Server Authentication</h3>
+ *
+ * <p>This is the most common form of TLS authentication: clients verify that servers are trusted
+ * and that they own the hostnames that they represent. Server authentication is required.
+ *
+ * <p>To perform server authentication:
+ *
+ * <ul>
+ *   <li>The server's handshake certificates must have a {@linkplain HeldCertificate held
+ *       certificate} (a certificate and its private key). The certificate's subject alternative
+ *       names must match the server's hostname. The server must also have is a (possibly-empty)
+ *       chain of intermediate certificates to establish trust from a root certificate to the
+ *       server's certificate. The root certificate is not included in this chain.
+ *   <li>The client's handshake certificates must include a set of trusted root certificates. They
+ *       will be used to authenticate the server's certificate chain. Typically this is a set of
+ *       well-known root certificates that is distributed with the HTTP client or its platform. It
+ *       may be augmented by certificates private to an organization or service.
+ * </ul>
+ *
+ * <h3>Client Authentication</h3>
+ *
+ * <p>This is authentication of the client by the server during the TLS handshake. Client
+ * authentication is optional.
+ *
+ * <p>To perform client authentication:
+ *
+ * <ul>
+ *   <li>The client's handshake certificates must have a {@linkplain HeldCertificate held
+ *       certificate} (a certificate and its private key). The client must also have a
+ *       (possibly-empty) chain of intermediate certificates to establish trust from a root
+ *       certificate to the client's certificate. The root certificate is not included in this
+ *       chain.
+ *   <li>The server's handshake certificates must include a set of trusted root certificates. They
+ *       will be used to authenticate the client's certificate chain. Typically this is not the same
+ *       set of root certificates used in server authentication. Instead it will be a small set of
+ *       roots private to an organization or service.
+ * </ul>
+ */
+public final class HandshakeCertificates {
+  private final X509KeyManager keyManager;
+  private final X509TrustManager trustManager;
+
+  private HandshakeCertificates(X509KeyManager keyManager, X509TrustManager trustManager) {
+    this.keyManager = keyManager;
+    this.trustManager = trustManager;
+  }
+
+  public X509KeyManager keyManager() {
+    return keyManager;
+  }
+
+  public X509TrustManager trustManager() {
+    return trustManager;
+  }
+
+  public SSLSocketFactory sslSocketFactory() {
+    return sslContext().getSocketFactory();
+  }
+
+  public SSLContext sslContext() {
+    try {
+      SSLContext sslContext = Platform.get().getSSLContext();
+      sslContext.init(new KeyManager[] { keyManager }, new TrustManager[] { trustManager },
+          new SecureRandom());
+      return sslContext;
+    } catch (KeyManagementException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public static final class Builder {
+    private @Nullable HeldCertificate heldCertificate;
+    private @Nullable X509Certificate[] intermediates;
+
+    private final List<X509Certificate> trustedCertificates = new ArrayList<>();
+
+    /**
+     * Configure the certificate chain to use when being authenticated. The first certificate is
+     * the held certificate, further certificates are included in the handshake so the peer can
+     * build a trusted path to a trusted root certificate.
+     *
+     * <p>The chain should include all intermediate certificates but does not need the root
+     * certificate that we expect to be known by the remote peer. The peer already has that
+     * certificate so transmitting it is unnecessary.
+     */
+    public Builder heldCertificate(HeldCertificate heldCertificate,
+        X509Certificate... intermediates) {
+      this.heldCertificate = heldCertificate;
+      this.intermediates = intermediates.clone(); // Defensive copy.
+      return this;
+    }
+
+    /**
+     * Add a trusted root certificate to use when authenticating a peer. Peers must provide
+     * a chain of certificates whose root is one of these.
+     */
+    public Builder addTrustedCertificate(X509Certificate certificate) {
+      this.trustedCertificates.add(certificate);
+      return this;
+    }
+
+    /**
+     * Add all of the host platform's trusted root certificates. This set varies by platform
+     * (Android vs. Java), by platform release (Android 4.4 vs. Android 9), and with user
+     * customizations.
+     *
+     * <p>Most TLS clients that connect to hosts on the public Internet should call this method.
+     * Otherwise it is necessary to manually prepare a comprehensive set of trusted roots.
+     *
+     * <p>If the host platform is compromised or misconfigured this may contain untrustworthy root
+     * certificates. Applications that connect to a known set of servers may be able to mitigate
+     * this problem with {@linkplain CertificatePinner certificate pinning}.
+     */
+    public Builder addPlatformTrustedCertificates() {
+      X509TrustManager platformTrustManager = Util.platformTrustManager();
+      Collections.addAll(trustedCertificates, platformTrustManager.getAcceptedIssuers());
+      return this;
+    }
+
+    public HandshakeCertificates build() {
+      try {
+        X509KeyManager keyManager = newKeyManager(null, heldCertificate, intermediates);
+        X509TrustManager trustManager = newTrustManager(null, trustedCertificates);
+        return new HandshakeCertificates(keyManager, trustManager);
+      } catch (GeneralSecurityException gse) {
+        throw new AssertionError(gse);
+      }
+    }
+  }
+}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java
new file mode 100644
index 0000000000..c659f58196
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java
@@ -0,0 +1,433 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls;
+
+import java.io.IOException;
+import java.math.BigInteger;
+import java.security.GeneralSecurityException;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.PrivateKey;
+import java.security.PublicKey;
+import java.security.SecureRandom;
+import java.security.Security;
+import java.security.cert.CertificateEncodingException;
+import java.security.cert.X509Certificate;
+import java.security.interfaces.RSAPrivateKey;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import javax.security.auth.x500.X500Principal;
+import okio.ByteString;
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
+import org.bouncycastle.asn1.x509.BasicConstraints;
+import org.bouncycastle.asn1.x509.GeneralName;
+import org.bouncycastle.asn1.x509.X509Extensions;
+import org.bouncycastle.jce.provider.BouncyCastleProvider;
+import org.bouncycastle.x509.X509V3CertificateGenerator;
+
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
+/**
+ * A certificate and its private key. These are some properties of certificates that are used with
+ * TLS:
+ *
+ * <ul>
+ *   <li><strong>A common name.</strong> This is a string identifier for the certificate. It usually
+ *       describes the purpose of the certificate like "Entrust Root Certification Authority - G2"
+ *       or "www.squareup.com".
+ *   <li><strong>A set of hostnames.</strong> These are in the certificate's subject alternative
+ *       name (SAN) extension. A subject alternative name is either a literal hostname ({@code
+ *       squareup.com}), a literal IP address ({@code 74.122.190.80}), or a hostname pattern ({@code
+ *       *.api.squareup.com}).
+ *   <li><strong>A validity interval.</strong> A certificate should not be used before its validity
+ *       interval starts or after it ends.
+ *   <li><strong>A public key.</strong> This cryptographic key is used for asymmetric encryption
+ *       digital signatures. Note that the private key is not a part of the certificate!
+ *   <li><strong>A signature issued by another certificate's private key.</strong> This mechanism
+ *       allows a trusted third-party to endorse a certificate. Third parties should only endorse
+ *       certificates once they've confirmed that the owner of the private key is also the owner of
+ *       the certificate's other properties.
+ * </ul>
+ *
+ * <p>Certificates are signed by other certificates and a sequence of them is called a certificate
+ * chain. The chain terminates in a self-signed "root" certificate. Signing certificates in the
+ * middle of the chain are called "intermediates". Organizations that offer certificate signing are
+ * called certificate authorities (CAs).
+ *
+ * <p>Browsers and other HTTP clients need a set of trusted root certificates to authenticate their
+ * peers. Sets of root certificates are managed by either the HTTP client (like Firefox), or the
+ * host platform (like Android). In July 2018 Android had 134 trusted root certificates for its HTTP
+ * clients to trust.
+ *
+ * <p>For example, in order to establish a secure connection to {@code https://www.squareup.com/},
+ * these three certificates are used. <pre>{@code
+ *
+ * www.squareup.com certificate:
+ *
+ *   Common Name: www.squareup.com
+ *   Subject Alternative Names: www.squareup.com, squareup.com, account.squareup.com...
+ *   Validity: 2018-07-03T20:18:17Z ‚Äì 2019-08-01T20:48:15Z
+ *   Public Key: d107beecc17325f55da976bcbab207ba4df68bd3f8fce7c3b5850311128264fd53e1baa342f58d93...
+ *   Signature: 1fb0e66fac05322721fe3a3917f7c98dee1729af39c99eab415f22d8347b508acdf0bab91781c3720...
+ *
+ * signed by intermediate certificate:
+ *
+ *   Common Name: Entrust Certification Authority - L1M
+ *   Subject Alternative Names: none
+ *   Validity: 2014-12-15T15:25:03Z ‚Äì 2030-10-15T15:55:03Z
+ *   Public Key: d081c13923c2b1d1ecf757dd55243691202248f7fcca520ab0ab3f33b5b08407f6df4e7ab0fb9822...
+ *   Signature: b487c784221a29c0a478ecf54f1bb484976f77eed4cf59afa843962f1d58dea6f3155b2ed9439c4c4...
+ *
+ * signed by root certificate:
+ *
+ *   Common Name: Entrust Root Certification Authority - G2
+ *   Subject Alternative Names: none
+ *   Validity: 2009-07-07T17:25:54Z ‚Äì 2030-12-07T17:55:54Z
+ *   Public Key: ba84b672db9e0c6be299e93001a776ea32b895411ac9da614e5872cffef68279bf7361060aa527d8...
+ *   Self-signed Signature: 799f1d96c6b6793f228d87d3870304606a6b9a2e59897311ac43d1f513ff8d392bc0f...
+ *
+ * }</pre>
+ *
+ * <p>In this example the HTTP client already knows and trusts the last certificate, "Entrust Root
+ * Certification Authority - G2". That certificate is used to verify the signature of the
+ * intermediate certificate, "Entrust Certification Authority - L1M". The intermediate certificate
+ * is used to verify the signature of the "www.squareup.com" certificate.
+ *
+ * <p>This roles are reversed for client authentication. In that case the client has a private key
+ * and a chain of certificates. The server uses a set of trusted root certificates to authenticate
+ * the client. Subject alternative names are not used for client authentication.
+ */
+public final class HeldCertificate {
+  private final X509Certificate certificate;
+  private final KeyPair keyPair;
+
+  public HeldCertificate(KeyPair keyPair, X509Certificate certificate) {
+    if (keyPair == null) throw new NullPointerException("keyPair == null");
+    if (certificate == null) throw new NullPointerException("certificate == null");
+    this.certificate = certificate;
+    this.keyPair = keyPair;
+  }
+
+  public X509Certificate certificate() {
+    return certificate;
+  }
+
+  public KeyPair keyPair() {
+    return keyPair;
+  }
+
+  /**
+   * Returns the certificate encoded in <a href="https://tools.ietf.org/html/rfc7468">PEM
+   * format</a>.
+   */
+  public String certificatePem() {
+    try {
+      StringBuilder result = new StringBuilder();
+      result.append("-----BEGIN CERTIFICATE-----\n");
+      encodeBase64Lines(result, ByteString.of(certificate.getEncoded()));
+      result.append("-----END CERTIFICATE-----\n");
+      return result.toString();
+    } catch (CertificateEncodingException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  /**
+   * Returns the RSA private key encoded in <a href="https://tools.ietf.org/html/rfc5208">PKCS
+   * #8</a> <a href="https://tools.ietf.org/html/rfc7468">PEM format</a>.
+   */
+  public String privateKeyPkcs8Pem() {
+    StringBuilder result = new StringBuilder();
+    result.append("-----BEGIN PRIVATE KEY-----\n");
+    encodeBase64Lines(result, ByteString.of(keyPair.getPrivate().getEncoded()));
+    result.append("-----END PRIVATE KEY-----\n");
+    return result.toString();
+  }
+
+  /**
+   * Returns the RSA private key encoded in <a href="https://tools.ietf.org/html/rfc8017">PKCS
+   * #1</a> <a href="https://tools.ietf.org/html/rfc7468">PEM format</a>.
+   */
+  public String privateKeyPkcs1Pem() {
+    if (!(keyPair.getPrivate() instanceof RSAPrivateKey)) {
+      throw new IllegalStateException("PKCS1 only supports RSA keys");
+    }
+    StringBuilder result = new StringBuilder();
+    result.append("-----BEGIN RSA PRIVATE KEY-----\n");
+    encodeBase64Lines(result, pkcs1Bytes());
+    result.append("-----END RSA PRIVATE KEY-----\n");
+    return result.toString();
+  }
+
+  private ByteString pkcs1Bytes() {
+    try {
+      PrivateKeyInfo privateKeyInfo = PrivateKeyInfo.getInstance(keyPair.getPrivate().getEncoded());
+      return ByteString.of(privateKeyInfo.parsePrivateKey().toASN1Primitive().getEncoded());
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  private void encodeBase64Lines(StringBuilder out, ByteString data) {
+    String base64 = data.base64();
+    for (int i = 0; i < base64.length(); i += 64) {
+      out.append(base64, i, Math.min(i + 64, base64.length())).append('\n');
+    }
+  }
+
+  /** Build a held certificate with reasonable defaults. */
+  public static final class Builder {
+    private static final long DEFAULT_DURATION_MILLIS = 1000L * 60 * 60 * 24; // 24 hours.
+
+    static {
+      Security.addProvider(new BouncyCastleProvider());
+    }
+
+    private long notBefore = -1L;
+    private long notAfter = -1L;
+    private @Nullable String cn;
+    private @Nullable String ou;
+    private final List<String> altNames = new ArrayList<>();
+    private @Nullable BigInteger serialNumber;
+    private @Nullable KeyPair keyPair;
+    private @Nullable HeldCertificate signedBy;
+    private int maxIntermediateCas = -1;
+    private @Nullable String keyAlgorithm;
+    private int keySize;
+
+    public Builder() {
+      ecdsa256();
+    }
+
+    /**
+     * Sets the certificate to be valid in {@code [notBefore..notAfter]}. Both endpoints are
+     * specified in the format of {@link System#currentTimeMillis()}. Specify -1L for both values
+     * to use the default interval, 24 hours starting when the certificate is created.
+     */
+    public Builder validityInterval(long notBefore, long notAfter) {
+      if (notBefore > notAfter || (notBefore == -1L) != (notAfter == -1L)) {
+        throw new IllegalArgumentException("invalid interval: " + notBefore + ".." + notAfter);
+      }
+      this.notBefore = notBefore;
+      this.notAfter = notAfter;
+      return this;
+    }
+
+    /**
+     * Sets the certificate to be valid immediately and until the specified duration has elapsed.
+     * The precision of this field is seconds; further precision will be truncated.
+     */
+    public Builder duration(long duration, TimeUnit unit) {
+      long now = System.currentTimeMillis();
+      return validityInterval(now, now + unit.toMillis(duration));
+    }
+
+    /**
+     * Adds a subject alternative name (SAN) to the certificate. This is usually a literal hostname,
+     * a literal IP address, or a hostname pattern. If no subject alternative names are added that
+     * extension will be omitted.
+     */
+    public Builder addSubjectAlternativeName(String altName) {
+      if (altName == null) throw new NullPointerException("altName == null");
+      altNames.add(altName);
+      return this;
+    }
+
+    /**
+     * Set this certificate's common name (CN). Historically this held the hostname of TLS
+     * certificate, but that practice was deprecated by <a
+     * href="https://tools.ietf.org/html/rfc2818">RFC 2818</a> and replaced with {@link
+     * #addSubjectAlternativeName(String) subject alternative names}. If unset a random string will
+     * be used.
+     */
+    public Builder commonName(String cn) {
+      this.cn = cn;
+      return this;
+    }
+
+    /** Sets the certificate's organizational unit (OU). If unset this field will be omitted. */
+    public Builder organizationalUnit(String ou) {
+      this.ou = ou;
+      return this;
+    }
+
+    /** Sets this certificate's serial number. If unset the serial number will be 1. */
+    public Builder serialNumber(BigInteger serialNumber) {
+      this.serialNumber = serialNumber;
+      return this;
+    }
+
+    /** Sets this certificate's serial number. If unset the serial number will be 1. */
+    public Builder serialNumber(long serialNumber) {
+      return serialNumber(BigInteger.valueOf(serialNumber));
+    }
+
+    /**
+     * Sets the public/private key pair used for this certificate. If unset a key pair will be
+     * generated.
+     */
+    public Builder keyPair(KeyPair keyPair) {
+      this.keyPair = keyPair;
+      return this;
+    }
+
+    /**
+     * Sets the public/private key pair used for this certificate. If unset a key pair will be
+     * generated.
+     */
+    public Builder keyPair(PublicKey publicKey, PrivateKey privateKey) {
+      return keyPair(new KeyPair(publicKey, privateKey));
+    }
+
+    /**
+     * Set the certificate that will issue this certificate. If unset the certificate will be
+     * self-signed.
+     */
+    public Builder signedBy(HeldCertificate signedBy) {
+      this.signedBy = signedBy;
+      return this;
+    }
+
+    /**
+     * Set this certificate to be a signing certificate, with up to {@code maxIntermediateCas}
+     * intermediate signing certificates beneath it.
+     *
+     * <p>By default this certificate cannot not sign other certificates. Set this to 0 so this
+     * certificate can sign other certificates (but those certificates cannot themselves sign
+     * certificates). Set this to 1 so this certificate can sign intermediate certificates that can
+     * themselves sign certificates. Add one for each additional layer of intermediates to permit.
+     */
+    public Builder certificateAuthority(int maxIntermediateCas) {
+      if (maxIntermediateCas < 0) {
+        throw new IllegalArgumentException("maxIntermediateCas < 0: " + maxIntermediateCas);
+      }
+      this.maxIntermediateCas = maxIntermediateCas;
+      return this;
+    }
+
+    /**
+     * Configure the certificate to generate a 256-bit ECDSA key, which provides about 128 bits of
+     * security. ECDSA keys are noticeably faster than RSA keys.
+     *
+     * <p>This is the default configuration and has been since this API was introduced in OkHttp
+     * 3.11.0. Note that the default may change in future releases.
+     */
+    public Builder ecdsa256() {
+      keyAlgorithm = "EC";
+      keySize = 256;
+      return this;
+    }
+
+    /**
+     * Configure the certificate to generate a 2048-bit RSA key, which provides about 112 bits of
+     * security. RSA keys are interoperable with very old clients that don't support ECDSA.
+     */
+    public Builder rsa2048() {
+      keyAlgorithm = "RSA";
+      keySize = 2048;
+      return this;
+    }
+
+    public HeldCertificate build() {
+      // Subject, public & private keys for this certificate.
+      KeyPair heldKeyPair = keyPair != null
+          ? keyPair
+          : generateKeyPair();
+
+      X500Principal subject = buildSubject();
+
+      // Subject, public & private keys for this certificate's signer. It may be self signed!
+      KeyPair signedByKeyPair;
+      X500Principal signedByPrincipal;
+      if (signedBy != null) {
+        signedByKeyPair = signedBy.keyPair;
+        signedByPrincipal = signedBy.certificate.getSubjectX500Principal();
+      } else {
+        signedByKeyPair = heldKeyPair;
+        signedByPrincipal = subject;
+      }
+
+      // Generate & sign the certificate.
+      long notBefore = this.notBefore != -1L ? this.notBefore : System.currentTimeMillis();
+      long notAfter = this.notAfter != -1L ? this.notAfter : notBefore + DEFAULT_DURATION_MILLIS;
+      BigInteger serialNumber = this.serialNumber != null ? this.serialNumber : BigInteger.ONE;
+      X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
+      generator.setSerialNumber(serialNumber);
+      generator.setIssuerDN(signedByPrincipal);
+      generator.setNotBefore(new Date(notBefore));
+      generator.setNotAfter(new Date(notAfter));
+      generator.setSubjectDN(subject);
+      generator.setPublicKey(heldKeyPair.getPublic());
+      generator.setSignatureAlgorithm(signedByKeyPair.getPrivate() instanceof RSAPrivateKey
+          ? "SHA256WithRSAEncryption"
+          : "SHA256withECDSA");
+
+      if (maxIntermediateCas != -1) {
+        generator.addExtension(X509Extensions.BasicConstraints, true,
+            new BasicConstraints(maxIntermediateCas));
+      }
+
+      if (!altNames.isEmpty()) {
+        ASN1Encodable[] encodableAltNames = new ASN1Encodable[altNames.size()];
+        for (int i = 0, size = altNames.size(); i < size; i++) {
+          String altName = altNames.get(i);
+          int tag = verifyAsIpAddress(altName)
+              ? GeneralName.iPAddress
+              : GeneralName.dNSName;
+          encodableAltNames[i] = new GeneralName(tag, altName);
+        }
+        generator.addExtension(X509Extensions.SubjectAlternativeName, true,
+            new DERSequence(encodableAltNames));
+      }
+
+      try {
+        X509Certificate certificate = generator.generate(signedByKeyPair.getPrivate());
+        return new HeldCertificate(heldKeyPair, certificate);
+      } catch (GeneralSecurityException e) {
+        throw new AssertionError(e);
+      }
+    }
+
+    private X500Principal buildSubject() {
+      StringBuilder nameBuilder = new StringBuilder();
+      if (cn != null) {
+        nameBuilder.append("CN=").append(cn);
+      } else {
+        nameBuilder.append("CN=").append(UUID.randomUUID());
+      }
+      if (ou != null) {
+        nameBuilder.append(", OU=").append(ou);
+      }
+      return new X500Principal(nameBuilder.toString());
+    }
+
+    private KeyPair generateKeyPair() {
+      try {
+        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyAlgorithm);
+        keyPairGenerator.initialize(keySize, new SecureRandom());
+        return keyPairGenerator.generateKeyPair();
+      } catch (GeneralSecurityException e) {
+        throw new AssertionError(e);
+      }
+    }
+  }
+}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java b/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java
new file mode 100644
index 0000000000..b127b36861
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls.internal;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import java.util.List;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.tls.HeldCertificate;
+import okhttp3.tls.HandshakeCertificates;
+
+public final class TlsUtil {
+  public static final char[] password = "password".toCharArray();
+  private static HandshakeCertificates localhost; // Lazily initialized.
+
+  private TlsUtil() {
+  }
+
+  /** Returns an SSL client for this host's localhost address. */
+  public static synchronized HandshakeCertificates localhost() {
+    if (localhost != null) return localhost;
+
+    try {
+      // Generate a self-signed cert for the server to serve and the client to trust.
+      HeldCertificate heldCertificate = new HeldCertificate.Builder()
+          .commonName("localhost")
+          .addSubjectAlternativeName(InetAddress.getByName("localhost").getCanonicalHostName())
+          .build();
+
+      localhost = new HandshakeCertificates.Builder()
+          .heldCertificate(heldCertificate)
+          .addTrustedCertificate(heldCertificate.certificate())
+          .build();
+
+      return localhost;
+    } catch (UnknownHostException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  /** Returns a trust manager that trusts {@code trustedCertificates}. */
+  public static X509TrustManager newTrustManager(String keyStoreType,
+      List<X509Certificate> trustedCertificates) throws GeneralSecurityException {
+    KeyStore trustStore = newEmptyKeyStore(keyStoreType);
+    for (int i = 0; i < trustedCertificates.size(); i++) {
+      trustStore.setCertificateEntry("cert_" + i, trustedCertificates.get(i));
+    }
+    TrustManagerFactory factory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    factory.init(trustStore);
+    TrustManager[] result = factory.getTrustManagers();
+    if (result.length != 1 || !(result[0] instanceof X509TrustManager)) {
+      throw new IllegalStateException("Unexpected trust managers:" + Arrays.toString(result));
+    }
+    return (X509TrustManager) result[0];
+  }
+
+  /**
+   * Returns a key manager for the held certificate and its chain. Returns an empty key manager if
+   * {@code heldCertificate} is null.
+   */
+  public static X509KeyManager newKeyManager(String keyStoreType, HeldCertificate heldCertificate,
+      X509Certificate... intermediates) throws GeneralSecurityException {
+    KeyStore keyStore = newEmptyKeyStore(keyStoreType);
+
+    if (heldCertificate != null) {
+      Certificate[] chain = new Certificate[1 + intermediates.length];
+      chain[0] = heldCertificate.certificate();
+      System.arraycopy(intermediates, 0, chain, 1, intermediates.length);
+      keyStore.setKeyEntry("private", heldCertificate.keyPair().getPrivate(), password, chain);
+    }
+
+    KeyManagerFactory factory = KeyManagerFactory.getInstance(
+        KeyManagerFactory.getDefaultAlgorithm());
+    factory.init(keyStore, password);
+    KeyManager[] result = factory.getKeyManagers();
+    if (result.length != 1 || !(result[0] instanceof X509KeyManager)) {
+      throw new IllegalStateException("Unexpected key managers:" + Arrays.toString(result));
+    }
+    return (X509KeyManager) result[0];
+  }
+
+  private static KeyStore newEmptyKeyStore(String keyStoreType) throws GeneralSecurityException {
+    if (keyStoreType == null) {
+      keyStoreType = KeyStore.getDefaultType();
+    }
+
+    try {
+      KeyStore keyStore = KeyStore.getInstance(keyStoreType);
+      InputStream in = null; // By convention, 'null' creates an empty key store.
+      keyStore.load(in, password);
+      return keyStore;
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
+}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/package-info.java b/okhttp-tls/src/main/java/okhttp3/tls/package-info.java
new file mode 100644
index 0000000000..061e524be6
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/package-info.java
@@ -0,0 +1,3 @@
+/** OkHttp Transport Layer Security (TLS) library. */
+@okhttp3.internal.annotations.EverythingIsNonNull
+package okhttp3.tls;
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
new file mode 100644
index 0000000000..f36743f471
--- /dev/null
+++ b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.security.PrivateKey;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import javax.net.ssl.SSLSocket;
+import okhttp3.Handshake;
+import okio.ByteString;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static java.util.Arrays.asList;
+import static okhttp3.internal.Util.closeQuietly;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class HandshakeCertificatesTest {
+  private ExecutorService executorService;
+  private ServerSocket serverSocket;
+
+  @Before public void setUp() {
+    executorService = Executors.newCachedThreadPool();
+  }
+
+  @After public void tearDown() {
+    executorService.shutdown();
+    closeQuietly(serverSocket);
+  }
+
+  @Test public void clientAndServer() throws Exception {
+    HeldCertificate clientRoot = new HeldCertificate.Builder()
+        .certificateAuthority(1)
+        .build();
+    HeldCertificate clientIntermediate = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .signedBy(clientRoot)
+        .build();
+    HeldCertificate clientCertificate = new HeldCertificate.Builder()
+        .signedBy(clientIntermediate)
+        .build();
+
+    HeldCertificate serverRoot = new HeldCertificate.Builder()
+        .certificateAuthority(1)
+        .build();
+    HeldCertificate serverIntermediate = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .signedBy(serverRoot)
+        .build();
+    HeldCertificate serverCertificate = new HeldCertificate.Builder()
+        .signedBy(serverIntermediate)
+        .build();
+
+    HandshakeCertificates server = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(clientRoot.certificate())
+        .heldCertificate(serverCertificate, serverIntermediate.certificate())
+        .build();
+
+    HandshakeCertificates client = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(serverRoot.certificate())
+        .heldCertificate(clientCertificate, clientIntermediate.certificate())
+        .build();
+
+    InetSocketAddress serverAddress = startTlsServer();
+    Future<Handshake> serverHandshakeFuture = doServerHandshake(server);
+    Future<Handshake> clientHandshakeFuture = doClientHandshake(client, serverAddress);
+
+    Handshake serverHandshake = serverHandshakeFuture.get();
+    assertThat(asList(clientCertificate.certificate(), clientIntermediate.certificate()))
+        .isEqualTo(serverHandshake.peerCertificates());
+    assertThat(asList(serverCertificate.certificate(), serverIntermediate.certificate()))
+        .isEqualTo(serverHandshake.localCertificates());
+
+    Handshake clientHandshake = clientHandshakeFuture.get();
+    assertThat(asList(serverCertificate.certificate(), serverIntermediate.certificate()))
+        .isEqualTo(clientHandshake.peerCertificates());
+    assertThat(asList(clientCertificate.certificate(), clientIntermediate.certificate()))
+        .isEqualTo(clientHandshake.localCertificates());
+  }
+
+  @Test public void keyManager() {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .certificateAuthority(1)
+        .build();
+    HeldCertificate intermediate = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .signedBy(root)
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .signedBy(intermediate)
+        .build();
+
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(certificate, intermediate.certificate())
+        .build();
+    assertPrivateKeysEquals(certificate.keyPair().getPrivate(),
+        handshakeCertificates.keyManager().getPrivateKey("private"));
+    assertThat(asList(handshakeCertificates.keyManager().getCertificateChain("private"))).isEqualTo(
+        asList(certificate.certificate(), intermediate.certificate()));
+  }
+
+  @Test public void platformTrustedCertificates() {
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addPlatformTrustedCertificates()
+        .build();
+    Set<String> names = new LinkedHashSet<>();
+    for (X509Certificate certificate : handshakeCertificates.trustManager().getAcceptedIssuers()) {
+      // Abbreviate a long name like "CN=Entrust Root Certification Authority - G2, OU=..."
+      String name = certificate.getSubjectDN().getName();
+      names.add(name.substring(0, name.indexOf(" ")));
+    }
+    // It's safe to assume all platforms will have a major Internet certificate issuer.
+    assertThat(names).contains("CN=Entrust");
+  }
+
+  private InetSocketAddress startTlsServer() throws IOException {
+    ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
+    serverSocket = serverSocketFactory.createServerSocket();
+    InetAddress serverAddress = InetAddress.getByName("localhost");
+    serverSocket.bind(new InetSocketAddress(serverAddress, 0), 50);
+    return new InetSocketAddress(serverAddress, serverSocket.getLocalPort());
+  }
+
+  private Future<Handshake> doServerHandshake(HandshakeCertificates server) {
+    return executorService.submit(() -> {
+      Socket rawSocket = null;
+      SSLSocket sslSocket = null;
+      try {
+        rawSocket = serverSocket.accept();
+        sslSocket = (SSLSocket) server.sslSocketFactory().createSocket(rawSocket,
+            rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(), true /* autoClose */);
+        sslSocket.setUseClientMode(false);
+        sslSocket.setWantClientAuth(true);
+        sslSocket.startHandshake();
+        return Handshake.get(sslSocket.getSession());
+      } finally {
+        closeQuietly(rawSocket);
+        closeQuietly(sslSocket);
+      }
+    });
+  }
+
+  private Future<Handshake> doClientHandshake(
+      HandshakeCertificates client, InetSocketAddress serverAddress) {
+    return executorService.submit(() -> {
+      Socket rawSocket = SocketFactory.getDefault().createSocket();
+      rawSocket.connect(serverAddress);
+      SSLSocket sslSocket = null;
+      try {
+        sslSocket = (SSLSocket) client.sslSocketFactory().createSocket(rawSocket,
+            rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(), true /* autoClose */);
+        sslSocket.startHandshake();
+        return Handshake.get(sslSocket.getSession());
+      } finally {
+        closeQuietly(rawSocket);
+        closeQuietly(sslSocket);
+      }
+    });
+  }
+
+  private void assertPrivateKeysEquals(PrivateKey expected, PrivateKey actual) {
+    assertThat(ByteString.of(actual.getEncoded())).isEqualTo(
+        ByteString.of(expected.getEncoded()));
+  }
+}
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
new file mode 100644
index 0000000000..76dbeb81f1
--- /dev/null
+++ b/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls;
+
+import java.math.BigInteger;
+import java.security.KeyFactory;
+import java.security.PrivateKey;
+import java.security.PublicKey;
+import java.security.cert.CertificateParsingException;
+import java.security.cert.X509Certificate;
+import java.security.spec.PKCS8EncodedKeySpec;
+import java.security.spec.X509EncodedKeySpec;
+import java.util.concurrent.TimeUnit;
+import okio.ByteString;
+import org.bouncycastle.asn1.x509.GeneralName;
+import org.junit.Test;
+
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
+
+public final class HeldCertificateTest {
+  @Test public void defaultCertificate() throws CertificateParsingException {
+    long now = System.currentTimeMillis();
+    HeldCertificate heldCertificate = new HeldCertificate.Builder().build();
+
+    X509Certificate certificate = heldCertificate.certificate();
+    assertThat(certificate.getSubjectX500Principal().getName()).overridingErrorMessage(
+        "self-signed").isEqualTo(certificate.getIssuerX500Principal().getName());
+    assertThat(certificate.getIssuerX500Principal().getName()).matches("CN=[0-9a-f-]{36}");
+    assertThat(certificate.getSerialNumber()).isEqualTo(BigInteger.ONE);
+    assertThat(certificate.getSubjectAlternativeNames()).isNull();
+
+    double deltaMillis = 1000.0;
+    long durationMillis = TimeUnit.MINUTES.toMillis(60 * 24);
+    assertThat((double) certificate.getNotBefore().getTime()).isCloseTo(
+        (double) now, offset(deltaMillis));
+    assertThat((double) certificate.getNotAfter().getTime()).isCloseTo(
+        (double) now + durationMillis, offset(deltaMillis));
+  }
+
+  @Test public void customInterval() {
+    // 5 seconds starting on 1970-01-01.
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .validityInterval(5_000L, 10_000L)
+        .build();
+    X509Certificate certificate = heldCertificate.certificate();
+    assertThat(certificate.getNotBefore().getTime()).isEqualTo(5_000L);
+    assertThat(certificate.getNotAfter().getTime()).isEqualTo(10_000L);
+  }
+
+  @Test public void customDuration() {
+    long now = System.currentTimeMillis();
+
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .duration(5, TimeUnit.SECONDS)
+        .build();
+    X509Certificate certificate = heldCertificate.certificate();
+
+    double deltaMillis = 1000.0;
+    long durationMillis = 5_000L;
+    assertThat((double) certificate.getNotBefore().getTime()).isCloseTo(
+        (double) now, offset(deltaMillis));
+    assertThat((double) certificate.getNotAfter().getTime()).isCloseTo(
+        (double) now + durationMillis, offset(deltaMillis));
+  }
+
+  @Test public void subjectAlternativeNames() throws CertificateParsingException {
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .addSubjectAlternativeName("1.1.1.1")
+        .addSubjectAlternativeName("cash.app")
+        .build();
+
+    X509Certificate certificate = heldCertificate.certificate();
+    assertThat(certificate.getSubjectAlternativeNames()).containsExactly(
+        asList(GeneralName.iPAddress, "1.1.1.1"),
+        asList(GeneralName.dNSName, "cash.app"));
+  }
+
+  @Test public void commonName() {
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .commonName("cash.app")
+        .build();
+
+    X509Certificate certificate = heldCertificate.certificate();
+    assertThat(certificate.getSubjectX500Principal().getName()).isEqualTo("CN=cash.app");
+  }
+
+  @Test public void organizationalUnit() {
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .commonName("cash.app")
+        .organizationalUnit("cash")
+        .build();
+
+    X509Certificate certificate = heldCertificate.certificate();
+    assertThat(certificate.getSubjectX500Principal().getName()).isEqualTo(
+        "CN=cash.app,OU=cash");
+  }
+
+  /** Confirm golden values of encoded PEMs. */
+  @Test public void pems() throws Exception {
+    KeyFactory keyFactory = KeyFactory.getInstance("RSA");
+
+    ByteString publicKeyBytes = ByteString.decodeBase64("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCApF"
+        + "HhtrLan28q+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1wJ4YEoUCjDlPOtpht7XLbUmBnbIzN89XK4UJVM6Sqp3"
+        + "K88Km8z7gMrdrfTom/274wL25fICR+yDEQ5fUVYBmJAKXZF1aoI0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQAB");
+    PublicKey publicKey = keyFactory.generatePublic(
+        new X509EncodedKeySpec(publicKeyBytes.toByteArray()));
+
+    ByteString privateKeyBytes = ByteString.decodeBase64("MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbA"
+        + "gEAAoGBAICkUeG2stqfbyr6gyiVm5pN9YEDRXlowi+rfYGyWhC7ouW9fXAnhgShQKMOU862mG3tcttSYGdsjM3z1"
+        + "crhQlUzpKqncrzwqbzPuAyt2t9Oib/bvjAvbl8gJH7IMRDl9RVgGYkApdkXVqgjSYigTHTEWxCEgnrfu/YzEkO6l"
+        + "3rXAgMBAAECgYB99mhnB6piADOuddXv626NzUBTr4xbsYRTgSxHzwf50oFTTBSDuW+1IOBVyTWu94SSPyt0LllPb"
+        + "C8Di3sQSTnVGpSqAvEXknBMzIc0UO74Rn9p3gZjEenPt1l77fIBa2nK06/rdsJCoE/1P1JSfM9w7LU1RsTmseYML"
+        + "eJl5F79gQJBAO/BbAKqg1yzK7VijygvBoUrr+rt2lbmKgcUQ/rxu8IIQk0M/xgJqSkXDXuOnboGM7sQSKfJAZUtT"
+        + "7xozvLzV7ECQQCJW59w7NIM0qZ/gIX2gcNZr1B/V3zcGlolTDciRm+fnKGNt2EEDKnVL3swzbEfTCa48IT0QKgZJ"
+        + "qpXZERa26UHAkBLXmiP5f5pk8F3wcXzAeVw06z3k1IB41Tu6MX+CyPU+TeudRlz+wV8b0zDvK+EnRKCCbptVFj1B"
+        + "kt8lQ4JfcnhAkAk2Y3Gz+HySrkcT7Cg12M/NkdUQnZe3jr88pt/+IGNwomc6Wt/mJ4fcWONTkGMcfOZff1NQeNXD"
+        + "AZ6941XCsIVAkASOg02PlVHLidU7mIE65swMM5/RNhS4aFjez/MwxFNOHaxc9VgCwYPXCLOtdf7AVovdyG0XWgbU"
+        + "XH+NyxKwboE");
+    PrivateKey privateKey = keyFactory.generatePrivate(
+        new PKCS8EncodedKeySpec(privateKeyBytes.toByteArray()));
+
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .keyPair(publicKey, privateKey)
+        .commonName("cash.app")
+        .validityInterval(0L, 1_000L)
+        .rsa2048()
+        .build();
+
+    assertThat((""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIBmjCCAQOgAwIBAgIBATANBgkqhkiG9w0BAQsFADATMREwDwYDVQQDEwhjYXNo\n"
+        + "LmFwcDAeFw03MDAxMDEwMDAwMDBaFw03MDAxMDEwMDAwMDFaMBMxETAPBgNVBAMT\n"
+        + "CGNhc2guYXBwMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCApFHhtrLan28q\n"
+        + "+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1wJ4YEoUCjDlPOtpht7XLbUmBnbIzN\n"
+        + "89XK4UJVM6Sqp3K88Km8z7gMrdrfTom/274wL25fICR+yDEQ5fUVYBmJAKXZF1ao\n"
+        + "I0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQABMA0GCSqGSIb3DQEBCwUAA4GBADam\n"
+        + "UVwKh5Ry7es3OxtY3IgQunPUoLc0Gw71gl9Z+7t2FJ5VkcI5gWfutmdxZ2bDXCI8\n"
+        + "8V0vxo1pHXnbBrnxhS/Z3TBerw8RyQqcaWOdp+pBXyIWmR+jHk9cHZCqQveTIBsY\n"
+        + "jaA9VEhgdaVhxBsT2qzUNDsXlOzGsliznDfoqETb\n"
+        + "-----END CERTIFICATE-----\n")).isEqualTo(heldCertificate.certificatePem());
+
+    assertThat((""
+        + "-----BEGIN RSA PRIVATE KEY-----\n"
+        + "MIICWwIBAAKBgQCApFHhtrLan28q+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1w\n"
+        + "J4YEoUCjDlPOtpht7XLbUmBnbIzN89XK4UJVM6Sqp3K88Km8z7gMrdrfTom/274w\n"
+        + "L25fICR+yDEQ5fUVYBmJAKXZF1aoI0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQAB\n"
+        + "AoGAffZoZweqYgAzrnXV7+tujc1AU6+MW7GEU4EsR88H+dKBU0wUg7lvtSDgVck1\n"
+        + "rveEkj8rdC5ZT2wvA4t7EEk51RqUqgLxF5JwTMyHNFDu+EZ/ad4GYxHpz7dZe+3y\n"
+        + "AWtpytOv63bCQqBP9T9SUnzPcOy1NUbE5rHmDC3iZeRe/YECQQDvwWwCqoNcsyu1\n"
+        + "Yo8oLwaFK6/q7dpW5ioHFEP68bvCCEJNDP8YCakpFw17jp26BjO7EEinyQGVLU+8\n"
+        + "aM7y81exAkEAiVufcOzSDNKmf4CF9oHDWa9Qf1d83BpaJUw3IkZvn5yhjbdhBAyp\n"
+        + "1S97MM2xH0wmuPCE9ECoGSaqV2REWtulBwJAS15oj+X+aZPBd8HF8wHlcNOs95NS\n"
+        + "AeNU7ujF/gsj1Pk3rnUZc/sFfG9Mw7yvhJ0Sggm6bVRY9QZLfJUOCX3J4QJAJNmN\n"
+        + "xs/h8kq5HE+woNdjPzZHVEJ2Xt46/PKbf/iBjcKJnOlrf5ieH3FjjU5BjHHzmX39\n"
+        + "TUHjVwwGeveNVwrCFQJAEjoNNj5VRy4nVO5iBOubMDDOf0TYUuGhY3s/zMMRTTh2\n"
+        + "sXPVYAsGD1wizrXX+wFaL3chtF1oG1Fx/jcsSsG6BA==\n"
+        + "-----END RSA PRIVATE KEY-----\n")).isEqualTo(heldCertificate.privateKeyPkcs1Pem());
+
+    assertThat((""
+        + "-----BEGIN PRIVATE KEY-----\n"
+        + "MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAICkUeG2stqfbyr6\n"
+        + "gyiVm5pN9YEDRXlowi+rfYGyWhC7ouW9fXAnhgShQKMOU862mG3tcttSYGdsjM3z\n"
+        + "1crhQlUzpKqncrzwqbzPuAyt2t9Oib/bvjAvbl8gJH7IMRDl9RVgGYkApdkXVqgj\n"
+        + "SYigTHTEWxCEgnrfu/YzEkO6l3rXAgMBAAECgYB99mhnB6piADOuddXv626NzUBT\n"
+        + "r4xbsYRTgSxHzwf50oFTTBSDuW+1IOBVyTWu94SSPyt0LllPbC8Di3sQSTnVGpSq\n"
+        + "AvEXknBMzIc0UO74Rn9p3gZjEenPt1l77fIBa2nK06/rdsJCoE/1P1JSfM9w7LU1\n"
+        + "RsTmseYMLeJl5F79gQJBAO/BbAKqg1yzK7VijygvBoUrr+rt2lbmKgcUQ/rxu8II\n"
+        + "Qk0M/xgJqSkXDXuOnboGM7sQSKfJAZUtT7xozvLzV7ECQQCJW59w7NIM0qZ/gIX2\n"
+        + "gcNZr1B/V3zcGlolTDciRm+fnKGNt2EEDKnVL3swzbEfTCa48IT0QKgZJqpXZERa\n"
+        + "26UHAkBLXmiP5f5pk8F3wcXzAeVw06z3k1IB41Tu6MX+CyPU+TeudRlz+wV8b0zD\n"
+        + "vK+EnRKCCbptVFj1Bkt8lQ4JfcnhAkAk2Y3Gz+HySrkcT7Cg12M/NkdUQnZe3jr8\n"
+        + "8pt/+IGNwomc6Wt/mJ4fcWONTkGMcfOZff1NQeNXDAZ6941XCsIVAkASOg02PlVH\n"
+        + "LidU7mIE65swMM5/RNhS4aFjez/MwxFNOHaxc9VgCwYPXCLOtdf7AVovdyG0XWgb\n"
+        + "UXH+NyxKwboE\n"
+        + "-----END PRIVATE KEY-----\n")).isEqualTo(heldCertificate.privateKeyPkcs8Pem());
+  }
+
+  @Test public void ecdsaSignedByRsa() {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .rsa2048()
+        .build();
+    HeldCertificate leaf = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .ecdsa256()
+        .signedBy(root)
+        .build();
+
+    assertThat(root.certificate().getSigAlgName()).isEqualTo("SHA256WITHRSA");
+    assertThat(leaf.certificate().getSigAlgName()).isEqualTo("SHA256WITHRSA");
+  }
+
+  @Test public void rsaSignedByEcdsa() {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .ecdsa256()
+        .build();
+    HeldCertificate leaf = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .rsa2048()
+        .signedBy(root)
+        .build();
+
+    assertThat(root.certificate().getSigAlgName()).isEqualTo("SHA256WITHECDSA");
+    assertThat(leaf.certificate().getSigAlgName()).isEqualTo("SHA256WITHECDSA");
+  }
+}
diff --git a/okhttp-urlconnection/build.gradle b/okhttp-urlconnection/build.gradle
new file mode 100644
index 0000000000..9249c79b1b
--- /dev/null
+++ b/okhttp-urlconnection/build.gradle
@@ -0,0 +1,31 @@
+apply plugin: 'com.vanniktech.maven.publish'
+
+jar {
+  manifest {
+    attributes('Automatic-Module-Name': 'okhttp3.urlconnection')
+  }
+}
+
+dependencies {
+  api project(':okhttp')
+  compileOnly deps.jsr305
+  compileOnly deps.animalSniffer
+
+  testImplementation project(':okhttp-testing-support')
+  testImplementation project(':okhttp-tls')
+  testImplementation project(':mockwebserver')
+  testImplementation deps.junit
+  testImplementation deps.assertj
+}
+
+apply plugin: 'me.champeau.gradle.japicmp'
+task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
+  oldClasspath = files(baselineJar(project, baselineVersion))
+  newClasspath = files(jar.archivePath)
+  onlyBinaryIncompatibleModified = true
+  failOnModification = true
+  txtOutputFile = file("$buildDir/reports/japi.txt")
+  ignoreMissingClasses = true
+  includeSynthetic = true
+}
+check.dependsOn(japicmp)
diff --git a/okhttp-urlconnection/gradle.properties b/okhttp-urlconnection/gradle.properties
new file mode 100644
index 0000000000..33c8a52a36
--- /dev/null
+++ b/okhttp-urlconnection/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=okhttp-urlconnection
+POM_NAME=okhttp-urlconnection
+POM_PACKAGING=jar
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
deleted file mode 100644
index 585b357ab2..0000000000
--- a/okhttp-urlconnection/pom.xml
+++ /dev/null
@@ -1,79 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.11.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-urlconnection</artifactId>
-  <name>OkHttp URLConnection</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.codehaus.mojo</groupId>
-      <artifactId>animal-sniffer-annotations</artifactId>
-      <version>${animal.sniffer.version}</version>
-      <optional>true</optional>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.10.4</version>
-        <configuration>
-          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3.urlconnection</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
index 2649510d35..f1892b7199 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
@@ -22,12 +22,14 @@
 import java.net.PasswordAuthentication;
 import java.net.Proxy;
 import java.util.List;
+import okhttp3.internal.annotations.EverythingIsNonNull;
 
 /**
  * Adapts {@link java.net.Authenticator} to {@link Authenticator}. Configure OkHttp to use {@link
  * java.net.Authenticator} with {@link OkHttpClient.Builder#authenticator} or {@link
  * OkHttpClient.Builder#proxyAuthenticator(Authenticator)}.
  */
+@EverythingIsNonNull
 public final class JavaNetAuthenticator implements Authenticator {
   @Override public Request authenticate(Route route, Response response) throws IOException {
     List<Challenge> challenges = response.challenges();
@@ -66,7 +68,7 @@
   }
 
   private InetAddress getConnectToInetAddress(Proxy proxy, HttpUrl url) throws IOException {
-    return (proxy != null && proxy.type() != Proxy.Type.DIRECT)
+    return proxy.type() != Proxy.Type.DIRECT
         ? ((InetSocketAddress) proxy.address()).getAddress()
         : InetAddress.getByName(url.host());
   }
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
deleted file mode 100644
index 5d4f671a31..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.CookieHandler;
-import java.net.HttpCookie;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import okhttp3.internal.platform.Platform;
-
-import static okhttp3.internal.Util.delimiterOffset;
-import static okhttp3.internal.Util.trimSubstring;
-import static okhttp3.internal.platform.Platform.WARN;
-
-/** A cookie jar that delegates to a {@link java.net.CookieHandler}. */
-public final class JavaNetCookieJar implements CookieJar {
-  private final CookieHandler cookieHandler;
-
-  public JavaNetCookieJar(CookieHandler cookieHandler) {
-    this.cookieHandler = cookieHandler;
-  }
-
-  @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
-    if (cookieHandler != null) {
-      List<String> cookieStrings = new ArrayList<>();
-      for (Cookie cookie : cookies) {
-        cookieStrings.add(cookie.toString(true));
-      }
-      Map<String, List<String>> multimap = Collections.singletonMap("Set-Cookie", cookieStrings);
-      try {
-        cookieHandler.put(url.uri(), multimap);
-      } catch (IOException e) {
-        Platform.get().log(WARN, "Saving cookies failed for " + url.resolve("/..."), e);
-      }
-    }
-  }
-
-  @Override public List<Cookie> loadForRequest(HttpUrl url) {
-    // The RI passes all headers. We don't have 'em, so we don't pass 'em!
-    Map<String, List<String>> headers = Collections.emptyMap();
-    Map<String, List<String>> cookieHeaders;
-    try {
-      cookieHeaders = cookieHandler.get(url.uri(), headers);
-    } catch (IOException e) {
-      Platform.get().log(WARN, "Loading cookies failed for " + url.resolve("/..."), e);
-      return Collections.emptyList();
-    }
-
-    List<Cookie> cookies = null;
-    for (Map.Entry<String, List<String>> entry : cookieHeaders.entrySet()) {
-      String key = entry.getKey();
-      if (("Cookie".equalsIgnoreCase(key) || "Cookie2".equalsIgnoreCase(key))
-          && !entry.getValue().isEmpty()) {
-        for (String header : entry.getValue()) {
-          if (cookies == null) cookies = new ArrayList<>();
-          cookies.addAll(decodeHeaderAsJavaNetCookies(url, header));
-        }
-      }
-    }
-
-    return cookies != null
-        ? Collections.unmodifiableList(cookies)
-        : Collections.<Cookie>emptyList();
-  }
-
-  /**
-   * Convert a request header to OkHttp's cookies via {@link HttpCookie}. That extra step handles
-   * multiple cookies in a single request header, which {@link Cookie#parse} doesn't support.
-   */
-  private List<Cookie> decodeHeaderAsJavaNetCookies(HttpUrl url, String header) {
-    List<Cookie> result = new ArrayList<>();
-    for (int pos = 0, limit = header.length(), pairEnd; pos < limit; pos = pairEnd + 1) {
-      pairEnd = delimiterOffset(header, pos, limit, ";,");
-      int equalsSign = delimiterOffset(header, pos, pairEnd, '=');
-      String name = trimSubstring(header, pos, equalsSign);
-      if (name.startsWith("$")) continue;
-
-      // We have either name=value or just a name.
-      String value = equalsSign < pairEnd
-          ? trimSubstring(header, equalsSign + 1, pairEnd)
-          : "";
-
-      // If the value is "quoted", drop the quotes.
-      if (value.startsWith("\"") && value.endsWith("\"")) {
-        value = value.substring(1, value.length() - 1);
-      }
-
-      result.add(new Cookie.Builder()
-          .name(name)
-          .value(value)
-          .domain(url.host())
-          .build());
-    }
-    return result;
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
new file mode 100644
index 0000000000..c9b2cd50f5
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.Util.delimiterOffset
+import okhttp3.internal.Util.trimSubstring
+import okhttp3.internal.cookieToString
+import okhttp3.internal.platform.Platform
+import okhttp3.internal.platform.Platform.Companion.WARN
+import java.io.IOException
+import java.net.CookieHandler
+import java.net.HttpCookie
+import java.util.ArrayList
+import java.util.Collections
+
+/** A cookie jar that delegates to a [java.net.CookieHandler].  */
+class JavaNetCookieJar(private val cookieHandler: CookieHandler) : CookieJar {
+
+  override fun saveFromResponse(url: HttpUrl, cookies: List<Cookie>) {
+    val cookieStrings = mutableListOf<String>()
+    for (cookie in cookies) {
+      cookieStrings.add(cookieToString(cookie, true))
+    }
+    val multimap = mapOf("Set-Cookie" to cookieStrings)
+    try {
+      cookieHandler.put(url.uri(), multimap)
+    } catch (e: IOException) {
+      Platform.get().log(WARN, "Saving cookies failed for " + url.resolve("/...")!!, e)
+    }
+  }
+
+  override fun loadForRequest(url: HttpUrl): List<Cookie> {
+    val cookieHeaders = try {
+      // The RI passes all headers. We don't have 'em, so we don't pass 'em!
+      cookieHandler.get(url.uri(), emptyMap<String, List<String>>())
+    } catch (e: IOException) {
+      Platform.get().log(WARN, "Loading cookies failed for " + url.resolve("/...")!!, e)
+      return emptyList()
+    }
+
+    var cookies: MutableList<Cookie>? = null
+    for ((key, value) in cookieHeaders) {
+      if (("Cookie".equals(key, ignoreCase = true) || "Cookie2".equals(key, ignoreCase = true))
+          && value.isNotEmpty()) {
+        for (header in value) {
+          if (cookies == null) cookies = ArrayList()
+          cookies.addAll(decodeHeaderAsJavaNetCookies(url, header))
+        }
+      }
+    }
+
+    return if (cookies != null) {
+      Collections.unmodifiableList(cookies)
+    } else {
+      emptyList()
+    }
+  }
+
+  /**
+   * Convert a request header to OkHttp's cookies via [HttpCookie]. That extra step handles
+   * multiple cookies in a single request header, which [Cookie.parse] doesn't support.
+   */
+  private fun decodeHeaderAsJavaNetCookies(url: HttpUrl, header: String): List<Cookie> {
+    val result = mutableListOf<Cookie>()
+    var pos = 0
+    val limit = header.length
+    var pairEnd: Int
+    while (pos < limit) {
+      pairEnd = delimiterOffset(header, pos, limit, ";,")
+      val equalsSign = delimiterOffset(header, pos, pairEnd, '=')
+      val name = trimSubstring(header, pos, equalsSign)
+      if (name.startsWith("$")) {
+        pos = pairEnd + 1
+        continue
+      }
+
+      // We have either name=value or just a name.
+      var value = if (equalsSign < pairEnd) {
+        trimSubstring(header, equalsSign + 1, pairEnd)
+      } else {
+        ""
+      }
+
+      // If the value is "quoted", drop the quotes.
+      if (value.startsWith("\"") && value.endsWith("\"")) {
+        value = value.substring(1, value.length - 1)
+      }
+
+      result.add(Cookie.Builder()
+          .name(name)
+          .value(value)
+          .domain(url.host())
+          .build())
+      pos = pairEnd + 1
+    }
+    return result
+  }
+}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java b/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
deleted file mode 100644
index 0bbe613492..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/OkUrlFactory.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.HttpURLConnection;
-import java.net.Proxy;
-import java.net.URL;
-import java.net.URLConnection;
-import java.net.URLStreamHandler;
-import java.net.URLStreamHandlerFactory;
-import okhttp3.internal.URLFilter;
-import okhttp3.internal.huc.OkHttpURLConnection;
-import okhttp3.internal.huc.OkHttpsURLConnection;
-
-/**
- * @deprecated OkHttp will be dropping its ability to be used with {@link HttpURLConnection} in an
- * upcoming release. Applications that need this should either downgrade to the system's built-in
- * {@link HttpURLConnection} or upgrade to OkHttp's Request/Response API.
- */
-public final class OkUrlFactory implements URLStreamHandlerFactory, Cloneable {
-  private OkHttpClient client;
-  private URLFilter urlFilter;
-
-  public OkUrlFactory(OkHttpClient client) {
-    this.client = client;
-  }
-
-  public OkHttpClient client() {
-    return client;
-  }
-
-  public OkUrlFactory setClient(OkHttpClient client) {
-    this.client = client;
-    return this;
-  }
-
-  void setUrlFilter(URLFilter filter) {
-    urlFilter = filter;
-  }
-
-  /**
-   * Returns a copy of this stream handler factory that includes a shallow copy of the internal
-   * {@linkplain OkHttpClient HTTP client}.
-   */
-  @Override public OkUrlFactory clone() {
-    return new OkUrlFactory(client);
-  }
-
-  public HttpURLConnection open(URL url) {
-    return open(url, client.proxy());
-  }
-
-  HttpURLConnection open(URL url, Proxy proxy) {
-    String protocol = url.getProtocol();
-    OkHttpClient copy = client.newBuilder()
-        .proxy(proxy)
-        .build();
-
-    if (protocol.equals("http")) return new OkHttpURLConnection(url, copy, urlFilter);
-    if (protocol.equals("https")) return new OkHttpsURLConnection(url, copy, urlFilter);
-    throw new IllegalArgumentException("Unexpected protocol: " + protocol);
-  }
-
-  /**
-   * Creates a URLStreamHandler as a {@link java.net.URL#setURLStreamHandlerFactory}.
-   *
-   * <p>This code configures OkHttp to handle all HTTP and HTTPS connections
-   * created with {@link java.net.URL#openConnection()}: <pre>   {@code
-   *
-   *   OkHttpClient okHttpClient = new OkHttpClient();
-   *   URL.setURLStreamHandlerFactory(new OkUrlFactory(okHttpClient));
-   * }</pre>
-   */
-  @Override public URLStreamHandler createURLStreamHandler(final String protocol) {
-    if (!protocol.equals("http") && !protocol.equals("https")) return null;
-
-    return new URLStreamHandler() {
-      @Override protected URLConnection openConnection(URL url) {
-        return open(url);
-      }
-
-      @Override protected URLConnection openConnection(URL url, Proxy proxy) {
-        return open(url, proxy);
-      }
-
-      @Override protected int getDefaultPort() {
-        if (protocol.equals("http")) return 80;
-        if (protocol.equals("https")) return 443;
-        throw new AssertionError();
-      }
-    };
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
deleted file mode 100644
index 0b7a02e1f9..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/JavaNetHeaders.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Map;
-import java.util.TreeMap;
-import okhttp3.Headers;
-
-public final class JavaNetHeaders {
-  private JavaNetHeaders() {
-  }
-
-  private static final Comparator<String> FIELD_NAME_COMPARATOR = new Comparator<String>() {
-    // @FindBugsSuppressWarnings("ES_COMPARING_PARAMETER_STRING_WITH_EQ")
-    @Override public int compare(String a, String b) {
-      if (a == b) {
-        return 0;
-      } else if (a == null) {
-        return -1;
-      } else if (b == null) {
-        return 1;
-      } else {
-        return String.CASE_INSENSITIVE_ORDER.compare(a, b);
-      }
-    }
-  };
-
-  /**
-   * Returns an immutable map containing each field to its list of values.
-   *
-   * @param valueForNullKey the request line for requests, or the status line for responses. If
-   * non-null, this value is mapped to the null key.
-   */
-  public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
-    Map<String, List<String>> result = new TreeMap<>(FIELD_NAME_COMPARATOR);
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      String fieldName = headers.name(i);
-      String value = headers.value(i);
-
-      List<String> allValues = new ArrayList<>();
-      List<String> otherValues = result.get(fieldName);
-      if (otherValues != null) {
-        allValues.addAll(otherValues);
-      }
-      allValues.add(value);
-      result.put(fieldName, Collections.unmodifiableList(allValues));
-    }
-    if (valueForNullKey != null) {
-      result.put(null, Collections.unmodifiableList(Collections.singletonList(valueForNullKey)));
-    }
-    return Collections.unmodifiableMap(result);
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java
deleted file mode 100644
index b4b2f68347..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/BufferedRequestBody.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import okhttp3.Request;
-import okio.Buffer;
-import okio.BufferedSink;
-
-/**
- * This request body involves an application thread only. First all bytes are written to the buffer.
- * Only once that is complete are bytes then copied to the network.
- *
- * <p>This body has two special powers. First, it can retransmit the same request body multiple
- * times in order to recover from failures or cope with redirects. Second, it can compute the total
- * length of the request body by measuring it after it has been written to the output stream.
- */
-final class BufferedRequestBody extends OutputStreamRequestBody {
-  final Buffer buffer = new Buffer();
-  long contentLength = -1L;
-
-  BufferedRequestBody(long expectedContentLength) {
-    initOutputStream(buffer, expectedContentLength);
-  }
-
-  @Override public long contentLength() throws IOException {
-    return contentLength;
-  }
-
-  /**
-   * Now that we've buffered the entire request body, update the request headers and the body
-   * itself. This happens late to enable HttpURLConnection users to complete the socket connection
-   * before sending request body bytes.
-   */
-  @Override public Request prepareToSendRequest(Request request) throws IOException {
-    if (request.header("Content-Length") != null) return request;
-
-    outputStream().close();
-    contentLength = buffer.size();
-    return request.newBuilder()
-        .removeHeader("Transfer-Encoding")
-        .header("Content-Length", Long.toString(buffer.size()))
-        .build();
-  }
-
-  @Override public void writeTo(BufferedSink sink) throws IOException {
-    buffer.copyTo(sink.buffer(), 0, buffer.size());
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
deleted file mode 100644
index a051bf2198..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
+++ /dev/null
@@ -1,308 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.URL;
-import java.security.Permission;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.util.List;
-import java.util.Map;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Handshake;
-import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
-
-/**
- * Implement an HTTPS connection by delegating to an HTTP connection for everything but the
- * HTTPS-specific stuff.
- */
-abstract class DelegatingHttpsURLConnection extends HttpsURLConnection {
-  private final HttpURLConnection delegate;
-
-  DelegatingHttpsURLConnection(HttpURLConnection delegate) {
-    super(delegate.getURL());
-    this.delegate = delegate;
-  }
-
-  protected abstract Handshake handshake();
-
-  @Override public abstract void setHostnameVerifier(HostnameVerifier hostnameVerifier);
-
-  @Override public abstract HostnameVerifier getHostnameVerifier();
-
-  @Override public abstract void setSSLSocketFactory(SSLSocketFactory sslSocketFactory);
-
-  @Override public abstract SSLSocketFactory getSSLSocketFactory();
-
-  @Override public String getCipherSuite() {
-    Handshake handshake = handshake();
-    return handshake != null ? handshake.cipherSuite().javaName() : null;
-  }
-
-  @Override public Certificate[] getLocalCertificates() {
-    Handshake handshake = handshake();
-    if (handshake == null) return null;
-    List<Certificate> result = handshake.localCertificates();
-    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
-  }
-
-  @Override public Certificate[] getServerCertificates() throws SSLPeerUnverifiedException {
-    Handshake handshake = handshake();
-    if (handshake == null) return null;
-    List<Certificate> result = handshake.peerCertificates();
-    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
-  }
-
-  @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-    Handshake handshake = handshake();
-    return handshake != null ? handshake.peerPrincipal() : null;
-  }
-
-  @Override public Principal getLocalPrincipal() {
-    Handshake handshake = handshake();
-    return handshake != null ? handshake.localPrincipal() : null;
-  }
-
-  @Override public void connect() throws IOException {
-    connected = true;
-    delegate.connect();
-  }
-
-  @Override public void disconnect() {
-    delegate.disconnect();
-  }
-
-  @Override public InputStream getErrorStream() {
-    return delegate.getErrorStream();
-  }
-
-  @Override public String getRequestMethod() {
-    return delegate.getRequestMethod();
-  }
-
-  @Override public int getResponseCode() throws IOException {
-    return delegate.getResponseCode();
-  }
-
-  @Override public String getResponseMessage() throws IOException {
-    return delegate.getResponseMessage();
-  }
-
-  @Override public void setRequestMethod(String method) throws ProtocolException {
-    delegate.setRequestMethod(method);
-  }
-
-  @Override public boolean usingProxy() {
-    return delegate.usingProxy();
-  }
-
-  @Override public boolean getInstanceFollowRedirects() {
-    return delegate.getInstanceFollowRedirects();
-  }
-
-  @Override public void setInstanceFollowRedirects(boolean followRedirects) {
-    delegate.setInstanceFollowRedirects(followRedirects);
-  }
-
-  @Override public boolean getAllowUserInteraction() {
-    return delegate.getAllowUserInteraction();
-  }
-
-  @Override public Object getContent() throws IOException {
-    return delegate.getContent();
-  }
-
-  @SuppressWarnings("unchecked") // Spec does not generify
-  @Override public Object getContent(Class[] types) throws IOException {
-    return delegate.getContent(types);
-  }
-
-  @Override public String getContentEncoding() {
-    return delegate.getContentEncoding();
-  }
-
-  @Override public int getContentLength() {
-    return delegate.getContentLength();
-  }
-
-  @IgnoreJRERequirement // Should only be invoked on Java 7+.
-  @Override public long getContentLengthLong() {
-    return delegate.getContentLengthLong();
-  }
-
-  @Override public String getContentType() {
-    return delegate.getContentType();
-  }
-
-  @Override public long getDate() {
-    return delegate.getDate();
-  }
-
-  @Override public boolean getDefaultUseCaches() {
-    return delegate.getDefaultUseCaches();
-  }
-
-  @Override public boolean getDoInput() {
-    return delegate.getDoInput();
-  }
-
-  @Override public boolean getDoOutput() {
-    return delegate.getDoOutput();
-  }
-
-  @Override public long getExpiration() {
-    return delegate.getExpiration();
-  }
-
-  @Override public String getHeaderField(int pos) {
-    return delegate.getHeaderField(pos);
-  }
-
-  @Override public Map<String, List<String>> getHeaderFields() {
-    return delegate.getHeaderFields();
-  }
-
-  @Override public Map<String, List<String>> getRequestProperties() {
-    return delegate.getRequestProperties();
-  }
-
-  @Override public void addRequestProperty(String field, String newValue) {
-    delegate.addRequestProperty(field, newValue);
-  }
-
-  @Override public String getHeaderField(String key) {
-    return delegate.getHeaderField(key);
-  }
-
-  @IgnoreJRERequirement // Should only be invoked on Java 7+.
-  @Override public long getHeaderFieldLong(String field, long defaultValue) {
-    return delegate.getHeaderFieldLong(field, defaultValue);
-  }
-
-  @Override public long getHeaderFieldDate(String field, long defaultValue) {
-    return delegate.getHeaderFieldDate(field, defaultValue);
-  }
-
-  @Override public int getHeaderFieldInt(String field, int defaultValue) {
-    return delegate.getHeaderFieldInt(field, defaultValue);
-  }
-
-  @Override public String getHeaderFieldKey(int position) {
-    return delegate.getHeaderFieldKey(position);
-  }
-
-  @Override public long getIfModifiedSince() {
-    return delegate.getIfModifiedSince();
-  }
-
-  @Override public InputStream getInputStream() throws IOException {
-    return delegate.getInputStream();
-  }
-
-  @Override public long getLastModified() {
-    return delegate.getLastModified();
-  }
-
-  @Override public OutputStream getOutputStream() throws IOException {
-    return delegate.getOutputStream();
-  }
-
-  @Override public Permission getPermission() throws IOException {
-    return delegate.getPermission();
-  }
-
-  @Override public String getRequestProperty(String field) {
-    return delegate.getRequestProperty(field);
-  }
-
-  @Override public URL getURL() {
-    return delegate.getURL();
-  }
-
-  @Override public boolean getUseCaches() {
-    return delegate.getUseCaches();
-  }
-
-  @Override public void setAllowUserInteraction(boolean newValue) {
-    delegate.setAllowUserInteraction(newValue);
-  }
-
-  @Override public void setDefaultUseCaches(boolean newValue) {
-    delegate.setDefaultUseCaches(newValue);
-  }
-
-  @Override public void setDoInput(boolean newValue) {
-    delegate.setDoInput(newValue);
-  }
-
-  @Override public void setDoOutput(boolean newValue) {
-    delegate.setDoOutput(newValue);
-  }
-
-  @IgnoreJRERequirement // Should only be invoked on Java 7+.
-  @Override public void setFixedLengthStreamingMode(long contentLength) {
-    delegate.setFixedLengthStreamingMode(contentLength);
-  }
-
-  @Override public void setIfModifiedSince(long newValue) {
-    delegate.setIfModifiedSince(newValue);
-  }
-
-  @Override public void setRequestProperty(String field, String newValue) {
-    delegate.setRequestProperty(field, newValue);
-  }
-
-  @Override public void setUseCaches(boolean newValue) {
-    delegate.setUseCaches(newValue);
-  }
-
-  @Override public void setConnectTimeout(int timeoutMillis) {
-    delegate.setConnectTimeout(timeoutMillis);
-  }
-
-  @Override public int getConnectTimeout() {
-    return delegate.getConnectTimeout();
-  }
-
-  @Override public void setReadTimeout(int timeoutMillis) {
-    delegate.setReadTimeout(timeoutMillis);
-  }
-
-  @Override public int getReadTimeout() {
-    return delegate.getReadTimeout();
-  }
-
-  @Override public String toString() {
-    return delegate.toString();
-  }
-
-  @Override public void setFixedLengthStreamingMode(int contentLength) {
-    delegate.setFixedLengthStreamingMode(contentLength);
-  }
-
-  @Override public void setChunkedStreamingMode(int chunkLength) {
-    delegate.setChunkedStreamingMode(chunkLength);
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
deleted file mode 100644
index b6e493c6ca..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
+++ /dev/null
@@ -1,657 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InterruptedIOException;
-import java.io.OutputStream;
-import java.net.HttpURLConnection;
-import java.net.InetSocketAddress;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.SocketPermission;
-import java.net.URL;
-import java.security.Permission;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.Dispatcher;
-import okhttp3.Handshake;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Internal;
-import okhttp3.internal.JavaNetHeaders;
-import okhttp3.internal.URLFilter;
-import okhttp3.internal.Version;
-import okhttp3.internal.http.HttpDate;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.StatusLine;
-import okhttp3.internal.platform.Platform;
-import okio.Buffer;
-
-import static okhttp3.internal.platform.Platform.WARN;
-
-/**
- * This implementation uses {@linkplain Call} to send requests and receive responses.
- *
- * <h3>What does 'connected' mean?</h3> This class inherits a {@code connected} field from the
- * superclass. That field is <strong>not</strong> used to indicate whether this URLConnection is
- * currently connected. Instead, it indicates whether a connection has ever been attempted. Once a
- * connection has been attempted, certain properties (request header fields, request method, etc.)
- * are immutable.
- */
-public final class OkHttpURLConnection extends HttpURLConnection implements Callback {
-  /**
-   * Synthetic response header: the selected {@link Protocol protocol} ("spdy/3.1", "http/1.1",
-   * etc).
-   */
-  public static final String SELECTED_PROTOCOL = Platform.get().getPrefix() + "-Selected-Protocol";
-
-  /** Synthetic response header: the location from which the response was loaded. */
-  public static final String RESPONSE_SOURCE = Platform.get().getPrefix() + "-Response-Source";
-
-  private static final Set<String> METHODS = new LinkedHashSet<>(
-      Arrays.asList("OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
-
-  // These fields are confined to the application thread that uses HttpURLConnection.
-
-  OkHttpClient client;
-  private final NetworkInterceptor networkInterceptor = new NetworkInterceptor();
-  private Headers.Builder requestHeaders = new Headers.Builder();
-  private boolean executed;
-  Call call;
-  URLFilter urlFilter;
-
-  /** Lazily created (with synthetic headers) on first call to getHeaders(). */
-  private Headers responseHeaders;
-
-  /** Like the superclass field of the same name, but a long and available on all platforms. */
-  private long fixedContentLength = -1L;
-
-  // These fields are guarded by lock.
-  private final Object lock = new Object();
-  private Response response;
-  private Throwable callFailure;
-  Response networkResponse;
-  boolean connectPending = true;
-  Proxy proxy;
-  Handshake handshake;
-
-  public OkHttpURLConnection(URL url, OkHttpClient client) {
-    super(url);
-    this.client = client;
-  }
-
-  public OkHttpURLConnection(URL url, OkHttpClient client, URLFilter urlFilter) {
-    this(url, client);
-    this.urlFilter = urlFilter;
-  }
-
-  @Override public void connect() throws IOException {
-    if (executed) return;
-
-    Call call = buildCall();
-    executed = true;
-    call.enqueue(this);
-
-    synchronized (lock) {
-      try {
-        while (connectPending && response == null && callFailure == null) {
-          lock.wait(); // Wait 'til the network interceptor is reached or the call fails.
-        }
-        if (callFailure != null) {
-          throw propagate(callFailure);
-        }
-      } catch (InterruptedException e) {
-        throw new InterruptedIOException();
-      }
-    }
-  }
-
-  @Override public void disconnect() {
-    // Calling disconnect() before a connection exists should have no effect.
-    if (call == null) return;
-
-    networkInterceptor.proceed(); // Unblock any waiting async thread.
-    call.cancel();
-  }
-
-  /**
-   * Returns an input stream from the server in the case of error such as the requested file (txt,
-   * htm, html) is not found on the remote server.
-   */
-  @Override public InputStream getErrorStream() {
-    try {
-      Response response = getResponse(true);
-      if (HttpHeaders.hasBody(response) && response.code() >= HTTP_BAD_REQUEST) {
-        return response.body().byteStream();
-      }
-      return null;
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  private Headers getHeaders() throws IOException {
-    if (responseHeaders == null) {
-      Response response = getResponse(true);
-      Headers headers = response.headers();
-      responseHeaders = headers.newBuilder()
-          .add(SELECTED_PROTOCOL, response.protocol().toString())
-          .add(RESPONSE_SOURCE, responseSourceHeader(response))
-          .build();
-    }
-    return responseHeaders;
-  }
-
-  private static String responseSourceHeader(Response response) {
-    if (response.networkResponse() == null) {
-      if (response.cacheResponse() == null) {
-        return "NONE";
-      }
-      return "CACHE " + response.code();
-    }
-    if (response.cacheResponse() == null) {
-      return "NETWORK " + response.code();
-    }
-    return "CONDITIONAL_CACHE " + response.networkResponse().code();
-  }
-
-  /**
-   * Returns the value of the field at {@code position}. Returns null if there are fewer than {@code
-   * position} headers.
-   */
-  @Override public String getHeaderField(int position) {
-    try {
-      Headers headers = getHeaders();
-      if (position < 0 || position >= headers.size()) return null;
-      return headers.value(position);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Returns the value of the field corresponding to the {@code fieldName}, or null if there is no
-   * such field. If the field has multiple values, the last value is returned.
-   */
-  @Override public String getHeaderField(String fieldName) {
-    try {
-      return fieldName == null
-          ? StatusLine.get(getResponse(true)).toString()
-          : getHeaders().get(fieldName);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  @Override public String getHeaderFieldKey(int position) {
-    try {
-      Headers headers = getHeaders();
-      if (position < 0 || position >= headers.size()) return null;
-      return headers.name(position);
-    } catch (IOException e) {
-      return null;
-    }
-  }
-
-  @Override public Map<String, List<String>> getHeaderFields() {
-    try {
-      return JavaNetHeaders.toMultimap(getHeaders(),
-          StatusLine.get(getResponse(true)).toString());
-    } catch (IOException e) {
-      return Collections.emptyMap();
-    }
-  }
-
-  @Override public Map<String, List<String>> getRequestProperties() {
-    if (connected) {
-      throw new IllegalStateException(
-          "Cannot access request header fields after connection is set");
-    }
-
-    return JavaNetHeaders.toMultimap(requestHeaders.build(), null);
-  }
-
-  @Override public InputStream getInputStream() throws IOException {
-    if (!doInput) {
-      throw new ProtocolException("This protocol does not support input");
-    }
-
-    Response response = getResponse(false);
-
-    if (response.code() >= HTTP_BAD_REQUEST) {
-      throw new FileNotFoundException(url.toString());
-    }
-
-    return response.body().byteStream();
-  }
-
-  @Override public OutputStream getOutputStream() throws IOException {
-    OutputStreamRequestBody requestBody = (OutputStreamRequestBody) buildCall().request().body();
-    if (requestBody == null) {
-      throw new ProtocolException("method does not support a request body: " + method);
-    }
-
-    // If this request needs to stream bytes to the server, build a physical connection immediately
-    // and start streaming those bytes over that connection.
-    if (requestBody instanceof StreamedRequestBody) {
-      connect();
-      networkInterceptor.proceed();
-    }
-
-    if (requestBody.isClosed()) {
-      throw new ProtocolException("cannot write request body after response has been read");
-    }
-
-    return requestBody.outputStream();
-  }
-
-  @Override public Permission getPermission() throws IOException {
-    URL url = getURL();
-    String hostname = url.getHost();
-    int hostPort = url.getPort() != -1
-        ? url.getPort()
-        : HttpUrl.defaultPort(url.getProtocol());
-    if (usingProxy()) {
-      InetSocketAddress proxyAddress = (InetSocketAddress) client.proxy().address();
-      hostname = proxyAddress.getHostName();
-      hostPort = proxyAddress.getPort();
-    }
-    return new SocketPermission(hostname + ":" + hostPort, "connect, resolve");
-  }
-
-  @Override public String getRequestProperty(String field) {
-    if (field == null) return null;
-    return requestHeaders.get(field);
-  }
-
-  @Override public void setConnectTimeout(int timeoutMillis) {
-    client = client.newBuilder()
-        .connectTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
-        .build();
-  }
-
-  @Override public void setInstanceFollowRedirects(boolean followRedirects) {
-    client = client.newBuilder()
-        .followRedirects(followRedirects)
-        .build();
-  }
-
-  @Override public boolean getInstanceFollowRedirects() {
-    return client.followRedirects();
-  }
-
-  @Override public int getConnectTimeout() {
-    return client.connectTimeoutMillis();
-  }
-
-  @Override public void setReadTimeout(int timeoutMillis) {
-    client = client.newBuilder()
-        .readTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
-        .build();
-  }
-
-  @Override public int getReadTimeout() {
-    return client.readTimeoutMillis();
-  }
-
-  private Call buildCall() throws IOException {
-    if (call != null) {
-      return call;
-    }
-
-    connected = true;
-    if (doOutput) {
-      if (method.equals("GET")) {
-        // they are requesting a stream to write to. This implies a POST method
-        method = "POST";
-      } else if (!HttpMethod.permitsRequestBody(method)) {
-        throw new ProtocolException(method + " does not support writing");
-      }
-    }
-
-    if (requestHeaders.get("User-Agent") == null) {
-      requestHeaders.add("User-Agent", defaultUserAgent());
-    }
-
-    OutputStreamRequestBody requestBody = null;
-    if (HttpMethod.permitsRequestBody(method)) {
-      // Add a content type for the request body, if one isn't already present.
-      String contentType = requestHeaders.get("Content-Type");
-      if (contentType == null) {
-        contentType = "application/x-www-form-urlencoded";
-        requestHeaders.add("Content-Type", contentType);
-      }
-
-      boolean stream = fixedContentLength != -1L || chunkLength > 0;
-
-      long contentLength = -1L;
-      String contentLengthString = requestHeaders.get("Content-Length");
-      if (fixedContentLength != -1L) {
-        contentLength = fixedContentLength;
-      } else if (contentLengthString != null) {
-        contentLength = Long.parseLong(contentLengthString);
-      }
-
-      requestBody = stream
-          ? new StreamedRequestBody(contentLength)
-          : new BufferedRequestBody(contentLength);
-      requestBody.timeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
-    }
-
-    Request request = new Request.Builder()
-        .url(Internal.instance.getHttpUrlChecked(getURL().toString()))
-        .headers(requestHeaders.build())
-        .method(method, requestBody)
-        .build();
-
-    if (urlFilter != null) {
-      urlFilter.checkURLPermitted(request.url().url());
-    }
-
-    OkHttpClient.Builder clientBuilder = client.newBuilder();
-    clientBuilder.interceptors().clear();
-    clientBuilder.interceptors().add(UnexpectedException.INTERCEPTOR);
-    clientBuilder.networkInterceptors().clear();
-    clientBuilder.networkInterceptors().add(networkInterceptor);
-
-    // Use a separate dispatcher so that limits aren't impacted. But use the same executor service!
-    clientBuilder.dispatcher(new Dispatcher(client.dispatcher().executorService()));
-
-    // If we're currently not using caches, make sure the engine's client doesn't have one.
-    if (!getUseCaches()) {
-      clientBuilder.cache(null);
-    }
-
-    return call = clientBuilder.build().newCall(request);
-  }
-
-  private String defaultUserAgent() {
-    String agent = System.getProperty("http.agent");
-    return agent != null ? toHumanReadableAscii(agent) : Version.userAgent();
-  }
-
-  /** Returns {@code s} with control characters and non-ASCII characters replaced with '?'. */
-  private static String toHumanReadableAscii(String s) {
-    for (int i = 0, length = s.length(), c; i < length; i += Character.charCount(c)) {
-      c = s.codePointAt(i);
-      if (c > '\u001f' && c < '\u007f') continue;
-
-      Buffer buffer = new Buffer();
-      buffer.writeUtf8(s, 0, i);
-      buffer.writeUtf8CodePoint('?');
-      for (int j = i + Character.charCount(c); j < length; j += Character.charCount(c)) {
-        c = s.codePointAt(j);
-        buffer.writeUtf8CodePoint(c > '\u001f' && c < '\u007f' ? c : '?');
-      }
-      return buffer.readUtf8();
-    }
-    return s;
-  }
-
-  /**
-   * Aggressively tries to get the final HTTP response, potentially making many HTTP requests in the
-   * process in order to cope with redirects and authentication.
-   */
-  private Response getResponse(boolean networkResponseOnError) throws IOException {
-    synchronized (lock) {
-      if (response != null) return response;
-      if (callFailure != null) {
-        if (networkResponseOnError && networkResponse != null) return networkResponse;
-        throw propagate(callFailure);
-      }
-    }
-
-    Call call = buildCall();
-    networkInterceptor.proceed();
-
-    OutputStreamRequestBody requestBody = (OutputStreamRequestBody) call.request().body();
-    if (requestBody != null) requestBody.outputStream().close();
-
-    if (executed) {
-      synchronized (lock) {
-        try {
-          while (response == null && callFailure == null) {
-            lock.wait(); // Wait until the response is returned or the call fails.
-          }
-        } catch (InterruptedException e) {
-          throw new InterruptedIOException();
-        }
-      }
-    } else {
-      executed = true;
-      try {
-        onResponse(call, call.execute());
-      } catch (IOException e) {
-        onFailure(call, e);
-      }
-    }
-
-    synchronized (lock) {
-      if (callFailure != null) throw propagate(callFailure);
-      if (response != null) return response;
-    }
-
-    throw new AssertionError();
-  }
-
-  /**
-   * Returns true if either:
-   *
-   * <ul>
-   *   <li>A specific proxy was explicitly configured for this connection.
-   *   <li>The response has already been retrieved, and a proxy was {@link
-   *       java.net.ProxySelector selected} in order to get it.
-   * </ul>
-   *
-   * <p><strong>Warning:</strong> This method may return false before attempting to connect and true
-   * afterwards.
-   */
-  @Override public boolean usingProxy() {
-    if (proxy != null) return true;
-    Proxy clientProxy = client.proxy();
-    return clientProxy != null && clientProxy.type() != Proxy.Type.DIRECT;
-  }
-
-  @Override public String getResponseMessage() throws IOException {
-    return getResponse(true).message();
-  }
-
-  @Override public int getResponseCode() throws IOException {
-    return getResponse(true).code();
-  }
-
-  @Override public void setRequestProperty(String field, String newValue) {
-    if (connected) {
-      throw new IllegalStateException("Cannot set request property after connection is made");
-    }
-    if (field == null) {
-      throw new NullPointerException("field == null");
-    }
-    if (newValue == null) {
-      // Silently ignore null header values for backwards compatibility with older
-      // android versions as well as with other URLConnection implementations.
-      //
-      // Some implementations send a malformed HTTP header when faced with
-      // such requests, we respect the spec and ignore the header.
-      Platform.get().log(WARN, "Ignoring header " + field + " because its value was null.", null);
-      return;
-    }
-
-    requestHeaders.set(field, newValue);
-  }
-
-  @Override public void setIfModifiedSince(long newValue) {
-    super.setIfModifiedSince(newValue);
-    if (ifModifiedSince != 0) {
-      requestHeaders.set("If-Modified-Since", HttpDate.format(new Date(ifModifiedSince)));
-    } else {
-      requestHeaders.removeAll("If-Modified-Since");
-    }
-  }
-
-  @Override public void addRequestProperty(String field, String value) {
-    if (connected) {
-      throw new IllegalStateException("Cannot add request property after connection is made");
-    }
-    if (field == null) {
-      throw new NullPointerException("field == null");
-    }
-    if (value == null) {
-      // Silently ignore null header values for backwards compatibility with older
-      // android versions as well as with other URLConnection implementations.
-      //
-      // Some implementations send a malformed HTTP header when faced with
-      // such requests, we respect the spec and ignore the header.
-      Platform.get().log(WARN, "Ignoring header " + field + " because its value was null.", null);
-      return;
-    }
-
-    requestHeaders.add(field, value);
-  }
-
-  @Override public void setRequestMethod(String method) throws ProtocolException {
-    if (!METHODS.contains(method)) {
-      throw new ProtocolException("Expected one of " + METHODS + " but was " + method);
-    }
-    this.method = method;
-  }
-
-  @Override public void setFixedLengthStreamingMode(int contentLength) {
-    setFixedLengthStreamingMode((long) contentLength);
-  }
-
-  @Override public void setFixedLengthStreamingMode(long contentLength) {
-    if (super.connected) throw new IllegalStateException("Already connected");
-    if (chunkLength > 0) throw new IllegalStateException("Already in chunked mode");
-    if (contentLength < 0) throw new IllegalArgumentException("contentLength < 0");
-    this.fixedContentLength = contentLength;
-    super.fixedContentLength = (int) Math.min(contentLength, Integer.MAX_VALUE);
-  }
-
-  @Override public void onFailure(Call call, IOException e) {
-    synchronized (lock) {
-      this.callFailure = (e instanceof UnexpectedException) ? e.getCause() : e;
-      lock.notifyAll();
-    }
-  }
-
-  @Override public void onResponse(Call call, Response response) {
-    synchronized (lock) {
-      this.response = response;
-      this.handshake = response.handshake();
-      this.url = response.request().url().url();
-      lock.notifyAll();
-    }
-  }
-
-  static final class UnexpectedException extends IOException {
-    static final Interceptor INTERCEPTOR = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        try {
-          return chain.proceed(chain.request());
-        } catch (Error | RuntimeException e) {
-          throw new UnexpectedException(e);
-        }
-      }
-    };
-
-    UnexpectedException(Throwable cause) {
-      super(cause);
-    }
-  }
-
-  /** Throws {@code throwable} as either an IOException, RuntimeException, or Error. */
-  private static IOException propagate(Throwable throwable) throws IOException {
-    if (throwable instanceof IOException) throw (IOException) throwable;
-    if (throwable instanceof Error) throw (Error) throwable;
-    if (throwable instanceof RuntimeException) throw (RuntimeException) throwable;
-    throw new AssertionError();
-  }
-
-  /**
-   * The HttpURLConnection gives the application control between establishing the connection and
-   * transmitting the request body. This interceptor stalls async calls right at this point. The
-   * call will remain stalled until {@link #proceed()} is called.
-   */
-  final class NetworkInterceptor implements Interceptor {
-    // Guarded by HttpUrlConnection.this.
-    private boolean proceed;
-
-    public void proceed() {
-      synchronized (lock) {
-        this.proceed = true;
-        lock.notifyAll();
-      }
-    }
-
-    @Override public Response intercept(Chain chain) throws IOException {
-      Request request = chain.request();
-
-      // Double-check the URL filter to prevent redirects from hitting filtered URLs.
-      if (urlFilter != null) {
-        urlFilter.checkURLPermitted(request.url().url());
-      }
-
-      synchronized (lock) {
-        connectPending = false;
-        proxy = chain.connection().route().proxy();
-        handshake = chain.connection().handshake();
-        lock.notifyAll();
-
-        try {
-          while (!proceed) {
-            lock.wait(); // Wait until proceed() is called.
-          }
-        } catch (InterruptedException e) {
-          throw new InterruptedIOException();
-        }
-      }
-
-      // Try to lock in the Content-Length before transmitting the request body.
-      if (request.body() instanceof OutputStreamRequestBody) {
-        OutputStreamRequestBody requestBody = (OutputStreamRequestBody) request.body();
-        request = requestBody.prepareToSendRequest(request);
-      }
-
-      Response response = chain.proceed(request);
-
-      synchronized (lock) {
-        networkResponse = response;
-        url = response.request().url().url();
-      }
-
-      return response;
-    }
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
deleted file mode 100644
index 9dc40b80a2..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.net.URL;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Handshake;
-import okhttp3.OkHttpClient;
-import okhttp3.internal.URLFilter;
-
-public final class OkHttpsURLConnection extends DelegatingHttpsURLConnection {
-  private final OkHttpURLConnection delegate;
-
-  public OkHttpsURLConnection(URL url, OkHttpClient client) {
-    this(new OkHttpURLConnection(url, client));
-  }
-
-  public OkHttpsURLConnection(URL url, OkHttpClient client, URLFilter filter) {
-    this(new OkHttpURLConnection(url, client, filter));
-  }
-
-  public OkHttpsURLConnection(OkHttpURLConnection delegate) {
-    super(delegate);
-    this.delegate = delegate;
-  }
-
-  @Override protected Handshake handshake() {
-    if (delegate.call == null) {
-      throw new IllegalStateException("Connection has not yet been established");
-    }
-
-    return delegate.handshake;
-  }
-
-  @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
-    delegate.client = delegate.client.newBuilder()
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-  }
-
-  @Override public HostnameVerifier getHostnameVerifier() {
-    return delegate.client.hostnameVerifier();
-  }
-
-  @Override public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
-    if (sslSocketFactory == null) {
-      throw new IllegalArgumentException("sslSocketFactory == null");
-    }
-    // This fails in JDK 9 because OkHttp is unable to extract the trust manager.
-    delegate.client = delegate.client.newBuilder()
-        .sslSocketFactory(sslSocketFactory)
-        .build();
-  }
-
-  @Override public SSLSocketFactory getSSLSocketFactory() {
-    return delegate.client.sslSocketFactory();
-  }
-
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java
deleted file mode 100644
index 6f4e8ef9e9..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OutputStreamRequestBody.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.io.OutputStream;
-import java.net.ProtocolException;
-import java.net.SocketTimeoutException;
-import okhttp3.MediaType;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okio.BufferedSink;
-import okio.Timeout;
-
-/**
- * A request body that's populated by blocking writes to an output stream. The output data is either
- * fully buffered (with {@link BufferedRequestBody}) or streamed (with {@link StreamedRequestBody}).
- * In either case the bytes of the body aren't known until the caller writes them to the output
- * stream.
- */
-abstract class OutputStreamRequestBody extends RequestBody {
-  private Timeout timeout;
-  private long expectedContentLength;
-  private OutputStream outputStream;
-  boolean closed;
-
-  protected void initOutputStream(final BufferedSink sink, final long expectedContentLength) {
-    this.timeout = sink.timeout();
-    this.expectedContentLength = expectedContentLength;
-
-    // An output stream that writes to sink. If expectedContentLength is not -1, then this expects
-    // exactly that many bytes to be written.
-    this.outputStream = new OutputStream() {
-      private long bytesReceived;
-
-      @Override public void write(int b) throws IOException {
-        write(new byte[] {(byte) b}, 0, 1);
-      }
-
-      @Override public void write(byte[] source, int offset, int byteCount) throws IOException {
-        if (closed) throw new IOException("closed"); // Not IllegalStateException!
-
-        if (expectedContentLength != -1L && bytesReceived + byteCount > expectedContentLength) {
-          throw new ProtocolException("expected " + expectedContentLength
-              + " bytes but received " + bytesReceived + byteCount);
-        }
-
-        bytesReceived += byteCount;
-        try {
-          sink.write(source, offset, byteCount);
-        } catch (InterruptedIOException e) {
-          throw new SocketTimeoutException(e.getMessage());
-        }
-      }
-
-      @Override public void flush() throws IOException {
-        if (closed) return; // Weird, but consistent with historical behavior.
-        sink.flush();
-      }
-
-      @Override public void close() throws IOException {
-        closed = true;
-
-        if (expectedContentLength != -1L && bytesReceived < expectedContentLength) {
-          throw new ProtocolException("expected " + expectedContentLength
-              + " bytes but received " + bytesReceived);
-        }
-
-        sink.close();
-      }
-    };
-  }
-
-  public final OutputStream outputStream() {
-    return outputStream;
-  }
-
-  public final Timeout timeout() {
-    return timeout;
-  }
-
-  public final boolean isClosed() {
-    return closed;
-  }
-
-  @Override public long contentLength() throws IOException {
-    return expectedContentLength;
-  }
-
-  @Override public final MediaType contentType() {
-    return null; // Let the caller provide this in a regular header.
-  }
-
-  public Request prepareToSendRequest(Request request) throws IOException {
-    return request;
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java
deleted file mode 100644
index 201ab09b66..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/StreamedRequestBody.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import okhttp3.internal.http.UnrepeatableRequestBody;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.Okio;
-import okio.Pipe;
-
-/**
- * This request body streams bytes from an application thread to an OkHttp dispatcher thread via a
- * pipe. Because the data is not buffered it can only be transmitted once.
- */
-final class StreamedRequestBody extends OutputStreamRequestBody implements UnrepeatableRequestBody {
-  private final Pipe pipe = new Pipe(8192);
-
-  StreamedRequestBody(long expectedContentLength) {
-    initOutputStream(Okio.buffer(pipe.sink()), expectedContentLength);
-  }
-
-  @Override public void writeTo(BufferedSink sink) throws IOException {
-    Buffer buffer = new Buffer();
-    while (pipe.source().read(buffer, 8192) != -1L) {
-      sink.write(buffer, buffer.size());
-    }
-  }
-}
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
deleted file mode 100644
index 446dfb9479..0000000000
--- a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
+++ /dev/null
@@ -1,285 +0,0 @@
-package okhttp3;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-import java.util.TimeZone;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.HttpsURLConnection;
-import okhttp3.internal.URLFilter;
-import okhttp3.internal.huc.OkHttpURLConnection;
-import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.internal.tls.SslClient;
-import okio.BufferedSource;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.nio.charset.StandardCharsets.US_ASCII;
-import static okio.Okio.buffer;
-import static okio.Okio.source;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-public class OkUrlFactoryTest {
-  @Rule public MockWebServer server = new MockWebServer();
-  @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
-
-  private OkUrlFactory factory;
-  private Cache cache;
-
-  @Before public void setUp() throws IOException {
-    cache = new Cache(new File("/cache/"), 10 * 1024 * 1024, fileSystem);
-    OkHttpClient client = new OkHttpClient.Builder()
-        .cache(cache)
-        .build();
-    factory = new OkUrlFactory(client);
-  }
-
-  @After public void tearDown() throws IOException {
-    cache.delete();
-  }
-
-  /**
-   * Response code 407 should only come from proxy servers. Android's client throws if it is sent by
-   * an origin server.
-   */
-  @Test public void originServerSends407() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(407));
-
-    HttpURLConnection conn = factory.open(server.url("/").url());
-    try {
-      conn.getResponseCode();
-      fail();
-    } catch (IOException ignored) {
-    }
-  }
-
-  @Test public void networkResponseSourceHeader() throws Exception {
-    server.enqueue(new MockResponse().setBody("Isla Sorna"));
-
-    HttpURLConnection connection = factory.open(server.url("/").url());
-    assertResponseHeader(connection, "NETWORK 200");
-    assertResponseBody(connection, "Isla Sorna");
-  }
-
-  @Test public void networkFailureResponseSourceHeader() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    HttpURLConnection connection = factory.open(server.url("/").url());
-    assertResponseHeader(connection, "NETWORK 404");
-    connection.getErrorStream().close();
-  }
-
-  @Test public void conditionalCacheHitResponseSourceHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("Isla Nublar"));
-    server.enqueue(new MockResponse().setResponseCode(304));
-
-    HttpURLConnection connection1 = factory.open(server.url("/").url());
-    assertResponseHeader(connection1, "NETWORK 200");
-    assertResponseBody(connection1, "Isla Nublar");
-
-    HttpURLConnection connection2 = factory.open(server.url("/").url());
-    assertResponseHeader(connection2, "CONDITIONAL_CACHE 304");
-    assertResponseBody(connection2, "Isla Nublar");
-  }
-
-  @Test public void conditionalCacheMissResponseSourceHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("Isla Nublar"));
-    server.enqueue(new MockResponse().setBody("Isla Sorna"));
-
-    HttpURLConnection connection1 = factory.open(server.url("/").url());
-    assertResponseHeader(connection1, "NETWORK 200");
-    assertResponseBody(connection1, "Isla Nublar");
-
-    HttpURLConnection connection2 = factory.open(server.url("/").url());
-    assertResponseHeader(connection2, "CONDITIONAL_CACHE 200");
-    assertResponseBody(connection2, "Isla Sorna");
-  }
-
-  @Test public void cacheResponseSourceHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Expires: " + formatDate(2, TimeUnit.HOURS))
-        .setBody("Isla Nublar"));
-
-    HttpURLConnection connection1 = factory.open(server.url("/").url());
-    assertResponseHeader(connection1, "NETWORK 200");
-    assertResponseBody(connection1, "Isla Nublar");
-
-    HttpURLConnection connection2 = factory.open(server.url("/").url());
-    assertResponseHeader(connection2, "CACHE 200");
-    assertResponseBody(connection2, "Isla Nublar");
-  }
-
-  @Test public void noneResponseSourceHeaders() throws Exception {
-    server.enqueue(new MockResponse().setBody("Isla Nublar"));
-
-    HttpURLConnection connection1 = factory.open(server.url("/").url());
-    assertResponseHeader(connection1, "NETWORK 200");
-    assertResponseBody(connection1, "Isla Nublar");
-
-    HttpURLConnection connection2 = factory.open(server.url("/").url());
-    connection2.setRequestProperty("Cache-Control", "only-if-cached");
-    assertResponseHeader(connection2, "NONE");
-  }
-
-  @Test
-  public void setInstanceFollowRedirectsFalse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /b")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpURLConnection connection = factory.open(server.url("/a").url());
-    connection.setInstanceFollowRedirects(false);
-    assertResponseBody(connection, "A");
-    assertResponseCode(connection, 302);
-  }
-
-  @Test
-  public void testURLFilter() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-    final URL blockedURL = server.url("/a").url();
-    factory.setUrlFilter(new URLFilter() {
-      @Override
-      public void checkURLPermitted(URL url) throws IOException {
-        if (blockedURL.equals(url)) {
-          throw new IOException("Blocked");
-        }
-      }
-    });
-    try {
-      HttpURLConnection connection = factory.open(server.url("/a").url());
-      connection.getInputStream();
-      fail("Connection was successful");
-    } catch (IOException e) {
-      assertEquals("Blocked", e.getMessage());
-    }
-    HttpURLConnection connection = factory.open(server.url("/b").url());
-    assertResponseBody(connection, "B");
-  }
-
-  @Test
-  public void testURLFilterRedirect() throws Exception {
-    MockWebServer cleartextServer = new MockWebServer();
-    cleartextServer.enqueue(new MockResponse()
-        .setBody("Blocked!"));
-    final URL blockedURL = cleartextServer.url("/").url();
-
-    SslClient contextBuilder = SslClient.localhost();
-    server.useHttps(contextBuilder.socketFactory, false);
-    factory.setClient(factory.client().newBuilder()
-        .sslSocketFactory(contextBuilder.socketFactory, contextBuilder.trustManager)
-        .followSslRedirects(true)
-        .build());
-    factory.setUrlFilter(new URLFilter() {
-      @Override
-      public void checkURLPermitted(URL url) throws IOException {
-        if (blockedURL.equals(url)) {
-          throw new IOException("Blocked");
-        }
-      }
-    });
-
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: " + blockedURL)
-        .setBody("This page has moved"));
-    URL destination = server.url("/").url();
-    try {
-      HttpsURLConnection httpsConnection = (HttpsURLConnection) factory.open(destination);
-      httpsConnection.getInputStream();
-      fail("Connection was successful");
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void usesValidHeaderValueForDefaultUserAgent() throws Exception {
-    String userAgent =  "üç© " + "\u001F" + ('\u001f' + 1) + ('\u007f' - 1)+ '\u007f' + " üç©";
-    String expected = "? ?" + ('\u001f' + 1) + ('\u007f' - 1) + "? ?";
-
-    System.setProperty("http.agent", userAgent);
-    server.enqueue(new MockResponse().setResponseCode(200));
-    InputStream inputStream = factory.open(server.url("/").url()).getInputStream();
-    long skipped;
-    do {
-      skipped = inputStream.skip(Long.MAX_VALUE);
-    } while (skipped != 0);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(expected, recordedRequest.getHeader("User-Agent"));
-  }
-
-  @Test public void usesSimpleDefaultUserAgentWithoutModification() throws Exception {
-    String userAgent = "OkHttp";
-    String expected = "OkHttp";
-
-    System.setProperty("http.agent", userAgent);
-    server.enqueue(new MockResponse().setResponseCode(200));
-    InputStream inputStream = factory.open(server.url("/").url()).getInputStream();
-    long skipped;
-    do {
-      skipped = inputStream.skip(Long.MAX_VALUE);
-    } while (skipped != 0);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(expected, recordedRequest.getHeader("User-Agent"));
-  }
-
-  @Test public void handlesBadUnicodeStringsInDefaultUserAgent() throws Exception {
-    String userAgent =  "üîä".substring(0, 1);
-    String expected = "?";
-
-    System.setProperty("http.agent", userAgent);
-    server.enqueue(new MockResponse().setResponseCode(200));
-    InputStream inputStream = factory.open(server.url("/").url()).getInputStream();
-    long skipped;
-    do {
-      skipped = inputStream.skip(Long.MAX_VALUE);
-    } while (skipped != 0);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(expected, recordedRequest.getHeader("User-Agent"));
-  }
-
-  private void assertResponseBody(HttpURLConnection connection, String expected) throws Exception {
-    BufferedSource source = buffer(source(connection.getInputStream()));
-    String actual = source.readString(US_ASCII);
-    source.close();
-    assertEquals(expected, actual);
-  }
-
-  private void assertResponseHeader(HttpURLConnection connection, String expected) {
-    assertEquals(expected, connection.getHeaderField(OkHttpURLConnection.RESPONSE_SOURCE));
-  }
-
-  private void assertResponseCode(HttpURLConnection connection, int expected) throws IOException {
-    assertEquals(expected, connection.getResponseCode());
-  }
-
-  private static String formatDate(long delta, TimeUnit timeUnit) {
-    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private static String formatDate(Date date) {
-    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
-    return rfc1123.format(date);
-  }
-}
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
deleted file mode 100644
index 104d719ddf..0000000000
--- a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
+++ /dev/null
@@ -1,1849 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.net.CookieManager;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.net.URL;
-import java.net.URLConnection;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import java.util.TimeZone;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLSession;
-import okhttp3.internal.Internal;
-import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.internal.platform.Platform;
-import okhttp3.mockwebserver.internal.tls.SslClient;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeFalse;
-
-/** Test caching with {@link OkUrlFactory}. */
-public final class UrlConnectionCacheTest {
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    @Override public boolean verify(String s, SSLSession sslSession) {
-      return true;
-    }
-  };
-
-  @Rule public MockWebServer server = new MockWebServer();
-  @Rule public MockWebServer server2 = new MockWebServer();
-  @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
-
-  private final SslClient sslClient = SslClient.localhost();
-  private OkUrlFactory urlFactory = new OkUrlFactory(new OkHttpClient());
-  private Cache cache;
-  private final CookieManager cookieManager = new CookieManager();
-
-  @Before public void setUp() throws Exception {
-    server.setProtocolNegotiationEnabled(false);
-    cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-    urlFactory = new OkUrlFactory(new OkHttpClient.Builder()
-        .cache(cache)
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build());
-  }
-
-  @After public void tearDown() throws Exception {
-    ResponseCache.setDefault(null);
-    cache.delete();
-  }
-
-  @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
-    assertSame(cache, urlFactory.client().cache());
-  }
-
-  /**
-   * Test that response caching is consistent with the RI and the spec.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
-   */
-  @Test public void responseCachingByResponseCode() throws Exception {
-    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
-    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
-
-    // We can't test 100 because it's not really a response.
-    // assertCached(false, 100);
-    assertCached(false, 101);
-    assertCached(false, 102);
-    assertCached(true, 200);
-    assertCached(false, 201);
-    assertCached(false, 202);
-    assertCached(true, 203);
-    assertCached(true, 204);
-    assertCached(false, 205);
-    assertCached(false, 206); //Electing to not cache partial responses
-    assertCached(false, 207);
-    assertCached(true, 300);
-    assertCached(true, 301);
-    assertCached(true, 302);
-    assertCached(false, 303);
-    assertCached(false, 304);
-    assertCached(false, 305);
-    assertCached(false, 306);
-    assertCached(true, 307);
-    assertCached(true, 308);
-    assertCached(false, 400);
-    assertCached(false, 401);
-    assertCached(false, 402);
-    assertCached(false, 403);
-    assertCached(true, 404);
-    assertCached(true, 405);
-    assertCached(false, 406);
-    assertCached(false, 408);
-    assertCached(false, 409);
-    // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true, 410);
-    assertCached(false, 411);
-    assertCached(false, 412);
-    assertCached(false, 413);
-    assertCached(true, 414);
-    assertCached(false, 415);
-    assertCached(false, 416);
-    assertCached(false, 417);
-    assertCached(false, 418);
-
-    assertCached(false, 500);
-    assertCached(true, 501);
-    assertCached(false, 502);
-    assertCached(false, 503);
-    assertCached(false, 504);
-    assertCached(false, 505);
-    assertCached(false, 506);
-  }
-
-  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
-    int expectedResponseCode = responseCode;
-
-    server = new MockWebServer();
-    MockResponse response = new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(responseCode)
-        .setBody("ABCDE")
-        .addHeader("WWW-Authenticate: challenge");
-    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
-      response.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
-      response.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
-        || responseCode == HttpURLConnection.HTTP_RESET) {
-      response.setBody(""); // We forbid bodies for 204 and 205.
-    }
-    server.enqueue(response);
-
-    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
-      // 408's are a bit of an outlier because we may repeat the request if we encounter this
-      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
-      // because of the retry. We just want to ensure the initial 408 isn't cached.
-      expectedResponseCode = 200;
-      server.enqueue(new MockResponse()
-          .addHeader("Cache-Control", "no-store")
-          .setBody("FGHIJ"));
-    }
-
-    server.start();
-
-    URL url = server.url("/").url();
-    HttpURLConnection conn = urlFactory.open(url);
-    assertEquals(expectedResponseCode, conn.getResponseCode());
-
-    // exhaust the content stream
-    readAscii(conn);
-
-    Response cached = cache.get(new Request.Builder().url(url).build());
-    if (shouldPut) {
-      assertNotNull(Integer.toString(responseCode), cached);
-      cached.body().close();
-    } else {
-      assertNull(Integer.toString(responseCode), cached);
-    }
-    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
-    testResponseCaching(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
-    testResponseCaching(TransferKind.CHUNKED);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
-    testResponseCaching(TransferKind.END_OF_STREAM);
-  }
-
-  /**
-   * HttpURLConnection.getInputStream().skip(long) causes ResponseCache corruption
-   * http://code.google.com/p/android/issues/detail?id=8175
-   */
-  private void testResponseCaching(TransferKind transferKind) throws IOException {
-    MockResponse response =
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .setStatus("HTTP/1.1 200 Fantastic");
-    transferKind.setBody(response, "I love puppies but hate spiders", 1);
-    server.enqueue(response);
-
-    // Make sure that calling skip() doesn't omit bytes from the cache.
-    HttpURLConnection urlConnection = urlFactory.open(server.url("/").url());
-    InputStream in = urlConnection.getInputStream();
-    assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
-    reliableSkip(in, "puppies but hate ".length());
-    assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
-    assertEquals(-1, in.read());
-    in.close();
-    assertEquals(1, cache.writeSuccessCount());
-    assertEquals(0, cache.writeAbortCount());
-
-    urlConnection = urlFactory.open(server.url("/").url()); // cached!
-    in = urlConnection.getInputStream();
-    assertEquals("I love puppies but hate spiders",
-        readAscii(urlConnection, "I love puppies but hate spiders".length()));
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-
-    assertEquals(-1, in.read());
-    in.close();
-    assertEquals(1, cache.writeSuccessCount());
-    assertEquals(0, cache.writeAbortCount());
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.hitCount());
-  }
-
-  @Test public void secureResponseCaching() throws IOException {
-    assumeFalse(getPlatform().equals("jdk9"));
-
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-
-    HttpsURLConnection c1 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
-    c1.setSSLSocketFactory(sslClient.socketFactory);
-    c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(c1));
-
-    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    String suite = c1.getCipherSuite();
-    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
-    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
-    Principal peerPrincipal = c1.getPeerPrincipal();
-    Principal localPrincipal = c1.getLocalPrincipal();
-
-    HttpsURLConnection c2 = (HttpsURLConnection) urlFactory.open(server.url("/").url()); // cached!
-    c2.setSSLSocketFactory(sslClient.socketFactory);
-    c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(c2));
-
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(1, cache.hitCount());
-
-    assertEquals(suite, c2.getCipherSuite());
-    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
-    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
-    assertEquals(peerPrincipal, c2.getPeerPrincipal());
-    assertEquals(localPrincipal, c2.getLocalPrincipal());
-  }
-
-  @Test public void responseCachingAndRedirects() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("ABC", readAscii(connection));
-
-    connection = urlFactory.open(server.url("/").url()); // cached!
-    assertEquals("ABC", readAscii(connection));
-
-    assertEquals(4, cache.requestCount()); // 2 requests + 2 redirects
-    assertEquals(2, cache.networkCount());
-    assertEquals(2, cache.hitCount());
-  }
-
-  @Test public void redirectToCachedResult() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("ABC"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-
-    assertEquals("ABC", readAscii(urlFactory.open(server.url("/foo").url())));
-    RecordedRequest request1 = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
-    assertEquals(0, request1.getSequenceNumber());
-
-    assertEquals("ABC", readAscii(urlFactory.open(server.url("/bar").url())));
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
-    assertEquals(1, request2.getSequenceNumber());
-
-    // an unrelated request should reuse the pooled connection
-    assertEquals("DEF", readAscii(urlFactory.open(server.url("/baz").url())));
-    RecordedRequest request3 = server.takeRequest();
-    assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
-    assertEquals(2, request3.getSequenceNumber());
-  }
-
-  @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
-        .build());
-
-    HttpsURLConnection connection1 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
-    assertEquals("ABC", readAscii(connection1));
-    assertNotNull(connection1.getCipherSuite());
-
-    // Cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
-    assertEquals("ABC", readAscii(connection2));
-    assertNotNull(connection2.getCipherSuite());
-
-    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.hitCount());
-    assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
-  }
-
-  /**
-   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
-   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
-   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
-   *
-   * https://github.com/square/okhttp/issues/214
-   */
-  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslClient.socketFactory, false);
-    server2.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server2.enqueue(new MockResponse().setBody("DEF"));
-
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: " + server2.url("/").url()));
-
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
-        .build());
-
-    HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
-    assertEquals("ABC", readAscii(connection1));
-
-    // Cached!
-    HttpURLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertEquals("ABC", readAscii(connection2));
-
-    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.hitCount());
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
-    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
-    testServerPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
-    // Intentionally empty. This case doesn't make sense because there's no
-    // such thing as a premature disconnect when the disconnect itself
-    // indicates the end of the data stream.
-  }
-
-  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
-    server.enqueue(truncateViolently(response, 16));
-    server.enqueue(new MockResponse().setBody("Request #2"));
-
-    BufferedReader reader = new BufferedReader(
-        new InputStreamReader(urlFactory.open(server.url("/").url()).getInputStream()));
-    assertEquals("ABCDE", reader.readLine());
-    try {
-      reader.readLine();
-      fail("This implementation silently ignored a truncated HTTP body.");
-    } catch (IOException expected) {
-    } finally {
-      reader.close();
-    }
-
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(0, cache.writeSuccessCount());
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("Request #2", readAscii(connection));
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(1, cache.writeSuccessCount());
-  }
-
-  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
-    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
-    testClientPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
-    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
-  }
-
-  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
-    // Setting a low transfer speed ensures that stream discarding will time out.
-    MockResponse response = new MockResponse().throttleBody(6, 1, TimeUnit.SECONDS);
-    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(response);
-    server.enqueue(new MockResponse().setBody("Request #2"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    InputStream in = connection.getInputStream();
-    assertEquals("ABCDE", readAscii(connection, 5));
-    in.close();
-    try {
-      in.read();
-      fail("Expected an IOException because the stream is closed.");
-    } catch (IOException expected) {
-    }
-
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(0, cache.writeSuccessCount());
-    connection = urlFactory.open(server.url("/").url());
-    assertEquals("Request #2", readAscii(connection));
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(1, cache.writeSuccessCount());
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
-    //      last modified: 105 seconds ago
-    //             served:   5 seconds ago
-    //   default lifetime: (105 - 5) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds from now
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-            .setBody("A"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    URLConnection connection = urlFactory.open(url);
-    assertEquals("A", readAscii(connection));
-    assertNull(connection.getHeaderField("Warning"));
-  }
-
-  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
-    //      last modified: 115 seconds ago
-    //             served:  15 seconds ago
-    //   default lifetime: (115 - 15) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds ago
-    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
-    //      last modified: 105 days ago
-    //             served:   5 days ago
-    //   default lifetime: (105 - 5) / 10 = 10 days
-    //            expires:  10 days from served date = 5 days from now
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
-        .setBody("A"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection));
-    assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
-        connection.getHeaderField("Warning"));
-  }
-
-  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/?foo=bar").url();
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    assertEquals("B", readAscii(urlFactory.open(url)));
-  }
-
-  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void expirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Cache-Control: max-age=60"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
-    // Chrome interprets max-age relative to the local clock. Both our cache
-    // and Firefox both use the earlier of the local and server's clock.
-    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
-    assertFullyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
-    assertFullyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=60")
-        .addHeader("Cache-Control: max-age=180"));
-  }
-
-  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=180")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void requestMethodOptionsIsNotCached() throws Exception {
-    testRequestMethod("OPTIONS", false);
-  }
-
-  @Test public void requestMethodGetIsCached() throws Exception {
-    testRequestMethod("GET", true);
-  }
-
-  @Test public void requestMethodHeadIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("HEAD", false);
-  }
-
-  @Test public void requestMethodPostIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("POST", false);
-  }
-
-  @Test public void requestMethodPutIsNotCached() throws Exception {
-    testRequestMethod("PUT", false);
-  }
-
-  @Test public void requestMethodDeleteIsNotCached() throws Exception {
-    testRequestMethod("DELETE", false);
-  }
-
-  @Test public void requestMethodTraceIsNotCached() throws Exception {
-    testRequestMethod("TRACE", false);
-  }
-
-  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
-    // 1. seed the cache (potentially)
-    // 2. expect a cache hit or miss
-    server.enqueue(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("X-Response-ID: 1"));
-    server.enqueue(new MockResponse().addHeader("X-Response-ID: 2"));
-
-    URL url = server.url("/").url();
-
-    HttpURLConnection request1 = urlFactory.open(url);
-    request1.setRequestMethod(requestMethod);
-    addRequestBodyIfNecessary(requestMethod, request1);
-    request1.getInputStream().close();
-    assertEquals("1", request1.getHeaderField("X-Response-ID"));
-
-    URLConnection request2 = urlFactory.open(url);
-    request2.getInputStream().close();
-    if (expectCached) {
-      assertEquals("1", request2.getHeaderField("X-Response-ID"));
-    } else {
-      assertEquals("2", request2.getHeaderField("X-Response-ID"));
-    }
-  }
-
-  @Test public void postInvalidatesCache() throws Exception {
-    testMethodInvalidates("POST");
-  }
-
-  @Test public void putInvalidatesCache() throws Exception {
-    testMethodInvalidates("PUT");
-  }
-
-  @Test public void deleteMethodInvalidatesCache() throws Exception {
-    testMethodInvalidates("DELETE");
-  }
-
-  private void testMethodInvalidates(String requestMethod) throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it
-    // 3. expect a cache miss
-    server.enqueue(
-        new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    URL url = server.url("/").url();
-
-    assertEquals("A", readAscii(urlFactory.open(url)));
-
-    HttpURLConnection invalidate = urlFactory.open(url);
-    invalidate.setRequestMethod(requestMethod);
-    addRequestBodyIfNecessary(requestMethod, invalidate);
-    assertEquals("B", readAscii(invalidate));
-
-    assertEquals("C", readAscii(urlFactory.open(url)));
-  }
-
-  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it with uncacheable response
-    // 3. expect a cache miss
-    server.enqueue(
-        new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B").setResponseCode(500));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    URL url = server.url("/").url();
-
-    assertEquals("A", readAscii(urlFactory.open(url)));
-
-    HttpURLConnection invalidate = urlFactory.open(url);
-    invalidate.setRequestMethod("POST");
-    addRequestBodyIfNecessary("POST", invalidate);
-    assertEquals("B", readAscii(invalidate));
-
-    assertEquals("C", readAscii(urlFactory.open(url)));
-  }
-
-  @Test public void etag() throws Exception {
-    RecordedRequest conditionalRequest =
-        assertConditionallyCached(new MockResponse().addHeader("ETag: v1"));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-  }
-
-  @Test public void etagAndExpirationDateInThePast() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("ETag: v1")
-            .addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse().addHeader("ETag: v1")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void cacheControlNoCache() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Cache-Control: no-cache"));
-  }
-
-  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .addHeader("Cache-Control: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void pragmaNoCache() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Pragma: no-cache"));
-  }
-
-  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-            .addHeader("Pragma: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void cacheControlNoStore() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
-    assertNotCached(new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
-    // 1. request a range
-    // 2. request a full document, expecting a cache miss
-    server.enqueue(new MockResponse().setBody("AA")
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 1000-1001/2000"));
-    server.enqueue(new MockResponse().setBody("BB"));
-
-    URL url = server.url("/").url();
-
-    URLConnection range = urlFactory.open(url);
-    range.addRequestProperty("Range", "bytes=1000-1001");
-    assertEquals("AA", readAscii(range));
-
-    assertEquals("BB", readAscii(urlFactory.open(url)));
-  }
-
-  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B")
-        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
-
-    URL url = server.url("/").url();
-
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    assertEquals("B", readAscii(urlFactory.open(url)));
-  }
-
-  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
-    assertNonIdentityEncodingCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
-    assertNonIdentityEncodingCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
-    server.enqueue(
-        response.setBody(gzip("ABCABCABC")).addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // At least three request/response pairs are required because after the first request is cached
-    // a different execution path might be taken. Thus modifications to the cache applied during
-    // the second request might not be visible until another request is performed.
-    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
-  }
-
-  @Test public void notModifiedSpecifiesEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setBody("DEFDEFDEF"));
-
-    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("DEFDEFDEF", readAscii(urlFactory.open(server.url("/").url())));
-  }
-
-  /** https://github.com/square/okhttp/issues/947 */
-  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Vary: Accept-Encoding")
-        .addHeader("Cache-Control: max-age=60"));
-    server.enqueue(new MockResponse().setBody("FAIL"));
-
-    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("ABCABCABC", readAscii(urlFactory.open(server.url("/").url())));
-  }
-
-  @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
-    server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(1, urlFactory.client().connectionPool().idleConnectionCount());
-  }
-
-  @Test public void expiresDateBeforeModifiedDate() throws Exception {
-    assertConditionallyCached(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
-  }
-
-  @Test public void requestMaxAge() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "max-age=30");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestMinFresh() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "min-fresh=120");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestMaxStale() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "max-stale=180");
-    assertEquals("A", readAscii(connection));
-    assertEquals("110 HttpURLConnection \"Response is stale\"",
-        connection.getHeaderField("Warning"));
-  }
-
-  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=120, must-revalidate")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "max-stale=180");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
-    // (no responses enqueued)
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-    assertEquals(1, cache.requestCount());
-    assertEquals(0, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-  }
-
-  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertEquals("A", readAscii(connection));
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(1, cache.hitCount());
-  }
-
-  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-  }
-
-  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertGatewayTimeout(connection);
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-  }
-
-  @Test public void requestCacheControlNoCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60")
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    URLConnection connection = urlFactory.open(url);
-    connection.setRequestProperty("Cache-Control", "no-cache");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void requestPragmaNoCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-            .addHeader("Cache-Control: max-age=60")
-            .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    URLConnection connection = urlFactory.open(url);
-    connection.setRequestProperty("Pragma", "no-cache");
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
-    MockResponse response =
-        new MockResponse().addHeader("ETag: v3").addHeader("Cache-Control: max-age=0");
-    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
-    RecordedRequest request =
-        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
-    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
-    assertNull(request.getHeader("If-None-Match"));
-  }
-
-  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
-    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
-    MockResponse response = new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: max-age=0");
-    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
-    assertEquals("v1", request.getHeader("If-None-Match"));
-    assertNull(request.getHeader("If-Modified-Since"));
-  }
-
-  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
-      String conditionValue) throws Exception {
-    server.enqueue(seed.setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(urlFactory.open(url)));
-
-    HttpURLConnection connection = urlFactory.open(url);
-    connection.addRequestProperty(conditionName, conditionValue);
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
-    assertEquals("", readAscii(connection));
-
-    server.takeRequest(); // seed
-    return server.takeRequest();
-  }
-
-  /**
-   * Confirm that {@link URLConnection#setIfModifiedSince} causes an If-Modified-Since header with a
-   * GMT timestamp.
-   *
-   * https://code.google.com/p/android/issues/detail?id=66135
-   */
-  @Test public void setIfModifiedSince() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    URL url = server.url("/").url();
-    URLConnection connection = urlFactory.open(url);
-    connection.setIfModifiedSince(1393666200000L);
-    assertEquals("A", readAscii(connection));
-    RecordedRequest request = server.takeRequest();
-    String ifModifiedSinceHeader = request.getHeader("If-Modified-Since");
-    assertEquals("Sat, 01 Mar 2014 09:30:00 GMT", ifModifiedSinceHeader);
-  }
-
-  /**
-   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
-   * served.
-   */
-  @Test public void retainServedDateFormat() throws Exception {
-    // Serve a response with a non-standard date format that OkHttp supports.
-    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
-    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
-    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
-    String lastModifiedString = dateFormat.format(lastModifiedDate);
-    String servedString = dateFormat.format(servedDate);
-
-    // This response should be conditionally cached.
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedString)
-        .addHeader("Expires: " + servedString)
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-
-    // The first request has no conditions.
-    RecordedRequest request1 = server.takeRequest();
-    assertNull(request1.getHeader("If-Modified-Since"));
-
-    // The 2nd request uses the server's date format.
-    RecordedRequest request2 = server.takeRequest();
-    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
-  }
-
-  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
-    connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
-    assertEquals("", readAscii(connection));
-  }
-
-  @Test public void authorizationRequestFullyCached() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection connection = urlFactory.open(url);
-    connection.addRequestProperty("Authorization", "password");
-    assertEquals("A", readAscii(connection));
-    assertEquals("A", readAscii(urlFactory.open(url)));
-  }
-
-  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Content-Location: /bar")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/foo").url())));
-    assertEquals("B", readAscii(urlFactory.open(server.url("/bar").url())));
-  }
-
-  @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setUseCaches(false);
-    assertEquals("A", readAscii(connection));
-    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
-  }
-
-  @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
-    server.enqueue(
-        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.setUseCaches(false);
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
-    URL url = new URL("http://localhost/");
-    URLConnection c1 = urlFactory.open(url);
-    URLConnection c2 = urlFactory.open(url);
-    assertTrue(c1.getDefaultUseCaches());
-    c1.setDefaultUseCaches(false);
-    try {
-      assertTrue(c1.getUseCaches());
-      assertTrue(c2.getUseCaches());
-      URLConnection c3 = urlFactory.open(url);
-      assertFalse(c3.getUseCaches());
-    } finally {
-      c1.setDefaultUseCaches(true);
-    }
-  }
-
-  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/a").url())));
-    assertEquals("A", readAscii(urlFactory.open(server.url("/a").url())));
-    assertEquals("B", readAscii(urlFactory.open(server.url("/b").url())));
-
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
-  }
-
-  @Test public void statisticsConditionalCacheMiss() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("C", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(3, cache.requestCount());
-    assertEquals(3, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-  }
-
-  @Test public void statisticsConditionalCacheHit() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(3, cache.requestCount());
-    assertEquals(3, cache.networkCount());
-    assertEquals(2, cache.hitCount());
-  }
-
-  @Test public void statisticsFullCacheHit() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals(3, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(2, cache.hitCount());
-  }
-
-  @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpURLConnection frConnection = urlFactory.open(url);
-    frConnection.addRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(frConnection));
-
-    HttpURLConnection enConnection = urlFactory.open(url);
-    enConnection.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("B", readAscii(enConnection));
-  }
-
-  @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection connection1 = urlFactory.open(url);
-    connection1.addRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = urlFactory.open(url);
-    connection2.addRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-  }
-
-  @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    URLConnection fooConnection = urlFactory.open(server.url("/").url());
-    fooConnection.addRequestProperty("Foo", "bar");
-    assertEquals("B", readAscii(fooConnection));
-  }
-
-  @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URLConnection fooConnection = urlFactory.open(server.url("/").url());
-    fooConnection.addRequestProperty("Foo", "bar");
-    assertEquals("A", readAscii(fooConnection));
-    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
-  }
-
-  @Test public void varyFieldsAreCaseInsensitive() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: ACCEPT-LANGUAGE")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection connection1 = urlFactory.open(url);
-    connection1.addRequestProperty("Accept-Language", "fr-CA");
-    assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = urlFactory.open(url);
-    connection2.addRequestProperty("accept-language", "fr-CA");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void varyMultipleFieldsWithMatch() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection connection1 = urlFactory.open(url);
-    connection1.addRequestProperty("Accept-Language", "fr-CA");
-    connection1.addRequestProperty("Accept-Charset", "UTF-8");
-    connection1.addRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(connection1));
-    URLConnection connection2 = urlFactory.open(url);
-    connection2.addRequestProperty("Accept-Language", "fr-CA");
-    connection2.addRequestProperty("Accept-Charset", "UTF-8");
-    connection2.addRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection frConnection = urlFactory.open(url);
-    frConnection.addRequestProperty("Accept-Language", "fr-CA");
-    frConnection.addRequestProperty("Accept-Charset", "UTF-8");
-    frConnection.addRequestProperty("Accept-Encoding", "identity");
-    assertEquals("A", readAscii(frConnection));
-    URLConnection enConnection = urlFactory.open(url);
-    enConnection.addRequestProperty("Accept-Language", "en-CA");
-    enConnection.addRequestProperty("Accept-Charset", "UTF-8");
-    enConnection.addRequestProperty("Accept-Encoding", "identity");
-    assertEquals("B", readAscii(enConnection));
-  }
-
-  @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection connection1 = urlFactory.open(url);
-    connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    connection1.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection1));
-
-    URLConnection connection2 = urlFactory.open(url);
-    connection2.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    connection2.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    URLConnection connection1 = urlFactory.open(url);
-    connection1.addRequestProperty("Accept-Language", "fr-CA, fr-FR");
-    connection1.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection1));
-
-    URLConnection connection2 = urlFactory.open(url);
-    connection2.addRequestProperty("Accept-Language", "fr-CA");
-    connection2.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("B", readAscii(connection2));
-  }
-
-  @Test public void varyAsterisk() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: *")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    assertEquals("B", readAscii(urlFactory.open(server.url("/").url())));
-  }
-
-  @Test public void varyAndHttps() throws Exception {
-    assumeFalse(getPlatform().equals("jdk9"));
-
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    HttpsURLConnection connection1 = (HttpsURLConnection) urlFactory.open(url);
-    connection1.setSSLSocketFactory(sslClient.socketFactory);
-    connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    connection1.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection1));
-
-    HttpsURLConnection connection2 = (HttpsURLConnection) urlFactory.open(url);
-    connection2.setSSLSocketFactory(sslClient.socketFactory);
-    connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    connection2.addRequestProperty("Accept-Language", "en-US");
-    assertEquals("A", readAscii(connection2));
-  }
-
-  @Test public void cachePlusCookies() throws Exception {
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .cookieJar(cookieJar)
-        .build());
-
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=FIRST")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=SECOND")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    cookieJar.assertResponseCookies("a=FIRST; path=/");
-
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    cookieJar.assertResponseCookies("a=SECOND; path=/");
-  }
-
-  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD, PUT")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
-
-    URLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
-  }
-
-  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: identity")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: none")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
-
-    URLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
-  }
-
-  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Warning: 199 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("199 test danger", connection1.getHeaderField("Warning"));
-
-    URLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals(null, connection2.getHeaderField("Warning"));
-  }
-
-  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Warning: 299 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URLConnection connection1 = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals("299 test danger", connection1.getHeaderField("Warning"));
-
-    URLConnection connection2 = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("299 test danger", connection2.getHeaderField("Warning"));
-  }
-
-  @Test public void cachePlusRange() throws Exception {
-    assertNotCached(new MockResponse().setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 100-100/200")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void conditionalHitUpdatesCache() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=30")
-        .addHeader("Allow: GET, HEAD")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    // cache miss; seed the cache
-    HttpURLConnection connection1 = urlFactory.open(server.url("/a").url());
-    assertEquals("A", readAscii(connection1));
-    assertEquals(null, connection1.getHeaderField("Allow"));
-
-    // conditional cache hit; update the cache
-    HttpURLConnection connection2 = urlFactory.open(server.url("/a").url());
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertEquals("A", readAscii(connection2));
-    assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
-
-    // full cache hit
-    HttpURLConnection connection3 = urlFactory.open(server.url("/a").url());
-    assertEquals("A", readAscii(connection3));
-    assertEquals("GET, HEAD", connection3.getHeaderField("Allow"));
-
-    assertEquals(2, server.getRequestCount());
-  }
-
-  @Test public void responseSourceHeaderCached() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    connection.addRequestProperty("Cache-Control", "only-if-cached");
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setBody("B")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("B", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
-    server.enqueue(new MockResponse().setBody("A")
-        .addHeader("Cache-Control: max-age=0")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse().setResponseCode(304));
-
-    assertEquals("A", readAscii(urlFactory.open(server.url("/").url())));
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void responseSourceHeaderFetched() throws IOException {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    URLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", readAscii(connection));
-  }
-
-  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
-    Headers.Builder headers = new Headers.Builder()
-        .add("Cache-Control: max-age=120");
-    Internal.instance.addLenient(headers, ": A");
-    server.enqueue(new MockResponse().setHeaders(headers.build()).setBody("body"));
-
-    HttpURLConnection connection = urlFactory.open(server.url("/").url());
-    assertEquals("A", connection.getHeaderField(""));
-    assertEquals("body", readAscii(connection));
-  }
-
-  /**
-   * Old implementations of OkHttp's response cache wrote header fields like ":status: 200 OK". This
-   * broke our cached response parser because it split on the first colon. This regression test
-   * exists to help us read these old bad cache entries.
-   *
-   * https://github.com/square/okhttp/issues/227
-   */
-  @Test public void testGoldenCacheResponse() throws Exception {
-    cache.close();
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    URL url = server.url("/").url();
-    String urlKey = Cache.key(HttpUrl.get(url));
-    String prefix = Platform.get().getPrefix();
-    String entryMetadata = ""
-        + "" + url + "\n"
-        + "GET\n"
-        + "0\n"
-        + "HTTP/1.1 200 OK\n"
-        + "7\n"
-        + ":status: 200 OK\n"
-        + ":version: HTTP/1.1\n"
-        + "etag: foo\n"
-        + "content-length: 3\n"
-        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + "X-Android-Response-Source: NETWORK 200\n"
-        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
-        + "\n"
-        + "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n"
-        + "1\n"
-        + "MIIBpDCCAQ2gAwIBAgIBATANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDEw1qd2lsc29uLmxvY2FsMB4XDTEzMDgy"
-        + "OTA1MDE1OVoXDTEzMDgzMDA1MDE1OVowGDEWMBQGA1UEAxMNandpbHNvbi5sb2NhbDCBnzANBgkqhkiG9w0BAQEF"
-        + "AAOBjQAwgYkCgYEAlFW+rGo/YikCcRghOyKkJanmVmJSce/p2/jH1QvNIFKizZdh8AKNwojt3ywRWaDULA/RlCUc"
-        + "ltF3HGNsCyjQI/+Lf40x7JpxXF8oim1E6EtDoYtGWAseelawus3IQ13nmo6nWzfyCA55KhAWf4VipelEy8DjcuFK"
-        + "v6L0xwXnI0ECAwEAATANBgkqhkiG9w0BAQsFAAOBgQAuluNyPo1HksU3+Mr/PyRQIQS4BI7pRXN8mcejXmqyscdP"
-        + "7S6J21FBFeRR8/XNjVOp4HT9uSc2hrRtTEHEZCmpyoxixbnM706ikTmC7SN/GgM+SmcoJ1ipJcNcl8N0X6zym4dm"
-        + "yFfXKHu2PkTo7QFdpOJFvP3lIigcSZXozfmEDg==\n"
-        + "-1\n";
-    String entryBody = "abc";
-    String journalBody = ""
-        + "libcore.io.DiskLruCache\n"
-        + "1\n"
-        + "201105\n"
-        + "2\n"
-        + "\n"
-        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.directory(), urlKey + ".1", entryBody);
-    writeFile(cache.directory(), "journal", journalBody);
-    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
-    urlFactory.setClient(urlFactory.client().newBuilder()
-        .cache(cache)
-        .build());
-
-    HttpURLConnection connection = urlFactory.open(url);
-    assertEquals(entryBody, readAscii(connection));
-    assertEquals("3", connection.getHeaderField("Content-Length"));
-    assertEquals("foo", connection.getHeaderField("etag"));
-  }
-
-  private void writeFile(File directory, String file, String content) throws IOException {
-    BufferedSink sink = Okio.buffer(fileSystem.sink(new File(directory, file)));
-    sink.writeUtf8(content);
-    sink.close();
-  }
-
-  /**
-   * @param delta the offset from the current date to use. Negative values yield dates in the past;
-   * positive values yield dates in the future.
-   */
-  private String formatDate(long delta, TimeUnit timeUnit) {
-    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private String formatDate(Date date) {
-    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
-    return rfc1123.format(date);
-  }
-
-  private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection invalidate)
-      throws IOException {
-    if (requestMethod.equals("POST") || requestMethod.equals("PUT")) {
-      invalidate.setDoOutput(true);
-      OutputStream requestBody = invalidate.getOutputStream();
-      requestBody.write('x');
-      requestBody.close();
-    }
-  }
-
-  private void assertNotCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    assertEquals("B", readAscii(urlFactory.open(url)));
-  }
-
-  /** @return the request with the conditional get headers. */
-  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
-    // scenario 1: condition succeeds
-    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // scenario 2: condition fails
-    server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
-
-    URL valid = server.url("/valid").url();
-    HttpURLConnection connection1 = urlFactory.open(valid);
-    assertEquals("A", readAscii(connection1));
-    assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
-    assertEquals("A-OK", connection1.getResponseMessage());
-    HttpURLConnection connection2 = urlFactory.open(valid);
-    assertEquals("A", readAscii(connection2));
-    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
-    assertEquals("A-OK", connection2.getResponseMessage());
-
-    URL invalid = server.url("/invalid").url();
-    HttpURLConnection connection3 = urlFactory.open(invalid);
-    assertEquals("B", readAscii(connection3));
-    assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
-    assertEquals("B-OK", connection3.getResponseMessage());
-    HttpURLConnection connection4 = urlFactory.open(invalid);
-    assertEquals("C", readAscii(connection4));
-    assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
-    assertEquals("C-OK", connection4.getResponseMessage());
-
-    server.takeRequest(); // regular get
-    return server.takeRequest(); // conditional get
-  }
-
-  private void assertFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(response.setBody("B"));
-
-    URL url = server.url("/").url();
-    assertEquals("A", readAscii(urlFactory.open(url)));
-    assertEquals("A", readAscii(urlFactory.open(url)));
-  }
-
-  /**
-   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
-   * how clients respond to the premature conclusion of the HTTP body.
-   */
-  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
-    response.setSocketPolicy(DISCONNECT_AT_END);
-    Headers headers = response.getHeaders();
-    Buffer truncatedBody = new Buffer();
-    truncatedBody.write(response.getBody(), numBytesToKeep);
-    response.setBody(truncatedBody);
-    response.setHeaders(headers);
-    return response;
-  }
-
-  /**
-   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
-   * characters can be read, the remaining characters are returned and the stream is closed.
-   */
-  private String readAscii(URLConnection connection, int count) throws IOException {
-    HttpURLConnection httpConnection = (HttpURLConnection) connection;
-    InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
-        ? connection.getInputStream()
-        : httpConnection.getErrorStream();
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  private String readAscii(URLConnection connection) throws IOException {
-    return readAscii(connection, Integer.MAX_VALUE);
-  }
-
-  private void reliableSkip(InputStream in, int length) throws IOException {
-    while (length > 0) {
-      length -= in.skip(length);
-    }
-  }
-
-  private void assertGatewayTimeout(HttpURLConnection connection) throws IOException {
-    try {
-      connection.getInputStream();
-      fail();
-    } catch (FileNotFoundException expected) {
-    }
-    assertEquals(504, connection.getResponseCode());
-    assertEquals(-1, connection.getErrorStream().read());
-  }
-
-  enum TransferKind {
-    CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
-        response.setChunkedBody(content, chunkSize);
-      }
-    },
-    FIXED_LENGTH() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-      }
-    },
-    END_OF_STREAM() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(DISCONNECT_AT_END);
-        response.removeHeader("Content-Length");
-      }
-    };
-
-    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, new Buffer().writeUtf8(content), chunkSize);
-    }
-  }
-
-  private <T> List<T> toListOrNull(T[] arrayOrNull) {
-    return arrayOrNull != null ? Arrays.asList(arrayOrNull) : null;
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(result));
-    sink.writeUtf8(data);
-    sink.close();
-    return result;
-  }
-
-  private String getPlatform() {
-    return System.getProperty("okhttp.platform", "platform");
-  }
-}
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java b/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
deleted file mode 100644
index ec0de83e52..0000000000
--- a/okhttp-urlconnection/src/test/java/okhttp3/internal/huc/URLEncodingTest.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.internal.huc;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Internal;
-import okhttp3.internal.cache.CacheRequest;
-import okhttp3.internal.cache.CacheStrategy;
-import okhttp3.internal.cache.InternalCache;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-/**
- * Exercises HttpURLConnection to convert URL to a URI. Unlike URL#toURI, HttpURLConnection recovers
- * from URLs with unescaped but unsupported URI characters like '{' and '|' by escaping these
- * characters.
- */
-public final class URLEncodingTest {
-  /**
-   * This test goes through the exhaustive set of interesting ASCII characters because most of those
-   * characters are interesting in some way according to RFC 2396 and RFC 2732. http://b/1158780
-   */
-  @Test @Ignore public void lenientUrlToUri() throws Exception {
-    // alphanum
-    testUrlToUriMapping("abzABZ09", "abzABZ09", "abzABZ09", "abzABZ09", "abzABZ09");
-
-    // control characters
-    testUrlToUriMapping("\u0001", "%01", "%01", "%01", "%01");
-    testUrlToUriMapping("\u001f", "%1F", "%1F", "%1F", "%1F");
-
-    // ascii characters
-    testUrlToUriMapping("%20", "%20", "%20", "%20", "%20");
-    testUrlToUriMapping("%20", "%20", "%20", "%20", "%20");
-    testUrlToUriMapping(" ", "%20", "%20", "%20", "%20");
-    testUrlToUriMapping("!", "!", "!", "!", "!");
-    testUrlToUriMapping("\"", "%22", "%22", "%22", "%22");
-    testUrlToUriMapping("#", null, null, null, "%23");
-    testUrlToUriMapping("$", "$", "$", "$", "$");
-    testUrlToUriMapping("&", "&", "&", "&", "&");
-    testUrlToUriMapping("'", "'", "'", "'", "'");
-    testUrlToUriMapping("(", "(", "(", "(", "(");
-    testUrlToUriMapping(")", ")", ")", ")", ")");
-    testUrlToUriMapping("*", "*", "*", "*", "*");
-    testUrlToUriMapping("+", "+", "+", "+", "+");
-    testUrlToUriMapping(",", ",", ",", ",", ",");
-    testUrlToUriMapping("-", "-", "-", "-", "-");
-    testUrlToUriMapping(".", ".", ".", ".", ".");
-    testUrlToUriMapping("/", null, "/", "/", "/");
-    testUrlToUriMapping(":", null, ":", ":", ":");
-    testUrlToUriMapping(";", ";", ";", ";", ";");
-    testUrlToUriMapping("<", "%3C", "%3C", "%3C", "%3C");
-    testUrlToUriMapping("=", "=", "=", "=", "=");
-    testUrlToUriMapping(">", "%3E", "%3E", "%3E", "%3E");
-    testUrlToUriMapping("?", null, null, "?", "?");
-    testUrlToUriMapping("@", "@", "@", "@", "@");
-    testUrlToUriMapping("[", null, "%5B", null, "%5B");
-    testUrlToUriMapping("\\", "%5C", "%5C", "%5C", "%5C");
-    testUrlToUriMapping("]", null, "%5D", null, "%5D");
-    testUrlToUriMapping("^", "%5E", "%5E", "%5E", "%5E");
-    testUrlToUriMapping("_", "_", "_", "_", "_");
-    testUrlToUriMapping("`", "%60", "%60", "%60", "%60");
-    testUrlToUriMapping("{", "%7B", "%7B", "%7B", "%7B");
-    testUrlToUriMapping("|", "%7C", "%7C", "%7C", "%7C");
-    testUrlToUriMapping("}", "%7D", "%7D", "%7D", "%7D");
-    testUrlToUriMapping("~", "~", "~", "~", "~");
-    testUrlToUriMapping("~", "~", "~", "~", "~");
-    testUrlToUriMapping("\u007f", "%7F", "%7F", "%7F", "%7F");
-
-    // beyond ascii
-    testUrlToUriMapping("\u0080", "%C2%80", "%C2%80", "%C2%80", "%C2%80");
-    testUrlToUriMapping("\u20ac", "\u20ac", "\u20ac", "\u20ac", "\u20ac");
-    testUrlToUriMapping("\ud842\udf9f", "\ud842\udf9f", "\ud842\udf9f", "\ud842\udf9f",
-        "\ud842\udf9f");
-  }
-
-  @Test @Ignore public void lenientUrlToUriNul() throws Exception {
-    testUrlToUriMapping("\u0000", "%00", "%00", "%00", "%00"); // RI fails this
-  }
-
-  private void testUrlToUriMapping(String string, String asAuthority, String asFile, String asQuery,
-      String asFragment) throws Exception {
-    if (asAuthority != null) {
-      assertEquals("http://host" + asAuthority + ".tld/",
-          backdoorUrlToUri(new URL("http://host" + string + ".tld/")).toString());
-    }
-    if (asFile != null) {
-      assertEquals("http://host.tld/file" + asFile + "/",
-          backdoorUrlToUri(new URL("http://host.tld/file" + string + "/")).toString());
-    }
-    if (asQuery != null) {
-      assertEquals("http://host.tld/file?q" + asQuery + "=x",
-          backdoorUrlToUri(new URL("http://host.tld/file?q" + string + "=x")).toString());
-    }
-    assertEquals("http://host.tld/file#" + asFragment + "-x",
-        backdoorUrlToUri(new URL("http://host.tld/file#" + asFragment + "-x")).toString());
-  }
-
-  private URI backdoorUrlToUri(URL url) throws Exception {
-    final AtomicReference<URI> uriReference = new AtomicReference<>();
-
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    Internal.instance.setCache(builder, new InternalCache() {
-      @Override public Response get(Request request) throws IOException {
-        uriReference.set(request.url().uri());
-        throw new UnsupportedOperationException();
-      }
-
-      @Override public CacheRequest put(Response response) throws IOException {
-        return null;
-      }
-
-      @Override public void remove(Request request) throws IOException {
-      }
-
-      @Override public void update(Response cached, Response network) {
-      }
-
-      @Override public void trackConditionalCacheHit() {
-      }
-
-      @Override public void trackResponse(CacheStrategy cacheStrategy) {
-      }
-    });
-
-    try {
-      HttpURLConnection connection = new OkUrlFactory(builder.build()).open(url);
-      connection.getResponseCode();
-    } catch (Exception expected) {
-      if (expected.getCause() instanceof URISyntaxException) {
-        expected.printStackTrace();
-      }
-    }
-
-    return uriReference.get();
-  }
-}
diff --git a/okhttp/Module.md b/okhttp/Module.md
new file mode 100644
index 0000000000..889dd17cc7
--- /dev/null
+++ b/okhttp/Module.md
@@ -0,0 +1,3 @@
+# Module okhttp
+
+An HTTP+HTTP/2 client for Android and Java applications.
diff --git a/okhttp/build.gradle b/okhttp/build.gradle
new file mode 100644
index 0000000000..e74ac37eec
--- /dev/null
+++ b/okhttp/build.gradle
@@ -0,0 +1,345 @@
+apply plugin: 'com.vanniktech.maven.publish'
+
+jar {
+  manifest {
+    attributes('Automatic-Module-Name': 'okhttp3')
+  }
+}
+
+sourceSets {
+  main.java.srcDirs += "$buildDir/generated/sources/java-templates/java/main"
+}
+
+compileJava {
+  dependsOn 'copyJavaTemplates'
+}
+
+task copyJavaTemplates(type: Copy) {
+  from 'src/main/java-templates'
+  into "$buildDir/generated/sources/java-templates/java/main"
+  expand('projectVersion': "$VERSION_NAME")
+  filteringCharset = 'UTF-8'
+}
+
+dependencies {
+  api deps.okio
+  api deps.kotlinStdlib
+  compileOnly deps.conscrypt
+  compileOnly deps.android
+  compileOnly deps.jsr305
+  compileOnly deps.animalSniffer
+
+  testImplementation deps.okio
+  testImplementation project(':okhttp-testing-support')
+  testImplementation project(':okhttp-tls')
+  testImplementation project(':okhttp-urlconnection')
+  testImplementation project(':mockwebserver')
+  testImplementation project(':okhttp-logging-interceptor')
+  testImplementation deps.conscrypt
+  testImplementation deps.junit
+  testImplementation deps.assertj
+  testCompileOnly deps.jsr305
+}
+
+apply plugin: 'me.champeau.gradle.japicmp'
+task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
+  oldClasspath = files(baselineJar(project, baselineVersion))
+  newClasspath = files(jar.archivePath)
+  onlyBinaryIncompatibleModified = true
+  failOnModification = true
+  txtOutputFile = file("$buildDir/reports/japi.txt")
+  ignoreMissingClasses = true
+  includeSynthetic = true
+  packageExcludes = [
+      'okhttp3.internal',
+  ]
+  classExcludes = [
+      // Package-private in 3.x, internal in 4.0.0:
+      'okhttp3.Cache$CacheResponseBody$1',
+  ]
+  methodExcludes = [
+      // Became 'final' in 4.0.0:
+      'okhttp3.Cache#delete()',
+      'okhttp3.Cache#directory()',
+      'okhttp3.Cache#evictAll()',
+      'okhttp3.Cache#hitCount()',
+      'okhttp3.Cache#initialize()',
+      'okhttp3.Cache#isClosed()',
+      'okhttp3.Cache#maxSize()',
+      'okhttp3.Cache#networkCount()',
+      'okhttp3.Cache#requestCount()',
+      'okhttp3.Cache#size()',
+      'okhttp3.Cache#urls()',
+      'okhttp3.Cache#writeAbortCount()',
+      'okhttp3.Cache#writeSuccessCount()',
+      'okhttp3.CacheControl#immutable()',
+      'okhttp3.CacheControl#isPrivate()',
+      'okhttp3.CacheControl#isPublic()',
+      'okhttp3.CacheControl#maxAgeSeconds()',
+      'okhttp3.CacheControl#maxStaleSeconds()',
+      'okhttp3.CacheControl#minFreshSeconds()',
+      'okhttp3.CacheControl#mustRevalidate()',
+      'okhttp3.CacheControl#noCache()',
+      'okhttp3.CacheControl#noStore()',
+      'okhttp3.CacheControl#noTransform()',
+      'okhttp3.CacheControl#onlyIfCached()',
+      'okhttp3.CacheControl#sMaxAgeSeconds()',
+      'okhttp3.CacheControl$Builder#build()',
+      'okhttp3.CacheControl$Builder#immutable()',
+      'okhttp3.CacheControl$Builder#maxAge(int, java.util.concurrent.TimeUnit)',
+      'okhttp3.CacheControl$Builder#maxStale(int, java.util.concurrent.TimeUnit)',
+      'okhttp3.CacheControl$Builder#minFresh(int, java.util.concurrent.TimeUnit)',
+      'okhttp3.CacheControl$Builder#noCache()',
+      'okhttp3.CacheControl$Builder#noStore()',
+      'okhttp3.CacheControl$Builder#noTransform()',
+      'okhttp3.CacheControl$Builder#onlyIfCached()',
+      'okhttp3.CertificatePinner#check(java.lang.String, java.util.List)',
+      'okhttp3.CertificatePinner#check(java.lang.String, java.security.cert.Certificate\\[\\])',
+      'okhttp3.CertificatePinner$Builder#add(java.lang.String, java.lang.String\\[\\])',
+      'okhttp3.CertificatePinner$Builder#build()',
+      'okhttp3.CertificatePinner$Pin#matches(java.lang.String)',
+      'okhttp3.Challenge#scheme()',
+      'okhttp3.Challenge#authParams()',
+      'okhttp3.Challenge#realm()',
+      'okhttp3.Challenge#charset()',
+      'okhttp3.Challenge#withCharset(java.nio.charset.Charset)',
+      'okhttp3.CipherSuite#javaName()',
+      'okhttp3.ConnectionPool#connectionCount()',
+      'okhttp3.ConnectionPool#evictAll()',
+      'okhttp3.ConnectionPool#idleConnectionCount()',
+      'okhttp3.ConnectionSpec#cipherSuites()',
+      'okhttp3.ConnectionSpec#isCompatible(javax.net.ssl.SSLSocket)',
+      'okhttp3.ConnectionSpec#isTls()',
+      'okhttp3.ConnectionSpec#supportsTlsExtensions()',
+      'okhttp3.ConnectionSpec#tlsVersions()',
+      'okhttp3.ConnectionSpec$Builder#allEnabledCipherSuites()',
+      'okhttp3.ConnectionSpec$Builder#allEnabledTlsVersions()',
+      'okhttp3.ConnectionSpec$Builder#build()',
+      'okhttp3.ConnectionSpec$Builder#cipherSuites(okhttp3.CipherSuite\\[\\])',
+      'okhttp3.ConnectionSpec$Builder#cipherSuites(java.lang.String\\[\\])',
+      'okhttp3.ConnectionSpec$Builder#supportsTlsExtensions(boolean)',
+      'okhttp3.ConnectionSpec$Builder#tlsVersions(okhttp3.TlsVersion\\[\\])',
+      'okhttp3.ConnectionSpec$Builder#tlsVersions(java.lang.String\\[\\])',
+      'okhttp3.Cookie#domain()',
+      'okhttp3.Cookie#expiresAt()',
+      'okhttp3.Cookie#hostOnly()',
+      'okhttp3.Cookie#httpOnly()',
+      'okhttp3.Cookie#matches(okhttp3.HttpUrl)',
+      'okhttp3.Cookie#name()',
+      'okhttp3.Cookie#path()',
+      'okhttp3.Cookie#persistent()',
+      'okhttp3.Cookie#secure()',
+      'okhttp3.Cookie#value()',
+      'okhttp3.Cookie$Builder#build()',
+      'okhttp3.Cookie$Builder#domain(java.lang.String)',
+      'okhttp3.Cookie$Builder#expiresAt(long)',
+      'okhttp3.Cookie$Builder#hostOnlyDomain(java.lang.String)',
+      'okhttp3.Cookie$Builder#httpOnly()',
+      'okhttp3.Cookie$Builder#name(java.lang.String)',
+      'okhttp3.Cookie$Builder#path(java.lang.String)',
+      'okhttp3.Cookie$Builder#secure()',
+      'okhttp3.Cookie$Builder#value(java.lang.String)',
+      'okhttp3.Address#certificatePinner()',
+      'okhttp3.Address#connectionSpecs()',
+      'okhttp3.Address#dns()',
+      'okhttp3.Address#hostnameVerifier()',
+      'okhttp3.Address#protocols()',
+      'okhttp3.Address#proxy()',
+      'okhttp3.Address#proxyAuthenticator()',
+      'okhttp3.Address#proxySelector()',
+      'okhttp3.Address#sslSocketFactory()',
+      'okhttp3.Address#url()',
+      'okhttp3.Address#socketFactory()',
+      'okhttp3.Dispatcher#cancelAll()',
+      'okhttp3.Dispatcher#executorService()',
+      'okhttp3.Dispatcher#getMaxRequests()',
+      'okhttp3.Dispatcher#getMaxRequestsPerHost()',
+      'okhttp3.Dispatcher#queuedCalls()',
+      'okhttp3.Dispatcher#queuedCallsCount()',
+      'okhttp3.Dispatcher#runningCalls()',
+      'okhttp3.Dispatcher#runningCallsCount()',
+      'okhttp3.Dispatcher#setIdleCallback(java.lang.Runnable)',
+      'okhttp3.Dispatcher#setMaxRequests(int)',
+      'okhttp3.Dispatcher#setMaxRequestsPerHost(int)',
+      'okhttp3.FormBody#encodedName(int)',
+      'okhttp3.FormBody#encodedValue(int)',
+      'okhttp3.FormBody#name(int)',
+      'okhttp3.FormBody#size()',
+      'okhttp3.FormBody#value(int)',
+      'okhttp3.FormBody$Builder#add(java.lang.String, java.lang.String)',
+      'okhttp3.FormBody$Builder#addEncoded(java.lang.String, java.lang.String)',
+      'okhttp3.FormBody$Builder#build()',
+      'okhttp3.Handshake#cipherSuite()',
+      'okhttp3.Handshake#localCertificates()',
+      'okhttp3.Handshake#localPrincipal()',
+      'okhttp3.Handshake#peerCertificates()',
+      'okhttp3.Handshake#tlsVersion()',
+      'okhttp3.Handshake#peerPrincipal()',
+      'okhttp3.Headers#byteCount()',
+      'okhttp3.Headers#get(java.lang.String)',
+      'okhttp3.Headers#getDate(java.lang.String)',
+      'okhttp3.Headers#getInstant(java.lang.String)',
+      'okhttp3.Headers#name(int)',
+      'okhttp3.Headers#names()',
+      'okhttp3.Headers#newBuilder()',
+      'okhttp3.Headers#size()',
+      'okhttp3.Headers#toMultimap()',
+      'okhttp3.Headers#value(int)',
+      'okhttp3.Headers#values(java.lang.String)',
+      'okhttp3.Headers$Builder#add(java.lang.String)',
+      'okhttp3.Headers$Builder#add(java.lang.String, java.lang.String)',
+      'okhttp3.Headers$Builder#add(java.lang.String, java.util.Date)',
+      'okhttp3.Headers$Builder#add(java.lang.String, java.time.Instant)',
+      'okhttp3.Headers$Builder#addAll(okhttp3.Headers)',
+      'okhttp3.Headers$Builder#addUnsafeNonAscii(java.lang.String, java.lang.String)',
+      'okhttp3.Headers$Builder#build()',
+      'okhttp3.Headers$Builder#get(java.lang.String)',
+      'okhttp3.Headers$Builder#removeAll(java.lang.String)',
+      'okhttp3.Headers$Builder#set(java.lang.String, java.util.Date)',
+      'okhttp3.Headers$Builder#set(java.lang.String, java.time.Instant)',
+      'okhttp3.Headers$Builder#set(java.lang.String, java.lang.String)',
+      'okhttp3.HttpUrl#encodedFragment()',
+      'okhttp3.HttpUrl#encodedPassword()',
+      'okhttp3.HttpUrl#encodedPath()',
+      'okhttp3.HttpUrl#encodedPathSegments()',
+      'okhttp3.HttpUrl#encodedQuery()',
+      'okhttp3.HttpUrl#encodedUsername()',
+      'okhttp3.HttpUrl#fragment()',
+      'okhttp3.HttpUrl#host()',
+      'okhttp3.HttpUrl#isHttps()',
+      'okhttp3.HttpUrl#newBuilder()',
+      'okhttp3.HttpUrl#newBuilder(java.lang.String)',
+      'okhttp3.HttpUrl#password()',
+      'okhttp3.HttpUrl#pathSegments()',
+      'okhttp3.HttpUrl#pathSize()',
+      'okhttp3.HttpUrl#port()',
+      'okhttp3.HttpUrl#query()',
+      'okhttp3.HttpUrl#queryParameter(java.lang.String)',
+      'okhttp3.HttpUrl#queryParameterName(int)',
+      'okhttp3.HttpUrl#queryParameterNames()',
+      'okhttp3.HttpUrl#queryParameterValue(int)',
+      'okhttp3.HttpUrl#queryParameterValues(java.lang.String)',
+      'okhttp3.HttpUrl#querySize()',
+      'okhttp3.HttpUrl#redact()',
+      'okhttp3.HttpUrl#resolve(java.lang.String)',
+      'okhttp3.HttpUrl#scheme()',
+      'okhttp3.HttpUrl#topPrivateDomain()',
+      'okhttp3.HttpUrl#uri()',
+      'okhttp3.HttpUrl#url()',
+      'okhttp3.HttpUrl#username()',
+      'okhttp3.HttpUrl$Builder#addEncodedPathSegment(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#addEncodedPathSegments(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#addEncodedQueryParameter(java.lang.String, java.lang.String)',
+      'okhttp3.HttpUrl$Builder#addPathSegment(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#addPathSegments(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#addQueryParameter(java.lang.String, java.lang.String)',
+      'okhttp3.HttpUrl$Builder#build()',
+      'okhttp3.HttpUrl$Builder#encodedFragment(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#encodedPassword(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#encodedPath(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#encodedQuery(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#encodedUsername(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#fragment(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#host(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#password(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#port(int)',
+      'okhttp3.HttpUrl$Builder#query(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#removeAllEncodedQueryParameters(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#removeAllQueryParameters(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#removePathSegment(int)',
+      'okhttp3.HttpUrl$Builder#scheme(java.lang.String)',
+      'okhttp3.HttpUrl$Builder#setEncodedPathSegment(int, java.lang.String)',
+      'okhttp3.HttpUrl$Builder#setEncodedQueryParameter(java.lang.String, java.lang.String)',
+      'okhttp3.HttpUrl$Builder#setPathSegment(int, java.lang.String)',
+      'okhttp3.HttpUrl$Builder#setQueryParameter(java.lang.String, java.lang.String)',
+      'okhttp3.HttpUrl$Builder#username(java.lang.String)',
+      'okhttp3.MediaType#charset()',
+      'okhttp3.MediaType#charset(java.nio.charset.Charset)',
+      'okhttp3.MediaType#subtype()',
+      'okhttp3.MediaType#type()',
+      'okhttp3.OkHttpClient$Builder#addInterceptor(okhttp3.Interceptor)',
+      'okhttp3.OkHttpClient$Builder#addNetworkInterceptor(okhttp3.Interceptor)',
+      'okhttp3.OkHttpClient$Builder#authenticator(okhttp3.Authenticator)',
+      'okhttp3.OkHttpClient$Builder#build()',
+      'okhttp3.OkHttpClient$Builder#cache(okhttp3.Cache)',
+      'okhttp3.OkHttpClient$Builder#callTimeout(long, java.util.concurrent.TimeUnit)',
+      'okhttp3.OkHttpClient$Builder#callTimeout(java.time.Duration)',
+      'okhttp3.OkHttpClient$Builder#certificatePinner(okhttp3.CertificatePinner)',
+      'okhttp3.OkHttpClient$Builder#connectionPool(okhttp3.ConnectionPool)',
+      'okhttp3.OkHttpClient$Builder#connectionSpecs(java.util.List)',
+      'okhttp3.OkHttpClient$Builder#connectTimeout(long, java.util.concurrent.TimeUnit)',
+      'okhttp3.OkHttpClient$Builder#connectTimeout(java.time.Duration)',
+      'okhttp3.OkHttpClient$Builder#cookieJar(okhttp3.CookieJar)',
+      'okhttp3.OkHttpClient$Builder#dispatcher(okhttp3.Dispatcher)',
+      'okhttp3.OkHttpClient$Builder#dns(okhttp3.Dns)',
+      'okhttp3.OkHttpClient$Builder#eventListener(okhttp3.EventListener)',
+      'okhttp3.OkHttpClient$Builder#eventListenerFactory(okhttp3.EventListener$Factory)',
+      'okhttp3.OkHttpClient$Builder#followRedirects(boolean)',
+      'okhttp3.OkHttpClient$Builder#followSslRedirects(boolean)',
+      'okhttp3.OkHttpClient$Builder#hostnameVerifier(javax.net.ssl.HostnameVerifier)',
+      'okhttp3.OkHttpClient$Builder#interceptors()',
+      'okhttp3.OkHttpClient$Builder#networkInterceptors()',
+      'okhttp3.OkHttpClient$Builder#pingInterval(long, java.util.concurrent.TimeUnit)',
+      'okhttp3.OkHttpClient$Builder#pingInterval(java.time.Duration)',
+      'okhttp3.OkHttpClient$Builder#protocols(java.util.List)',
+      'okhttp3.OkHttpClient$Builder#proxy(java.net.Proxy)',
+      'okhttp3.OkHttpClient$Builder#proxyAuthenticator(okhttp3.Authenticator)',
+      'okhttp3.OkHttpClient$Builder#proxySelector(java.net.ProxySelector)',
+      'okhttp3.OkHttpClient$Builder#readTimeout(long, java.util.concurrent.TimeUnit)',
+      'okhttp3.OkHttpClient$Builder#readTimeout(java.time.Duration)',
+      'okhttp3.OkHttpClient$Builder#retryOnConnectionFailure(boolean)',
+      'okhttp3.OkHttpClient$Builder#socketFactory(javax.net.SocketFactory)',
+      'okhttp3.OkHttpClient$Builder#sslSocketFactory(javax.net.ssl.SSLSocketFactory)',
+      'okhttp3.OkHttpClient$Builder#sslSocketFactory(javax.net.ssl.SSLSocketFactory, javax.net.ssl.X509TrustManager)',
+      'okhttp3.OkHttpClient$Builder#writeTimeout(long, java.util.concurrent.TimeUnit)',
+      'okhttp3.OkHttpClient$Builder#writeTimeout(java.time.Duration)',
+      'okhttp3.RealCall#getResponseWithInterceptorChain()',
+      'okhttp3.RealCall#redactedUrl()',
+      'okhttp3.RealCall#toLoggableString()',
+      'okhttp3.RealCall$AsyncCall#callsPerHost()',
+      'okhttp3.RealCall$AsyncCall#executeOn(java.util.concurrent.ExecutorService)',
+      'okhttp3.RealCall$AsyncCall#get()',
+      'okhttp3.RealCall$AsyncCall#host()',
+      'okhttp3.RealCall$AsyncCall#request()',
+      'okhttp3.RealCall$AsyncCall#reuseCallsPerHostFrom(okhttp3.RealCall$AsyncCall)',
+      'okhttp3.Request#body()',
+      'okhttp3.Request#cacheControl()',
+      'okhttp3.Request#header(java.lang.String)',
+      'okhttp3.Request#headers()',
+      'okhttp3.Request#headers(java.lang.String)',
+      'okhttp3.Request#isHttps()',
+      'okhttp3.Request#method()',
+      'okhttp3.Request#newBuilder()',
+      'okhttp3.Request#tag()',
+      'okhttp3.Request#tag(java.lang.Class)',
+      'okhttp3.Request#url()',
+      'okhttp3.Response#body()',
+      'okhttp3.Response#cacheControl()',
+      'okhttp3.Response#cacheResponse()',
+      'okhttp3.Response#challenges()',
+      'okhttp3.Response#code()',
+      'okhttp3.Response#handshake()',
+      'okhttp3.Response#header(java.lang.String)',
+      'okhttp3.Response#header(java.lang.String, java.lang.String)',
+      'okhttp3.Response#headers(java.lang.String)',
+      'okhttp3.Response#headers()',
+      'okhttp3.Response#isRedirect()',
+      'okhttp3.Response#isSuccessful()',
+      'okhttp3.Response#message()',
+      'okhttp3.Response#networkResponse()',
+      'okhttp3.Response#newBuilder()',
+      'okhttp3.Response#peekBody(long)',
+      'okhttp3.Response#priorResponse()',
+      'okhttp3.Response#protocol()',
+      'okhttp3.Response#receivedResponseAtMillis()',
+      'okhttp3.Response#request()',
+      'okhttp3.Response#sentRequestAtMillis()',
+      'okhttp3.Response#trailers()',
+      'okhttp3.Route#address()',
+      'okhttp3.Route#proxy()',
+      'okhttp3.Route#requiresTunnel()',
+      'okhttp3.Route#socketAddress()',
+      'okhttp3.TlsVersion#javaName()',
+  ]
+}
+check.dependsOn(japicmp)
diff --git a/okhttp/gradle.properties b/okhttp/gradle.properties
new file mode 100644
index 0000000000..f847919b06
--- /dev/null
+++ b/okhttp/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=okhttp
+POM_NAME=okhttp
+POM_PACKAGING=jar
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
deleted file mode 100644
index 29f38b6b02..0000000000
--- a/okhttp/pom.xml
+++ /dev/null
@@ -1,77 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.11.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp</artifactId>
-  <name>OkHttp</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okio</groupId>
-      <artifactId>okio</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>org.conscrypt</groupId>
-      <artifactId>conscrypt-openjdk-uber</artifactId>
-      <version>1.0.1</version>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.google.code.findbugs</groupId>
-      <artifactId>jsr305</artifactId>
-      <scope>provided</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>templating-maven-plugin</artifactId>
-        <version>1.0-alpha-3</version>
-        <executions>
-          <execution>
-            <goals>
-              <goal>filter-sources</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.10.4</version>
-        <configuration>
-          <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
-          <links>
-            <link>http://square.github.io/okio/</link>
-          </links>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-jar-plugin</artifactId>
-        <version>3.0.2</version>
-        <configuration>
-          <archive>
-            <manifestEntries>
-              <Automatic-Module-Name>okhttp3</Automatic-Module-Name>
-            </manifestEntries>
-          </archive>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp/src/main/java-templates/okhttp3/internal/Version.java b/okhttp/src/main/java-templates/okhttp3/internal/Version.java
index fce1c067c0..52e0608569 100644
--- a/okhttp/src/main/java-templates/okhttp3/internal/Version.java
+++ b/okhttp/src/main/java-templates/okhttp3/internal/Version.java
@@ -17,7 +17,7 @@
 
 public final class Version {
   public static String userAgent() {
-    return "okhttp/${project.version}";
+    return "okhttp/${projectVersion}";
   }
 
   private Version() {
diff --git a/okhttp/src/main/java/okhttp3/Address.java b/okhttp/src/main/java/okhttp3/Address.java
deleted file mode 100644
index 9df666ad78..0000000000
--- a/okhttp/src/main/java/okhttp3/Address.java
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.SocketFactory;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.internal.Util;
-
-import static okhttp3.internal.Util.equal;
-
-/**
- * A specification for a connection to an origin server. For simple connections, this is the
- * server's hostname and port. If an explicit proxy is requested (or {@linkplain Proxy#NO_PROXY no
- * proxy} is explicitly requested), this also includes that proxy information. For secure
- * connections the address also includes the SSL socket factory, hostname verifier, and certificate
- * pinner.
- *
- * <p>HTTP requests that share the same {@code Address} may also share the same {@link Connection}.
- */
-public final class Address {
-  final HttpUrl url;
-  final Dns dns;
-  final SocketFactory socketFactory;
-  final Authenticator proxyAuthenticator;
-  final List<Protocol> protocols;
-  final List<ConnectionSpec> connectionSpecs;
-  final ProxySelector proxySelector;
-  final @Nullable Proxy proxy;
-  final @Nullable SSLSocketFactory sslSocketFactory;
-  final @Nullable HostnameVerifier hostnameVerifier;
-  final @Nullable CertificatePinner certificatePinner;
-
-  public Address(String uriHost, int uriPort, Dns dns, SocketFactory socketFactory,
-      @Nullable SSLSocketFactory sslSocketFactory, @Nullable HostnameVerifier hostnameVerifier,
-      @Nullable CertificatePinner certificatePinner, Authenticator proxyAuthenticator,
-      @Nullable Proxy proxy, List<Protocol> protocols, List<ConnectionSpec> connectionSpecs,
-      ProxySelector proxySelector) {
-    this.url = new HttpUrl.Builder()
-        .scheme(sslSocketFactory != null ? "https" : "http")
-        .host(uriHost)
-        .port(uriPort)
-        .build();
-
-    if (dns == null) throw new NullPointerException("dns == null");
-    this.dns = dns;
-
-    if (socketFactory == null) throw new NullPointerException("socketFactory == null");
-    this.socketFactory = socketFactory;
-
-    if (proxyAuthenticator == null) {
-      throw new NullPointerException("proxyAuthenticator == null");
-    }
-    this.proxyAuthenticator = proxyAuthenticator;
-
-    if (protocols == null) throw new NullPointerException("protocols == null");
-    this.protocols = Util.immutableList(protocols);
-
-    if (connectionSpecs == null) throw new NullPointerException("connectionSpecs == null");
-    this.connectionSpecs = Util.immutableList(connectionSpecs);
-
-    if (proxySelector == null) throw new NullPointerException("proxySelector == null");
-    this.proxySelector = proxySelector;
-
-    this.proxy = proxy;
-    this.sslSocketFactory = sslSocketFactory;
-    this.hostnameVerifier = hostnameVerifier;
-    this.certificatePinner = certificatePinner;
-  }
-
-  /**
-   * Returns a URL with the hostname and port of the origin server. The path, query, and fragment of
-   * this URL are always empty, since they are not significant for planning a route.
-   */
-  public HttpUrl url() {
-    return url;
-  }
-
-  /** Returns the service that will be used to resolve IP addresses for hostnames. */
-  public Dns dns() {
-    return dns;
-  }
-
-  /** Returns the socket factory for new connections. */
-  public SocketFactory socketFactory() {
-    return socketFactory;
-  }
-
-  /** Returns the client's proxy authenticator. */
-  public Authenticator proxyAuthenticator() {
-    return proxyAuthenticator;
-  }
-
-  /**
-   * Returns the protocols the client supports. This method always returns a non-null list that
-   * contains minimally {@link Protocol#HTTP_1_1}.
-   */
-  public List<Protocol> protocols() {
-    return protocols;
-  }
-
-  public List<ConnectionSpec> connectionSpecs() {
-    return connectionSpecs;
-  }
-
-  /**
-   * Returns this address's proxy selector. Only used if the proxy is null. If none of this
-   * selector's proxies are reachable, a direct connection will be attempted.
-   */
-  public ProxySelector proxySelector() {
-    return proxySelector;
-  }
-
-  /**
-   * Returns this address's explicitly-specified HTTP proxy, or null to delegate to the {@linkplain
-   * #proxySelector proxy selector}.
-   */
-  public @Nullable Proxy proxy() {
-    return proxy;
-  }
-
-  /** Returns the SSL socket factory, or null if this is not an HTTPS address. */
-  public @Nullable SSLSocketFactory sslSocketFactory() {
-    return sslSocketFactory;
-  }
-
-  /** Returns the hostname verifier, or null if this is not an HTTPS address. */
-  public @Nullable HostnameVerifier hostnameVerifier() {
-    return hostnameVerifier;
-  }
-
-  /** Returns this address's certificate pinner, or null if this is not an HTTPS address. */
-  public @Nullable CertificatePinner certificatePinner() {
-    return certificatePinner;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof Address
-        && url.equals(((Address) other).url)
-        && equalsNonHost((Address) other);
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + url.hashCode();
-    result = 31 * result + dns.hashCode();
-    result = 31 * result + proxyAuthenticator.hashCode();
-    result = 31 * result + protocols.hashCode();
-    result = 31 * result + connectionSpecs.hashCode();
-    result = 31 * result + proxySelector.hashCode();
-    result = 31 * result + (proxy != null ? proxy.hashCode() : 0);
-    result = 31 * result + (sslSocketFactory != null ? sslSocketFactory.hashCode() : 0);
-    result = 31 * result + (hostnameVerifier != null ? hostnameVerifier.hashCode() : 0);
-    result = 31 * result + (certificatePinner != null ? certificatePinner.hashCode() : 0);
-    return result;
-  }
-
-  boolean equalsNonHost(Address that) {
-    return this.dns.equals(that.dns)
-        && this.proxyAuthenticator.equals(that.proxyAuthenticator)
-        && this.protocols.equals(that.protocols)
-        && this.connectionSpecs.equals(that.connectionSpecs)
-        && this.proxySelector.equals(that.proxySelector)
-        && equal(this.proxy, that.proxy)
-        && equal(this.sslSocketFactory, that.sslSocketFactory)
-        && equal(this.hostnameVerifier, that.hostnameVerifier)
-        && equal(this.certificatePinner, that.certificatePinner)
-        && this.url().port() == that.url().port();
-  }
-
-  @Override public String toString() {
-    StringBuilder result = new StringBuilder()
-        .append("Address{")
-        .append(url.host()).append(":").append(url.port());
-
-    if (proxy != null) {
-      result.append(", proxy=").append(proxy);
-    } else {
-      result.append(", proxySelector=").append(proxySelector);
-    }
-
-    result.append("}");
-    return result.toString();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Address.kt b/okhttp/src/main/java/okhttp3/Address.kt
new file mode 100644
index 0000000000..62139b0b92
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Address.kt
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.net.Proxy
+import java.net.ProxySelector
+import java.util.Objects
+import javax.net.SocketFactory
+import javax.net.ssl.HostnameVerifier
+import javax.net.ssl.SSLSocketFactory
+import okhttp3.internal.Util
+
+/**
+ * A specification for a connection to an origin server. For simple connections, this is the
+ * server's hostname and port. If an explicit proxy is requested (or [no proxy][Proxy.NO_PROXY] is explicitly requested),
+ * this also includes that proxy information. For secure connections the address also includes the SSL socket factory,
+ * hostname verifier, and certificate pinner.
+ *
+ * HTTP requests that share the same `Address` may also share the same [Connection].
+ */
+class Address(
+    uriHost: String,
+    uriPort: Int,
+    private val dns: Dns,
+    private val socketFactory: SocketFactory,
+    private val sslSocketFactory: SSLSocketFactory?,
+    private val hostnameVerifier: HostnameVerifier?,
+    private val certificatePinner: CertificatePinner?,
+    private val proxyAuthenticator: Authenticator,
+    private val proxy: Proxy?,
+    protocols: List<Protocol>,
+    connectionSpecs: List<ConnectionSpec>,
+    private val proxySelector: ProxySelector
+) {
+  private val url: HttpUrl = HttpUrl.Builder()
+      .scheme(if (sslSocketFactory != null) "https" else "http")
+      .host(uriHost)
+      .port(uriPort)
+      .build()
+
+  /**
+   * The protocols the client supports. This method always returns a non-null list that
+   * contains minimally [Protocol.HTTP_1_1].
+   */
+  private val protocols: List<Protocol> = Util.immutableList(protocols)
+
+  private val connectionSpecs: List<ConnectionSpec> = Util.immutableList(connectionSpecs)
+
+  /**
+   * Returns a URL with the hostname and port of the origin server. The path, query, and fragment of
+   * this URL are always empty, since they are not significant for planning a route.
+   */
+  fun url() = url
+
+  /** Returns the service that will be used to resolve IP addresses for hostnames. */
+  fun dns() = dns
+
+  /** Returns the socket factory for new connections. */
+  fun socketFactory() = socketFactory
+
+  /** Returns the client's proxy authenticator. */
+  fun proxyAuthenticator() = proxyAuthenticator
+
+  /**
+   * Returns the protocols the client supports. This method always returns a non-null list that
+   * contains minimally {@link Protocol#HTTP_1_1}.
+   */
+  fun protocols() = protocols
+
+  fun connectionSpecs() = connectionSpecs
+
+  /**
+   * Returns this address's proxy selector. Only used if the proxy is null. If none of this
+   * selector's proxies are reachable, a direct connection will be attempted.
+   */
+  fun proxySelector() = proxySelector
+
+  /**
+   * Returns this address's explicitly-specified HTTP proxy, or null to delegate to the {@linkplain
+   * #proxySelector proxy selector}.
+   */
+  fun proxy() = proxy
+
+  /** Returns the SSL socket factory, or null if this is not an HTTPS address. */
+  fun sslSocketFactory() = sslSocketFactory
+
+  /** Returns the hostname verifier, or null if this is not an HTTPS address. */
+  fun hostnameVerifier() = hostnameVerifier
+
+  /** Returns this address's certificate pinner, or null if this is not an HTTPS address. */
+  fun certificatePinner() = certificatePinner
+
+  override fun equals(other: Any?): Boolean {
+    return other is Address
+        && url == other.url
+        && equalsNonHost(other)
+  }
+
+  override fun hashCode(): Int {
+    var result = 17
+    result = 31 * result + url.hashCode()
+    result = 31 * result + dns.hashCode()
+    result = 31 * result + proxyAuthenticator.hashCode()
+    result = 31 * result + protocols.hashCode()
+    result = 31 * result + connectionSpecs.hashCode()
+    result = 31 * result + proxySelector.hashCode()
+    result = 31 * result + Objects.hashCode(proxy)
+    result = 31 * result + Objects.hashCode(sslSocketFactory)
+    result = 31 * result + Objects.hashCode(hostnameVerifier)
+    result = 31 * result + Objects.hashCode(certificatePinner)
+    return result
+  }
+
+  internal fun equalsNonHost(that: Address): Boolean {
+    return this.dns == that.dns
+        && this.proxyAuthenticator == that.proxyAuthenticator
+        && this.protocols == that.protocols
+        && this.connectionSpecs == that.connectionSpecs
+        && this.proxySelector == that.proxySelector
+        && this.proxy == that.proxy
+        && this.sslSocketFactory == that.sslSocketFactory
+        && this.hostnameVerifier == that.hostnameVerifier
+        && this.certificatePinner == that.certificatePinner
+        && this.url().port() == that.url().port()
+  }
+
+  override fun toString(): String {
+    return "Address{" +
+        "${url.host()}:${url.port()}, " +
+        (if (proxy != null) "proxy=$proxy" else "proxySelector=$proxySelector") +
+        "}"
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
deleted file mode 100644
index 9e34bc9706..0000000000
--- a/okhttp/src/main/java/okhttp3/Authenticator.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import javax.annotation.Nullable;
-
-/**
- * Responds to an authentication challenge from either a remote web server or a proxy server.
- * Implementations may either attempt to satisfy the challenge by returning a request that includes
- * an authorization header, or they may refuse the challenge by returning null. In this case the
- * unauthenticated response will be returned to the caller that triggered it.
- *
- * <p>Implementations should check if the initial request already included an attempt to
- * authenticate. If so it is likely that further attempts will not be useful and the authenticator
- * should give up.
- *
- * <p>When authentication is requested by an origin server, the response code is 401 and the
- * implementation should respond with a new request that sets the "Authorization" header.
- * <pre>   {@code
- *
- *    if (response.request().header("Authorization") != null) {
- *      return null; // Give up, we've already failed to authenticate.
- *    }
- *
- *    String credential = Credentials.basic(...)
- *    return response.request().newBuilder()
- *        .header("Authorization", credential)
- *        .build();
- * }</pre>
- *
- * <p>When authentication is requested by a proxy server, the response code is 407 and the
- * implementation should respond with a new request that sets the "Proxy-Authorization" header.
- * <pre>   {@code
- *
- *    if (response.request().header("Proxy-Authorization") != null) {
- *      return null; // Give up, we've already failed to authenticate.
- *    }
- *
- *    String credential = Credentials.basic(...)
- *    return response.request().newBuilder()
- *        .header("Proxy-Authorization", credential)
- *        .build();
- * }</pre>
- *
- * <p>Applications may configure OkHttp with an authenticator for origin servers, or proxy servers,
- * or both.
- */
-public interface Authenticator {
-  /** An authenticator that knows no credentials and makes no attempt to authenticate. */
-  Authenticator NONE = new Authenticator() {
-    @Override public Request authenticate(Route route, Response response) {
-      return null;
-    }
-  };
-
-  /**
-   * Returns a request that includes a credential to satisfy an authentication challenge in {@code
-   * response}. Returns null if the challenge cannot be satisfied.
-   */
-  @Nullable Request authenticate(Route route, Response response) throws IOException;
-}
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.kt b/okhttp/src/main/java/okhttp3/Authenticator.kt
new file mode 100644
index 0000000000..62c3f8877d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Authenticator.kt
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.io.IOException
+
+/**
+ * Performs either **preemptive** authentication before connecting to a proxy server, or
+ * **reactive** authentication after receiving a challenge from either an origin web server or proxy
+ * server.
+ *
+ * ## Preemptive Authentication
+ *
+ * To make HTTPS calls using an HTTP proxy server OkHttp must first negotiate a connection with
+ * the proxy. This proxy connection is called a "TLS Tunnel" and is specified by
+ * [RFC 2817][rfc_2817]. The HTTP CONNECT request that creates this tunnel connection is special: it
+ * does not participate in any [interceptors][Interceptor] or [event listeners][EventListener]. It
+ * doesn't include the motivating request's HTTP headers or even its full URL; only the target
+ * server's hostname is sent to the proxy.
+ *
+ * Prior to sending any CONNECT request OkHttp always calls the proxy authenticator so that it may
+ * prepare preemptive authentication. OkHttp will call [authenticate] with a fake `HTTP/1.1 407
+ * Proxy Authentication Required` response that has a `Proxy-Authenticate: OkHttp-Preemptive`
+ * challenge. The proxy authenticator may return either either an authenticated request, or null to
+ * connect without authentication.
+ *
+ * ```
+ * for (Challenge challenge : response.challenges()) {
+ *   // If this is preemptive auth, use a preemptive credential.
+ *   if (challenge.scheme().equalsIgnoreCase("OkHttp-Preemptive")) {
+ *     return response.request().newBuilder()
+ *         .header("Proxy-Authorization", "secret")
+ *         .build();
+ *   }
+ * }
+ * return null; // Didn't find a preemptive auth scheme.
+ * ```
+ *
+ * ## Reactive Authentication
+ *
+ * Implementations authenticate by returning a follow-up request that includes an authorization
+ * header, or they may decline the challenge by returning null. In this case the unauthenticated
+ * response will be returned to the caller that triggered it.
+ *
+ * Implementations should check if the initial request already included an attempt to
+ * authenticate. If so it is likely that further attempts will not be useful and the authenticator
+ * should give up.
+ *
+ * When reactive authentication is requested by an origin web server, the response code is 401
+ * and the implementation should respond with a new request that sets the "Authorization" header.
+ *
+ * ```
+ * if (response.request().header("Authorization") != null) {
+ *   return null; // Give up, we've already failed to authenticate.
+ * }
+ *
+ * String credential = Credentials.basic(...)
+ * return response.request().newBuilder()
+ *     .header("Authorization", credential)
+ *     .build();
+ * ```
+ *
+ * When reactive authentication is requested by a proxy server, the response code is 407 and the
+ * implementation should respond with a new request that sets the "Proxy-Authorization" header.
+ *
+ * ```
+ * if (response.request().header("Proxy-Authorization") != null) {
+ *   return null; // Give up, we've already failed to authenticate.
+ * }
+ *
+ * String credential = Credentials.basic(...)
+ * return response.request().newBuilder()
+ *     .header("Proxy-Authorization", credential)
+ *     .build();
+ * ```
+ *
+ * The proxy authenticator may implement preemptive authentication, reactive authentication, or
+ * both.
+ *
+ * Applications may configure OkHttp with an authenticator for origin servers, or proxy servers,
+ * or both.
+ *
+ * [rfc_2817]: https://tools.ietf.org/html/rfc2817
+ */
+interface Authenticator {
+  /**
+   * Returns a request that includes a credential to satisfy an authentication challenge in
+   * `response`. Returns null if the challenge cannot be satisfied.
+   *
+   * The route is best effort, it currently may not always be provided even when logically
+   * available. It may also not be provided when an authenticator is re-used manually in an
+   * application interceptor, such as when implementing client-specific retries.
+   */
+  @Throws(IOException::class)
+  fun authenticate(route: Route?, response: Response): Request?
+
+  companion object {
+    /** An authenticator that knows no credentials and makes no attempt to authenticate.  */
+    @JvmField
+    val NONE = object : Authenticator {
+      override fun authenticate(route: Route?, response: Response): Request? {
+        return null
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
deleted file mode 100644
index d43d91d257..0000000000
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ /dev/null
@@ -1,770 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.Closeable;
-import java.io.File;
-import java.io.Flushable;
-import java.io.IOException;
-import java.security.cert.Certificate;
-import java.security.cert.CertificateEncodingException;
-import java.security.cert.CertificateException;
-import java.security.cert.CertificateFactory;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.NoSuchElementException;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.cache.CacheRequest;
-import okhttp3.internal.cache.CacheStrategy;
-import okhttp3.internal.cache.DiskLruCache;
-import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.HttpMethod;
-import okhttp3.internal.http.StatusLine;
-import okhttp3.internal.io.FileSystem;
-import okhttp3.internal.platform.Platform;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.ForwardingSink;
-import okio.ForwardingSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-
-/**
- * Caches HTTP and HTTPS responses to the filesystem so they may be reused, saving time and
- * bandwidth.
- *
- * <h3>Cache Optimization</h3>
- *
- * <p>To measure cache effectiveness, this class tracks three statistics:
- * <ul>
- *     <li><strong>{@linkplain #requestCount() Request Count:}</strong> the number of HTTP
- *         requests issued since this cache was created.
- *     <li><strong>{@linkplain #networkCount() Network Count:}</strong> the number of those
- *         requests that required network use.
- *     <li><strong>{@linkplain #hitCount() Hit Count:}</strong> the number of those requests
- *         whose responses were served by the cache.
- * </ul>
- *
- * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
- * the response, the client will issue a conditional {@code GET}. The server will then send either
- * the updated response if it has changed, or a short 'not modified' response if the client's copy
- * is still valid. Such responses increment both the network count and hit count.
- *
- * <p>The best way to improve the cache hit rate is by configuring the web server to return
- * cacheable responses. Although this client honors all <a
- * href="http://tools.ietf.org/html/rfc7234">HTTP/1.1 (RFC 7234)</a> cache headers, it doesn't cache
- * partial responses.
- *
- * <h3>Force a Network Response</h3>
- *
- * <p>In some situations, such as after a user clicks a 'refresh' button, it may be necessary to
- * skip the cache, and fetch data directly from the server. To force a full refresh, add the {@code
- * no-cache} directive: <pre>   {@code
- *
- *   Request request = new Request.Builder()
- *       .cacheControl(new CacheControl.Builder().noCache().build())
- *       .url("http://publicobject.com/helloworld.txt")
- *       .build();
- * }</pre>
- *
- * If it is only necessary to force a cached response to be validated by the server, use the more
- * efficient {@code max-age=0} directive instead: <pre>   {@code
- *
- *   Request request = new Request.Builder()
- *       .cacheControl(new CacheControl.Builder()
- *           .maxAge(0, TimeUnit.SECONDS)
- *           .build())
- *       .url("http://publicobject.com/helloworld.txt")
- *       .build();
- * }</pre>
- *
- * <h3>Force a Cache Response</h3>
- *
- * <p>Sometimes you'll want to show resources if they are available immediately, but not otherwise.
- * This can be used so your application can show <i>something</i> while waiting for the latest data
- * to be downloaded. To restrict a request to locally-cached resources, add the {@code
- * only-if-cached} directive: <pre>   {@code
- *
- *     Request request = new Request.Builder()
- *         .cacheControl(new CacheControl.Builder()
- *             .onlyIfCached()
- *             .build())
- *         .url("http://publicobject.com/helloworld.txt")
- *         .build();
- *     Response forceCacheResponse = client.newCall(request).execute();
- *     if (forceCacheResponse.code() != 504) {
- *       // The resource was cached! Show it.
- *     } else {
- *       // The resource was not cached.
- *     }
- * }</pre>
- * This technique works even better in situations where a stale response is better than no response.
- * To permit stale cached responses, use the {@code max-stale} directive with the maximum staleness
- * in seconds: <pre>   {@code
- *
- *   Request request = new Request.Builder()
- *       .cacheControl(new CacheControl.Builder()
- *           .maxStale(365, TimeUnit.DAYS)
- *           .build())
- *       .url("http://publicobject.com/helloworld.txt")
- *       .build();
- * }</pre>
- *
- * <p>The {@link CacheControl} class can configure request caching directives and parse response
- * caching directives. It even offers convenient constants {@link CacheControl#FORCE_NETWORK} and
- * {@link CacheControl#FORCE_CACHE} that address the use cases above.
- */
-public final class Cache implements Closeable, Flushable {
-  private static final int VERSION = 201105;
-  private static final int ENTRY_METADATA = 0;
-  private static final int ENTRY_BODY = 1;
-  private static final int ENTRY_COUNT = 2;
-
-  final InternalCache internalCache = new InternalCache() {
-    @Override public Response get(Request request) throws IOException {
-      return Cache.this.get(request);
-    }
-
-    @Override public CacheRequest put(Response response) throws IOException {
-      return Cache.this.put(response);
-    }
-
-    @Override public void remove(Request request) throws IOException {
-      Cache.this.remove(request);
-    }
-
-    @Override public void update(Response cached, Response network) {
-      Cache.this.update(cached, network);
-    }
-
-    @Override public void trackConditionalCacheHit() {
-      Cache.this.trackConditionalCacheHit();
-    }
-
-    @Override public void trackResponse(CacheStrategy cacheStrategy) {
-      Cache.this.trackResponse(cacheStrategy);
-    }
-  };
-
-  final DiskLruCache cache;
-
-  /* read and write statistics, all guarded by 'this' */
-  int writeSuccessCount;
-  int writeAbortCount;
-  private int networkCount;
-  private int hitCount;
-  private int requestCount;
-
-  public Cache(File directory, long maxSize) {
-    this(directory, maxSize, FileSystem.SYSTEM);
-  }
-
-  Cache(File directory, long maxSize, FileSystem fileSystem) {
-    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);
-  }
-
-  public static String key(HttpUrl url) {
-    return ByteString.encodeUtf8(url.toString()).md5().hex();
-  }
-
-  @Nullable Response get(Request request) {
-    String key = key(request.url());
-    DiskLruCache.Snapshot snapshot;
-    Entry entry;
-    try {
-      snapshot = cache.get(key);
-      if (snapshot == null) {
-        return null;
-      }
-    } catch (IOException e) {
-      // Give up because the cache cannot be read.
-      return null;
-    }
-
-    try {
-      entry = new Entry(snapshot.getSource(ENTRY_METADATA));
-    } catch (IOException e) {
-      Util.closeQuietly(snapshot);
-      return null;
-    }
-
-    Response response = entry.response(snapshot);
-
-    if (!entry.matches(request, response)) {
-      Util.closeQuietly(response.body());
-      return null;
-    }
-
-    return response;
-  }
-
-  @Nullable CacheRequest put(Response response) {
-    String requestMethod = response.request().method();
-
-    if (HttpMethod.invalidatesCache(response.request().method())) {
-      try {
-        remove(response.request());
-      } catch (IOException ignored) {
-        // The cache cannot be written.
-      }
-      return null;
-    }
-    if (!requestMethod.equals("GET")) {
-      // Don't cache non-GET responses. We're technically allowed to cache
-      // HEAD requests and some POST requests, but the complexity of doing
-      // so is high and the benefit is low.
-      return null;
-    }
-
-    if (HttpHeaders.hasVaryAll(response)) {
-      return null;
-    }
-
-    Entry entry = new Entry(response);
-    DiskLruCache.Editor editor = null;
-    try {
-      editor = cache.edit(key(response.request().url()));
-      if (editor == null) {
-        return null;
-      }
-      entry.writeTo(editor);
-      return new CacheRequestImpl(editor);
-    } catch (IOException e) {
-      abortQuietly(editor);
-      return null;
-    }
-  }
-
-  void remove(Request request) throws IOException {
-    cache.remove(key(request.url()));
-  }
-
-  void update(Response cached, Response network) {
-    Entry entry = new Entry(network);
-    DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;
-    DiskLruCache.Editor editor = null;
-    try {
-      editor = snapshot.edit(); // Returns null if snapshot is not current.
-      if (editor != null) {
-        entry.writeTo(editor);
-        editor.commit();
-      }
-    } catch (IOException e) {
-      abortQuietly(editor);
-    }
-  }
-
-  private void abortQuietly(@Nullable DiskLruCache.Editor editor) {
-    // Give up because the cache cannot be written.
-    try {
-      if (editor != null) {
-        editor.abort();
-      }
-    } catch (IOException ignored) {
-    }
-  }
-
-  /**
-   * Initialize the cache. This will include reading the journal files from the storage and building
-   * up the necessary in-memory cache information.
-   *
-   * <p>The initialization time may vary depending on the journal file size and the current actual
-   * cache size. The application needs to be aware of calling this function during the
-   * initialization phase and preferably in a background worker thread.
-   *
-   * <p>Note that if the application chooses to not call this method to initialize the cache. By
-   * default, the okhttp will perform lazy initialization upon the first usage of the cache.
-   */
-  public void initialize() throws IOException {
-    cache.initialize();
-  }
-
-  /**
-   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
-   * directory including files that weren't created by the cache.
-   */
-  public void delete() throws IOException {
-    cache.delete();
-  }
-
-  /**
-   * Deletes all values stored in the cache. In-flight writes to the cache will complete normally,
-   * but the corresponding responses will not be stored.
-   */
-  public void evictAll() throws IOException {
-    cache.evictAll();
-  }
-
-  /**
-   * Returns an iterator over the URLs in this cache. This iterator doesn't throw {@code
-   * ConcurrentModificationException}, but if new responses are added while iterating, their URLs
-   * will not be returned. If existing responses are evicted during iteration, they will be absent
-   * (unless they were already returned).
-   *
-   * <p>The iterator supports {@linkplain Iterator#remove}. Removing a URL from the iterator evicts
-   * the corresponding response from the cache. Use this to evict selected responses.
-   */
-  public Iterator<String> urls() throws IOException {
-    return new Iterator<String>() {
-      final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
-
-      @Nullable String nextUrl;
-      boolean canRemove;
-
-      @Override public boolean hasNext() {
-        if (nextUrl != null) return true;
-
-        canRemove = false; // Prevent delegate.remove() on the wrong item!
-        while (delegate.hasNext()) {
-          DiskLruCache.Snapshot snapshot = delegate.next();
-          try {
-            BufferedSource metadata = Okio.buffer(snapshot.getSource(ENTRY_METADATA));
-            nextUrl = metadata.readUtf8LineStrict();
-            return true;
-          } catch (IOException ignored) {
-            // We couldn't read the metadata for this snapshot; possibly because the host filesystem
-            // has disappeared! Skip it.
-          } finally {
-            snapshot.close();
-          }
-        }
-
-        return false;
-      }
-
-      @Override public String next() {
-        if (!hasNext()) throw new NoSuchElementException();
-        String result = nextUrl;
-        nextUrl = null;
-        canRemove = true;
-        return result;
-      }
-
-      @Override public void remove() {
-        if (!canRemove) throw new IllegalStateException("remove() before next()");
-        delegate.remove();
-      }
-    };
-  }
-
-  public synchronized int writeAbortCount() {
-    return writeAbortCount;
-  }
-
-  public synchronized int writeSuccessCount() {
-    return writeSuccessCount;
-  }
-
-  public long size() throws IOException {
-    return cache.size();
-  }
-
-  public long maxSize() {
-    return cache.getMaxSize();
-  }
-
-  @Override public void flush() throws IOException {
-    cache.flush();
-  }
-
-  @Override public void close() throws IOException {
-    cache.close();
-  }
-
-  public File directory() {
-    return cache.getDirectory();
-  }
-
-  public boolean isClosed() {
-    return cache.isClosed();
-  }
-
-  synchronized void trackResponse(CacheStrategy cacheStrategy) {
-    requestCount++;
-
-    if (cacheStrategy.networkRequest != null) {
-      // If this is a conditional request, we'll increment hitCount if/when it hits.
-      networkCount++;
-    } else if (cacheStrategy.cacheResponse != null) {
-      // This response uses the cache and not the network. That's a cache hit.
-      hitCount++;
-    }
-  }
-
-  synchronized void trackConditionalCacheHit() {
-    hitCount++;
-  }
-
-  public synchronized int networkCount() {
-    return networkCount;
-  }
-
-  public synchronized int hitCount() {
-    return hitCount;
-  }
-
-  public synchronized int requestCount() {
-    return requestCount;
-  }
-
-  private final class CacheRequestImpl implements CacheRequest {
-    private final DiskLruCache.Editor editor;
-    private Sink cacheOut;
-    private Sink body;
-    boolean done;
-
-    CacheRequestImpl(final DiskLruCache.Editor editor) {
-      this.editor = editor;
-      this.cacheOut = editor.newSink(ENTRY_BODY);
-      this.body = new ForwardingSink(cacheOut) {
-        @Override public void close() throws IOException {
-          synchronized (Cache.this) {
-            if (done) {
-              return;
-            }
-            done = true;
-            writeSuccessCount++;
-          }
-          super.close();
-          editor.commit();
-        }
-      };
-    }
-
-    @Override public void abort() {
-      synchronized (Cache.this) {
-        if (done) {
-          return;
-        }
-        done = true;
-        writeAbortCount++;
-      }
-      Util.closeQuietly(cacheOut);
-      try {
-        editor.abort();
-      } catch (IOException ignored) {
-      }
-    }
-
-    @Override public Sink body() {
-      return body;
-    }
-  }
-
-  private static final class Entry {
-    /** Synthetic response header: the local time when the request was sent. */
-    private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
-
-    /** Synthetic response header: the local time when the response was received. */
-    private static final String RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis";
-
-    private final String url;
-    private final Headers varyHeaders;
-    private final String requestMethod;
-    private final Protocol protocol;
-    private final int code;
-    private final String message;
-    private final Headers responseHeaders;
-    private final @Nullable Handshake handshake;
-    private final long sentRequestMillis;
-    private final long receivedResponseMillis;
-
-    /**
-     * Reads an entry from an input stream. A typical entry looks like this:
-     * <pre>{@code
-     *   http://google.com/foo
-     *   GET
-     *   2
-     *   Accept-Language: fr-CA
-     *   Accept-Charset: UTF-8
-     *   HTTP/1.1 200 OK
-     *   3
-     *   Content-Type: image/png
-     *   Content-Length: 100
-     *   Cache-Control: max-age=600
-     * }</pre>
-     *
-     * <p>A typical HTTPS file looks like this:
-     * <pre>{@code
-     *   https://google.com/foo
-     *   GET
-     *   2
-     *   Accept-Language: fr-CA
-     *   Accept-Charset: UTF-8
-     *   HTTP/1.1 200 OK
-     *   3
-     *   Content-Type: image/png
-     *   Content-Length: 100
-     *   Cache-Control: max-age=600
-     *
-     *   AES_256_WITH_MD5
-     *   2
-     *   base64-encoded peerCertificate[0]
-     *   base64-encoded peerCertificate[1]
-     *   -1
-     *   TLSv1.2
-     * }</pre>
-     * The file is newline separated. The first two lines are the URL and the request method. Next
-     * is the number of HTTP Vary request header lines, followed by those lines.
-     *
-     * <p>Next is the response status line, followed by the number of HTTP response header lines,
-     * followed by those lines.
-     *
-     * <p>HTTPS responses also contain SSL session information. This begins with a blank line, and
-     * then a line containing the cipher suite. Next is the length of the peer certificate chain.
-     * These certificates are base64-encoded and appear each on their own line. The next line
-     * contains the length of the local certificate chain. These certificates are also
-     * base64-encoded and appear each on their own line. A length of -1 is used to encode a null
-     * array. The last line is optional. If present, it contains the TLS version.
-     */
-    Entry(Source in) throws IOException {
-      try {
-        BufferedSource source = Okio.buffer(in);
-        url = source.readUtf8LineStrict();
-        requestMethod = source.readUtf8LineStrict();
-        Headers.Builder varyHeadersBuilder = new Headers.Builder();
-        int varyRequestHeaderLineCount = readInt(source);
-        for (int i = 0; i < varyRequestHeaderLineCount; i++) {
-          varyHeadersBuilder.addLenient(source.readUtf8LineStrict());
-        }
-        varyHeaders = varyHeadersBuilder.build();
-
-        StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
-        protocol = statusLine.protocol;
-        code = statusLine.code;
-        message = statusLine.message;
-        Headers.Builder responseHeadersBuilder = new Headers.Builder();
-        int responseHeaderLineCount = readInt(source);
-        for (int i = 0; i < responseHeaderLineCount; i++) {
-          responseHeadersBuilder.addLenient(source.readUtf8LineStrict());
-        }
-        String sendRequestMillisString = responseHeadersBuilder.get(SENT_MILLIS);
-        String receivedResponseMillisString = responseHeadersBuilder.get(RECEIVED_MILLIS);
-        responseHeadersBuilder.removeAll(SENT_MILLIS);
-        responseHeadersBuilder.removeAll(RECEIVED_MILLIS);
-        sentRequestMillis = sendRequestMillisString != null
-            ? Long.parseLong(sendRequestMillisString)
-            : 0L;
-        receivedResponseMillis = receivedResponseMillisString != null
-            ? Long.parseLong(receivedResponseMillisString)
-            : 0L;
-        responseHeaders = responseHeadersBuilder.build();
-
-        if (isHttps()) {
-          String blank = source.readUtf8LineStrict();
-          if (blank.length() > 0) {
-            throw new IOException("expected \"\" but was \"" + blank + "\"");
-          }
-          String cipherSuiteString = source.readUtf8LineStrict();
-          CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-          List<Certificate> peerCertificates = readCertificateList(source);
-          List<Certificate> localCertificates = readCertificateList(source);
-          TlsVersion tlsVersion = !source.exhausted()
-              ? TlsVersion.forJavaName(source.readUtf8LineStrict())
-              : TlsVersion.SSL_3_0;
-          handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);
-        } else {
-          handshake = null;
-        }
-      } finally {
-        in.close();
-      }
-    }
-
-    Entry(Response response) {
-      this.url = response.request().url().toString();
-      this.varyHeaders = HttpHeaders.varyHeaders(response);
-      this.requestMethod = response.request().method();
-      this.protocol = response.protocol();
-      this.code = response.code();
-      this.message = response.message();
-      this.responseHeaders = response.headers();
-      this.handshake = response.handshake();
-      this.sentRequestMillis = response.sentRequestAtMillis();
-      this.receivedResponseMillis = response.receivedResponseAtMillis();
-    }
-
-    public void writeTo(DiskLruCache.Editor editor) throws IOException {
-      BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
-
-      sink.writeUtf8(url)
-          .writeByte('\n');
-      sink.writeUtf8(requestMethod)
-          .writeByte('\n');
-      sink.writeDecimalLong(varyHeaders.size())
-          .writeByte('\n');
-      for (int i = 0, size = varyHeaders.size(); i < size; i++) {
-        sink.writeUtf8(varyHeaders.name(i))
-            .writeUtf8(": ")
-            .writeUtf8(varyHeaders.value(i))
-            .writeByte('\n');
-      }
-
-      sink.writeUtf8(new StatusLine(protocol, code, message).toString())
-          .writeByte('\n');
-      sink.writeDecimalLong(responseHeaders.size() + 2)
-          .writeByte('\n');
-      for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-        sink.writeUtf8(responseHeaders.name(i))
-            .writeUtf8(": ")
-            .writeUtf8(responseHeaders.value(i))
-            .writeByte('\n');
-      }
-      sink.writeUtf8(SENT_MILLIS)
-          .writeUtf8(": ")
-          .writeDecimalLong(sentRequestMillis)
-          .writeByte('\n');
-      sink.writeUtf8(RECEIVED_MILLIS)
-          .writeUtf8(": ")
-          .writeDecimalLong(receivedResponseMillis)
-          .writeByte('\n');
-
-      if (isHttps()) {
-        sink.writeByte('\n');
-        sink.writeUtf8(handshake.cipherSuite().javaName())
-            .writeByte('\n');
-        writeCertList(sink, handshake.peerCertificates());
-        writeCertList(sink, handshake.localCertificates());
-        sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte('\n');
-      }
-      sink.close();
-    }
-
-    private boolean isHttps() {
-      return url.startsWith("https://");
-    }
-
-    private List<Certificate> readCertificateList(BufferedSource source) throws IOException {
-      int length = readInt(source);
-      if (length == -1) return Collections.emptyList(); // OkHttp v1.2 used -1 to indicate null.
-
-      try {
-        CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-        List<Certificate> result = new ArrayList<>(length);
-        for (int i = 0; i < length; i++) {
-          String line = source.readUtf8LineStrict();
-          Buffer bytes = new Buffer();
-          bytes.write(ByteString.decodeBase64(line));
-          result.add(certificateFactory.generateCertificate(bytes.inputStream()));
-        }
-        return result;
-      } catch (CertificateException e) {
-        throw new IOException(e.getMessage());
-      }
-    }
-
-    private void writeCertList(BufferedSink sink, List<Certificate> certificates)
-        throws IOException {
-      try {
-        sink.writeDecimalLong(certificates.size())
-            .writeByte('\n');
-        for (int i = 0, size = certificates.size(); i < size; i++) {
-          byte[] bytes = certificates.get(i).getEncoded();
-          String line = ByteString.of(bytes).base64();
-          sink.writeUtf8(line)
-              .writeByte('\n');
-        }
-      } catch (CertificateEncodingException e) {
-        throw new IOException(e.getMessage());
-      }
-    }
-
-    public boolean matches(Request request, Response response) {
-      return url.equals(request.url().toString())
-          && requestMethod.equals(request.method())
-          && HttpHeaders.varyMatches(response, varyHeaders, request);
-    }
-
-    public Response response(DiskLruCache.Snapshot snapshot) {
-      String contentType = responseHeaders.get("Content-Type");
-      String contentLength = responseHeaders.get("Content-Length");
-      Request cacheRequest = new Request.Builder()
-          .url(url)
-          .method(requestMethod, null)
-          .headers(varyHeaders)
-          .build();
-      return new Response.Builder()
-          .request(cacheRequest)
-          .protocol(protocol)
-          .code(code)
-          .message(message)
-          .headers(responseHeaders)
-          .body(new CacheResponseBody(snapshot, contentType, contentLength))
-          .handshake(handshake)
-          .sentRequestAtMillis(sentRequestMillis)
-          .receivedResponseAtMillis(receivedResponseMillis)
-          .build();
-    }
-  }
-
-  static int readInt(BufferedSource source) throws IOException {
-    try {
-      long result = source.readDecimalLong();
-      String line = source.readUtf8LineStrict();
-      if (result < 0 || result > Integer.MAX_VALUE || !line.isEmpty()) {
-        throw new IOException("expected an int but was \"" + result + line + "\"");
-      }
-      return (int) result;
-    } catch (NumberFormatException e) {
-      throw new IOException(e.getMessage());
-    }
-  }
-
-  private static class CacheResponseBody extends ResponseBody {
-    final DiskLruCache.Snapshot snapshot;
-    private final BufferedSource bodySource;
-    private final @Nullable String contentType;
-    private final @Nullable String contentLength;
-
-    CacheResponseBody(final DiskLruCache.Snapshot snapshot,
-        String contentType, String contentLength) {
-      this.snapshot = snapshot;
-      this.contentType = contentType;
-      this.contentLength = contentLength;
-
-      Source source = snapshot.getSource(ENTRY_BODY);
-      bodySource = Okio.buffer(new ForwardingSource(source) {
-        @Override public void close() throws IOException {
-          snapshot.close();
-          super.close();
-        }
-      });
-    }
-
-    @Override public MediaType contentType() {
-      return contentType != null ? MediaType.parse(contentType) : null;
-    }
-
-    @Override public long contentLength() {
-      try {
-        return contentLength != null ? Long.parseLong(contentLength) : -1;
-      } catch (NumberFormatException e) {
-        return -1;
-      }
-    }
-
-    @Override public BufferedSource source() {
-      return bodySource;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Cache.kt b/okhttp/src/main/java/okhttp3/Cache.kt
new file mode 100644
index 0000000000..094f81f23f
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Cache.kt
@@ -0,0 +1,741 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.Util.closeQuietly
+import okhttp3.internal.addHeaderLenient
+import okhttp3.internal.cache.CacheRequest
+import okhttp3.internal.cache.CacheStrategy
+import okhttp3.internal.cache.DiskLruCache
+import okhttp3.internal.cache.InternalCache
+import okhttp3.internal.http.HttpHeaders
+import okhttp3.internal.http.HttpMethod
+import okhttp3.internal.http.StatusLine
+import okhttp3.internal.io.FileSystem
+import okhttp3.internal.platform.Platform
+import okio.buffer
+import okio.Buffer
+import okio.BufferedSink
+import okio.BufferedSource
+import okio.ByteString
+import okio.ByteString.Companion.decodeBase64
+import okio.ByteString.Companion.encodeUtf8
+import okio.ForwardingSink
+import okio.ForwardingSource
+import okio.Sink
+import okio.Source
+import java.io.Closeable
+import java.io.File
+import java.io.Flushable
+import java.io.IOException
+import java.security.cert.Certificate
+import java.security.cert.CertificateEncodingException
+import java.security.cert.CertificateException
+import java.security.cert.CertificateFactory
+import java.util.ArrayList
+import java.util.NoSuchElementException
+
+/**
+ * Caches HTTP and HTTPS responses to the filesystem so they may be reused, saving time and
+ * bandwidth.
+ *
+ * ## Cache Optimization
+ *
+ * To measure cache effectiveness, this class tracks three statistics:
+ *
+ *  * **[Request Count:][requestCount]** the number of HTTP requests issued since this cache was
+ *    created.
+ *  * **[Network Count:][networkCount]** the number of those requests that required network use.
+ *  * **[Hit Count:][hitCount]** the number of those requests whose responses were served by the
+ *    cache.
+ *
+ * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of
+ * the response, the client will issue a conditional `GET`. The server will then send either
+ * the updated response if it has changed, or a short 'not modified' response if the client's copy
+ * is still valid. Such responses increment both the network count and hit count.
+ *
+ * The best way to improve the cache hit rate is by configuring the web server to return cacheable
+ * responses. Although this client honors all [HTTP/1.1 (RFC 7234)][rfc_7234] cache headers, it
+ * doesn't cache partial responses.
+ *
+ * ## Force a Network Response
+ *
+ * In some situations, such as after a user clicks a 'refresh' button, it may be necessary to skip
+ * the cache, and fetch data directly from the server. To force a full refresh, add the `no-cache`
+ * directive:
+ *
+ * ```
+ * Request request = new Request.Builder()
+ *     .cacheControl(new CacheControl.Builder().noCache().build())
+ *     .url("http://publicobject.com/helloworld.txt")
+ *     .build();
+ * ```
+ *
+ * If it is only necessary to force a cached response to be validated by the server, use the more
+ * efficient `max-age=0` directive instead:
+ *
+ * ```
+ * Request request = new Request.Builder()
+ *     .cacheControl(new CacheControl.Builder()
+ *         .maxAge(0, TimeUnit.SECONDS)
+ *         .build())
+ *     .url("http://publicobject.com/helloworld.txt")
+ *     .build();
+ * ```
+ *
+ * ## Force a Cache Response
+ *
+ * Sometimes you'll want to show resources if they are available immediately, but not otherwise.
+ * This can be used so your application can show *something* while waiting for the latest data to be
+ * downloaded. To restrict a request to locally-cached resources, add the `only-if-cached`
+ * directive:
+ *
+ * ```
+ * Request request = new Request.Builder()
+ *     .cacheControl(new CacheControl.Builder()
+ *         .onlyIfCached()
+ *         .build())
+ *     .url("http://publicobject.com/helloworld.txt")
+ *     .build();
+ * Response forceCacheResponse = client.newCall(request).execute();
+ * if (forceCacheResponse.code() != 504) {
+ *   // The resource was cached! Show it.
+ * } else {
+ *   // The resource was not cached.
+ * }
+ * ```
+ *
+ * This technique works even better in situations where a stale response is better than no response.
+ * To permit stale cached responses, use the `max-stale` directive with the maximum staleness in
+ * seconds:
+ *
+ * ```
+ * Request request = new Request.Builder()
+ *     .cacheControl(new CacheControl.Builder()
+ *         .maxStale(365, TimeUnit.DAYS)
+ *         .build())
+ *     .url("http://publicobject.com/helloworld.txt")
+ *     .build();
+ * ```
+ *
+ * The [CacheControl] class can configure request caching directives and parse response caching
+ * directives. It even offers convenient constants [CacheControl.FORCE_NETWORK] and
+ * [CacheControl.FORCE_CACHE] that address the use cases above.
+ *
+ * [rfc_7234]: http://tools.ietf.org/html/rfc7234
+ */
+class Cache internal constructor(
+  directory: File,
+  maxSize: Long,
+  fileSystem: FileSystem
+) : Closeable, Flushable {
+  internal val internalCache: InternalCache = object : InternalCache {
+    override fun get(request: Request): Response? {
+      return this@Cache.get(request)
+    }
+
+    override fun put(response: Response): CacheRequest? {
+      return this@Cache.put(response)
+    }
+
+    override fun remove(request: Request) {
+      this@Cache.remove(request)
+    }
+
+    override fun update(cached: Response, network: Response) {
+      this@Cache.update(cached, network)
+    }
+
+    override fun trackConditionalCacheHit() {
+      this@Cache.trackConditionalCacheHit()
+    }
+
+    override fun trackResponse(cacheStrategy: CacheStrategy) {
+      this@Cache.trackResponse(cacheStrategy)
+    }
+  }
+
+  internal val cache: DiskLruCache
+
+  // read and write statistics, all guarded by 'this'.
+  internal var writeSuccessCount: Int = 0
+  internal var writeAbortCount: Int = 0
+  private var networkCount: Int = 0
+  private var hitCount: Int = 0
+  private var requestCount: Int = 0
+
+  val isClosed: Boolean get() = cache.isClosed
+
+  /** Create a cache of at most `maxSize` bytes in `directory`. */
+  constructor(directory: File, maxSize: Long) : this(directory, maxSize, FileSystem.SYSTEM)
+
+  init {
+    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize)
+  }
+
+  internal fun get(request: Request): Response? {
+    val key = key(request.url())
+    val snapshot: DiskLruCache.Snapshot = try {
+      cache.get(key) ?: return null
+    } catch (e: IOException) {
+      return null // Give up because the cache cannot be read.
+    }
+
+    val entry: Entry = try {
+      Entry(snapshot.getSource(ENTRY_METADATA))
+    } catch (e: IOException) {
+      closeQuietly(snapshot)
+      return null
+    }
+
+    val response = entry.response(snapshot)
+    if (!entry.matches(request, response)) {
+      closeQuietly(response.body())
+      return null
+    }
+
+    return response
+  }
+
+  internal fun put(response: Response): CacheRequest? {
+    val requestMethod = response.request().method()
+
+    if (HttpMethod.invalidatesCache(response.request().method())) {
+      try {
+        remove(response.request())
+      } catch (ignored: IOException) {
+        // The cache cannot be written.
+      }
+      return null
+    }
+
+    if (requestMethod != "GET") {
+      // Don't cache non-GET responses. We're technically allowed to cache HEAD requests and some
+      // POST requests, but the complexity of doing so is high and the benefit is low.
+      return null
+    }
+
+    if (HttpHeaders.hasVaryAll(response)) {
+      return null
+    }
+
+    val entry = Entry(response)
+    var editor: DiskLruCache.Editor? = null
+    try {
+      editor = cache.edit(key(response.request().url())) ?: return null
+      entry.writeTo(editor)
+      return RealCacheRequest(editor)
+    } catch (e: IOException) {
+      abortQuietly(editor)
+      return null
+    }
+  }
+
+  @Throws(IOException::class)
+  internal fun remove(request: Request) {
+    cache.remove(key(request.url()))
+  }
+
+  internal fun update(cached: Response, network: Response) {
+    val entry = Entry(network)
+    val snapshot = (cached.body() as CacheResponseBody).snapshot
+    var editor: DiskLruCache.Editor? = null
+    try {
+      editor = snapshot.edit() // Returns null if snapshot is not current.
+      if (editor != null) {
+        entry.writeTo(editor)
+        editor.commit()
+      }
+    } catch (e: IOException) {
+      abortQuietly(editor)
+    }
+  }
+
+  private fun abortQuietly(editor: DiskLruCache.Editor?) {
+    // Give up because the cache cannot be written.
+    try {
+      editor?.abort()
+    } catch (ignored: IOException) {
+    }
+  }
+
+  /**
+   * Initialize the cache. This will include reading the journal files from the storage and building
+   * up the necessary in-memory cache information.
+   *
+   * The initialization time may vary depending on the journal file size and the current actual
+   * cache size. The application needs to be aware of calling this function during the
+   * initialization phase and preferably in a background worker thread.
+   *
+   * Note that if the application chooses to not call this method to initialize the cache. By
+   * default, OkHttp will perform lazy initialization upon the first usage of the cache.
+   */
+  @Throws(IOException::class)
+  fun initialize() {
+    cache.initialize()
+  }
+
+  /**
+   * Closes the cache and deletes all of its stored values. This will delete all files in the cache
+   * directory including files that weren't created by the cache.
+   */
+  @Throws(IOException::class)
+  fun delete() {
+    cache.delete()
+  }
+
+  /**
+   * Deletes all values stored in the cache. In-flight writes to the cache will complete normally,
+   * but the corresponding responses will not be stored.
+   */
+  @Throws(IOException::class)
+  fun evictAll() {
+    cache.evictAll()
+  }
+
+  /**
+   * Returns an iterator over the URLs in this cache. This iterator doesn't throw
+   * `ConcurrentModificationException`, but if new responses are added while iterating, their URLs
+   * will not be returned. If existing responses are evicted during iteration, they will be absent
+   * (unless they were already returned).
+   *
+   * The iterator supports [MutableIterator.remove]. Removing a URL from the iterator evicts the
+   * corresponding response from the cache. Use this to evict selected responses.
+   */
+  @Throws(IOException::class)
+  fun urls(): MutableIterator<String> {
+    return object : MutableIterator<String> {
+      val delegate: MutableIterator<DiskLruCache.Snapshot> = cache.snapshots()
+      var nextUrl: String? = null
+      var canRemove: Boolean = false
+
+      override fun hasNext(): Boolean {
+        if (nextUrl != null) return true
+
+        canRemove = false // Prevent delegate.remove() on the wrong item!
+        while (delegate.hasNext()) {
+          try {
+            delegate.next().use { snapshot ->
+              val metadata = snapshot.getSource(ENTRY_METADATA).buffer()
+              nextUrl = metadata.readUtf8LineStrict()
+              return true
+            }
+          } catch (ignored: IOException) {
+            // We couldn't read the metadata for this snapshot; possibly because the host filesystem
+            // has disappeared! Skip it.
+          }
+        }
+
+        return false
+      }
+
+      override fun next(): String {
+        if (!hasNext()) throw NoSuchElementException()
+        val result = nextUrl!!
+        nextUrl = null
+        canRemove = true
+        return result
+      }
+
+      override fun remove() {
+        if (!canRemove) throw IllegalStateException("remove() before next()")
+        delegate.remove()
+      }
+    }
+  }
+
+  @Synchronized fun writeAbortCount(): Int = writeAbortCount
+
+  @Synchronized fun writeSuccessCount(): Int = writeSuccessCount
+
+  @Throws(IOException::class)
+  fun size(): Long = cache.size()
+
+  /** Max size of the cache (in bytes).  */
+  fun maxSize(): Long = cache.maxSize
+
+  @Throws(IOException::class)
+  override fun flush() {
+    cache.flush()
+  }
+
+  @Throws(IOException::class)
+  override fun close() {
+    cache.close()
+  }
+
+  fun directory(): File = cache.directory
+
+  @Synchronized internal fun trackResponse(cacheStrategy: CacheStrategy) {
+    requestCount++
+
+    if (cacheStrategy.networkRequest != null) {
+      // If this is a conditional request, we'll increment hitCount if/when it hits.
+      networkCount++
+    } else if (cacheStrategy.cacheResponse != null) {
+      // This response uses the cache and not the network. That's a cache hit.
+      hitCount++
+    }
+  }
+
+  @Synchronized internal fun trackConditionalCacheHit() {
+    hitCount++
+  }
+
+  @Synchronized fun networkCount(): Int = networkCount
+
+  @Synchronized fun hitCount(): Int = hitCount
+
+  @Synchronized fun requestCount(): Int = requestCount
+
+  private inner class RealCacheRequest internal constructor(
+    private val editor: DiskLruCache.Editor
+  ) : CacheRequest {
+    private val cacheOut: Sink = editor.newSink(ENTRY_BODY)
+    private val body: Sink
+    internal var done: Boolean = false
+
+    init {
+      this.body = object : ForwardingSink(cacheOut) {
+        @Throws(IOException::class)
+        override fun close() {
+          synchronized(this@Cache) {
+            if (done) return
+            done = true
+            writeSuccessCount++
+          }
+          super.close()
+          editor.commit()
+        }
+      }
+    }
+
+    override fun abort() {
+      synchronized(this@Cache) {
+        if (done) return
+        done = true
+        writeAbortCount++
+      }
+      closeQuietly(cacheOut)
+      try {
+        editor.abort()
+      } catch (ignored: IOException) {
+      }
+    }
+
+    override fun body(): Sink = body
+  }
+
+  private class Entry {
+    private val url: String
+    private val varyHeaders: Headers
+    private val requestMethod: String
+    private val protocol: Protocol
+    private val code: Int
+    private val message: String
+    private val responseHeaders: Headers
+    private val handshake: Handshake?
+    private val sentRequestMillis: Long
+    private val receivedResponseMillis: Long
+
+    private val isHttps: Boolean get() = url.startsWith("https://")
+
+    /**
+     * Reads an entry from an input stream. A typical entry looks like this:
+     *
+     * ```
+     * http://google.com/foo
+     * GET
+     * 2
+     * Accept-Language: fr-CA
+     * Accept-Charset: UTF-8
+     * HTTP/1.1 200 OK
+     * 3
+     * Content-Type: image/png
+     * Content-Length: 100
+     * Cache-Control: max-age=600
+     * ```
+     *
+     * A typical HTTPS file looks like this:
+     *
+     * ```
+     * https://google.com/foo
+     * GET
+     * 2
+     * Accept-Language: fr-CA
+     * Accept-Charset: UTF-8
+     * HTTP/1.1 200 OK
+     * 3
+     * Content-Type: image/png
+     * Content-Length: 100
+     * Cache-Control: max-age=600
+     *
+     * AES_256_WITH_MD5
+     * 2
+     * base64-encoded peerCertificate[0]
+     * base64-encoded peerCertificate[1]
+     * -1
+     * TLSv1.2
+     * ```
+     *
+     * The file is newline separated. The first two lines are the URL and the request method. Next
+     * is the number of HTTP Vary request header lines, followed by those lines.
+     *
+     * Next is the response status line, followed by the number of HTTP response header lines,
+     * followed by those lines.
+     *
+     * HTTPS responses also contain SSL session information. This begins with a blank line, and then
+     * a line containing the cipher suite. Next is the length of the peer certificate chain. These
+     * certificates are base64-encoded and appear each on their own line. The next line contains the
+     * length of the local certificate chain. These certificates are also base64-encoded and appear
+     * each on their own line. A length of -1 is used to encode a null array. The last line is
+     * optional. If present, it contains the TLS version.
+     */
+    @Throws(IOException::class)
+    internal constructor(rawSource: Source) {
+      try {
+        val source = rawSource.buffer()
+        url = source.readUtf8LineStrict()
+        requestMethod = source.readUtf8LineStrict()
+        val varyHeadersBuilder = Headers.Builder()
+        val varyRequestHeaderLineCount = readInt(source)
+        for (i in 0 until varyRequestHeaderLineCount) {
+          addHeaderLenient(varyHeadersBuilder, source.readUtf8LineStrict())
+        }
+        varyHeaders = varyHeadersBuilder.build()
+
+        val statusLine = StatusLine.parse(source.readUtf8LineStrict())
+        protocol = statusLine.protocol
+        code = statusLine.code
+        message = statusLine.message
+        val responseHeadersBuilder = Headers.Builder()
+        val responseHeaderLineCount = readInt(source)
+        for (i in 0 until responseHeaderLineCount) {
+          addHeaderLenient(responseHeadersBuilder, source.readUtf8LineStrict())
+        }
+        val sendRequestMillisString = responseHeadersBuilder[SENT_MILLIS]
+        val receivedResponseMillisString = responseHeadersBuilder[RECEIVED_MILLIS]
+        responseHeadersBuilder.removeAll(SENT_MILLIS)
+        responseHeadersBuilder.removeAll(RECEIVED_MILLIS)
+        sentRequestMillis = sendRequestMillisString?.toLong() ?: 0L
+        receivedResponseMillis = receivedResponseMillisString?.toLong() ?: 0L
+        responseHeaders = responseHeadersBuilder.build()
+
+        if (isHttps) {
+          val blank = source.readUtf8LineStrict()
+          if (blank.isNotEmpty()) {
+            throw IOException("expected \"\" but was \"$blank\"")
+          }
+          val cipherSuiteString = source.readUtf8LineStrict()
+          val cipherSuite = CipherSuite.forJavaName(cipherSuiteString)
+          val peerCertificates = readCertificateList(source)
+          val localCertificates = readCertificateList(source)
+          val tlsVersion = if (!source.exhausted()) {
+            TlsVersion.forJavaName(source.readUtf8LineStrict())
+          } else {
+            TlsVersion.SSL_3_0
+          }
+          handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates)
+        } else {
+          handshake = null
+        }
+      } finally {
+        rawSource.close()
+      }
+    }
+
+    internal constructor(response: Response) {
+      this.url = response.request().url().toString()
+      this.varyHeaders = HttpHeaders.varyHeaders(response)
+      this.requestMethod = response.request().method()
+      this.protocol = response.protocol()
+      this.code = response.code()
+      this.message = response.message()
+      this.responseHeaders = response.headers()
+      this.handshake = response.handshake()
+      this.sentRequestMillis = response.sentRequestAtMillis()
+      this.receivedResponseMillis = response.receivedResponseAtMillis()
+    }
+
+    @Throws(IOException::class)
+    fun writeTo(editor: DiskLruCache.Editor) {
+      val sink = editor.newSink(ENTRY_METADATA).buffer()
+      sink.writeUtf8(url).writeByte('\n'.toInt())
+      sink.writeUtf8(requestMethod).writeByte('\n'.toInt())
+      sink.writeDecimalLong(varyHeaders.size().toLong()).writeByte('\n'.toInt())
+      for (i in 0 until varyHeaders.size()) {
+        sink.writeUtf8(varyHeaders.name(i))
+            .writeUtf8(": ")
+            .writeUtf8(varyHeaders.value(i))
+            .writeByte('\n'.toInt())
+      }
+
+      sink.writeUtf8(StatusLine(protocol, code, message).toString()).writeByte('\n'.toInt())
+      sink.writeDecimalLong((responseHeaders.size() + 2).toLong()).writeByte('\n'.toInt())
+      for (i in 0 until responseHeaders.size()) {
+        sink.writeUtf8(responseHeaders.name(i))
+            .writeUtf8(": ")
+            .writeUtf8(responseHeaders.value(i))
+            .writeByte('\n'.toInt())
+      }
+      sink.writeUtf8(SENT_MILLIS)
+          .writeUtf8(": ")
+          .writeDecimalLong(sentRequestMillis)
+          .writeByte('\n'.toInt())
+      sink.writeUtf8(RECEIVED_MILLIS)
+          .writeUtf8(": ")
+          .writeDecimalLong(receivedResponseMillis)
+          .writeByte('\n'.toInt())
+
+      if (isHttps) {
+        sink.writeByte('\n'.toInt())
+        sink.writeUtf8(handshake!!.cipherSuite().javaName()).writeByte('\n'.toInt())
+        writeCertList(sink, handshake.peerCertificates())
+        writeCertList(sink, handshake.localCertificates())
+        sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte('\n'.toInt())
+      }
+      sink.close()
+    }
+
+    @Throws(IOException::class)
+    private fun readCertificateList(source: BufferedSource): List<Certificate> {
+      val length = readInt(source)
+      if (length == -1) return emptyList() // OkHttp v1.2 used -1 to indicate null.
+
+      try {
+        val certificateFactory = CertificateFactory.getInstance("X.509")
+        val result = ArrayList<Certificate>(length)
+        for (i in 0 until length) {
+          val line = source.readUtf8LineStrict()
+          val bytes = Buffer()
+          bytes.write(line.decodeBase64()!!)
+          result.add(certificateFactory.generateCertificate(bytes.inputStream()))
+        }
+        return result
+      } catch (e: CertificateException) {
+        throw IOException(e.message)
+      }
+    }
+
+    @Throws(IOException::class)
+    private fun writeCertList(sink: BufferedSink, certificates: List<Certificate>) {
+      try {
+        sink.writeDecimalLong(certificates.size.toLong()).writeByte('\n'.toInt())
+        for (i in 0 until certificates.size) {
+          val bytes = certificates[i].encoded
+          val line = ByteString.of(*bytes).base64()
+          sink.writeUtf8(line).writeByte('\n'.toInt())
+        }
+      } catch (e: CertificateEncodingException) {
+        throw IOException(e.message)
+      }
+
+    }
+
+    fun matches(request: Request, response: Response): Boolean {
+      return url == request.url().toString()
+          && requestMethod == request.method()
+          && HttpHeaders.varyMatches(response, varyHeaders, request)
+    }
+
+    fun response(snapshot: DiskLruCache.Snapshot): Response {
+      val contentType = responseHeaders["Content-Type"]
+      val contentLength = responseHeaders["Content-Length"]
+      val cacheRequest = Request.Builder()
+          .url(url)
+          .method(requestMethod, null)
+          .headers(varyHeaders)
+          .build()
+      return Response.Builder()
+          .request(cacheRequest)
+          .protocol(protocol)
+          .code(code)
+          .message(message)
+          .headers(responseHeaders)
+          .body(CacheResponseBody(snapshot, contentType, contentLength))
+          .handshake(handshake)
+          .sentRequestAtMillis(sentRequestMillis)
+          .receivedResponseAtMillis(receivedResponseMillis)
+          .build()
+    }
+
+    companion object {
+      /** Synthetic response header: the local time when the request was sent.  */
+      private val SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis"
+
+      /** Synthetic response header: the local time when the response was received.  */
+      private val RECEIVED_MILLIS = Platform.get().getPrefix() + "-Received-Millis"
+    }
+  }
+
+  private class CacheResponseBody internal constructor(
+    internal val snapshot: DiskLruCache.Snapshot,
+    private val contentType: String?,
+    private val contentLength: String?
+  ) : ResponseBody() {
+    private val bodySource: BufferedSource
+
+    init {
+      val source = snapshot.getSource(ENTRY_BODY)
+      bodySource = object : ForwardingSource(source) {
+        @Throws(IOException::class)
+        override fun close() {
+          snapshot.close()
+          super.close()
+        }
+      }.buffer()
+    }
+
+    override fun contentType(): MediaType? {
+      return if (contentType != null) MediaType.parse(contentType) else null
+    }
+
+    override fun contentLength(): Long {
+      return try {
+        contentLength?.toLong() ?: -1
+      } catch (e: NumberFormatException) {
+        -1L
+      }
+    }
+
+    override fun source(): BufferedSource = bodySource
+  }
+
+  companion object {
+    private const val VERSION = 201105
+    private const val ENTRY_METADATA = 0
+    private const val ENTRY_BODY = 1
+    private const val ENTRY_COUNT = 2
+
+    @JvmStatic
+    fun key(url: HttpUrl): String = url.toString().encodeUtf8().md5().hex()
+
+    @Throws(IOException::class)
+    @JvmStatic
+    internal fun readInt(source: BufferedSource): Int {
+      try {
+        val result = source.readDecimalLong()
+        val line = source.readUtf8LineStrict()
+        if (result < 0 || result > Integer.MAX_VALUE || !line.isEmpty()) {
+          throw IOException("expected an int but was \"$result$line\"")
+        }
+        return result.toInt()
+      } catch (e: NumberFormatException) {
+        throw IOException(e.message)
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/CacheControl.java b/okhttp/src/main/java/okhttp3/CacheControl.java
deleted file mode 100644
index a32add5f97..0000000000
--- a/okhttp/src/main/java/okhttp3/CacheControl.java
+++ /dev/null
@@ -1,373 +0,0 @@
-package okhttp3;
-
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.internal.http.HttpHeaders;
-
-/**
- * A Cache-Control header with cache directives from a server or client. These directives set policy
- * on what responses can be stored, and which requests can be satisfied by those stored responses.
- *
- * <p>See <a href="https://tools.ietf.org/html/rfc7234#section-5.2">RFC 7234, 5.2</a>.
- */
-public final class CacheControl {
-  /**
-   * Cache control request directives that require network validation of responses. Note that such
-   * requests may be assisted by the cache via conditional GET requests.
-   */
-  public static final CacheControl FORCE_NETWORK = new Builder().noCache().build();
-
-  /**
-   * Cache control request directives that uses the cache only, even if the cached response is
-   * stale. If the response isn't available in the cache or requires server validation, the call
-   * will fail with a {@code 504 Unsatisfiable Request}.
-   */
-  public static final CacheControl FORCE_CACHE = new Builder()
-      .onlyIfCached()
-      .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)
-      .build();
-
-  private final boolean noCache;
-  private final boolean noStore;
-  private final int maxAgeSeconds;
-  private final int sMaxAgeSeconds;
-  private final boolean isPrivate;
-  private final boolean isPublic;
-  private final boolean mustRevalidate;
-  private final int maxStaleSeconds;
-  private final int minFreshSeconds;
-  private final boolean onlyIfCached;
-  private final boolean noTransform;
-  private final boolean immutable;
-
-  @Nullable String headerValue; // Lazily computed, null if absent.
-
-  private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
-      boolean isPrivate, boolean isPublic, boolean mustRevalidate, int maxStaleSeconds,
-      int minFreshSeconds, boolean onlyIfCached, boolean noTransform, boolean immutable,
-      @Nullable String headerValue) {
-    this.noCache = noCache;
-    this.noStore = noStore;
-    this.maxAgeSeconds = maxAgeSeconds;
-    this.sMaxAgeSeconds = sMaxAgeSeconds;
-    this.isPrivate = isPrivate;
-    this.isPublic = isPublic;
-    this.mustRevalidate = mustRevalidate;
-    this.maxStaleSeconds = maxStaleSeconds;
-    this.minFreshSeconds = minFreshSeconds;
-    this.onlyIfCached = onlyIfCached;
-    this.noTransform = noTransform;
-    this.immutable = immutable;
-    this.headerValue = headerValue;
-  }
-
-  CacheControl(Builder builder) {
-    this.noCache = builder.noCache;
-    this.noStore = builder.noStore;
-    this.maxAgeSeconds = builder.maxAgeSeconds;
-    this.sMaxAgeSeconds = -1;
-    this.isPrivate = false;
-    this.isPublic = false;
-    this.mustRevalidate = false;
-    this.maxStaleSeconds = builder.maxStaleSeconds;
-    this.minFreshSeconds = builder.minFreshSeconds;
-    this.onlyIfCached = builder.onlyIfCached;
-    this.noTransform = builder.noTransform;
-    this.immutable = builder.immutable;
-  }
-
-  /**
-   * In a response, this field's name "no-cache" is misleading. It doesn't prevent us from caching
-   * the response; it only means we have to validate the response with the origin server before
-   * returning it. We can do this with a conditional GET.
-   *
-   * <p>In a request, it means do not use a cache to satisfy the request.
-   */
-  public boolean noCache() {
-    return noCache;
-  }
-
-  /** If true, this response should not be cached. */
-  public boolean noStore() {
-    return noStore;
-  }
-
-  /**
-   * The duration past the response's served date that it can be served without validation.
-   */
-  public int maxAgeSeconds() {
-    return maxAgeSeconds;
-  }
-
-  /**
-   * The "s-maxage" directive is the max age for shared caches. Not to be confused with "max-age"
-   * for non-shared caches, As in Firefox and Chrome, this directive is not honored by this cache.
-   */
-  public int sMaxAgeSeconds() {
-    return sMaxAgeSeconds;
-  }
-
-  public boolean isPrivate() {
-    return isPrivate;
-  }
-
-  public boolean isPublic() {
-    return isPublic;
-  }
-
-  public boolean mustRevalidate() {
-    return mustRevalidate;
-  }
-
-  public int maxStaleSeconds() {
-    return maxStaleSeconds;
-  }
-
-  public int minFreshSeconds() {
-    return minFreshSeconds;
-  }
-
-  /**
-   * This field's name "only-if-cached" is misleading. It actually means "do not use the network".
-   * It is set by a client who only wants to make a request if it can be fully satisfied by the
-   * cache. Cached responses that would require validation (ie. conditional gets) are not permitted
-   * if this header is set.
-   */
-  public boolean onlyIfCached() {
-    return onlyIfCached;
-  }
-
-  public boolean noTransform() {
-    return noTransform;
-  }
-
-  public boolean immutable() {
-    return immutable;
-  }
-
-  /**
-   * Returns the cache directives of {@code headers}. This honors both Cache-Control and Pragma
-   * headers if they are present.
-   */
-  public static CacheControl parse(Headers headers) {
-    boolean noCache = false;
-    boolean noStore = false;
-    int maxAgeSeconds = -1;
-    int sMaxAgeSeconds = -1;
-    boolean isPrivate = false;
-    boolean isPublic = false;
-    boolean mustRevalidate = false;
-    int maxStaleSeconds = -1;
-    int minFreshSeconds = -1;
-    boolean onlyIfCached = false;
-    boolean noTransform = false;
-    boolean immutable = false;
-
-    boolean canUseHeaderValue = true;
-    String headerValue = null;
-
-    for (int i = 0, size = headers.size(); i < size; i++) {
-      String name = headers.name(i);
-      String value = headers.value(i);
-
-      if (name.equalsIgnoreCase("Cache-Control")) {
-        if (headerValue != null) {
-          // Multiple cache-control headers means we can't use the raw value.
-          canUseHeaderValue = false;
-        } else {
-          headerValue = value;
-        }
-      } else if (name.equalsIgnoreCase("Pragma")) {
-        // Might specify additional cache-control params. We invalidate just in case.
-        canUseHeaderValue = false;
-      } else {
-        continue;
-      }
-
-      int pos = 0;
-      while (pos < value.length()) {
-        int tokenStart = pos;
-        pos = HttpHeaders.skipUntil(value, pos, "=,;");
-        String directive = value.substring(tokenStart, pos).trim();
-        String parameter;
-
-        if (pos == value.length() || value.charAt(pos) == ',' || value.charAt(pos) == ';') {
-          pos++; // consume ',' or ';' (if necessary)
-          parameter = null;
-        } else {
-          pos++; // consume '='
-          pos = HttpHeaders.skipWhitespace(value, pos);
-
-          // quoted string
-          if (pos < value.length() && value.charAt(pos) == '\"') {
-            pos++; // consume '"' open quote
-            int parameterStart = pos;
-            pos = HttpHeaders.skipUntil(value, pos, "\"");
-            parameter = value.substring(parameterStart, pos);
-            pos++; // consume '"' close quote (if necessary)
-
-            // unquoted string
-          } else {
-            int parameterStart = pos;
-            pos = HttpHeaders.skipUntil(value, pos, ",;");
-            parameter = value.substring(parameterStart, pos).trim();
-          }
-        }
-
-        if ("no-cache".equalsIgnoreCase(directive)) {
-          noCache = true;
-        } else if ("no-store".equalsIgnoreCase(directive)) {
-          noStore = true;
-        } else if ("max-age".equalsIgnoreCase(directive)) {
-          maxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1);
-        } else if ("s-maxage".equalsIgnoreCase(directive)) {
-          sMaxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1);
-        } else if ("private".equalsIgnoreCase(directive)) {
-          isPrivate = true;
-        } else if ("public".equalsIgnoreCase(directive)) {
-          isPublic = true;
-        } else if ("must-revalidate".equalsIgnoreCase(directive)) {
-          mustRevalidate = true;
-        } else if ("max-stale".equalsIgnoreCase(directive)) {
-          maxStaleSeconds = HttpHeaders.parseSeconds(parameter, Integer.MAX_VALUE);
-        } else if ("min-fresh".equalsIgnoreCase(directive)) {
-          minFreshSeconds = HttpHeaders.parseSeconds(parameter, -1);
-        } else if ("only-if-cached".equalsIgnoreCase(directive)) {
-          onlyIfCached = true;
-        } else if ("no-transform".equalsIgnoreCase(directive)) {
-          noTransform = true;
-        } else if ("immutable".equalsIgnoreCase(directive)) {
-          immutable = true;
-        }
-      }
-    }
-
-    if (!canUseHeaderValue) {
-      headerValue = null;
-    }
-    return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic,
-        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, immutable,
-        headerValue);
-  }
-
-  @Override public String toString() {
-    String result = headerValue;
-    return result != null ? result : (headerValue = headerValue());
-  }
-
-  private String headerValue() {
-    StringBuilder result = new StringBuilder();
-    if (noCache) result.append("no-cache, ");
-    if (noStore) result.append("no-store, ");
-    if (maxAgeSeconds != -1) result.append("max-age=").append(maxAgeSeconds).append(", ");
-    if (sMaxAgeSeconds != -1) result.append("s-maxage=").append(sMaxAgeSeconds).append(", ");
-    if (isPrivate) result.append("private, ");
-    if (isPublic) result.append("public, ");
-    if (mustRevalidate) result.append("must-revalidate, ");
-    if (maxStaleSeconds != -1) result.append("max-stale=").append(maxStaleSeconds).append(", ");
-    if (minFreshSeconds != -1) result.append("min-fresh=").append(minFreshSeconds).append(", ");
-    if (onlyIfCached) result.append("only-if-cached, ");
-    if (noTransform) result.append("no-transform, ");
-    if (immutable) result.append("immutable, ");
-    if (result.length() == 0) return "";
-    result.delete(result.length() - 2, result.length());
-    return result.toString();
-  }
-
-  /** Builds a {@code Cache-Control} request header. */
-  public static final class Builder {
-    boolean noCache;
-    boolean noStore;
-    int maxAgeSeconds = -1;
-    int maxStaleSeconds = -1;
-    int minFreshSeconds = -1;
-    boolean onlyIfCached;
-    boolean noTransform;
-    boolean immutable;
-
-    /** Don't accept an unvalidated cached response. */
-    public Builder noCache() {
-      this.noCache = true;
-      return this;
-    }
-
-    /** Don't store the server's response in any cache. */
-    public Builder noStore() {
-      this.noStore = true;
-      return this;
-    }
-
-    /**
-     * Sets the maximum age of a cached response. If the cache response's age exceeds {@code
-     * maxAge}, it will not be used and a network request will be made.
-     *
-     * @param maxAge a non-negative integer. This is stored and transmitted with {@link
-     * TimeUnit#SECONDS} precision; finer precision will be lost.
-     */
-    public Builder maxAge(int maxAge, TimeUnit timeUnit) {
-      if (maxAge < 0) throw new IllegalArgumentException("maxAge < 0: " + maxAge);
-      long maxAgeSecondsLong = timeUnit.toSeconds(maxAge);
-      this.maxAgeSeconds = maxAgeSecondsLong > Integer.MAX_VALUE
-          ? Integer.MAX_VALUE
-          : (int) maxAgeSecondsLong;
-      return this;
-    }
-
-    /**
-     * Accept cached responses that have exceeded their freshness lifetime by up to {@code
-     * maxStale}. If unspecified, stale cache responses will not be used.
-     *
-     * @param maxStale a non-negative integer. This is stored and transmitted with {@link
-     * TimeUnit#SECONDS} precision; finer precision will be lost.
-     */
-    public Builder maxStale(int maxStale, TimeUnit timeUnit) {
-      if (maxStale < 0) throw new IllegalArgumentException("maxStale < 0: " + maxStale);
-      long maxStaleSecondsLong = timeUnit.toSeconds(maxStale);
-      this.maxStaleSeconds = maxStaleSecondsLong > Integer.MAX_VALUE
-          ? Integer.MAX_VALUE
-          : (int) maxStaleSecondsLong;
-      return this;
-    }
-
-    /**
-     * Sets the minimum number of seconds that a response will continue to be fresh for. If the
-     * response will be stale when {@code minFresh} have elapsed, the cached response will not be
-     * used and a network request will be made.
-     *
-     * @param minFresh a non-negative integer. This is stored and transmitted with {@link
-     * TimeUnit#SECONDS} precision; finer precision will be lost.
-     */
-    public Builder minFresh(int minFresh, TimeUnit timeUnit) {
-      if (minFresh < 0) throw new IllegalArgumentException("minFresh < 0: " + minFresh);
-      long minFreshSecondsLong = timeUnit.toSeconds(minFresh);
-      this.minFreshSeconds = minFreshSecondsLong > Integer.MAX_VALUE
-          ? Integer.MAX_VALUE
-          : (int) minFreshSecondsLong;
-      return this;
-    }
-
-    /**
-     * Only accept the response if it is in the cache. If the response isn't cached, a {@code 504
-     * Unsatisfiable Request} response will be returned.
-     */
-    public Builder onlyIfCached() {
-      this.onlyIfCached = true;
-      return this;
-    }
-
-    /** Don't accept a transformed response. */
-    public Builder noTransform() {
-      this.noTransform = true;
-      return this;
-    }
-
-    public Builder immutable() {
-      this.immutable = true;
-      return this;
-    }
-
-    public CacheControl build() {
-      return new CacheControl(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/CacheControl.kt b/okhttp/src/main/java/okhttp3/CacheControl.kt
new file mode 100644
index 0000000000..341002f02b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CacheControl.kt
@@ -0,0 +1,349 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.http.HttpHeaders
+import java.util.concurrent.TimeUnit
+
+/**
+ * A Cache-Control header with cache directives from a server or client. These directives set policy
+ * on what responses can be stored, and which requests can be satisfied by those stored responses.
+ *
+ * See [RFC 7234, 5.2](https://tools.ietf.org/html/rfc7234#section-5.2).
+ */
+class CacheControl private constructor(
+  private val noCache: Boolean,
+  private val noStore: Boolean,
+  private val maxAgeSeconds: Int,
+  private val sMaxAgeSeconds: Int,
+  val isPrivate: Boolean,
+  val isPublic: Boolean,
+  private val mustRevalidate: Boolean,
+  private val maxStaleSeconds: Int,
+  private val minFreshSeconds: Int,
+  private val onlyIfCached: Boolean,
+  private val noTransform: Boolean,
+  private val immutable: Boolean,
+  private var headerValue: String?
+) {
+  /**
+   * In a response, this field's name "no-cache" is misleading. It doesn't prevent us from caching
+   * the response; it only means we have to validate the response with the origin server before
+   * returning it. We can do this with a conditional GET.
+   *
+   * In a request, it means do not use a cache to satisfy the request.
+   */
+  fun noCache() = noCache
+
+  /** If true, this response should not be cached.  */
+  fun noStore() = noStore
+
+  /** The duration past the response's served date that it can be served without validation. */
+  fun maxAgeSeconds() = maxAgeSeconds
+
+  /**
+   * The "s-maxage" directive is the max age for shared caches. Not to be confused with "max-age"
+   * for non-shared caches, As in Firefox and Chrome, this directive is not honored by this cache.
+   */
+  fun sMaxAgeSeconds() = sMaxAgeSeconds
+
+  fun mustRevalidate() = mustRevalidate
+
+  fun maxStaleSeconds() = maxStaleSeconds
+
+  fun minFreshSeconds() = minFreshSeconds
+
+  /**
+   * This field's name "only-if-cached" is misleading. It actually means "do not use the network".
+   * It is set by a client who only wants to make a request if it can be fully satisfied by the
+   * cache. Cached responses that would require validation (ie. conditional gets) are not permitted
+   * if this header is set.
+   */
+  fun onlyIfCached() = onlyIfCached
+
+  fun noTransform() = noTransform
+
+  fun immutable() = immutable
+
+  override fun toString(): String {
+    var result = headerValue
+    if (result == null) {
+      result = buildString {
+        if (noCache) append("no-cache, ")
+        if (noStore) append("no-store, ")
+        if (maxAgeSeconds != -1) append("max-age=").append(maxAgeSeconds).append(", ")
+        if (sMaxAgeSeconds != -1) append("s-maxage=").append(sMaxAgeSeconds).append(", ")
+        if (isPrivate) append("private, ")
+        if (isPublic) append("public, ")
+        if (mustRevalidate) append("must-revalidate, ")
+        if (maxStaleSeconds != -1) append("max-stale=").append(maxStaleSeconds).append(", ")
+        if (minFreshSeconds != -1) append("min-fresh=").append(minFreshSeconds).append(", ")
+        if (onlyIfCached) append("only-if-cached, ")
+        if (noTransform) append("no-transform, ")
+        if (immutable) append("immutable, ")
+        if (isEmpty()) return ""
+        delete(length - 2, length)
+      }
+      headerValue = result
+    }
+    return result
+  }
+
+  /** Builds a `Cache-Control` request header.  */
+  class Builder {
+    private var noCache: Boolean = false
+    private var noStore: Boolean = false
+    private var maxAgeSeconds = -1
+    private var maxStaleSeconds = -1
+    private var minFreshSeconds = -1
+    private var onlyIfCached: Boolean = false
+    private var noTransform: Boolean = false
+    private var immutable: Boolean = false
+
+    /** Don't accept an unvalidated cached response.  */
+    fun noCache(): Builder {
+      this.noCache = true
+      return this
+    }
+
+    /** Don't store the server's response in any cache.  */
+    fun noStore(): Builder {
+      this.noStore = true
+      return this
+    }
+
+    /**
+     * Sets the maximum age of a cached response. If the cache response's age exceeds `maxAge`, it
+     * will not be used and a network request will be made.
+     *
+     * @param maxAge a non-negative integer. This is stored and transmitted with [TimeUnit.SECONDS]
+     *     precision; finer precision will be lost.
+     */
+    fun maxAge(maxAge: Int, timeUnit: TimeUnit): Builder {
+      if (maxAge < 0) throw IllegalArgumentException("maxAge < 0: $maxAge")
+      val maxAgeSecondsLong = timeUnit.toSeconds(maxAge.toLong())
+      this.maxAgeSeconds = maxAgeSecondsLong.clampToInt()
+      return this
+    }
+
+    /**
+     * Accept cached responses that have exceeded their freshness lifetime by up to `maxStale`. If
+     * unspecified, stale cache responses will not be used.
+     *
+     * @param maxStale a non-negative integer. This is stored and transmitted with
+     *     [TimeUnit.SECONDS] precision; finer precision will be lost.
+     */
+    fun maxStale(maxStale: Int, timeUnit: TimeUnit): Builder {
+      if (maxStale < 0) throw IllegalArgumentException("maxStale < 0: $maxStale")
+      val maxStaleSecondsLong = timeUnit.toSeconds(maxStale.toLong())
+      this.maxStaleSeconds = maxStaleSecondsLong.clampToInt()
+      return this
+    }
+
+    /**
+     * Sets the minimum number of seconds that a response will continue to be fresh for. If the
+     * response will be stale when `minFresh` have elapsed, the cached response will not be used and
+     * a network request will be made.
+     *
+     * @param minFresh a non-negative integer. This is stored and transmitted with
+     *     [TimeUnit.SECONDS] precision; finer precision will be lost.
+     */
+    fun minFresh(minFresh: Int, timeUnit: TimeUnit): Builder {
+      if (minFresh < 0) throw IllegalArgumentException("minFresh < 0: $minFresh")
+      val minFreshSecondsLong = timeUnit.toSeconds(minFresh.toLong())
+      this.minFreshSeconds = minFreshSecondsLong.clampToInt()
+      return this
+    }
+
+    /**
+     * Only accept the response if it is in the cache. If the response isn't cached, a `504
+     * Unsatisfiable Request` response will be returned.
+     */
+    fun onlyIfCached(): Builder {
+      this.onlyIfCached = true
+      return this
+    }
+
+    /** Don't accept a transformed response.  */
+    fun noTransform(): Builder {
+      this.noTransform = true
+      return this
+    }
+
+    fun immutable(): Builder {
+      this.immutable = true
+      return this
+    }
+
+    private fun Long.clampToInt(): Int {
+      return when {
+        this > Integer.MAX_VALUE -> Integer.MAX_VALUE
+        else -> toInt()
+      }
+    }
+
+    fun build(): CacheControl {
+      return CacheControl(noCache, noStore, maxAgeSeconds, -1, false, false, false, maxStaleSeconds,
+          minFreshSeconds, onlyIfCached, noTransform, immutable, null)
+    }
+  }
+
+  companion object {
+    /**
+     * Cache control request directives that require network validation of responses. Note that such
+     * requests may be assisted by the cache via conditional GET requests.
+     */
+    @JvmField
+    val FORCE_NETWORK = Builder()
+        .noCache()
+        .build()
+
+    /**
+     * Cache control request directives that uses the cache only, even if the cached response is
+     * stale. If the response isn't available in the cache or requires server validation, the call
+     * will fail with a `504 Unsatisfiable Request`.
+     */
+    @JvmField
+    val FORCE_CACHE = Builder()
+        .onlyIfCached()
+        .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)
+        .build()
+
+    /**
+     * Returns the cache directives of `headers`. This honors both Cache-Control and Pragma headers
+     * if they are present.
+     */
+    @JvmStatic
+    fun parse(headers: Headers): CacheControl {
+      var noCache = false
+      var noStore = false
+      var maxAgeSeconds = -1
+      var sMaxAgeSeconds = -1
+      var isPrivate = false
+      var isPublic = false
+      var mustRevalidate = false
+      var maxStaleSeconds = -1
+      var minFreshSeconds = -1
+      var onlyIfCached = false
+      var noTransform = false
+      var immutable = false
+
+      var canUseHeaderValue = true
+      var headerValue: String? = null
+
+      loop@ for (i in 0 until headers.size()) {
+        val name = headers.name(i)
+        val value = headers.value(i)
+
+        when {
+          name.equals("Cache-Control", ignoreCase = true) -> {
+            if (headerValue != null) {
+              // Multiple cache-control headers means we can't use the raw value.
+              canUseHeaderValue = false
+            } else {
+              headerValue = value
+            }
+          }
+          name.equals("Pragma", ignoreCase = true) -> {
+            // Might specify additional cache-control params. We invalidate just in case.
+            canUseHeaderValue = false
+          }
+          else -> {
+            continue@loop
+          }
+        }
+
+        var pos = 0
+        while (pos < value.length) {
+          val tokenStart = pos
+          pos = HttpHeaders.skipUntil(value, pos, "=,;")
+          val directive = value.substring(tokenStart, pos).trim { it <= ' ' }
+          val parameter: String?
+
+          if (pos == value.length || value[pos] == ',' || value[pos] == ';') {
+            pos++ // Consume ',' or ';' (if necessary).
+            parameter = null
+          } else {
+            pos++ // Consume '='.
+            pos = HttpHeaders.skipWhitespace(value, pos)
+
+            if (pos < value.length && value[pos] == '\"') {
+              // Quoted string.
+              pos++ // Consume '"' open quote.
+              val parameterStart = pos
+              pos = HttpHeaders.skipUntil(value, pos, "\"")
+              parameter = value.substring(parameterStart, pos)
+              pos++ // Consume '"' close quote (if necessary).
+
+            } else {
+              // Unquoted string.
+              val parameterStart = pos
+              pos = HttpHeaders.skipUntil(value, pos, ",;")
+              parameter = value.substring(parameterStart, pos).trim { it <= ' ' }
+            }
+          }
+
+          when {
+            "no-cache".equals(directive, ignoreCase = true) -> {
+              noCache = true
+            }
+            "no-store".equals(directive, ignoreCase = true) -> {
+              noStore = true
+            }
+            "max-age".equals(directive, ignoreCase = true) -> {
+              maxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1)
+            }
+            "s-maxage".equals(directive, ignoreCase = true) -> {
+              sMaxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1)
+            }
+            "private".equals(directive, ignoreCase = true) -> {
+              isPrivate = true
+            }
+            "public".equals(directive, ignoreCase = true) -> {
+              isPublic = true
+            }
+            "must-revalidate".equals(directive, ignoreCase = true) -> {
+              mustRevalidate = true
+            }
+            "max-stale".equals(directive, ignoreCase = true) -> {
+              maxStaleSeconds = HttpHeaders.parseSeconds(parameter, Integer.MAX_VALUE)
+            }
+            "min-fresh".equals(directive, ignoreCase = true) -> {
+              minFreshSeconds = HttpHeaders.parseSeconds(parameter, -1)
+            }
+            "only-if-cached".equals(directive, ignoreCase = true) -> {
+              onlyIfCached = true
+            }
+            "no-transform".equals(directive, ignoreCase = true) -> {
+              noTransform = true
+            }
+            "immutable".equals(directive, ignoreCase = true) -> {
+              immutable = true
+            }
+          }
+        }
+      }
+
+      if (!canUseHeaderValue) {
+        headerValue = null
+      }
+
+      return CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic,
+          mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, immutable,
+          headerValue)
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
deleted file mode 100644
index 5b4669ad21..0000000000
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-
-/**
- * A call is a request that has been prepared for execution. A call can be canceled. As this object
- * represents a single request/response pair (stream), it cannot be executed twice.
- */
-public interface Call extends Cloneable {
-  /** Returns the original request that initiated this call. */
-  Request request();
-
-  /**
-   * Invokes the request immediately, and blocks until the response can be processed or is in
-   * error.
-   *
-   * <p>To avoid leaking resources callers should close the {@link Response} which in turn will
-   * close the underlying {@link ResponseBody}.
-   *
-   * <pre>@{code
-   *
-   *   // ensure the response (and underlying response body) is closed
-   *   try (Response response = client.newCall(request).execute()) {
-   *     ...
-   *   }
-   *
-   * }</pre>
-   *
-   * <p>The caller may read the response body with the response's {@link Response#body} method. To
-   * avoid leaking resources callers must {@linkplain ResponseBody close the response body} or the
-   * Response.
-   *
-   * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
-   * not necessarily indicate application-layer success: {@code response} may still indicate an
-   * unhappy HTTP response code like 404 or 500.
-   *
-   * @throws IOException if the request could not be executed due to cancellation, a connectivity
-   * problem or timeout. Because networks can fail during an exchange, it is possible that the
-   * remote server accepted the request before the failure.
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  Response execute() throws IOException;
-
-  /**
-   * Schedules the request to be executed at some point in the future.
-   *
-   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
-   * immediately unless there are several other requests currently being executed.
-   *
-   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
-   * failure exception.
-   *
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  void enqueue(Callback responseCallback);
-
-  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
-  void cancel();
-
-  /**
-   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
-   * #enqueue(Callback) enqueued}. It is an error to execute a call more than once.
-   */
-  boolean isExecuted();
-
-  boolean isCanceled();
-
-  /**
-   * Create a new, identical call to this one which can be enqueued or executed even if this call
-   * has already been.
-   */
-  Call clone();
-
-  interface Factory {
-    Call newCall(Request request);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Call.kt b/okhttp/src/main/java/okhttp3/Call.kt
new file mode 100644
index 0000000000..a56a036b15
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Call.kt
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okio.Timeout
+import java.io.IOException
+
+/**
+ * A call is a request that has been prepared for execution. A call can be canceled. As this object
+ * represents a single request/response pair (stream), it cannot be executed twice.
+ */
+interface Call : Cloneable {
+  /** Returns the original request that initiated this call.  */
+  fun request(): Request
+
+  /**
+   * Invokes the request immediately, and blocks until the response can be processed or is in error.
+   *
+   * To avoid leaking resources callers should close the [Response] which in turn will close the
+   * underlying [ResponseBody].
+   *
+   * ```
+   * // ensure the response (and underlying response body) is closed
+   * try (Response response = client.newCall(request).execute()) {
+   *   ...
+   * }
+   * ```
+   *
+   * The caller may read the response body with the response's [Response.body] method. To avoid
+   * leaking resources callers must [close the response body][ResponseBody] or the response.
+   *
+   * Note that transport-layer success (receiving a HTTP response code, headers and body) does not
+   * necessarily indicate application-layer success: `response` may still indicate an unhappy HTTP
+   * response code like 404 or 500.
+   *
+   * @throws IOException if the request could not be executed due to cancellation, a connectivity
+   *     problem or timeout. Because networks can fail during an exchange, it is possible that the
+   *     remote server accepted the request before the failure.
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  @Throws(IOException::class)
+  fun execute(): Response
+
+  /**
+   * Schedules the request to be executed at some point in the future.
+   *
+   * The [dispatcher][OkHttpClient.dispatcher] defines when the request will run: usually
+   * immediately unless there are several other requests currently being executed.
+   *
+   * This client will later call back `responseCallback` with either an HTTP response or a failure
+   * exception.
+   *
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  fun enqueue(responseCallback: Callback)
+
+  /** Cancels the request, if possible. Requests that are already complete cannot be canceled.  */
+  fun cancel()
+
+  /**
+   * Returns true if this call has been either [executed][execute] or [enqueued][enqueue]. It is an
+   * error to execute a call more than once.
+   */
+  val isExecuted: Boolean
+
+  val isCanceled: Boolean
+
+  /**
+   * Returns a timeout that spans the entire call: resolving DNS, connecting, writing the request
+   * body, server processing, and reading the response body. If the call requires redirects or
+   * retries all must complete within one timeout period.
+   *
+   * Configure the client's default timeout with [OkHttpClient.Builder.callTimeout].
+   */
+  fun timeout(): Timeout
+
+  /**
+   * Create a new, identical call to this one which can be enqueued or executed even if this call
+   * has already been.
+   */
+  override fun clone(): Call
+
+  interface Factory {
+    fun newCall(request: Request): Call
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Callback.java b/okhttp/src/main/java/okhttp3/Callback.kt
similarity index 59%
rename from okhttp/src/main/java/okhttp3/Callback.java
rename to okhttp/src/main/java/okhttp3/Callback.kt
index 3b7ed85bf4..84a0702935 100644
--- a/okhttp/src/main/java/okhttp3/Callback.java
+++ b/okhttp/src/main/java/okhttp3/Callback.kt
@@ -13,27 +13,28 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3;
+package okhttp3
 
-import java.io.IOException;
+import java.io.IOException
 
-public interface Callback {
+interface Callback {
   /**
    * Called when the request could not be executed due to cancellation, a connectivity problem or
    * timeout. Because networks can fail during an exchange, it is possible that the remote server
    * accepted the request before the failure.
    */
-  void onFailure(Call call, IOException e);
+  fun onFailure(call: Call, e: IOException)
 
   /**
    * Called when the HTTP response was successfully returned by the remote server. The callback may
-   * proceed to read the response body with {@link Response#body}. The response is still live until
-   * its response body is {@linkplain ResponseBody closed}. The recipient of the callback may
-   * consume the response body on another thread.
+   * proceed to read the response body with [Response.body]. The response is still live until its
+   * response body is [closed][ResponseBody]. The recipient of the callback may consume the response
+   * body on another thread.
    *
-   * <p>Note that transport-layer success (receiving a HTTP response code, headers and body) does
-   * not necessarily indicate application-layer success: {@code response} may still indicate an
-   * unhappy HTTP response code like 404 or 500.
+   * Note that transport-layer success (receiving a HTTP response code, headers and body) does not
+   * necessarily indicate application-layer success: `response` may still indicate an unhappy HTTP
+   * response code like 404 or 500.
    */
-  void onResponse(Call call, Response response) throws IOException;
+  @Throws(IOException::class)
+  fun onResponse(call: Call, response: Response)
 }
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
deleted file mode 100644
index 6fab2cf1d1..0000000000
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ /dev/null
@@ -1,344 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import okhttp3.internal.tls.CertificateChainCleaner;
-import okio.ByteString;
-
-import static okhttp3.internal.Util.equal;
-
-/**
- * Constrains which certificates are trusted. Pinning certificates defends against attacks on
- * certificate authorities. It also prevents connections through man-in-the-middle certificate
- * authorities either known or unknown to the application's user.
- *
- * <p>This class currently pins a certificate's Subject Public Key Info as described on <a
- * href="http://goo.gl/AIx3e5">Adam Langley's Weblog</a>. Pins are either base64 SHA-256 hashes as
- * in <a href="http://tools.ietf.org/html/rfc7469">HTTP Public Key Pinning (HPKP)</a> or SHA-1
- * base64 hashes as in Chromium's <a href="http://goo.gl/XDh6je">static certificates</a>.
- *
- * <h3>Setting up Certificate Pinning</h3>
- *
- * <p>The easiest way to pin a host is turn on pinning with a broken configuration and read the
- * expected configuration when the connection fails. Be sure to do this on a trusted network, and
- * without man-in-the-middle tools like <a href="http://charlesproxy.com">Charles</a> or <a
- * href="http://fiddlertool.com">Fiddler</a>.
- *
- * <p>For example, to pin {@code https://publicobject.com}, start with a broken
- * configuration: <pre>   {@code
- *
- *     String hostname = "publicobject.com";
- *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
- *         .add(hostname, "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
- *         .build();
- *     OkHttpClient client = OkHttpClient.Builder()
- *         .certificatePinner(certificatePinner)
- *         .build();
- *
- *     Request request = new Request.Builder()
- *         .url("https://" + hostname)
- *         .build();
- *     client.newCall(request).execute();
- * }</pre>
- *
- * As expected, this fails with a certificate pinning exception: <pre>   {@code
- *
- * javax.net.ssl.SSLPeerUnverifiedException: Certificate pinning failure!
- *   Peer certificate chain:
- *     sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=: CN=publicobject.com, OU=PositiveSSL
- *     sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=: CN=COMODO RSA Secure Server CA
- *     sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=: CN=COMODO RSA Certification Authority
- *     sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=: CN=AddTrust External CA Root
- *   Pinned certificates for publicobject.com:
- *     sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
- *   at okhttp3.CertificatePinner.check(CertificatePinner.java)
- *   at okhttp3.Connection.upgradeToTls(Connection.java)
- *   at okhttp3.Connection.connect(Connection.java)
- *   at okhttp3.Connection.connectAndSetOwner(Connection.java)
- * }</pre>
- *
- * Follow up by pasting the public key hashes from the exception into the
- * certificate pinner's configuration: <pre>   {@code
- *
- *     CertificatePinner certificatePinner = new CertificatePinner.Builder()
- *       .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
- *       .add("publicobject.com", "sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=")
- *       .add("publicobject.com", "sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=")
- *       .add("publicobject.com", "sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=")
- *       .build();
- * }</pre>
- *
- * Pinning is per-hostname and/or per-wildcard pattern. To pin both {@code publicobject.com} and
- * {@code www.publicobject.com}, you must configure both hostnames.
- *
- * <p>Wildcard pattern rules:
- * <ol>
- *     <li>Asterisk {@code *} is only permitted in the left-most domain name label and must be the
- *         only character in that label (i.e., must match the whole left-most label). For example,
- *         {@code *.example.com} is permitted, while {@code *a.example.com}, {@code a*.example.com},
- *         {@code a*b.example.com}, {@code a.*.example.com} are not permitted.
- *     <li>Asterisk {@code *} cannot match across domain name labels. For example,
- *         {@code *.example.com} matches {@code test.example.com} but does not match
- *         {@code sub.test.example.com}.
- *     <li>Wildcard patterns for single-label domain names are not permitted.
- * </ol>
- *
- * If hostname pinned directly and via wildcard pattern, both direct and wildcard pins will be used.
- * For example: {@code *.example.com} pinned with {@code pin1} and {@code a.example.com} pinned with
- * {@code pin2}, to check {@code a.example.com} both {@code pin1} and {@code pin2} will be used.
- *
- * <h3>Warning: Certificate Pinning is Dangerous!</h3>
- *
- * <p>Pinning certificates limits your server team's abilities to update their TLS certificates. By
- * pinning certificates, you take on additional operational complexity and limit your ability to
- * migrate between certificate authorities. Do not use certificate pinning without the blessing of
- * your server's TLS administrator!
- *
- * <h4>Note about self-signed certificates</h4>
- *
- * <p>{@link CertificatePinner} can not be used to pin self-signed certificate if such certificate
- * is not accepted by {@link javax.net.ssl.TrustManager}.
- *
- * @see <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning"> OWASP:
- * Certificate and Public Key Pinning</a>
- */
-public final class CertificatePinner {
-  public static final CertificatePinner DEFAULT = new Builder().build();
-
-  private final Set<Pin> pins;
-  private final @Nullable CertificateChainCleaner certificateChainCleaner;
-
-  CertificatePinner(Set<Pin> pins, @Nullable CertificateChainCleaner certificateChainCleaner) {
-    this.pins = pins;
-    this.certificateChainCleaner = certificateChainCleaner;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    if (other == this) return true;
-    return other instanceof CertificatePinner
-        && (equal(certificateChainCleaner, ((CertificatePinner) other).certificateChainCleaner)
-        && pins.equals(((CertificatePinner) other).pins));
-  }
-
-  @Override public int hashCode() {
-    int result = certificateChainCleaner != null ? certificateChainCleaner.hashCode() : 0;
-    result = 31 * result + pins.hashCode();
-    return result;
-  }
-
-  /**
-   * Confirms that at least one of the certificates pinned for {@code hostname} is in {@code
-   * peerCertificates}. Does nothing if there are no certificates pinned for {@code hostname}.
-   * OkHttp calls this after a successful TLS handshake, but before the connection is used.
-   *
-   * @throws SSLPeerUnverifiedException if {@code peerCertificates} don't match the certificates
-   * pinned for {@code hostname}.
-   */
-  public void check(String hostname, List<Certificate> peerCertificates)
-      throws SSLPeerUnverifiedException {
-    List<Pin> pins = findMatchingPins(hostname);
-    if (pins.isEmpty()) return;
-
-    if (certificateChainCleaner != null) {
-      peerCertificates = certificateChainCleaner.clean(peerCertificates, hostname);
-    }
-
-    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
-      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
-
-      // Lazily compute the hashes for each certificate.
-      ByteString sha1 = null;
-      ByteString sha256 = null;
-
-      for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
-        Pin pin = pins.get(p);
-        if (pin.hashAlgorithm.equals("sha256/")) {
-          if (sha256 == null) sha256 = sha256(x509Certificate);
-          if (pin.hash.equals(sha256)) return; // Success!
-        } else if (pin.hashAlgorithm.equals("sha1/")) {
-          if (sha1 == null) sha1 = sha1(x509Certificate);
-          if (pin.hash.equals(sha1)) return; // Success!
-        } else {
-          throw new AssertionError("unsupported hashAlgorithm: " + pin.hashAlgorithm);
-        }
-      }
-    }
-
-    // If we couldn't find a matching pin, format a nice exception.
-    StringBuilder message = new StringBuilder()
-        .append("Certificate pinning failure!")
-        .append("\n  Peer certificate chain:");
-    for (int c = 0, certsSize = peerCertificates.size(); c < certsSize; c++) {
-      X509Certificate x509Certificate = (X509Certificate) peerCertificates.get(c);
-      message.append("\n    ").append(pin(x509Certificate))
-          .append(": ").append(x509Certificate.getSubjectDN().getName());
-    }
-    message.append("\n  Pinned certificates for ").append(hostname).append(":");
-    for (int p = 0, pinsSize = pins.size(); p < pinsSize; p++) {
-      Pin pin = pins.get(p);
-      message.append("\n    ").append(pin);
-    }
-    throw new SSLPeerUnverifiedException(message.toString());
-  }
-
-  /** @deprecated replaced with {@link #check(String, List)}. */
-  public void check(String hostname, Certificate... peerCertificates)
-      throws SSLPeerUnverifiedException {
-    check(hostname, Arrays.asList(peerCertificates));
-  }
-
-  /**
-   * Returns list of matching certificates' pins for the hostname. Returns an empty list if the
-   * hostname does not have pinned certificates.
-   */
-  List<Pin> findMatchingPins(String hostname) {
-    List<Pin> result = Collections.emptyList();
-    for (Pin pin : pins) {
-      if (pin.matches(hostname)) {
-        if (result.isEmpty()) result = new ArrayList<>();
-        result.add(pin);
-      }
-    }
-    return result;
-  }
-
-  /** Returns a certificate pinner that uses {@code certificateChainCleaner}. */
-  CertificatePinner withCertificateChainCleaner(
-      @Nullable CertificateChainCleaner certificateChainCleaner) {
-    return equal(this.certificateChainCleaner, certificateChainCleaner)
-        ? this
-        : new CertificatePinner(pins, certificateChainCleaner);
-  }
-
-  /**
-   * Returns the SHA-256 of {@code certificate}'s public key.
-   *
-   * <p>In OkHttp 3.1.2 and earlier, this returned a SHA-1 hash of the public key. Both types are
-   * supported, but SHA-256 is preferred.
-   */
-  public static String pin(Certificate certificate) {
-    if (!(certificate instanceof X509Certificate)) {
-      throw new IllegalArgumentException("Certificate pinning requires X509 certificates");
-    }
-    return "sha256/" + sha256((X509Certificate) certificate).base64();
-  }
-
-  static ByteString sha1(X509Certificate x509Certificate) {
-    return ByteString.of(x509Certificate.getPublicKey().getEncoded()).sha1();
-  }
-
-  static ByteString sha256(X509Certificate x509Certificate) {
-    return ByteString.of(x509Certificate.getPublicKey().getEncoded()).sha256();
-  }
-
-  static final class Pin {
-    private static final String WILDCARD = "*.";
-    /** A hostname like {@code example.com} or a pattern like {@code *.example.com}. */
-    final String pattern;
-    /** The canonical hostname, i.e. {@code EXAMPLE.com} becomes {@code example.com}. */
-    final String canonicalHostname;
-    /** Either {@code sha1/} or {@code sha256/}. */
-    final String hashAlgorithm;
-    /** The hash of the pinned certificate using {@link #hashAlgorithm}. */
-    final ByteString hash;
-
-    Pin(String pattern, String pin) {
-      this.pattern = pattern;
-      this.canonicalHostname = pattern.startsWith(WILDCARD)
-          ? HttpUrl.parse("http://" + pattern.substring(WILDCARD.length())).host()
-          : HttpUrl.parse("http://" + pattern).host();
-      if (pin.startsWith("sha1/")) {
-        this.hashAlgorithm = "sha1/";
-        this.hash = ByteString.decodeBase64(pin.substring("sha1/".length()));
-      } else if (pin.startsWith("sha256/")) {
-        this.hashAlgorithm = "sha256/";
-        this.hash = ByteString.decodeBase64(pin.substring("sha256/".length()));
-      } else {
-        throw new IllegalArgumentException("pins must start with 'sha256/' or 'sha1/': " + pin);
-      }
-
-      if (this.hash == null) {
-        throw new IllegalArgumentException("pins must be base64: " + pin);
-      }
-    }
-
-    boolean matches(String hostname) {
-      if (pattern.startsWith(WILDCARD)) {
-        int firstDot = hostname.indexOf('.');
-        return (hostname.length() - firstDot - 1) == canonicalHostname.length()
-            && hostname.regionMatches(false, firstDot + 1, canonicalHostname, 0,
-            canonicalHostname.length());
-      }
-
-      return hostname.equals(canonicalHostname);
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof Pin
-          && pattern.equals(((Pin) other).pattern)
-          && hashAlgorithm.equals(((Pin) other).hashAlgorithm)
-          && hash.equals(((Pin) other).hash);
-    }
-
-    @Override public int hashCode() {
-      int result = 17;
-      result = 31 * result + pattern.hashCode();
-      result = 31 * result + hashAlgorithm.hashCode();
-      result = 31 * result + hash.hashCode();
-      return result;
-    }
-
-    @Override public String toString() {
-      return hashAlgorithm + hash.base64();
-    }
-  }
-
-  /** Builds a configured certificate pinner. */
-  public static final class Builder {
-    private final List<Pin> pins = new ArrayList<>();
-
-    /**
-     * Pins certificates for {@code pattern}.
-     *
-     * @param pattern lower-case host name or wildcard pattern such as {@code *.example.com}.
-     * @param pins SHA-256 or SHA-1 hashes. Each pin is a hash of a certificate's Subject Public Key
-     * Info, base64-encoded and prefixed with either {@code sha256/} or {@code sha1/}.
-     */
-    public Builder add(String pattern, String... pins) {
-      if (pattern == null) throw new NullPointerException("pattern == null");
-
-      for (String pin : pins) {
-        this.pins.add(new Pin(pattern, pin));
-      }
-
-      return this;
-    }
-
-    public CertificatePinner build() {
-      return new CertificatePinner(new LinkedHashSet<>(pins), null);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.kt b/okhttp/src/main/java/okhttp3/CertificatePinner.kt
new file mode 100644
index 0000000000..5ffd8a952a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.kt
@@ -0,0 +1,329 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.tls.CertificateChainCleaner
+import okio.ByteString
+import okio.ByteString.Companion.decodeBase64
+import java.security.cert.Certificate
+import java.security.cert.X509Certificate
+import java.util.Objects
+import javax.net.ssl.SSLPeerUnverifiedException
+
+/**
+ * Constrains which certificates are trusted. Pinning certificates defends against attacks on
+ * certificate authorities. It also prevents connections through man-in-the-middle certificate
+ * authorities either known or unknown to the application's user.
+ * This class currently pins a certificate's Subject Public Key Info as described on
+ * [Adam Langley's Weblog][langley]. Pins are either base64 SHA-256 hashes as in
+ * [HTTP Public Key Pinning (HPKP)][rfc_7469] or SHA-1 base64 hashes as in Chromium's
+ * [static certificates][static_certificates].
+ *
+ * ## Setting up Certificate Pinning
+ *
+ * The easiest way to pin a host is turn on pinning with a broken configuration and read the
+ * expected configuration when the connection fails. Be sure to do this on a trusted network, and
+ * without man-in-the-middle tools like [Charles][charles] or [Fiddler][fiddler].
+ *
+ * For example, to pin `https://publicobject.com`, start with a broken configuration:
+ *
+ * ```
+ * String hostname = "publicobject.com";
+ * CertificatePinner certificatePinner = new CertificatePinner.Builder()
+ *     .add(hostname, "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
+ *     .build();
+ * OkHttpClient client = OkHttpClient.Builder()
+ *     .certificatePinner(certificatePinner)
+ *     .build();
+ *
+ * Request request = new Request.Builder()
+ *     .url("https://" + hostname)
+ *     .build();
+ * client.newCall(request).execute();
+ * ```
+ *
+ * As expected, this fails with a certificate pinning exception:
+ *
+ * ```
+ * javax.net.ssl.SSLPeerUnverifiedException: Certificate pinning failure!
+ * Peer certificate chain:
+ *     sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=: CN=publicobject.com, OU=PositiveSSL
+ *     sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=: CN=COMODO RSA Secure Server CA
+ *     sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=: CN=COMODO RSA Certification Authority
+ *     sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=: CN=AddTrust External CA Root
+ * Pinned certificates for publicobject.com:
+ *     sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
+ *   at okhttp3.CertificatePinner.check(CertificatePinner.java)
+ *   at okhttp3.Connection.upgradeToTls(Connection.java)
+ *   at okhttp3.Connection.connect(Connection.java)
+ *   at okhttp3.Connection.connectAndSetOwner(Connection.java)
+ * ```
+ *
+ * Follow up by pasting the public key hashes from the exception into the
+ * certificate pinner's configuration:
+ *
+ * ```
+ * CertificatePinner certificatePinner = new CertificatePinner.Builder()
+ *     .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+ *     .add("publicobject.com", "sha256/klO23nT2ehFDXCfx3eHTDRESMz3asj1muO+4aIdjiuY=")
+ *     .add("publicobject.com", "sha256/grX4Ta9HpZx6tSHkmCrvpApTQGo67CYDnvprLg5yRME=")
+ *     .add("publicobject.com", "sha256/lCppFqbkrlJ3EcVFAkeip0+44VaoJUymbnOaEUk7tEU=")
+ *     .build();
+ * ```
+ *
+ * Pinning is per-hostname and/or per-wildcard pattern. To pin both `publicobject.com` and
+ * `www.publicobject.com`, you must configure both hostnames.
+ *
+ * Wildcard pattern rules:
+ *
+ *  1. Asterisk `*` is only permitted in the left-most domain name label and must be the only
+ *     character in that label (i.e., must match the whole left-most label). For example,
+ *     `*.example.com` is permitted, while `*a.example.com`, `a*.example.com`, `a*b.example.com`,
+ *     `a.*.example.com` are not permitted.
+ *  2. Asterisk `*` cannot match across domain name labels. For example, `*.example.com` matches
+ *     `test.example.com` but does not match `sub.test.example.com`.
+ *  3. Wildcard patterns for single-label domain names are not permitted.
+ *
+ * If hostname pinned directly and via wildcard pattern, both direct and wildcard pins will be used.
+ * For example: `*.example.com` pinned with `pin1` and `a.example.com` pinned with `pin2`, to check
+ * `a.example.com` both `pin1` and `pin2` will be used.
+ *
+ * ## Warning: Certificate Pinning is Dangerous!
+ *
+ * Pinning certificates limits your server team's abilities to update their TLS certificates. By
+ * pinning certificates, you take on additional operational complexity and limit your ability to
+ * migrate between certificate authorities. Do not use certificate pinning without the blessing of
+ * your server's TLS administrator!
+ *
+ * ### Note about self-signed certificates
+ *
+ * [CertificatePinner] can not be used to pin self-signed certificate if such certificate is not
+ * accepted by [javax.net.ssl.TrustManager].
+ *
+ * See also [OWASP: Certificate and Public Key Pinning][owasp].
+ *
+ * [charles]: http://charlesproxy.com
+ * [fiddler]: http://fiddlertool.com
+ * [langley]: http://goo.gl/AIx3e5
+ * [owasp]: https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning
+ * [rfc_7469]: http://tools.ietf.org/html/rfc7469
+ * [static_certificates]: http://goo.gl/XDh6je
+ */
+data class CertificatePinner internal constructor(
+  private val pins: Set<Pin>,
+  private val certificateChainCleaner: CertificateChainCleaner?
+) {
+  /**
+   * Confirms that at least one of the certificates pinned for `hostname` is in `peerCertificates`.
+   * Does nothing if there are no certificates pinned for `hostname`. OkHttp calls this after a
+   * successful TLS handshake, but before the connection is used.
+   *
+   * @throws SSLPeerUnverifiedException if `peerCertificates` don't match the certificates pinned
+   *     for `hostname`.
+   */
+  @Throws(SSLPeerUnverifiedException::class)
+  fun check(hostname: String, peerCertificates: List<Certificate>) {
+    var peerCertificates = peerCertificates
+    val pins = findMatchingPins(hostname)
+    if (pins.isEmpty()) return
+
+    if (certificateChainCleaner != null) {
+      peerCertificates = certificateChainCleaner.clean(peerCertificates, hostname)
+    }
+
+    for (peerCertificate in peerCertificates) {
+      val x509Certificate = peerCertificate as X509Certificate
+
+      // Lazily compute the hashes for each certificate.
+      var sha1: ByteString? = null
+      var sha256: ByteString? = null
+
+      for (pin in pins) {
+        when (pin.hashAlgorithm) {
+          "sha256/" -> {
+            if (sha256 == null) sha256 = sha256(x509Certificate)
+            if (pin.hash == sha256) return  // Success!
+          }
+          "sha1/" -> {
+            if (sha1 == null) sha1 = sha1(x509Certificate)
+            if (pin.hash == sha1) return  // Success!
+          }
+          else -> throw AssertionError("unsupported hashAlgorithm: ${pin.hashAlgorithm}")
+        }
+      }
+    }
+
+    // If we couldn't find a matching pin, format a nice exception.
+    val message = buildString {
+      append("Certificate pinning failure!")
+      append("\n  Peer certificate chain:")
+      for (c in 0 until peerCertificates.size) {
+        val x509Certificate = peerCertificates[c] as X509Certificate
+        append("\n    ")
+        append(pin(x509Certificate))
+        append(": ")
+        append(x509Certificate.subjectDN.name)
+      }
+      append("\n  Pinned certificates for ")
+      append(hostname)
+      append(":")
+      for (pin in pins) {
+        append("\n    ")
+        append(pin)
+      }
+    }
+    throw SSLPeerUnverifiedException(message)
+  }
+
+  @Deprecated(
+      "replaced with {@link #check(String, List)}.",
+      ReplaceWith("check(hostname, peerCertificates.toList())")
+  )
+  @Throws(SSLPeerUnverifiedException::class)
+  inline fun check(hostname: String, vararg peerCertificates: Certificate) {
+    check(hostname, peerCertificates.toList())
+  }
+
+  /**
+   * Returns list of matching certificates' pins for the hostname. Returns an empty list if the
+   * hostname does not have pinned certificates.
+   */
+  internal fun findMatchingPins(hostname: String): List<Pin> {
+    var result: List<Pin> = emptyList()
+    for (pin in pins) {
+      if (pin.matches(hostname)) {
+        if (result.isEmpty()) result = mutableListOf()
+        (result as MutableList<Pin>).add(pin)
+      }
+    }
+    return result
+  }
+
+  /** Returns a certificate pinner that uses `certificateChainCleaner`.  */
+  internal fun withCertificateChainCleaner(
+    certificateChainCleaner: CertificateChainCleaner?
+  ): CertificatePinner {
+    return if (this.certificateChainCleaner == certificateChainCleaner) {
+      this
+    } else {
+      CertificatePinner(pins, certificateChainCleaner)
+    }
+  }
+
+  internal class Pin(
+    /** A hostname like `example.com` or a pattern like `*.example.com`.  */
+    val pattern: String,
+    pin: String
+  ) {
+    /** The canonical hostname, i.e. `EXAMPLE.com` becomes `example.com`.  */
+    val canonicalHostname: String
+    /** Either `sha1/` or `sha256/`.  */
+    val hashAlgorithm: String
+    /** The hash of the pinned certificate using [.hashAlgorithm].  */
+    val hash: ByteString
+
+    init {
+      this.canonicalHostname = if (pattern.startsWith(WILDCARD)) {
+        HttpUrl.get("http://${pattern.substring(WILDCARD.length)}").host()
+      } else {
+        HttpUrl.get("http://$pattern").host()
+      }
+      when {
+        pin.startsWith("sha1/") -> {
+          this.hashAlgorithm = "sha1/"
+          this.hash = pin.substring("sha1/".length).decodeBase64()!!
+        }
+        pin.startsWith("sha256/") -> {
+          this.hashAlgorithm = "sha256/"
+          this.hash = pin.substring("sha256/".length).decodeBase64()!!
+        }
+        else -> throw IllegalArgumentException("pins must start with 'sha256/' or 'sha1/': $pin")
+      }
+    }
+
+    fun matches(hostname: String): Boolean {
+      if (pattern.startsWith(WILDCARD)) {
+        val firstDot = hostname.indexOf('.')
+        return hostname.length - firstDot - 1 == canonicalHostname.length
+            && hostname.regionMatches(firstDot + 1, canonicalHostname, 0, canonicalHostname.length,
+            ignoreCase = false)
+      }
+      return hostname == canonicalHostname
+    }
+
+    override fun equals(other: Any?): Boolean {
+      return other is Pin
+          && pattern == other.pattern
+          && hashAlgorithm == other.hashAlgorithm
+          && hash == other.hash
+    }
+
+    override fun hashCode(): Int {
+      var result = 17
+      result = 31 * result + pattern.hashCode()
+      result = 31 * result + hashAlgorithm.hashCode()
+      result = 31 * result + hash.hashCode()
+      return result
+    }
+
+    override fun toString(): String = hashAlgorithm + hash.base64()
+  }
+
+  /** Builds a configured certificate pinner.  */
+  class Builder {
+    private val pins = mutableListOf<Pin>()
+
+    /**
+     * Pins certificates for `pattern`.
+     *
+     * @param pattern lower-case host name or wildcard pattern such as `*.example.com`.
+     * @param pins SHA-256 or SHA-1 hashes. Each pin is a hash of a certificate's Subject Public Key
+     * Info, base64-encoded and prefixed with either `sha256/` or `sha1/`.
+     */
+    fun add(pattern: String, vararg pins: String) = apply {
+      for (pin in pins) {
+        this.pins.add(Pin(pattern, pin))
+      }
+    }
+
+    fun build(): CertificatePinner = CertificatePinner(pins.toSet(), null)
+  }
+
+  companion object {
+    internal const val WILDCARD = "*."
+
+    @JvmField
+    val DEFAULT = Builder().build()
+
+    /**
+     * Returns the SHA-256 of `certificate`'s public key.
+     *
+     * In OkHttp 3.1.2 and earlier, this returned a SHA-1 hash of the public key. Both types are
+     * supported, but SHA-256 is preferred.
+     */
+    @JvmStatic
+    fun pin(certificate: Certificate): String {
+      require(certificate is X509Certificate) { "Certificate pinning requires X509 certificates" }
+      return "sha256/${sha256(certificate).base64()}"
+    }
+
+    internal fun sha1(x509Certificate: X509Certificate): ByteString =
+        ByteString.of(*x509Certificate.publicKey.encoded).sha1()
+
+    internal fun sha256(x509Certificate: X509Certificate): ByteString =
+        ByteString.of(*x509Certificate.publicKey.encoded).sha256()
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Challenge.java b/okhttp/src/main/java/okhttp3/Challenge.java
deleted file mode 100644
index 4b000eceda..0000000000
--- a/okhttp/src/main/java/okhttp3/Challenge.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.nio.charset.Charset;
-import javax.annotation.Nullable;
-
-import static okhttp3.internal.Util.ISO_8859_1;
-
-/** An RFC 7617 challenge. */
-public final class Challenge {
-  private final String scheme;
-  private final String realm;
-  private final Charset charset;
-
-  public Challenge(String scheme, String realm) {
-    this(scheme, realm, ISO_8859_1);
-  }
-
-  private Challenge(String scheme, String realm, Charset charset) {
-    if (scheme == null) throw new NullPointerException("scheme == null");
-    if (realm == null) throw new NullPointerException("realm == null");
-    if (charset == null) throw new NullPointerException("charset == null");
-    this.scheme = scheme;
-    this.realm = realm;
-    this.charset = charset;
-  }
-
-  /** Returns a copy of this charset that expects a credential encoded with {@code charset}. */
-  public Challenge withCharset(Charset charset) {
-    return new Challenge(scheme, realm, charset);
-  }
-
-  /** Returns the authentication scheme, like {@code Basic}. */
-  public String scheme() {
-    return scheme;
-  }
-
-  /** Returns the protection space. */
-  public String realm() {
-    return realm;
-  }
-
-  /** Returns the charset that should be used to encode the credential. */
-  public Charset charset() {
-    return charset;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof Challenge
-        && ((Challenge) other).scheme.equals(scheme)
-        && ((Challenge) other).realm.equals(realm)
-        && ((Challenge) other).charset.equals(charset);
-  }
-
-  @Override public int hashCode() {
-    int result = 29;
-    result = 31 * result + realm.hashCode();
-    result = 31 * result + scheme.hashCode();
-    result = 31 * result + charset.hashCode();
-    return result;
-  }
-
-  @Override public String toString() {
-    return scheme
-        + " realm=\"" + realm + "\""
-        + " charset=\"" + charset + "\"";
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Challenge.kt b/okhttp/src/main/java/okhttp3/Challenge.kt
new file mode 100644
index 0000000000..6871bbd9ed
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Challenge.kt
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.nio.charset.Charset
+import java.nio.charset.StandardCharsets.ISO_8859_1
+import java.util.Collections.singletonMap
+import java.util.Collections.unmodifiableMap
+import java.util.Locale.US
+
+/** An RFC 7235 challenge. */
+class Challenge(
+  private val scheme: String,
+  authParams: Map<String?, String>
+) {
+  private val authParams: Map<String?, String>
+
+  init {
+    val newAuthParams: MutableMap<String?, String> = LinkedHashMap()
+    for ((key, value) in authParams) {
+      val newKey = key?.toLowerCase(US)
+      newAuthParams[newKey] = value
+    }
+    this.authParams = unmodifiableMap<String?, String>(newAuthParams)
+  }
+
+  constructor(scheme: String, realm: String) : this(scheme, singletonMap("realm", realm))
+
+  /** Returns a copy of this charset that expects a credential encoded with [charset]. */
+  fun withCharset(charset: Charset): Challenge {
+    val authParams = LinkedHashMap(this.authParams)
+    authParams["charset"] = charset.name()
+    return Challenge(scheme, authParams)
+  }
+
+  /** Returns the authentication scheme, like `Basic`. */
+  fun scheme() = scheme
+
+  /**
+   * Returns the auth params, including [realm] and [charset] if present, but as
+   * strings. The map's keys are lowercase and should be treated case-insensitively.
+   */
+  fun authParams() = authParams
+
+  /** Returns the protection space. */
+  fun realm(): String? = authParams["realm"]
+
+  /** Returns the charset that should be used to encode the credentials. */
+  fun charset(): Charset {
+    val charset = authParams["charset"]
+    if (charset != null) {
+      try {
+        return Charset.forName(charset)
+      } catch (ignore: Exception) {
+      }
+    }
+    return ISO_8859_1
+  }
+
+  override fun equals(other: Any?): Boolean {
+    return other is Challenge
+        && other.scheme == scheme
+        && other.authParams == authParams
+  }
+
+  override fun hashCode(): Int {
+    var result = 29
+    result = 31 * result + scheme.hashCode()
+    result = 31 * result + authParams.hashCode()
+    return result
+  }
+
+  override fun toString(): String {
+    return "$scheme authParams=$authParams"
+  }
+
+}
\ No newline at end of file
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.java b/okhttp/src/main/java/okhttp3/CipherSuite.java
deleted file mode 100644
index cf8f3a9c70..0000000000
--- a/okhttp/src/main/java/okhttp3/CipherSuite.java
+++ /dev/null
@@ -1,450 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Map;
-import java.util.TreeMap;
-
-/**
- * <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml">TLS cipher
- * suites</a>.
- *
- * <p><strong>Not all cipher suites are supported on all platforms.</strong> As newer cipher suites
- * are created (for stronger privacy, better performance, etc.) they will be adopted by the platform
- * and then exposed here. Cipher suites that are not available on either Android (through API level
- * 24) or Java (through JDK 9) are omitted for brevity.
- *
- * <p>See <a href="https://developer.android.com/reference/javax/net/ssl/SSLEngine.html">Android SSLEngine</a>
- * which lists the cipher suites supported by Android.
- *
- * <p>See <a href="https://docs.oracle.com/javase/9/security/oracleproviders.htm">JDK 9 Providers</a>
- * which lists the cipher suites supported by Oracle.
- *
- * <p>See <a href="https://github.com/google/conscrypt/blob/master/common/src/main/java/org/conscrypt/NativeCrypto.java">NativeCrypto.java</a>
- * from conscrypt, which lists the cipher suites supported by Conscrypt.
- */
-public final class CipherSuite {
-  /**
-   * Compares cipher suites names like "TLS_RSA_WITH_NULL_MD5" and "SSL_RSA_WITH_NULL_MD5", ignoring
-   * the "TLS_" or "SSL_" prefix which is not consistent across platforms. In particular some IBM
-   * JVMs use the "SSL_" prefix everywhere whereas Oracle JVMs mix "TLS_" and "SSL_".
-   */
-  static final Comparator<String> ORDER_BY_NAME = new Comparator<String>() {
-    @Override public int compare(String a, String b) {
-      for (int i = 4, limit = Math.min(a.length(), b.length()); i < limit; i++) {
-        char charA = a.charAt(i);
-        char charB = b.charAt(i);
-        if (charA != charB) return charA < charB ? -1 : 1;
-      }
-      int lengthA = a.length();
-      int lengthB = b.length();
-      if (lengthA != lengthB) return lengthA < lengthB ? -1 : 1;
-      return 0;
-    }
-  };
-
-  /**
-   * Holds interned instances. This needs to be above the of() calls below so that it's
-   * initialized by the time those parts of {@code <clinit>()} run. Guarded by CipherSuite.class.
-   */
-  private static final Map<String, CipherSuite> INSTANCES = new TreeMap<>(ORDER_BY_NAME);
-
-  // Last updated 2016-07-03 using cipher suites from Android 24 and Java 9.
-
-  // public static final CipherSuite TLS_NULL_WITH_NULL_NULL = of("TLS_NULL_WITH_NULL_NULL", 0x0000);
-  public static final CipherSuite TLS_RSA_WITH_NULL_MD5 = of("SSL_RSA_WITH_NULL_MD5", 0x0001);
-  public static final CipherSuite TLS_RSA_WITH_NULL_SHA = of("SSL_RSA_WITH_NULL_SHA", 0x0002);
-  public static final CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003);
-  public static final CipherSuite TLS_RSA_WITH_RC4_128_MD5 = of("SSL_RSA_WITH_RC4_128_MD5", 0x0004);
-  public static final CipherSuite TLS_RSA_WITH_RC4_128_SHA = of("SSL_RSA_WITH_RC4_128_SHA", 0x0005);
-  // public static final CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = of("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006);
-  // public static final CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = of("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007);
-  public static final CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008);
-  public static final CipherSuite TLS_RSA_WITH_DES_CBC_SHA = of("SSL_RSA_WITH_DES_CBC_SHA", 0x0009);
-  public static final CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a);
-  // public static final CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b);
-  // public static final CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA = of("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c);
-  // public static final CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d);
-  // public static final CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA = of("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010);
-  public static final CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011);
-  public static final CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA = of("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012);
-  public static final CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013);
-  public static final CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014);
-  public static final CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA = of("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015);
-  public static final CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = of("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016);
-  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = of("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017);
-  public static final CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = of("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018);
-  public static final CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = of("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019);
-  public static final CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA = of("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a);
-  public static final CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = of("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b);
-  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_SHA = of("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e);
-  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA = of("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f);
-  public static final CipherSuite TLS_KRB5_WITH_RC4_128_SHA = of("TLS_KRB5_WITH_RC4_128_SHA", 0x0020);
-  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA = of("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021);
-  public static final CipherSuite TLS_KRB5_WITH_DES_CBC_MD5 = of("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022);
-  public static final CipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = of("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023);
-  public static final CipherSuite TLS_KRB5_WITH_RC4_128_MD5 = of("TLS_KRB5_WITH_RC4_128_MD5", 0x0024);
-  // public static final CipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5 = of("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026);
-  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA = of("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029);
-  // public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a);
-  public static final CipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = of("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA = of("TLS_PSK_WITH_NULL_SHA", 0x002c);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA = of("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA = of("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = of("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = of("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = of("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = of("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a);
-  public static final CipherSuite TLS_RSA_WITH_NULL_SHA256 = of("TLS_RSA_WITH_NULL_SHA256", 0x003b);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040);
-  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043);
-  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044);
-  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = of("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = of("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d);
-  public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086);
-  public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087);
-  public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = of("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089);
-  public static final CipherSuite TLS_PSK_WITH_RC4_128_SHA = of("TLS_PSK_WITH_RC4_128_SHA", 0x008a);
-  public static final CipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b);
-  public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA = of("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c);
-  public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA = of("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA = of("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA = of("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA = of("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA = of("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095);
-  public static final CipherSuite TLS_RSA_WITH_SEED_CBC_SHA = of("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096);
-  // public static final CipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA = of("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097);
-  // public static final CipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA = of("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA = of("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA = of("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a);
-  // public static final CipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA = of("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b);
-  public static final CipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c);
-  public static final CipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e);
-  public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0);
-  // public static final CipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2);
-  public static final CipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4);
-  // public static final CipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256 = of("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6);
-  public static final CipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384 = of("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA256 = of("TLS_PSK_WITH_NULL_SHA256", 0x00b0);
-  // public static final CipherSuite TLS_PSK_WITH_NULL_SHA384 = of("TLS_PSK_WITH_NULL_SHA384", 0x00b1);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA256 = of("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_NULL_SHA384 = of("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA256 = of("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_NULL_SHA384 = of("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5);
-  public static final CipherSuite TLS_EMPTY_RENEGOTIATION_INFO_SCSV = of("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff);
-  public static final CipherSuite TLS_FALLBACK_SCSV = of("TLS_FALLBACK_SCSV", 0x5600);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA = of("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA = of("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = of("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA = of("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = of("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA = of("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA = of("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = of("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = of("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA = of("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA = of("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014);
-  public static final CipherSuite TLS_ECDH_anon_WITH_NULL_SHA = of("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015);
-  public static final CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA = of("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016);
-  public static final CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017);
-  public static final CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA = of("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018);
-  public static final CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA = of("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f);
-  // public static final CipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020);
-  // public static final CipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021);
-  // public static final CipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = of("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d);
-  public static final CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031);
-  public static final CipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_RC4_128_SHA = of("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = of("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034);
-  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = of("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035);
-  public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = of("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA = of("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA256 = of("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA384 = of("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = of("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = of("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050);
-  // public static final CipherSuite TLS_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054);
-  // public static final CipherSuite TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058);
-  // public static final CipherSuite TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = of("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a);
-  // public static final CipherSuite TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = of("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a);
-  // public static final CipherSuite TLS_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a);
-  // public static final CipherSuite TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e);
-  // public static final CipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080);
-  // public static final CipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082);
-  // public static final CipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084);
-  // public static final CipherSuite TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088);
-  // public static final CipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a);
-  // public static final CipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c);
-  // public static final CipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = of("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = of("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094);
-  // public static final CipherSuite TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = of("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = of("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b);
-  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM = of("TLS_RSA_WITH_AES_128_CCM", 0xc09c);
-  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM = of("TLS_RSA_WITH_AES_256_CCM", 0xc09d);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM = of("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM = of("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f);
-  // public static final CipherSuite TLS_RSA_WITH_AES_128_CCM_8 = of("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0);
-  // public static final CipherSuite TLS_RSA_WITH_AES_256_CCM_8 = of("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_128_CCM_8 = of("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_AES_256_CCM_8 = of("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM = of("TLS_PSK_WITH_AES_128_CCM", 0xc0a4);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM = of("TLS_PSK_WITH_AES_256_CCM", 0xc0a5);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_128_CCM = of("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_AES_256_CCM = of("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7);
-  // public static final CipherSuite TLS_PSK_WITH_AES_128_CCM_8 = of("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8);
-  // public static final CipherSuite TLS_PSK_WITH_AES_256_CCM_8 = of("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9);
-  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_128_CCM_8 = of("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa);
-  // public static final CipherSuite TLS_PSK_DHE_WITH_AES_256_CCM_8 = of("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM = of("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae);
-  // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af);
-  public static final CipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8);
-  public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa);
-  // public static final CipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccab);
-   public static final CipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac);
-  // public static final CipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccad);
-  // public static final CipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccae);
-
-  final String javaName;
-
-  /**
-   * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
-   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
-   */
-  public static synchronized CipherSuite forJavaName(String javaName) {
-    CipherSuite result = INSTANCES.get(javaName);
-    if (result == null) {
-      result = new CipherSuite(javaName);
-      INSTANCES.put(javaName, result);
-    }
-    return result;
-  }
-
-  static List<CipherSuite> forJavaNames(String... cipherSuites) {
-    List<CipherSuite> result = new ArrayList<>(cipherSuites.length);
-    for (String cipherSuite : cipherSuites) {
-      result.add(forJavaName(cipherSuite));
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  private CipherSuite(String javaName) {
-    if (javaName == null) {
-      throw new NullPointerException();
-    }
-    this.javaName = javaName;
-  }
-
-  /**
-   * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
-   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
-   * @param value the integer identifier for this cipher suite. (Documentation only.)
-   */
-  private static CipherSuite of(String javaName, int value) {
-    return forJavaName(javaName);
-  }
-
-  /**
-   * Returns the Java name of this cipher suite. For some older cipher suites the Java name has the
-   * prefix {@code SSL_}, causing the Java name to be different from the instance name which is
-   * always prefixed {@code TLS_}. For example, {@code TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName()}
-   * is {@code "SSL_RSA_EXPORT_WITH_RC4_40_MD5"}.
-   */
-  public String javaName() {
-    return javaName;
-  }
-
-  @Override public String toString() {
-    return javaName;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.kt b/okhttp/src/main/java/okhttp3/CipherSuite.kt
new file mode 100644
index 0000000000..0317ca71d4
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CipherSuite.kt
@@ -0,0 +1,455 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+/**
+ * [TLS cipher suites][iana_tls_parameters].
+ *
+ * **Not all cipher suites are supported on all platforms.** As newer cipher suites are created (for
+ * stronger privacy, better performance, etc.) they will be adopted by the platform and then exposed
+ * here. Cipher suites that are not available on either Android (through API level 24) or Java
+ * (through JDK 9) are omitted for brevity.
+ *
+ * See [Android SSLEngine][sslengine] which lists the cipher suites supported by Android.
+ *
+ * See [JDK Providers][oracle_providers] which lists the cipher suites supported by Oracle.
+ *
+ * See [NativeCrypto.java][conscrypt_providers] which lists the cipher suites supported by
+ * Conscrypt.
+ *
+ * [iana_tls_parameters]: https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml
+ * [sslengine]: https://developer.android.com/reference/javax/net/ssl/SSLEngine.html
+ * [oracle_providers]: https://docs.oracle.com/javase/10/security/oracle-providers.htm
+ * [conscrypt_providers]: https://github.com/google/conscrypt/blob/master/common/src/main/java/org/conscrypt/NativeCrypto.java
+ */
+class CipherSuite private constructor(
+  private val javaName: String
+) {
+  /**
+   * Returns the Java name of this cipher suite. For some older cipher suites the Java name has the
+   * prefix `SSL_`, causing the Java name to be different from the instance name which is always
+   * prefixed `TLS_`. For example, `TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName()` is
+   * `"SSL_RSA_EXPORT_WITH_RC4_40_MD5"`.
+   */
+  fun javaName(): String = javaName
+
+  override fun toString(): String = javaName
+
+  companion object {
+    /**
+     * Compares cipher suites names like "TLS_RSA_WITH_NULL_MD5" and "SSL_RSA_WITH_NULL_MD5",
+     * ignoring the "TLS_" or "SSL_" prefix which is not consistent across platforms. In particular
+     * some IBM JVMs use the "SSL_" prefix everywhere whereas Oracle JVMs mix "TLS_" and "SSL_".
+     */
+    internal val ORDER_BY_NAME = object: Comparator<String> {
+      override fun compare(a: String, b: String): Int {
+        var i = 4
+        val limit = Math.min(a.length, b.length)
+        while (i < limit) {
+          val charA = a.get(i)
+          val charB = b.get(i)
+          if (charA != charB) return if (charA < charB) -1 else 1
+          i++
+        }
+        val lengthA = a.length
+        val lengthB = b.length
+        if (lengthA != lengthB) return if (lengthA < lengthB) -1 else 1
+        return 0
+      }
+    }
+
+    /**
+     * Holds interned instances. This needs to be above the init() calls below so that it's
+     * initialized by the time those parts of `<clinit>()` run. Guarded by CipherSuite.class.
+     */
+    private val INSTANCES = mutableMapOf<String, CipherSuite>()
+
+    // Last updated 2016-07-03 using cipher suites from Android 24 and Java 9.
+
+    // @JvmField val TLS_NULL_WITH_NULL_NULL = init("TLS_NULL_WITH_NULL_NULL", 0x0000)
+    @JvmField val TLS_RSA_WITH_NULL_MD5 = init("SSL_RSA_WITH_NULL_MD5", 0x0001)
+    @JvmField val TLS_RSA_WITH_NULL_SHA = init("SSL_RSA_WITH_NULL_SHA", 0x0002)
+    @JvmField val TLS_RSA_EXPORT_WITH_RC4_40_MD5 = init("SSL_RSA_EXPORT_WITH_RC4_40_MD5", 0x0003)
+    @JvmField val TLS_RSA_WITH_RC4_128_MD5 = init("SSL_RSA_WITH_RC4_128_MD5", 0x0004)
+    @JvmField val TLS_RSA_WITH_RC4_128_SHA = init("SSL_RSA_WITH_RC4_128_SHA", 0x0005)
+    // @JvmField val TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = init("SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", 0x0006)
+    // @JvmField val TLS_RSA_WITH_IDEA_CBC_SHA = init("TLS_RSA_WITH_IDEA_CBC_SHA", 0x0007)
+    @JvmField val TLS_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0008)
+    @JvmField val TLS_RSA_WITH_DES_CBC_SHA = init("SSL_RSA_WITH_DES_CBC_SHA", 0x0009)
+    @JvmField val TLS_RSA_WITH_3DES_EDE_CBC_SHA = init("SSL_RSA_WITH_3DES_EDE_CBC_SHA", 0x000a)
+    // @JvmField val TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x000b)
+    // @JvmField val TLS_DH_DSS_WITH_DES_CBC_SHA = init("TLS_DH_DSS_WITH_DES_CBC_SHA", 0x000c)
+    // @JvmField val TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = init("TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA", 0x000d)
+    // @JvmField val TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x000e)
+    // @JvmField val TLS_DH_RSA_WITH_DES_CBC_SHA = init("TLS_DH_RSA_WITH_DES_CBC_SHA", 0x000f)
+    // @JvmField val TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA", 0x0010)
+    @JvmField val TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", 0x0011)
+    @JvmField val TLS_DHE_DSS_WITH_DES_CBC_SHA = init("SSL_DHE_DSS_WITH_DES_CBC_SHA", 0x0012)
+    @JvmField val TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = init("SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", 0x0013)
+    @JvmField val TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", 0x0014)
+    @JvmField val TLS_DHE_RSA_WITH_DES_CBC_SHA = init("SSL_DHE_RSA_WITH_DES_CBC_SHA", 0x0015)
+    @JvmField val TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = init("SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", 0x0016)
+    @JvmField val TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 = init("SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", 0x0017)
+    @JvmField val TLS_DH_anon_WITH_RC4_128_MD5 = init("SSL_DH_anon_WITH_RC4_128_MD5", 0x0018)
+    @JvmField val TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA = init("SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", 0x0019)
+    @JvmField val TLS_DH_anon_WITH_DES_CBC_SHA = init("SSL_DH_anon_WITH_DES_CBC_SHA", 0x001a)
+    @JvmField val TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = init("SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", 0x001b)
+    @JvmField val TLS_KRB5_WITH_DES_CBC_SHA = init("TLS_KRB5_WITH_DES_CBC_SHA", 0x001e)
+    @JvmField val TLS_KRB5_WITH_3DES_EDE_CBC_SHA = init("TLS_KRB5_WITH_3DES_EDE_CBC_SHA", 0x001f)
+    @JvmField val TLS_KRB5_WITH_RC4_128_SHA = init("TLS_KRB5_WITH_RC4_128_SHA", 0x0020)
+    // @JvmField val TLS_KRB5_WITH_IDEA_CBC_SHA = init("TLS_KRB5_WITH_IDEA_CBC_SHA", 0x0021)
+    @JvmField val TLS_KRB5_WITH_DES_CBC_MD5 = init("TLS_KRB5_WITH_DES_CBC_MD5", 0x0022)
+    @JvmField val TLS_KRB5_WITH_3DES_EDE_CBC_MD5 = init("TLS_KRB5_WITH_3DES_EDE_CBC_MD5", 0x0023)
+    @JvmField val TLS_KRB5_WITH_RC4_128_MD5 = init("TLS_KRB5_WITH_RC4_128_MD5", 0x0024)
+    // @JvmField val TLS_KRB5_WITH_IDEA_CBC_MD5 = init("TLS_KRB5_WITH_IDEA_CBC_MD5", 0x0025)
+    @JvmField val TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA = init("TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA", 0x0026)
+    // @JvmField val TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA = init("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA", 0x0027)
+    @JvmField val TLS_KRB5_EXPORT_WITH_RC4_40_SHA = init("TLS_KRB5_EXPORT_WITH_RC4_40_SHA", 0x0028)
+    @JvmField val TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 = init("TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5", 0x0029)
+    // @JvmField val TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 = init("TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5", 0x002a)
+    @JvmField val TLS_KRB5_EXPORT_WITH_RC4_40_MD5 = init("TLS_KRB5_EXPORT_WITH_RC4_40_MD5", 0x002b)
+    // @JvmField val TLS_PSK_WITH_NULL_SHA = init("TLS_PSK_WITH_NULL_SHA", 0x002c)
+    // @JvmField val TLS_DHE_PSK_WITH_NULL_SHA = init("TLS_DHE_PSK_WITH_NULL_SHA", 0x002d)
+    // @JvmField val TLS_RSA_PSK_WITH_NULL_SHA = init("TLS_RSA_PSK_WITH_NULL_SHA", 0x002e)
+    @JvmField val TLS_RSA_WITH_AES_128_CBC_SHA = init("TLS_RSA_WITH_AES_128_CBC_SHA", 0x002f)
+    // @JvmField val TLS_DH_DSS_WITH_AES_128_CBC_SHA = init("TLS_DH_DSS_WITH_AES_128_CBC_SHA", 0x0030)
+    // @JvmField val TLS_DH_RSA_WITH_AES_128_CBC_SHA = init("TLS_DH_RSA_WITH_AES_128_CBC_SHA", 0x0031)
+    @JvmField val TLS_DHE_DSS_WITH_AES_128_CBC_SHA = init("TLS_DHE_DSS_WITH_AES_128_CBC_SHA", 0x0032)
+    @JvmField val TLS_DHE_RSA_WITH_AES_128_CBC_SHA = init("TLS_DHE_RSA_WITH_AES_128_CBC_SHA", 0x0033)
+    @JvmField val TLS_DH_anon_WITH_AES_128_CBC_SHA = init("TLS_DH_anon_WITH_AES_128_CBC_SHA", 0x0034)
+    @JvmField val TLS_RSA_WITH_AES_256_CBC_SHA = init("TLS_RSA_WITH_AES_256_CBC_SHA", 0x0035)
+    // @JvmField val TLS_DH_DSS_WITH_AES_256_CBC_SHA = init("TLS_DH_DSS_WITH_AES_256_CBC_SHA", 0x0036)
+    // @JvmField val TLS_DH_RSA_WITH_AES_256_CBC_SHA = init("TLS_DH_RSA_WITH_AES_256_CBC_SHA", 0x0037)
+    @JvmField val TLS_DHE_DSS_WITH_AES_256_CBC_SHA = init("TLS_DHE_DSS_WITH_AES_256_CBC_SHA", 0x0038)
+    @JvmField val TLS_DHE_RSA_WITH_AES_256_CBC_SHA = init("TLS_DHE_RSA_WITH_AES_256_CBC_SHA", 0x0039)
+    @JvmField val TLS_DH_anon_WITH_AES_256_CBC_SHA = init("TLS_DH_anon_WITH_AES_256_CBC_SHA", 0x003a)
+    @JvmField val TLS_RSA_WITH_NULL_SHA256 = init("TLS_RSA_WITH_NULL_SHA256", 0x003b)
+    @JvmField val TLS_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_RSA_WITH_AES_128_CBC_SHA256", 0x003c)
+    @JvmField val TLS_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_RSA_WITH_AES_256_CBC_SHA256", 0x003d)
+    // @JvmField val TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_AES_128_CBC_SHA256", 0x003e)
+    // @JvmField val TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_AES_128_CBC_SHA256", 0x003f)
+    @JvmField val TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", 0x0040)
+    @JvmField val TLS_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0041)
+    // @JvmField val TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0042)
+    // @JvmField val TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0043)
+    @JvmField val TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA", 0x0044)
+    @JvmField val TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA", 0x0045)
+    // @JvmField val TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA = init("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA", 0x0046)
+    @JvmField val TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", 0x0067)
+    // @JvmField val TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = init("TLS_DH_DSS_WITH_AES_256_CBC_SHA256", 0x0068)
+    // @JvmField val TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_DH_RSA_WITH_AES_256_CBC_SHA256", 0x0069)
+    @JvmField val TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = init("TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", 0x006a)
+    @JvmField val TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = init("TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", 0x006b)
+    @JvmField val TLS_DH_anon_WITH_AES_128_CBC_SHA256 = init("TLS_DH_anon_WITH_AES_128_CBC_SHA256", 0x006c)
+    @JvmField val TLS_DH_anon_WITH_AES_256_CBC_SHA256 = init("TLS_DH_anon_WITH_AES_256_CBC_SHA256", 0x006d)
+    @JvmField val TLS_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0084)
+    // @JvmField val TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0085)
+    // @JvmField val TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0086)
+    @JvmField val TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA", 0x0087)
+    @JvmField val TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA", 0x0088)
+    // @JvmField val TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA = init("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA", 0x0089)
+    @JvmField val TLS_PSK_WITH_RC4_128_SHA = init("TLS_PSK_WITH_RC4_128_SHA", 0x008a)
+    @JvmField val TLS_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_PSK_WITH_3DES_EDE_CBC_SHA", 0x008b)
+    @JvmField val TLS_PSK_WITH_AES_128_CBC_SHA = init("TLS_PSK_WITH_AES_128_CBC_SHA", 0x008c)
+    @JvmField val TLS_PSK_WITH_AES_256_CBC_SHA = init("TLS_PSK_WITH_AES_256_CBC_SHA", 0x008d)
+    // @JvmField val TLS_DHE_PSK_WITH_RC4_128_SHA = init("TLS_DHE_PSK_WITH_RC4_128_SHA", 0x008e)
+    // @JvmField val TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA", 0x008f)
+    // @JvmField val TLS_DHE_PSK_WITH_AES_128_CBC_SHA = init("TLS_DHE_PSK_WITH_AES_128_CBC_SHA", 0x0090)
+    // @JvmField val TLS_DHE_PSK_WITH_AES_256_CBC_SHA = init("TLS_DHE_PSK_WITH_AES_256_CBC_SHA", 0x0091)
+    // @JvmField val TLS_RSA_PSK_WITH_RC4_128_SHA = init("TLS_RSA_PSK_WITH_RC4_128_SHA", 0x0092)
+    // @JvmField val TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA", 0x0093)
+    // @JvmField val TLS_RSA_PSK_WITH_AES_128_CBC_SHA = init("TLS_RSA_PSK_WITH_AES_128_CBC_SHA", 0x0094)
+    // @JvmField val TLS_RSA_PSK_WITH_AES_256_CBC_SHA = init("TLS_RSA_PSK_WITH_AES_256_CBC_SHA", 0x0095)
+    @JvmField val TLS_RSA_WITH_SEED_CBC_SHA = init("TLS_RSA_WITH_SEED_CBC_SHA", 0x0096)
+    // @JvmField val TLS_DH_DSS_WITH_SEED_CBC_SHA = init("TLS_DH_DSS_WITH_SEED_CBC_SHA", 0x0097)
+    // @JvmField val TLS_DH_RSA_WITH_SEED_CBC_SHA = init("TLS_DH_RSA_WITH_SEED_CBC_SHA", 0x0098)
+    // @JvmField val TLS_DHE_DSS_WITH_SEED_CBC_SHA = init("TLS_DHE_DSS_WITH_SEED_CBC_SHA", 0x0099)
+    // @JvmField val TLS_DHE_RSA_WITH_SEED_CBC_SHA = init("TLS_DHE_RSA_WITH_SEED_CBC_SHA", 0x009a)
+    // @JvmField val TLS_DH_anon_WITH_SEED_CBC_SHA = init("TLS_DH_anon_WITH_SEED_CBC_SHA", 0x009b)
+    @JvmField val TLS_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_RSA_WITH_AES_128_GCM_SHA256", 0x009c)
+    @JvmField val TLS_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_RSA_WITH_AES_256_GCM_SHA384", 0x009d)
+    @JvmField val TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_AES_128_GCM_SHA256", 0x009e)
+    @JvmField val TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_AES_256_GCM_SHA384", 0x009f)
+    // @JvmField val TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_AES_128_GCM_SHA256", 0x00a0)
+    // @JvmField val TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_AES_256_GCM_SHA384", 0x00a1)
+    @JvmField val TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_AES_128_GCM_SHA256", 0x00a2)
+    @JvmField val TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_AES_256_GCM_SHA384", 0x00a3)
+    // @JvmField val TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_AES_128_GCM_SHA256", 0x00a4)
+    // @JvmField val TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_AES_256_GCM_SHA384", 0x00a5)
+    @JvmField val TLS_DH_anon_WITH_AES_128_GCM_SHA256 = init("TLS_DH_anon_WITH_AES_128_GCM_SHA256", 0x00a6)
+    @JvmField val TLS_DH_anon_WITH_AES_256_GCM_SHA384 = init("TLS_DH_anon_WITH_AES_256_GCM_SHA384", 0x00a7)
+    // @JvmField val TLS_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_PSK_WITH_AES_128_GCM_SHA256", 0x00a8)
+    // @JvmField val TLS_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_PSK_WITH_AES_256_GCM_SHA384", 0x00a9)
+    // @JvmField val TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_AES_128_GCM_SHA256", 0x00aa)
+    // @JvmField val TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_AES_256_GCM_SHA384", 0x00ab)
+    // @JvmField val TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_AES_128_GCM_SHA256", 0x00ac)
+    // @JvmField val TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_AES_256_GCM_SHA384", 0x00ad)
+    // @JvmField val TLS_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_PSK_WITH_AES_128_CBC_SHA256", 0x00ae)
+    // @JvmField val TLS_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_PSK_WITH_AES_256_CBC_SHA384", 0x00af)
+    // @JvmField val TLS_PSK_WITH_NULL_SHA256 = init("TLS_PSK_WITH_NULL_SHA256", 0x00b0)
+    // @JvmField val TLS_PSK_WITH_NULL_SHA384 = init("TLS_PSK_WITH_NULL_SHA384", 0x00b1)
+    // @JvmField val TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_AES_128_CBC_SHA256", 0x00b2)
+    // @JvmField val TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_AES_256_CBC_SHA384", 0x00b3)
+    // @JvmField val TLS_DHE_PSK_WITH_NULL_SHA256 = init("TLS_DHE_PSK_WITH_NULL_SHA256", 0x00b4)
+    // @JvmField val TLS_DHE_PSK_WITH_NULL_SHA384 = init("TLS_DHE_PSK_WITH_NULL_SHA384", 0x00b5)
+    // @JvmField val TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_AES_128_CBC_SHA256", 0x00b6)
+    // @JvmField val TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_AES_256_CBC_SHA384", 0x00b7)
+    // @JvmField val TLS_RSA_PSK_WITH_NULL_SHA256 = init("TLS_RSA_PSK_WITH_NULL_SHA256", 0x00b8)
+    // @JvmField val TLS_RSA_PSK_WITH_NULL_SHA384 = init("TLS_RSA_PSK_WITH_NULL_SHA384", 0x00b9)
+    // @JvmField val TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00ba)
+    // @JvmField val TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bb)
+    // @JvmField val TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00bc)
+    // @JvmField val TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256", 0x00bd)
+    // @JvmField val TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0x00be)
+    // @JvmField val TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256", 0x00bf)
+    // @JvmField val TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c0)
+    // @JvmField val TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c1)
+    // @JvmField val TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c2)
+    // @JvmField val TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256", 0x00c3)
+    // @JvmField val TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256", 0x00c4)
+    // @JvmField val TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256", 0x00c5)
+    @JvmField val TLS_EMPTY_RENEGOTIATION_INFO_SCSV = init("TLS_EMPTY_RENEGOTIATION_INFO_SCSV", 0x00ff)
+    @JvmField val TLS_FALLBACK_SCSV = init("TLS_FALLBACK_SCSV", 0x5600)
+    @JvmField val TLS_ECDH_ECDSA_WITH_NULL_SHA = init("TLS_ECDH_ECDSA_WITH_NULL_SHA", 0xc001)
+    @JvmField val TLS_ECDH_ECDSA_WITH_RC4_128_SHA = init("TLS_ECDH_ECDSA_WITH_RC4_128_SHA", 0xc002)
+    @JvmField val TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc003)
+    @JvmField val TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", 0xc004)
+    @JvmField val TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = init("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", 0xc005)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_NULL_SHA = init("TLS_ECDHE_ECDSA_WITH_NULL_SHA", 0xc006)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = init("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", 0xc007)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", 0xc008)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", 0xc009)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", 0xc00a)
+    @JvmField val TLS_ECDH_RSA_WITH_NULL_SHA = init("TLS_ECDH_RSA_WITH_NULL_SHA", 0xc00b)
+    @JvmField val TLS_ECDH_RSA_WITH_RC4_128_SHA = init("TLS_ECDH_RSA_WITH_RC4_128_SHA", 0xc00c)
+    @JvmField val TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", 0xc00d)
+    @JvmField val TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = init("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", 0xc00e)
+    @JvmField val TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = init("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", 0xc00f)
+    @JvmField val TLS_ECDHE_RSA_WITH_NULL_SHA = init("TLS_ECDHE_RSA_WITH_NULL_SHA", 0xc010)
+    @JvmField val TLS_ECDHE_RSA_WITH_RC4_128_SHA = init("TLS_ECDHE_RSA_WITH_RC4_128_SHA", 0xc011)
+    @JvmField val TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", 0xc012)
+    @JvmField val TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", 0xc013)
+    @JvmField val TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", 0xc014)
+    @JvmField val TLS_ECDH_anon_WITH_NULL_SHA = init("TLS_ECDH_anon_WITH_NULL_SHA", 0xc015)
+    @JvmField val TLS_ECDH_anon_WITH_RC4_128_SHA = init("TLS_ECDH_anon_WITH_RC4_128_SHA", 0xc016)
+    @JvmField val TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA", 0xc017)
+    @JvmField val TLS_ECDH_anon_WITH_AES_128_CBC_SHA = init("TLS_ECDH_anon_WITH_AES_128_CBC_SHA", 0xc018)
+    @JvmField val TLS_ECDH_anon_WITH_AES_256_CBC_SHA = init("TLS_ECDH_anon_WITH_AES_256_CBC_SHA", 0xc019)
+    // @JvmField val TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA", 0xc01a)
+    // @JvmField val TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA", 0xc01b)
+    // @JvmField val TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA", 0xc01c)
+    // @JvmField val TLS_SRP_SHA_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_WITH_AES_128_CBC_SHA", 0xc01d)
+    // @JvmField val TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA", 0xc01e)
+    // @JvmField val TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA", 0xc01f)
+    // @JvmField val TLS_SRP_SHA_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_WITH_AES_256_CBC_SHA", 0xc020)
+    // @JvmField val TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA", 0xc021)
+    // @JvmField val TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = init("TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA", 0xc022)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", 0xc023)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", 0xc024)
+    @JvmField val TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", 0xc025)
+    @JvmField val TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", 0xc026)
+    @JvmField val TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", 0xc027)
+    @JvmField val TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", 0xc028)
+    @JvmField val TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", 0xc029)
+    @JvmField val TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", 0xc02a)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02b)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02c)
+    @JvmField val TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256", 0xc02d)
+    @JvmField val TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384", 0xc02e)
+    @JvmField val TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", 0xc02f)
+    @JvmField val TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", 0xc030)
+    @JvmField val TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256", 0xc031)
+    @JvmField val TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384", 0xc032)
+    // @JvmField val TLS_ECDHE_PSK_WITH_RC4_128_SHA = init("TLS_ECDHE_PSK_WITH_RC4_128_SHA", 0xc033)
+    // @JvmField val TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = init("TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA", 0xc034)
+    @JvmField val TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = init("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA", 0xc035)
+    @JvmField val TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = init("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA", 0xc036)
+    // @JvmField val TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256", 0xc037)
+    // @JvmField val TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384", 0xc038)
+    // @JvmField val TLS_ECDHE_PSK_WITH_NULL_SHA = init("TLS_ECDHE_PSK_WITH_NULL_SHA", 0xc039)
+    // @JvmField val TLS_ECDHE_PSK_WITH_NULL_SHA256 = init("TLS_ECDHE_PSK_WITH_NULL_SHA256", 0xc03a)
+    // @JvmField val TLS_ECDHE_PSK_WITH_NULL_SHA384 = init("TLS_ECDHE_PSK_WITH_NULL_SHA384", 0xc03b)
+    // @JvmField val TLS_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_RSA_WITH_ARIA_128_CBC_SHA256", 0xc03c)
+    // @JvmField val TLS_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_RSA_WITH_ARIA_256_CBC_SHA384", 0xc03d)
+    // @JvmField val TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256", 0xc03e)
+    // @JvmField val TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384", 0xc03f)
+    // @JvmField val TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc040)
+    // @JvmField val TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc041)
+    // @JvmField val TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256", 0xc042)
+    // @JvmField val TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384", 0xc043)
+    // @JvmField val TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc044)
+    // @JvmField val TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc045)
+    // @JvmField val TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 = init("TLS_DH_anon_WITH_ARIA_128_CBC_SHA256", 0xc046)
+    // @JvmField val TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 = init("TLS_DH_anon_WITH_ARIA_256_CBC_SHA384", 0xc047)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc048)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc049)
+    // @JvmField val TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256", 0xc04a)
+    // @JvmField val TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384", 0xc04b)
+    // @JvmField val TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04c)
+    // @JvmField val TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04d)
+    // @JvmField val TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256", 0xc04e)
+    // @JvmField val TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384", 0xc04f)
+    // @JvmField val TLS_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_RSA_WITH_ARIA_128_GCM_SHA256", 0xc050)
+    // @JvmField val TLS_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_RSA_WITH_ARIA_256_GCM_SHA384", 0xc051)
+    // @JvmField val TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc052)
+    // @JvmField val TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc053)
+    // @JvmField val TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc054)
+    // @JvmField val TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc055)
+    // @JvmField val TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256", 0xc056)
+    // @JvmField val TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384", 0xc057)
+    // @JvmField val TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256", 0xc058)
+    // @JvmField val TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384", 0xc059)
+    // @JvmField val TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 = init("TLS_DH_anon_WITH_ARIA_128_GCM_SHA256", 0xc05a)
+    // @JvmField val TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 = init("TLS_DH_anon_WITH_ARIA_256_GCM_SHA384", 0xc05b)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05c)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05d)
+    // @JvmField val TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256", 0xc05e)
+    // @JvmField val TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384", 0xc05f)
+    // @JvmField val TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256", 0xc060)
+    // @JvmField val TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384", 0xc061)
+    // @JvmField val TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256", 0xc062)
+    // @JvmField val TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384", 0xc063)
+    // @JvmField val TLS_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_PSK_WITH_ARIA_128_CBC_SHA256", 0xc064)
+    // @JvmField val TLS_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_PSK_WITH_ARIA_256_CBC_SHA384", 0xc065)
+    // @JvmField val TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc066)
+    // @JvmField val TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc067)
+    // @JvmField val TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256", 0xc068)
+    // @JvmField val TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384", 0xc069)
+    // @JvmField val TLS_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06a)
+    // @JvmField val TLS_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06b)
+    // @JvmField val TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06c)
+    // @JvmField val TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06d)
+    // @JvmField val TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256", 0xc06e)
+    // @JvmField val TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384", 0xc06f)
+    // @JvmField val TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256", 0xc070)
+    // @JvmField val TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384", 0xc071)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc072)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc073)
+    // @JvmField val TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc074)
+    // @JvmField val TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc075)
+    // @JvmField val TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc076)
+    // @JvmField val TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc077)
+    // @JvmField val TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256", 0xc078)
+    // @JvmField val TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384", 0xc079)
+    // @JvmField val TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07a)
+    // @JvmField val TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07b)
+    // @JvmField val TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07c)
+    // @JvmField val TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07d)
+    // @JvmField val TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc07e)
+    // @JvmField val TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc07f)
+    // @JvmField val TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc080)
+    // @JvmField val TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc081)
+    // @JvmField val TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256", 0xc082)
+    // @JvmField val TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384", 0xc083)
+    // @JvmField val TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256", 0xc084)
+    // @JvmField val TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384", 0xc085)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc086)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc087)
+    // @JvmField val TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc088)
+    // @JvmField val TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc089)
+    // @JvmField val TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08a)
+    // @JvmField val TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08b)
+    // @JvmField val TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256", 0xc08c)
+    // @JvmField val TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384", 0xc08d)
+    // @JvmField val TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc08e)
+    // @JvmField val TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc08f)
+    // @JvmField val TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc090)
+    // @JvmField val TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc091)
+    // @JvmField val TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 = init("TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256", 0xc092)
+    // @JvmField val TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 = init("TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384", 0xc093)
+    // @JvmField val TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc094)
+    // @JvmField val TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc095)
+    // @JvmField val TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc096)
+    // @JvmField val TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc097)
+    // @JvmField val TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc098)
+    // @JvmField val TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc099)
+    // @JvmField val TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = init("TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256", 0xc09a)
+    // @JvmField val TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = init("TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384", 0xc09b)
+    // @JvmField val TLS_RSA_WITH_AES_128_CCM = init("TLS_RSA_WITH_AES_128_CCM", 0xc09c)
+    // @JvmField val TLS_RSA_WITH_AES_256_CCM = init("TLS_RSA_WITH_AES_256_CCM", 0xc09d)
+    // @JvmField val TLS_DHE_RSA_WITH_AES_128_CCM = init("TLS_DHE_RSA_WITH_AES_128_CCM", 0xc09e)
+    // @JvmField val TLS_DHE_RSA_WITH_AES_256_CCM = init("TLS_DHE_RSA_WITH_AES_256_CCM", 0xc09f)
+    // @JvmField val TLS_RSA_WITH_AES_128_CCM_8 = init("TLS_RSA_WITH_AES_128_CCM_8", 0xc0a0)
+    // @JvmField val TLS_RSA_WITH_AES_256_CCM_8 = init("TLS_RSA_WITH_AES_256_CCM_8", 0xc0a1)
+    // @JvmField val TLS_DHE_RSA_WITH_AES_128_CCM_8 = init("TLS_DHE_RSA_WITH_AES_128_CCM_8", 0xc0a2)
+    // @JvmField val TLS_DHE_RSA_WITH_AES_256_CCM_8 = init("TLS_DHE_RSA_WITH_AES_256_CCM_8", 0xc0a3)
+    // @JvmField val TLS_PSK_WITH_AES_128_CCM = init("TLS_PSK_WITH_AES_128_CCM", 0xc0a4)
+    // @JvmField val TLS_PSK_WITH_AES_256_CCM = init("TLS_PSK_WITH_AES_256_CCM", 0xc0a5)
+    // @JvmField val TLS_DHE_PSK_WITH_AES_128_CCM = init("TLS_DHE_PSK_WITH_AES_128_CCM", 0xc0a6)
+    // @JvmField val TLS_DHE_PSK_WITH_AES_256_CCM = init("TLS_DHE_PSK_WITH_AES_256_CCM", 0xc0a7)
+    // @JvmField val TLS_PSK_WITH_AES_128_CCM_8 = init("TLS_PSK_WITH_AES_128_CCM_8", 0xc0a8)
+    // @JvmField val TLS_PSK_WITH_AES_256_CCM_8 = init("TLS_PSK_WITH_AES_256_CCM_8", 0xc0a9)
+    // @JvmField val TLS_PSK_DHE_WITH_AES_128_CCM_8 = init("TLS_PSK_DHE_WITH_AES_128_CCM_8", 0xc0aa)
+    // @JvmField val TLS_PSK_DHE_WITH_AES_256_CCM_8 = init("TLS_PSK_DHE_WITH_AES_256_CCM_8", 0xc0ab)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_AES_128_CCM = init("TLS_ECDHE_ECDSA_WITH_AES_128_CCM", 0xc0ac)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_AES_256_CCM = init("TLS_ECDHE_ECDSA_WITH_AES_256_CCM", 0xc0ad)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 = init("TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8", 0xc0ae)
+    // @JvmField val TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = init("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af)
+    @JvmField val TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8)
+    @JvmField val TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9)
+    @JvmField val TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa)
+    // @JvmField val TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccab)
+    @JvmField val TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac)
+    // @JvmField val TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccad)
+    // @JvmField val TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = init("TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccae)
+
+    // TLS 1.3 https://tools.ietf.org/html/rfc8446
+    @JvmField val TLS_AES_128_GCM_SHA256 = init("TLS_AES_128_GCM_SHA256", 0x1301)
+    @JvmField val TLS_AES_256_GCM_SHA384 = init("TLS_AES_256_GCM_SHA384", 0x1302)
+    @JvmField val TLS_CHACHA20_POLY1305_SHA256 = init("TLS_CHACHA20_POLY1305_SHA256", 0x1303)
+    @JvmField val TLS_AES_128_CCM_SHA256 = init("TLS_AES_128_CCM_SHA256", 0x1304)
+    @JvmField val TLS_AES_128_CCM_8_SHA256 = init("TLS_AES_128_CCM_8_SHA256", 0x1305)
+
+    /**
+     * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA
+     *     name for older cipher suites because the prefix is `SSL_` instead of `TLS_`.
+     */
+    @JvmStatic
+    @Synchronized fun forJavaName(javaName: String): CipherSuite {
+      var result: CipherSuite? = INSTANCES[javaName]
+      if (result == null) {
+        result = INSTANCES[secondaryName(javaName)]
+
+        if (result == null) {
+          result = CipherSuite(javaName)
+        }
+
+        // Add the new cipher suite, or a confirmed alias.
+        INSTANCES[javaName] = result
+      }
+      return result
+    }
+
+    private fun secondaryName(javaName: String): String {
+      return when {
+        javaName.startsWith("TLS_") -> "SSL_" + javaName.substring(4)
+        javaName.startsWith("SSL_") -> "TLS_" + javaName.substring(4)
+        else -> javaName
+      }
+    }
+
+    /**
+     * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA
+     *     name for older cipher suites because the prefix is `SSL_` instead of `TLS_`.
+     * @param value the integer identifier for this cipher suite. (Documentation only.)
+     */
+    private fun init(javaName: String, value: Int): CipherSuite {
+      val suite = CipherSuite(javaName)
+      INSTANCES[javaName] = suite
+      return suite
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Connection.java b/okhttp/src/main/java/okhttp3/Connection.java
deleted file mode 100644
index cb6d70996d..0000000000
--- a/okhttp/src/main/java/okhttp3/Connection.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package okhttp3;
-
-import java.net.Socket;
-import javax.annotation.Nullable;
-
-/**
- * The sockets and streams of an HTTP, HTTPS, or HTTPS+HTTP/2 connection. May be used for multiple
- * HTTP request/response exchanges. Connections may be direct to the origin server or via a proxy.
- *
- * <p>Typically instances of this class are created, connected and exercised automatically by the
- * HTTP client. Applications may use this class to monitor HTTP connections as members of a
- * {@linkplain ConnectionPool connection pool}.
- *
- * <p>Do not confuse this class with the misnamed {@code HttpURLConnection}, which isn't so much a
- * connection as a single request/response exchange.
- *
- * <h3>Modern TLS</h3>
- *
- * <p>There are tradeoffs when selecting which options to include when negotiating a secure
- * connection to a remote host. Newer TLS options are quite useful:
- *
- * <ul>
- *     <li>Server Name Indication (SNI) enables one IP address to negotiate secure connections for
- *         multiple domain names.
- *     <li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used to
- *         negotiate HTTP/2.
- * </ul>
- *
- * <p>Unfortunately, older HTTPS servers refuse to connect when such options are presented. Rather
- * than avoiding these options entirely, this class allows a connection to be attempted with modern
- * options and then retried without them should the attempt fail.
- *
- * <h3>Connection Reuse</h3>
- *
- * <p>Each connection can carry a varying number of streams, depending on the underlying protocol
- * being used. HTTP/1.x connections can carry either zero or one streams. HTTP/2 connections can
- * carry any number of streams, dynamically configured with {@code SETTINGS_MAX_CONCURRENT_STREAMS}.
- * A connection currently carrying zero streams is an idle stream. We keep it alive because reusing
- * an existing connection is typically faster than establishing a new one.
- *
- * <p>When a single logical call requires multiple streams due to redirects or authorization
- * challenges, we prefer to use the same physical connection for all streams in the sequence. There
- * are potential performance and behavior consequences to this preference. To support this feature,
- * this class separates <i>allocations</i> from <i>streams</i>. An allocation is created by a call,
- * used for one or more streams, and then released. An allocated connection won't be stolen by other
- * calls while a redirect or authorization challenge is being handled.
- *
- * <p>When the maximum concurrent streams limit is reduced, some allocations will be rescinded.
- * Attempting to create new streams on these allocations will fail.
- *
- * <p>Note that an allocation may be released before its stream is completed. This is intended to
- * make bookkeeping easier for the caller: releasing the allocation as soon as the terminal stream
- * has been found. But only complete the stream once its data stream has been exhausted.
- */
-public interface Connection {
-  /** Returns the route used by this connection. */
-  Route route();
-
-  /**
-   * Returns the socket that this connection is using. Returns an {@linkplain
-   * javax.net.ssl.SSLSocket SSL socket} if this connection is HTTPS. If this is an HTTP/2
-   * connection the socket may be shared by multiple concurrent calls.
-   */
-  Socket socket();
-
-  /**
-   * Returns the TLS handshake used to establish this connection, or null if the connection is not
-   * HTTPS.
-   */
-  @Nullable Handshake handshake();
-
-  /**
-   * Returns the protocol negotiated by this connection, or {@link Protocol#HTTP_1_1} if no protocol
-   * has been negotiated. This method returns {@link Protocol#HTTP_1_1} even if the remote peer is
-   * using {@link Protocol#HTTP_1_0}.
-   */
-  Protocol protocol();
-}
diff --git a/okhttp/src/main/java/okhttp3/Connection.kt b/okhttp/src/main/java/okhttp3/Connection.kt
new file mode 100644
index 0000000000..20dda3de9d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Connection.kt
@@ -0,0 +1,92 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3
+
+import java.net.Socket
+
+/**
+ * The sockets and streams of an HTTP, HTTPS, or HTTPS+HTTP/2 connection. May be used for multiple
+ * HTTP request/response exchanges. Connections may be direct to the origin server or via a proxy.
+ *
+ * Typically instances of this class are created, connected and exercised automatically by the HTTP
+ * client. Applications may use this class to monitor HTTP connections as members of a
+ * [connection pool][ConnectionPool].
+ *
+ * Do not confuse this class with the misnamed `HttpURLConnection`, which isn't so much a connection
+ * as a single request/response exchange.
+ *
+ * ## Modern TLS
+ *
+ * There are trade-offs when selecting which options to include when negotiating a secure connection
+ * to a remote host. Newer TLS options are quite useful:
+ *
+ *  * Server Name Indication (SNI) enables one IP address to negotiate secure connections for
+ *    multiple domain names.
+ *
+ *  * Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used to
+ *    negotiate HTTP/2.
+ *
+ * Unfortunately, older HTTPS servers refuse to connect when such options are presented. Rather than
+ * avoiding these options entirely, this class allows a connection to be attempted with modern
+ * options and then retried without them should the attempt fail.
+ *
+ * ## Connection Reuse
+ *
+ * Each connection can carry a varying number of streams, depending on the underlying protocol being
+ * used. HTTP/1.x connections can carry either zero or one streams. HTTP/2 connections can carry any
+ * number of streams, dynamically configured with `SETTINGS_MAX_CONCURRENT_STREAMS`. A connection
+ * currently carrying zero streams is an idle stream. We keep it alive because reusing an existing
+ * connection is typically faster than establishing a new one.
+ *
+ * When a single logical call requires multiple streams due to redirects or authorization
+ * challenges, we prefer to use the same physical connection for all streams in the sequence. There
+ * are potential performance and behavior consequences to this preference. To support this feature,
+ * this class separates _allocations_ from _streams_. An allocation is created by a call, used for
+ * one or more streams, and then released. An allocated connection won't be stolen by other calls
+ * while a redirect or authorization challenge is being handled.
+ *
+ * When the maximum concurrent streams limit is reduced, some allocations will be rescinded.
+ * Attempting to create new streams on these allocations will fail.
+ *
+ * Note that an allocation may be released before its stream is completed. This is intended to make
+ * bookkeeping easier for the caller: releasing the allocation as soon as the terminal stream has
+ * been found. But only complete the stream once its data stream has been exhausted.
+ */
+interface Connection {
+  /** Returns the route used by this connection. */
+  fun route(): Route
+
+  /**
+   * Returns the socket that this connection is using. Returns an
+   * [SSL socket][javax.net.ssl.SSLSocket] if this connection is HTTPS. If this is an HTTP/2
+   * connection the socket may be shared by multiple concurrent calls.
+   */
+  fun socket(): Socket
+
+  /**
+   * Returns the TLS handshake used to establish this connection, or null if the connection is not
+   * HTTPS.
+   */
+  fun handshake(): Handshake?
+
+  /**
+   * Returns the protocol negotiated by this connection, or [Protocol.HTTP_1_1] if no protocol
+   * has been negotiated. This method returns [Protocol.HTTP_1_1] even if the remote peer is using
+   * [Protocol.HTTP_1_0].
+   */
+  fun protocol(): Protocol
+}
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.kt b/okhttp/src/main/java/okhttp3/ConnectionPool.kt
new file mode 100644
index 0000000000..0a85d80849
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.kt
@@ -0,0 +1,53 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.connection.RealConnectionPool
+import java.util.concurrent.TimeUnit
+
+/**
+ * Manages reuse of HTTP and HTTP/2 connections for reduced network latency. HTTP requests that
+ * share the same [Address] may share a [Connection]. This class implements the policy
+ * of which connections to keep open for future use.
+ *
+ * @constructor Create a new connection pool with tuning parameters appropriate for a single-user
+ * application. The tuning parameters in this pool are subject to change in future OkHttp releases.
+ * Currently this pool holds up to 5 idle connections which will be evicted after 5 minutes of
+ * inactivity.
+ */
+class ConnectionPool(
+  maxIdleConnections: Int,
+  keepAliveDuration: Long,
+  timeUnit: TimeUnit
+) {
+  // TODO(kotlin): remove @JvmField once OkHttpClient is in Kotlin
+  @JvmField internal val delegate =
+      RealConnectionPool(maxIdleConnections, keepAliveDuration, timeUnit)
+
+  constructor() : this(5, 5, TimeUnit.MINUTES)
+
+  /** Returns the number of idle connections in the pool.  */
+  fun idleConnectionCount(): Int = delegate.idleConnectionCount()
+
+  /** Returns total number of connections in the pool.  */
+  fun connectionCount(): Int = delegate.connectionCount()
+
+  /** Close and remove all idle connections in the pool.  */
+  fun evictAll() {
+    delegate.evictAll()
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
deleted file mode 100644
index a2f2a627b7..0000000000
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ /dev/null
@@ -1,326 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.Arrays;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLSocket;
-import okhttp3.internal.Util;
-
-import static okhttp3.internal.Util.concat;
-import static okhttp3.internal.Util.indexOf;
-import static okhttp3.internal.Util.intersect;
-import static okhttp3.internal.Util.nonEmptyIntersection;
-
-/**
- * Specifies configuration for the socket connection that HTTP traffic travels through. For {@code
- * https:} URLs, this includes the TLS version and cipher suites to use when negotiating a secure
- * connection.
- *
- * <p>The TLS versions configured in a connection spec are only be used if they are also enabled in
- * the SSL socket. For example, if an SSL socket does not have TLS 1.3 enabled, it will not be used
- * even if it is present on the connection spec. The same policy also applies to cipher suites.
- *
- * <p>Use {@link Builder#allEnabledTlsVersions()} and {@link Builder#allEnabledCipherSuites} to
- * defer all feature selection to the underlying SSL socket.
- */
-public final class ConnectionSpec {
-
-  // Most secure but generally supported list.
-  private static final CipherSuite[] RESTRICTED_CIPHER_SUITES = new CipherSuite[] {
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
-  };
-
-  // This is nearly equal to the cipher suites supported in Chrome 51, current as of 2016-05-25.
-  // All of these suites are available on Android 7.0; earlier releases support a subset of these
-  // suites. https://github.com/square/okhttp/issues/1972
-  private static final CipherSuite[] APPROVED_CIPHER_SUITES = new CipherSuite[] {
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
-      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
-
-      // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
-      // continue to include them until better suites are commonly available. For example, none
-      // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
-      CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
-      CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,
-      CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
-      CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
-  };
-
-  /** A secure TLS connection assuming a modern client platform and server. */
-  public static final ConnectionSpec RESTRICTED_TLS = new Builder(true)
-      .cipherSuites(RESTRICTED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
-      .supportsTlsExtensions(true)
-      .build();
-
-  /** A modern TLS connection with extensions like SNI and ALPN available. */
-  public static final ConnectionSpec MODERN_TLS = new Builder(true)
-      .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
-      .supportsTlsExtensions(true)
-      .build();
-
-  /** A backwards-compatible fallback connection for interop with obsolete servers. */
-  public static final ConnectionSpec COMPATIBLE_TLS = new Builder(MODERN_TLS)
-      .tlsVersions(TlsVersion.TLS_1_0)
-      .supportsTlsExtensions(true)
-      .build();
-
-  /** Unencrypted, unauthenticated connections for {@code http:} URLs. */
-  public static final ConnectionSpec CLEARTEXT = new Builder(false).build();
-
-  final boolean tls;
-  final boolean supportsTlsExtensions;
-  final @Nullable String[] cipherSuites;
-  final @Nullable String[] tlsVersions;
-
-  ConnectionSpec(Builder builder) {
-    this.tls = builder.tls;
-    this.cipherSuites = builder.cipherSuites;
-    this.tlsVersions = builder.tlsVersions;
-    this.supportsTlsExtensions = builder.supportsTlsExtensions;
-  }
-
-  public boolean isTls() {
-    return tls;
-  }
-
-  /**
-   * Returns the cipher suites to use for a connection. Returns null if all of the SSL socket's
-   * enabled cipher suites should be used.
-   */
-  public @Nullable List<CipherSuite> cipherSuites() {
-    return cipherSuites != null ? CipherSuite.forJavaNames(cipherSuites) : null;
-  }
-
-  /**
-   * Returns the TLS versions to use when negotiating a connection. Returns null if all of the SSL
-   * socket's enabled TLS versions should be used.
-   */
-  public @Nullable List<TlsVersion> tlsVersions() {
-    return tlsVersions != null ? TlsVersion.forJavaNames(tlsVersions) : null;
-  }
-
-  public boolean supportsTlsExtensions() {
-    return supportsTlsExtensions;
-  }
-
-  /** Applies this spec to {@code sslSocket}. */
-  void apply(SSLSocket sslSocket, boolean isFallback) {
-    ConnectionSpec specToApply = supportedSpec(sslSocket, isFallback);
-
-    if (specToApply.tlsVersions != null) {
-      sslSocket.setEnabledProtocols(specToApply.tlsVersions);
-    }
-    if (specToApply.cipherSuites != null) {
-      sslSocket.setEnabledCipherSuites(specToApply.cipherSuites);
-    }
-  }
-
-  /**
-   * Returns a copy of this that omits cipher suites and TLS versions not enabled by {@code
-   * sslSocket}.
-   */
-  private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
-    String[] cipherSuitesIntersection = cipherSuites != null
-        ? intersect(CipherSuite.ORDER_BY_NAME, sslSocket.getEnabledCipherSuites(), cipherSuites)
-        : sslSocket.getEnabledCipherSuites();
-    String[] tlsVersionsIntersection = tlsVersions != null
-        ? intersect(Util.NATURAL_ORDER, sslSocket.getEnabledProtocols(), tlsVersions)
-        : sslSocket.getEnabledProtocols();
-
-    // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
-    // the SCSV cipher is added to signal that a protocol fallback has taken place.
-    String[] supportedCipherSuites = sslSocket.getSupportedCipherSuites();
-    int indexOfFallbackScsv = indexOf(
-        CipherSuite.ORDER_BY_NAME, supportedCipherSuites, "TLS_FALLBACK_SCSV");
-    if (isFallback && indexOfFallbackScsv != -1) {
-      cipherSuitesIntersection = concat(
-          cipherSuitesIntersection, supportedCipherSuites[indexOfFallbackScsv]);
-    }
-
-    return new Builder(this)
-        .cipherSuites(cipherSuitesIntersection)
-        .tlsVersions(tlsVersionsIntersection)
-        .build();
-  }
-
-  /**
-   * Returns {@code true} if the socket, as currently configured, supports this connection spec. In
-   * order for a socket to be compatible the enabled cipher suites and protocols must intersect.
-   *
-   * <p>For cipher suites, at least one of the {@link #cipherSuites() required cipher suites} must
-   * match the socket's enabled cipher suites. If there are no required cipher suites the socket
-   * must have at least one cipher suite enabled.
-   *
-   * <p>For protocols, at least one of the {@link #tlsVersions() required protocols} must match the
-   * socket's enabled protocols.
-   */
-  public boolean isCompatible(SSLSocket socket) {
-    if (!tls) {
-      return false;
-    }
-
-    if (tlsVersions != null && !nonEmptyIntersection(
-        Util.NATURAL_ORDER, tlsVersions, socket.getEnabledProtocols())) {
-      return false;
-    }
-
-    if (cipherSuites != null && !nonEmptyIntersection(
-        CipherSuite.ORDER_BY_NAME, cipherSuites, socket.getEnabledCipherSuites())) {
-      return false;
-    }
-
-    return true;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    if (!(other instanceof ConnectionSpec)) return false;
-    if (other == this) return true;
-
-    ConnectionSpec that = (ConnectionSpec) other;
-    if (this.tls != that.tls) return false;
-
-    if (tls) {
-      if (!Arrays.equals(this.cipherSuites, that.cipherSuites)) return false;
-      if (!Arrays.equals(this.tlsVersions, that.tlsVersions)) return false;
-      if (this.supportsTlsExtensions != that.supportsTlsExtensions) return false;
-    }
-
-    return true;
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    if (tls) {
-      result = 31 * result + Arrays.hashCode(cipherSuites);
-      result = 31 * result + Arrays.hashCode(tlsVersions);
-      result = 31 * result + (supportsTlsExtensions ? 0 : 1);
-    }
-    return result;
-  }
-
-  @Override public String toString() {
-    if (!tls) {
-      return "ConnectionSpec()";
-    }
-
-    String cipherSuitesString = cipherSuites != null ? cipherSuites().toString() : "[all enabled]";
-    String tlsVersionsString = tlsVersions != null ? tlsVersions().toString() : "[all enabled]";
-    return "ConnectionSpec("
-        + "cipherSuites=" + cipherSuitesString
-        + ", tlsVersions=" + tlsVersionsString
-        + ", supportsTlsExtensions=" + supportsTlsExtensions
-        + ")";
-  }
-
-  public static final class Builder {
-    boolean tls;
-    @Nullable String[] cipherSuites;
-    @Nullable String[] tlsVersions;
-    boolean supportsTlsExtensions;
-
-    Builder(boolean tls) {
-      this.tls = tls;
-    }
-
-    public Builder(ConnectionSpec connectionSpec) {
-      this.tls = connectionSpec.tls;
-      this.cipherSuites = connectionSpec.cipherSuites;
-      this.tlsVersions = connectionSpec.tlsVersions;
-      this.supportsTlsExtensions = connectionSpec.supportsTlsExtensions;
-    }
-
-    public Builder allEnabledCipherSuites() {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
-      this.cipherSuites = null;
-      return this;
-    }
-
-    public Builder cipherSuites(CipherSuite... cipherSuites) {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
-
-      String[] strings = new String[cipherSuites.length];
-      for (int i = 0; i < cipherSuites.length; i++) {
-        strings[i] = cipherSuites[i].javaName;
-      }
-      return cipherSuites(strings);
-    }
-
-    public Builder cipherSuites(String... cipherSuites) {
-      if (!tls) throw new IllegalStateException("no cipher suites for cleartext connections");
-
-      if (cipherSuites.length == 0) {
-        throw new IllegalArgumentException("At least one cipher suite is required");
-      }
-
-      this.cipherSuites = cipherSuites.clone(); // Defensive copy.
-      return this;
-    }
-
-    public Builder allEnabledTlsVersions() {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
-      this.tlsVersions = null;
-      return this;
-    }
-
-    public Builder tlsVersions(TlsVersion... tlsVersions) {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
-
-      String[] strings = new String[tlsVersions.length];
-      for (int i = 0; i < tlsVersions.length; i++) {
-        strings[i] = tlsVersions[i].javaName;
-      }
-
-      return tlsVersions(strings);
-    }
-
-    public Builder tlsVersions(String... tlsVersions) {
-      if (!tls) throw new IllegalStateException("no TLS versions for cleartext connections");
-
-      if (tlsVersions.length == 0) {
-        throw new IllegalArgumentException("At least one TLS version is required");
-      }
-
-      this.tlsVersions = tlsVersions.clone(); // Defensive copy.
-      return this;
-    }
-
-    public Builder supportsTlsExtensions(boolean supportsTlsExtensions) {
-      if (!tls) throw new IllegalStateException("no TLS extensions for cleartext connections");
-      this.supportsTlsExtensions = supportsTlsExtensions;
-      return this;
-    }
-
-    public ConnectionSpec build() {
-      return new ConnectionSpec(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.kt b/okhttp/src/main/java/okhttp3/ConnectionSpec.kt
new file mode 100644
index 0000000000..f6c0a197bd
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.kt
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.ConnectionSpec.Builder
+import okhttp3.internal.Util
+import okhttp3.internal.Util.concat
+import okhttp3.internal.Util.indexOf
+import okhttp3.internal.Util.intersect
+import okhttp3.internal.Util.nonEmptyIntersection
+import java.util.Arrays
+import java.util.Objects
+import javax.net.ssl.SSLSocket
+
+/**
+ * Specifies configuration for the socket connection that HTTP traffic travels through. For `https:`
+ * URLs, this includes the TLS version and cipher suites to use when negotiating a secure
+ * connection.
+ *
+ * The TLS versions configured in a connection spec are only be used if they are also enabled in the
+ * SSL socket. For example, if an SSL socket does not have TLS 1.3 enabled, it will not be used even
+ * if it is present on the connection spec. The same policy also applies to cipher suites.
+ *
+ * Use [Builder.allEnabledTlsVersions] and [Builder.allEnabledCipherSuites] to defer all feature
+ * selection to the underlying SSL socket.
+ *
+ * The configuration of each spec changes with each OkHttp release. This is annoying: upgrading
+ * your OkHttp library can break connectivity to certain web servers! But it‚Äôs a necessary annoyance
+ * because the TLS ecosystem is dynamic and staying up to date is necessary to stay secure. See
+ * [OkHttp's TLS Configuration History][tls_history] to track these changes.
+ *
+ * [tls_history]: https://github.com/square/okhttp/wiki/TLS-Configuration-History
+ */
+class ConnectionSpec internal constructor(builder: Builder) {
+  val isTls: Boolean = builder.tls
+  internal val supportsTlsExtensions: Boolean = builder.supportsTlsExtensions
+  internal val cipherSuites: Array<String>? = builder.cipherSuites
+  internal val tlsVersions: Array<String>? = builder.tlsVersions
+
+  /**
+   * Returns the cipher suites to use for a connection. Returns null if all of the SSL socket's
+   * enabled cipher suites should be used.
+   */
+  fun cipherSuites(): List<CipherSuite>? = cipherSuites?.map(CipherSuite.Companion::forJavaName)
+
+  /**
+   * Returns the TLS versions to use when negotiating a connection. Returns null if all of the SSL
+   * socket's enabled TLS versions should be used.
+   */
+  fun tlsVersions(): List<TlsVersion>? = tlsVersions?.map(TlsVersion.Companion::forJavaName)
+
+  fun supportsTlsExtensions(): Boolean = supportsTlsExtensions
+
+  /** Applies this spec to `sslSocket`.  */
+  internal fun apply(sslSocket: SSLSocket, isFallback: Boolean) {
+    val specToApply = supportedSpec(sslSocket, isFallback)
+
+    if (specToApply.tlsVersions != null) {
+      sslSocket.enabledProtocols = specToApply.tlsVersions
+    }
+
+    if (specToApply.cipherSuites != null) {
+      sslSocket.enabledCipherSuites = specToApply.cipherSuites
+    }
+  }
+
+  /**
+   * Returns a copy of this that omits cipher suites and TLS versions not enabled by `sslSocket`.
+   */
+  private fun supportedSpec(sslSocket: SSLSocket, isFallback: Boolean): ConnectionSpec {
+    var cipherSuitesIntersection = if (cipherSuites != null) {
+      intersect(CipherSuite.ORDER_BY_NAME, sslSocket.enabledCipherSuites, cipherSuites)
+    } else {
+      sslSocket.enabledCipherSuites
+    }
+
+    val tlsVersionsIntersection = if (tlsVersions != null) {
+      intersect(Util.NATURAL_ORDER, sslSocket.enabledProtocols, tlsVersions)
+    } else {
+      sslSocket.enabledProtocols
+    }
+
+    // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00 the SCSV
+    // cipher is added to signal that a protocol fallback has taken place.
+    val supportedCipherSuites = sslSocket.supportedCipherSuites
+    val indexOfFallbackScsv = indexOf(
+        CipherSuite.ORDER_BY_NAME, supportedCipherSuites, "TLS_FALLBACK_SCSV")
+    if (isFallback && indexOfFallbackScsv != -1) {
+      cipherSuitesIntersection = concat(
+          cipherSuitesIntersection, supportedCipherSuites[indexOfFallbackScsv])
+    }
+
+    return Builder(this)
+        .cipherSuites(*cipherSuitesIntersection)
+        .tlsVersions(*tlsVersionsIntersection)
+        .build()
+  }
+
+  /**
+   * Returns `true` if the socket, as currently configured, supports this connection spec. In
+   * order for a socket to be compatible the enabled cipher suites and protocols must intersect.
+   *
+   * For cipher suites, at least one of the [required cipher suites][cipherSuites] must match the
+   * socket's enabled cipher suites. If there are no required cipher suites the socket must have at
+   * least one cipher suite enabled.
+   *
+   * For protocols, at least one of the [required protocols][tlsVersions] must match the socket's
+   * enabled protocols.
+   */
+  fun isCompatible(socket: SSLSocket): Boolean {
+    if (!isTls) {
+      return false
+    }
+
+    if (tlsVersions != null
+        && !nonEmptyIntersection(Util.NATURAL_ORDER, tlsVersions, socket.enabledProtocols)) {
+      return false
+    }
+
+    if (cipherSuites != null
+        && !nonEmptyIntersection(
+            CipherSuite.ORDER_BY_NAME, cipherSuites, socket.enabledCipherSuites)) {
+      return false
+    }
+
+    return true
+  }
+
+  override fun equals(other: Any?): Boolean {
+    if (other !is ConnectionSpec) return false
+    if (other === this) return true
+
+    val that = other as ConnectionSpec?
+    if (this.isTls != that!!.isTls) return false
+
+    if (isTls) {
+      if (!Arrays.equals(this.cipherSuites, that.cipherSuites)) return false
+      if (!Arrays.equals(this.tlsVersions, that.tlsVersions)) return false
+      if (this.supportsTlsExtensions != that.supportsTlsExtensions) return false
+    }
+
+    return true
+  }
+
+  override fun hashCode(): Int {
+    var result = 17
+    if (isTls) {
+      result = 31 * result + cipherSuites!!.contentHashCode()
+      result = 31 * result + tlsVersions!!.contentHashCode()
+      result = 31 * result + if (supportsTlsExtensions) 0 else 1
+    }
+    return result
+  }
+
+  override fun toString(): String {
+    if (!isTls) return "ConnectionSpec()"
+
+    return ("ConnectionSpec(" +
+        "cipherSuites=${Objects.toString(cipherSuites(), "[all enabled]")}, " +
+        "tlsVersions=${Objects.toString(tlsVersions(), "[all enabled]")}, " +
+        "supportsTlsExtensions=$supportsTlsExtensions)")
+  }
+
+  class Builder {
+    internal var tls: Boolean = false
+    internal var cipherSuites: Array<String>? = null
+    internal var tlsVersions: Array<String>? = null
+    internal var supportsTlsExtensions: Boolean = false
+
+    internal constructor(tls: Boolean) {
+      this.tls = tls
+    }
+
+    constructor(connectionSpec: ConnectionSpec) {
+      this.tls = connectionSpec.isTls
+      this.cipherSuites = connectionSpec.cipherSuites
+      this.tlsVersions = connectionSpec.tlsVersions
+      this.supportsTlsExtensions = connectionSpec.supportsTlsExtensions
+    }
+
+    fun allEnabledCipherSuites() = apply {
+      require(tls) { "no cipher suites for cleartext connections" }
+      this.cipherSuites = null
+    }
+
+    fun cipherSuites(vararg cipherSuites: CipherSuite): Builder = apply {
+      require(tls) { "no cipher suites for cleartext connections" }
+      val strings = cipherSuites.map(CipherSuite::javaName).toTypedArray()
+      return cipherSuites(*strings)
+    }
+
+    fun cipherSuites(vararg cipherSuites: String) = apply {
+      require(tls) { "no cipher suites for cleartext connections" }
+      require(cipherSuites.isNotEmpty()) { "At least one cipher suite is required" }
+
+      this.cipherSuites = cipherSuites.clone() as Array<String> // Defensive copy.
+    }
+
+    fun allEnabledTlsVersions() = apply {
+      require(tls) { "no TLS versions for cleartext connections" }
+      this.tlsVersions = null
+    }
+
+    fun tlsVersions(vararg tlsVersions: TlsVersion): Builder = apply {
+      require(tls) { "no TLS versions for cleartext connections" }
+
+      val strings = tlsVersions.map(TlsVersion::javaName).toTypedArray()
+      return tlsVersions(*strings)
+    }
+
+    fun tlsVersions(vararg tlsVersions: String) = apply {
+      require(tls) { "no TLS versions for cleartext connections" }
+      require(tlsVersions.isNotEmpty()) { "At least one TLS version is required" }
+
+      this.tlsVersions = tlsVersions.clone() as Array<String> // Defensive copy.
+    }
+
+    @Deprecated("since OkHttp 3.13 all TLS-connections are expected to support TLS extensions.\n" +
+        "In a future release setting this to true will be unnecessary and setting it to false\n" +
+        "will have no effect.")
+    fun supportsTlsExtensions(supportsTlsExtensions: Boolean) = apply {
+      require(tls) { "no TLS extensions for cleartext connections" }
+      this.supportsTlsExtensions = supportsTlsExtensions
+    }
+
+    fun build(): ConnectionSpec = ConnectionSpec(this)
+  }
+
+  companion object {
+    // Most secure but generally supported list.
+    private val RESTRICTED_CIPHER_SUITES = arrayOf(
+        // TLSv1.3.
+        CipherSuite.TLS_AES_128_GCM_SHA256,
+        CipherSuite.TLS_AES_256_GCM_SHA384,
+        CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+
+        // TLSv1.0, TLSv1.1, TLSv1.2.
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+        CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256)
+
+    // This is nearly equal to the cipher suites supported in Chrome 72, current as of 2019-02-24.
+    // See https://tinyurl.com/okhttp-cipher-suites for availability.
+    private val APPROVED_CIPHER_SUITES = arrayOf(
+        // TLSv1.3.
+        CipherSuite.TLS_AES_128_GCM_SHA256,
+        CipherSuite.TLS_AES_256_GCM_SHA384,
+        CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+
+        // TLSv1.0, TLSv1.1, TLSv1.2.
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+        CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+        CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
+
+        // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
+        // continue to include them until better suites are commonly available.
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+        CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+        CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
+        CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,
+        CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,
+        CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,
+        CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA)
+
+    /** A secure TLS connection that requires a recent client platform and a recent server.  */
+    @JvmField
+    val RESTRICTED_TLS = Builder(true)
+        .cipherSuites(*RESTRICTED_CIPHER_SUITES)
+        .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(true)
+        .build()
+
+    /**
+     * A modern TLS configuration that works on most client platforms and can connect to most servers.
+     * This is OkHttp's default configuration.
+     */
+    @JvmField
+    val MODERN_TLS = Builder(true)
+        .cipherSuites(*APPROVED_CIPHER_SUITES)
+        .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)
+        .supportsTlsExtensions(true)
+        .build()
+
+    /**
+     * A backwards-compatible fallback configuration that works on obsolete client platforms and can
+     * connect to obsolete servers. When possible, prefer to upgrade your client platform or server
+     * rather than using this configuration.
+     */
+    @JvmField
+    val COMPATIBLE_TLS = Builder(true)
+        .cipherSuites(*APPROVED_CIPHER_SUITES)
+        .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
+        .supportsTlsExtensions(true)
+        .build()
+
+    /** Unencrypted, unauthenticated connections for `http:` URLs.  */
+    @JvmField
+    val CLEARTEXT = Builder(false).build()
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
deleted file mode 100644
index fbfa99c26d..0000000000
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ /dev/null
@@ -1,612 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.Collections;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.List;
-import java.util.Locale;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpDate;
-import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
-
-import static okhttp3.internal.Util.UTC;
-import static okhttp3.internal.Util.canonicalizeHost;
-import static okhttp3.internal.Util.delimiterOffset;
-import static okhttp3.internal.Util.indexOfControlOrNonAscii;
-import static okhttp3.internal.Util.trimSubstring;
-import static okhttp3.internal.Util.verifyAsIpAddress;
-
-/**
- * An <a href="http://tools.ietf.org/html/rfc6265">RFC 6265</a> Cookie.
- *
- * <p>This class doesn't support additional attributes on cookies, like <a
- * href="https://code.google.com/p/chromium/issues/detail?id=232693">Chromium's Priority=HIGH
- * extension</a>.
- */
-public final class Cookie {
-  private static final Pattern YEAR_PATTERN
-      = Pattern.compile("(\\d{2,4})[^\\d]*");
-  private static final Pattern MONTH_PATTERN
-      = Pattern.compile("(?i)(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec).*");
-  private static final Pattern DAY_OF_MONTH_PATTERN
-      = Pattern.compile("(\\d{1,2})[^\\d]*");
-  private static final Pattern TIME_PATTERN
-      = Pattern.compile("(\\d{1,2}):(\\d{1,2}):(\\d{1,2})[^\\d]*");
-
-  private final String name;
-  private final String value;
-  private final long expiresAt;
-  private final String domain;
-  private final String path;
-  private final boolean secure;
-  private final boolean httpOnly;
-
-  private final boolean persistent; // True if 'expires' or 'max-age' is present.
-  private final boolean hostOnly; // True unless 'domain' is present.
-
-  private Cookie(String name, String value, long expiresAt, String domain, String path,
-      boolean secure, boolean httpOnly, boolean hostOnly, boolean persistent) {
-    this.name = name;
-    this.value = value;
-    this.expiresAt = expiresAt;
-    this.domain = domain;
-    this.path = path;
-    this.secure = secure;
-    this.httpOnly = httpOnly;
-    this.hostOnly = hostOnly;
-    this.persistent = persistent;
-  }
-
-  Cookie(Builder builder) {
-    if (builder.name == null) throw new NullPointerException("builder.name == null");
-    if (builder.value == null) throw new NullPointerException("builder.value == null");
-    if (builder.domain == null) throw new NullPointerException("builder.domain == null");
-
-    this.name = builder.name;
-    this.value = builder.value;
-    this.expiresAt = builder.expiresAt;
-    this.domain = builder.domain;
-    this.path = builder.path;
-    this.secure = builder.secure;
-    this.httpOnly = builder.httpOnly;
-    this.persistent = builder.persistent;
-    this.hostOnly = builder.hostOnly;
-  }
-
-  /** Returns a non-empty string with this cookie's name. */
-  public String name() {
-    return name;
-  }
-
-  /** Returns a possibly-empty string with this cookie's value. */
-  public String value() {
-    return value;
-  }
-
-  /** Returns true if this cookie does not expire at the end of the current session. */
-  public boolean persistent() {
-    return persistent;
-  }
-
-  /**
-   * Returns the time that this cookie expires, in the same format as {@link
-   * System#currentTimeMillis()}. This is December 31, 9999 if the cookie is {@linkplain
-   * #persistent() not persistent}, in which case it will expire at the end of the current session.
-   *
-   * <p>This may return a value less than the current time, in which case the cookie is already
-   * expired. Webservers may return expired cookies as a mechanism to delete previously set cookies
-   * that may or may not themselves be expired.
-   */
-  public long expiresAt() {
-    return expiresAt;
-  }
-
-  /**
-   * Returns true if this cookie's domain should be interpreted as a single host name, or false if
-   * it should be interpreted as a pattern. This flag will be false if its {@code Set-Cookie} header
-   * included a {@code domain} attribute.
-   *
-   * <p>For example, suppose the cookie's domain is {@code example.com}. If this flag is true it
-   * matches <strong>only</strong> {@code example.com}. If this flag is false it matches {@code
-   * example.com} and all subdomains including {@code api.example.com}, {@code www.example.com}, and
-   * {@code beta.api.example.com}.
-   */
-  public boolean hostOnly() {
-    return hostOnly;
-  }
-
-  /**
-   * Returns the cookie's domain. If {@link #hostOnly()} returns true this is the only domain that
-   * matches this cookie; otherwise it matches this domain and all subdomains.
-   */
-  public String domain() {
-    return domain;
-  }
-
-  /**
-   * Returns this cookie's path. This cookie matches URLs prefixed with path segments that match
-   * this path's segments. For example, if this path is {@code /foo} this cookie matches requests to
-   * {@code /foo} and {@code /foo/bar}, but not {@code /} or {@code /football}.
-   */
-  public String path() {
-    return path;
-  }
-
-  /**
-   * Returns true if this cookie should be limited to only HTTP APIs. In web browsers this prevents
-   * the cookie from being accessible to scripts.
-   */
-  public boolean httpOnly() {
-    return httpOnly;
-  }
-
-  /** Returns true if this cookie should be limited to only HTTPS requests. */
-  public boolean secure() {
-    return secure;
-  }
-
-  /**
-   * Returns true if this cookie should be included on a request to {@code url}. In addition to this
-   * check callers should also confirm that this cookie has not expired.
-   */
-  public boolean matches(HttpUrl url) {
-    boolean domainMatch = hostOnly
-        ? url.host().equals(domain)
-        : domainMatch(url.host(), domain);
-    if (!domainMatch) return false;
-
-    if (!pathMatch(url, path)) return false;
-
-    if (secure && !url.isHttps()) return false;
-
-    return true;
-  }
-
-  private static boolean domainMatch(String urlHost, String domain) {
-    if (urlHost.equals(domain)) {
-      return true; // As in 'example.com' matching 'example.com'.
-    }
-
-    if (urlHost.endsWith(domain)
-        && urlHost.charAt(urlHost.length() - domain.length() - 1) == '.'
-        && !verifyAsIpAddress(urlHost)) {
-      return true; // As in 'example.com' matching 'www.example.com'.
-    }
-
-    return false;
-  }
-
-  private static boolean pathMatch(HttpUrl url, String path) {
-    String urlPath = url.encodedPath();
-
-    if (urlPath.equals(path)) {
-      return true; // As in '/foo' matching '/foo'.
-    }
-
-    if (urlPath.startsWith(path)) {
-      if (path.endsWith("/")) return true; // As in '/' matching '/foo'.
-      if (urlPath.charAt(path.length()) == '/') return true; // As in '/foo' matching '/foo/bar'.
-    }
-
-    return false;
-  }
-
-  /**
-   * Attempt to parse a {@code Set-Cookie} HTTP header value {@code setCookie} as a cookie. Returns
-   * null if {@code setCookie} is not a well-formed cookie.
-   */
-  public static @Nullable Cookie parse(HttpUrl url, String setCookie) {
-    return parse(System.currentTimeMillis(), url, setCookie);
-  }
-
-  static @Nullable Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
-    int pos = 0;
-    int limit = setCookie.length();
-    int cookiePairEnd = delimiterOffset(setCookie, pos, limit, ';');
-
-    int pairEqualsSign = delimiterOffset(setCookie, pos, cookiePairEnd, '=');
-    if (pairEqualsSign == cookiePairEnd) return null;
-
-    String cookieName = trimSubstring(setCookie, pos, pairEqualsSign);
-    if (cookieName.isEmpty() || indexOfControlOrNonAscii(cookieName) != -1) return null;
-
-    String cookieValue = trimSubstring(setCookie, pairEqualsSign + 1, cookiePairEnd);
-    if (indexOfControlOrNonAscii(cookieValue) != -1) return null;
-
-    long expiresAt = HttpDate.MAX_DATE;
-    long deltaSeconds = -1L;
-    String domain = null;
-    String path = null;
-    boolean secureOnly = false;
-    boolean httpOnly = false;
-    boolean hostOnly = true;
-    boolean persistent = false;
-
-    pos = cookiePairEnd + 1;
-    while (pos < limit) {
-      int attributePairEnd = delimiterOffset(setCookie, pos, limit, ';');
-
-      int attributeEqualsSign = delimiterOffset(setCookie, pos, attributePairEnd, '=');
-      String attributeName = trimSubstring(setCookie, pos, attributeEqualsSign);
-      String attributeValue = attributeEqualsSign < attributePairEnd
-          ? trimSubstring(setCookie, attributeEqualsSign + 1, attributePairEnd)
-          : "";
-
-      if (attributeName.equalsIgnoreCase("expires")) {
-        try {
-          expiresAt = parseExpires(attributeValue, 0, attributeValue.length());
-          persistent = true;
-        } catch (IllegalArgumentException e) {
-          // Ignore this attribute, it isn't recognizable as a date.
-        }
-      } else if (attributeName.equalsIgnoreCase("max-age")) {
-        try {
-          deltaSeconds = parseMaxAge(attributeValue);
-          persistent = true;
-        } catch (NumberFormatException e) {
-          // Ignore this attribute, it isn't recognizable as a max age.
-        }
-      } else if (attributeName.equalsIgnoreCase("domain")) {
-        try {
-          domain = parseDomain(attributeValue);
-          hostOnly = false;
-        } catch (IllegalArgumentException e) {
-          // Ignore this attribute, it isn't recognizable as a domain.
-        }
-      } else if (attributeName.equalsIgnoreCase("path")) {
-        path = attributeValue;
-      } else if (attributeName.equalsIgnoreCase("secure")) {
-        secureOnly = true;
-      } else if (attributeName.equalsIgnoreCase("httponly")) {
-        httpOnly = true;
-      }
-
-      pos = attributePairEnd + 1;
-    }
-
-    // If 'Max-Age' is present, it takes precedence over 'Expires', regardless of the order the two
-    // attributes are declared in the cookie string.
-    if (deltaSeconds == Long.MIN_VALUE) {
-      expiresAt = Long.MIN_VALUE;
-    } else if (deltaSeconds != -1L) {
-      long deltaMilliseconds = deltaSeconds <= (Long.MAX_VALUE / 1000)
-          ? deltaSeconds * 1000
-          : Long.MAX_VALUE;
-      expiresAt = currentTimeMillis + deltaMilliseconds;
-      if (expiresAt < currentTimeMillis || expiresAt > HttpDate.MAX_DATE) {
-        expiresAt = HttpDate.MAX_DATE; // Handle overflow & limit the date range.
-      }
-    }
-
-    // If the domain is present, it must domain match. Otherwise we have a host-only cookie.
-    String urlHost = url.host();
-    if (domain == null) {
-      domain = urlHost;
-    } else if (!domainMatch(urlHost, domain)) {
-      return null; // No domain match? This is either incompetence or malice!
-    }
-
-    // If the domain is a suffix of the url host, it must not be a public suffix.
-    if (urlHost.length() != domain.length()
-        && PublicSuffixDatabase.get().getEffectiveTldPlusOne(domain) == null) {
-      return null;
-    }
-
-    // If the path is absent or didn't start with '/', use the default path. It's a string like
-    // '/foo/bar' for a URL like 'http://example.com/foo/bar/baz'. It always starts with '/'.
-    if (path == null || !path.startsWith("/")) {
-      String encodedPath = url.encodedPath();
-      int lastSlash = encodedPath.lastIndexOf('/');
-      path = lastSlash != 0 ? encodedPath.substring(0, lastSlash) : "/";
-    }
-
-    return new Cookie(cookieName, cookieValue, expiresAt, domain, path, secureOnly, httpOnly,
-        hostOnly, persistent);
-  }
-
-  /** Parse a date as specified in RFC 6265, section 5.1.1. */
-  private static long parseExpires(String s, int pos, int limit) {
-    pos = dateCharacterOffset(s, pos, limit, false);
-
-    int hour = -1;
-    int minute = -1;
-    int second = -1;
-    int dayOfMonth = -1;
-    int month = -1;
-    int year = -1;
-    Matcher matcher = TIME_PATTERN.matcher(s);
-
-    while (pos < limit) {
-      int end = dateCharacterOffset(s, pos + 1, limit, true);
-      matcher.region(pos, end);
-
-      if (hour == -1 && matcher.usePattern(TIME_PATTERN).matches()) {
-        hour = Integer.parseInt(matcher.group(1));
-        minute = Integer.parseInt(matcher.group(2));
-        second = Integer.parseInt(matcher.group(3));
-      } else if (dayOfMonth == -1 && matcher.usePattern(DAY_OF_MONTH_PATTERN).matches()) {
-        dayOfMonth = Integer.parseInt(matcher.group(1));
-      } else if (month == -1 && matcher.usePattern(MONTH_PATTERN).matches()) {
-        String monthString = matcher.group(1).toLowerCase(Locale.US);
-        month = MONTH_PATTERN.pattern().indexOf(monthString) / 4; // Sneaky! jan=1, dec=12.
-      } else if (year == -1 && matcher.usePattern(YEAR_PATTERN).matches()) {
-        year = Integer.parseInt(matcher.group(1));
-      }
-
-      pos = dateCharacterOffset(s, end + 1, limit, false);
-    }
-
-    // Convert two-digit years into four-digit years. 99 becomes 1999, 15 becomes 2015.
-    if (year >= 70 && year <= 99) year += 1900;
-    if (year >= 0 && year <= 69) year += 2000;
-
-    // If any partial is omitted or out of range, return -1. The date is impossible. Note that leap
-    // seconds are not supported by this syntax.
-    if (year < 1601) throw new IllegalArgumentException();
-    if (month == -1) throw new IllegalArgumentException();
-    if (dayOfMonth < 1 || dayOfMonth > 31) throw new IllegalArgumentException();
-    if (hour < 0 || hour > 23) throw new IllegalArgumentException();
-    if (minute < 0 || minute > 59) throw new IllegalArgumentException();
-    if (second < 0 || second > 59) throw new IllegalArgumentException();
-
-    Calendar calendar = new GregorianCalendar(UTC);
-    calendar.setLenient(false);
-    calendar.set(Calendar.YEAR, year);
-    calendar.set(Calendar.MONTH, month - 1);
-    calendar.set(Calendar.DAY_OF_MONTH, dayOfMonth);
-    calendar.set(Calendar.HOUR_OF_DAY, hour);
-    calendar.set(Calendar.MINUTE, minute);
-    calendar.set(Calendar.SECOND, second);
-    calendar.set(Calendar.MILLISECOND, 0);
-    return calendar.getTimeInMillis();
-  }
-
-  /**
-   * Returns the index of the next date character in {@code input}, or if {@code invert} the index
-   * of the next non-date character in {@code input}.
-   */
-  private static int dateCharacterOffset(String input, int pos, int limit, boolean invert) {
-    for (int i = pos; i < limit; i++) {
-      int c = input.charAt(i);
-      boolean dateCharacter = (c < ' ' && c != '\t') || (c >= '\u007f')
-          || (c >= '0' && c <= '9')
-          || (c >= 'a' && c <= 'z')
-          || (c >= 'A' && c <= 'Z')
-          || (c == ':');
-      if (dateCharacter == !invert) return i;
-    }
-    return limit;
-  }
-
-  /**
-   * Returns the positive value if {@code attributeValue} is positive, or {@link Long#MIN_VALUE} if
-   * it is either 0 or negative. If the value is positive but out of range, this returns {@link
-   * Long#MAX_VALUE}.
-   *
-   * @throws NumberFormatException if {@code s} is not an integer of any precision.
-   */
-  private static long parseMaxAge(String s) {
-    try {
-      long parsed = Long.parseLong(s);
-      return parsed <= 0L ? Long.MIN_VALUE : parsed;
-    } catch (NumberFormatException e) {
-      // Check if the value is an integer (positive or negative) that's too big for a long.
-      if (s.matches("-?\\d+")) {
-        return s.startsWith("-") ? Long.MIN_VALUE : Long.MAX_VALUE;
-      }
-      throw e;
-    }
-  }
-
-  /**
-   * Returns a domain string like {@code example.com} for an input domain like {@code EXAMPLE.COM}
-   * or {@code .example.com}.
-   */
-  private static String parseDomain(String s) {
-    if (s.endsWith(".")) {
-      throw new IllegalArgumentException();
-    }
-    if (s.startsWith(".")) {
-      s = s.substring(1);
-    }
-    String canonicalDomain = canonicalizeHost(s);
-    if (canonicalDomain == null) {
-      throw new IllegalArgumentException();
-    }
-    return canonicalDomain;
-  }
-
-  /** Returns all of the cookies from a set of HTTP response headers. */
-  public static List<Cookie> parseAll(HttpUrl url, Headers headers) {
-    List<String> cookieStrings = headers.values("Set-Cookie");
-    List<Cookie> cookies = null;
-
-    for (int i = 0, size = cookieStrings.size(); i < size; i++) {
-      Cookie cookie = Cookie.parse(url, cookieStrings.get(i));
-      if (cookie == null) continue;
-      if (cookies == null) cookies = new ArrayList<>();
-      cookies.add(cookie);
-    }
-
-    return cookies != null
-        ? Collections.unmodifiableList(cookies)
-        : Collections.<Cookie>emptyList();
-  }
-
-  /**
-   * Builds a cookie. The {@linkplain #name() name}, {@linkplain #value() value}, and {@linkplain
-   * #domain() domain} values must all be set before calling {@link #build}.
-   */
-  public static final class Builder {
-    String name;
-    String value;
-    long expiresAt = HttpDate.MAX_DATE;
-    String domain;
-    String path = "/";
-    boolean secure;
-    boolean httpOnly;
-    boolean persistent;
-    boolean hostOnly;
-
-    public Builder name(String name) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (!name.trim().equals(name)) throw new IllegalArgumentException("name is not trimmed");
-      this.name = name;
-      return this;
-    }
-
-    public Builder value(String value) {
-      if (value == null) throw new NullPointerException("value == null");
-      if (!value.trim().equals(value)) throw new IllegalArgumentException("value is not trimmed");
-      this.value = value;
-      return this;
-    }
-
-    public Builder expiresAt(long expiresAt) {
-      if (expiresAt <= 0) expiresAt = Long.MIN_VALUE;
-      if (expiresAt > HttpDate.MAX_DATE) expiresAt = HttpDate.MAX_DATE;
-      this.expiresAt = expiresAt;
-      this.persistent = true;
-      return this;
-    }
-
-    /**
-     * Set the domain pattern for this cookie. The cookie will match {@code domain} and all of its
-     * subdomains.
-     */
-    public Builder domain(String domain) {
-      return domain(domain, false);
-    }
-
-    /**
-     * Set the host-only domain for this cookie. The cookie will match {@code domain} but none of
-     * its subdomains.
-     */
-    public Builder hostOnlyDomain(String domain) {
-      return domain(domain, true);
-    }
-
-    private Builder domain(String domain, boolean hostOnly) {
-      if (domain == null) throw new NullPointerException("domain == null");
-      String canonicalDomain = Util.canonicalizeHost(domain);
-      if (canonicalDomain == null) {
-        throw new IllegalArgumentException("unexpected domain: " + domain);
-      }
-      this.domain = canonicalDomain;
-      this.hostOnly = hostOnly;
-      return this;
-    }
-
-    public Builder path(String path) {
-      if (!path.startsWith("/")) throw new IllegalArgumentException("path must start with '/'");
-      this.path = path;
-      return this;
-    }
-
-    public Builder secure() {
-      this.secure = true;
-      return this;
-    }
-
-    public Builder httpOnly() {
-      this.httpOnly = true;
-      return this;
-    }
-
-    public Cookie build() {
-      return new Cookie(this);
-    }
-  }
-
-  @Override public String toString() {
-    return toString(false);
-  }
-
-  /**
-   * @param forObsoleteRfc2965 true to include a leading {@code .} on the domain pattern. This is
-   *     necessary for {@code example.com} to match {@code www.example.com} under RFC 2965. This
-   *     extra dot is ignored by more recent specifications.
-   */
-  String toString(boolean forObsoleteRfc2965) {
-    StringBuilder result = new StringBuilder();
-    result.append(name);
-    result.append('=');
-    result.append(value);
-
-    if (persistent) {
-      if (expiresAt == Long.MIN_VALUE) {
-        result.append("; max-age=0");
-      } else {
-        result.append("; expires=").append(HttpDate.format(new Date(expiresAt)));
-      }
-    }
-
-    if (!hostOnly) {
-      result.append("; domain=");
-      if (forObsoleteRfc2965) {
-        result.append(".");
-      }
-      result.append(domain);
-    }
-
-    result.append("; path=").append(path);
-
-    if (secure) {
-      result.append("; secure");
-    }
-
-    if (httpOnly) {
-      result.append("; httponly");
-    }
-
-    return result.toString();
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    if (!(other instanceof Cookie)) return false;
-    Cookie that = (Cookie) other;
-    return that.name.equals(name)
-        && that.value.equals(value)
-        && that.domain.equals(domain)
-        && that.path.equals(path)
-        && that.expiresAt == expiresAt
-        && that.secure == secure
-        && that.httpOnly == httpOnly
-        && that.persistent == persistent
-        && that.hostOnly == hostOnly;
-  }
-
-  @Override public int hashCode() {
-    int hash = 17;
-    hash = 31 * hash + name.hashCode();
-    hash = 31 * hash + value.hashCode();
-    hash = 31 * hash + domain.hashCode();
-    hash = 31 * hash + path.hashCode();
-    hash = 31 * hash + (int) (expiresAt ^ (expiresAt >>> 32));
-    hash = 31 * hash + (secure ? 0 : 1);
-    hash = 31 * hash + (httpOnly ? 0 : 1);
-    hash = 31 * hash + (persistent ? 0 : 1);
-    hash = 31 * hash + (hostOnly ? 0 : 1);
-    return hash;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Cookie.kt b/okhttp/src/main/java/okhttp3/Cookie.kt
new file mode 100644
index 0000000000..1ff6d8b456
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Cookie.kt
@@ -0,0 +1,530 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.Util
+import okhttp3.internal.Util.UTC
+import okhttp3.internal.Util.canonicalizeHost
+import okhttp3.internal.Util.delimiterOffset
+import okhttp3.internal.Util.indexOfControlOrNonAscii
+import okhttp3.internal.Util.trimSubstring
+import okhttp3.internal.Util.verifyAsIpAddress
+import okhttp3.internal.http.HttpDate
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase
+import java.util.Calendar
+import java.util.Collections
+import java.util.Date
+import java.util.GregorianCalendar
+import java.util.Locale
+import java.util.regex.Pattern
+
+/**
+ * An [RFC 6265](http://tools.ietf.org/html/rfc6265) Cookie.
+ *
+ * This class doesn't support additional attributes on cookies, like
+ * [Chromium's Priority=HIGH extension][chromium_extension].
+ *
+ * [chromium_extension]: https://code.google.com/p/chromium/issues/detail?id=232693
+ */
+data class Cookie private constructor(
+  private val name: String,
+  private val value: String,
+  private val expiresAt: Long,
+  private val domain: String,
+  private val path: String,
+  private val secure: Boolean,
+  private val httpOnly: Boolean,
+  private val persistent: Boolean, // True if 'expires' or 'max-age' is present.
+  private val hostOnly: Boolean // True unless 'domain' is present.
+) {
+  /** Returns a non-empty string with this cookie's name.  */
+  fun name(): String = name
+
+  /** Returns a possibly-empty string with this cookie's value.  */
+  fun value(): String = value
+
+  /** Returns true if this cookie does not expire at the end of the current session.  */
+  fun persistent(): Boolean = persistent
+
+  /**
+   * Returns the time that this cookie expires, in the same format as [System.currentTimeMillis].
+   * This is December 31, 9999 if the cookie is [persistent], in which case it will expire at the
+   * end of the current session.
+   *
+   * This may return a value less than the current time, in which case the cookie is already
+   * expired. Webservers may return expired cookies as a mechanism to delete previously set cookies
+   * that may or may not themselves be expired.
+   */
+  fun expiresAt(): Long = expiresAt
+
+  /**
+   * Returns true if this cookie's domain should be interpreted as a single host name, or false if
+   * it should be interpreted as a pattern. This flag will be false if its `Set-Cookie` header
+   * included a `domain` attribute.
+   *
+   * For example, suppose the cookie's domain is `example.com`. If this flag is true it matches
+   * **only** `example.com`. If this flag is false it matches `example.com` and all subdomains
+   * including `api.example.com`, `www.example.com`, and `beta.api.example.com`.
+   */
+  fun hostOnly(): Boolean = hostOnly
+
+  /**
+   * Returns the cookie's domain. If [hostOnly] returns true this is the only domain that matches
+   * this cookie; otherwise it matches this domain and all subdomains.
+   */
+  fun domain(): String = domain
+
+  /**
+   * Returns this cookie's path. This cookie matches URLs prefixed with path segments that match
+   * this path's segments. For example, if this path is `/foo` this cookie matches requests to
+   * `/foo` and `/foo/bar`, but not `/` or `/football`.
+   */
+  fun path(): String = path
+
+  /**
+   * Returns true if this cookie should be limited to only HTTP APIs. In web browsers this prevents
+   * the cookie from being accessible to scripts.
+   */
+  fun httpOnly(): Boolean = httpOnly
+
+  /** Returns true if this cookie should be limited to only HTTPS requests.  */
+  fun secure(): Boolean = secure
+
+  /**
+   * Returns true if this cookie should be included on a request to `url`. In addition to this
+   * check callers should also confirm that this cookie has not expired.
+   */
+  fun matches(url: HttpUrl): Boolean {
+    val domainMatch = if (hostOnly) {
+      url.host() == domain
+    } else {
+      domainMatch(url.host(), domain)
+    }
+    if (!domainMatch) return false
+
+    if (!pathMatch(url, path)) return false
+
+    return !secure || url.isHttps
+  }
+
+  /**
+   * Builds a cookie. The [name], [value], and [domain] values must all be set before calling
+   * [build].
+   */
+  class Builder {
+    private var name: String? = null
+    private var value: String? = null
+    private var expiresAt = HttpDate.MAX_DATE
+    private var domain: String? = null
+    private var path = "/"
+    private var secure: Boolean = false
+    private var httpOnly: Boolean = false
+    private var persistent: Boolean = false
+    private var hostOnly: Boolean = false
+
+    fun name(name: String) = apply {
+      require(name.trim { it <= ' ' } == name) { "name is not trimmed" }
+      this.name = name
+    }
+
+    fun value(value: String) = apply {
+      require(value.trim { it <= ' ' } == value) { "value is not trimmed" }
+      this.value = value
+    }
+
+    fun expiresAt(expiresAt: Long) = apply {
+      var expiresAt = expiresAt
+      if (expiresAt <= 0) expiresAt = Long.MIN_VALUE
+      if (expiresAt > HttpDate.MAX_DATE) expiresAt = HttpDate.MAX_DATE
+      this.expiresAt = expiresAt
+      this.persistent = true
+    }
+
+    /**
+     * Set the domain pattern for this cookie. The cookie will match `domain` and all of its
+     * subdomains.
+     */
+    fun domain(domain: String): Builder = domain(domain, false)
+
+    /**
+     * Set the host-only domain for this cookie. The cookie will match `domain` but none of
+     * its subdomains.
+     */
+    fun hostOnlyDomain(domain: String): Builder = domain(domain, true)
+
+    private fun domain(domain: String, hostOnly: Boolean) = apply {
+      val canonicalDomain = Util.canonicalizeHost(domain)
+          ?: throw IllegalArgumentException("unexpected domain: $domain")
+      this.domain = canonicalDomain
+      this.hostOnly = hostOnly
+    }
+
+    fun path(path: String) = apply {
+      require(path.startsWith("/")) { "path must start with '/'" }
+      this.path = path
+    }
+
+    fun secure() = apply {
+      this.secure = true
+    }
+
+    fun httpOnly() = apply {
+      this.httpOnly = true
+    }
+
+    fun build(): Cookie {
+      return Cookie(
+          name ?: throw NullPointerException("builder.name == null"),
+          value ?: throw NullPointerException("builder.value == null"),
+          expiresAt,
+          domain ?: throw NullPointerException("builder.domain == null"),
+          path,
+          secure,
+          httpOnly,
+          persistent,
+          hostOnly)
+    }
+  }
+
+  override fun toString(): String = toString(false)
+
+  /**
+   * @param forObsoleteRfc2965 true to include a leading `.` on the domain pattern. This is
+   *     necessary for `example.com` to match `www.example.com` under RFC 2965. This extra dot is
+   *     ignored by more recent specifications.
+   */
+  internal fun toString(forObsoleteRfc2965: Boolean): String {
+    return buildString {
+      append(name)
+      append('=')
+      append(value)
+
+      if (persistent) {
+        if (expiresAt == Long.MIN_VALUE) {
+          append("; max-age=0")
+        } else {
+          append("; expires=").append(HttpDate.format(Date(expiresAt)))
+        }
+      }
+
+      if (!hostOnly) {
+        append("; domain=")
+        if (forObsoleteRfc2965) {
+          append(".")
+        }
+        append(domain)
+      }
+
+      append("; path=").append(path)
+
+      if (secure) {
+        append("; secure")
+      }
+
+      if (httpOnly) {
+        append("; httponly")
+      }
+
+      return toString()
+    }
+  }
+
+  companion object {
+    private val YEAR_PATTERN = Pattern.compile("(\\d{2,4})[^\\d]*")
+    private val MONTH_PATTERN =
+        Pattern.compile("(?i)(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec).*")
+    private val DAY_OF_MONTH_PATTERN = Pattern.compile("(\\d{1,2})[^\\d]*")
+    private val TIME_PATTERN = Pattern.compile("(\\d{1,2}):(\\d{1,2}):(\\d{1,2})[^\\d]*")
+
+    private fun domainMatch(urlHost: String, domain: String): Boolean {
+      if (urlHost == domain) {
+        return true // As in 'example.com' matching 'example.com'.
+      }
+
+      return urlHost.endsWith(domain)
+          && urlHost[urlHost.length - domain.length - 1] == '.'
+          && !verifyAsIpAddress(urlHost)
+    }
+
+    private fun pathMatch(url: HttpUrl, path: String): Boolean {
+      val urlPath = url.encodedPath()
+
+      if (urlPath == path) {
+        return true // As in '/foo' matching '/foo'.
+      }
+
+      if (urlPath.startsWith(path)) {
+        if (path.endsWith("/")) return true // As in '/' matching '/foo'.
+        if (urlPath[path.length] == '/') return true // As in '/foo' matching '/foo/bar'.
+      }
+
+      return false
+    }
+
+    /**
+     * Attempt to parse a `Set-Cookie` HTTP header value `setCookie` as a cookie. Returns null if
+     * `setCookie` is not a well-formed cookie.
+     */
+    @JvmStatic
+    fun parse(url: HttpUrl, setCookie: String): Cookie? =
+        parse(System.currentTimeMillis(), url, setCookie)
+
+    internal fun parse(currentTimeMillis: Long, url: HttpUrl, setCookie: String): Cookie? {
+      var pos = 0
+      val limit = setCookie.length
+      val cookiePairEnd = delimiterOffset(setCookie, pos, limit, ';')
+
+      val pairEqualsSign = delimiterOffset(setCookie, pos, cookiePairEnd, '=')
+      if (pairEqualsSign == cookiePairEnd) return null
+
+      val cookieName = trimSubstring(setCookie, pos, pairEqualsSign)
+      if (cookieName.isEmpty() || indexOfControlOrNonAscii(cookieName) != -1) return null
+
+      val cookieValue = trimSubstring(setCookie, pairEqualsSign + 1, cookiePairEnd)
+      if (indexOfControlOrNonAscii(cookieValue) != -1) return null
+
+      var expiresAt = HttpDate.MAX_DATE
+      var deltaSeconds = -1L
+      var domain: String? = null
+      var path: String? = null
+      var secureOnly = false
+      var httpOnly = false
+      var hostOnly = true
+      var persistent = false
+
+      pos = cookiePairEnd + 1
+      while (pos < limit) {
+        val attributePairEnd = delimiterOffset(setCookie, pos, limit, ';')
+
+        val attributeEqualsSign = delimiterOffset(setCookie, pos, attributePairEnd, '=')
+        val attributeName = trimSubstring(setCookie, pos, attributeEqualsSign)
+        val attributeValue = if (attributeEqualsSign < attributePairEnd) {
+          trimSubstring(setCookie, attributeEqualsSign + 1, attributePairEnd)
+        } else {
+          ""
+        }
+
+        when {
+          attributeName.equals("expires", ignoreCase = true) -> {
+            try {
+              expiresAt = parseExpires(attributeValue, 0, attributeValue.length)
+              persistent = true
+            } catch (e: IllegalArgumentException) {
+              // Ignore this attribute, it isn't recognizable as a date.
+            }
+          }
+          attributeName.equals("max-age", ignoreCase = true) -> {
+            try {
+              deltaSeconds = parseMaxAge(attributeValue)
+              persistent = true
+            } catch (e: NumberFormatException) {
+              // Ignore this attribute, it isn't recognizable as a max age.
+            }
+          }
+          attributeName.equals("domain", ignoreCase = true) -> {
+            try {
+              domain = parseDomain(attributeValue)
+              hostOnly = false
+            } catch (e: IllegalArgumentException) {
+              // Ignore this attribute, it isn't recognizable as a domain.
+            }
+          }
+          attributeName.equals("path", ignoreCase = true) -> {
+            path = attributeValue
+          }
+          attributeName.equals("secure", ignoreCase = true) -> {
+            secureOnly = true
+          }
+          attributeName.equals("httponly", ignoreCase = true) -> {
+            httpOnly = true
+          }
+        }
+
+        pos = attributePairEnd + 1
+      }
+
+      // If 'Max-Age' is present, it takes precedence over 'Expires', regardless of the order the two
+      // attributes are declared in the cookie string.
+      if (deltaSeconds == Long.MIN_VALUE) {
+        expiresAt = Long.MIN_VALUE
+      } else if (deltaSeconds != -1L) {
+        val deltaMilliseconds = if (deltaSeconds <= Long.MAX_VALUE / 1000) {
+          deltaSeconds * 1000
+        } else {
+          Long.MAX_VALUE
+        }
+        expiresAt = currentTimeMillis + deltaMilliseconds
+        if (expiresAt < currentTimeMillis || expiresAt > HttpDate.MAX_DATE) {
+          expiresAt = HttpDate.MAX_DATE // Handle overflow & limit the date range.
+        }
+      }
+
+      // If the domain is present, it must domain match. Otherwise we have a host-only cookie.
+      val urlHost = url.host()
+      if (domain == null) {
+        domain = urlHost
+      } else if (!domainMatch(urlHost, domain)) {
+        return null // No domain match? This is either incompetence or malice!
+      }
+
+      // If the domain is a suffix of the url host, it must not be a public suffix.
+      if (urlHost.length != domain.length
+          && PublicSuffixDatabase.get().getEffectiveTldPlusOne(domain) == null) {
+        return null
+      }
+
+      // If the path is absent or didn't start with '/', use the default path. It's a string like
+      // '/foo/bar' for a URL like 'http://example.com/foo/bar/baz'. It always starts with '/'.
+      if (path == null || !path.startsWith("/")) {
+        val encodedPath = url.encodedPath()
+        val lastSlash = encodedPath.lastIndexOf('/')
+        path = if (lastSlash != 0) encodedPath.substring(0, lastSlash) else "/"
+      }
+
+      return Cookie(cookieName, cookieValue, expiresAt, domain, path, secureOnly, httpOnly,
+          persistent, hostOnly)
+    }
+
+    /** Parse a date as specified in RFC 6265, section 5.1.1.  */
+    private fun parseExpires(s: String, pos: Int, limit: Int): Long {
+      var pos = pos
+      pos = dateCharacterOffset(s, pos, limit, false)
+
+      var hour = -1
+      var minute = -1
+      var second = -1
+      var dayOfMonth = -1
+      var month = -1
+      var year = -1
+      val matcher = TIME_PATTERN.matcher(s)
+
+      while (pos < limit) {
+        val end = dateCharacterOffset(s, pos + 1, limit, true)
+        matcher.region(pos, end)
+
+        when {
+          hour == -1 && matcher.usePattern(TIME_PATTERN).matches() -> {
+            hour = Integer.parseInt(matcher.group(1))
+            minute = Integer.parseInt(matcher.group(2))
+            second = Integer.parseInt(matcher.group(3))
+          }
+          dayOfMonth == -1 && matcher.usePattern(DAY_OF_MONTH_PATTERN).matches() -> {
+            dayOfMonth = Integer.parseInt(matcher.group(1))
+          }
+          month == -1 && matcher.usePattern(MONTH_PATTERN).matches() -> {
+            val monthString = matcher.group(1).toLowerCase(Locale.US)
+            month = MONTH_PATTERN.pattern().indexOf(monthString) / 4 // Sneaky! jan=1, dec=12.
+          }
+          year == -1 && matcher.usePattern(YEAR_PATTERN).matches() -> {
+            year = Integer.parseInt(matcher.group(1))
+          }
+        }
+
+        pos = dateCharacterOffset(s, end + 1, limit, false)
+      }
+
+      // Convert two-digit years into four-digit years. 99 becomes 1999, 15 becomes 2015.
+      if (year in 70..99) year += 1900
+      if (year in 0..69) year += 2000
+
+      // If any partial is omitted or out of range, return -1. The date is impossible. Note that leap
+      // seconds are not supported by this syntax.
+      require(year >= 1601)
+      require(month != -1)
+      require(dayOfMonth in 1..31)
+      require(hour in 0..23)
+      require(minute in 0..59)
+      require(second in 0..59)
+
+      GregorianCalendar(UTC).apply {
+        isLenient = false
+        set(Calendar.YEAR, year)
+        set(Calendar.MONTH, month - 1)
+        set(Calendar.DAY_OF_MONTH, dayOfMonth)
+        set(Calendar.HOUR_OF_DAY, hour)
+        set(Calendar.MINUTE, minute)
+        set(Calendar.SECOND, second)
+        set(Calendar.MILLISECOND, 0)
+        return timeInMillis
+      }
+    }
+
+    /**
+     * Returns the index of the next date character in `input`, or if `invert` the index
+     * of the next non-date character in `input`.
+     */
+    private fun dateCharacterOffset(input: String, pos: Int, limit: Int, invert: Boolean): Int {
+      for (i in pos until limit) {
+        val c = input[i].toInt()
+        val dateCharacter = (c < ' '.toInt() && c != '\t'.toInt() || c >= '\u007f'.toInt()
+            || c in '0'.toInt()..'9'.toInt()
+            || c in 'a'.toInt()..'z'.toInt()
+            || c in 'A'.toInt()..'Z'.toInt()
+            || c == ':'.toInt())
+        if (dateCharacter == !invert) return i
+      }
+      return limit
+    }
+
+    /**
+     * Returns the positive value if `attributeValue` is positive, or [Long.MIN_VALUE] if it is
+     * either 0 or negative. If the value is positive but out of range, this returns
+     * [Long.MAX_VALUE].
+     *
+     * @throws NumberFormatException if `s` is not an integer of any precision.
+     */
+    private fun parseMaxAge(s: String): Long {
+      try {
+        val parsed = s.toLong()
+        return if (parsed <= 0L) Long.MIN_VALUE else parsed
+      } catch (e: NumberFormatException) {
+        // Check if the value is an integer (positive or negative) that's too big for a long.
+        if (s.matches("-?\\d+".toRegex())) {
+          return if (s.startsWith("-")) Long.MIN_VALUE else Long.MAX_VALUE
+        }
+        throw e
+      }
+    }
+
+    /**
+     * Returns a domain string like `example.com` for an input domain like `EXAMPLE.COM`
+     * or `.example.com`.
+     */
+    private fun parseDomain(s: String): String {
+      require(!s.endsWith("."))
+      return canonicalizeHost(s.removePrefix(".")) ?: throw IllegalArgumentException()
+    }
+
+    /** Returns all of the cookies from a set of HTTP response headers.  */
+    @JvmStatic
+    fun parseAll(url: HttpUrl, headers: Headers): List<Cookie> {
+      val cookieStrings = headers.values("Set-Cookie")
+      var cookies: MutableList<Cookie>? = null
+
+      for (i in 0 until cookieStrings.size) {
+        val cookie = Cookie.parse(url, cookieStrings[i]) ?: continue
+        if (cookies == null) cookies = mutableListOf()
+        cookies.add(cookie)
+      }
+
+      return if (cookies != null) {
+        Collections.unmodifiableList(cookies)
+      } else {
+        emptyList()
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/CookieJar.java b/okhttp/src/main/java/okhttp3/CookieJar.java
deleted file mode 100644
index bdb3cd552e..0000000000
--- a/okhttp/src/main/java/okhttp3/CookieJar.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.Collections;
-import java.util.List;
-
-/**
- * Provides <strong>policy</strong> and <strong>persistence</strong> for HTTP cookies.
- *
- * <p>As policy, implementations of this interface are responsible for selecting which cookies to
- * accept and which to reject. A reasonable policy is to reject all cookies, though that may
- * interfere with session-based authentication schemes that require cookies.
- *
- * <p>As persistence, implementations of this interface must also provide storage of cookies. Simple
- * implementations may store cookies in memory; sophisticated ones may use the file system or
- * database to hold accepted cookies. The <a
- * href="https://tools.ietf.org/html/rfc6265#section-5.3">cookie storage model</a> specifies
- * policies for updating and expiring cookies.
- */
-public interface CookieJar {
-  /** A cookie jar that never accepts any cookies. */
-  CookieJar NO_COOKIES = new CookieJar() {
-    @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
-    }
-
-    @Override public List<Cookie> loadForRequest(HttpUrl url) {
-      return Collections.emptyList();
-    }
-  };
-
-  /**
-   * Saves {@code cookies} from an HTTP response to this store according to this jar's policy.
-   *
-   * <p>Note that this method may be called a second time for a single HTTP response if the response
-   * includes a trailer. For this obscure HTTP feature, {@code cookies} contains only the trailer's
-   * cookies.
-   */
-  void saveFromResponse(HttpUrl url, List<Cookie> cookies);
-
-  /**
-   * Load cookies from the jar for an HTTP request to {@code url}. This method returns a possibly
-   * empty list of cookies for the network request.
-   *
-   * <p>Simple implementations will return the accepted cookies that have not yet expired and that
-   * {@linkplain Cookie#matches match} {@code url}.
-   */
-  List<Cookie> loadForRequest(HttpUrl url);
-}
diff --git a/okhttp/src/main/java/okhttp3/CookieJar.kt b/okhttp/src/main/java/okhttp3/CookieJar.kt
new file mode 100644
index 0000000000..d270f25a98
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/CookieJar.kt
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+/**
+ * Provides **policy** and **persistence** for HTTP cookies.
+ *
+ * As policy, implementations of this interface are responsible for selecting which cookies to
+ * accept and which to reject. A reasonable policy is to reject all cookies, though that may
+ * interfere with session-based authentication schemes that require cookies.
+ *
+ * As persistence, implementations of this interface must also provide storage of cookies. Simple
+ * implementations may store cookies in memory; sophisticated ones may use the file system or
+ * database to hold accepted cookies. The [cookie storage model][rfc_6265_53] specifies policies for
+ * updating and expiring cookies.
+ *
+ * [rfc_6265_53]: https://tools.ietf.org/html/rfc6265#section-5.3
+ */
+interface CookieJar {
+  /**
+   * Saves `cookies` from an HTTP response to this store according to this jar's policy.
+   *
+   * Note that this method may be called a second time for a single HTTP response if the response
+   * includes a trailer. For this obscure HTTP feature, `cookies` contains only the trailer's
+   * cookies.
+   */
+  fun saveFromResponse(url: HttpUrl, cookies: List<Cookie>)
+
+  /**
+   * Load cookies from the jar for an HTTP request to `url`. This method returns a possibly
+   * empty list of cookies for the network request.
+   *
+   * Simple implementations will return the accepted cookies that have not yet expired and that
+   * [match][Cookie.matches] `url`.
+   */
+  fun loadForRequest(url: HttpUrl): List<Cookie>
+
+  companion object {
+    /** A cookie jar that never accepts any cookies. */
+    @JvmField
+    val NO_COOKIES: CookieJar = object : CookieJar {
+      override fun saveFromResponse(url: HttpUrl, cookies: List<Cookie>) {}
+
+      override fun loadForRequest(url: HttpUrl): List<Cookie> {
+        return emptyList()
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Credentials.java b/okhttp/src/main/java/okhttp3/Credentials.kt
similarity index 55%
rename from okhttp/src/main/java/okhttp3/Credentials.java
rename to okhttp/src/main/java/okhttp3/Credentials.kt
index 530863e4a8..bb670714c7 100644
--- a/okhttp/src/main/java/okhttp3/Credentials.java
+++ b/okhttp/src/main/java/okhttp3/Credentials.kt
@@ -13,26 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3;
+package okhttp3
 
-import java.nio.charset.Charset;
-import okio.ByteString;
-
-import static okhttp3.internal.Util.ISO_8859_1;
+import okio.ByteString.Companion.encode
+import java.nio.charset.Charset
+import java.nio.charset.StandardCharsets.ISO_8859_1
 
 /** Factory for HTTP authorization credentials. */
-public final class Credentials {
-  private Credentials() {
-  }
-
+object Credentials {
   /** Returns an auth credential for the Basic scheme. */
-  public static String basic(String username, String password) {
-    return basic(username, password, ISO_8859_1);
-  }
-
-  public static String basic(String username, String password, Charset charset) {
-    String usernameAndPassword = username + ":" + password;
-    String encoded = ByteString.encodeString(usernameAndPassword, charset).base64();
-    return "Basic " + encoded;
+  @JvmStatic @JvmOverloads fun basic(
+    username: String,
+    password: String,
+    charset: Charset = ISO_8859_1
+  ): String {
+    val usernameAndPassword = "$username:$password"
+    val encoded = usernameAndPassword.encode(charset).base64()
+    return "Basic $encoded"
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
deleted file mode 100644
index 21013bda11..0000000000
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Deque;
-import java.util.Iterator;
-import java.util.List;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.RealCall.AsyncCall;
-import okhttp3.internal.Util;
-
-/**
- * Policy on when async requests are executed.
- *
- * <p>Each dispatcher uses an {@link ExecutorService} to run calls internally. If you supply your
- * own executor, it should be able to run {@linkplain #getMaxRequests the configured maximum} number
- * of calls concurrently.
- */
-public final class Dispatcher {
-  private int maxRequests = 64;
-  private int maxRequestsPerHost = 5;
-  private @Nullable Runnable idleCallback;
-
-  /** Executes calls. Created lazily. */
-  private @Nullable ExecutorService executorService;
-
-  /** Ready async calls in the order they'll be run. */
-  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
-
-  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();
-
-  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
-
-  public Dispatcher(ExecutorService executorService) {
-    this.executorService = executorService;
-  }
-
-  public Dispatcher() {
-  }
-
-  public synchronized ExecutorService executorService() {
-    if (executorService == null) {
-      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
-          new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
-    }
-    return executorService;
-  }
-
-  /**
-   * Set the maximum number of requests to execute concurrently. Above this requests queue in
-   * memory, waiting for the running calls to complete.
-   *
-   * <p>If more than {@code maxRequests} requests are in flight when this is invoked, those requests
-   * will remain in flight.
-   */
-  public synchronized void setMaxRequests(int maxRequests) {
-    if (maxRequests < 1) {
-      throw new IllegalArgumentException("max < 1: " + maxRequests);
-    }
-    this.maxRequests = maxRequests;
-    promoteCalls();
-  }
-
-  public synchronized int getMaxRequests() {
-    return maxRequests;
-  }
-
-  /**
-   * Set the maximum number of requests for each host to execute concurrently. This limits requests
-   * by the URL's host name. Note that concurrent requests to a single IP address may still exceed
-   * this limit: multiple hostnames may share an IP address or be routed through the same HTTP
-   * proxy.
-   *
-   * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those
-   * requests will remain in flight.
-   *
-   * <p>WebSocket connections to hosts <b>do not</b> count against this limit.
-   */
-  public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
-    if (maxRequestsPerHost < 1) {
-      throw new IllegalArgumentException("max < 1: " + maxRequestsPerHost);
-    }
-    this.maxRequestsPerHost = maxRequestsPerHost;
-    promoteCalls();
-  }
-
-  public synchronized int getMaxRequestsPerHost() {
-    return maxRequestsPerHost;
-  }
-
-  /**
-   * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running
-   * calls returns to zero).
-   *
-   * <p>Note: The time at which a {@linkplain Call call} is considered idle is different depending
-   * on whether it was run {@linkplain Call#enqueue(Callback) asynchronously} or
-   * {@linkplain Call#execute() synchronously}. Asynchronous calls become idle after the
-   * {@link Callback#onResponse onResponse} or {@link Callback#onFailure onFailure} callback has
-   * returned. Synchronous calls become idle once {@link Call#execute() execute()} returns. This
-   * means that if you are doing synchronous calls the network layer will not truly be idle until
-   * every returned {@link Response} has been closed.
-   */
-  public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
-    this.idleCallback = idleCallback;
-  }
-
-  synchronized void enqueue(AsyncCall call) {
-    if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {
-      runningAsyncCalls.add(call);
-      executorService().execute(call);
-    } else {
-      readyAsyncCalls.add(call);
-    }
-  }
-
-  /**
-   * Cancel all calls currently enqueued or executing. Includes calls executed both {@linkplain
-   * Call#execute() synchronously} and {@linkplain Call#enqueue asynchronously}.
-   */
-  public synchronized void cancelAll() {
-    for (AsyncCall call : readyAsyncCalls) {
-      call.get().cancel();
-    }
-
-    for (AsyncCall call : runningAsyncCalls) {
-      call.get().cancel();
-    }
-
-    for (RealCall call : runningSyncCalls) {
-      call.cancel();
-    }
-  }
-
-  private void promoteCalls() {
-    if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.
-    if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.
-
-    for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {
-      AsyncCall call = i.next();
-
-      if (runningCallsForHost(call) < maxRequestsPerHost) {
-        i.remove();
-        runningAsyncCalls.add(call);
-        executorService().execute(call);
-      }
-
-      if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.
-    }
-  }
-
-  /** Returns the number of running calls that share a host with {@code call}. */
-  private int runningCallsForHost(AsyncCall call) {
-    int result = 0;
-    for (AsyncCall c : runningAsyncCalls) {
-      if (c.get().forWebSocket) continue;
-      if (c.host().equals(call.host())) result++;
-    }
-    return result;
-  }
-
-  /** Used by {@code Call#execute} to signal it is in-flight. */
-  synchronized void executed(RealCall call) {
-    runningSyncCalls.add(call);
-  }
-
-  /** Used by {@code AsyncCall#run} to signal completion. */
-  void finished(AsyncCall call) {
-    finished(runningAsyncCalls, call, true);
-  }
-
-  /** Used by {@code Call#execute} to signal completion. */
-  void finished(RealCall call) {
-    finished(runningSyncCalls, call, false);
-  }
-
-  private <T> void finished(Deque<T> calls, T call, boolean promoteCalls) {
-    int runningCallsCount;
-    Runnable idleCallback;
-    synchronized (this) {
-      if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!");
-      if (promoteCalls) promoteCalls();
-      runningCallsCount = runningCallsCount();
-      idleCallback = this.idleCallback;
-    }
-
-    if (runningCallsCount == 0 && idleCallback != null) {
-      idleCallback.run();
-    }
-  }
-
-  /** Returns a snapshot of the calls currently awaiting execution. */
-  public synchronized List<Call> queuedCalls() {
-    List<Call> result = new ArrayList<>();
-    for (AsyncCall asyncCall : readyAsyncCalls) {
-      result.add(asyncCall.get());
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  /** Returns a snapshot of the calls currently being executed. */
-  public synchronized List<Call> runningCalls() {
-    List<Call> result = new ArrayList<>();
-    result.addAll(runningSyncCalls);
-    for (AsyncCall asyncCall : runningAsyncCalls) {
-      result.add(asyncCall.get());
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  public synchronized int queuedCallsCount() {
-    return readyAsyncCalls.size();
-  }
-
-  public synchronized int runningCallsCount() {
-    return runningAsyncCalls.size() + runningSyncCalls.size();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.kt b/okhttp/src/main/java/okhttp3/Dispatcher.kt
new file mode 100644
index 0000000000..ab16307c53
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.kt
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.RealCall.AsyncCall
+import okhttp3.internal.Util
+import java.util.ArrayDeque
+import java.util.ArrayList
+import java.util.Collections
+import java.util.Deque
+import java.util.concurrent.ExecutorService
+import java.util.concurrent.SynchronousQueue
+import java.util.concurrent.ThreadPoolExecutor
+import java.util.concurrent.TimeUnit
+
+/**
+ * Policy on when async requests are executed.
+ *
+ *
+ * Each dispatcher uses an [ExecutorService] to run calls internally. If you supply your own
+ * executor, it should be able to run [the configured maximum][maxRequests] number of calls
+ * concurrently.
+ */
+class Dispatcher constructor() {
+  /**
+   * Set the maximum number of requests to execute concurrently. Above this requests queue in
+   * memory, waiting for the running calls to complete.
+   *
+   * If more than `maxRequests` requests are in flight when this is invoked, those requests
+   * will remain in flight.
+   */
+  @get:Synchronized var maxRequests = 64
+    set(maxRequests) {
+      require(maxRequests >= 1) { "max < 1: $maxRequests" }
+      synchronized(this) {
+        field = maxRequests
+      }
+      promoteAndExecute()
+    }
+
+  /**
+   * Set the maximum number of requests for each host to execute concurrently. This limits requests
+   * by the URL's host name. Note that concurrent requests to a single IP address may still exceed
+   * this limit: multiple hostnames may share an IP address or be routed through the same HTTP
+   * proxy.
+   *
+   * If more than `maxRequestsPerHost` requests are in flight when this is invoked, those
+   * requests will remain in flight.
+   *
+   * WebSocket connections to hosts **do not** count against this limit.
+   */
+  @get:Synchronized var maxRequestsPerHost = 5
+    set(maxRequestsPerHost) {
+      require(maxRequestsPerHost >= 1) { "max < 1: $maxRequestsPerHost" }
+      synchronized(this) {
+        field = maxRequestsPerHost
+      }
+      promoteAndExecute()
+    }
+
+  private var idleCallback: Runnable? = null
+
+  /** Executes calls. Created lazily.  */
+  private var executorService: ExecutorService? = null
+
+  /** Ready async calls in the order they'll be run.  */
+  private val readyAsyncCalls = ArrayDeque<AsyncCall>()
+
+  /** Running asynchronous calls. Includes canceled calls that haven't finished yet.  */
+  private val runningAsyncCalls = ArrayDeque<AsyncCall>()
+
+  /** Running synchronous calls. Includes canceled calls that haven't finished yet.  */
+  private val runningSyncCalls = ArrayDeque<RealCall>()
+
+  constructor(executorService: ExecutorService) : this() {
+    this.executorService = executorService
+  }
+
+  @Synchronized fun executorService(): ExecutorService {
+    if (executorService == null) {
+      executorService = ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS,
+          SynchronousQueue(), Util.threadFactory("OkHttp Dispatcher", false))
+    }
+    return executorService!!
+  }
+
+  /**
+   * Set a callback to be invoked each time the dispatcher becomes idle (when the number of running
+   * calls returns to zero).
+   *
+   * Note: The time at which a [call][Call] is considered idle is different depending
+   * on whether it was run [asynchronously][Call.enqueue] or [synchronously][Call.execute].
+   * Asynchronous calls become idle after the [onResponse][Callback.onResponse] or
+   * [onFailure][Callback.onFailure] callback has returned. Synchronous calls become idle once
+   * [execute()][Call.execute] returns. This means that if you are doing synchronous calls the
+   * network layer will not truly be idle until every returned [Response] has been closed.
+   */
+  @Synchronized fun setIdleCallback(idleCallback: Runnable?) {
+    this.idleCallback = idleCallback
+  }
+
+  internal fun enqueue(call: AsyncCall) {
+    synchronized(this) {
+      readyAsyncCalls.add(call)
+
+      // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to
+      // the same host.
+      if (!call.get().forWebSocket) {
+        val existingCall = findExistingCallWithHost(call.host())
+        if (existingCall != null) call.reuseCallsPerHostFrom(existingCall)
+      }
+    }
+    promoteAndExecute()
+  }
+
+  private fun findExistingCallWithHost(host: String): AsyncCall? {
+    for (existingCall in runningAsyncCalls) {
+      if (existingCall.host() == host) return existingCall
+    }
+    for (existingCall in readyAsyncCalls) {
+      if (existingCall.host() == host) return existingCall
+    }
+    return null
+  }
+
+  /**
+   * Cancel all calls currently enqueued or executing. Includes calls executed both
+   * [synchronously][Call.execute] and [asynchronously][Call.enqueue].
+   */
+  @Synchronized fun cancelAll() {
+    for (call in readyAsyncCalls) {
+      call.get().cancel()
+    }
+    for (call in runningAsyncCalls) {
+      call.get().cancel()
+    }
+    for (call in runningSyncCalls) {
+      call.cancel()
+    }
+  }
+
+  /**
+   * Promotes eligible calls from [readyAsyncCalls] to [runningAsyncCalls] and runs them on the
+   * executor service. Must not be called with synchronization because executing calls can call
+   * into user code.
+   *
+   * @return true if the dispatcher is currently running calls.
+   */
+  private fun promoteAndExecute(): Boolean {
+    assert(!Thread.holdsLock(this))
+
+    val executableCalls = ArrayList<AsyncCall>()
+    val isRunning: Boolean
+    synchronized(this) {
+      val i = readyAsyncCalls.iterator()
+      while (i.hasNext()) {
+        val asyncCall = i.next()
+
+        if (runningAsyncCalls.size >= this.maxRequests) break // Max capacity.
+        if (asyncCall.callsPerHost().get() >= this.maxRequestsPerHost) continue // Host max capacity.
+
+        i.remove()
+        asyncCall.callsPerHost().incrementAndGet()
+        executableCalls.add(asyncCall)
+        runningAsyncCalls.add(asyncCall)
+      }
+      isRunning = runningCallsCount() > 0
+    }
+
+    for (i in 0 until executableCalls.size) {
+      val asyncCall = executableCalls[i]
+      asyncCall.executeOn(executorService())
+    }
+
+    return isRunning
+  }
+
+  /** Used by `Call#execute` to signal it is in-flight.  */
+  @Synchronized internal fun executed(call: RealCall) {
+    runningSyncCalls.add(call)
+  }
+
+  /** Used by `AsyncCall#run` to signal completion.  */
+  internal fun finished(call: AsyncCall) {
+    call.callsPerHost().decrementAndGet()
+    finished(runningAsyncCalls, call)
+  }
+
+  /** Used by `Call#execute` to signal completion.  */
+  internal fun finished(call: RealCall) {
+    finished(runningSyncCalls, call)
+  }
+
+  private fun <T> finished(calls: Deque<T>, call: T) {
+    val idleCallback: Runnable?
+    synchronized(this) {
+      if (!calls.remove(call)) throw AssertionError("Call wasn't in-flight!")
+      idleCallback = this.idleCallback
+    }
+
+    val isRunning = promoteAndExecute()
+
+    if (!isRunning && idleCallback != null) {
+      idleCallback.run()
+    }
+  }
+
+  /** Returns a snapshot of the calls currently awaiting execution.  */
+  @Synchronized fun queuedCalls(): List<Call> {
+    return Collections.unmodifiableList(readyAsyncCalls.map { it.get() })
+  }
+
+  /** Returns a snapshot of the calls currently being executed.  */
+  @Synchronized fun runningCalls(): List<Call> {
+    return Collections.unmodifiableList(runningSyncCalls + runningAsyncCalls.map { it.get() })
+  }
+
+  @Synchronized fun queuedCallsCount(): Int = readyAsyncCalls.size
+
+  @Synchronized fun runningCallsCount(): Int = runningAsyncCalls.size + runningSyncCalls.size
+}
diff --git a/okhttp/src/main/java/okhttp3/Dns.java b/okhttp/src/main/java/okhttp3/Dns.java
deleted file mode 100644
index de3b4cb215..0000000000
--- a/okhttp/src/main/java/okhttp3/Dns.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * A domain name service that resolves IP addresses for host names. Most applications will use the
- * {@linkplain #SYSTEM system DNS service}, which is the default. Some applications may provide
- * their own implementation to use a different DNS server, to prefer IPv6 addresses, to prefer IPv4
- * addresses, or to force a specific known IP address.
- *
- * <p>Implementations of this interface must be safe for concurrent use.
- */
-public interface Dns {
-  /**
-   * A DNS that uses {@link InetAddress#getAllByName} to ask the underlying operating system to
-   * lookup IP addresses. Most custom {@link Dns} implementations should delegate to this instance.
-   */
-  Dns SYSTEM = new Dns() {
-    @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-      if (hostname == null) throw new UnknownHostException("hostname == null");
-      try {
-        return Arrays.asList(InetAddress.getAllByName(hostname));
-      } catch (NullPointerException e) {
-        UnknownHostException unknownHostException =
-            new UnknownHostException("Broken system behaviour for dns lookup of " + hostname);
-        unknownHostException.initCause(e);
-        throw unknownHostException;
-      }
-    }
-  };
-
-  /**
-   * Returns the IP addresses of {@code hostname}, in the order they will be attempted by OkHttp. If
-   * a connection to an address fails, OkHttp will retry the connection with the next address until
-   * either a connection is made, the set of IP addresses is exhausted, or a limit is exceeded.
-   */
-  List<InetAddress> lookup(String hostname) throws UnknownHostException;
-}
diff --git a/okhttp/src/main/java/okhttp3/Dns.kt b/okhttp/src/main/java/okhttp3/Dns.kt
new file mode 100644
index 0000000000..46ae272099
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Dns.kt
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.Dns.Companion.SYSTEM
+import java.net.InetAddress
+import java.net.UnknownHostException
+
+/**
+ * A domain name service that resolves IP addresses for host names. Most applications will use the
+ * [system DNS service][SYSTEM], which is the default. Some applications may provide their own
+ * implementation to use a different DNS server, to prefer IPv6 addresses, to prefer IPv4 addresses,
+ * or to force a specific known IP address.
+ *
+ * Implementations of this interface must be safe for concurrent use.
+ */
+interface Dns {
+  /**
+   * Returns the IP addresses of `hostname`, in the order they will be attempted by OkHttp. If a
+   * connection to an address fails, OkHttp will retry the connection with the next address until
+   * either a connection is made, the set of IP addresses is exhausted, or a limit is exceeded.
+   */
+  @Throws(UnknownHostException::class)
+  fun lookup(hostname: String): List<InetAddress>
+
+  companion object {
+    /**
+     * A DNS that uses [InetAddress.getAllByName] to ask the underlying operating system to
+     * lookup IP addresses. Most custom [Dns] implementations should delegate to this instance.
+     */
+    @JvmField
+    val SYSTEM = object : Dns {
+      override fun lookup(hostname: String): List<InetAddress> {
+        try {
+          return InetAddress.getAllByName(hostname).toList()
+        } catch (e: NullPointerException) {
+          val unknownHostException = UnknownHostException(
+              "Broken system behaviour for dns lookup of $hostname")
+          unknownHostException.initCause(e)
+          throw unknownHostException
+        }
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/EventListener.java b/okhttp/src/main/java/okhttp3/EventListener.java
deleted file mode 100644
index 583675f804..0000000000
--- a/okhttp/src/main/java/okhttp3/EventListener.java
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.util.List;
-import javax.annotation.Nullable;
-
-/**
- * Listener for metrics events. Extend this class to monitor the quantity, size, and duration of
- * your application's HTTP calls.
- *
- * <h3>Warning: This is a non-final API.</h3>
- *
- * <p><strong>As of OkHttp 3.10, this feature is an unstable preview: the API is subject to change,
- * and the implementation is incomplete. We expect that OkHttp 3.11 or 3.12 will finalize this API.
- * Until then, expect API and behavior changes when you update your OkHttp dependency.</strong>
- *
- * <p>All start/connect/acquire events will eventually receive a matching end/release event,
- * either successful (non-null parameters), or failed (non-null throwable).  The first common
- * parameters of each event pair are used to link the event in case of concurrent or repeated
- * events e.g. dnsStart(call, domainName) -&gt; dnsEnd(call, domainName, inetAddressList).
- *
- * <p>Nesting is as follows
- * <ul>
- *   <li>call -&gt; (dns -&gt; connect -&gt; secure connect)* -&gt; request events</li>
- *   <li>call -&gt; (connection acquire/release)*</li>
- * </ul>
- *
- * <p>Request events are ordered:
- * requestHeaders -&gt; requestBody -&gt; responseHeaders -&gt; responseBody
- *
- * <p>Since connections may be reused, the dns and connect events may not be present for a call,
- * or may be repeated in case of failure retries, even concurrently in case of happy eyeballs type
- * scenarios. A redirect cross domain, or to use https may cause additional connection and request
- * events.
- *
- * <p>All event methods must execute fast, without external locking, cannot throw exceptions,
- * attempt to mutate the event parameters, or be reentrant back into the client.
- * Any IO - writing to files or network should be done asynchronously.
- */
-public abstract class EventListener {
-  public static final EventListener NONE = new EventListener() {
-  };
-
-  static EventListener.Factory factory(final EventListener listener) {
-    return new EventListener.Factory() {
-      public EventListener create(Call call) {
-        return listener;
-      }
-    };
-  }
-
-  /**
-   * Invoked as soon as a call is enqueued or executed by a client. In case of thread or stream
-   * limits, this call may be executed well before processing the request is able to begin.
-   *
-   * <p>This will be invoked only once for a single {@link Call}. Retries of different routes
-   * or redirects will be handled within the boundaries of a single callStart and {@link
-   * #callEnd}/{@link #callFailed} pair.
-   */
-  public void callStart(Call call) {
-  }
-
-  /**
-   * Invoked just prior to a DNS lookup. See {@link Dns#lookup(String)}.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different host.
-   *
-   * <p>If the {@link Call} is able to reuse an existing pooled connection, this method will not be
-   * invoked. See {@link ConnectionPool}.
-   */
-  public void dnsStart(Call call, String domainName) {
-  }
-
-  /**
-   * Invoked immediately after a DNS lookup.
-   *
-   * <p>This method is invoked after {@link #dnsStart}.
-   */
-  public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
-  }
-
-  /**
-   * Invoked just prior to initiating a socket connection.
-   *
-   * <p>This method will be invoked if no existing connection in the {@link ConnectionPool} can be
-   * reused.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address, or a connection is retried.
-   */
-  public void connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
-  }
-
-  /**
-   * Invoked just prior to initiating a TLS connection.
-   *
-   * <p>This method is invoked if the following conditions are met:
-   * <ul>
-   * <li>The {@link Call#request()} requires TLS.</li>
-   * <li>No existing connection from the {@link ConnectionPool} can be reused.</li>
-   * </ul>
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address, or a connection is retried.
-   */
-  public void secureConnectStart(Call call) {
-  }
-
-  /**
-   * Invoked immediately after a TLS connection was attempted.
-   *
-   * <p>This method is invoked after {@link #secureConnectStart}.
-   */
-  public void secureConnectEnd(Call call, @Nullable Handshake handshake) {
-  }
-
-  /**
-   * Invoked immediately after a socket connection was attempted.
-   *
-   * <p>If the {@code call} uses HTTPS, this will be invoked after
-   * {@link #secureConnectEnd(Call, Handshake)}, otherwise it will invoked after
-   * {@link #connectStart(Call, InetSocketAddress, Proxy)}.
-   */
-  public void connectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
-      @Nullable Protocol protocol) {
-  }
-
-  /**
-   * Invoked when a connection attempt fails. This failure is not terminal if further routes are
-   * available and failure recovery is enabled.
-   *
-   * <p>If the {@code call} uses HTTPS, this will be invoked after {@link #secureConnectEnd(Call,
-   * Handshake)}, otherwise it will invoked after {@link #connectStart(Call, InetSocketAddress,
-   * Proxy)}.
-   */
-  public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
-      @Nullable Protocol protocol, IOException ioe) {
-  }
-
-  /**
-   * Invoked after a connection has been acquired for the {@code call}.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address.
-   */
-  public void connectionAcquired(Call call, Connection connection) {
-  }
-
-  /**
-   * Invoked after a connection has been released for the {@code call}.
-   *
-   * <p>This method is always invoked after {@link #connectionAcquired(Call, Connection)}.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address.
-   */
-  public void connectionReleased(Call call, Connection connection) {
-  }
-
-  /**
-   * Invoked just prior to sending request headers.
-   *
-   * <p>The connection is implicit, and will generally relate to the last
-   * {@link #connectionAcquired(Call, Connection)} event.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address.
-   */
-  public void requestHeadersStart(Call call) {
-  }
-
-  /**
-   * Invoked immediately after sending request headers.
-   *
-   * <p>This method is always invoked after {@link #requestHeadersStart(Call)}.
-   *
-   * @param request the request sent over the network. It is an error to access the body of this
-   *     request.
-   */
-  public void requestHeadersEnd(Call call, Request request) {
-  }
-
-  /**
-   * Invoked just prior to sending a request body.  Will only be invoked for request allowing and
-   * having a request body to send.
-   *
-   * <p>The connection is implicit, and will generally relate to the last
-   * {@link #connectionAcquired(Call, Connection)} event.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address.
-   */
-  public void requestBodyStart(Call call) {
-  }
-
-  /**
-   * Invoked immediately after sending a request body.
-   *
-   * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
-   */
-  public void requestBodyEnd(Call call, long byteCount) {
-  }
-
-  /**
-   * Invoked just prior to receiving response headers.
-   *
-   * <p>The connection is implicit, and will generally relate to the last
-   * {@link #connectionAcquired(Call, Connection)} event.
-   *
-   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
-   * to the {@link Call#request()} is a redirect to a different address.
-   */
-  public void responseHeadersStart(Call call) {
-  }
-
-  /**
-   * Invoked immediately after receiving response headers.
-   *
-   * <p>This method is always invoked after {@link #responseHeadersStart}.
-   *
-   * @param response the response received over the network. It is an error to access the body of
-   *     this response.
-   */
-  public void responseHeadersEnd(Call call, Response response) {
-  }
-
-  /**
-   * Invoked just prior to receiving the response body.
-   *
-   * <p>The connection is implicit, and will generally relate to the last
-   * {@link #connectionAcquired(Call, Connection)} event.
-   *
-   * <p>This will usually be invoked only 1 time for a single {@link Call},
-   * exceptions are a limited set of cases including failure recovery.
-   */
-  public void responseBodyStart(Call call) {
-  }
-
-  /**
-   * Invoked immediately after receiving a response body and completing reading it.
-   *
-   * <p>Will only be invoked for requests having a response body e.g. won't be invoked for a
-   * websocket upgrade.
-   *
-   * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
-   */
-  public void responseBodyEnd(Call call, long byteCount) {
-  }
-
-  /**
-   * Invoked immediately after a call has completely ended.  This includes delayed consumption
-   * of response body by the caller.
-   *
-   * <p>This method is always invoked after {@link #callStart(Call)}.
-   */
-  public void callEnd(Call call) {
-  }
-
-  /**
-   * Invoked when a call fails permanently.
-   *
-   * <p>This method is always invoked after {@link #callStart(Call)}.
-   */
-  public void callFailed(Call call, IOException ioe) {
-  }
-
-  /**
-   * <h3>Warning: This is a non-final API.</h3>
-   *
-   * <p><strong>As of OkHttp 3.10, this feature is an unstable preview: the API is subject to
-   * change, and the implementation is incomplete. We expect that OkHttp 3.11 or 3.12 will finalize
-   * this API. Until then, expect API and behavior changes when you update your OkHttp
-   * dependency.</strong>
-   */
-  public interface Factory {
-    /**
-     * Creates an instance of the {@link EventListener} for a particular {@link Call}. The returned
-     * {@link EventListener} instance will be used during the lifecycle of the {@code call}.
-     *
-     * <p>This method is invoked after the {@code call} is created. See
-     * {@link OkHttpClient#newCall(Request)}.
-     *
-     * <p><strong>It is an error for implementations to issue any mutating operations on the
-     * {@code call} instance from this method.</strong>
-     */
-    EventListener create(Call call);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/EventListener.kt b/okhttp/src/main/java/okhttp3/EventListener.kt
new file mode 100644
index 0000000000..f4ea9063ab
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/EventListener.kt
@@ -0,0 +1,356 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.io.IOException
+import java.net.InetAddress
+import java.net.InetSocketAddress
+import java.net.Proxy
+
+/**
+ * Listener for metrics events. Extend this class to monitor the quantity, size, and duration of
+ * your application's HTTP calls.
+ *
+ * All start/connect/acquire events will eventually receive a matching end/release event, either
+ * successful (non-null parameters), or failed (non-null throwable).  The first common parameters of
+ * each event pair are used to link the event in case of concurrent or repeated events e.g.
+ * dnsStart(call, domainName) -&gt; dnsEnd(call, domainName, inetAddressList).
+ *
+ * Nesting is as follows
+ *
+ *  * call -&gt; (dns -&gt; connect -&gt; secure connect)* -&gt; request events
+ *  * call -&gt; (connection acquire/release)*
+ *
+ * Request events are ordered:
+ *
+ * requestHeaders -&gt; requestBody -&gt; responseHeaders -&gt; responseBody
+ *
+ * Since connections may be reused, the dns and connect events may not be present for a call, or may
+ * be repeated in case of failure retries, even concurrently in case of happy eyeballs type
+ * scenarios. A redirect cross domain, or to use https may cause additional connection and request
+ * events.
+ *
+ * All event methods must execute fast, without external locking, cannot throw exceptions, attempt
+ * to mutate the event parameters, or be re-entrant back into the client. Any IO - writing to files
+ * or network should be done asynchronously.
+ */
+abstract class EventListener {
+  /**
+   * Invoked as soon as a call is enqueued or executed by a client. In case of thread or stream
+   * limits, this call may be executed well before processing the request is able to begin.
+   *
+   * This will be invoked only once for a single [Call]. Retries of different routes or redirects
+   * will be handled within the boundaries of a single [callStart] and [callEnd]/[callFailed] pair.
+   */
+  open fun callStart(
+    call: Call
+  ) {
+  }
+
+  /**
+   * Invoked just prior to a DNS lookup. See [Dns.lookup].
+   *
+   * This can be invoked more than 1 time for a single [Call]. For example, if the response to the
+   * [Call.request] is a redirect to a different host.
+   *
+   * If the [Call] is able to reuse an existing pooled connection, this method will not be invoked.
+   * See [ConnectionPool].
+   */
+  open fun dnsStart(
+    call: Call,
+    domainName: String
+  ) {
+  }
+
+  /**
+   * Invoked immediately after a DNS lookup.
+   *
+   * This method is invoked after [dnsStart].
+   */
+  open fun dnsEnd(
+    call: Call,
+    domainName: String,
+    inetAddressList: List<@JvmSuppressWildcards InetAddress>
+  ) {
+  }
+
+  /**
+   * Invoked just prior to initiating a socket connection.
+   *
+   * This method will be invoked if no existing connection in the [ConnectionPool] can be reused.
+   *
+   * This can be invoked more than 1 time for a single [Call]. For example, if the response to the
+   * [Call.request] is a redirect to a different address, or a connection is retried.
+   */
+  open fun connectStart(
+    call: Call,
+    inetSocketAddress: InetSocketAddress,
+    proxy: Proxy
+  ) {
+  }
+
+  /**
+   * Invoked just prior to initiating a TLS connection.
+   *
+   * This method is invoked if the following conditions are met:
+   *
+   *  * The [Call.request] requires TLS.
+   *
+   *  * No existing connection from the [ConnectionPool] can be reused.
+   *
+   * This can be invoked more than 1 time for a single [Call]. For example, if the response to the
+   * [Call.request] is a redirect to a different address, or a connection is retried.
+   */
+  open fun secureConnectStart(
+    call: Call
+  ) {
+  }
+
+  /**
+   * Invoked immediately after a TLS connection was attempted.
+   *
+   * This method is invoked after [secureConnectStart].
+   */
+  open fun secureConnectEnd(
+    call: Call,
+    handshake: Handshake?
+  ) {
+  }
+
+  /**
+   * Invoked immediately after a socket connection was attempted.
+   *
+   * If the `call` uses HTTPS, this will be invoked after [secureConnectEnd], otherwise it will
+   * invoked after [connectStart].
+   */
+  open fun connectEnd(
+    call: Call,
+    inetSocketAddress: InetSocketAddress,
+    proxy: Proxy,
+    protocol: Protocol?
+  ) {
+  }
+
+  /**
+   * Invoked when a connection attempt fails. This failure is not terminal if further routes are
+   * available and failure recovery is enabled.
+   *
+   * If the `call` uses HTTPS, this will be invoked after [secureConnectEnd], otherwise it will
+   * invoked after [connectStart].
+   */
+  open fun connectFailed(
+    call: Call,
+    inetSocketAddress: InetSocketAddress,
+    proxy: Proxy,
+    protocol: Protocol?,
+    ioe: IOException
+  ) {
+  }
+
+  /**
+   * Invoked after a connection has been acquired for the `call`.
+   *
+   * This can be invoked more than 1 time for a single [Call]. For example, if the response
+   * to the [Call.request] is a redirect to a different address.
+   */
+  open fun connectionAcquired(
+    call: Call,
+    connection: Connection
+  ) {
+  }
+
+  /**
+   * Invoked after a connection has been released for the `call`.
+   *
+   * This method is always invoked after [connectionAcquired].
+   *
+   * This can be invoked more than 1 time for a single [Call]. For example, if the response to the
+   * [Call.request] is a redirect to a different address.
+   */
+  open fun connectionReleased(
+    call: Call,
+    connection: Connection
+  ) {
+  }
+
+  /**
+   * Invoked just prior to sending request headers.
+   *
+   * The connection is implicit, and will generally relate to the last [connectionAcquired] event.
+   *
+   * This can be invoked more than 1 time for a single [Call]. For example, if the response to the
+   * [Call.request] is a redirect to a different address.
+   */
+  open fun requestHeadersStart(
+    call: Call
+  ) {
+  }
+
+  /**
+   * Invoked immediately after sending request headers.
+   *
+   * This method is always invoked after [requestHeadersStart].
+   *
+   * @param request the request sent over the network. It is an error to access the body of this
+   *     request.
+   */
+  open fun requestHeadersEnd(call: Call, request: Request) {
+  }
+
+  /**
+   * Invoked just prior to sending a request body.  Will only be invoked for request allowing and
+   * having a request body to send.
+   *
+   * The connection is implicit, and will generally relate to the last [connectionAcquired] event.
+   *
+   * This can be invoked more than 1 time for a single [Call]. For example, if the response to the
+   * [Call.request] is a redirect to a different address.
+   */
+  open fun requestBodyStart(
+    call: Call
+  ) {
+  }
+
+  /**
+   * Invoked immediately after sending a request body.
+   *
+   * This method is always invoked after [requestBodyStart].
+   */
+  open fun requestBodyEnd(
+    call: Call,
+    byteCount: Long
+  ) {
+  }
+
+  /**
+   * Invoked when a request fails to be written.
+   *
+   * This method is invoked after [requestHeadersStart] or [requestBodyStart]. Note that request
+   * failures do not necessarily fail the entire call.
+   */
+  open fun requestFailed(
+    call: Call,
+    ioe: IOException
+  ) {
+  }
+
+  /**
+   * Invoked just prior to receiving response headers.
+   *
+   * The connection is implicit, and will generally relate to the last [connectionAcquired] event.
+   *
+   * This can be invoked more than 1 time for a single [Call]. For example, if the response to the
+   * [Call.request] is a redirect to a different address.
+   */
+  open fun responseHeadersStart(
+    call: Call
+  ) {
+  }
+
+  /**
+   * Invoked immediately after receiving response headers.
+   *
+   * This method is always invoked after [responseHeadersStart].
+   *
+   * @param response the response received over the network. It is an error to access the body of
+   *     this response.
+   */
+  open fun responseHeadersEnd(
+    call: Call,
+    response: Response
+  ) {
+  }
+
+  /**
+   * Invoked just prior to receiving the response body.
+   *
+   * The connection is implicit, and will generally relate to the last [connectionAcquired] event.
+   *
+   * This will usually be invoked only 1 time for a single [Call], exceptions are a limited set of
+   * cases including failure recovery.
+   */
+  open fun responseBodyStart(
+    call: Call
+  ) {
+  }
+
+  /**
+   * Invoked immediately after receiving a response body and completing reading it.
+   *
+   * Will only be invoked for requests having a response body e.g. won't be invoked for a web socket
+   * upgrade.
+   *
+   * This method is always invoked after [requestBodyStart].
+   */
+  open fun responseBodyEnd(
+    call: Call,
+    byteCount: Long
+  ) {
+  }
+
+  /**
+   * Invoked when a response fails to be read.
+   *
+   * This method is invoked after [responseHeadersStart] or [responseBodyStart]. Note that response
+   * failures do not necessarily fail the entire call.
+   */
+  open fun responseFailed(
+    call: Call,
+    ioe: IOException
+  ) {
+  }
+
+  /**
+   * Invoked immediately after a call has completely ended.  This includes delayed consumption
+   * of response body by the caller.
+   *
+   * This method is always invoked after [callStart].
+   */
+  open fun callEnd(
+    call: Call
+  ) {
+  }
+
+  /**
+   * Invoked when a call fails permanently.
+   *
+   * This method is always invoked after [callStart].
+   */
+  open fun callFailed(
+    call: Call,
+    ioe: IOException
+  ) {
+  }
+
+  interface Factory {
+    /**
+     * Creates an instance of the [EventListener] for a particular [Call]. The returned
+     * [EventListener] instance will be used during the lifecycle of the `call`.
+     *
+     * This method is invoked after the `call` is created. See [OkHttpClient.newCall].
+     *
+     * **It is an error for implementations to issue any mutating operations on the `call` instance
+     * from this method.**
+     */
+    fun create(call: Call): EventListener
+  }
+
+  companion object {
+    @JvmField
+    val NONE: EventListener = object : EventListener() {
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
deleted file mode 100644
index 486c6bbf0e..0000000000
--- a/okhttp/src/main/java/okhttp3/FormBody.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.List;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSink;
-
-import static okhttp3.HttpUrl.FORM_ENCODE_SET;
-import static okhttp3.HttpUrl.percentDecode;
-
-public final class FormBody extends RequestBody {
-  private static final MediaType CONTENT_TYPE =
-      MediaType.parse("application/x-www-form-urlencoded");
-
-  private final List<String> encodedNames;
-  private final List<String> encodedValues;
-
-  FormBody(List<String> encodedNames, List<String> encodedValues) {
-    this.encodedNames = Util.immutableList(encodedNames);
-    this.encodedValues = Util.immutableList(encodedValues);
-  }
-
-  /** The number of key-value pairs in this form-encoded body. */
-  public int size() {
-    return encodedNames.size();
-  }
-
-  public String encodedName(int index) {
-    return encodedNames.get(index);
-  }
-
-  public String name(int index) {
-    return percentDecode(encodedName(index), true);
-  }
-
-  public String encodedValue(int index) {
-    return encodedValues.get(index);
-  }
-
-  public String value(int index) {
-    return percentDecode(encodedValue(index), true);
-  }
-
-  @Override public MediaType contentType() {
-    return CONTENT_TYPE;
-  }
-
-  @Override public long contentLength() {
-    return writeOrCountBytes(null, true);
-  }
-
-  @Override public void writeTo(BufferedSink sink) throws IOException {
-    writeOrCountBytes(sink, false);
-  }
-
-  /**
-   * Either writes this request to {@code sink} or measures its content length. We have one method
-   * do double-duty to make sure the counting and content are consistent, particularly when it comes
-   * to awkward operations like measuring the encoded length of header strings, or the
-   * length-in-digits of an encoded integer.
-   */
-  private long writeOrCountBytes(@Nullable BufferedSink sink, boolean countBytes) {
-    long byteCount = 0L;
-
-    Buffer buffer;
-    if (countBytes) {
-      buffer = new Buffer();
-    } else {
-      buffer = sink.buffer();
-    }
-
-    for (int i = 0, size = encodedNames.size(); i < size; i++) {
-      if (i > 0) buffer.writeByte('&');
-      buffer.writeUtf8(encodedNames.get(i));
-      buffer.writeByte('=');
-      buffer.writeUtf8(encodedValues.get(i));
-    }
-
-    if (countBytes) {
-      byteCount = buffer.size();
-      buffer.clear();
-    }
-
-    return byteCount;
-  }
-
-  public static final class Builder {
-    private final List<String> names = new ArrayList<>();
-    private final List<String> values = new ArrayList<>();
-    private final Charset charset;
-
-    public Builder() {
-      this(null);
-    }
-
-    public Builder(Charset charset) {
-      this.charset = charset;
-    }
-
-    public Builder add(String name, String value) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (value == null) throw new NullPointerException("value == null");
-
-      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true, charset));
-      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true, charset));
-      return this;
-    }
-
-    public Builder addEncoded(String name, String value) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (value == null) throw new NullPointerException("value == null");
-
-      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true, charset));
-      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true, charset));
-      return this;
-    }
-
-    public FormBody build() {
-      return new FormBody(names, values);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/FormBody.kt b/okhttp/src/main/java/okhttp3/FormBody.kt
new file mode 100644
index 0000000000..77f96dca1d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/FormBody.kt
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.HttpUrl.Companion.FORM_ENCODE_SET
+import okhttp3.HttpUrl.Companion.percentDecode
+import okhttp3.internal.Util
+import okio.Buffer
+import okio.BufferedSink
+import java.io.IOException
+import java.nio.charset.Charset
+
+class FormBody internal constructor(
+  encodedNames: List<String>,
+  encodedValues: List<String>
+) : RequestBody() {
+  private val encodedNames: List<String> = Util.immutableList(encodedNames)
+  private val encodedValues: List<String> = Util.immutableList(encodedValues)
+
+  /** The number of key-value pairs in this form-encoded body.  */
+  fun size(): Int = encodedNames.size
+
+  fun encodedName(index: Int) = encodedNames[index]
+
+  fun name(index: Int) = percentDecode(encodedName(index), true)
+
+  fun encodedValue(index: Int) = encodedValues[index]
+
+  fun value(index: Int) = percentDecode(encodedValue(index), true)
+
+  override fun contentType() = CONTENT_TYPE
+
+  override fun contentLength() = writeOrCountBytes(null, true)
+
+  @Throws(IOException::class)
+  override fun writeTo(sink: BufferedSink) {
+    writeOrCountBytes(sink, false)
+  }
+
+  /**
+   * Either writes this request to `sink` or measures its content length. We have one method
+   * do double-duty to make sure the counting and content are consistent, particularly when it comes
+   * to awkward operations like measuring the encoded length of header strings, or the
+   * length-in-digits of an encoded integer.
+   */
+  private fun writeOrCountBytes(sink: BufferedSink?, countBytes: Boolean): Long {
+    var byteCount = 0L
+    val buffer: Buffer = if (countBytes) Buffer() else sink!!.buffer
+
+    for (i in 0 until encodedNames.size) {
+      if (i > 0) buffer.writeByte('&'.toInt())
+      buffer.writeUtf8(encodedNames[i])
+      buffer.writeByte('='.toInt())
+      buffer.writeUtf8(encodedValues[i])
+    }
+
+    if (countBytes) {
+      byteCount = buffer.size
+      buffer.clear()
+    }
+
+    return byteCount
+  }
+
+  class Builder @JvmOverloads constructor(private val charset: Charset? = null) {
+    private val names = mutableListOf<String>()
+    private val values = mutableListOf<String>()
+
+    fun add(name: String, value: String): Builder {
+      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true, charset))
+      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true, charset))
+      return this
+    }
+
+    fun addEncoded(name: String, value: String): Builder {
+      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true, charset))
+      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true, charset))
+      return this
+    }
+
+    fun build(): FormBody = FormBody(names, values)
+  }
+
+  companion object {
+    private val CONTENT_TYPE: MediaType = MediaType.get("application/x-www-form-urlencoded")
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Handshake.java b/okhttp/src/main/java/okhttp3/Handshake.java
deleted file mode 100644
index 59a5418b86..0000000000
--- a/okhttp/src/main/java/okhttp3/Handshake.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.Collections;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import okhttp3.internal.Util;
-
-/**
- * A record of a TLS handshake. For HTTPS clients, the client is <i>local</i> and the remote server
- * is its <i>peer</i>.
- *
- * <p>This value object describes a completed handshake. Use {@link ConnectionSpec} to set policy
- * for new handshakes.
- */
-public final class Handshake {
-  private final TlsVersion tlsVersion;
-  private final CipherSuite cipherSuite;
-  private final List<Certificate> peerCertificates;
-  private final List<Certificate> localCertificates;
-
-  private Handshake(TlsVersion tlsVersion, CipherSuite cipherSuite,
-      List<Certificate> peerCertificates, List<Certificate> localCertificates) {
-    this.tlsVersion = tlsVersion;
-    this.cipherSuite = cipherSuite;
-    this.peerCertificates = peerCertificates;
-    this.localCertificates = localCertificates;
-  }
-
-  public static Handshake get(SSLSession session) {
-    String cipherSuiteString = session.getCipherSuite();
-    if (cipherSuiteString == null) throw new IllegalStateException("cipherSuite == null");
-    CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-
-    String tlsVersionString = session.getProtocol();
-    if (tlsVersionString == null) throw new IllegalStateException("tlsVersion == null");
-    TlsVersion tlsVersion = TlsVersion.forJavaName(tlsVersionString);
-
-    Certificate[] peerCertificates;
-    try {
-      peerCertificates = session.getPeerCertificates();
-    } catch (SSLPeerUnverifiedException ignored) {
-      peerCertificates = null;
-    }
-    List<Certificate> peerCertificatesList = peerCertificates != null
-        ? Util.immutableList(peerCertificates)
-        : Collections.<Certificate>emptyList();
-
-    Certificate[] localCertificates = session.getLocalCertificates();
-    List<Certificate> localCertificatesList = localCertificates != null
-        ? Util.immutableList(localCertificates)
-        : Collections.<Certificate>emptyList();
-
-    return new Handshake(tlsVersion, cipherSuite, peerCertificatesList, localCertificatesList);
-  }
-
-  public static Handshake get(TlsVersion tlsVersion, CipherSuite cipherSuite,
-      List<Certificate> peerCertificates, List<Certificate> localCertificates) {
-    if (tlsVersion == null) throw new NullPointerException("tlsVersion == null");
-    if (cipherSuite == null) throw new NullPointerException("cipherSuite == null");
-    return new Handshake(tlsVersion, cipherSuite, Util.immutableList(peerCertificates),
-        Util.immutableList(localCertificates));
-  }
-
-  /**
-   * Returns the TLS version used for this connection. This value wasn't tracked prior to OkHttp
-   * 3.0. For responses cached by preceding versions this returns {@link TlsVersion#SSL_3_0}.
-   */
-  public TlsVersion tlsVersion() {
-    return tlsVersion;
-  }
-
-  /** Returns the cipher suite used for the connection. */
-  public CipherSuite cipherSuite() {
-    return cipherSuite;
-  }
-
-  /** Returns a possibly-empty list of certificates that identify the remote peer. */
-  public List<Certificate> peerCertificates() {
-    return peerCertificates;
-  }
-
-  /** Returns the remote peer's principle, or null if that peer is anonymous. */
-  public @Nullable Principal peerPrincipal() {
-    return !peerCertificates.isEmpty()
-        ? ((X509Certificate) peerCertificates.get(0)).getSubjectX500Principal()
-        : null;
-  }
-
-  /** Returns a possibly-empty list of certificates that identify this peer. */
-  public List<Certificate> localCertificates() {
-    return localCertificates;
-  }
-
-  /** Returns the local principle, or null if this peer is anonymous. */
-  public @Nullable Principal localPrincipal() {
-    return !localCertificates.isEmpty()
-        ? ((X509Certificate) localCertificates.get(0)).getSubjectX500Principal()
-        : null;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    if (!(other instanceof Handshake)) return false;
-    Handshake that = (Handshake) other;
-    return tlsVersion.equals(that.tlsVersion)
-        && cipherSuite.equals(that.cipherSuite)
-        && peerCertificates.equals(that.peerCertificates)
-        && localCertificates.equals(that.localCertificates);
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + tlsVersion.hashCode();
-    result = 31 * result + cipherSuite.hashCode();
-    result = 31 * result + peerCertificates.hashCode();
-    result = 31 * result + localCertificates.hashCode();
-    return result;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Handshake.kt b/okhttp/src/main/java/okhttp3/Handshake.kt
new file mode 100644
index 0000000000..ec6bed624b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Handshake.kt
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.Util
+import java.io.IOException
+import java.security.Principal
+import java.security.cert.Certificate
+import java.security.cert.X509Certificate
+import javax.net.ssl.SSLPeerUnverifiedException
+import javax.net.ssl.SSLSession
+
+/**
+ * A record of a TLS handshake. For HTTPS clients, the client is *local* and the remote server
+ * is its *peer*.
+ *
+ * This value object describes a completed handshake. Use [ConnectionSpec] to set policy
+ * for new handshakes.
+ */
+data class Handshake private constructor(
+  private val tlsVersion: TlsVersion,
+  private val cipherSuite: CipherSuite,
+  private val peerCertificates: List<Certificate>,
+  private val localCertificates: List<Certificate>
+) {
+
+  /**
+   * Returns the TLS version used for this connection. This value wasn't tracked prior to OkHttp
+   * 3.0. For responses cached by preceding versions this returns [TlsVersion.SSL_3_0].
+   */
+  fun tlsVersion() = tlsVersion
+
+  /** Returns the cipher suite used for the connection. */
+  fun cipherSuite() = cipherSuite
+
+  /** Returns a possibly-empty list of certificates that identify the remote peer. */
+  fun peerCertificates() = peerCertificates
+
+  /** Returns the remote peer's principle, or null if that peer is anonymous. */
+  fun peerPrincipal(): Principal? {
+    return if (peerCertificates.isNotEmpty()) {
+      (peerCertificates[0] as X509Certificate).subjectX500Principal
+    } else {
+      null
+    }
+  }
+
+  /** Returns a possibly-empty list of certificates that identify this peer. */
+  fun localCertificates() = localCertificates
+
+  /** Returns the local principle, or null if this peer is anonymous. */
+  fun localPrincipal(): Principal? {
+    return if (localCertificates.isNotEmpty()) {
+      (localCertificates[0] as X509Certificate).subjectX500Principal
+    } else {
+      null
+    }
+  }
+
+  override fun toString(): String {
+    return "Handshake{" +
+        "tlsVersion=" +
+        tlsVersion +
+        " cipherSuite=" +
+        cipherSuite +
+        " peerCertificates=" +
+        names(peerCertificates) +
+        " localCertificates=" +
+        names(localCertificates) +
+        "}"
+  }
+
+  private fun names(certificates: List<Certificate>): List<String> {
+    return certificates
+        .map {
+          if (it is X509Certificate) {
+            it.subjectDN.toString()
+          } else {
+            it.type
+          }
+        }
+  }
+
+  companion object {
+    @Throws(IOException::class)
+    @JvmStatic
+    fun get(session: SSLSession): Handshake {
+      val cipherSuiteString = session.cipherSuite ?: throw IllegalStateException("cipherSuite == null")
+      if ("SSL_NULL_WITH_NULL_NULL" == cipherSuiteString) {
+        throw IOException("cipherSuite == SSL_NULL_WITH_NULL_NULL")
+      }
+      val cipherSuite = CipherSuite.forJavaName(cipherSuiteString)
+
+      val tlsVersionString = session.protocol ?: throw IllegalStateException("tlsVersion == null")
+      if ("NONE" == tlsVersionString) throw IOException("tlsVersion == NONE")
+      val tlsVersion = TlsVersion.forJavaName(tlsVersionString)
+
+      val peerCertificates: Array<Certificate>? = try {
+        session.peerCertificates
+      } catch (ignored: SSLPeerUnverifiedException) {
+        null
+      }
+
+      val peerCertificatesList = if (peerCertificates != null) {
+        Util.immutableList(*peerCertificates)
+      } else {
+        emptyList()
+      }
+
+      val localCertificates = session.localCertificates
+      val localCertificatesList = if (localCertificates != null) {
+        Util.immutableList(*localCertificates)
+      } else {
+        emptyList()
+      }
+
+      return Handshake(tlsVersion, cipherSuite, peerCertificatesList, localCertificatesList)
+    }
+
+    @JvmStatic
+    fun get(tlsVersion: TlsVersion, cipherSuite: CipherSuite,
+            peerCertificates: List<Certificate>, localCertificates: List<Certificate>): Handshake {
+      return Handshake(tlsVersion, cipherSuite, Util.immutableList(peerCertificates),
+          Util.immutableList(localCertificates))
+    }
+  }
+}
\ No newline at end of file
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
deleted file mode 100644
index d5ef33aa70..0000000000
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ /dev/null
@@ -1,358 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeMap;
-import java.util.TreeSet;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpDate;
-
-/**
- * The header fields of a single HTTP message. Values are uninterpreted strings; use {@code Request}
- * and {@code Response} for interpreted headers. This class maintains the order of the header fields
- * within the HTTP message.
- *
- * <p>This class tracks header values line-by-line. A field with multiple comma- separated values on
- * the same line will be treated as a field with a single value by this class. It is the caller's
- * responsibility to detect and split on commas if their field permits multiple values. This
- * simplifies use of single-valued fields whose values routinely contain commas, such as cookies or
- * dates.
- *
- * <p>This class trims whitespace from values. It never returns values with leading or trailing
- * whitespace.
- *
- * <p>Instances of this class are immutable. Use {@link Builder} to create instances.
- */
-public final class Headers {
-  private final String[] namesAndValues;
-
-  Headers(Builder builder) {
-    this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
-  }
-
-  private Headers(String[] namesAndValues) {
-    this.namesAndValues = namesAndValues;
-  }
-
-  /** Returns the last value corresponding to the specified field, or null. */
-  public @Nullable String get(String name) {
-    return get(namesAndValues, name);
-  }
-
-  /**
-   * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
-   * either the field is absent or cannot be parsed as a date.
-   */
-  public @Nullable Date getDate(String name) {
-    String value = get(name);
-    return value != null ? HttpDate.parse(value) : null;
-  }
-
-  /** Returns the number of field values. */
-  public int size() {
-    return namesAndValues.length / 2;
-  }
-
-  /** Returns the field at {@code position}. */
-  public String name(int index) {
-    return namesAndValues[index * 2];
-  }
-
-  /** Returns the value at {@code index}. */
-  public String value(int index) {
-    return namesAndValues[index * 2 + 1];
-  }
-
-  /** Returns an immutable case-insensitive set of header names. */
-  public Set<String> names() {
-    TreeSet<String> result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
-    for (int i = 0, size = size(); i < size; i++) {
-      result.add(name(i));
-    }
-    return Collections.unmodifiableSet(result);
-  }
-
-  /** Returns an immutable list of the header values for {@code name}. */
-  public List<String> values(String name) {
-    List<String> result = null;
-    for (int i = 0, size = size(); i < size; i++) {
-      if (name.equalsIgnoreCase(name(i))) {
-        if (result == null) result = new ArrayList<>(2);
-        result.add(value(i));
-      }
-    }
-    return result != null
-        ? Collections.unmodifiableList(result)
-        : Collections.<String>emptyList();
-  }
-
-  /**
-   * Returns the number of bytes required to encode these headers using HTTP/1.1. This is also the
-   * approximate size of HTTP/2 headers before they are compressed with HPACK. This value is
-   * intended to be used as a metric: smaller headers are more efficient to encode and transmit.
-   */
-  public long byteCount() {
-    // Each header name has 2 bytes of overhead for ': ' and every header value has 2 bytes of
-    // overhead for '\r\n'.
-    long result = namesAndValues.length * 2;
-
-    for (int i = 0, size = namesAndValues.length; i < size; i++) {
-      result += namesAndValues[i].length();
-    }
-
-    return result;
-  }
-
-  public Builder newBuilder() {
-    Builder result = new Builder();
-    Collections.addAll(result.namesAndValues, namesAndValues);
-    return result;
-  }
-
-  /**
-   * Returns true if {@code other} is a {@code Headers} object with the same headers, with the same
-   * casing, in the same order. Note that two headers instances may be <i>semantically</i> equal
-   * but not equal according to this method. In particular, none of the following sets of headers
-   * are equal according to this method: <pre>   {@code
-   *
-   *   1. Original
-   *   Content-Type: text/html
-   *   Content-Length: 50
-   *
-   *   2. Different order
-   *   Content-Length: 50
-   *   Content-Type: text/html
-   *
-   *   3. Different case
-   *   content-type: text/html
-   *   content-length: 50
-   *
-   *   4. Different values
-   *   Content-Type: text/html
-   *   Content-Length: 050
-   * }</pre>
-   *
-   * Applications that require semantically equal headers should convert them into a canonical form
-   * before comparing them for equality.
-   */
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof Headers
-        && Arrays.equals(((Headers) other).namesAndValues, namesAndValues);
-  }
-
-  @Override public int hashCode() {
-    return Arrays.hashCode(namesAndValues);
-  }
-
-  @Override public String toString() {
-    StringBuilder result = new StringBuilder();
-    for (int i = 0, size = size(); i < size; i++) {
-      result.append(name(i)).append(": ").append(value(i)).append("\n");
-    }
-    return result.toString();
-  }
-
-  public Map<String, List<String>> toMultimap() {
-    Map<String, List<String>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
-    for (int i = 0, size = size(); i < size; i++) {
-      String name = name(i).toLowerCase(Locale.US);
-      List<String> values = result.get(name);
-      if (values == null) {
-        values = new ArrayList<>(2);
-        result.put(name, values);
-      }
-      values.add(value(i));
-    }
-    return result;
-  }
-
-  private static String get(String[] namesAndValues, String name) {
-    for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
-      if (name.equalsIgnoreCase(namesAndValues[i])) {
-        return namesAndValues[i + 1];
-      }
-    }
-    return null;
-  }
-
-  /**
-   * Returns headers for the alternating header names and values. There must be an even number of
-   * arguments, and they must alternate between header names and values.
-   */
-  public static Headers of(String... namesAndValues) {
-    if (namesAndValues == null) throw new NullPointerException("namesAndValues == null");
-    if (namesAndValues.length % 2 != 0) {
-      throw new IllegalArgumentException("Expected alternating header names and values");
-    }
-
-    // Make a defensive copy and clean it up.
-    namesAndValues = namesAndValues.clone();
-    for (int i = 0; i < namesAndValues.length; i++) {
-      if (namesAndValues[i] == null) throw new IllegalArgumentException("Headers cannot be null");
-      namesAndValues[i] = namesAndValues[i].trim();
-    }
-
-    // Check for malformed headers.
-    for (int i = 0; i < namesAndValues.length; i += 2) {
-      String name = namesAndValues[i];
-      String value = namesAndValues[i + 1];
-      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
-      }
-    }
-
-    return new Headers(namesAndValues);
-  }
-
-  /**
-   * Returns headers for the header names and values in the {@link Map}.
-   */
-  public static Headers of(Map<String, String> headers) {
-    if (headers == null) throw new NullPointerException("headers == null");
-
-    // Make a defensive copy and clean it up.
-    String[] namesAndValues = new String[headers.size() * 2];
-    int i = 0;
-    for (Map.Entry<String, String> header : headers.entrySet()) {
-      if (header.getKey() == null || header.getValue() == null) {
-        throw new IllegalArgumentException("Headers cannot be null");
-      }
-      String name = header.getKey().trim();
-      String value = header.getValue().trim();
-      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
-      }
-      namesAndValues[i] = name;
-      namesAndValues[i + 1] = value;
-      i += 2;
-    }
-
-    return new Headers(namesAndValues);
-  }
-
-  public static final class Builder {
-    final List<String> namesAndValues = new ArrayList<>(20);
-
-    /**
-     * Add a header line without any validation. Only appropriate for headers from the remote peer
-     * or cache.
-     */
-    Builder addLenient(String line) {
-      int index = line.indexOf(":", 1);
-      if (index != -1) {
-        return addLenient(line.substring(0, index), line.substring(index + 1));
-      } else if (line.startsWith(":")) {
-        // Work around empty header names and header names that start with a
-        // colon (created by old broken SPDY versions of the response cache).
-        return addLenient("", line.substring(1)); // Empty header name.
-      } else {
-        return addLenient("", line); // No header name.
-      }
-    }
-
-    /** Add an header line containing a field name, a literal colon, and a value. */
-    public Builder add(String line) {
-      int index = line.indexOf(":");
-      if (index == -1) {
-        throw new IllegalArgumentException("Unexpected header: " + line);
-      }
-      return add(line.substring(0, index).trim(), line.substring(index + 1));
-    }
-
-    /** Add a field with the specified value. */
-    public Builder add(String name, String value) {
-      checkNameAndValue(name, value);
-      return addLenient(name, value);
-    }
-
-    /**
-     * Add a field with the specified value without any validation. Only appropriate for headers
-     * from the remote peer or cache.
-     */
-    Builder addLenient(String name, String value) {
-      namesAndValues.add(name);
-      namesAndValues.add(value.trim());
-      return this;
-    }
-
-    public Builder removeAll(String name) {
-      for (int i = 0; i < namesAndValues.size(); i += 2) {
-        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
-          namesAndValues.remove(i); // name
-          namesAndValues.remove(i); // value
-          i -= 2;
-        }
-      }
-      return this;
-    }
-
-    /**
-     * Set a field with the specified value. If the field is not found, it is added. If the field is
-     * found, the existing values are replaced.
-     */
-    public Builder set(String name, String value) {
-      checkNameAndValue(name, value);
-      removeAll(name);
-      addLenient(name, value);
-      return this;
-    }
-
-    private void checkNameAndValue(String name, String value) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (name.isEmpty()) throw new IllegalArgumentException("name is empty");
-      for (int i = 0, length = name.length(); i < length; i++) {
-        char c = name.charAt(i);
-        if (c <= '\u0020' || c >= '\u007f') {
-          throw new IllegalArgumentException(Util.format(
-              "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
-        }
-      }
-      if (value == null) throw new NullPointerException("value for name " + name + " == null");
-      for (int i = 0, length = value.length(); i < length; i++) {
-        char c = value.charAt(i);
-        if ((c <= '\u001f' && c != '\t') || c >= '\u007f') {
-          throw new IllegalArgumentException(Util.format(
-              "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
-        }
-      }
-    }
-
-    /** Equivalent to {@code build().get(name)}, but potentially faster. */
-    public String get(String name) {
-      for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
-        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
-          return namesAndValues.get(i + 1);
-        }
-      }
-      return null;
-    }
-
-    public Headers build() {
-      return new Headers(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Headers.kt b/okhttp/src/main/java/okhttp3/Headers.kt
new file mode 100644
index 0000000000..3251d771ab
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Headers.kt
@@ -0,0 +1,410 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package okhttp3
+
+import okhttp3.Headers.Builder
+import okhttp3.internal.Util
+import okhttp3.internal.http.HttpDate
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
+import java.time.Instant
+import java.util.ArrayList
+import java.util.Arrays
+import java.util.Collections
+import java.util.Date
+import java.util.Locale
+import java.util.TreeMap
+import java.util.TreeSet
+
+/**
+ * The header fields of a single HTTP message. Values are uninterpreted strings; use `Request` and
+ * `Response` for interpreted headers. This class maintains the order of the header fields within
+ * the HTTP message.
+ *
+ * This class tracks header values line-by-line. A field with multiple comma- separated values on
+ * the same line will be treated as a field with a single value by this class. It is the caller's
+ * responsibility to detect and split on commas if their field permits multiple values. This
+ * simplifies use of single-valued fields whose values routinely contain commas, such as cookies or
+ * dates.
+ *
+ * This class trims whitespace from values. It never returns values with leading or trailing
+ * whitespace.
+ *
+ * Instances of this class are immutable. Use [Builder] to create instances.
+ */
+class Headers private constructor(
+  private val namesAndValues: Array<String>
+) {
+  /** Returns the last value corresponding to the specified field, or null. */
+  operator fun get(name: String): String? = get(namesAndValues, name)
+
+  /**
+   * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
+   * either the field is absent or cannot be parsed as a date.
+   */
+  fun getDate(name: String): Date? {
+    val value = get(name)
+    return if (value != null) HttpDate.parse(value) else null
+  }
+
+  /**
+   * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
+   * either the field is absent or cannot be parsed as a date.
+   */
+  @IgnoreJRERequirement
+  fun getInstant(name: String): Instant? {
+    val value = getDate(name)
+    return value?.toInstant()
+  }
+
+  /** Returns the number of field values.  */
+  fun size(): Int = namesAndValues.size / 2
+
+  /** Returns the field at `position`.  */
+  fun name(index: Int): String = namesAndValues[index * 2]
+
+  /** Returns the value at `index`.  */
+  fun value(index: Int): String = namesAndValues[index * 2 + 1]
+
+  /** Returns an immutable case-insensitive set of header names.  */
+  fun names(): Set<String> {
+    val result = TreeSet(String.CASE_INSENSITIVE_ORDER)
+    for (i in 0 until size()) {
+      result.add(name(i))
+    }
+    return Collections.unmodifiableSet(result)
+  }
+
+  /** Returns an immutable list of the header values for `name`.  */
+  fun values(name: String): List<String> {
+    var result: MutableList<String>? = null
+    for (i in 0 until size()) {
+      if (name.equals(name(i), ignoreCase = true)) {
+        if (result == null) result = ArrayList(2)
+        result.add(value(i))
+      }
+    }
+    return if (result != null) {
+      Collections.unmodifiableList(result)
+    } else {
+      emptyList()
+    }
+  }
+
+  /**
+   * Returns the number of bytes required to encode these headers using HTTP/1.1. This is also the
+   * approximate size of HTTP/2 headers before they are compressed with HPACK. This value is
+   * intended to be used as a metric: smaller headers are more efficient to encode and transmit.
+   */
+  fun byteCount(): Long {
+    // Each header name has 2 bytes of overhead for ': ' and every header value has 2 bytes of
+    // overhead for '\r\n'.
+    var result = (namesAndValues.size * 2).toLong()
+
+    for (i in 0 until namesAndValues.size) {
+      result += namesAndValues[i].length.toLong()
+    }
+
+    return result
+  }
+
+  fun newBuilder(): Builder {
+    val result = Builder()
+    Collections.addAll(result.namesAndValues, *namesAndValues)
+    return result
+  }
+
+  /**
+   * Returns true if `other` is a `Headers` object with the same headers, with the same casing, in
+   * the same order. Note that two headers instances may be *semantically* equal but not equal
+   * according to this method. In particular, none of the following sets of headers are equal
+   * according to this method:
+   *
+   * 1. Original
+   * ```
+   * Content-Type: text/html
+   * Content-Length: 50
+   * ```
+   *
+   * 2. Different order
+   *
+   * ```
+   * Content-Length: 50
+   * Content-Type: text/html
+   * ```
+   *
+   * 3. Different case
+   *
+   * ```
+   * content-type: text/html
+   * content-length: 50
+   * ```
+   *
+   * 4. Different values
+   *
+   * ```
+   * Content-Type: text/html
+   * Content-Length: 050
+   * ```
+   *
+   * Applications that require semantically equal headers should convert them into a canonical form
+   * before comparing them for equality.
+   */
+  override fun equals(other: Any?): Boolean {
+    return other is Headers && Arrays.equals(other.namesAndValues, namesAndValues)
+  }
+
+  override fun hashCode(): Int = Arrays.hashCode(namesAndValues)
+
+  override fun toString(): String {
+    return buildString {
+      for (i in 0 until size()) {
+        append(name(i))
+        append(": ")
+        append(value(i))
+        append("\n")
+      }
+    }
+  }
+
+  fun toMultimap(): Map<String, List<String>> {
+    val result = TreeMap<String, MutableList<String>>(String.CASE_INSENSITIVE_ORDER)
+    for (i in 0 until size()) {
+      val name = name(i).toLowerCase(Locale.US)
+      var values: MutableList<String>? = result[name]
+      if (values == null) {
+        values = ArrayList(2)
+        result[name] = values
+      }
+      values.add(value(i))
+    }
+    return result
+  }
+
+  class Builder {
+    internal val namesAndValues: MutableList<String> = ArrayList(20)
+
+    /**
+     * Add a header line without any validation. Only appropriate for headers from the remote peer
+     * or cache.
+     */
+    internal fun addLenient(line: String): Builder {
+      val index = line.indexOf(":", 1)
+      return when {
+        index != -1 -> {
+          addLenient(line.substring(0, index), line.substring(index + 1))
+        }
+        line.startsWith(":") -> {
+          // Work around empty header names and header names that start with a
+          // colon (created by old broken SPDY versions of the response cache).
+          addLenient("", line.substring(1)) // Empty header name.
+        }
+        else -> {
+          // No header name.
+          addLenient("", line)
+        }
+      }
+    }
+
+    /** Add an header line containing a field name, a literal colon, and a value. */
+    fun add(line: String): Builder {
+      val index = line.indexOf(":")
+      require(index != -1) { "Unexpected header: $line" }
+      return add(line.substring(0, index).trim { it <= ' ' }, line.substring(index + 1))
+    }
+
+    /**
+     * Add a header with the specified name and value. Does validation of header names and values.
+     */
+    fun add(name: String, value: String): Builder {
+      checkName(name)
+      checkValue(value, name)
+      return addLenient(name, value)
+    }
+
+    /**
+     * Add a header with the specified name and value. Does validation of header names, allowing
+     * non-ASCII values.
+     */
+    fun addUnsafeNonAscii(name: String, value: String): Builder {
+      checkName(name)
+      return addLenient(name, value)
+    }
+
+    /**
+     * Adds all headers from an existing collection.
+     */
+    fun addAll(headers: Headers) = apply {
+      for (i in 0 until headers.size()) {
+        addLenient(headers.name(i), headers.value(i))
+      }
+    }
+
+    /**
+     * Add a header with the specified name and formatted date. Does validation of header names and
+     * value.
+     */
+    fun add(name: String, value: Date) = apply {
+      add(name, HttpDate.format(value))
+    }
+
+    /**
+     * Add a header with the specified name and formatted instant. Does validation of header names
+     * and value.
+     */
+    @IgnoreJRERequirement
+    fun add(name: String, value: Instant): Builder {
+      return add(name, Date(value.toEpochMilli()))
+    }
+
+    /**
+     * Set a field with the specified date. If the field is not found, it is added. If the field is
+     * found, the existing values are replaced.
+     */
+    operator fun set(name: String, value: Date) = apply {
+      set(name, HttpDate.format(value))
+    }
+
+    /**
+     * Set a field with the specified instant. If the field is not found, it is added. If the field
+     * is found, the existing values are replaced.
+     */
+    @IgnoreJRERequirement
+    operator fun set(name: String, value: Instant) = apply {
+      return set(name, Date(value.toEpochMilli()))
+    }
+
+    /**
+     * Add a field with the specified value without any validation. Only appropriate for headers
+     * from the remote peer or cache.
+     */
+    internal fun addLenient(name: String, value: String) = apply {
+      namesAndValues.add(name)
+      namesAndValues.add(value.trim { it <= ' ' })
+    }
+
+    fun removeAll(name: String) = apply {
+      var i = 0
+      while (i < namesAndValues.size) {
+        if (name.equals(namesAndValues[i], ignoreCase = true)) {
+          namesAndValues.removeAt(i) // name
+          namesAndValues.removeAt(i) // value
+          i -= 2
+        }
+        i += 2
+      }
+    }
+
+    /**
+     * Set a field with the specified value. If the field is not found, it is added. If the field is
+     * found, the existing values are replaced.
+     */
+    operator fun set(name: String, value: String) = apply {
+      checkName(name)
+      checkValue(value, name)
+      removeAll(name)
+      addLenient(name, value)
+    }
+
+    /** Equivalent to `build().get(name)`, but potentially faster.  */
+    operator fun get(name: String): String? {
+      for (i in namesAndValues.size - 2 downTo 0 step 2) {
+        if (name.equals(namesAndValues[i], ignoreCase = true)) {
+          return namesAndValues[i + 1]
+        }
+      }
+      return null
+    }
+
+    fun build(): Headers = Headers(namesAndValues.toTypedArray())
+  }
+
+  companion object {
+    private fun get(namesAndValues: Array<String>, name: String): String? {
+      for (i in namesAndValues.size - 2 downTo 0 step 2) {
+        if (name.equals(namesAndValues[i], ignoreCase = true)) {
+          return namesAndValues[i + 1]
+        }
+      }
+      return null
+    }
+
+    /**
+     * Returns headers for the alternating header names and values. There must be an even number of
+     * arguments, and they must alternate between header names and values.
+     */
+    @JvmStatic
+    fun of(vararg namesAndValues: String): Headers {
+      require(namesAndValues.size % 2 == 0) { "Expected alternating header names and values" }
+
+      // Make a defensive copy and clean it up.
+      val namesAndValues: Array<String> = namesAndValues.clone() as Array<String>
+      for (i in namesAndValues.indices) {
+        require(namesAndValues[i] != null) { "Headers cannot be null" }
+        namesAndValues[i] = namesAndValues[i].trim { it <= ' ' }
+      }
+
+      // Check for malformed headers.
+      for (i in 0 until namesAndValues.size step 2) {
+        val name = namesAndValues[i]
+        val value = namesAndValues[i + 1]
+        checkName(name)
+        checkValue(value, name)
+      }
+
+      return Headers(namesAndValues)
+    }
+
+    /** Returns headers for the header names and values in the [Map]. */
+    @JvmStatic
+    fun of(headers: Map<String, String>): Headers {
+      // Make a defensive copy and clean it up.
+      val namesAndValues = arrayOfNulls<String>(headers.size * 2)
+      var i = 0
+      for ((key, value1) in headers) {
+        val name = key.trim { it <= ' ' }
+        val value = value1.trim { it <= ' ' }
+        checkName(name)
+        checkValue(value, name)
+        namesAndValues[i] = name
+        namesAndValues[i + 1] = value
+        i += 2
+      }
+
+      return Headers(namesAndValues as Array<String>)
+    }
+
+    internal fun checkName(name: String) {
+      require(name.isNotEmpty()) { "name is empty" }
+      for (i in 0 until name.length) {
+        val c = name[i]
+        require(c in '\u0021'..'\u007e') {
+          Util.format("Unexpected char %#04x at %d in header name: %s", c.toInt(), i, name)
+        }
+      }
+    }
+
+    internal fun checkValue(value: String, name: String) {
+      for (i in 0 until value.length) {
+        val c = value[i]
+        require(c == '\t' || c in '\u0020'..'\u007e') {
+          Util.format("Unexpected char %#04x at %d in %s value: %s", c.toInt(), i, name, value)
+        }
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
deleted file mode 100644
index a4a6b428f1..0000000000
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ /dev/null
@@ -1,1761 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.InetAddress;
-import java.net.MalformedURLException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.net.UnknownHostException;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
-import okio.Buffer;
-
-import static okhttp3.internal.Util.decodeHexDigit;
-import static okhttp3.internal.Util.delimiterOffset;
-import static okhttp3.internal.Util.skipLeadingAsciiWhitespace;
-import static okhttp3.internal.Util.skipTrailingAsciiWhitespace;
-import static okhttp3.internal.Util.verifyAsIpAddress;
-
-/**
- * A uniform resource locator (URL) with a scheme of either {@code http} or {@code https}. Use this
- * class to compose and decompose Internet addresses. For example, this code will compose and print
- * a URL for Google search: <pre>   {@code
- *
- *   HttpUrl url = new HttpUrl.Builder()
- *       .scheme("https")
- *       .host("www.google.com")
- *       .addPathSegment("search")
- *       .addQueryParameter("q", "polar bears")
- *       .build();
- *   System.out.println(url);
- * }</pre>
- *
- * which prints: <pre>   {@code
- *
- *     https://www.google.com/search?q=polar%20bears
- * }</pre>
- *
- * As another example, this code prints the human-readable query parameters of a Twitter search:
- * <pre>   {@code
- *
- *   HttpUrl url = HttpUrl.parse("https://twitter.com/search?q=cute%20%23puppies&f=images");
- *   for (int i = 0, size = url.querySize(); i < size; i++) {
- *     System.out.println(url.queryParameterName(i) + ": " + url.queryParameterValue(i));
- *   }
- * }</pre>
- *
- * which prints: <pre>   {@code
- *
- *   q: cute #puppies
- *   f: images
- * }</pre>
- *
- * In addition to composing URLs from their component parts and decomposing URLs into their
- * component parts, this class implements relative URL resolution: what address you'd reach by
- * clicking a relative link on a specified page. For example: <pre>   {@code
- *
- *   HttpUrl base = HttpUrl.parse("https://www.youtube.com/user/WatchTheDaily/videos");
- *   HttpUrl link = base.resolve("../../watch?v=cbP2N1BQdYc");
- *   System.out.println(link);
- * }</pre>
- *
- * which prints: <pre>   {@code
- *
- *   https://www.youtube.com/watch?v=cbP2N1BQdYc
- * }</pre>
- *
- * <h3>What's in a URL?</h3>
- *
- * A URL has several components.
- *
- * <h4>Scheme</h4>
- *
- * <p>Sometimes referred to as <i>protocol</i>, A URL's scheme describes what mechanism should be
- * used to retrieve the resource. Although URLs have many schemes ({@code mailto}, {@code file},
- * {@code ftp}), this class only supports {@code http} and {@code https}. Use {@link URI
- * java.net.URI} for URLs with arbitrary schemes.
- *
- * <h4>Username and Password</h4>
- *
- * <p>Username and password are either present, or the empty string {@code ""} if absent. This class
- * offers no mechanism to differentiate empty from absent. Neither of these components are popular
- * in practice. Typically HTTP applications use other mechanisms for user identification and
- * authentication.
- *
- * <h4>Host</h4>
- *
- * <p>The host identifies the webserver that serves the URL's resource. It is either a hostname like
- * {@code square.com} or {@code localhost}, an IPv4 address like {@code 192.168.0.1}, or an IPv6
- * address like {@code ::1}.
- *
- * <p>Usually a webserver is reachable with multiple identifiers: its IP addresses, registered
- * domain names, and even {@code localhost} when connecting from the server itself. Each of a
- * webserver's names is a distinct URL and they are not interchangeable. For example, even if {@code
- * http://square.github.io/dagger} and {@code http://google.github.io/dagger} are served by the same
- * IP address, the two URLs identify different resources.
- *
- * <h4>Port</h4>
- *
- * <p>The port used to connect to the webserver. By default this is 80 for HTTP and 443 for HTTPS.
- * This class never returns -1 for the port: if no port is explicitly specified in the URL then the
- * scheme's default is used.
- *
- * <h4>Path</h4>
- *
- * <p>The path identifies a specific resource on the host. Paths have a hierarchical structure like
- * "/square/okhttp/issues/1486" and decompose into a list of segments like ["square", "okhttp",
- * "issues", "1486"].
- *
- * <p>This class offers methods to compose and decompose paths by segment. It composes each path
- * from a list of segments by alternating between "/" and the encoded segment. For example the
- * segments ["a", "b"] build "/a/b" and the segments ["a", "b", ""] build "/a/b/".
- *
- * <p>If a path's last segment is the empty string then the path ends with "/". This class always
- * builds non-empty paths: if the path is omitted it defaults to "/". The default path's segment
- * list is a single empty string: [""].
- *
- * <h4>Query</h4>
- *
- * <p>The query is optional: it can be null, empty, or non-empty. For many HTTP URLs the query
- * string is subdivided into a collection of name-value parameters. This class offers methods to set
- * the query as the single string, or as individual name-value parameters. With name-value
- * parameters the values are optional and names may be repeated.
- *
- * <h4>Fragment</h4>
- *
- * <p>The fragment is optional: it can be null, empty, or non-empty. Unlike host, port, path, and
- * query the fragment is not sent to the webserver: it's private to the client.
- *
- * <h3>Encoding</h3>
- *
- * <p>Each component must be encoded before it is embedded in the complete URL. As we saw above, the
- * string {@code cute #puppies} is encoded as {@code cute%20%23puppies} when used as a query
- * parameter value.
- *
- * <h4>Percent encoding</h4>
- *
- * <p>Percent encoding replaces a character (like {@code \ud83c\udf69}) with its UTF-8 hex bytes
- * (like {@code %F0%9F%8D%A9}). This approach works for whitespace characters, control characters,
- * non-ASCII characters, and characters that already have another meaning in a particular context.
- *
- * <p>Percent encoding is used in every URL component except for the hostname. But the set of
- * characters that need to be encoded is different for each component. For example, the path
- * component must escape all of its {@code ?} characters, otherwise it could be interpreted as the
- * start of the URL's query. But within the query and fragment components, the {@code ?} character
- * doesn't delimit anything and doesn't need to be escaped. <pre>   {@code
- *
- *   HttpUrl url = HttpUrl.parse("http://who-let-the-dogs.out").newBuilder()
- *       .addPathSegment("_Who?_")
- *       .query("_Who?_")
- *       .fragment("_Who?_")
- *       .build();
- *   System.out.println(url);
- * }</pre>
- *
- * This prints: <pre>   {@code
- *
- *   http://who-let-the-dogs.out/_Who%3F_?_Who?_#_Who?_
- * }</pre>
- *
- * When parsing URLs that lack percent encoding where it is required, this class will percent encode
- * the offending characters.
- *
- * <h4>IDNA Mapping and Punycode encoding</h4>
- *
- * <p>Hostnames have different requirements and use a different encoding scheme. It consists of IDNA
- * mapping and Punycode encoding.
- *
- * <p>In order to avoid confusion and discourage phishing attacks, <a
- * href="http://www.unicode.org/reports/tr46/#ToASCII">IDNA Mapping</a> transforms names to avoid
- * confusing characters. This includes basic case folding: transforming shouting {@code SQUARE.COM}
- * into cool and casual {@code square.com}. It also handles more exotic characters. For example, the
- * Unicode trademark sign (‚Ñ¢) could be confused for the letters "TM" in {@code http://ho‚Ñ¢mail.com}.
- * To mitigate this, the single character (‚Ñ¢) maps to the string (tm). There is similar policy for
- * all of the 1.1 million Unicode code points. Note that some code points such as "\ud83c\udf69" are
- * not mapped and cannot be used in a hostname.
- *
- * <p><a href="http://ietf.org/rfc/rfc3492.txt">Punycode</a> converts a Unicode string to an ASCII
- * string to make international domain names work everywhere. For example, "œÉ" encodes as "xn--4xa".
- * The encoded string is not human readable, but can be used with classes like {@link InetAddress}
- * to establish connections.
- *
- * <h3>Why another URL model?</h3>
- *
- * <p>Java includes both {@link URL java.net.URL} and {@link URI java.net.URI}. We offer a new URL
- * model to address problems that the others don't.
- *
- * <h4>Different URLs should be different</h4>
- *
- * <p>Although they have different content, {@code java.net.URL} considers the following two URLs
- * equal, and the {@link Object#equals equals()} method between them returns true:
- *
- * <ul>
- *   <li>http://square.github.io/
- *   <li>http://google.github.io/
- * </ul>
- *
- * This is because those two hosts share the same IP address. This is an old, bad design decision
- * that makes {@code java.net.URL} unusable for many things. It shouldn't be used as a {@link
- * java.util.Map Map} key or in a {@link Set}. Doing so is both inefficient because equality may
- * require a DNS lookup, and incorrect because unequal URLs may be equal because of how they are
- * hosted.
- *
- * <h4>Equal URLs should be equal</h4>
- *
- * <p>These two URLs are semantically identical, but {@code java.net.URI} disagrees:
- *
- * <ul>
- *   <li>http://host:80/
- *   <li>http://host
- * </ul>
- *
- * Both the unnecessary port specification ({@code :80}) and the absent trailing slash ({@code /})
- * cause URI to bucket the two URLs separately. This harms URI's usefulness in collections. Any
- * application that stores information-per-URL will need to either canonicalize manually, or suffer
- * unnecessary redundancy for such URLs.
- *
- * <p>Because they don't attempt canonical form, these classes are surprisingly difficult to use
- * securely. Suppose you're building a webservice that checks that incoming paths are prefixed
- * "/static/images/" before serving the corresponding assets from the filesystem. <pre>   {@code
- *
- *   String attack = "http://example.com/static/images/../../../../../etc/passwd";
- *   System.out.println(new URL(attack).getPath());
- *   System.out.println(new URI(attack).getPath());
- *   System.out.println(HttpUrl.parse(attack).encodedPath());
- * }</pre>
- *
- * By canonicalizing the input paths, they are complicit in directory traversal attacks. Code that
- * checks only the path prefix may suffer!
- * <pre>   {@code
- *
- *    /static/images/../../../../../etc/passwd
- *    /static/images/../../../../../etc/passwd
- *    /etc/passwd
- * }</pre>
- *
- * <h4>If it works on the web, it should work in your application</h4>
- *
- * <p>The {@code java.net.URI} class is strict around what URLs it accepts. It rejects URLs like
- * "http://example.com/abc|def" because the '|' character is unsupported. This class is more
- * forgiving: it will automatically percent-encode the '|', yielding "http://example.com/abc%7Cdef".
- * This kind behavior is consistent with web browsers. {@code HttpUrl} prefers consistency with
- * major web browsers over consistency with obsolete specifications.
- *
- * <h4>Paths and Queries should decompose</h4>
- *
- * <p>Neither of the built-in URL models offer direct access to path segments or query parameters.
- * Manually using {@code StringBuilder} to assemble these components is cumbersome: do '+'
- * characters get silently replaced with spaces? If a query parameter contains a '&amp;', does that
- * get escaped? By offering methods to read and write individual query parameters directly,
- * application developers are saved from the hassles of encoding and decoding.
- *
- * <h4>Plus a modern API</h4>
- *
- * <p>The URL (JDK1.0) and URI (Java 1.4) classes predate builders and instead use telescoping
- * constructors. For example, there's no API to compose a URI with a custom port without also
- * providing a query and fragment.
- *
- * <p>Instances of {@link HttpUrl} are well-formed and always have a scheme, host, and path. With
- * {@code java.net.URL} it's possible to create an awkward URL like {@code http:/} with scheme and
- * path but no hostname. Building APIs that consume such malformed values is difficult!
- *
- * <p>This class has a modern API. It avoids punitive checked exceptions: {@link #parse parse()}
- * returns null if the input is an invalid URL. You can even be explicit about whether each
- * component has been encoded already.
- */
-public final class HttpUrl {
-  private static final char[] HEX_DIGITS =
-      {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
-  static final String USERNAME_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
-  static final String PASSWORD_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#";
-  static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
-  static final String PATH_SEGMENT_ENCODE_SET_URI = "[]";
-  static final String QUERY_ENCODE_SET = " \"'<>#";
-  static final String QUERY_COMPONENT_REENCODE_SET = " \"'<>#&=";
-  static final String QUERY_COMPONENT_ENCODE_SET = " !\"#$&'(),/:;<=>?@[]\\^`{|}~";
-  static final String QUERY_COMPONENT_ENCODE_SET_URI = "\\^`{|}";
-  static final String FORM_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#&!$(),~";
-  static final String FRAGMENT_ENCODE_SET = "";
-  static final String FRAGMENT_ENCODE_SET_URI = " \"#<>\\^`{|}";
-
-  /** Either "http" or "https". */
-  final String scheme;
-
-  /** Decoded username. */
-  private final String username;
-
-  /** Decoded password. */
-  private final String password;
-
-  /** Canonical hostname. */
-  final String host;
-
-  /** Either 80, 443 or a user-specified port. In range [1..65535]. */
-  final int port;
-
-  /**
-   * A list of canonical path segments. This list always contains at least one element, which may be
-   * the empty string. Each segment is formatted with a leading '/', so if path segments were ["a",
-   * "b", ""], then the encoded path would be "/a/b/".
-   */
-  private final List<String> pathSegments;
-
-  /**
-   * Alternating, decoded query names and values, or null for no query. Names may be empty or
-   * non-empty, but never null. Values are null if the name has no corresponding '=' separator, or
-   * empty, or non-empty.
-   */
-  private final @Nullable List<String> queryNamesAndValues;
-
-  /** Decoded fragment. */
-  private final @Nullable String fragment;
-
-  /** Canonical URL. */
-  private final String url;
-
-  HttpUrl(Builder builder) {
-    this.scheme = builder.scheme;
-    this.username = percentDecode(builder.encodedUsername, false);
-    this.password = percentDecode(builder.encodedPassword, false);
-    this.host = builder.host;
-    this.port = builder.effectivePort();
-    this.pathSegments = percentDecode(builder.encodedPathSegments, false);
-    this.queryNamesAndValues = builder.encodedQueryNamesAndValues != null
-        ? percentDecode(builder.encodedQueryNamesAndValues, true)
-        : null;
-    this.fragment = builder.encodedFragment != null
-        ? percentDecode(builder.encodedFragment, false)
-        : null;
-    this.url = builder.toString();
-  }
-
-  /** Returns this URL as a {@link URL java.net.URL}. */
-  public URL url() {
-    try {
-      return new URL(url);
-    } catch (MalformedURLException e) {
-      throw new RuntimeException(e); // Unexpected!
-    }
-  }
-
-  /**
-   * Returns this URL as a {@link URI java.net.URI}. Because {@code URI} is more strict than this
-   * class, the returned URI may be semantically different from this URL:
-   *
-   * <ul>
-   *     <li>Characters forbidden by URI like {@code [} and {@code |} will be escaped.
-   *     <li>Invalid percent-encoded sequences like {@code %xx} will be encoded like {@code %25xx}.
-   *     <li>Whitespace and control characters in the fragment will be stripped.
-   * </ul>
-   *
-   * <p>These differences may have a significant consequence when the URI is interpreted by a
-   * webserver. For this reason the {@linkplain URI URI class} and this method should be avoided.
-   */
-  public URI uri() {
-    String uri = newBuilder().reencodeForUri().toString();
-    try {
-      return new URI(uri);
-    } catch (URISyntaxException e) {
-      // Unlikely edge case: the URI has a forbidden character in the fragment. Strip it & retry.
-      try {
-        String stripped = uri.replaceAll("[\\u0000-\\u001F\\u007F-\\u009F\\p{javaWhitespace}]", "");
-        return URI.create(stripped);
-      } catch (Exception e1) {
-        throw new RuntimeException(e); // Unexpected!
-      }
-    }
-  }
-
-  /** Returns either "http" or "https". */
-  public String scheme() {
-    return scheme;
-  }
-
-  public boolean isHttps() {
-    return scheme.equals("https");
-  }
-
-  /**
-   * Returns the username, or an empty string if none is set.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code encodedUsername()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://username@host/}</td><td>{@code "username"}</td></tr>
-   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "username"}</td></tr>
-   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "a%20b"}</td></tr>
-   * </table>
-   */
-  public String encodedUsername() {
-    if (username.isEmpty()) return "";
-    int usernameStart = scheme.length() + 3; // "://".length() == 3.
-    int usernameEnd = delimiterOffset(url, usernameStart, url.length(), ":@");
-    return url.substring(usernameStart, usernameEnd);
-  }
-
-  /**
-   * Returns the decoded username, or an empty string if none is present.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code username()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://username@host/}</td><td>{@code "username"}</td></tr>
-   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "username"}</td></tr>
-   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "a b"}</td></tr>
-   * </table>
-   */
-  public String username() {
-    return username;
-  }
-
-  /**
-   * Returns the password, or an empty string if none is set.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code encodedPassword()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://username@host/}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "password"}</td></tr>
-   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "c%20d"}</td></tr>
-   * </table>
-   */
-  public String encodedPassword() {
-    if (password.isEmpty()) return "";
-    int passwordStart = url.indexOf(':', scheme.length() + 3) + 1;
-    int passwordEnd = url.indexOf('@');
-    return url.substring(passwordStart, passwordEnd);
-  }
-
-  /**
-   * Returns the decoded password, or an empty string if none is present.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code password()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://username@host/}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://username:password@host/}</td><td>{@code "password"}</td></tr>
-   *   <tr><td>{@code http://a%20b:c%20d@host/}</td><td>{@code "c d"}</td></tr>
-   * </table>
-   */
-  public String password() {
-    return password;
-  }
-
-  /**
-   * Returns the host address suitable for use with {@link InetAddress#getAllByName(String)}. May
-   * be:
-   *
-   * <ul>
-   *   <li>A regular host name, like {@code android.com}.
-   *   <li>An IPv4 address, like {@code 127.0.0.1}.
-   *   <li>An IPv6 address, like {@code ::1}. Note that there are no square braces.
-   *   <li>An encoded IDN, like {@code xn--n3h.net}.
-   * </ul>
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code host()}</th></tr>
-   *   <tr><td>{@code http://android.com/}</td><td>{@code "android.com"}</td></tr>
-   *   <tr><td>{@code http://127.0.0.1/}</td><td>{@code "127.0.0.1"}</td></tr>
-   *   <tr><td>{@code http://[::1]/}</td><td>{@code "::1"}</td></tr>
-   *   <tr><td>{@code http://xn--n3h.net/}</td><td>{@code "xn--n3h.net"}</td></tr>
-   * </table>
-   */
-  public String host() {
-    return host;
-  }
-
-  /**
-   * Returns the explicitly-specified port if one was provided, or the default port for this URL's
-   * scheme. For example, this returns 8443 for {@code https://square.com:8443/} and 443 for {@code
-   * https://square.com/}. The result is in {@code [1..65535]}.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code port()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code 80}</td></tr>
-   *   <tr><td>{@code http://host:8000/}</td><td>{@code 8000}</td></tr>
-   *   <tr><td>{@code https://host/}</td><td>{@code 443}</td></tr>
-   * </table>
-   */
-  public int port() {
-    return port;
-  }
-
-  /**
-   * Returns 80 if {@code scheme.equals("http")}, 443 if {@code scheme.equals("https")} and -1
-   * otherwise.
-   */
-  public static int defaultPort(String scheme) {
-    if (scheme.equals("http")) {
-      return 80;
-    } else if (scheme.equals("https")) {
-      return 443;
-    } else {
-      return -1;
-    }
-  }
-
-  /**
-   * Returns the number of segments in this URL's path. This is also the number of slashes in the
-   * URL's path, like 3 in {@code http://host/a/b/c}. This is always at least 1.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code pathSize()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code 1}</td></tr>
-   *   <tr><td>{@code http://host/a/b/c}</td><td>{@code 3}</td></tr>
-   *   <tr><td>{@code http://host/a/b/c/}</td><td>{@code 4}</td></tr>
-   * </table>
-   */
-  public int pathSize() {
-    return pathSegments.size();
-  }
-
-  /**
-   * Returns the entire path of this URL encoded for use in HTTP resource resolution. The returned
-   * path will start with {@code "/"}.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code encodedPath()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code "/"}</td></tr>
-   *   <tr><td>{@code http://host/a/b/c}</td><td>{@code "/a/b/c"}</td></tr>
-   *   <tr><td>{@code http://host/a/b%20c/d}</td><td>{@code "/a/b%20c/d"}</td></tr>
-   * </table>
-   */
-  public String encodedPath() {
-    int pathStart = url.indexOf('/', scheme.length() + 3); // "://".length() == 3.
-    int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
-    return url.substring(pathStart, pathEnd);
-  }
-
-  static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
-    for (int i = 0, size = pathSegments.size(); i < size; i++) {
-      out.append('/');
-      out.append(pathSegments.get(i));
-    }
-  }
-
-  /**
-   * Returns a list of encoded path segments like {@code ["a", "b", "c"]} for the URL {@code
-   * http://host/a/b/c}. This list is never empty though it may contain a single empty string.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code encodedPathSegments()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code [""]}</td></tr>
-   *   <tr><td>{@code http://host/a/b/c}</td><td>{@code ["a", "b", "c"]}</td></tr>
-   *   <tr><td>{@code http://host/a/b%20c/d}</td><td>{@code ["a", "b%20c", "d"]}</td></tr>
-   * </table>
-   */
-  public List<String> encodedPathSegments() {
-    int pathStart = url.indexOf('/', scheme.length() + 3);
-    int pathEnd = delimiterOffset(url, pathStart, url.length(), "?#");
-    List<String> result = new ArrayList<>();
-    for (int i = pathStart; i < pathEnd; ) {
-      i++; // Skip the '/'.
-      int segmentEnd = delimiterOffset(url, i, pathEnd, '/');
-      result.add(url.substring(i, segmentEnd));
-      i = segmentEnd;
-    }
-    return result;
-  }
-
-  /**
-   * Returns a list of path segments like {@code ["a", "b", "c"]} for the URL {@code
-   * http://host/a/b/c}. This list is never empty though it may contain a single empty string.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code pathSegments()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code [""]}</td></tr>
-   *   <tr><td>{@code http://host/a/b/c"}</td><td>{@code ["a", "b", "c"]}</td></tr>
-   *   <tr><td>{@code http://host/a/b%20c/d"}</td><td>{@code ["a", "b c", "d"]}</td></tr>
-   * </table>
-   */
-  public List<String> pathSegments() {
-    return pathSegments;
-  }
-
-  /**
-   * Returns the query of this URL, encoded for use in HTTP resource resolution. The returned string
-   * may be null (for URLs with no query), empty (for URLs with an empty query) or non-empty (all
-   * other URLs).
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code encodedQuery()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
-   *   <tr><td>{@code http://host/?}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code
-   *       "a=apple&k=key+lime"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "a=apple&a=apricot"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a=apple&b"}</td></tr>
-   * </table>
-   */
-  public @Nullable String encodedQuery() {
-    if (queryNamesAndValues == null) return null; // No query.
-    int queryStart = url.indexOf('?') + 1;
-    int queryEnd = delimiterOffset(url, queryStart, url.length(), '#');
-    return url.substring(queryStart, queryEnd);
-  }
-
-  static void namesAndValuesToQueryString(StringBuilder out, List<String> namesAndValues) {
-    for (int i = 0, size = namesAndValues.size(); i < size; i += 2) {
-      String name = namesAndValues.get(i);
-      String value = namesAndValues.get(i + 1);
-      if (i > 0) out.append('&');
-      out.append(name);
-      if (value != null) {
-        out.append('=');
-        out.append(value);
-      }
-    }
-  }
-
-  /**
-   * Cuts {@code encodedQuery} up into alternating parameter names and values. This divides a query
-   * string like {@code subject=math&easy&problem=5-2=3} into the list {@code ["subject", "math",
-   * "easy", null, "problem", "5-2=3"]}. Note that values may be null and may contain '='
-   * characters.
-   */
-  static List<String> queryStringToNamesAndValues(String encodedQuery) {
-    List<String> result = new ArrayList<>();
-    for (int pos = 0; pos <= encodedQuery.length(); ) {
-      int ampersandOffset = encodedQuery.indexOf('&', pos);
-      if (ampersandOffset == -1) ampersandOffset = encodedQuery.length();
-
-      int equalsOffset = encodedQuery.indexOf('=', pos);
-      if (equalsOffset == -1 || equalsOffset > ampersandOffset) {
-        result.add(encodedQuery.substring(pos, ampersandOffset));
-        result.add(null); // No value for this name.
-      } else {
-        result.add(encodedQuery.substring(pos, equalsOffset));
-        result.add(encodedQuery.substring(equalsOffset + 1, ampersandOffset));
-      }
-      pos = ampersandOffset + 1;
-    }
-    return result;
-  }
-
-  /**
-   * Returns this URL's query, like {@code "abc"} for {@code http://host/?abc}. Most callers should
-   * prefer {@link #queryParameterName} and {@link #queryParameterValue} because these methods offer
-   * direct access to individual query parameters.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code query()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
-   *   <tr><td>{@code http://host/?}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "a=apple&k=key
-   *       lime"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "a=apple&a=apricot"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a=apple&b"}</td></tr>
-   * </table>
-   */
-  public @Nullable String query() {
-    if (queryNamesAndValues == null) return null; // No query.
-    StringBuilder result = new StringBuilder();
-    namesAndValuesToQueryString(result, queryNamesAndValues);
-    return result.toString();
-  }
-
-  /**
-   * Returns the number of query parameters in this URL, like 2 for {@code
-   * http://host/?a=apple&b=banana}. If this URL has no query this returns 0. Otherwise it returns
-   * one more than the number of {@code "&"} separators in the query.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code querySize()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code 0}</td></tr>
-   *   <tr><td>{@code http://host/?}</td><td>{@code 1}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code 2}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code 2}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code 2}</td></tr>
-   * </table>
-   */
-  public int querySize() {
-    return queryNamesAndValues != null ? queryNamesAndValues.size() / 2 : 0;
-  }
-
-  /**
-   * Returns the first query parameter named {@code name} decoded using UTF-8, or null if there is
-   * no such query parameter.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code queryParameter("a")}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
-   *   <tr><td>{@code http://host/?}</td><td>null</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "apple"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "apple"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "apple"}</td></tr>
-   * </table>
-   */
-  public @Nullable String queryParameter(String name) {
-    if (queryNamesAndValues == null) return null;
-    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
-      if (name.equals(queryNamesAndValues.get(i))) {
-        return queryNamesAndValues.get(i + 1);
-      }
-    }
-    return null;
-  }
-
-  /**
-   * Returns the distinct query parameter names in this URL, like {@code ["a", "b"]} for {@code
-   * http://host/?a=apple&b=banana}. If this URL has no query this returns the empty set.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code queryParameterNames()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code []}</td></tr>
-   *   <tr><td>{@code http://host/?}</td><td>{@code [""]}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code ["a", "k"]}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code ["a"]}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code ["a", "b"]}</td></tr>
-   * </table>
-   */
-  public Set<String> queryParameterNames() {
-    if (queryNamesAndValues == null) return Collections.emptySet();
-    Set<String> result = new LinkedHashSet<>();
-    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
-      result.add(queryNamesAndValues.get(i));
-    }
-    return Collections.unmodifiableSet(result);
-  }
-
-  /**
-   * Returns all values for the query parameter {@code name} ordered by their appearance in this
-   * URL. For example this returns {@code ["banana"]} for {@code queryParameterValue("b")} on {@code
-   * http://host/?a=apple&b=banana}.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code queryParameterValues("a")}</th><th>{@code
-   *       queryParameterValues("b")}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>{@code []}</td><td>{@code []}</td></tr>
-   *   <tr><td>{@code http://host/?}</td><td>{@code []}</td><td>{@code []}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code ["apple"]}</td><td>{@code
-   *       []}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code ["apple",
-   *       "apricot"]}</td><td>{@code []}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code ["apple"]}</td><td>{@code
-   *       [null]}</td></tr>
-   * </table>
-   */
-  public List<String> queryParameterValues(String name) {
-    if (queryNamesAndValues == null) return Collections.emptyList();
-    List<String> result = new ArrayList<>();
-    for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
-      if (name.equals(queryNamesAndValues.get(i))) {
-        result.add(queryNamesAndValues.get(i + 1));
-      }
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  /**
-   * Returns the name of the query parameter at {@code index}. For example this returns {@code "a"}
-   * for {@code queryParameterName(0)} on {@code http://host/?a=apple&b=banana}. This throws if
-   * {@code index} is not less than the {@linkplain #querySize query size}.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code queryParameterName(0)}</th><th>{@code
-   *       queryParameterName(1)}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>exception</td><td>exception</td></tr>
-   *   <tr><td>{@code http://host/?}</td><td>{@code ""}</td><td>exception</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "a"}</td><td>{@code
-   *       "k"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "a"}</td><td>{@code
-   *       "a"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a"}</td><td>{@code "b"}</td></tr>
-   * </table>
-   */
-  public String queryParameterName(int index) {
-    if (queryNamesAndValues == null) throw new IndexOutOfBoundsException();
-    return queryNamesAndValues.get(index * 2);
-  }
-
-  /**
-   * Returns the value of the query parameter at {@code index}. For example this returns {@code
-   * "apple"} for {@code queryParameterName(0)} on {@code http://host/?a=apple&b=banana}. This
-   * throws if {@code index} is not less than the {@linkplain #querySize query size}.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code queryParameterValue(0)}</th><th>{@code
-   *       queryParameterValue(1)}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>exception</td><td>exception</td></tr>
-   *   <tr><td>{@code http://host/?}</td><td>null</td><td>exception</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&k=key+lime}</td><td>{@code "apple"}</td><td>{@code
-   *       "key lime"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&a=apricot}</td><td>{@code "apple"}</td><td>{@code
-   *       "apricot"}</td></tr>
-   *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "apple"}</td><td>null</td></tr>
-   * </table>
-   */
-  public String queryParameterValue(int index) {
-    if (queryNamesAndValues == null) throw new IndexOutOfBoundsException();
-    return queryNamesAndValues.get(index * 2 + 1);
-  }
-
-  /**
-   * Returns this URL's encoded fragment, like {@code "abc"} for {@code http://host/#abc}. This
-   * returns null if the URL has no fragment.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code encodedFragment()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
-   *   <tr><td>{@code http://host/#}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://host/#abc}</td><td>{@code "abc"}</td></tr>
-   *   <tr><td>{@code http://host/#abc|def}</td><td>{@code "abc|def"}</td></tr>
-   * </table>
-   */
-  public @Nullable String encodedFragment() {
-    if (fragment == null) return null;
-    int fragmentStart = url.indexOf('#') + 1;
-    return url.substring(fragmentStart);
-  }
-
-  /**
-   * Returns this URL's fragment, like {@code "abc"} for {@code http://host/#abc}. This returns null
-   * if the URL has no fragment.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code fragment()}</th></tr>
-   *   <tr><td>{@code http://host/}</td><td>null</td></tr>
-   *   <tr><td>{@code http://host/#}</td><td>{@code ""}</td></tr>
-   *   <tr><td>{@code http://host/#abc}</td><td>{@code "abc"}</td></tr>
-   *   <tr><td>{@code http://host/#abc|def}</td><td>{@code "abc|def"}</td></tr>
-   * </table>
-   */
-  public @Nullable String fragment() {
-    return fragment;
-  }
-
-  /**
-   * Returns a string with containing this URL with its username, password, query, and fragment
-   * stripped, and its path replaced with {@code /...}. For example, redacting {@code
-   * http://username:password@example.com/path} returns {@code http://example.com/...}.
-   */
-  public String redact() {
-    return newBuilder("/...")
-        .username("")
-        .password("")
-        .build()
-        .toString();
-  }
-
-  /**
-   * Returns the URL that would be retrieved by following {@code link} from this URL, or null if
-   * the resulting URL is not well-formed.
-   */
-  public @Nullable HttpUrl resolve(String link) {
-    Builder builder = newBuilder(link);
-    return builder != null ? builder.build() : null;
-  }
-
-  public Builder newBuilder() {
-    Builder result = new Builder();
-    result.scheme = scheme;
-    result.encodedUsername = encodedUsername();
-    result.encodedPassword = encodedPassword();
-    result.host = host;
-    // If we're set to a default port, unset it in case of a scheme change.
-    result.port = port != defaultPort(scheme) ? port : -1;
-    result.encodedPathSegments.clear();
-    result.encodedPathSegments.addAll(encodedPathSegments());
-    result.encodedQuery(encodedQuery());
-    result.encodedFragment = encodedFragment();
-    return result;
-  }
-
-  /**
-   * Returns a builder for the URL that would be retrieved by following {@code link} from this URL,
-   * or null if the resulting URL is not well-formed.
-   */
-  public @Nullable Builder newBuilder(String link) {
-    Builder builder = new Builder();
-    Builder.ParseResult result = builder.parse(this, link);
-    return result == Builder.ParseResult.SUCCESS ? builder : null;
-  }
-
-  /**
-   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
-   * URL, or null if it isn't.
-   */
-  public static @Nullable HttpUrl parse(String url) {
-    Builder builder = new Builder();
-    Builder.ParseResult result = builder.parse(null, url);
-    return result == Builder.ParseResult.SUCCESS ? builder.build() : null;
-  }
-
-  /**
-   * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
-   * null if it has any other protocol.
-   */
-  public static @Nullable HttpUrl get(URL url) {
-    return parse(url.toString());
-  }
-
-  /**
-   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
-   * URL, or throws an exception if it isn't.
-   *
-   * @throws MalformedURLException if there was a non-host related URL issue
-   * @throws UnknownHostException if the host was invalid
-   */
-  static HttpUrl getChecked(String url) throws MalformedURLException, UnknownHostException {
-    Builder builder = new Builder();
-    Builder.ParseResult result = builder.parse(null, url);
-    switch (result) {
-      case SUCCESS:
-        return builder.build();
-      case INVALID_HOST:
-        throw new UnknownHostException("Invalid host: " + url);
-      case UNSUPPORTED_SCHEME:
-      case MISSING_SCHEME:
-      case INVALID_PORT:
-      default:
-        throw new MalformedURLException("Invalid URL: " + result + " for " + url);
-    }
-  }
-
-  public static @Nullable HttpUrl get(URI uri) {
-    return parse(uri.toString());
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof HttpUrl && ((HttpUrl) other).url.equals(url);
-  }
-
-  @Override public int hashCode() {
-    return url.hashCode();
-  }
-
-  @Override public String toString() {
-    return url;
-  }
-
-  /**
-   * Returns the domain name of this URL's {@link #host()} that is one level beneath the public
-   * suffix by consulting the <a href="https://publicsuffix.org">public suffix list</a>. Returns
-   * null if this URL's {@link #host()} is an IP address or is considered a public suffix by the
-   * public suffix list.
-   *
-   * <p>In general this method <strong>should not</strong> be used to test whether a domain is valid
-   * or routable. Instead, DNS is the recommended source for that information.
-   *
-   * <p><table summary="">
-   *   <tr><th>URL</th><th>{@code topPrivateDomain()}</th></tr>
-   *   <tr><td>{@code http://google.com}</td><td>{@code "google.com"}</td></tr>
-   *   <tr><td>{@code http://adwords.google.co.uk}</td><td>{@code "google.co.uk"}</td></tr>
-   *   <tr><td>{@code http://square}</td><td>null</td></tr>
-   *   <tr><td>{@code http://co.uk}</td><td>null</td></tr>
-   *   <tr><td>{@code http://localhost}</td><td>null</td></tr>
-   *   <tr><td>{@code http://127.0.0.1}</td><td>null</td></tr>
-   * </table>
-   */
-  public @Nullable String topPrivateDomain() {
-    if (verifyAsIpAddress(host)) return null;
-    return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host);
-  }
-
-  public static final class Builder {
-    @Nullable String scheme;
-    String encodedUsername = "";
-    String encodedPassword = "";
-    @Nullable String host;
-    int port = -1;
-    final List<String> encodedPathSegments = new ArrayList<>();
-    @Nullable List<String> encodedQueryNamesAndValues;
-    @Nullable String encodedFragment;
-
-    public Builder() {
-      encodedPathSegments.add(""); // The default path is '/' which needs a trailing space.
-    }
-
-    public Builder scheme(String scheme) {
-      if (scheme == null) {
-        throw new NullPointerException("scheme == null");
-      } else if (scheme.equalsIgnoreCase("http")) {
-        this.scheme = "http";
-      } else if (scheme.equalsIgnoreCase("https")) {
-        this.scheme = "https";
-      } else {
-        throw new IllegalArgumentException("unexpected scheme: " + scheme);
-      }
-      return this;
-    }
-
-    public Builder username(String username) {
-      if (username == null) throw new NullPointerException("username == null");
-      this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, false, false, false, true);
-      return this;
-    }
-
-    public Builder encodedUsername(String encodedUsername) {
-      if (encodedUsername == null) throw new NullPointerException("encodedUsername == null");
-      this.encodedUsername = canonicalize(
-          encodedUsername, USERNAME_ENCODE_SET, true, false, false, true);
-      return this;
-    }
-
-    public Builder password(String password) {
-      if (password == null) throw new NullPointerException("password == null");
-      this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, false, false, false, true);
-      return this;
-    }
-
-    public Builder encodedPassword(String encodedPassword) {
-      if (encodedPassword == null) throw new NullPointerException("encodedPassword == null");
-      this.encodedPassword = canonicalize(
-          encodedPassword, PASSWORD_ENCODE_SET, true, false, false, true);
-      return this;
-    }
-
-    /**
-     * @param host either a regular hostname, International Domain Name, IPv4 address, or IPv6
-     * address.
-     */
-    public Builder host(String host) {
-      if (host == null) throw new NullPointerException("host == null");
-      String encoded = canonicalizeHost(host, 0, host.length());
-      if (encoded == null) throw new IllegalArgumentException("unexpected host: " + host);
-      this.host = encoded;
-      return this;
-    }
-
-    public Builder port(int port) {
-      if (port <= 0 || port > 65535) throw new IllegalArgumentException("unexpected port: " + port);
-      this.port = port;
-      return this;
-    }
-
-    int effectivePort() {
-      return port != -1 ? port : defaultPort(scheme);
-    }
-
-    public Builder addPathSegment(String pathSegment) {
-      if (pathSegment == null) throw new NullPointerException("pathSegment == null");
-      push(pathSegment, 0, pathSegment.length(), false, false);
-      return this;
-    }
-
-    /**
-     * Adds a set of path segments separated by a slash (either {@code \} or {@code /}). If
-     * {@code pathSegments} starts with a slash, the resulting URL will have empty path segment.
-     */
-    public Builder addPathSegments(String pathSegments) {
-      if (pathSegments == null) throw new NullPointerException("pathSegments == null");
-      return addPathSegments(pathSegments, false);
-    }
-
-    public Builder addEncodedPathSegment(String encodedPathSegment) {
-      if (encodedPathSegment == null) {
-        throw new NullPointerException("encodedPathSegment == null");
-      }
-      push(encodedPathSegment, 0, encodedPathSegment.length(), false, true);
-      return this;
-    }
-
-    /**
-     * Adds a set of encoded path segments separated by a slash (either {@code \} or {@code /}). If
-     * {@code encodedPathSegments} starts with a slash, the resulting URL will have empty path
-     * segment.
-     */
-    public Builder addEncodedPathSegments(String encodedPathSegments) {
-      if (encodedPathSegments == null) {
-        throw new NullPointerException("encodedPathSegments == null");
-      }
-      return addPathSegments(encodedPathSegments, true);
-    }
-
-    private Builder addPathSegments(String pathSegments, boolean alreadyEncoded) {
-      int offset = 0;
-      do {
-        int segmentEnd = delimiterOffset(pathSegments, offset, pathSegments.length(), "/\\");
-        boolean addTrailingSlash = segmentEnd < pathSegments.length();
-        push(pathSegments, offset, segmentEnd, addTrailingSlash, alreadyEncoded);
-        offset = segmentEnd + 1;
-      } while (offset <= pathSegments.length());
-      return this;
-    }
-
-    public Builder setPathSegment(int index, String pathSegment) {
-      if (pathSegment == null) throw new NullPointerException("pathSegment == null");
-      String canonicalPathSegment = canonicalize(
-          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false, false, true,
-              null);
-      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
-        throw new IllegalArgumentException("unexpected path segment: " + pathSegment);
-      }
-      encodedPathSegments.set(index, canonicalPathSegment);
-      return this;
-    }
-
-    public Builder setEncodedPathSegment(int index, String encodedPathSegment) {
-      if (encodedPathSegment == null) {
-        throw new NullPointerException("encodedPathSegment == null");
-      }
-      String canonicalPathSegment = canonicalize(encodedPathSegment,
-          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false, false, true,
-          null);
-      encodedPathSegments.set(index, canonicalPathSegment);
-      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
-        throw new IllegalArgumentException("unexpected path segment: " + encodedPathSegment);
-      }
-      return this;
-    }
-
-    public Builder removePathSegment(int index) {
-      encodedPathSegments.remove(index);
-      if (encodedPathSegments.isEmpty()) {
-        encodedPathSegments.add(""); // Always leave at least one '/'.
-      }
-      return this;
-    }
-
-    public Builder encodedPath(String encodedPath) {
-      if (encodedPath == null) throw new NullPointerException("encodedPath == null");
-      if (!encodedPath.startsWith("/")) {
-        throw new IllegalArgumentException("unexpected encodedPath: " + encodedPath);
-      }
-      resolvePath(encodedPath, 0, encodedPath.length());
-      return this;
-    }
-
-    public Builder query(@Nullable String query) {
-      this.encodedQueryNamesAndValues = query != null
-          ? queryStringToNamesAndValues(canonicalize(
-          query, QUERY_ENCODE_SET, false, false, true, true))
-          : null;
-      return this;
-    }
-
-    public Builder encodedQuery(@Nullable String encodedQuery) {
-      this.encodedQueryNamesAndValues = encodedQuery != null
-          ? queryStringToNamesAndValues(
-          canonicalize(encodedQuery, QUERY_ENCODE_SET, true, false, true, true))
-          : null;
-      return this;
-    }
-
-    /** Encodes the query parameter using UTF-8 and adds it to this URL's query string. */
-    public Builder addQueryParameter(String name, @Nullable String value) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
-      encodedQueryNamesAndValues.add(
-          canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true));
-      encodedQueryNamesAndValues.add(value != null
-          ? canonicalize(value, QUERY_COMPONENT_ENCODE_SET, false, false, true, true)
-          : null);
-      return this;
-    }
-
-    /** Adds the pre-encoded query parameter to this URL's query string. */
-    public Builder addEncodedQueryParameter(String encodedName, @Nullable String encodedValue) {
-      if (encodedName == null) throw new NullPointerException("encodedName == null");
-      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
-      encodedQueryNamesAndValues.add(
-          canonicalize(encodedName, QUERY_COMPONENT_REENCODE_SET, true, false, true, true));
-      encodedQueryNamesAndValues.add(encodedValue != null
-          ? canonicalize(encodedValue, QUERY_COMPONENT_REENCODE_SET, true, false, true, true)
-          : null);
-      return this;
-    }
-
-    public Builder setQueryParameter(String name, @Nullable String value) {
-      removeAllQueryParameters(name);
-      addQueryParameter(name, value);
-      return this;
-    }
-
-    public Builder setEncodedQueryParameter(String encodedName, @Nullable String encodedValue) {
-      removeAllEncodedQueryParameters(encodedName);
-      addEncodedQueryParameter(encodedName, encodedValue);
-      return this;
-    }
-
-    public Builder removeAllQueryParameters(String name) {
-      if (name == null) throw new NullPointerException("name == null");
-      if (encodedQueryNamesAndValues == null) return this;
-      String nameToRemove = canonicalize(
-          name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true);
-      removeAllCanonicalQueryParameters(nameToRemove);
-      return this;
-    }
-
-    public Builder removeAllEncodedQueryParameters(String encodedName) {
-      if (encodedName == null) throw new NullPointerException("encodedName == null");
-      if (encodedQueryNamesAndValues == null) return this;
-      removeAllCanonicalQueryParameters(
-          canonicalize(encodedName, QUERY_COMPONENT_REENCODE_SET, true, false, true, true));
-      return this;
-    }
-
-    private void removeAllCanonicalQueryParameters(String canonicalName) {
-      for (int i = encodedQueryNamesAndValues.size() - 2; i >= 0; i -= 2) {
-        if (canonicalName.equals(encodedQueryNamesAndValues.get(i))) {
-          encodedQueryNamesAndValues.remove(i + 1);
-          encodedQueryNamesAndValues.remove(i);
-          if (encodedQueryNamesAndValues.isEmpty()) {
-            encodedQueryNamesAndValues = null;
-            return;
-          }
-        }
-      }
-    }
-
-    public Builder fragment(@Nullable String fragment) {
-      this.encodedFragment = fragment != null
-          ? canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false, false, false)
-          : null;
-      return this;
-    }
-
-    public Builder encodedFragment(@Nullable String encodedFragment) {
-      this.encodedFragment = encodedFragment != null
-          ? canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false, false, false)
-          : null;
-      return this;
-    }
-
-    /**
-     * Re-encodes the components of this URL so that it satisfies (obsolete) RFC 2396, which is
-     * particularly strict for certain components.
-     */
-    Builder reencodeForUri() {
-      for (int i = 0, size = encodedPathSegments.size(); i < size; i++) {
-        String pathSegment = encodedPathSegments.get(i);
-        encodedPathSegments.set(i,
-            canonicalize(pathSegment, PATH_SEGMENT_ENCODE_SET_URI, true, true, false, true));
-      }
-      if (encodedQueryNamesAndValues != null) {
-        for (int i = 0, size = encodedQueryNamesAndValues.size(); i < size; i++) {
-          String component = encodedQueryNamesAndValues.get(i);
-          if (component != null) {
-            encodedQueryNamesAndValues.set(i,
-                canonicalize(component, QUERY_COMPONENT_ENCODE_SET_URI, true, true, true, true));
-          }
-        }
-      }
-      if (encodedFragment != null) {
-        encodedFragment = canonicalize(
-            encodedFragment, FRAGMENT_ENCODE_SET_URI, true, true, false, false);
-      }
-      return this;
-    }
-
-    public HttpUrl build() {
-      if (scheme == null) throw new IllegalStateException("scheme == null");
-      if (host == null) throw new IllegalStateException("host == null");
-      return new HttpUrl(this);
-    }
-
-    @Override public String toString() {
-      StringBuilder result = new StringBuilder();
-      result.append(scheme);
-      result.append("://");
-
-      if (!encodedUsername.isEmpty() || !encodedPassword.isEmpty()) {
-        result.append(encodedUsername);
-        if (!encodedPassword.isEmpty()) {
-          result.append(':');
-          result.append(encodedPassword);
-        }
-        result.append('@');
-      }
-
-      if (host.indexOf(':') != -1) {
-        // Host is an IPv6 address.
-        result.append('[');
-        result.append(host);
-        result.append(']');
-      } else {
-        result.append(host);
-      }
-
-      int effectivePort = effectivePort();
-      if (effectivePort != defaultPort(scheme)) {
-        result.append(':');
-        result.append(effectivePort);
-      }
-
-      pathSegmentsToString(result, encodedPathSegments);
-
-      if (encodedQueryNamesAndValues != null) {
-        result.append('?');
-        namesAndValuesToQueryString(result, encodedQueryNamesAndValues);
-      }
-
-      if (encodedFragment != null) {
-        result.append('#');
-        result.append(encodedFragment);
-      }
-
-      return result.toString();
-    }
-
-    enum ParseResult {
-      SUCCESS,
-      MISSING_SCHEME,
-      UNSUPPORTED_SCHEME,
-      INVALID_PORT,
-      INVALID_HOST,
-    }
-
-    ParseResult parse(@Nullable HttpUrl base, String input) {
-      int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
-      int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
-
-      // Scheme.
-      int schemeDelimiterOffset = schemeDelimiterOffset(input, pos, limit);
-      if (schemeDelimiterOffset != -1) {
-        if (input.regionMatches(true, pos, "https:", 0, 6)) {
-          this.scheme = "https";
-          pos += "https:".length();
-        } else if (input.regionMatches(true, pos, "http:", 0, 5)) {
-          this.scheme = "http";
-          pos += "http:".length();
-        } else {
-          return ParseResult.UNSUPPORTED_SCHEME; // Not an HTTP scheme.
-        }
-      } else if (base != null) {
-        this.scheme = base.scheme;
-      } else {
-        return ParseResult.MISSING_SCHEME; // No scheme.
-      }
-
-      // Authority.
-      boolean hasUsername = false;
-      boolean hasPassword = false;
-      int slashCount = slashCount(input, pos, limit);
-      if (slashCount >= 2 || base == null || !base.scheme.equals(this.scheme)) {
-        // Read an authority if either:
-        //  * The input starts with 2 or more slashes. These follow the scheme if it exists.
-        //  * The input scheme exists and is different from the base URL's scheme.
-        //
-        // The structure of an authority is:
-        //   username:password@host:port
-        //
-        // Username, password and port are optional.
-        //   [username[:password]@]host[:port]
-        pos += slashCount;
-        authority:
-        while (true) {
-          int componentDelimiterOffset = delimiterOffset(input, pos, limit, "@/\\?#");
-          int c = componentDelimiterOffset != limit
-              ? input.charAt(componentDelimiterOffset)
-              : -1;
-          switch (c) {
-            case '@':
-              // User info precedes.
-              if (!hasPassword) {
-                int passwordColonOffset = delimiterOffset(
-                    input, pos, componentDelimiterOffset, ':');
-                String canonicalUsername = canonicalize(
-                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false, false, true,
-                    null);
-                this.encodedUsername = hasUsername
-                    ? this.encodedUsername + "%40" + canonicalUsername
-                    : canonicalUsername;
-                if (passwordColonOffset != componentDelimiterOffset) {
-                  hasPassword = true;
-                  this.encodedPassword = canonicalize(input, passwordColonOffset + 1,
-                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true,
-                      null);
-                }
-                hasUsername = true;
-              } else {
-                this.encodedPassword = this.encodedPassword + "%40" + canonicalize(input, pos,
-                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true,
-                    null);
-              }
-              pos = componentDelimiterOffset + 1;
-              break;
-
-            case -1:
-            case '/':
-            case '\\':
-            case '?':
-            case '#':
-              // Host info precedes.
-              int portColonOffset = portColonOffset(input, pos, componentDelimiterOffset);
-              if (portColonOffset + 1 < componentDelimiterOffset) {
-                this.host = canonicalizeHost(input, pos, portColonOffset);
-                this.port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
-                if (this.port == -1) return ParseResult.INVALID_PORT; // Invalid port.
-              } else {
-                this.host = canonicalizeHost(input, pos, portColonOffset);
-                this.port = defaultPort(this.scheme);
-              }
-              if (this.host == null) return ParseResult.INVALID_HOST; // Invalid host.
-              pos = componentDelimiterOffset;
-              break authority;
-          }
-        }
-      } else {
-        // This is a relative link. Copy over all authority components. Also maybe the path & query.
-        this.encodedUsername = base.encodedUsername();
-        this.encodedPassword = base.encodedPassword();
-        this.host = base.host;
-        this.port = base.port;
-        this.encodedPathSegments.clear();
-        this.encodedPathSegments.addAll(base.encodedPathSegments());
-        if (pos == limit || input.charAt(pos) == '#') {
-          encodedQuery(base.encodedQuery());
-        }
-      }
-
-      // Resolve the relative path.
-      int pathDelimiterOffset = delimiterOffset(input, pos, limit, "?#");
-      resolvePath(input, pos, pathDelimiterOffset);
-      pos = pathDelimiterOffset;
-
-      // Query.
-      if (pos < limit && input.charAt(pos) == '?') {
-        int queryDelimiterOffset = delimiterOffset(input, pos, limit, '#');
-        this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
-            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true, null));
-        pos = queryDelimiterOffset;
-      }
-
-      // Fragment.
-      if (pos < limit && input.charAt(pos) == '#') {
-        this.encodedFragment = canonicalize(
-            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false, null);
-      }
-
-      return ParseResult.SUCCESS;
-    }
-
-    private void resolvePath(String input, int pos, int limit) {
-      // Read a delimiter.
-      if (pos == limit) {
-        // Empty path: keep the base path as-is.
-        return;
-      }
-      char c = input.charAt(pos);
-      if (c == '/' || c == '\\') {
-        // Absolute path: reset to the default "/".
-        encodedPathSegments.clear();
-        encodedPathSegments.add("");
-        pos++;
-      } else {
-        // Relative path: clear everything after the last '/'.
-        encodedPathSegments.set(encodedPathSegments.size() - 1, "");
-      }
-
-      // Read path segments.
-      for (int i = pos; i < limit; ) {
-        int pathSegmentDelimiterOffset = delimiterOffset(input, i, limit, "/\\");
-        boolean segmentHasTrailingSlash = pathSegmentDelimiterOffset < limit;
-        push(input, i, pathSegmentDelimiterOffset, segmentHasTrailingSlash, true);
-        i = pathSegmentDelimiterOffset;
-        if (segmentHasTrailingSlash) i++;
-      }
-    }
-
-    /** Adds a path segment. If the input is ".." or equivalent, this pops a path segment. */
-    private void push(String input, int pos, int limit, boolean addTrailingSlash,
-        boolean alreadyEncoded) {
-      String segment = canonicalize(
-          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false, false, true, null);
-      if (isDot(segment)) {
-        return; // Skip '.' path segments.
-      }
-      if (isDotDot(segment)) {
-        pop();
-        return;
-      }
-      if (encodedPathSegments.get(encodedPathSegments.size() - 1).isEmpty()) {
-        encodedPathSegments.set(encodedPathSegments.size() - 1, segment);
-      } else {
-        encodedPathSegments.add(segment);
-      }
-      if (addTrailingSlash) {
-        encodedPathSegments.add("");
-      }
-    }
-
-    private boolean isDot(String input) {
-      return input.equals(".") || input.equalsIgnoreCase("%2e");
-    }
-
-    private boolean isDotDot(String input) {
-      return input.equals("..")
-          || input.equalsIgnoreCase("%2e.")
-          || input.equalsIgnoreCase(".%2e")
-          || input.equalsIgnoreCase("%2e%2e");
-    }
-
-    /**
-     * Removes a path segment. When this method returns the last segment is always "", which means
-     * the encoded path will have a trailing '/'.
-     *
-     * <p>Popping "/a/b/c/" yields "/a/b/". In this case the list of path segments goes from ["a",
-     * "b", "c", ""] to ["a", "b", ""].
-     *
-     * <p>Popping "/a/b/c" also yields "/a/b/". The list of path segments goes from ["a", "b", "c"]
-     * to ["a", "b", ""].
-     */
-    private void pop() {
-      String removed = encodedPathSegments.remove(encodedPathSegments.size() - 1);
-
-      // Make sure the path ends with a '/' by either adding an empty string or clearing a segment.
-      if (removed.isEmpty() && !encodedPathSegments.isEmpty()) {
-        encodedPathSegments.set(encodedPathSegments.size() - 1, "");
-      } else {
-        encodedPathSegments.add("");
-      }
-    }
-
-    /**
-     * Returns the index of the ':' in {@code input} that is after scheme characters. Returns -1 if
-     * {@code input} does not have a scheme that starts at {@code pos}.
-     */
-    private static int schemeDelimiterOffset(String input, int pos, int limit) {
-      if (limit - pos < 2) return -1;
-
-      char c0 = input.charAt(pos);
-      if ((c0 < 'a' || c0 > 'z') && (c0 < 'A' || c0 > 'Z')) return -1; // Not a scheme start char.
-
-      for (int i = pos + 1; i < limit; i++) {
-        char c = input.charAt(i);
-
-        if ((c >= 'a' && c <= 'z')
-            || (c >= 'A' && c <= 'Z')
-            || (c >= '0' && c <= '9')
-            || c == '+'
-            || c == '-'
-            || c == '.') {
-          continue; // Scheme character. Keep going.
-        } else if (c == ':') {
-          return i; // Scheme prefix!
-        } else {
-          return -1; // Non-scheme character before the first ':'.
-        }
-      }
-
-      return -1; // No ':'; doesn't start with a scheme.
-    }
-
-    /** Returns the number of '/' and '\' slashes in {@code input}, starting at {@code pos}. */
-    private static int slashCount(String input, int pos, int limit) {
-      int slashCount = 0;
-      while (pos < limit) {
-        char c = input.charAt(pos);
-        if (c == '\\' || c == '/') {
-          slashCount++;
-          pos++;
-        } else {
-          break;
-        }
-      }
-      return slashCount;
-    }
-
-    /** Finds the first ':' in {@code input}, skipping characters between square braces "[...]". */
-    private static int portColonOffset(String input, int pos, int limit) {
-      for (int i = pos; i < limit; i++) {
-        switch (input.charAt(i)) {
-          case '[':
-            while (++i < limit) {
-              if (input.charAt(i) == ']') break;
-            }
-            break;
-          case ':':
-            return i;
-        }
-      }
-      return limit; // No colon.
-    }
-
-    private static String canonicalizeHost(String input, int pos, int limit) {
-      // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
-      // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
-      String percentDecoded = percentDecode(input, pos, limit, false);
-      return Util.canonicalizeHost(percentDecoded);
-    }
-
-    private static int parsePort(String input, int pos, int limit) {
-      try {
-        // Canonicalize the port string to skip '\n' etc.
-        String portString = canonicalize(input, pos, limit, "", false, false, false, true, null);
-        int i = Integer.parseInt(portString);
-        if (i > 0 && i <= 65535) return i;
-        return -1;
-      } catch (NumberFormatException e) {
-        return -1; // Invalid port.
-      }
-    }
-  }
-
-  static String percentDecode(String encoded, boolean plusIsSpace) {
-    return percentDecode(encoded, 0, encoded.length(), plusIsSpace);
-  }
-
-  private List<String> percentDecode(List<String> list, boolean plusIsSpace) {
-    int size = list.size();
-    List<String> result = new ArrayList<>(size);
-    for (int i = 0; i < size; i++) {
-      String s = list.get(i);
-      result.add(s != null ? percentDecode(s, plusIsSpace) : null);
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  static String percentDecode(String encoded, int pos, int limit, boolean plusIsSpace) {
-    for (int i = pos; i < limit; i++) {
-      char c = encoded.charAt(i);
-      if (c == '%' || (c == '+' && plusIsSpace)) {
-        // Slow path: the character at i requires decoding!
-        Buffer out = new Buffer();
-        out.writeUtf8(encoded, pos, i);
-        percentDecode(out, encoded, i, limit, plusIsSpace);
-        return out.readUtf8();
-      }
-    }
-
-    // Fast path: no characters in [pos..limit) required decoding.
-    return encoded.substring(pos, limit);
-  }
-
-  static void percentDecode(Buffer out, String encoded, int pos, int limit, boolean plusIsSpace) {
-    int codePoint;
-    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
-      codePoint = encoded.codePointAt(i);
-      if (codePoint == '%' && i + 2 < limit) {
-        int d1 = decodeHexDigit(encoded.charAt(i + 1));
-        int d2 = decodeHexDigit(encoded.charAt(i + 2));
-        if (d1 != -1 && d2 != -1) {
-          out.writeByte((d1 << 4) + d2);
-          i += 2;
-          continue;
-        }
-      } else if (codePoint == '+' && plusIsSpace) {
-        out.writeByte(' ');
-        continue;
-      }
-      out.writeUtf8CodePoint(codePoint);
-    }
-  }
-
-  static boolean percentEncoded(String encoded, int pos, int limit) {
-    return pos + 2 < limit
-        && encoded.charAt(pos) == '%'
-        && decodeHexDigit(encoded.charAt(pos + 1)) != -1
-        && decodeHexDigit(encoded.charAt(pos + 2)) != -1;
-  }
-
-  /**
-   * Returns a substring of {@code input} on the range {@code [pos..limit)} with the following
-   * transformations:
-   * <ul>
-   *   <li>Tabs, newlines, form feeds and carriage returns are skipped.
-   *   <li>In queries, ' ' is encoded to '+' and '+' is encoded to "%2B".
-   *   <li>Characters in {@code encodeSet} are percent-encoded.
-   *   <li>Control characters and non-ASCII characters are percent-encoded.
-   *   <li>All other characters are copied without transformation.
-   * </ul>
-   *
-   * @param alreadyEncoded true to leave '%' as-is; false to convert it to '%25'.
-   * @param strict true to encode '%' if it is not the prefix of a valid percent encoding.
-   * @param plusIsSpace true to encode '+' as "%2B" if it is not already encoded.
-   * @param asciiOnly true to encode all non-ASCII codepoints.
-   * @param charset which charset to use, null equals UTF-8.
-   */
-  static String canonicalize(String input, int pos, int limit, String encodeSet,
-      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly,
-      Charset charset) {
-    int codePoint;
-    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
-      codePoint = input.codePointAt(i);
-      if (codePoint < 0x20
-          || codePoint == 0x7f
-          || codePoint >= 0x80 && asciiOnly
-          || encodeSet.indexOf(codePoint) != -1
-          || codePoint == '%' && (!alreadyEncoded || strict && !percentEncoded(input, i, limit))
-          || codePoint == '+' && plusIsSpace) {
-        // Slow path: the character at i requires encoding!
-        Buffer out = new Buffer();
-        out.writeUtf8(input, pos, i);
-        canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, strict, plusIsSpace,
-            asciiOnly, charset);
-        return out.readUtf8();
-      }
-    }
-
-    // Fast path: no characters in [pos..limit) required encoding.
-    return input.substring(pos, limit);
-  }
-
-  static void canonicalize(Buffer out, String input, int pos, int limit, String encodeSet,
-      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly,
-      Charset charset) {
-    Buffer encodedCharBuffer = null; // Lazily allocated.
-    int codePoint;
-    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
-      codePoint = input.codePointAt(i);
-      if (alreadyEncoded
-          && (codePoint == '\t' || codePoint == '\n' || codePoint == '\f' || codePoint == '\r')) {
-        // Skip this character.
-      } else if (codePoint == '+' && plusIsSpace) {
-        // Encode '+' as '%2B' since we permit ' ' to be encoded as either '+' or '%20'.
-        out.writeUtf8(alreadyEncoded ? "+" : "%2B");
-      } else if (codePoint < 0x20
-          || codePoint == 0x7f
-          || codePoint >= 0x80 && asciiOnly
-          || encodeSet.indexOf(codePoint) != -1
-          || codePoint == '%' && (!alreadyEncoded || strict && !percentEncoded(input, i, limit))) {
-        // Percent encode this character.
-        if (encodedCharBuffer == null) {
-          encodedCharBuffer = new Buffer();
-        }
-
-        if (charset == null || charset.equals(Util.UTF_8)) {
-          encodedCharBuffer.writeUtf8CodePoint(codePoint);
-        } else {
-          encodedCharBuffer.writeString(input, i, i + Character.charCount(codePoint), charset);
-        }
-
-        while (!encodedCharBuffer.exhausted()) {
-          int b = encodedCharBuffer.readByte() & 0xff;
-          out.writeByte('%');
-          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
-          out.writeByte(HEX_DIGITS[b & 0xf]);
-        }
-      } else {
-        // This character doesn't need encoding. Just copy it over.
-        out.writeUtf8CodePoint(codePoint);
-      }
-    }
-  }
-
-  static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
-      boolean plusIsSpace, boolean asciiOnly, Charset charset) {
-    return canonicalize(
-        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly,
-            charset);
-  }
-
-  static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
-      boolean plusIsSpace, boolean asciiOnly) {
-   return canonicalize(
-        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly, null);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.kt b/okhttp/src/main/java/okhttp3/HttpUrl.kt
new file mode 100644
index 0000000000..4fc26196e1
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.kt
@@ -0,0 +1,1736 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.HttpUrl.Companion.get
+import okhttp3.HttpUrl.Companion.parse
+import okhttp3.internal.Util
+import okhttp3.internal.Util.decodeHexDigit
+import okhttp3.internal.Util.delimiterOffset
+import okhttp3.internal.Util.skipLeadingAsciiWhitespace
+import okhttp3.internal.Util.skipTrailingAsciiWhitespace
+import okhttp3.internal.Util.verifyAsIpAddress
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase
+import okio.Buffer
+import java.net.InetAddress
+import java.net.MalformedURLException
+import java.net.URI
+import java.net.URISyntaxException
+import java.net.URL
+import java.nio.charset.Charset
+import java.nio.charset.StandardCharsets.UTF_8
+import java.util.ArrayList
+import java.util.Collections
+import java.util.LinkedHashSet
+
+/**
+ * A uniform resource locator (URL) with a scheme of either `http` or `https`. Use this class to
+ * compose and decompose Internet addresses. For example, this code will compose and print a URL for
+ * Google search:
+ *
+ * ```
+ * HttpUrl url = new HttpUrl.Builder()
+ *     .scheme("https")
+ *     .host("www.google.com")
+ *     .addPathSegment("search")
+ *     .addQueryParameter("q", "polar bears")
+ *     .build();
+ * System.out.println(url);
+ * ```
+ *
+ * which prints:
+ *
+ * ```
+ * https://www.google.com/search?q=polar%20bears
+ * ```
+ *
+ * As another example, this code prints the human-readable query parameters of a Twitter search:
+ *
+ * ```
+ * HttpUrl url = HttpUrl.parse("https://twitter.com/search?q=cute%20%23puppies&f=images");
+ * for (int i = 0, size = url.querySize(); i < size; i++) {
+ *   System.out.println(url.queryParameterName(i) + ": " + url.queryParameterValue(i));
+ * }
+ * ```
+ *
+ * which prints:
+ *
+ * ```
+ * q: cute #puppies
+ * f: images
+ * ```
+ *
+ * In addition to composing URLs from their component parts and decomposing URLs into their
+ * component parts, this class implements relative URL resolution: what address you'd reach by
+ * clicking a relative link on a specified page. For example:
+ *
+ * ```
+ * HttpUrl base = HttpUrl.parse("https://www.youtube.com/user/WatchTheDaily/videos");
+ * HttpUrl link = base.resolve("../../watch?v=cbP2N1BQdYc");
+ * System.out.println(link);
+ * ```
+ *
+ * which prints:
+ *
+ * ```
+ * https://www.youtube.com/watch?v=cbP2N1BQdYc
+ * ```
+ *
+ * ## What's in a URL?
+ *
+ * A URL has several components.
+ *
+ * ### Scheme
+ *
+ * Sometimes referred to as *protocol*, A URL's scheme describes what mechanism should be used to
+ * retrieve the resource. Although URLs have many schemes (`mailto`, `file`, `ftp`), this class only
+ * supports `http` and `https`. Use [java.net.URI][URI] for URLs with arbitrary schemes.
+ *
+ * ### Username and Password
+ *
+ * Username and password are either present, or the empty string `""` if absent. This class offers
+ * no mechanism to differentiate empty from absent. Neither of these components are popular in
+ * practice. Typically HTTP applications use other mechanisms for user identification and
+ * authentication.
+ *
+ * ### Host
+ *
+ * The host identifies the webserver that serves the URL's resource. It is either a hostname like
+ * `square.com` or `localhost`, an IPv4 address like `192.168.0.1`, or an IPv6 address like `::1`.
+ *
+ * Usually a webserver is reachable with multiple identifiers: its IP addresses, registered
+ * domain names, and even `localhost` when connecting from the server itself. Each of a web server's
+ * names is a distinct URL and they are not interchangeable. For example, even if
+ * `http://square.github.io/dagger` and `http://google.github.io/dagger` are served by the same IP
+ * address, the two URLs identify different resources.
+ *
+ * ### Port
+ *
+ * The port used to connect to the web server. By default this is 80 for HTTP and 443 for HTTPS.
+ * This class never returns -1 for the port: if no port is explicitly specified in the URL then the
+ * scheme's default is used.
+ *
+ * ### Path
+ *
+ * The path identifies a specific resource on the host. Paths have a hierarchical structure like
+ * "/square/okhttp/issues/1486" and decompose into a list of segments like `["square", "okhttp",
+ * "issues", "1486"]`.
+ *
+ * This class offers methods to compose and decompose paths by segment. It composes each path
+ * from a list of segments by alternating between "/" and the encoded segment. For example the
+ * segments `["a", "b"]` build "/a/b" and the segments `["a", "b", ""]` build "/a/b/".
+ *
+ * If a path's last segment is the empty string then the path ends with "/". This class always
+ * builds non-empty paths: if the path is omitted it defaults to "/". The default path's segment
+ * list is a single empty string: `[""]`.
+ *
+ * ### Query
+ *
+ * The query is optional: it can be null, empty, or non-empty. For many HTTP URLs the query string
+ * is subdivided into a collection of name-value parameters. This class offers methods to set the
+ * query as the single string, or as individual name-value parameters. With name-value parameters
+ * the values are optional and names may be repeated.
+ *
+ * ### Fragment
+ *
+ * The fragment is optional: it can be null, empty, or non-empty. Unlike host, port, path, and
+ * query the fragment is not sent to the webserver: it's private to the client.
+ *
+ * ## Encoding
+ *
+ * Each component must be encoded before it is embedded in the complete URL. As we saw above, the
+ * string `cute #puppies` is encoded as `cute%20%23puppies` when used as a query parameter value.
+ *
+ * ### Percent encoding
+ *
+ * Percent encoding replaces a character (like `\ud83c\udf69`) with its UTF-8 hex bytes (like
+ * `%F0%9F%8D%A9`). This approach works for whitespace characters, control characters, non-ASCII
+ * characters, and characters that already have another meaning in a particular context.
+ *
+ * Percent encoding is used in every URL component except for the hostname. But the set of
+ * characters that need to be encoded is different for each component. For example, the path
+ * component must escape all of its `?` characters, otherwise it could be interpreted as the
+ * start of the URL's query. But within the query and fragment components, the `?` character
+ * doesn't delimit anything and doesn't need to be escaped.
+ *
+ * ```
+ * HttpUrl url = HttpUrl.parse("http://who-let-the-dogs.out").newBuilder()
+ *     .addPathSegment("_Who?_")
+ *     .query("_Who?_")
+ *     .fragment("_Who?_")
+ *     .build();
+ * System.out.println(url);
+ * ```
+ *
+ * This prints:
+ *
+ * ```
+ * http://who-let-the-dogs.out/_Who%3F_?_Who?_#_Who?_
+ * ```
+ *
+ * When parsing URLs that lack percent encoding where it is required, this class will percent encode
+ * the offending characters.
+ *
+ * ### IDNA Mapping and Punycode encoding
+ *
+ * Hostnames have different requirements and use a different encoding scheme. It consists of IDNA
+ * mapping and Punycode encoding.
+ *
+ * In order to avoid confusion and discourage phishing attacks, [IDNA Mapping][idna] transforms
+ * names to avoid confusing characters. This includes basic case folding: transforming shouting
+ * `SQUARE.COM` into cool and casual `square.com`. It also handles more exotic characters. For
+ * example, the Unicode trademark sign (‚Ñ¢) could be confused for the letters "TM" in
+ * `http://ho‚Ñ¢mail.com`. To mitigate this, the single character (‚Ñ¢) maps to the string (tm). There
+ * is similar policy for all of the 1.1 million Unicode code points. Note that some code points such
+ * as "\ud83c\udf69" are not mapped and cannot be used in a hostname.
+ *
+ * [Punycode](http://ietf.org/rfc/rfc3492.txt) converts a Unicode string to an ASCII string to make
+ * international domain names work everywhere. For example, "œÉ" encodes as "xn--4xa". The encoded
+ * string is not human readable, but can be used with classes like [InetAddress] to establish
+ * connections.
+ *
+ * ## Why another URL model?
+ *
+ * Java includes both [java.net.URL][URL] and [java.net.URI][URI]. We offer a new URL
+ * model to address problems that the others don't.
+ *
+ * ### Different URLs should be different
+ *
+ * Although they have different content, `java.net.URL` considers the following two URLs
+ * equal, and the [equals()][Object.equals] method between them returns true:
+ *
+ *  * http://square.github.io/
+ *
+ *  * http://google.github.io/
+ *
+ * This is because those two hosts share the same IP address. This is an old, bad design decision
+ * that makes `java.net.URL` unusable for many things. It shouldn't be used as a [Map] key or in a
+ * [Set]. Doing so is both inefficient because equality may require a DNS lookup, and incorrect
+ * because unequal URLs may be equal because of how they are hosted.
+ *
+ * ### Equal URLs should be equal
+ *
+ * These two URLs are semantically identical, but `java.net.URI` disagrees:
+ *
+ *  * http://host:80/
+ *
+ *  * http://host
+ *
+ * Both the unnecessary port specification (`:80`) and the absent trailing slash (`/`) cause URI to
+ * bucket the two URLs separately. This harms URI's usefulness in collections. Any application that
+ * stores information-per-URL will need to either canonicalize manually, or suffer unnecessary
+ * redundancy for such URLs.
+ *
+ * Because they don't attempt canonical form, these classes are surprisingly difficult to use
+ * securely. Suppose you're building a webservice that checks that incoming paths are prefixed
+ * "/static/images/" before serving the corresponding assets from the filesystem.
+ *
+ * ```
+ * String attack = "http://example.com/static/images/../../../../../etc/passwd";
+ * System.out.println(new URL(attack).getPath());
+ * System.out.println(new URI(attack).getPath());
+ * System.out.println(HttpUrl.parse(attack).encodedPath());
+ * ```
+ *
+ * By canonicalizing the input paths, they are complicit in directory traversal attacks. Code that
+ * checks only the path prefix may suffer!
+ *
+ * ```
+ * /static/images/../../../../../etc/passwd
+ * /static/images/../../../../../etc/passwd
+ * /etc/passwd
+ * ```
+ *
+ * ### If it works on the web, it should work in your application
+ *
+ * The `java.net.URI` class is strict around what URLs it accepts. It rejects URLs like
+ * `http://example.com/abc|def` because the `|` character is unsupported. This class is more
+ * forgiving: it will automatically percent-encode the `|'` yielding `http://example.com/abc%7Cdef`.
+ * This kind behavior is consistent with web browsers. `HttpUrl` prefers consistency with major web
+ * browsers over consistency with obsolete specifications.
+ *
+ * ### Paths and Queries should decompose
+ *
+ * Neither of the built-in URL models offer direct access to path segments or query parameters.
+ * Manually using `StringBuilder` to assemble these components is cumbersome: do '+' characters get
+ * silently replaced with spaces? If a query parameter contains a '&amp;', does that get escaped?
+ * By offering methods to read and write individual query parameters directly, application
+ * developers are saved from the hassles of encoding and decoding.
+ *
+ * ### Plus a modern API
+ *
+ * The URL (JDK1.0) and URI (Java 1.4) classes predate builders and instead use telescoping
+ * constructors. For example, there's no API to compose a URI with a custom port without also
+ * providing a query and fragment.
+ *
+ * Instances of [HttpUrl] are well-formed and always have a scheme, host, and path. With
+ * `java.net.URL` it's possible to create an awkward URL like `http:/` with scheme and path but no
+ * hostname. Building APIs that consume such malformed values is difficult!
+ *
+ * This class has a modern API. It avoids punitive checked exceptions: [get] throws
+ * [IllegalArgumentException] on invalid input or [parse] returns null if the input is an invalid
+ * URL. You can even be explicit about whether each component has been encoded already.
+ *
+ * [idna]: http://www.unicode.org/reports/tr46/#ToASCII
+ */
+class HttpUrl internal constructor(builder: Builder) {
+
+  /** Either "http" or "https".  */
+  internal val scheme: String = builder.scheme ?: throw IllegalStateException("scheme == null")
+
+  /** Decoded username.  */
+  private val username: String = percentDecode(builder.encodedUsername, false)
+
+  /** Decoded password.  */
+  private val password: String = percentDecode(builder.encodedPassword, false)
+
+  /** Canonical hostname.  */
+  internal val host: String = builder.host ?: throw IllegalStateException("host == null")
+
+  /** Either 80, 443 or a user-specified port. In range [1..65535].  */
+  internal val port: Int = builder.effectivePort()
+
+  /**
+   * A list of canonical path segments. This list always contains at least one element, which may be
+   * the empty string. Each segment is formatted with a leading '/', so if path segments were ["a",
+   * "b", ""], then the encoded path would be "/a/b/".
+   */
+  @Suppress("UNCHECKED_CAST")
+  private val pathSegments: List<String> =
+      percentDecode(builder.encodedPathSegments, false) as List<String>
+
+  /**
+   * Alternating, decoded query names and values, or null for no query. Names may be empty or
+   * non-empty, but never null. Values are null if the name has no corresponding '=' separator, or
+   * empty, or non-empty.
+   */
+  private val queryNamesAndValues: List<String?>? =
+      builder.encodedQueryNamesAndValues?.let { percentDecode(it, true) }
+
+  /** Decoded fragment.  */
+  private val fragment: String? = builder.encodedFragment?.let { percentDecode(it, false) }
+
+  /** Canonical URL.  */
+  private val url: String = builder.toString()
+
+  val isHttps: Boolean = scheme == "https"
+
+  /** Returns this URL as a [java.net.URL][URL].  */
+  fun url(): URL {
+    try {
+      return URL(url)
+    } catch (e: MalformedURLException) {
+      throw RuntimeException(e) // Unexpected!
+    }
+  }
+
+  /**
+   * Returns this URL as a [java.net.URI][URI]. Because `URI` is more strict than this class, the
+   * returned URI may be semantically different from this URL:
+   *
+   *  * Characters forbidden by URI like `[` and `|` will be escaped.
+   *
+   *  * Invalid percent-encoded sequences like `%xx` will be encoded like `%25xx`.
+   *
+   *  * Whitespace and control characters in the fragment will be stripped.
+   *
+   * These differences may have a significant consequence when the URI is interpreted by a
+   * web server. For this reason the [URI class][URI] and this method should be avoided.
+   */
+  fun uri(): URI {
+    val uri = newBuilder().reencodeForUri().toString()
+    try {
+      return URI(uri)
+    } catch (e: URISyntaxException) {
+      // Unlikely edge case: the URI has a forbidden character in the fragment. Strip it & retry.
+      try {
+        val stripped = uri.replace(Regex("[\\u0000-\\u001F\\u007F-\\u009F\\p{javaWhitespace}]"), "")
+        return URI.create(stripped)
+      } catch (e1: Exception) {
+        throw RuntimeException(e) // Unexpected!
+      }
+    }
+  }
+
+  /** Returns either "http" or "https".  */
+  fun scheme(): String = scheme
+
+  /**
+   * Returns the username, or an empty string if none is set.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`encodedUsername()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`""`</td></tr>
+   * <tr><td>`http://username@host/`</td><td>`"username"`</td></tr>
+   * <tr><td>`http://username:password@host/`</td><td>`"username"`</td></tr>
+   * <tr><td>`http://a%20b:c%20d@host/`</td><td>`"a%20b"`</td></tr>
+   * </table>
+   */
+  fun encodedUsername(): String {
+    if (username.isEmpty()) return ""
+    val usernameStart = scheme.length + 3 // "://".length() == 3.
+    val usernameEnd = delimiterOffset(url, usernameStart, url.length, ":@")
+    return url.substring(usernameStart, usernameEnd)
+  }
+
+  /**
+   * Returns the decoded username, or an empty string if none is present.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`username()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`""`</td></tr>
+   * <tr><td>`http://username@host/`</td><td>`"username"`</td></tr>
+   * <tr><td>`http://username:password@host/`</td><td>`"username"`</td></tr>
+   * <tr><td>`http://a%20b:c%20d@host/`</td><td>`"a b"`</td></tr>
+   * </table>
+   */
+  fun username(): String = username
+
+  /**
+   * Returns the password, or an empty string if none is set.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`encodedPassword()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`""`</td></tr>
+   * <tr><td>`http://username@host/`</td><td>`""`</td></tr>
+   * <tr><td>`http://username:password@host/`</td><td>`"password"`</td></tr>
+   * <tr><td>`http://a%20b:c%20d@host/`</td><td>`"c%20d"`</td></tr>
+   * </table>
+   */
+  fun encodedPassword(): String {
+    if (password.isEmpty()) return ""
+    val passwordStart = url.indexOf(':', scheme.length + 3) + 1
+    val passwordEnd = url.indexOf('@')
+    return url.substring(passwordStart, passwordEnd)
+  }
+
+  /**
+   * Returns the decoded password, or an empty string if none is present.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`password()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`""`</td></tr>
+   * <tr><td>`http://username@host/`</td><td>`""`</td></tr>
+   * <tr><td>`http://username:password@host/`</td><td>`"password"`</td></tr>
+   * <tr><td>`http://a%20b:c%20d@host/`</td><td>`"c d"`</td></tr>
+   * </table>
+   */
+  fun password(): String = password
+
+  /**
+   * Returns the host address suitable for use with [InetAddress.getAllByName]. May be:
+   *
+   *  * A regular host name, like `android.com`.
+   *
+   *  * An IPv4 address, like `127.0.0.1`.
+   *
+   *  * An IPv6 address, like `::1`. Note that there are no square braces.
+   *
+   *  * An encoded IDN, like `xn--n3h.net`.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`host()`</th></tr>
+   * <tr><td>`http://android.com/`</td><td>`"android.com"`</td></tr>
+   * <tr><td>`http://127.0.0.1/`</td><td>`"127.0.0.1"`</td></tr>
+   * <tr><td>`http://[::1]/`</td><td>`"::1"`</td></tr>
+   * <tr><td>`http://xn--n3h.net/`</td><td>`"xn--n3h.net"`</td></tr>
+   * </table>
+   */
+  fun host(): String = host
+
+  /**
+   * Returns the explicitly-specified port if one was provided, or the default port for this URL's
+   * scheme. For example, this returns 8443 for `https://square.com:8443/` and 443 for
+   * `https://square.com/`. The result is in `[1..65535]`.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`port()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`80`</td></tr>
+   * <tr><td>`http://host:8000/`</td><td>`8000`</td></tr>
+   * <tr><td>`https://host/`</td><td>`443`</td></tr>
+   * </table>
+   */
+  fun port(): Int = port
+
+  /**
+   * Returns the number of segments in this URL's path. This is also the number of slashes in the
+   * URL's path, like 3 in `http://host/a/b/c`. This is always at least 1.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`pathSize()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`1`</td></tr>
+   * <tr><td>`http://host/a/b/c`</td><td>`3`</td></tr>
+   * <tr><td>`http://host/a/b/c/`</td><td>`4`</td></tr>
+   * </table>
+   */
+  fun pathSize(): Int = pathSegments.size
+
+  /**
+   * Returns the entire path of this URL encoded for use in HTTP resource resolution. The returned
+   * path will start with `"/"`.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`encodedPath()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`"/"`</td></tr>
+   * <tr><td>`http://host/a/b/c`</td><td>`"/a/b/c"`</td></tr>
+   * <tr><td>`http://host/a/b%20c/d`</td><td>`"/a/b%20c/d"`</td></tr>
+   * </table>
+   */
+  fun encodedPath(): String {
+    val pathStart = url.indexOf('/', scheme.length + 3) // "://".length() == 3.
+    val pathEnd = delimiterOffset(url, pathStart, url.length, "?#")
+    return url.substring(pathStart, pathEnd)
+  }
+
+  /**
+   * Returns a list of encoded path segments like `["a", "b", "c"]` for the URL `http://host/a/b/c`.
+   * This list is never empty though it may contain a single empty string.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`encodedPathSegments()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`[""]`</td></tr>
+   * <tr><td>`http://host/a/b/c`</td><td>`["a", "b", "c"]`</td></tr>
+   * <tr><td>`http://host/a/b%20c/d`</td><td>`["a", "b%20c", "d"]`</td></tr>
+   * </table>
+   */
+  fun encodedPathSegments(): List<String> {
+    val pathStart = url.indexOf('/', scheme.length + 3)
+    val pathEnd = delimiterOffset(url, pathStart, url.length, "?#")
+    val result = ArrayList<String>()
+    var i = pathStart
+    while (i < pathEnd) {
+      i++ // Skip the '/'.
+      val segmentEnd = delimiterOffset(url, i, pathEnd, '/')
+      result.add(url.substring(i, segmentEnd))
+      i = segmentEnd
+    }
+    return result
+  }
+
+  /**
+   * Returns a list of path segments like `["a", "b", "c"]` for the URL `http://host/a/b/c`. This
+   * list is never empty though it may contain a single empty string.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`pathSegments()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`[""]`</td></tr>
+   * <tr><td>`http://host/a/b/c"`</td><td>`["a", "b", "c"]`</td></tr>
+   * <tr><td>`http://host/a/b%20c/d"`</td><td>`["a", "b c", "d"]`</td></tr>
+   * </table>
+   */
+  fun pathSegments(): List<String> = pathSegments
+
+  /**
+   * Returns the query of this URL, encoded for use in HTTP resource resolution. The returned string
+   * may be null (for URLs with no query), empty (for URLs with an empty query) or non-empty (all
+   * other URLs).
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`encodedQuery()`</th></tr>
+   * <tr><td>`http://host/`</td><td>null</td></tr>
+   * <tr><td>`http://host/?`</td><td>`""`</td></tr>
+   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`"a=apple&k=key+lime"`</td></tr>
+   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`"a=apple&a=apricot"`</td></tr>
+   * <tr><td>`http://host/?a=apple&b`</td><td>`"a=apple&b"`</td></tr>
+   * </table>
+   */
+  fun encodedQuery(): String? {
+    if (queryNamesAndValues == null) return null // No query.
+    val queryStart = url.indexOf('?') + 1
+    val queryEnd = delimiterOffset(url, queryStart, url.length, '#')
+    return url.substring(queryStart, queryEnd)
+  }
+
+  /**
+   * Returns this URL's query, like `"abc"` for `http://host/?abc`. Most callers should
+   * prefer [queryParameterName] and [queryParameterValue] because these methods offer direct access
+   * to individual query parameters.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`query()`</th></tr>
+   * <tr><td>`http://host/`</td><td>null</td></tr>
+   * <tr><td>`http://host/?`</td><td>`""`</td></tr>
+   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`"a=apple&k=key
+   * lime"`</td></tr>
+   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`"a=apple&a=apricot"`</td></tr>
+   * <tr><td>`http://host/?a=apple&b`</td><td>`"a=apple&b"`</td></tr>
+   * </table>
+   */
+  fun query(): String? {
+    if (queryNamesAndValues == null) return null // No query.
+    val result = StringBuilder()
+    namesAndValuesToQueryString(result, queryNamesAndValues)
+    return result.toString()
+  }
+
+  /**
+   * Returns the number of query parameters in this URL, like 2 for `http://host/?a=apple&b=banana`.
+   * If this URL has no query this returns 0. Otherwise it returns one more than the number of `"&"`
+   * separators in the query.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`querySize()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`0`</td></tr>
+   * <tr><td>`http://host/?`</td><td>`1`</td></tr>
+   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`2`</td></tr>
+   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`2`</td></tr>
+   * <tr><td>`http://host/?a=apple&b`</td><td>`2`</td></tr>
+   * </table>
+   */
+  fun querySize(): Int {
+    return if (queryNamesAndValues != null) queryNamesAndValues.size / 2 else 0
+  }
+
+  /**
+   * Returns the first query parameter named `name` decoded using UTF-8, or null if there is
+   * no such query parameter.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`queryParameter("a")`</th></tr>
+   * <tr><td>`http://host/`</td><td>null</td></tr>
+   * <tr><td>`http://host/?`</td><td>null</td></tr>
+   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`"apple"`</td></tr>
+   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`"apple"`</td></tr>
+   * <tr><td>`http://host/?a=apple&b`</td><td>`"apple"`</td></tr>
+   * </table>
+   */
+  fun queryParameter(name: String): String? {
+    if (queryNamesAndValues == null) return null
+    for (i in 0 until queryNamesAndValues.size step 2) {
+      if (name == queryNamesAndValues[i]) {
+        return queryNamesAndValues[i + 1]
+      }
+    }
+    return null
+  }
+
+  /**
+   * Returns the distinct query parameter names in this URL, like `["a", "b"]` for
+   * `http://host/?a=apple&b=banana`. If this URL has no query this returns the empty set.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`queryParameterNames()`</th></tr>
+   * <tr><td>`http://host/`</td><td>`[]`</td></tr>
+   * <tr><td>`http://host/?`</td><td>`[""]`</td></tr>
+   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`["a", "k"]`</td></tr>
+   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`["a"]`</td></tr>
+   * <tr><td>`http://host/?a=apple&b`</td><td>`["a", "b"]`</td></tr>
+   * </table>
+   */
+  fun queryParameterNames(): Set<String> {
+    if (queryNamesAndValues == null) return emptySet()
+    val result = LinkedHashSet<String>()
+    for (i in 0 until queryNamesAndValues.size step 2) {
+      result.add(queryNamesAndValues[i]!!)
+    }
+    return Collections.unmodifiableSet(result)
+  }
+
+  /**
+   * Returns all values for the query parameter `name` ordered by their appearance in this
+   * URL. For example this returns `["banana"]` for `queryParameterValue("b")` on
+   * `http://host/?a=apple&b=banana`.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`queryParameterValues("a")`</th><th>`queryParameterValues("b")`</th></tr>
+   * <tr><td>`http://host/`</td><td>`[]`</td><td>`[]`</td></tr>
+   * <tr><td>`http://host/?`</td><td>`[]`</td><td>`[]`</td></tr>
+   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`["apple"]`</td><td>`[]`</td></tr>
+   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`["apple", "apricot"]`</td><td>`[]`</td></tr>
+   * <tr><td>`http://host/?a=apple&b`</td><td>`["apple"]`</td><td>`[null]`</td></tr>
+   * </table>
+   */
+  fun queryParameterValues(name: String): List<String?> {
+    if (queryNamesAndValues == null) return emptyList()
+    val result = ArrayList<String?>()
+    for (i in 0 until queryNamesAndValues.size step 2) {
+      if (name == queryNamesAndValues[i]) {
+        result.add(queryNamesAndValues[i + 1])
+      }
+    }
+    return Collections.unmodifiableList(result)
+  }
+
+  /**
+   * Returns the name of the query parameter at `index`. For example this returns `"a"`
+   * for `queryParameterName(0)` on `http://host/?a=apple&b=banana`. This throws if
+   * `index` is not less than the [query size][querySize].
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`queryParameterName(0)`</th><th>`queryParameterName(1)`</th></tr>
+   * <tr><td>`http://host/`</td><td>exception</td><td>exception</td></tr>
+   * <tr><td>`http://host/?`</td><td>`""`</td><td>exception</td></tr>
+   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`"a"`</td><td>`"k"`</td></tr>
+   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`"a"`</td><td>`"a"`</td></tr>
+   * <tr><td>`http://host/?a=apple&b`</td><td>`"a"`</td><td>`"b"`</td></tr>
+   * </table>
+   */
+  fun queryParameterName(index: Int): String {
+    if (queryNamesAndValues == null) throw IndexOutOfBoundsException()
+    return queryNamesAndValues[index * 2]!!
+  }
+
+  /**
+   * Returns the value of the query parameter at `index`. For example this returns `"apple"` for
+   * `queryParameterName(0)` on `http://host/?a=apple&b=banana`. This throws if `index` is not less
+   * than the [query size][querySize].
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`queryParameterValue(0)`</th><th>`queryParameterValue(1)`</th></tr>
+   * <tr><td>`http://host/`</td><td>exception</td><td>exception</td></tr>
+   * <tr><td>`http://host/?`</td><td>null</td><td>exception</td></tr>
+   * <tr><td>`http://host/?a=apple&k=key+lime`</td><td>`"apple"`</td><td>`"key lime"`</td></tr>
+   * <tr><td>`http://host/?a=apple&a=apricot`</td><td>`"apple"`</td><td>`"apricot"`</td></tr>
+   * <tr><td>`http://host/?a=apple&b`</td><td>`"apple"`</td><td>null</td></tr>
+   * </table>
+   */
+  fun queryParameterValue(index: Int): String? {
+    if (queryNamesAndValues == null) throw IndexOutOfBoundsException()
+    return queryNamesAndValues[index * 2 + 1]
+  }
+
+  /**
+   * Returns this URL's encoded fragment, like `"abc"` for `http://host/#abc`. This returns null if
+   * the URL has no fragment.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`encodedFragment()`</th></tr>
+   * <tr><td>`http://host/`</td><td>null</td></tr>
+   * <tr><td>`http://host/#`</td><td>`""`</td></tr>
+   * <tr><td>`http://host/#abc`</td><td>`"abc"`</td></tr>
+   * <tr><td>`http://host/#abc|def`</td><td>`"abc|def"`</td></tr>
+   * </table>
+   */
+  fun encodedFragment(): String? {
+    if (fragment == null) return null
+    val fragmentStart = url.indexOf('#') + 1
+    return url.substring(fragmentStart)
+  }
+
+  /**
+   * Returns this URL's fragment, like `"abc"` for `http://host/#abc`. This returns null
+   * if the URL has no fragment.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`fragment()`</th></tr>
+   * <tr><td>`http://host/`</td><td>null</td></tr>
+   * <tr><td>`http://host/#`</td><td>`""`</td></tr>
+   * <tr><td>`http://host/#abc`</td><td>`"abc"`</td></tr>
+   * <tr><td>`http://host/#abc|def`</td><td>`"abc|def"`</td></tr>
+   * </table>
+   */
+  fun fragment(): String? = fragment
+
+  /**
+   * Returns a string with containing this URL with its username, password, query, and fragment
+   * stripped, and its path replaced with `/...`. For example, redacting
+   * `http://username:password@example.com/path` returns `http://example.com/...`.
+   */
+  fun redact(): String {
+    return newBuilder("/...")!!
+        .username("")
+        .password("")
+        .build()
+        .toString()
+  }
+
+  /**
+   * Returns the URL that would be retrieved by following `link` from this URL, or null if the
+   * resulting URL is not well-formed.
+   */
+  fun resolve(link: String): HttpUrl? = newBuilder(link)?.build()
+
+  fun newBuilder(): Builder {
+    val result = Builder()
+    result.scheme = scheme
+    result.encodedUsername = encodedUsername()
+    result.encodedPassword = encodedPassword()
+    result.host = host
+    // If we're set to a default port, unset it in case of a scheme change.
+    result.port = if (port != defaultPort(scheme)) port else -1
+    result.encodedPathSegments.clear()
+    result.encodedPathSegments.addAll(encodedPathSegments())
+    result.encodedQuery(encodedQuery())
+    result.encodedFragment = encodedFragment()
+    return result
+  }
+
+  /**
+   * Returns a builder for the URL that would be retrieved by following `link` from this URL,
+   * or null if the resulting URL is not well-formed.
+   */
+  fun newBuilder(link: String): Builder? {
+    try {
+      return Builder().parse(this, link)
+    } catch (ignored: IllegalArgumentException) {
+      return null
+    }
+  }
+
+  override fun equals(other: Any?): Boolean {
+    return other is HttpUrl && other.url == url
+  }
+
+  override fun hashCode(): Int = url.hashCode()
+
+  override fun toString(): String = url
+
+  /**
+   * Returns the domain name of this URL's [host] that is one level beneath the public suffix by
+   * consulting the [public suffix list](https://publicsuffix.org). Returns null if this URL's
+   * [host] is an IP address or is considered a public suffix by the public suffix list.
+   *
+   * In general this method **should not** be used to test whether a domain is valid or routable.
+   * Instead, DNS is the recommended source for that information.
+   *
+   * <table summary="">
+   * <tr><th>URL</th><th>`topPrivateDomain()`</th></tr>
+   * <tr><td>`http://google.com`</td><td>`"google.com"`</td></tr>
+   * <tr><td>`http://adwords.google.co.uk`</td><td>`"google.co.uk"`</td></tr>
+   * <tr><td>`http://square`</td><td>null</td></tr>
+   * <tr><td>`http://co.uk`</td><td>null</td></tr>
+   * <tr><td>`http://localhost`</td><td>null</td></tr>
+   * <tr><td>`http://127.0.0.1`</td><td>null</td></tr>
+   * </table>
+   */
+  fun topPrivateDomain(): String? {
+    if (verifyAsIpAddress(host)) {
+      return null
+    } else {
+      return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host)
+    }
+  }
+
+  class Builder {
+    internal var scheme: String? = null
+    internal var encodedUsername = ""
+    internal var encodedPassword = ""
+    internal var host: String? = null
+    internal var port = -1
+    internal val encodedPathSegments = mutableListOf<String>()
+    internal var encodedQueryNamesAndValues: MutableList<String?>? = null
+    internal var encodedFragment: String? = null
+
+    init {
+      encodedPathSegments.add("") // The default path is '/' which needs a trailing space.
+    }
+
+    fun scheme(scheme: String): Builder {
+      when {
+        scheme.equals("http", ignoreCase = true) -> this.scheme = "http"
+        scheme.equals("https", ignoreCase = true) -> this.scheme = "https"
+        else -> throw IllegalArgumentException("unexpected scheme: $scheme")
+      }
+      return this
+    }
+
+    fun username(username: String): Builder {
+      this.encodedUsername = canonicalize(username, USERNAME_ENCODE_SET, false, false, false, true)
+      return this
+    }
+
+    fun encodedUsername(encodedUsername: String): Builder {
+      this.encodedUsername = canonicalize(
+          encodedUsername, USERNAME_ENCODE_SET, true, false, false, true)
+      return this
+    }
+
+    fun password(password: String): Builder {
+      this.encodedPassword = canonicalize(password, PASSWORD_ENCODE_SET, false, false, false, true)
+      return this
+    }
+
+    fun encodedPassword(encodedPassword: String): Builder {
+      this.encodedPassword = canonicalize(
+          encodedPassword, PASSWORD_ENCODE_SET, true, false, false, true)
+      return this
+    }
+
+    /**
+     * @param host either a regular hostname, International Domain Name, IPv4 address, or IPv6
+     * address.
+     */
+    fun host(host: String): Builder {
+      val encoded = canonicalizeHost(host, 0, host.length) ?: throw IllegalArgumentException(
+          "unexpected host: $host")
+      this.host = encoded
+      return this
+    }
+
+    fun port(port: Int): Builder {
+      if (port <= 0 || port > 65535) throw IllegalArgumentException("unexpected port: $port")
+      this.port = port
+      return this
+    }
+
+    internal fun effectivePort(): Int {
+      return if (port != -1) port else defaultPort(scheme!!)
+    }
+
+    fun addPathSegment(pathSegment: String): Builder {
+      push(pathSegment, 0, pathSegment.length, false, false)
+      return this
+    }
+
+    /**
+     * Adds a set of path segments separated by a slash (either `\` or `/`). If `pathSegments`
+     * starts with a slash, the resulting URL will have empty path segment.
+     */
+    fun addPathSegments(pathSegments: String): Builder {
+      return addPathSegments(pathSegments, false)
+    }
+
+    fun addEncodedPathSegment(encodedPathSegment: String): Builder {
+      push(encodedPathSegment, 0, encodedPathSegment.length, false, true)
+      return this
+    }
+
+    /**
+     * Adds a set of encoded path segments separated by a slash (either `\` or `/`). If
+     * `encodedPathSegments` starts with a slash, the resulting URL will have empty path segment.
+     */
+    fun addEncodedPathSegments(encodedPathSegments: String): Builder {
+      return addPathSegments(encodedPathSegments, true)
+    }
+
+    private fun addPathSegments(pathSegments: String, alreadyEncoded: Boolean): Builder {
+      var offset = 0
+      do {
+        val segmentEnd = delimiterOffset(pathSegments, offset, pathSegments.length, "/\\")
+        val addTrailingSlash = segmentEnd < pathSegments.length
+        push(pathSegments, offset, segmentEnd, addTrailingSlash, alreadyEncoded)
+        offset = segmentEnd + 1
+      } while (offset <= pathSegments.length)
+      return this
+    }
+
+    fun setPathSegment(index: Int, pathSegment: String): Builder {
+      val canonicalPathSegment = canonicalize(pathSegment, 0, pathSegment.length,
+          PATH_SEGMENT_ENCODE_SET, false, false, false, true, null)
+      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
+        throw IllegalArgumentException("unexpected path segment: $pathSegment")
+      }
+      encodedPathSegments[index] = canonicalPathSegment
+      return this
+    }
+
+    fun setEncodedPathSegment(index: Int, encodedPathSegment: String): Builder {
+      val canonicalPathSegment = canonicalize(encodedPathSegment, 0, encodedPathSegment.length,
+          PATH_SEGMENT_ENCODE_SET, true, false, false, true, null)
+      encodedPathSegments[index] = canonicalPathSegment
+      if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
+        throw IllegalArgumentException("unexpected path segment: $encodedPathSegment")
+      }
+      return this
+    }
+
+    fun removePathSegment(index: Int): Builder {
+      encodedPathSegments.removeAt(index)
+      if (encodedPathSegments.isEmpty()) {
+        encodedPathSegments.add("") // Always leave at least one '/'.
+      }
+      return this
+    }
+
+    fun encodedPath(encodedPath: String): Builder {
+      if (!encodedPath.startsWith("/")) {
+        throw IllegalArgumentException("unexpected encodedPath: $encodedPath")
+      }
+      resolvePath(encodedPath, 0, encodedPath.length)
+      return this
+    }
+
+    fun query(query: String?): Builder {
+      this.encodedQueryNamesAndValues = if (query != null) {
+        queryStringToNamesAndValues(canonicalize(query, QUERY_ENCODE_SET, false, false, true, true))
+      } else {
+        null
+      }
+      return this
+    }
+
+    fun encodedQuery(encodedQuery: String?): Builder {
+      this.encodedQueryNamesAndValues = if (encodedQuery != null) {
+        queryStringToNamesAndValues(
+            canonicalize(encodedQuery, QUERY_ENCODE_SET, true, false, true, true))
+      } else {
+        null
+      }
+      return this
+    }
+
+    /** Encodes the query parameter using UTF-8 and adds it to this URL's query string.  */
+    fun addQueryParameter(name: String, value: String?): Builder {
+      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = ArrayList()
+      encodedQueryNamesAndValues!!.add(
+          canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true))
+      encodedQueryNamesAndValues!!.add(if (value != null) {
+        canonicalize(value, QUERY_COMPONENT_ENCODE_SET, false, false, true, true)
+      } else {
+        null
+      })
+      return this
+    }
+
+    /** Adds the pre-encoded query parameter to this URL's query string.  */
+    fun addEncodedQueryParameter(encodedName: String, encodedValue: String?): Builder {
+      if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = ArrayList()
+      encodedQueryNamesAndValues!!.add(
+          canonicalize(encodedName, QUERY_COMPONENT_REENCODE_SET, true, false, true, true))
+      encodedQueryNamesAndValues!!.add(if (encodedValue != null) {
+        canonicalize(encodedValue, QUERY_COMPONENT_REENCODE_SET, true, false, true, true)
+      } else {
+        null
+      })
+      return this
+    }
+
+    fun setQueryParameter(name: String, value: String?): Builder {
+      removeAllQueryParameters(name)
+      addQueryParameter(name, value)
+      return this
+    }
+
+    fun setEncodedQueryParameter(encodedName: String, encodedValue: String?): Builder {
+      removeAllEncodedQueryParameters(encodedName)
+      addEncodedQueryParameter(encodedName, encodedValue)
+      return this
+    }
+
+    fun removeAllQueryParameters(name: String): Builder {
+      if (encodedQueryNamesAndValues == null) return this
+      val nameToRemove = canonicalize(name, QUERY_COMPONENT_ENCODE_SET, false, false, true, true)
+      removeAllCanonicalQueryParameters(nameToRemove)
+      return this
+    }
+
+    fun removeAllEncodedQueryParameters(encodedName: String): Builder {
+      if (encodedQueryNamesAndValues == null) return this
+      removeAllCanonicalQueryParameters(
+          canonicalize(encodedName, QUERY_COMPONENT_REENCODE_SET, true, false, true, true))
+      return this
+    }
+
+    private fun removeAllCanonicalQueryParameters(canonicalName: String) {
+      var i = encodedQueryNamesAndValues!!.size - 2
+      while (i >= 0) {
+        if (canonicalName == encodedQueryNamesAndValues!![i]) {
+          encodedQueryNamesAndValues!!.removeAt(i + 1)
+          encodedQueryNamesAndValues!!.removeAt(i)
+          if (encodedQueryNamesAndValues!!.isEmpty()) {
+            encodedQueryNamesAndValues = null
+            return
+          }
+        }
+        i -= 2
+      }
+    }
+
+    fun fragment(fragment: String?): Builder {
+      this.encodedFragment = if (fragment != null) {
+        canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false, false, false)
+      } else {
+        null
+      }
+      return this
+    }
+
+    fun encodedFragment(encodedFragment: String?): Builder {
+      this.encodedFragment = if (encodedFragment != null) {
+        canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false, false, false)
+      } else {
+        null
+      }
+      return this
+    }
+
+    /**
+     * Re-encodes the components of this URL so that it satisfies (obsolete) RFC 2396, which is
+     * particularly strict for certain components.
+     */
+    internal fun reencodeForUri(): Builder {
+      for (i in 0 until encodedPathSegments.size) {
+        val pathSegment = encodedPathSegments[i]
+        encodedPathSegments[i] =
+            canonicalize(pathSegment, PATH_SEGMENT_ENCODE_SET_URI, true, true, false, true)
+      }
+      if (encodedQueryNamesAndValues != null) {
+        for (i in 0 until encodedQueryNamesAndValues!!.size) {
+          val component = encodedQueryNamesAndValues!![i]
+          if (component != null) {
+            encodedQueryNamesAndValues!![i] =
+                canonicalize(component, QUERY_COMPONENT_ENCODE_SET_URI, true, true, true, true)
+          }
+        }
+      }
+      if (encodedFragment != null) {
+        encodedFragment = canonicalize(
+            encodedFragment!!, FRAGMENT_ENCODE_SET_URI, true, true, false, false)
+      }
+      return this
+    }
+
+    fun build(): HttpUrl = HttpUrl(this)
+
+    override fun toString(): String {
+      val result = StringBuilder()
+      if (scheme != null) {
+        result.append(scheme)
+        result.append("://")
+      } else {
+        result.append("//")
+      }
+
+      if (!encodedUsername.isEmpty() || !encodedPassword.isEmpty()) {
+        result.append(encodedUsername)
+        if (!encodedPassword.isEmpty()) {
+          result.append(':')
+          result.append(encodedPassword)
+        }
+        result.append('@')
+      }
+
+      if (host != null) {
+        if (host!!.indexOf(':') != -1) {
+          // Host is an IPv6 address.
+          result.append('[')
+          result.append(host)
+          result.append(']')
+        } else {
+          result.append(host)
+        }
+      }
+
+      if (port != -1 || scheme != null) {
+        val effectivePort = effectivePort()
+        if (scheme == null || effectivePort != defaultPort(scheme!!)) {
+          result.append(':')
+          result.append(effectivePort)
+        }
+      }
+
+      pathSegmentsToString(result, encodedPathSegments)
+
+      if (encodedQueryNamesAndValues != null) {
+        result.append('?')
+        namesAndValuesToQueryString(result, encodedQueryNamesAndValues!!)
+      }
+
+      if (encodedFragment != null) {
+        result.append('#')
+        result.append(encodedFragment)
+      }
+
+      return result.toString()
+    }
+
+    internal fun parse(base: HttpUrl?, input: String): Builder {
+      var pos = skipLeadingAsciiWhitespace(input, 0, input.length)
+      val limit = skipTrailingAsciiWhitespace(input, pos, input.length)
+
+      // Scheme.
+      val schemeDelimiterOffset = schemeDelimiterOffset(input, pos, limit)
+      if (schemeDelimiterOffset != -1) {
+        if (input.regionMatches(pos, "https:", 0, 6, ignoreCase = true)) {
+          this.scheme = "https"
+          pos += "https:".length
+        } else if (input.regionMatches(pos, "http:", 0, 5, ignoreCase = true)) {
+          this.scheme = "http"
+          pos += "http:".length
+        } else {
+          throw IllegalArgumentException("Expected URL scheme 'http' or 'https' but was '"
+              + input.substring(0, schemeDelimiterOffset) + "'")
+        }
+      } else if (base != null) {
+        this.scheme = base.scheme
+      } else {
+        throw IllegalArgumentException(
+            "Expected URL scheme 'http' or 'https' but no colon was found")
+      }
+
+      // Authority.
+      var hasUsername = false
+      var hasPassword = false
+      val slashCount = slashCount(input, pos, limit)
+      if (slashCount >= 2 || base == null || base.scheme != this.scheme) {
+        // Read an authority if either:
+        //  * The input starts with 2 or more slashes. These follow the scheme if it exists.
+        //  * The input scheme exists and is different from the base URL's scheme.
+        //
+        // The structure of an authority is:
+        //   username:password@host:port
+        //
+        // Username, password and port are optional.
+        //   [username[:password]@]host[:port]
+        pos += slashCount
+        authority@ while (true) {
+          val componentDelimiterOffset = delimiterOffset(input, pos, limit, "@/\\?#")
+          val c = if (componentDelimiterOffset != limit) {
+            input[componentDelimiterOffset].toInt()
+          } else {
+            -1
+          }
+          when (c) {
+            '@'.toInt() -> {
+              // User info precedes.
+              if (!hasPassword) {
+                val passwordColonOffset = delimiterOffset(
+                    input, pos, componentDelimiterOffset, ':')
+                val canonicalUsername = canonicalize(input, pos, passwordColonOffset,
+                    USERNAME_ENCODE_SET, true, false, false, true, null)
+                this.encodedUsername = if (hasUsername) {
+                  this.encodedUsername + "%40" + canonicalUsername
+                } else {
+                  canonicalUsername
+                }
+                if (passwordColonOffset != componentDelimiterOffset) {
+                  hasPassword = true
+                  this.encodedPassword = canonicalize(input, passwordColonOffset + 1,
+                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true, null)
+                }
+                hasUsername = true
+              } else {
+                this.encodedPassword = this.encodedPassword + "%40" + canonicalize(input, pos,
+                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true, null)
+              }
+              pos = componentDelimiterOffset + 1
+            }
+
+            -1, '/'.toInt(), '\\'.toInt(), '?'.toInt(), '#'.toInt() -> {
+              // Host info precedes.
+              val portColonOffset = portColonOffset(input, pos, componentDelimiterOffset)
+              if (portColonOffset + 1 < componentDelimiterOffset) {
+                host = canonicalizeHost(input, pos, portColonOffset)
+                port = parsePort(input, portColonOffset + 1, componentDelimiterOffset)
+                require(port != -1) {
+                  "Invalid URL port: \"${input.substring(portColonOffset + 1,
+                      componentDelimiterOffset)}\""
+                }
+              } else {
+                host = canonicalizeHost(input, pos, portColonOffset)
+                port = defaultPort(scheme!!)
+              }
+              require(host != null) {
+                "$INVALID_HOST: \"${input.substring(pos, portColonOffset)}\""
+              }
+              pos = componentDelimiterOffset
+              break@authority
+            }
+          }
+        }
+      } else {
+        // This is a relative link. Copy over all authority components. Also maybe the path & query.
+        this.encodedUsername = base.encodedUsername()
+        this.encodedPassword = base.encodedPassword()
+        this.host = base.host
+        this.port = base.port
+        this.encodedPathSegments.clear()
+        this.encodedPathSegments.addAll(base.encodedPathSegments())
+        if (pos == limit || input[pos] == '#') {
+          encodedQuery(base.encodedQuery())
+        }
+      }
+
+      // Resolve the relative path.
+      val pathDelimiterOffset = delimiterOffset(input, pos, limit, "?#")
+      resolvePath(input, pos, pathDelimiterOffset)
+      pos = pathDelimiterOffset
+
+      // Query.
+      if (pos < limit && input[pos] == '?') {
+        val queryDelimiterOffset = delimiterOffset(input, pos, limit, '#')
+        this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
+            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true, null))
+        pos = queryDelimiterOffset
+      }
+
+      // Fragment.
+      if (pos < limit && input[pos] == '#') {
+        this.encodedFragment = canonicalize(
+            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false, null)
+      }
+
+      return this
+    }
+
+    private fun resolvePath(input: String, startPos: Int, limit: Int) {
+      var pos = startPos
+      // Read a delimiter.
+      if (pos == limit) {
+        // Empty path: keep the base path as-is.
+        return
+      }
+      val c = input[pos]
+      if (c == '/' || c == '\\') {
+        // Absolute path: reset to the default "/".
+        encodedPathSegments.clear()
+        encodedPathSegments.add("")
+        pos++
+      } else {
+        // Relative path: clear everything after the last '/'.
+        encodedPathSegments[encodedPathSegments.size - 1] = ""
+      }
+
+      // Read path segments.
+      var i = pos
+      while (i < limit) {
+        val pathSegmentDelimiterOffset = delimiterOffset(input, i, limit, "/\\")
+        val segmentHasTrailingSlash = pathSegmentDelimiterOffset < limit
+        push(input, i, pathSegmentDelimiterOffset, segmentHasTrailingSlash, true)
+        i = pathSegmentDelimiterOffset
+        if (segmentHasTrailingSlash) i++
+      }
+    }
+
+    /** Adds a path segment. If the input is ".." or equivalent, this pops a path segment.  */
+    private fun push(
+      input: String, pos: Int, limit: Int, addTrailingSlash: Boolean,
+      alreadyEncoded: Boolean
+    ) {
+      val segment = canonicalize(
+          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false, false, true, null)
+      if (isDot(segment)) {
+        return  // Skip '.' path segments.
+      }
+      if (isDotDot(segment)) {
+        pop()
+        return
+      }
+      if (encodedPathSegments[encodedPathSegments.size - 1].isEmpty()) {
+        encodedPathSegments[encodedPathSegments.size - 1] = segment
+      } else {
+        encodedPathSegments.add(segment)
+      }
+      if (addTrailingSlash) {
+        encodedPathSegments.add("")
+      }
+    }
+
+    private fun isDot(input: String): Boolean {
+      return input == "." || input.equals("%2e", ignoreCase = true)
+    }
+
+    private fun isDotDot(input: String): Boolean {
+      return (input == ".."
+          || input.equals("%2e.", ignoreCase = true)
+          || input.equals(".%2e", ignoreCase = true)
+          || input.equals("%2e%2e", ignoreCase = true))
+    }
+
+    /**
+     * Removes a path segment. When this method returns the last segment is always "", which means
+     * the encoded path will have a trailing '/'.
+     *
+     * Popping "/a/b/c/" yields "/a/b/". In this case the list of path segments goes from ["a",
+     * "b", "c", ""] to ["a", "b", ""].
+     *
+     * Popping "/a/b/c" also yields "/a/b/". The list of path segments goes from ["a", "b", "c"]
+     * to ["a", "b", ""].
+     */
+    private fun pop() {
+      val removed = encodedPathSegments.removeAt(encodedPathSegments.size - 1)
+
+      // Make sure the path ends with a '/' by either adding an empty string or clearing a segment.
+      if (removed.isEmpty() && !encodedPathSegments.isEmpty()) {
+        encodedPathSegments[encodedPathSegments.size - 1] = ""
+      } else {
+        encodedPathSegments.add("")
+      }
+    }
+
+    companion object {
+      internal const val INVALID_HOST = "Invalid URL host"
+
+      /**
+       * Returns the index of the ':' in `input` that is after scheme characters. Returns -1 if
+       * `input` does not have a scheme that starts at `pos`.
+       */
+      @JvmStatic
+      private fun schemeDelimiterOffset(input: String, pos: Int, limit: Int): Int {
+        if (limit - pos < 2) return -1
+
+        val c0 = input[pos]
+        if ((c0 < 'a' || c0 > 'z') && (c0 < 'A' || c0 > 'Z')) return -1 // Not a scheme start char.
+
+        for (i in pos + 1 until limit) {
+          val c = input[i]
+
+          if (c >= 'a' && c <= 'z'
+              || c >= 'A' && c <= 'Z'
+              || c >= '0' && c <= '9'
+              || c == '+'
+              || c == '-'
+              || c == '.') {
+            continue // Scheme character. Keep going.
+          } else if (c == ':') {
+            return i // Scheme prefix!
+          } else {
+            return -1 // Non-scheme character before the first ':'.
+          }
+        }
+
+        return -1 // No ':'; doesn't start with a scheme.
+      }
+
+      /** Returns the number of '/' and '\' slashes in `input`, starting at `pos`.  */
+      @JvmStatic
+      private fun slashCount(input: String, pos: Int, limit: Int): Int {
+        var slashCount = 0
+        for (i in pos until limit) {
+          val c = input[i]
+          if (c == '\\' || c == '/') {
+            slashCount++
+          } else {
+            break
+          }
+        }
+        return slashCount
+      }
+
+      /** Finds the first ':' in `input`, skipping characters between square braces "[...]".  */
+      @JvmStatic
+      private fun portColonOffset(input: String, pos: Int, limit: Int): Int {
+        var i = pos
+        while (i < limit) {
+          when (input[i]) {
+            '[' -> {
+              while (++i < limit) {
+                if (input[i] == ']') break
+              }
+            }
+            ':' -> return i
+          }
+          i++
+        }
+        return limit // No colon.
+      }
+
+      @JvmStatic
+      private fun canonicalizeHost(input: String, pos: Int, limit: Int): String? {
+        // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
+        // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
+        val percentDecoded = percentDecode(input, pos, limit, false)
+        return Util.canonicalizeHost(percentDecoded)
+      }
+
+      @JvmStatic
+      private fun parsePort(input: String, pos: Int, limit: Int): Int {
+        try {
+          // Canonicalize the port string to skip '\n' etc.
+          val portString = canonicalize(input, pos, limit, "", false, false, false, true, null)
+          val i = Integer.parseInt(portString)
+          return if (i > 0 && i <= 65535) i else -1
+        } catch (e: NumberFormatException) {
+          return -1 // Invalid port.
+        }
+
+      }
+    }
+  }
+
+  private fun percentDecode(list: List<String?>, plusIsSpace: Boolean): List<String?> {
+    val size = list.size
+    val result = ArrayList<String?>(size)
+    for (i in 0 until size) {
+      val s = list[i]
+      result.add(if (s != null) percentDecode(s, plusIsSpace) else null)
+    }
+    return Collections.unmodifiableList(result)
+  }
+
+  companion object {
+    @JvmStatic
+    private val HEX_DIGITS =
+        charArrayOf('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F')
+    internal const val USERNAME_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#"
+    internal const val PASSWORD_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#"
+    internal const val PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#"
+    internal const val PATH_SEGMENT_ENCODE_SET_URI = "[]"
+    internal const val QUERY_ENCODE_SET = " \"'<>#"
+    internal const val QUERY_COMPONENT_REENCODE_SET = " \"'<>#&="
+    internal const val QUERY_COMPONENT_ENCODE_SET = " !\"#$&'(),/:;<=>?@[]\\^`{|}~"
+    internal const val QUERY_COMPONENT_ENCODE_SET_URI = "\\^`{|}"
+    internal const val FORM_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#&!$(),~"
+    internal const val FRAGMENT_ENCODE_SET = ""
+    internal const val FRAGMENT_ENCODE_SET_URI = " \"#<>\\^`{|}"
+
+    /** Returns 80 if `scheme.equals("http")`, 443 if `scheme.equals("https")` and -1 otherwise. */
+    @JvmStatic
+    fun defaultPort(scheme: String): Int {
+      return when (scheme) {
+        "http" -> 80
+        "https" -> 443
+        else -> -1
+      }
+    }
+
+    @JvmStatic
+    internal fun pathSegmentsToString(out: StringBuilder, pathSegments: List<String>) {
+      for (i in 0 until pathSegments.size) {
+        out.append('/')
+        out.append(pathSegments[i])
+      }
+    }
+
+    @JvmStatic
+    internal fun namesAndValuesToQueryString(out: StringBuilder, namesAndValues: List<String?>) {
+      for (i in 0 until namesAndValues.size step 2) {
+        val name = namesAndValues[i]
+        val value = namesAndValues[i + 1]
+        if (i > 0) out.append('&')
+        out.append(name)
+        if (value != null) {
+          out.append('=')
+          out.append(value)
+        }
+      }
+    }
+
+    /**
+     * Cuts `encodedQuery` up into alternating parameter names and values. This divides a query
+     * string like `subject=math&easy&problem=5-2=3` into the list `["subject", "math", "easy",
+     * null, "problem", "5-2=3"]`. Note that values may be null and may contain '=' characters.
+     */
+    @JvmStatic
+    internal fun queryStringToNamesAndValues(encodedQuery: String): MutableList<String?> {
+      val result = mutableListOf<String?>()
+      var pos = 0
+      while (pos <= encodedQuery.length) {
+        var ampersandOffset = encodedQuery.indexOf('&', pos)
+        if (ampersandOffset == -1) ampersandOffset = encodedQuery.length
+
+        val equalsOffset = encodedQuery.indexOf('=', pos)
+        if (equalsOffset == -1 || equalsOffset > ampersandOffset) {
+          result.add(encodedQuery.substring(pos, ampersandOffset))
+          result.add(null) // No value for this name.
+        } else {
+          result.add(encodedQuery.substring(pos, equalsOffset))
+          result.add(encodedQuery.substring(equalsOffset + 1, ampersandOffset))
+        }
+        pos = ampersandOffset + 1
+      }
+      return result
+    }
+
+    /**
+     * Returns a new `HttpUrl` representing `url` if it is a well-formed HTTP or HTTPS URL, or null
+     * if it isn't.
+     */
+    @JvmStatic
+    fun parse(url: String): HttpUrl? {
+      try {
+        return get(url)
+      } catch (ignored: IllegalArgumentException) {
+        return null
+      }
+    }
+
+    /**
+     * Returns a new `HttpUrl` representing `url`.
+     *
+     * @throws IllegalArgumentException If `url` is not a well-formed HTTP or HTTPS URL.
+     */
+    @JvmStatic
+    operator fun get(url: String): HttpUrl = Builder().parse(null, url).build()
+
+    /**
+     * Returns an [HttpUrl] for `url` if its protocol is `http` or `https`, or
+     * null if it has any other protocol.
+     */
+    @JvmStatic
+    operator fun get(url: URL): HttpUrl? = parse(url.toString())
+
+    @JvmStatic
+    operator fun get(uri: URI): HttpUrl? = parse(uri.toString())
+
+    @JvmStatic
+    internal fun percentDecode(encoded: String, plusIsSpace: Boolean): String =
+        percentDecode(encoded, 0, encoded.length, plusIsSpace)
+
+    @JvmStatic
+    internal fun percentDecode(
+      encoded: String,
+      pos: Int,
+      limit: Int,
+      plusIsSpace: Boolean
+    ): String {
+      for (i in pos until limit) {
+        val c = encoded[i]
+        if (c == '%' || c == '+' && plusIsSpace) {
+          // Slow path: the character at i requires decoding!
+          val out = Buffer()
+          out.writeUtf8(encoded, pos, i)
+          percentDecode(out, encoded, i, limit, plusIsSpace)
+          return out.readUtf8()
+        }
+      }
+
+      // Fast path: no characters in [pos..limit) required decoding.
+      return encoded.substring(pos, limit)
+    }
+
+    @JvmStatic
+    internal fun percentDecode(
+      out: Buffer,
+      encoded: String,
+      pos: Int,
+      limit: Int,
+      plusIsSpace: Boolean
+    ) {
+      var codePoint: Int
+      var i = pos
+      while (i < limit) {
+        codePoint = encoded.codePointAt(i)
+        if (codePoint == '%'.toInt() && i + 2 < limit) {
+          val d1 = decodeHexDigit(encoded[i + 1])
+          val d2 = decodeHexDigit(encoded[i + 2])
+          if (d1 != -1 && d2 != -1) {
+            out.writeByte((d1 shl 4) + d2)
+            i += 2
+            i += Character.charCount(codePoint)
+            continue
+          }
+        } else if (codePoint == '+'.toInt() && plusIsSpace) {
+          out.writeByte(' '.toInt())
+          i++
+          continue
+        }
+        out.writeUtf8CodePoint(codePoint)
+        i += Character.charCount(codePoint)
+      }
+    }
+
+    @JvmStatic
+    internal fun percentEncoded(encoded: String, pos: Int, limit: Int): Boolean {
+      return (pos + 2 < limit
+          && encoded[pos] == '%'
+          && decodeHexDigit(encoded[pos + 1]) != -1
+          && decodeHexDigit(encoded[pos + 2]) != -1)
+    }
+
+    /**
+     * Returns a substring of `input` on the range `[pos..limit)` with the following
+     * transformations:
+     *
+     *  * Tabs, newlines, form feeds and carriage returns are skipped.
+     *
+     *  * In queries, ' ' is encoded to '+' and '+' is encoded to "%2B".
+     *
+     *  * Characters in `encodeSet` are percent-encoded.
+     *
+     *  * Control characters and non-ASCII characters are percent-encoded.
+     *
+     *  * All other characters are copied without transformation.
+     *
+     * @param alreadyEncoded true to leave '%' as-is; false to convert it to '%25'.
+     * @param strict true to encode '%' if it is not the prefix of a valid percent encoding.
+     * @param plusIsSpace true to encode '+' as "%2B" if it is not already encoded.
+     * @param asciiOnly true to encode all non-ASCII codepoints.
+     * @param charset which charset to use, null equals UTF-8.
+     */
+    @JvmStatic
+    internal fun canonicalize(
+      input: String, pos: Int, limit: Int, encodeSet: String,
+      alreadyEncoded: Boolean, strict: Boolean, plusIsSpace: Boolean, asciiOnly: Boolean,
+      charset: Charset?
+    ): String {
+      var codePoint: Int
+      var i = pos
+      while (i < limit) {
+        codePoint = input.codePointAt(i)
+        if (codePoint < 0x20
+            || codePoint == 0x7f
+            || codePoint >= 0x80 && asciiOnly
+            || encodeSet.indexOf(codePoint.toChar()) != -1
+            || codePoint == '%'.toInt() && (!alreadyEncoded || strict && !percentEncoded(input, i,
+                limit))
+            || codePoint == '+'.toInt() && plusIsSpace) {
+          // Slow path: the character at i requires encoding!
+          val out = Buffer()
+          out.writeUtf8(input, pos, i)
+          canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, strict, plusIsSpace,
+              asciiOnly, charset)
+          return out.readUtf8()
+        }
+        i += Character.charCount(codePoint)
+      }
+
+      // Fast path: no characters in [pos..limit) required encoding.
+      return input.substring(pos, limit)
+    }
+
+    @JvmStatic
+    internal fun canonicalize(
+      out: Buffer, input: String, pos: Int, limit: Int, encodeSet: String,
+      alreadyEncoded: Boolean, strict: Boolean, plusIsSpace: Boolean, asciiOnly: Boolean,
+      charset: Charset?
+    ) {
+      var encodedCharBuffer: Buffer? = null // Lazily allocated.
+      var codePoint: Int
+      var i = pos
+      while (i < limit) {
+        codePoint = input.codePointAt(i)
+        if (alreadyEncoded && (codePoint == '\t'.toInt() || codePoint == '\n'.toInt() || codePoint == '\u000c'.toInt() || codePoint == '\r'.toInt())) {
+          // Skip this character.
+        } else if (codePoint == '+'.toInt() && plusIsSpace) {
+          // Encode '+' as '%2B' since we permit ' ' to be encoded as either '+' or '%20'.
+          out.writeUtf8(if (alreadyEncoded) "+" else "%2B")
+        } else if (codePoint < 0x20
+            || codePoint == 0x7f
+            || codePoint >= 0x80 && asciiOnly
+            || encodeSet.indexOf(codePoint.toChar()) != -1
+            || codePoint == '%'.toInt() && (!alreadyEncoded || strict && !percentEncoded(input, i,
+                limit))) {
+          // Percent encode this character.
+          if (encodedCharBuffer == null) {
+            encodedCharBuffer = Buffer()
+          }
+
+          if (charset == null || charset == UTF_8) {
+            encodedCharBuffer.writeUtf8CodePoint(codePoint)
+          } else {
+            encodedCharBuffer.writeString(input, i, i + Character.charCount(codePoint), charset)
+          }
+
+          while (!encodedCharBuffer.exhausted()) {
+            val b = encodedCharBuffer.readByte().toInt() and 0xff
+            out.writeByte('%'.toInt())
+            out.writeByte(HEX_DIGITS[b shr 4 and 0xf].toInt())
+            out.writeByte(HEX_DIGITS[b and 0xf].toInt())
+          }
+        } else {
+          // This character doesn't need encoding. Just copy it over.
+          out.writeUtf8CodePoint(codePoint)
+        }
+        i += Character.charCount(codePoint)
+      }
+    }
+
+    @JvmStatic
+    internal fun canonicalize(
+      input: String, encodeSet: String, alreadyEncoded: Boolean, strict: Boolean,
+      plusIsSpace: Boolean, asciiOnly: Boolean, charset: Charset?
+    ): String = canonicalize(input, 0, input.length, encodeSet, alreadyEncoded, strict, plusIsSpace,
+        asciiOnly, charset)
+
+    @JvmStatic
+    internal fun canonicalize(
+      input: String, encodeSet: String, alreadyEncoded: Boolean, strict: Boolean,
+      plusIsSpace: Boolean, asciiOnly: Boolean
+    ): String = canonicalize(
+        input, 0, input.length, encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly, null)
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Interceptor.java b/okhttp/src/main/java/okhttp3/Interceptor.kt
similarity index 62%
rename from okhttp/src/main/java/okhttp3/Interceptor.java
rename to okhttp/src/main/java/okhttp3/Interceptor.kt
index 1005592697..6e050bb125 100644
--- a/okhttp/src/main/java/okhttp3/Interceptor.java
+++ b/okhttp/src/main/java/okhttp3/Interceptor.kt
@@ -13,43 +13,44 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3;
+package okhttp3
 
-import java.io.IOException;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
+import java.io.IOException
+import java.util.concurrent.TimeUnit
 
 /**
  * Observes, modifies, and potentially short-circuits requests going out and the corresponding
  * responses coming back in. Typically interceptors add, remove, or transform headers on the request
  * or response.
  */
-public interface Interceptor {
-  Response intercept(Chain chain) throws IOException;
+interface Interceptor {
+  @Throws(IOException::class)
+  fun intercept(chain: Chain): Response
 
   interface Chain {
-    Request request();
+    fun request(): Request
 
-    Response proceed(Request request) throws IOException;
+    @Throws(IOException::class)
+    fun proceed(request: Request): Response
 
     /**
      * Returns the connection the request will be executed on. This is only available in the chains
      * of network interceptors; for application interceptors this is always null.
      */
-    @Nullable Connection connection();
+    fun connection(): Connection?
 
-    Call call();
+    fun call(): Call
 
-    int connectTimeoutMillis();
+    fun connectTimeoutMillis(): Int
 
-    Chain withConnectTimeout(int timeout, TimeUnit unit);
+    fun withConnectTimeout(timeout: Int, unit: TimeUnit): Chain
 
-    int readTimeoutMillis();
+    fun readTimeoutMillis(): Int
 
-    Chain withReadTimeout(int timeout, TimeUnit unit);
+    fun withReadTimeout(timeout: Int, unit: TimeUnit): Chain
 
-    int writeTimeoutMillis();
+    fun writeTimeoutMillis(): Int
 
-    Chain withWriteTimeout(int timeout, TimeUnit unit);
+    fun withWriteTimeout(timeout: Int, unit: TimeUnit): Chain
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/MediaType.java b/okhttp/src/main/java/okhttp3/MediaType.java
deleted file mode 100644
index 95194c5711..0000000000
--- a/okhttp/src/main/java/okhttp3/MediaType.java
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.nio.charset.Charset;
-import java.util.Locale;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import javax.annotation.Nullable;
-
-/**
- * An <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a> Media Type, appropriate to describe
- * the content type of an HTTP request or response body.
- */
-public final class MediaType {
-  private static final String TOKEN = "([a-zA-Z0-9-!#$%&'*+.^_`{|}~]+)";
-  private static final String QUOTED = "\"([^\"]*)\"";
-  private static final Pattern TYPE_SUBTYPE = Pattern.compile(TOKEN + "/" + TOKEN);
-  private static final Pattern PARAMETER = Pattern.compile(
-      ";\\s*(?:" + TOKEN + "=(?:" + TOKEN + "|" + QUOTED + "))?");
-
-  private final String mediaType;
-  private final String type;
-  private final String subtype;
-  private final @Nullable String charset;
-
-  private MediaType(String mediaType, String type, String subtype, @Nullable String charset) {
-    this.mediaType = mediaType;
-    this.type = type;
-    this.subtype = subtype;
-    this.charset = charset;
-  }
-
-  /**
-   * Returns a media type for {@code string}, or null if {@code string} is not a well-formed media
-   * type.
-   */
-  public static @Nullable MediaType parse(String string) {
-    Matcher typeSubtype = TYPE_SUBTYPE.matcher(string);
-    if (!typeSubtype.lookingAt()) return null;
-    String type = typeSubtype.group(1).toLowerCase(Locale.US);
-    String subtype = typeSubtype.group(2).toLowerCase(Locale.US);
-
-    String charset = null;
-    Matcher parameter = PARAMETER.matcher(string);
-    for (int s = typeSubtype.end(); s < string.length(); s = parameter.end()) {
-      parameter.region(s, string.length());
-      if (!parameter.lookingAt()) return null; // This is not a well-formed media type.
-
-      String name = parameter.group(1);
-      if (name == null || !name.equalsIgnoreCase("charset")) continue;
-      String charsetParameter;
-      String token = parameter.group(2);
-      if (token != null) {
-        // If the token is 'single-quoted' it's invalid! But we're lenient and strip the quotes.
-        charsetParameter = (token.startsWith("'") && token.endsWith("'") && token.length() > 2)
-            ? token.substring(1, token.length() - 1)
-            : token;
-      } else {
-        // Value is "double-quoted". That's valid and our regex group already strips the quotes.
-        charsetParameter = parameter.group(3);
-      }
-      if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
-        return null; // Multiple different charsets!
-      }
-      charset = charsetParameter;
-    }
-
-    return new MediaType(string, type, subtype, charset);
-  }
-
-  /**
-   * Returns the high-level media type, such as "text", "image", "audio", "video", or
-   * "application".
-   */
-  public String type() {
-    return type;
-  }
-
-  /**
-   * Returns a specific media subtype, such as "plain" or "png", "mpeg", "mp4" or "xml".
-   */
-  public String subtype() {
-    return subtype;
-  }
-
-  /**
-   * Returns the charset of this media type, or null if this media type doesn't specify a charset.
-   */
-  public @Nullable Charset charset() {
-    return charset(null);
-  }
-
-  /**
-   * Returns the charset of this media type, or {@code defaultValue} if either this media type
-   * doesn't specify a charset, of it its charset is unsupported by the current runtime.
-   */
-  public @Nullable Charset charset(@Nullable Charset defaultValue) {
-    try {
-      return charset != null ? Charset.forName(charset) : defaultValue;
-    } catch (IllegalArgumentException e) {
-      return defaultValue; // This charset is invalid or unsupported. Give up.
-    }
-  }
-
-  /**
-   * Returns the encoded media type, like "text/plain; charset=utf-8", appropriate for use in a
-   * Content-Type header.
-   */
-  @Override public String toString() {
-    return mediaType;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof MediaType && ((MediaType) other).mediaType.equals(mediaType);
-  }
-
-  @Override public int hashCode() {
-    return mediaType.hashCode();
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/MediaType.kt b/okhttp/src/main/java/okhttp3/MediaType.kt
new file mode 100644
index 0000000000..6644c0c632
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/MediaType.kt
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.nio.charset.Charset
+import java.util.Locale
+import java.util.regex.Pattern
+
+/**
+ * An [RFC 2045][rfc_2045] Media Type, appropriate to describe the content type of an HTTP request
+ * or response body.
+ *
+ * [rfc_2045]: http://tools.ietf.org/html/rfc2045
+ */
+class MediaType private constructor(
+  private val mediaType: String,
+  val type: String,
+  val subtype: String,
+  private val charset: String?
+) {
+  /**
+   * Returns the charset of this media type, or `defaultValue` if either this media type
+   * doesn't specify a charset, of it its charset is unsupported by the current runtime.
+   */
+  @JvmOverloads
+  fun charset(defaultValue: Charset? = null): Charset? {
+    try {
+      return if (charset != null) Charset.forName(charset) else defaultValue
+    } catch (e: IllegalArgumentException) {
+      return defaultValue // This charset is invalid or unsupported. Give up.
+    }
+  }
+
+  /**
+   * Returns the high-level media type, such as "text", "image", "audio", "video", or
+   * "application".
+   */
+  fun type() = type
+
+  /**
+   * Returns a specific media subtype, such as "plain" or "png", "mpeg", "mp4" or "xml".
+   */
+  fun subtype() = subtype
+
+  /**
+   * Returns the encoded media type, like "text/plain; charset=utf-8", appropriate for use in a
+   * Content-Type header.
+   */
+  override fun toString(): String = mediaType
+
+  override fun equals(other: Any?): Boolean = other is MediaType && other.mediaType == mediaType
+
+  override fun hashCode(): Int = mediaType.hashCode()
+
+  companion object {
+    private const val TOKEN = "([a-zA-Z0-9-!#$%&'*+.^_`{|}~]+)"
+    private const val QUOTED = "\"([^\"]*)\""
+    private val TYPE_SUBTYPE = Pattern.compile("$TOKEN/$TOKEN")
+    private val PARAMETER = Pattern.compile(";\\s*(?:$TOKEN=(?:$TOKEN|$QUOTED))?")
+
+    /**
+     * Returns a media type for `string`.
+     *
+     * @throws IllegalArgumentException if `string` is not a well-formed media type.
+     */
+    @JvmStatic
+    fun get(string: String): MediaType {
+      val typeSubtype = TYPE_SUBTYPE.matcher(string)
+      require(typeSubtype.lookingAt()) { "No subtype found for: \"$string\"" }
+      val type = typeSubtype.group(1).toLowerCase(Locale.US)
+      val subtype = typeSubtype.group(2).toLowerCase(Locale.US)
+
+      var charset: String? = null
+      val parameter = PARAMETER.matcher(string)
+      var s = typeSubtype.end()
+      while (s < string.length) {
+        parameter.region(s, string.length)
+        require(parameter.lookingAt()) {
+          "Parameter is not formatted correctly: \"${string.substring(s)}\" for: \"$string\""
+        }
+
+        val name = parameter.group(1)
+        if (name == null || !name.equals("charset", ignoreCase = true)) {
+          s = parameter.end()
+          continue
+        }
+        val charsetParameter: String
+        val token = parameter.group(2)
+        charsetParameter = when {
+          token == null -> {
+            // Value is "double-quoted". That's valid and our regex group already strips the quotes.
+            parameter.group(3)
+          }
+          token.startsWith("'") && token.endsWith("'") && token.length > 2 -> {
+            // If the token is 'single-quoted' it's invalid! But we're lenient and strip the quotes.
+            token.substring(1, token.length - 1)
+          }
+          else -> token
+        }
+        require(charset == null || charsetParameter.equals(charset, ignoreCase = true)) {
+          "Multiple charsets defined: \"$charset\" and: \"$charsetParameter\" for: \"$string\""
+        }
+        charset = charsetParameter
+        s = parameter.end()
+      }
+
+      return MediaType(string, type, subtype, charset)
+    }
+
+    /** Returns a media type for `string`, or null if `string` is not a well-formed media type. */
+    @JvmStatic
+    fun parse(string: String): MediaType? {
+      try {
+        return get(string)
+      } catch (ignored: IllegalArgumentException) {
+        return null
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.java b/okhttp/src/main/java/okhttp3/MultipartBody.java
index 09c1eaf2fe..a3f4863fba 100644
--- a/okhttp/src/main/java/okhttp3/MultipartBody.java
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.java
@@ -32,34 +32,34 @@
    * need to be bundled in a particular order. Any "multipart" subtypes that an implementation does
    * not recognize must be treated as being of subtype "mixed".
    */
-  public static final MediaType MIXED = MediaType.parse("multipart/mixed");
+  public static final MediaType MIXED = MediaType.get("multipart/mixed");
 
   /**
    * The "multipart/alternative" type is syntactically identical to "multipart/mixed", but the
    * semantics are different. In particular, each of the body parts is an "alternative" version of
    * the same information.
    */
-  public static final MediaType ALTERNATIVE = MediaType.parse("multipart/alternative");
+  public static final MediaType ALTERNATIVE = MediaType.get("multipart/alternative");
 
   /**
    * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
    * particular, in a digest, the default {@code Content-Type} value for a body part is changed from
    * "text/plain" to "message/rfc822".
    */
-  public static final MediaType DIGEST = MediaType.parse("multipart/digest");
+  public static final MediaType DIGEST = MediaType.get("multipart/digest");
 
   /**
    * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
    * particular, in a parallel entity, the order of body parts is not significant.
    */
-  public static final MediaType PARALLEL = MediaType.parse("multipart/parallel");
+  public static final MediaType PARALLEL = MediaType.get("multipart/parallel");
 
   /**
    * The media-type multipart/form-data follows the rules of all multipart MIME data streams as
    * outlined in RFC 2046. In forms, there are a series of fields to be supplied by the user who
    * fills out the form. Each field has a name. Within a given form, the names are unique.
    */
-  public static final MediaType FORM = MediaType.parse("multipart/form-data");
+  public static final MediaType FORM = MediaType.get("multipart/form-data");
 
   private static final byte[] COLONSPACE = {':', ' '};
   private static final byte[] CRLF = {'\r', '\n'};
@@ -74,7 +74,7 @@
   MultipartBody(ByteString boundary, MediaType type, List<Part> parts) {
     this.boundary = boundary;
     this.originalType = type;
-    this.contentType = MediaType.parse(type + "; boundary=" + boundary.utf8());
+    this.contentType = MediaType.get(type + "; boundary=" + boundary.utf8());
     this.parts = Util.immutableList(parts);
   }
 
@@ -199,7 +199,7 @@ private long writeOrCountBytes(
    * want to have a good chance of things working, please avoid double-quotes, newlines, percent
    * signs, and the like in your field names.
    */
-  static StringBuilder appendQuotedString(StringBuilder target, String key) {
+  static void appendQuotedString(StringBuilder target, String key) {
     target.append('"');
     for (int i = 0, len = key.length(); i < len; i++) {
       char ch = key.charAt(i);
@@ -219,7 +219,6 @@ static StringBuilder appendQuotedString(StringBuilder target, String key) {
       }
     }
     target.append('"');
-    return target;
   }
 
   public static final class Part {
@@ -256,7 +255,11 @@ public static Part createFormData(String name, @Nullable String filename, Reques
         appendQuotedString(disposition, filename);
       }
 
-      return create(Headers.of("Content-Disposition", disposition.toString()), body);
+      Headers headers = new Headers.Builder()
+          .addUnsafeNonAscii("Content-Disposition", disposition.toString())
+          .build();
+
+      return create(headers, body);
     }
 
     final @Nullable Headers headers;
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
deleted file mode 100644
index 9b0bdcc1f1..0000000000
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ /dev/null
@@ -1,947 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.MalformedURLException;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.Socket;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
-import java.security.KeyStore;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Random;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import javax.net.SocketFactory;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.connection.RouteDatabase;
-import okhttp3.internal.connection.StreamAllocation;
-import okhttp3.internal.platform.Platform;
-import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.internal.tls.OkHostnameVerifier;
-import okhttp3.internal.ws.RealWebSocket;
-import okio.Sink;
-import okio.Source;
-
-import static okhttp3.internal.Util.assertionError;
-import static okhttp3.internal.Util.checkDuration;
-
-/**
- * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
- * responses.
- *
- * <h3>OkHttpClients should be shared</h3>
- *
- * <p>OkHttp performs best when you create a single {@code OkHttpClient} instance and reuse it for
- * all of your HTTP calls. This is because each client holds its own connection pool and thread
- * pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a
- * client for each request wastes resources on idle pools.
- *
- * <p>Use {@code new OkHttpClient()} to create a shared instance with the default settings:
- * <pre>   {@code
- *
- *   // The singleton HTTP client.
- *   public final OkHttpClient client = new OkHttpClient();
- * }</pre>
- *
- * <p>Or use {@code new OkHttpClient.Builder()} to create a shared instance with custom settings:
- * <pre>   {@code
- *
- *   // The singleton HTTP client.
- *   public final OkHttpClient client = new OkHttpClient.Builder()
- *       .addInterceptor(new HttpLoggingInterceptor())
- *       .cache(new Cache(cacheDir, cacheSize))
- *       .build();
- * }</pre>
- *
- * <h3>Customize your client with newBuilder()</h3>
- *
- * <p>You can customize a shared OkHttpClient instance with {@link #newBuilder()}. This builds a
- * client that shares the same connection pool, thread pools, and configuration. Use the builder
- * methods to configure the derived client for a specific purpose.
- *
- * <p>This example shows a call with a short 500 millisecond timeout: <pre>   {@code
- *
- *   OkHttpClient eagerClient = client.newBuilder()
- *       .readTimeout(500, TimeUnit.MILLISECONDS)
- *       .build();
- *   Response response = eagerClient.newCall(request).execute();
- * }</pre>
- *
- * <h3>Shutdown isn't necessary</h3>
- *
- * <p>The threads and connections that are held will be released automatically if they remain idle.
- * But if you are writing a application that needs to aggressively release unused resources you may
- * do so.
- *
- * <p>Shutdown the dispatcher's executor service with {@link ExecutorService#shutdown shutdown()}.
- * This will also cause future calls to the client to be rejected. <pre>   {@code
- *
- *     client.dispatcher().executorService().shutdown();
- * }</pre>
- *
- * <p>Clear the connection pool with {@link ConnectionPool#evictAll() evictAll()}. Note that the
- * connection pool's daemon thread may not exit immediately. <pre>   {@code
- *
- *     client.connectionPool().evictAll();
- * }</pre>
- *
- * <p>If your client has a cache, call {@link Cache#close close()}. Note that it is an error to
- * create calls against a cache that is closed, and doing so will cause the call to crash.
- * <pre>   {@code
- *
- *     client.cache().close();
- * }</pre>
- *
- * <p>OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
- * remain idle.
- */
-public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
-  static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
-      Protocol.HTTP_2, Protocol.HTTP_1_1);
-
-  static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
-      ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
-
-  static {
-    Internal.instance = new Internal() {
-      @Override public void addLenient(Headers.Builder builder, String line) {
-        builder.addLenient(line);
-      }
-
-      @Override public void addLenient(Headers.Builder builder, String name, String value) {
-        builder.addLenient(name, value);
-      }
-
-      @Override public void setCache(OkHttpClient.Builder builder, InternalCache internalCache) {
-        builder.setInternalCache(internalCache);
-      }
-
-      @Override public boolean connectionBecameIdle(
-          ConnectionPool pool, RealConnection connection) {
-        return pool.connectionBecameIdle(connection);
-      }
-
-      @Override public RealConnection get(ConnectionPool pool, Address address,
-          StreamAllocation streamAllocation, Route route) {
-        return pool.get(address, streamAllocation, route);
-      }
-
-      @Override public boolean equalsNonHost(Address a, Address b) {
-        return a.equalsNonHost(b);
-      }
-
-      @Override public Socket deduplicate(
-          ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
-        return pool.deduplicate(address, streamAllocation);
-      }
-
-      @Override public void put(ConnectionPool pool, RealConnection connection) {
-        pool.put(connection);
-      }
-
-      @Override public RouteDatabase routeDatabase(ConnectionPool connectionPool) {
-        return connectionPool.routeDatabase;
-      }
-
-      @Override public int code(Response.Builder responseBuilder) {
-        return responseBuilder.code;
-      }
-
-      @Override
-      public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
-        tlsConfiguration.apply(sslSocket, isFallback);
-      }
-
-      @Override public HttpUrl getHttpUrlChecked(String url)
-          throws MalformedURLException, UnknownHostException {
-        return HttpUrl.getChecked(url);
-      }
-
-      @Override public StreamAllocation streamAllocation(Call call) {
-        return ((RealCall) call).streamAllocation();
-      }
-
-      @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
-        return RealCall.newRealCall(client, originalRequest, true);
-      }
-    };
-  }
-
-  final Dispatcher dispatcher;
-  final @Nullable Proxy proxy;
-  final List<Protocol> protocols;
-  final List<ConnectionSpec> connectionSpecs;
-  final List<Interceptor> interceptors;
-  final List<Interceptor> networkInterceptors;
-  final EventListener.Factory eventListenerFactory;
-  final ProxySelector proxySelector;
-  final CookieJar cookieJar;
-  final @Nullable Cache cache;
-  final @Nullable InternalCache internalCache;
-  final SocketFactory socketFactory;
-  final @Nullable SSLSocketFactory sslSocketFactory;
-  final @Nullable CertificateChainCleaner certificateChainCleaner;
-  final HostnameVerifier hostnameVerifier;
-  final CertificatePinner certificatePinner;
-  final Authenticator proxyAuthenticator;
-  final Authenticator authenticator;
-  final ConnectionPool connectionPool;
-  final Dns dns;
-  final boolean followSslRedirects;
-  final boolean followRedirects;
-  final boolean retryOnConnectionFailure;
-  final int connectTimeout;
-  final int readTimeout;
-  final int writeTimeout;
-  final int pingInterval;
-
-  public OkHttpClient() {
-    this(new Builder());
-  }
-
-  OkHttpClient(Builder builder) {
-    this.dispatcher = builder.dispatcher;
-    this.proxy = builder.proxy;
-    this.protocols = builder.protocols;
-    this.connectionSpecs = builder.connectionSpecs;
-    this.interceptors = Util.immutableList(builder.interceptors);
-    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
-    this.eventListenerFactory = builder.eventListenerFactory;
-    this.proxySelector = builder.proxySelector;
-    this.cookieJar = builder.cookieJar;
-    this.cache = builder.cache;
-    this.internalCache = builder.internalCache;
-    this.socketFactory = builder.socketFactory;
-
-    boolean isTLS = false;
-    for (ConnectionSpec spec : connectionSpecs) {
-      isTLS = isTLS || spec.isTls();
-    }
-
-    if (builder.sslSocketFactory != null || !isTLS) {
-      this.sslSocketFactory = builder.sslSocketFactory;
-      this.certificateChainCleaner = builder.certificateChainCleaner;
-    } else {
-      X509TrustManager trustManager = systemDefaultTrustManager();
-      this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
-    }
-
-    if (sslSocketFactory != null) {
-      Platform.get().configureSslSocketFactory(sslSocketFactory);
-    }
-
-    this.hostnameVerifier = builder.hostnameVerifier;
-    this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
-        certificateChainCleaner);
-    this.proxyAuthenticator = builder.proxyAuthenticator;
-    this.authenticator = builder.authenticator;
-    this.connectionPool = builder.connectionPool;
-    this.dns = builder.dns;
-    this.followSslRedirects = builder.followSslRedirects;
-    this.followRedirects = builder.followRedirects;
-    this.retryOnConnectionFailure = builder.retryOnConnectionFailure;
-    this.connectTimeout = builder.connectTimeout;
-    this.readTimeout = builder.readTimeout;
-    this.writeTimeout = builder.writeTimeout;
-    this.pingInterval = builder.pingInterval;
-
-    if (interceptors.contains(null)) {
-      throw new IllegalStateException("Null interceptor: " + interceptors);
-    }
-    if (networkInterceptors.contains(null)) {
-      throw new IllegalStateException("Null network interceptor: " + networkInterceptors);
-    }
-  }
-
-  private X509TrustManager systemDefaultTrustManager() {
-    try {
-      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-          TrustManagerFactory.getDefaultAlgorithm());
-      trustManagerFactory.init((KeyStore) null);
-      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-        throw new IllegalStateException("Unexpected default trust managers:"
-            + Arrays.toString(trustManagers));
-      }
-      return (X509TrustManager) trustManagers[0];
-    } catch (GeneralSecurityException e) {
-      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
-    }
-  }
-
-  private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustManager) {
-    try {
-      SSLContext sslContext = Platform.get().getSSLContext();
-      sslContext.init(null, new TrustManager[] { trustManager }, null);
-      return sslContext.getSocketFactory();
-    } catch (GeneralSecurityException e) {
-      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
-    }
-  }
-
-  /** Default connect timeout (in milliseconds). */
-  public int connectTimeoutMillis() {
-    return connectTimeout;
-  }
-
-  /** Default read timeout (in milliseconds). */
-  public int readTimeoutMillis() {
-    return readTimeout;
-  }
-
-  /** Default write timeout (in milliseconds). */
-  public int writeTimeoutMillis() {
-    return writeTimeout;
-  }
-
-  /** Web socket ping interval (in milliseconds). */
-  public int pingIntervalMillis() {
-    return pingInterval;
-  }
-
-  public Proxy proxy() {
-    return proxy;
-  }
-
-  public ProxySelector proxySelector() {
-    return proxySelector;
-  }
-
-  public CookieJar cookieJar() {
-    return cookieJar;
-  }
-
-  public @Nullable Cache cache() {
-    return cache;
-  }
-
-  InternalCache internalCache() {
-    return cache != null ? cache.internalCache : internalCache;
-  }
-
-  public Dns dns() {
-    return dns;
-  }
-
-  public SocketFactory socketFactory() {
-    return socketFactory;
-  }
-
-  public SSLSocketFactory sslSocketFactory() {
-    return sslSocketFactory;
-  }
-
-  public HostnameVerifier hostnameVerifier() {
-    return hostnameVerifier;
-  }
-
-  public CertificatePinner certificatePinner() {
-    return certificatePinner;
-  }
-
-  public Authenticator authenticator() {
-    return authenticator;
-  }
-
-  public Authenticator proxyAuthenticator() {
-    return proxyAuthenticator;
-  }
-
-  public ConnectionPool connectionPool() {
-    return connectionPool;
-  }
-
-  public boolean followSslRedirects() {
-    return followSslRedirects;
-  }
-
-  public boolean followRedirects() {
-    return followRedirects;
-  }
-
-  public boolean retryOnConnectionFailure() {
-    return retryOnConnectionFailure;
-  }
-
-  public Dispatcher dispatcher() {
-    return dispatcher;
-  }
-
-  public List<Protocol> protocols() {
-    return protocols;
-  }
-
-  public List<ConnectionSpec> connectionSpecs() {
-    return connectionSpecs;
-  }
-
-  /**
-   * Returns an immutable list of interceptors that observe the full span of each call: from before
-   * the connection is established (if any) until after the response source is selected (either the
-   * origin server, cache, or both).
-   */
-  public List<Interceptor> interceptors() {
-    return interceptors;
-  }
-
-  /**
-   * Returns an immutable list of interceptors that observe a single network request and response.
-   * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error for
-   * a network interceptor to short-circuit or repeat a network request.
-   */
-  public List<Interceptor> networkInterceptors() {
-    return networkInterceptors;
-  }
-
-  public EventListener.Factory eventListenerFactory() {
-    return eventListenerFactory;
-  }
-
-  /**
-   * Prepares the {@code request} to be executed at some point in the future.
-   */
-  @Override public Call newCall(Request request) {
-    return RealCall.newRealCall(this, request, false /* for web socket */);
-  }
-
-  /**
-   * Uses {@code request} to connect a new web socket.
-   */
-  @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {
-    RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval);
-    webSocket.connect(this);
-    return webSocket;
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  public static final class Builder {
-    Dispatcher dispatcher;
-    @Nullable Proxy proxy;
-    List<Protocol> protocols;
-    List<ConnectionSpec> connectionSpecs;
-    final List<Interceptor> interceptors = new ArrayList<>();
-    final List<Interceptor> networkInterceptors = new ArrayList<>();
-    EventListener.Factory eventListenerFactory;
-    ProxySelector proxySelector;
-    CookieJar cookieJar;
-    @Nullable Cache cache;
-    @Nullable InternalCache internalCache;
-    SocketFactory socketFactory;
-    @Nullable SSLSocketFactory sslSocketFactory;
-    @Nullable CertificateChainCleaner certificateChainCleaner;
-    HostnameVerifier hostnameVerifier;
-    CertificatePinner certificatePinner;
-    Authenticator proxyAuthenticator;
-    Authenticator authenticator;
-    ConnectionPool connectionPool;
-    Dns dns;
-    boolean followSslRedirects;
-    boolean followRedirects;
-    boolean retryOnConnectionFailure;
-    int connectTimeout;
-    int readTimeout;
-    int writeTimeout;
-    int pingInterval;
-
-    public Builder() {
-      dispatcher = new Dispatcher();
-      protocols = DEFAULT_PROTOCOLS;
-      connectionSpecs = DEFAULT_CONNECTION_SPECS;
-      eventListenerFactory = EventListener.factory(EventListener.NONE);
-      proxySelector = ProxySelector.getDefault();
-      cookieJar = CookieJar.NO_COOKIES;
-      socketFactory = SocketFactory.getDefault();
-      hostnameVerifier = OkHostnameVerifier.INSTANCE;
-      certificatePinner = CertificatePinner.DEFAULT;
-      proxyAuthenticator = Authenticator.NONE;
-      authenticator = Authenticator.NONE;
-      connectionPool = new ConnectionPool();
-      dns = Dns.SYSTEM;
-      followSslRedirects = true;
-      followRedirects = true;
-      retryOnConnectionFailure = true;
-      connectTimeout = 10_000;
-      readTimeout = 10_000;
-      writeTimeout = 10_000;
-      pingInterval = 0;
-    }
-
-    Builder(OkHttpClient okHttpClient) {
-      this.dispatcher = okHttpClient.dispatcher;
-      this.proxy = okHttpClient.proxy;
-      this.protocols = okHttpClient.protocols;
-      this.connectionSpecs = okHttpClient.connectionSpecs;
-      this.interceptors.addAll(okHttpClient.interceptors);
-      this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
-      this.eventListenerFactory = okHttpClient.eventListenerFactory;
-      this.proxySelector = okHttpClient.proxySelector;
-      this.cookieJar = okHttpClient.cookieJar;
-      this.internalCache = okHttpClient.internalCache;
-      this.cache = okHttpClient.cache;
-      this.socketFactory = okHttpClient.socketFactory;
-      this.sslSocketFactory = okHttpClient.sslSocketFactory;
-      this.certificateChainCleaner = okHttpClient.certificateChainCleaner;
-      this.hostnameVerifier = okHttpClient.hostnameVerifier;
-      this.certificatePinner = okHttpClient.certificatePinner;
-      this.proxyAuthenticator = okHttpClient.proxyAuthenticator;
-      this.authenticator = okHttpClient.authenticator;
-      this.connectionPool = okHttpClient.connectionPool;
-      this.dns = okHttpClient.dns;
-      this.followSslRedirects = okHttpClient.followSslRedirects;
-      this.followRedirects = okHttpClient.followRedirects;
-      this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure;
-      this.connectTimeout = okHttpClient.connectTimeout;
-      this.readTimeout = okHttpClient.readTimeout;
-      this.writeTimeout = okHttpClient.writeTimeout;
-      this.pingInterval = okHttpClient.pingInterval;
-    }
-
-    /**
-     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
-     * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
-     * milliseconds.
-     *
-     * <p>The connectTimeout is applied when connecting a TCP socket to the target host.
-     * The default value is 10 seconds.
-     */
-    public Builder connectTimeout(long timeout, TimeUnit unit) {
-      connectTimeout = checkDuration("timeout", timeout, unit);
-      return this;
-    }
-
-    /**
-     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
-     * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
-     *
-     * @see Socket#setSoTimeout(int)
-     * @see Source#timeout()
-     */
-    public Builder readTimeout(long timeout, TimeUnit unit) {
-      readTimeout = checkDuration("timeout", timeout, unit);
-      return this;
-    }
-
-    /**
-     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
-     * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
-     *
-     * <p>The write timeout is applied for individual write IO operations.
-     * The default value is 10 seconds.
-     *
-     * @see Sink#timeout()
-     */
-    public Builder writeTimeout(long timeout, TimeUnit unit) {
-      writeTimeout = checkDuration("timeout", timeout, unit);
-      return this;
-    }
-
-    /**
-     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
-     * automatically send ping frames until either the connection fails or it is closed. This keeps
-     * the connection alive and may detect connectivity failures.
-     *
-     * <p>If the server does not respond to each ping with a pong within {@code interval}, this
-     * client will assume that connectivity has been lost. When this happens on a web socket the
-     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
-     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
-     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
-     *
-     * <p>The default value of 0 disables client-initiated pings.
-     */
-    public Builder pingInterval(long interval, TimeUnit unit) {
-      pingInterval = checkDuration("interval", interval, unit);
-      return this;
-    }
-
-    /**
-     * Sets the HTTP proxy that will be used by connections created by this client. This takes
-     * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
-     * it is by default). To disable proxy use completely, call {@code proxy(Proxy.NO_PROXY)}.
-     */
-    public Builder proxy(@Nullable Proxy proxy) {
-      this.proxy = proxy;
-      return this;
-    }
-
-    /**
-     * Sets the proxy selection policy to be used if no {@link #proxy proxy} is specified
-     * explicitly. The proxy selector may return multiple proxies; in that case they will be tried
-     * in sequence until a successful connection is established.
-     *
-     * <p>If unset, the {@link ProxySelector#getDefault() system-wide default} proxy selector will
-     * be used.
-     */
-    public Builder proxySelector(ProxySelector proxySelector) {
-      this.proxySelector = proxySelector;
-      return this;
-    }
-
-    /**
-     * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
-     * outgoing HTTP requests.
-     *
-     * <p>If unset, {@linkplain CookieJar#NO_COOKIES no cookies} will be accepted nor provided.
-     */
-    public Builder cookieJar(CookieJar cookieJar) {
-      if (cookieJar == null) throw new NullPointerException("cookieJar == null");
-      this.cookieJar = cookieJar;
-      return this;
-    }
-
-    /** Sets the response cache to be used to read and write cached responses. */
-    void setInternalCache(@Nullable InternalCache internalCache) {
-      this.internalCache = internalCache;
-      this.cache = null;
-    }
-
-    /** Sets the response cache to be used to read and write cached responses. */
-    public Builder cache(@Nullable Cache cache) {
-      this.cache = cache;
-      this.internalCache = null;
-      return this;
-    }
-
-    /**
-     * Sets the DNS service used to lookup IP addresses for hostnames.
-     *
-     * <p>If unset, the {@link Dns#SYSTEM system-wide default} DNS will be used.
-     */
-    public Builder dns(Dns dns) {
-      if (dns == null) throw new NullPointerException("dns == null");
-      this.dns = dns;
-      return this;
-    }
-
-    /**
-     * Sets the socket factory used to create connections. OkHttp only uses the parameterless {@link
-     * SocketFactory#createSocket() createSocket()} method to create unconnected sockets. Overriding
-     * this method, e. g., allows the socket to be bound to a specific local address.
-     *
-     * <p>If unset, the {@link SocketFactory#getDefault() system-wide default} socket factory will
-     * be used.
-     */
-    public Builder socketFactory(SocketFactory socketFactory) {
-      if (socketFactory == null) throw new NullPointerException("socketFactory == null");
-      this.socketFactory = socketFactory;
-      return this;
-    }
-
-    /**
-     * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
-     * be used.
-     *
-     * @deprecated {@code SSLSocketFactory} does not expose its {@link X509TrustManager}, which is
-     *     a field that OkHttp needs to build a clean certificate chain. This method instead must
-     *     use reflection to extract the trust manager. Applications should prefer to call {@link
-     *     #sslSocketFactory(SSLSocketFactory, X509TrustManager)}, which avoids such reflection.
-     */
-    public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
-      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
-      this.sslSocketFactory = sslSocketFactory;
-      this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory);
-      return this;
-    }
-
-    /**
-     * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
-     * system defaults will be used.
-     *
-     * <p>Most applications should not call this method, and instead use the system defaults. Those
-     * classes include special optimizations that can be lost if the implementations are decorated.
-     *
-     * <p>If necessary, you can create and configure the defaults yourself with the following code:
-     *
-     * <pre>   {@code
-     *
-     *   TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-     *       TrustManagerFactory.getDefaultAlgorithm());
-     *   trustManagerFactory.init((KeyStore) null);
-     *   TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-     *   if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-     *     throw new IllegalStateException("Unexpected default trust managers:"
-     *         + Arrays.toString(trustManagers));
-     *   }
-     *   X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
-     *
-     *   SSLContext sslContext = SSLContext.getInstance("TLS");
-     *   sslContext.init(null, new TrustManager[] { trustManager }, null);
-     *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
-     *
-     *   OkHttpClient client = new OkHttpClient.Builder()
-     *       .sslSocketFactory(sslSocketFactory, trustManager)
-     *       .build();
-     * }</pre>
-     */
-    public Builder sslSocketFactory(
-        SSLSocketFactory sslSocketFactory, X509TrustManager trustManager) {
-      if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
-      if (trustManager == null) throw new NullPointerException("trustManager == null");
-      this.sslSocketFactory = sslSocketFactory;
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
-      return this;
-    }
-
-    /**
-     * Sets the verifier used to confirm that response certificates apply to requested hostnames for
-     * HTTPS connections.
-     *
-     * <p>If unset, a default hostname verifier will be used.
-     */
-    public Builder hostnameVerifier(HostnameVerifier hostnameVerifier) {
-      if (hostnameVerifier == null) throw new NullPointerException("hostnameVerifier == null");
-      this.hostnameVerifier = hostnameVerifier;
-      return this;
-    }
-
-    /**
-     * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
-     * connections rely on only the {@link #sslSocketFactory SSL socket factory} to establish trust.
-     * Pinning certificates avoids the need to trust certificate authorities.
-     */
-    public Builder certificatePinner(CertificatePinner certificatePinner) {
-      if (certificatePinner == null) throw new NullPointerException("certificatePinner == null");
-      this.certificatePinner = certificatePinner;
-      return this;
-    }
-
-    /**
-     * Sets the authenticator used to respond to challenges from origin servers. Use {@link
-     * #proxyAuthenticator} to set the authenticator for proxy servers.
-     *
-     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
-     */
-    public Builder authenticator(Authenticator authenticator) {
-      if (authenticator == null) throw new NullPointerException("authenticator == null");
-      this.authenticator = authenticator;
-      return this;
-    }
-
-    /**
-     * Sets the authenticator used to respond to challenges from proxy servers. Use {@link
-     * #authenticator} to set the authenticator for origin servers.
-     *
-     * <p>If unset, the {@linkplain Authenticator#NONE no authentication will be attempted}.
-     */
-    public Builder proxyAuthenticator(Authenticator proxyAuthenticator) {
-      if (proxyAuthenticator == null) throw new NullPointerException("proxyAuthenticator == null");
-      this.proxyAuthenticator = proxyAuthenticator;
-      return this;
-    }
-
-    /**
-     * Sets the connection pool used to recycle HTTP and HTTPS connections.
-     *
-     * <p>If unset, a new connection pool will be used.
-     */
-    public Builder connectionPool(ConnectionPool connectionPool) {
-      if (connectionPool == null) throw new NullPointerException("connectionPool == null");
-      this.connectionPool = connectionPool;
-      return this;
-    }
-
-    /**
-     * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
-     *
-     * <p>If unset, protocol redirects will be followed. This is different than the built-in {@code
-     * HttpURLConnection}'s default.
-     */
-    public Builder followSslRedirects(boolean followProtocolRedirects) {
-      this.followSslRedirects = followProtocolRedirects;
-      return this;
-    }
-
-    /** Configure this client to follow redirects. If unset, redirects will be followed. */
-    public Builder followRedirects(boolean followRedirects) {
-      this.followRedirects = followRedirects;
-      return this;
-    }
-
-    /**
-     * Configure this client to retry or not when a connectivity problem is encountered. By default,
-     * this client silently recovers from the following problems:
-     *
-     * <ul>
-     *   <li><strong>Unreachable IP addresses.</strong> If the URL's host has multiple IP addresses,
-     *       failure to reach any individual IP address doesn't fail the overall request. This can
-     *       increase availability of multi-homed services.
-     *   <li><strong>Stale pooled connections.</strong> The {@link ConnectionPool} reuses sockets
-     *       to decrease request latency, but these connections will occasionally time out.
-     *   <li><strong>Unreachable proxy servers.</strong> A {@link ProxySelector} can be used to
-     *       attempt multiple proxy servers in sequence, eventually falling back to a direct
-     *       connection.
-     * </ul>
-     *
-     * Set this to false to avoid retrying requests when doing so is destructive. In this case the
-     * calling application should do its own recovery of connectivity failures.
-     */
-    public Builder retryOnConnectionFailure(boolean retryOnConnectionFailure) {
-      this.retryOnConnectionFailure = retryOnConnectionFailure;
-      return this;
-    }
-
-    /**
-     * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
-     */
-    public Builder dispatcher(Dispatcher dispatcher) {
-      if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
-      this.dispatcher = dispatcher;
-      return this;
-    }
-
-    /**
-     * Configure the protocols used by this client to communicate with remote servers. By default
-     * this client will prefer the most efficient transport available, falling back to more
-     * ubiquitous protocols. Applications should only call this method to avoid specific
-     * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
-     *
-     * <p>The following protocols are currently supported:
-     *
-     * <ul>
-     *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-     *     <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
-     * </ul>
-     *
-     * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
-     * protocols. The http/1.1 transport will never be dropped.
-     *
-     * <p>If multiple protocols are specified, <a
-     * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
-     * negotiate a transport.
-     *
-     * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
-     * HTTP/1.1} only. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
-     * Response#protocol()}.
-     *
-     * @param protocols the protocols to use, in order of preference. The list must contain {@link
-     * Protocol#HTTP_1_1}. It should not contain null or {@link Protocol#HTTP_1_0}. If you use
-     * {@link Protocol#H2C}, then it should be the only specified protocol in the list.
-     */
-    public Builder protocols(List<Protocol> protocols) {
-      // Create a private copy of the list.
-      protocols = new ArrayList<>(protocols);
-
-      if (protocols.contains(Protocol.H2C) && protocols.size() > 1) {
-        // when using h2c prior knowledge, no other protocol should be supported.
-        throw new IllegalArgumentException("protocols containing h2c cannot use other protocols: "
-                + protocols);
-      } else if (!protocols.contains(Protocol.H2C) && !protocols.contains(Protocol.HTTP_1_1)) {
-        // Validate that the list has everything we require and nothing we forbid.
-        throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
-      }
-      if (protocols.contains(Protocol.HTTP_1_0)) {
-        throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
-      }
-      if (protocols.contains(null)) {
-        throw new IllegalArgumentException("protocols must not contain null");
-      }
-
-      // Remove protocols that we no longer support.
-      protocols.remove(Protocol.SPDY_3);
-
-      // Assign as an unmodifiable list. This is effectively immutable.
-      this.protocols = Collections.unmodifiableList(protocols);
-      return this;
-    }
-
-    public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
-      this.connectionSpecs = Util.immutableList(connectionSpecs);
-      return this;
-    }
-
-    /**
-     * Returns a modifiable list of interceptors that observe the full span of each call: from
-     * before the connection is established (if any) until after the response source is selected
-     * (either the origin server, cache, or both).
-     */
-    public List<Interceptor> interceptors() {
-      return interceptors;
-    }
-
-    public Builder addInterceptor(Interceptor interceptor) {
-      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
-      interceptors.add(interceptor);
-      return this;
-    }
-
-    /**
-     * Returns a modifiable list of interceptors that observe a single network request and response.
-     * These interceptors must call {@link Interceptor.Chain#proceed} exactly once: it is an error
-     * for a network interceptor to short-circuit or repeat a network request.
-     */
-    public List<Interceptor> networkInterceptors() {
-      return networkInterceptors;
-    }
-
-    public Builder addNetworkInterceptor(Interceptor interceptor) {
-      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
-      networkInterceptors.add(interceptor);
-      return this;
-    }
-
-    /**
-     * Configure a single client scoped listener that will receive all analytic events
-     * for this client.
-     *
-     * @see EventListener for semantics and restrictions on listener implementations.
-     */
-    public Builder eventListener(EventListener eventListener) {
-      if (eventListener == null) throw new NullPointerException("eventListener == null");
-      this.eventListenerFactory = EventListener.factory(eventListener);
-      return this;
-    }
-
-    /**
-     * Configure a factory to provide per-call scoped listeners that will receive analytic events
-     * for this client.
-     *
-     * @see EventListener for semantics and restrictions on listener implementations.
-     */
-    public Builder eventListenerFactory(EventListener.Factory eventListenerFactory) {
-      if (eventListenerFactory == null) {
-        throw new NullPointerException("eventListenerFactory == null");
-      }
-      this.eventListenerFactory = eventListenerFactory;
-      return this;
-    }
-
-    public OkHttpClient build() {
-      return new OkHttpClient(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.kt b/okhttp/src/main/java/okhttp3/OkHttpClient.kt
new file mode 100644
index 0000000000..d212882025
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.kt
@@ -0,0 +1,828 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.Protocol.HTTP_1_1
+import okhttp3.Protocol.HTTP_2
+import okhttp3.internal.Internal
+import okhttp3.internal.Util
+import okhttp3.internal.Util.checkDuration
+import okhttp3.internal.cache.InternalCache
+import okhttp3.internal.connection.Exchange
+import okhttp3.internal.platform.Platform
+import okhttp3.internal.proxy.NullProxySelector
+import okhttp3.internal.tls.CertificateChainCleaner
+import okhttp3.internal.tls.OkHostnameVerifier
+import okhttp3.internal.ws.RealWebSocket
+import okio.Sink
+import okio.Source
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
+import java.net.Proxy
+import java.net.ProxySelector
+import java.net.Socket
+import java.security.GeneralSecurityException
+import java.time.Duration
+import java.util.Collections
+import java.util.Random
+import java.util.concurrent.ExecutorService
+import java.util.concurrent.TimeUnit
+import javax.net.SocketFactory
+import javax.net.ssl.HostnameVerifier
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.TrustManager
+import javax.net.ssl.X509TrustManager
+import kotlin.DeprecationLevel.ERROR
+
+/**
+ * Factory for [calls][Call], which can be used to send HTTP requests and read their responses.
+ *
+ * ## OkHttpClients Should Be Shared
+ *
+ * OkHttp performs best when you create a single `OkHttpClient` instance and reuse it for all of
+ * your HTTP calls. This is because each client holds its own connection pool and thread pools.
+ * Reusing connections and threads reduces latency and saves memory. Conversely, creating a client
+ * for each request wastes resources on idle pools.
+ *
+ * Use `new OkHttpClient()` to create a shared instance with the default settings:
+ *
+ * ```
+ * // The singleton HTTP client.
+ * public final OkHttpClient client = new OkHttpClient();
+ * ```
+ *
+ * Or use `new OkHttpClient.Builder()` to create a shared instance with custom settings:
+ *
+ * ```
+ * // The singleton HTTP client.
+ * public final OkHttpClient client = new OkHttpClient.Builder()
+ *     .addInterceptor(new HttpLoggingInterceptor())
+ *     .cache(new Cache(cacheDir, cacheSize))
+ *     .build();
+ * ```
+ *
+ * ## Customize Your Client With newBuilder()
+ *
+ * You can customize a shared OkHttpClient instance with [newBuilder]. This builds a client that
+ * shares the same connection pool, thread pools, and configuration. Use the builder methods to
+ * configure the derived client for a specific purpose.
+ *
+ * This example shows a call with a short 500 millisecond timeout:
+ *
+ * ```
+ * OkHttpClient eagerClient = client.newBuilder()
+ *     .readTimeout(500, TimeUnit.MILLISECONDS)
+ *     .build();
+ * Response response = eagerClient.newCall(request).execute();
+ * ```
+ *
+ * ## Shutdown Isn't Necessary
+ *
+ * The threads and connections that are held will be released automatically if they remain idle. But
+ * if you are writing a application that needs to aggressively release unused resources you may do
+ * so.
+ *
+ * Shutdown the dispatcher's executor service with [shutdown()][ExecutorService.shutdown]. This will
+ * also cause future calls to the client to be rejected.
+ *
+ * ```
+ * client.dispatcher().executorService().shutdown();
+ * ```
+ *
+ * Clear the connection pool with [evictAll()][ConnectionPool.evictAll]. Note that the connection
+ * pool's daemon thread may not exit immediately.
+ *
+ * ```
+ * client.connectionPool().evictAll();
+ * ```
+ *
+ * If your client has a cache, call [close()][Cache.close]. Note that it is an error to create calls
+ * against a cache that is closed, and doing so will cause the call to crash.
+ *
+ * ```
+ * client.cache().close();
+ * ```
+ *
+ * OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
+ * remain idle.
+ */
+open class OkHttpClient internal constructor(
+  builder: Builder
+) : Cloneable, Call.Factory, WebSocket.Factory {
+  private val dispatcher: Dispatcher = builder.dispatcher
+  private val proxy: Proxy? = builder.proxy
+  private val protocols: List<Protocol> = builder.protocols
+  private val connectionSpecs: List<ConnectionSpec> = builder.connectionSpecs
+  private val interceptors: List<Interceptor> =
+      Util.immutableList(builder.interceptors)
+  private val networkInterceptors: List<Interceptor> =
+      Util.immutableList(builder.networkInterceptors)
+  private val eventListenerFactory: EventListener.Factory = builder.eventListenerFactory
+  private val proxySelector: ProxySelector = builder.proxySelector
+  private val cookieJar: CookieJar = builder.cookieJar
+  private val cache: Cache? = builder.cache
+  private val socketFactory: SocketFactory = builder.socketFactory
+  private val sslSocketFactory: SSLSocketFactory?
+  private val hostnameVerifier: HostnameVerifier = builder.hostnameVerifier
+  private val certificatePinner: CertificatePinner
+  private val proxyAuthenticator: Authenticator = builder.proxyAuthenticator
+  private val authenticator: Authenticator = builder.authenticator
+  private val connectionPool: ConnectionPool = builder.connectionPool
+  private val dns: Dns = builder.dns
+  private val followSslRedirects: Boolean = builder.followSslRedirects
+  private val followRedirects: Boolean = builder.followRedirects
+  private val retryOnConnectionFailure: Boolean = builder.retryOnConnectionFailure
+  private val callTimeout: Int = builder.callTimeout
+  private val connectTimeout: Int = builder.connectTimeout
+  private val readTimeout: Int = builder.readTimeout
+  private val writeTimeout: Int = builder.writeTimeout
+  private val pingInterval: Int = builder.pingInterval
+  private val internalCache: InternalCache? = builder.internalCache
+  private val certificateChainCleaner: CertificateChainCleaner?
+
+  constructor() : this(Builder())
+
+  init {
+    var isTLS = false
+    for (spec in connectionSpecs) {
+      isTLS = isTLS || spec.isTls
+    }
+
+    // TODO - these nullability warnings existed in Java
+    if (builder.sslSocketFactory != null || !isTLS) {
+      this.sslSocketFactory = builder.sslSocketFactory
+      this.certificateChainCleaner = builder.certificateChainCleaner
+    } else {
+      val trustManager = Util.platformTrustManager()
+      this.sslSocketFactory = newSslSocketFactory(trustManager)
+      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager)
+    }
+
+    if (sslSocketFactory != null) {
+      Platform.get().configureSslSocketFactory(sslSocketFactory)
+    }
+
+    this.certificatePinner = builder.certificatePinner
+        .withCertificateChainCleaner(certificateChainCleaner)
+
+    check(null !in (interceptors as List<Interceptor?>)) {
+      "Null interceptor: $interceptors"
+    }
+    check(null !in (networkInterceptors as List<Interceptor?>)) {
+      "Null network interceptor: $networkInterceptors"
+    }
+  }
+
+  open fun dispatcher(): Dispatcher = dispatcher
+
+  open fun proxy(): Proxy? = proxy
+
+  open fun protocols(): List<Protocol> = protocols
+
+  open fun connectionSpecs(): List<ConnectionSpec> = connectionSpecs
+
+  /**
+   * Returns an immutable list of interceptors that observe the full span of each call: from before
+   * the connection is established (if any) until after the response source is selected (either the
+   * origin server, cache, or both).
+   */
+  open fun interceptors(): List<Interceptor> = interceptors
+
+  /**
+   * Returns an immutable list of interceptors that observe a single network request and response.
+   * These interceptors must call [Interceptor.Chain.proceed] exactly once: it is an error for
+   * a network interceptor to short-circuit or repeat a network request.
+   */
+  open fun networkInterceptors(): List<Interceptor> = networkInterceptors
+
+  open fun eventListenerFactory(): EventListener.Factory = eventListenerFactory
+
+  open fun proxySelector(): ProxySelector = proxySelector
+
+  open fun cookieJar(): CookieJar = cookieJar
+
+  open fun cache(): Cache? = cache
+
+  open fun socketFactory(): SocketFactory = socketFactory
+
+  open fun sslSocketFactory(): SSLSocketFactory = sslSocketFactory!!
+
+  open fun hostnameVerifier(): HostnameVerifier = hostnameVerifier
+
+  open fun certificatePinner(): CertificatePinner = certificatePinner
+
+  open fun proxyAuthenticator(): Authenticator = proxyAuthenticator
+
+  open fun authenticator(): Authenticator = authenticator
+
+  open fun connectionPool(): ConnectionPool = connectionPool
+
+  open fun dns(): Dns = dns
+
+  open fun followSslRedirects(): Boolean = followSslRedirects
+
+  open fun followRedirects(): Boolean = followRedirects
+
+  open fun retryOnConnectionFailure(): Boolean = retryOnConnectionFailure
+
+  /**
+   * Default call timeout (in milliseconds). By default there is no timeout for complete calls, but
+   * there is for the connect, write, and read actions within a call.
+   */
+  open fun callTimeoutMillis(): Int = callTimeout
+
+  /** Default connect timeout (in milliseconds). The default is 10 seconds.  */
+  open fun connectTimeoutMillis(): Int = connectTimeout
+
+  /** Default read timeout (in milliseconds). The default is 10 seconds. */
+  open fun readTimeoutMillis(): Int = readTimeout
+
+  /** Default write timeout (in milliseconds). The default is 10 seconds. */
+  open fun writeTimeoutMillis(): Int = writeTimeout
+
+  /** Web socket and HTTP/2 ping interval (in milliseconds). By default pings are not sent. */
+  open fun pingIntervalMillis(): Int = pingInterval
+
+  internal fun internalCache(): InternalCache? {
+    return cache?.internalCache ?: internalCache
+  }
+
+  /** Prepares the [request] to be executed at some point in the future. */
+  override fun newCall(request: Request): Call {
+    return RealCall.newRealCall(this, request, false /* for web socket */)
+  }
+
+  /** Uses [request] to connect a new web socket. */
+  override fun newWebSocket(request: Request, listener: WebSocketListener): WebSocket {
+    val webSocket = RealWebSocket(request, listener, Random(), pingInterval.toLong())
+    webSocket.connect(this)
+    return webSocket
+  }
+
+  open fun newBuilder(): Builder = Builder(this)
+
+  class Builder constructor() {
+    internal var dispatcher: Dispatcher = Dispatcher()
+    internal var proxy: Proxy? = null
+    internal var protocols: List<Protocol> = DEFAULT_PROTOCOLS
+    internal var connectionSpecs: List<ConnectionSpec> = DEFAULT_CONNECTION_SPECS
+    internal val interceptors: MutableList<Interceptor> = mutableListOf()
+    internal val networkInterceptors: MutableList<Interceptor> = mutableListOf()
+    internal var eventListenerFactory: EventListener.Factory = Util.eventListenerFactory(
+        EventListener.NONE)
+    internal var proxySelector: ProxySelector = ProxySelector.getDefault() ?: NullProxySelector()
+    internal var cookieJar: CookieJar = CookieJar.NO_COOKIES
+    internal var cache: Cache? = null
+    internal var internalCache: InternalCache? = null
+    internal var socketFactory: SocketFactory = SocketFactory.getDefault()
+    internal var sslSocketFactory: SSLSocketFactory? = null
+    internal var certificateChainCleaner: CertificateChainCleaner? = null
+    internal var hostnameVerifier: HostnameVerifier = OkHostnameVerifier.INSTANCE
+    internal var certificatePinner: CertificatePinner = CertificatePinner.DEFAULT
+    internal var proxyAuthenticator: Authenticator = Authenticator.NONE
+    internal var authenticator: Authenticator = Authenticator.NONE
+    internal var connectionPool: ConnectionPool = ConnectionPool()
+    internal var dns: Dns = Dns.SYSTEM
+    internal var followSslRedirects: Boolean = true
+    internal var followRedirects: Boolean = true
+    internal var retryOnConnectionFailure: Boolean = true
+    internal var callTimeout: Int = 0
+    internal var connectTimeout: Int = 10000
+    internal var readTimeout: Int = 10000
+    internal var writeTimeout: Int = 10000
+    internal var pingInterval: Int = 0
+
+    internal constructor(okHttpClient: OkHttpClient) : this() {
+      this.dispatcher = okHttpClient.dispatcher
+      this.proxy = okHttpClient.proxy
+      this.protocols = okHttpClient.protocols
+      this.connectionSpecs = okHttpClient.connectionSpecs
+      this.interceptors += okHttpClient.interceptors
+      this.networkInterceptors += okHttpClient.networkInterceptors
+      this.eventListenerFactory = okHttpClient.eventListenerFactory
+      this.proxySelector = okHttpClient.proxySelector
+      this.cookieJar = okHttpClient.cookieJar
+      this.internalCache = okHttpClient.internalCache
+      this.cache = okHttpClient.cache
+      this.socketFactory = okHttpClient.socketFactory
+      this.sslSocketFactory = okHttpClient.sslSocketFactory
+      this.certificateChainCleaner = okHttpClient.certificateChainCleaner
+      this.hostnameVerifier = okHttpClient.hostnameVerifier
+      this.certificatePinner = okHttpClient.certificatePinner
+      this.proxyAuthenticator = okHttpClient.proxyAuthenticator
+      this.authenticator = okHttpClient.authenticator
+      this.connectionPool = okHttpClient.connectionPool
+      this.dns = okHttpClient.dns
+      this.followSslRedirects = okHttpClient.followSslRedirects
+      this.followRedirects = okHttpClient.followRedirects
+      this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure
+      this.callTimeout = okHttpClient.callTimeout
+      this.connectTimeout = okHttpClient.connectTimeout
+      this.readTimeout = okHttpClient.readTimeout
+      this.writeTimeout = okHttpClient.writeTimeout
+      this.pingInterval = okHttpClient.pingInterval
+    }
+
+    /**
+     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+     * must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The call timeout spans the entire call: resolving DNS, connecting, writing the request body,
+     * server processing, and reading the response body. If the call requires redirects or retries
+     * all must complete within one timeout period.
+     *
+     * The default value is 0 which imposes no timeout.
+     */
+    fun callTimeout(timeout: Long, unit: TimeUnit) = apply {
+      callTimeout = checkDuration("timeout", timeout, unit)
+    }
+
+    /**
+     * Sets the default timeout for complete calls. A value of 0 means no timeout, otherwise values
+     * must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The call timeout spans the entire call: resolving DNS, connecting, writing the request body,
+     * server processing, and reading the response body. If the call requires redirects or retries
+     * all must complete within one timeout period.
+     *
+     * The default value is 0 which imposes no timeout.
+     */
+    @IgnoreJRERequirement
+    fun callTimeout(duration: Duration) = apply {
+      callTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+    }
+
+    /**
+     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+     * otherwise values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The connect timeout is applied when connecting a TCP socket to the target host. The default
+     * value is 10 seconds.
+     */
+    fun connectTimeout(timeout: Long, unit: TimeUnit) = apply {
+      connectTimeout = checkDuration("timeout", timeout, unit)
+    }
+
+    /**
+     * Sets the default connect timeout for new connections. A value of 0 means no timeout,
+     * otherwise values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The connect timeout is applied when connecting a TCP socket to the target host. The default
+     * value is 10 seconds.
+     */
+    @IgnoreJRERequirement
+    fun connectTimeout(duration: Duration) = apply {
+      connectTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+    }
+
+    /**
+     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The read timeout is applied to both the TCP socket and for individual read IO operations
+     * including on [Source] of the [Response]. The default value is 10 seconds.
+     *
+     * @see Socket.setSoTimeout
+     * @see Source.timeout
+     */
+    fun readTimeout(timeout: Long, unit: TimeUnit) = apply {
+      readTimeout = checkDuration("timeout", timeout, unit)
+    }
+
+    /**
+     * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The read timeout is applied to both the TCP socket and for individual read IO operations
+     * including on [Source] of the [Response]. The default value is 10 seconds.
+     *
+     * @see Socket.setSoTimeout
+     * @see Source.timeout
+     */
+    @IgnoreJRERequirement
+    fun readTimeout(duration: Duration) = apply {
+      readTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+    }
+
+    /**
+     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The write timeout is applied for individual write IO operations. The default value is 10
+     * seconds.
+     *
+     * @see Sink.timeout
+     */
+    fun writeTimeout(timeout: Long, unit: TimeUnit) = apply {
+      writeTimeout = checkDuration("timeout", timeout, unit)
+    }
+
+    /**
+     * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
+     * values must be between 1 and [Integer.MAX_VALUE] when converted to milliseconds.
+     *
+     * The write timeout is applied for individual write IO operations. The default value is 10
+     * seconds.
+     *
+     * @see Sink.timeout
+     */
+    @IgnoreJRERequirement
+    fun writeTimeout(duration: Duration) = apply {
+      writeTimeout = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+    }
+
+    /**
+     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+     * automatically send ping frames until either the connection fails or it is closed. This keeps
+     * the connection alive and may detect connectivity failures.
+     *
+     * If the server does not respond to each ping with a pong within `interval`, this client will
+     * assume that connectivity has been lost. When this happens on a web socket the connection is
+     * canceled and its listener is [notified][WebSocketListener.onFailure]. When it happens on an
+     * HTTP/2 connection the connection is closed and any calls it is carrying
+     * [will fail with an IOException][java.io.IOException].
+     *
+     * The default value of 0 disables client-initiated pings.
+     */
+    fun pingInterval(interval: Long, unit: TimeUnit) = apply {
+      pingInterval = checkDuration("interval", interval, unit)
+    }
+
+    /**
+     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+     * automatically send ping frames until either the connection fails or it is closed. This keeps
+     * the connection alive and may detect connectivity failures.
+     *
+     * If the server does not respond to each ping with a pong within `interval`, this client will
+     * assume that connectivity has been lost. When this happens on a web socket the connection is
+     * canceled and its listener is [notified][WebSocketListener.onFailure]. When it happens on an
+     * HTTP/2 connection the connection is closed and any calls it is carrying
+     * [will fail with an IOException][java.io.IOException].
+     *
+     * The default value of 0 disables client-initiated pings.
+     */
+    @IgnoreJRERequirement
+    fun pingInterval(duration: Duration) = apply {
+      pingInterval = checkDuration("timeout", duration.toMillis(), TimeUnit.MILLISECONDS)
+    }
+
+    /**
+     * Sets the HTTP proxy that will be used by connections created by this client. This takes
+     * precedence over [proxySelector], which is only honored when this proxy is null (which it is
+     * by default). To disable proxy use completely, call `proxy(Proxy.NO_PROXY)`.
+     */
+    fun proxy(proxy: Proxy?) = apply {
+      this.proxy = proxy
+    }
+
+    /**
+     * Sets the proxy selection policy to be used if no [proxy][proxy] is specified explicitly. The
+     * proxy selector may return multiple proxies; in that case they will be tried in sequence until
+     * a successful connection is established.
+     *
+     * If unset, the [system-wide default][ProxySelector.getDefault] proxy selector will be used.
+     */
+    fun proxySelector(proxySelector: ProxySelector) = apply {
+      this.proxySelector = proxySelector
+    }
+
+    /**
+     * Sets the handler that can accept cookies from incoming HTTP responses and provides cookies to
+     * outgoing HTTP requests.
+     *
+     * If unset, [no cookies][CookieJar.NO_COOKIES] will be accepted nor provided.
+     */
+    fun cookieJar(cookieJar: CookieJar) = apply {
+      this.cookieJar = cookieJar
+    }
+
+    /** Sets the response cache to be used to read and write cached responses.  */
+    fun cache(cache: Cache?) = apply {
+      this.cache = cache
+      this.internalCache = null
+    }
+
+    /**
+     * Sets the DNS service used to lookup IP addresses for hostnames.
+     *
+     * If unset, the [system-wide default][Dns.SYSTEM] DNS will be used.
+     */
+    fun dns(dns: Dns) = apply {
+      this.dns = dns
+    }
+
+    /**
+     * Sets the socket factory used to create connections. OkHttp only uses the parameterless
+     * [SocketFactory.createSocket] method to create unconnected sockets. Overriding this method,
+     * e. g., allows the socket to be bound to a specific local address.
+     *
+     * If unset, the [system-wide default][SocketFactory.getDefault] socket factory will be used.
+     */
+    fun socketFactory(socketFactory: SocketFactory) = apply {
+      if (socketFactory is SSLSocketFactory) {
+        throw IllegalArgumentException("socketFactory instanceof SSLSocketFactory")
+      }
+      this.socketFactory = socketFactory
+    }
+
+    /**
+     * Sets the socket factory used to secure HTTPS connections. If unset, the system default will
+     * be used.
+     *
+     * @deprecated [SSLSocketFactory] does not expose its [X509TrustManager], which is a field that
+     *     OkHttp needs to build a clean certificate chain. This method instead must use reflection
+     *     to extract the trust manager. Applications should prefer to call
+     *     `sslSocketFactory(SSLSocketFactory, X509TrustManager)`, which avoids such reflection.
+     */
+    @Deprecated(
+        message = "Use the sslSocketFactory overload that accepts a X509TrustManager.",
+        level = ERROR
+    )
+    fun sslSocketFactory(sslSocketFactory: SSLSocketFactory) = apply {
+      this.sslSocketFactory = sslSocketFactory
+      this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory)
+    }
+
+    /**
+     * Sets the socket factory and trust manager used to secure HTTPS connections. If unset, the
+     * system defaults will be used.
+     *
+     * Most applications should not call this method, and instead use the system defaults. Those
+     * classes include special optimizations that can be lost if the implementations are decorated.
+     *
+     * If necessary, you can create and configure the defaults yourself with the following code:
+     *
+     * ```
+     * TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+     * TrustManagerFactory.getDefaultAlgorithm());
+     * trustManagerFactory.init((KeyStore) null);
+     * TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+     * if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+     *     throw new IllegalStateException("Unexpected default trust managers:"
+     *         + Arrays.toString(trustManagers));
+     * }
+     * X509TrustManager trustManager = (X509TrustManager) trustManagers[0];
+     *
+     * SSLContext sslContext = SSLContext.getInstance("TLS");
+     * sslContext.init(null, new TrustManager[] { trustManager }, null);
+     * SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+     *
+     * OkHttpClient client = new OkHttpClient.Builder()
+     *     .sslSocketFactory(sslSocketFactory, trustManager)
+     *     .build();
+     * ```
+     */
+    fun sslSocketFactory(
+      sslSocketFactory: SSLSocketFactory, trustManager: X509TrustManager
+    ) = apply {
+      this.sslSocketFactory = sslSocketFactory
+      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager)
+    }
+
+    /**
+     * Sets the verifier used to confirm that response certificates apply to requested hostnames for
+     * HTTPS connections.
+     *
+     * If unset, a default hostname verifier will be used.
+     */
+    fun hostnameVerifier(hostnameVerifier: HostnameVerifier) = apply {
+      this.hostnameVerifier = hostnameVerifier
+    }
+
+    /**
+     * Sets the certificate pinner that constrains which certificates are trusted. By default HTTPS
+     * connections rely on only the [SSL socket factory][sslSocketFactory] to establish trust.
+     * Pinning certificates avoids the need to trust certificate authorities.
+     */
+    fun certificatePinner(certificatePinner: CertificatePinner) = apply {
+      this.certificatePinner = certificatePinner
+    }
+
+    /**
+     * Sets the authenticator used to respond to challenges from origin servers. Use
+     * [proxyAuthenticator] to set the authenticator for proxy servers.
+     *
+     * If unset, the [no authentication will be attempted][Authenticator.NONE].
+     */
+    fun authenticator(authenticator: Authenticator) = apply {
+      this.authenticator = authenticator
+    }
+
+    /**
+     * Sets the authenticator used to respond to challenges from proxy servers. Use [authenticator]
+     * to set the authenticator for origin servers.
+     *
+     * If unset, the [no authentication will be attempted][Authenticator.NONE].
+     */
+    fun proxyAuthenticator(proxyAuthenticator: Authenticator) = apply {
+      this.proxyAuthenticator = proxyAuthenticator
+    }
+
+    /**
+     * Sets the connection pool used to recycle HTTP and HTTPS connections.
+     *
+     * If unset, a new connection pool will be used.
+     */
+    fun connectionPool(connectionPool: ConnectionPool) = apply {
+      this.connectionPool = connectionPool
+    }
+
+    /**
+     * Configure this client to follow redirects from HTTPS to HTTP and from HTTP to HTTPS.
+     *
+     * If unset, protocol redirects will be followed. This is different than the built-in
+     * `HttpURLConnection`'s default.
+     */
+    fun followSslRedirects(followProtocolRedirects: Boolean) = apply {
+      this.followSslRedirects = followProtocolRedirects
+    }
+
+    /** Configure this client to follow redirects. If unset, redirects will be followed. */
+    fun followRedirects(followRedirects: Boolean) = apply {
+      this.followRedirects = followRedirects
+    }
+
+    /**
+     * Configure this client to retry or not when a connectivity problem is encountered. By default,
+     * this client silently recovers from the following problems:
+     *
+     * * **Unreachable IP addresses.** If the URL's host has multiple IP addresses,
+     *   failure to reach any individual IP address doesn't fail the overall request. This can
+     *   increase availability of multi-homed services.
+     *
+     * * **Stale pooled connections.** The [ConnectionPool] reuses sockets
+     *   to decrease request latency, but these connections will occasionally time out.
+     *
+     * * **Unreachable proxy servers.** A [ProxySelector] can be used to
+     *   attempt multiple proxy servers in sequence, eventually falling back to a direct
+     *   connection.
+     *
+     * Set this to false to avoid retrying requests when doing so is destructive. In this case the
+     * calling application should do its own recovery of connectivity failures.
+     */
+    fun retryOnConnectionFailure(retryOnConnectionFailure: Boolean) = apply {
+      this.retryOnConnectionFailure = retryOnConnectionFailure
+    }
+
+    /**
+     * Sets the dispatcher used to set policy and execute asynchronous requests. Must not be null.
+     */
+    fun dispatcher(dispatcher: Dispatcher) = apply {
+      this.dispatcher = dispatcher
+    }
+
+    /**
+     * Configure the protocols used by this client to communicate with remote servers. By default
+     * this client will prefer the most efficient transport available, falling back to more
+     * ubiquitous protocols. Applications should only call this method to avoid specific
+     * compatibility problems, such as web servers that behave incorrectly when HTTP/2 is enabled.
+     *
+     * The following protocols are currently supported:
+     *
+     * * [http/1.1][rfc_2616]
+     * * [h2][rfc_7540]
+     * * [h2 with prior knowledge(cleartext only)][rfc_7540_34]
+     *
+     * **This is an evolving set.** Future releases include support for transitional
+     * protocols. The http/1.1 transport will never be dropped.
+     *
+     * If multiple protocols are specified, [ALPN][alpn] will be used to negotiate a transport.
+     * Protocol negotiation is only attempted for HTTPS URLs.
+     *
+     * [Protocol.HTTP_1_0] is not supported in this set. Requests are initiated with `HTTP/1.1`. If
+     * the server responds with `HTTP/1.0`, that will be exposed by [Response.protocol].
+     *
+     * [alpn]: http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg
+     * [rfc_2616]: http://www.w3.org/Protocols/rfc2616/rfc2616.html
+     * [rfc_7540]: https://tools.ietf.org/html/rfc7540
+     * [rfc_7540_34]: https://tools.ietf.org/html/rfc7540#section-3.4
+     *
+     * @param protocols the protocols to use, in order of preference. If the list contains
+     *     [Protocol.H2_PRIOR_KNOWLEDGE] then that must be the only protocol and HTTPS URLs will not
+     *     be supported. Otherwise the list must contain [Protocol.HTTP_1_1]. The list must
+     *     not contain null or [Protocol.HTTP_1_0].
+     */
+    fun protocols(protocols: List<Protocol>) = apply {
+      // Create a private copy of the list.
+      val protocolsCopy = protocols.toMutableList()
+
+      // Validate that the list has everything we require and nothing we forbid.
+      require(Protocol.H2_PRIOR_KNOWLEDGE in protocolsCopy || Protocol.HTTP_1_1 in protocolsCopy) {
+        "protocols must contain h2_prior_knowledge or http/1.1: $protocolsCopy"
+      }
+      require(Protocol.H2_PRIOR_KNOWLEDGE !in protocolsCopy || protocolsCopy.size <= 1) {
+        "protocols containing h2_prior_knowledge cannot use other protocols: $protocolsCopy"
+      }
+      require(Protocol.HTTP_1_0 !in protocolsCopy) {
+        "protocols must not contain http/1.0: $protocolsCopy"
+      }
+      require(null !in (protocols as List<Protocol?>)) {
+        "protocols must not contain null"
+      }
+
+      // Remove protocolsCopy that we no longer support.
+      @Suppress("DEPRECATION")
+      protocolsCopy.remove(Protocol.SPDY_3)
+
+      // Assign as an unmodifiable list. This is effectively immutable.
+      this.protocols = Collections.unmodifiableList(protocols)
+    }
+
+    fun connectionSpecs(connectionSpecs: List<ConnectionSpec>) = apply {
+      this.connectionSpecs = Util.immutableList(connectionSpecs)
+    }
+
+    /**
+     * Returns a modifiable list of interceptors that observe the full span of each call: from
+     * before the connection is established (if any) until after the response source is selected
+     * (either the origin server, cache, or both).
+     */
+    fun interceptors(): List<Interceptor> = interceptors
+
+    fun addInterceptor(interceptor: Interceptor) = apply {
+      interceptors += interceptor
+    }
+
+    /**
+     * Returns a modifiable list of interceptors that observe a single network request and response.
+     * These interceptors must call [Interceptor.Chain.proceed] exactly once: it is an error for a
+     * network interceptor to short-circuit or repeat a network request.
+     */
+    fun networkInterceptors(): List<Interceptor> = networkInterceptors
+
+    fun addNetworkInterceptor(interceptor: Interceptor) = apply {
+      networkInterceptors += interceptor
+    }
+
+    /**
+     * Configure a single client scoped listener that will receive all analytic events for this
+     * client.
+     *
+     * @see EventListener for semantics and restrictions on listener implementations.
+     */
+    fun eventListener(eventListener: EventListener) = apply {
+      this.eventListenerFactory = Util.eventListenerFactory(eventListener)
+    }
+
+    /**
+     * Configure a factory to provide per-call scoped listeners that will receive analytic events
+     * for this client.
+     *
+     * @see EventListener for semantics and restrictions on listener implementations.
+     */
+    fun eventListenerFactory(eventListenerFactory: EventListener.Factory) = apply {
+      this.eventListenerFactory = eventListenerFactory
+    }
+
+    fun build(): OkHttpClient = OkHttpClient(this)
+  }
+
+  companion object {
+    internal val DEFAULT_PROTOCOLS = Util.immutableList(HTTP_2, HTTP_1_1)
+
+    internal val DEFAULT_CONNECTION_SPECS = Util.immutableList(
+        ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT)
+
+    init {
+      Internal.instance = object : Internal() {
+        override fun realConnectionPool(connectionPool: ConnectionPool) =
+            connectionPool.delegate
+
+        override fun equalsNonHost(a: Address, b: Address) = a.equalsNonHost(b)
+
+        override fun code(responseBuilder: Response.Builder) = responseBuilder.code
+
+        override fun newWebSocketCall(client: OkHttpClient, originalRequest: Request) =
+            RealCall.newRealCall(client, originalRequest, true)
+
+        override fun initExchange(responseBuilder: Response.Builder, exchange: Exchange) {
+          responseBuilder.initExchange(exchange)
+        }
+
+        override fun exchange(response: Response) = response.exchange
+      }
+    }
+
+    private fun newSslSocketFactory(trustManager: X509TrustManager): SSLSocketFactory {
+      try {
+        val sslContext = Platform.get().getSSLContext()
+        sslContext.init(null, arrayOf<TrustManager>(trustManager), null)
+        return sslContext.socketFactory
+      } catch (e: GeneralSecurityException) {
+        throw AssertionError("No System TLS", e) // The system has no TLS. Just give up.
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Protocol.java b/okhttp/src/main/java/okhttp3/Protocol.java
deleted file mode 100644
index 108155f3bd..0000000000
--- a/okhttp/src/main/java/okhttp3/Protocol.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-
-/**
- * Protocols that OkHttp implements for <a
- * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> selection.
- *
- * <h3>Protocol vs Scheme</h3> Despite its name, {@link java.net.URL#getProtocol()} returns the
- * {@linkplain java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not the protocol
- * (http/1.1, spdy/3.1, etc.). OkHttp uses the word <i>protocol</i> to identify how HTTP messages
- * are framed.
- */
-public enum Protocol {
-  /**
-   * An obsolete plaintext framing that does not use persistent sockets by default.
-   */
-  HTTP_1_0("http/1.0"),
-
-  /**
-   * A plaintext framing that includes persistent connections.
-   *
-   * <p>This version of OkHttp implements <a href="https://tools.ietf.org/html/rfc7230">RFC
-   * 7230</a>, and tracks revisions to that spec.
-   */
-  HTTP_1_1("http/1.1"),
-
-  /**
-   * Chromium's binary-framed protocol that includes header compression, multiplexing multiple
-   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on SPDY/3.
-   *
-   * <p>Current versions of OkHttp do not support this protocol.
-   *
-   * @deprecated OkHttp has dropped support for SPDY. Prefer {@link #HTTP_2}.
-   */
-  SPDY_3("spdy/3.1"),
-
-  /**
-   * The IETF's binary-framed protocol that includes header compression, multiplexing multiple
-   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on HTTP/2.
-   *
-   * <p>HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support {@linkplain
-   * CipherSuite#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256} , present in Java 8+ and Android 5+. Servers
-   * that enforce this may send an exception message including the string {@code
-   * INADEQUATE_SECURITY}.
-   */
-  HTTP_2("h2"),
-
-  /**
-   * Cleartext implementation of HTTP2. This enumeration exists for the "prior knowledge" upgrade
-   * semantic supported by the protocol.
-   *
-   * @see <a href="https://tools.ietf.org/html/rfc7540#section-3.4">Starting HTTP/2 with Prior
-   * Knowledge</a>
-   */
-  H2C("h2c"),
-
-  /**
-   * QUIC (Quick UDP Internet Connection) is a new multiplexed and secure transport atop UDP,
-   * designed from the ground up and optimized for HTTP/2 semantics.
-   * HTTP/1.1 semantics are layered on HTTP/2.
-   *
-   * <p>QUIC is not natively supported by OkHttp, but provided to allow a theoretical
-   * interceptor that provides support.
-   */
-  QUIC("quic");
-
-  private final String protocol;
-
-  Protocol(String protocol) {
-    this.protocol = protocol;
-  }
-
-  /**
-   * Returns the protocol identified by {@code protocol}.
-   *
-   * @throws IOException if {@code protocol} is unknown.
-   */
-  public static Protocol get(String protocol) throws IOException {
-    // Unroll the loop over values() to save an allocation.
-    if (protocol.equals(HTTP_1_0.protocol)) return HTTP_1_0;
-    if (protocol.equals(HTTP_1_1.protocol)) return HTTP_1_1;
-    if (protocol.equals(H2C.protocol)) return H2C;
-    if (protocol.equals(HTTP_2.protocol)) return HTTP_2;
-    if (protocol.equals(SPDY_3.protocol)) return SPDY_3;
-    if (protocol.equals(QUIC.protocol)) return QUIC;
-    throw new IOException("Unexpected protocol: " + protocol);
-  }
-
-  /**
-   * Returns the string used to identify this protocol for ALPN, like "http/1.1", "spdy/3.1" or
-   * "h2".
-   *
-   * @see <a href="https://www.iana.org/assignments/tls-extensiontype-values">IANA
-   * tls-extensiontype-values</a>
-   */
-  @Override public String toString() {
-    return protocol;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Protocol.kt b/okhttp/src/main/java/okhttp3/Protocol.kt
new file mode 100644
index 0000000000..d3f920362d
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Protocol.kt
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.io.IOException
+
+/**
+ * Protocols that OkHttp implements for [ALPN][ietf_alpn] selection.
+ *
+ * ## Protocol vs Scheme
+ *
+ * Despite its name, [java.net.URL.getProtocol] returns the [scheme][java.net.URI.getScheme] (http,
+ * https, etc.) of the URL, not the protocol (http/1.1, spdy/3.1, etc.). OkHttp uses the word
+ * *protocol* to identify how HTTP messages are framed.
+ *
+ * [ietf_alpn]: http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg
+ */
+enum class Protocol(private val protocol: String) {
+  /**
+   * An obsolete plaintext framing that does not use persistent sockets by default.
+   */
+  HTTP_1_0("http/1.0"),
+
+  /**
+   * A plaintext framing that includes persistent connections.
+   *
+   * This version of OkHttp implements [RFC 7230][rfc_7230], and tracks revisions to that spec.
+   *
+   * [rfc_7230]: https://tools.ietf.org/html/rfc7230
+   */
+  HTTP_1_1("http/1.1"),
+
+  /**
+   * Chromium's binary-framed protocol that includes header compression, multiplexing multiple
+   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on SPDY/3.
+   *
+   * Current versions of OkHttp do not support this protocol.
+   */
+  @Deprecated("OkHttp has dropped support for SPDY. Prefer {@link #HTTP_2}.")
+  SPDY_3("spdy/3.1"),
+
+  /**
+   * The IETF's binary-framed protocol that includes header compression, multiplexing multiple
+   * requests on the same socket, and server-push. HTTP/1.1 semantics are layered on HTTP/2.
+   *
+   * HTTP/2 requires deployments of HTTP/2 that use TLS 1.2 support
+   * [CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256], present in Java 8+ and Android 5+.
+   * Servers that enforce this may send an exception message including the string
+   * `INADEQUATE_SECURITY`.
+   */
+  HTTP_2("h2"),
+
+  /**
+   * Cleartext HTTP/2 with no "upgrade" round trip. This option requires the client to have prior
+   * knowledge that the server supports cleartext HTTP/2.
+   *
+   * See also [Starting HTTP/2 with Prior Knowledge][rfc_7540_34].
+   *
+   * [rfc_7540_34]: https://tools.ietf.org/html/rfc7540.section-3.4
+   */
+  H2_PRIOR_KNOWLEDGE("h2_prior_knowledge"),
+
+  /**
+   * QUIC (Quick UDP Internet Connection) is a new multiplexed and secure transport atop UDP,
+   * designed from the ground up and optimized for HTTP/2 semantics. HTTP/1.1 semantics are layered
+   * on HTTP/2.
+   *
+   * QUIC is not natively supported by OkHttp, but provided to allow a theoretical interceptor that
+   * provides support.
+   */
+  QUIC("quic");
+
+  /**
+   * Returns the string used to identify this protocol for ALPN, like "http/1.1", "spdy/3.1" or
+   * "h2".
+   *
+   * See also [IANA tls-extensiontype-values][iana].
+   *
+   * [iana]: https://www.iana.org/assignments/tls-extensiontype-values
+   */
+  override fun toString() = protocol
+
+  companion object {
+    /**
+     * Returns the protocol identified by `protocol`.
+     *
+     * @throws IOException if `protocol` is unknown.
+     */
+    @JvmStatic
+    @Throws(IOException::class)
+    operator fun get(protocol: String): Protocol {
+      // Unroll the loop over values() to save an allocation.
+      @Suppress("DEPRECATION")
+      return when (protocol) {
+        HTTP_1_0.protocol -> HTTP_1_0
+        HTTP_1_1.protocol -> HTTP_1_1
+        H2_PRIOR_KNOWLEDGE.protocol -> H2_PRIOR_KNOWLEDGE
+        HTTP_2.protocol -> HTTP_2
+        SPDY_3.protocol -> SPDY_3
+        QUIC.protocol -> QUIC
+        else -> throw IOException("Unexpected protocol: $protocol")
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
deleted file mode 100644
index 808b3dc7ba..0000000000
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import okhttp3.internal.NamedRunnable;
-import okhttp3.internal.cache.CacheInterceptor;
-import okhttp3.internal.connection.ConnectInterceptor;
-import okhttp3.internal.connection.StreamAllocation;
-import okhttp3.internal.http.BridgeInterceptor;
-import okhttp3.internal.http.CallServerInterceptor;
-import okhttp3.internal.http.RealInterceptorChain;
-import okhttp3.internal.http.RetryAndFollowUpInterceptor;
-import okhttp3.internal.platform.Platform;
-
-import static okhttp3.internal.platform.Platform.INFO;
-
-final class RealCall implements Call {
-  final OkHttpClient client;
-  final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
-
-  /**
-   * There is a cycle between the {@link Call} and {@link EventListener} that makes this awkward.
-   * This will be set after we create the call instance then create the event listener instance.
-   */
-  private EventListener eventListener;
-
-  /** The application's original request unadulterated by redirects or auth headers. */
-  final Request originalRequest;
-  final boolean forWebSocket;
-
-  // Guarded by this.
-  private boolean executed;
-
-  private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
-    this.client = client;
-    this.originalRequest = originalRequest;
-    this.forWebSocket = forWebSocket;
-    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
-  }
-
-  static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
-    // Safely publish the Call instance to the EventListener.
-    RealCall call = new RealCall(client, originalRequest, forWebSocket);
-    call.eventListener = client.eventListenerFactory().create(call);
-    return call;
-  }
-
-  @Override public Request request() {
-    return originalRequest;
-  }
-
-  @Override public Response execute() throws IOException {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
-      executed = true;
-    }
-    captureCallStackTrace();
-    eventListener.callStart(this);
-    try {
-      client.dispatcher().executed(this);
-      Response result = getResponseWithInterceptorChain();
-      if (result == null) throw new IOException("Canceled");
-      return result;
-    } catch (IOException e) {
-      eventListener.callFailed(this, e);
-      throw e;
-    } finally {
-      client.dispatcher().finished(this);
-    }
-  }
-
-  private void captureCallStackTrace() {
-    Object callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
-    retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
-  }
-
-  @Override public void enqueue(Callback responseCallback) {
-    synchronized (this) {
-      if (executed) throw new IllegalStateException("Already Executed");
-      executed = true;
-    }
-    captureCallStackTrace();
-    eventListener.callStart(this);
-    client.dispatcher().enqueue(new AsyncCall(responseCallback));
-  }
-
-  @Override public void cancel() {
-    retryAndFollowUpInterceptor.cancel();
-  }
-
-  @Override public synchronized boolean isExecuted() {
-    return executed;
-  }
-
-  @Override public boolean isCanceled() {
-    return retryAndFollowUpInterceptor.isCanceled();
-  }
-
-  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
-  @Override public RealCall clone() {
-    return RealCall.newRealCall(client, originalRequest, forWebSocket);
-  }
-
-  StreamAllocation streamAllocation() {
-    return retryAndFollowUpInterceptor.streamAllocation();
-  }
-
-  final class AsyncCall extends NamedRunnable {
-    private final Callback responseCallback;
-
-    AsyncCall(Callback responseCallback) {
-      super("OkHttp %s", redactedUrl());
-      this.responseCallback = responseCallback;
-    }
-
-    String host() {
-      return originalRequest.url().host();
-    }
-
-    Request request() {
-      return originalRequest;
-    }
-
-    RealCall get() {
-      return RealCall.this;
-    }
-
-    @Override protected void execute() {
-      boolean signalledCallback = false;
-      try {
-        Response response = getResponseWithInterceptorChain();
-        if (retryAndFollowUpInterceptor.isCanceled()) {
-          signalledCallback = true;
-          responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
-        } else {
-          signalledCallback = true;
-          responseCallback.onResponse(RealCall.this, response);
-        }
-      } catch (IOException e) {
-        if (signalledCallback) {
-          // Do not signal the callback twice!
-          Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
-        } else {
-          eventListener.callFailed(RealCall.this, e);
-          responseCallback.onFailure(RealCall.this, e);
-        }
-      } finally {
-        client.dispatcher().finished(this);
-      }
-    }
-  }
-
-  /**
-   * Returns a string that describes this call. Doesn't include a full URL as that might contain
-   * sensitive information.
-   */
-  String toLoggableString() {
-    return (isCanceled() ? "canceled " : "")
-        + (forWebSocket ? "web socket" : "call")
-        + " to " + redactedUrl();
-  }
-
-  String redactedUrl() {
-    return originalRequest.url().redact();
-  }
-
-  Response getResponseWithInterceptorChain() throws IOException {
-    // Build a full stack of interceptors.
-    List<Interceptor> interceptors = new ArrayList<>();
-    interceptors.addAll(client.interceptors());
-    interceptors.add(retryAndFollowUpInterceptor);
-    interceptors.add(new BridgeInterceptor(client.cookieJar()));
-    interceptors.add(new CacheInterceptor(client.internalCache()));
-    interceptors.add(new ConnectInterceptor(client));
-    if (!forWebSocket) {
-      interceptors.addAll(client.networkInterceptors());
-    }
-    interceptors.add(new CallServerInterceptor(forWebSocket));
-
-    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
-        originalRequest, this, eventListener, client.connectTimeoutMillis(),
-        client.readTimeoutMillis(), client.writeTimeoutMillis());
-
-    return chain.proceed(originalRequest);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/RealCall.kt b/okhttp/src/main/java/okhttp3/RealCall.kt
new file mode 100644
index 0000000000..d9be4ba0e1
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/RealCall.kt
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.NamedRunnable
+import okhttp3.internal.Util.closeQuietly
+import okhttp3.internal.cache.CacheInterceptor
+import okhttp3.internal.connection.ConnectInterceptor
+import okhttp3.internal.connection.Transmitter
+import okhttp3.internal.http.BridgeInterceptor
+import okhttp3.internal.http.CallServerInterceptor
+import okhttp3.internal.http.RealInterceptorChain
+import okhttp3.internal.http.RetryAndFollowUpInterceptor
+import okhttp3.internal.platform.Platform
+import okhttp3.internal.platform.Platform.Companion.INFO
+import okio.Timeout
+import java.io.IOException
+import java.io.InterruptedIOException
+import java.util.ArrayList
+import java.util.concurrent.ExecutorService
+import java.util.concurrent.RejectedExecutionException
+import java.util.concurrent.atomic.AtomicInteger
+
+internal class RealCall private constructor(
+  val client: OkHttpClient,
+  /** The application's original request unadulterated by redirects or auth headers.  */
+  val originalRequest: Request,
+  val forWebSocket: Boolean
+) : Call {
+  /**
+   * There is a cycle between the [Call] and [Transmitter] that makes this awkward.
+   * This is set after immediately after creating the call instance.
+   */
+  private lateinit var transmitter: Transmitter
+
+  // Guarded by this.
+  @get:Synchronized override var isExecuted: Boolean = false
+
+  override val isCanceled: Boolean
+    get() = transmitter.isCanceled
+
+  override fun request(): Request = originalRequest
+
+  override fun execute(): Response {
+    synchronized(this) {
+      check(!isExecuted) { "Already Executed" }
+      isExecuted = true
+    }
+    transmitter.timeoutEnter()
+    transmitter.callStart()
+    try {
+      client.dispatcher().executed(this)
+      return getResponseWithInterceptorChain()
+    } finally {
+      client.dispatcher().finished(this)
+    }
+  }
+
+  override fun enqueue(responseCallback: Callback) {
+    synchronized(this) {
+      check(!isExecuted) { "Already Executed" }
+      isExecuted = true
+    }
+    transmitter.callStart()
+    client.dispatcher().enqueue(AsyncCall(responseCallback))
+  }
+
+  override fun cancel() {
+    transmitter.cancel()
+  }
+
+  override fun timeout(): Timeout = transmitter.timeout()
+
+  @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
+  override fun clone(): RealCall {
+    return RealCall.newRealCall(client, originalRequest, forWebSocket)
+  }
+
+  internal inner class AsyncCall(
+    private val responseCallback: Callback
+  ) : NamedRunnable("OkHttp %s", redactedUrl()) {
+    @Volatile private var callsPerHost = AtomicInteger(0)
+
+    fun callsPerHost(): AtomicInteger = callsPerHost
+
+    fun reuseCallsPerHostFrom(other: AsyncCall) {
+      this.callsPerHost = other.callsPerHost
+    }
+
+    fun host(): String = originalRequest.url().host()
+
+    fun request(): Request = originalRequest
+
+    fun get(): RealCall = this@RealCall
+
+    /**
+     * Attempt to enqueue this async call on `executorService`. This will attempt to clean up
+     * if the executor has been shut down by reporting the call as failed.
+     */
+    fun executeOn(executorService: ExecutorService) {
+      assert(!Thread.holdsLock(client.dispatcher()))
+      var success = false
+      try {
+        executorService.execute(this)
+        success = true
+      } catch (e: RejectedExecutionException) {
+        val ioException = InterruptedIOException("executor rejected")
+        ioException.initCause(e)
+        transmitter.noMoreExchanges(ioException)
+        responseCallback.onFailure(this@RealCall, ioException)
+      } finally {
+        if (!success) {
+          client.dispatcher().finished(this) // This call is no longer running!
+        }
+      }
+    }
+
+    override fun execute() {
+      var signalledCallback = false
+      transmitter.timeoutEnter()
+      try {
+        val response = getResponseWithInterceptorChain()
+        signalledCallback = true
+        responseCallback.onResponse(this@RealCall, response)
+      } catch (e: IOException) {
+        if (signalledCallback) {
+          // Do not signal the callback twice!
+          Platform.get().log(INFO, "Callback failure for ${toLoggableString()}", e)
+        } else {
+          responseCallback.onFailure(this@RealCall, e)
+        }
+      } finally {
+        client.dispatcher().finished(this)
+      }
+    }
+  }
+
+  /**
+   * Returns a string that describes this call. Doesn't include a full URL as that might contain
+   * sensitive information.
+   */
+  fun toLoggableString(): String {
+    return ((if (isCanceled) "canceled " else "")
+        + (if (forWebSocket) "web socket" else "call")
+        + " to " + redactedUrl())
+  }
+
+  fun redactedUrl(): String = originalRequest.url().redact()
+
+  @Throws(IOException::class)
+  fun getResponseWithInterceptorChain(): Response {
+    // Build a full stack of interceptors.
+    val interceptors = ArrayList<Interceptor>()
+    interceptors.addAll(client.interceptors())
+    interceptors.add(RetryAndFollowUpInterceptor(client))
+    interceptors.add(BridgeInterceptor(client.cookieJar()))
+    interceptors.add(CacheInterceptor(client.internalCache()))
+    interceptors.add(ConnectInterceptor(client))
+    if (!forWebSocket) {
+      interceptors.addAll(client.networkInterceptors())
+    }
+    interceptors.add(CallServerInterceptor(forWebSocket))
+
+    val chain = RealInterceptorChain(interceptors, transmitter, null, 0,
+        originalRequest, this, client.connectTimeoutMillis(),
+        client.readTimeoutMillis(), client.writeTimeoutMillis())
+
+    var calledNoMoreExchanges = false
+    try {
+      val response = chain.proceed(originalRequest)
+      if (transmitter.isCanceled) {
+        closeQuietly(response)
+        throw IOException("Canceled")
+      }
+      return response
+    } catch (e: IOException) {
+      calledNoMoreExchanges = true
+      throw transmitter.noMoreExchanges(e) as Throwable
+    } finally {
+      if (!calledNoMoreExchanges) {
+        transmitter.noMoreExchanges(null)
+      }
+    }
+  }
+
+  companion object {
+    fun newRealCall(
+      client: OkHttpClient,
+      originalRequest: Request,
+      forWebSocket: Boolean
+    ): RealCall {
+      // Safely publish the Call instance to the EventListener.
+      return RealCall(client, originalRequest, forWebSocket).apply {
+        transmitter = Transmitter(client, this)
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
deleted file mode 100644
index fa9aaa434f..0000000000
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ /dev/null
@@ -1,260 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.URL;
-import java.util.List;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpMethod;
-
-/**
- * An HTTP request. Instances of this class are immutable if their {@link #body} is null or itself
- * immutable.
- */
-public final class Request {
-  final HttpUrl url;
-  final String method;
-  final Headers headers;
-  final @Nullable RequestBody body;
-  final Object tag;
-
-  private volatile CacheControl cacheControl; // Lazily initialized.
-
-  Request(Builder builder) {
-    this.url = builder.url;
-    this.method = builder.method;
-    this.headers = builder.headers.build();
-    this.body = builder.body;
-    this.tag = builder.tag != null ? builder.tag : this;
-  }
-
-  public HttpUrl url() {
-    return url;
-  }
-
-  public String method() {
-    return method;
-  }
-
-  public Headers headers() {
-    return headers;
-  }
-
-  public @Nullable String header(String name) {
-    return headers.get(name);
-  }
-
-  public List<String> headers(String name) {
-    return headers.values(name);
-  }
-
-  public @Nullable RequestBody body() {
-    return body;
-  }
-
-  public Object tag() {
-    return tag;
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  /**
-   * Returns the cache control directives for this response. This is never null, even if this
-   * response contains no {@code Cache-Control} header.
-   */
-  public CacheControl cacheControl() {
-    CacheControl result = cacheControl;
-    return result != null ? result : (cacheControl = CacheControl.parse(headers));
-  }
-
-  public boolean isHttps() {
-    return url.isHttps();
-  }
-
-  @Override public String toString() {
-    return "Request{method="
-        + method
-        + ", url="
-        + url
-        + ", tag="
-        + (tag != this ? tag : null)
-        + '}';
-  }
-
-  public static class Builder {
-    HttpUrl url;
-    String method;
-    Headers.Builder headers;
-    RequestBody body;
-    Object tag;
-
-    public Builder() {
-      this.method = "GET";
-      this.headers = new Headers.Builder();
-    }
-
-    Builder(Request request) {
-      this.url = request.url;
-      this.method = request.method;
-      this.body = request.body;
-      this.tag = request.tag;
-      this.headers = request.headers.newBuilder();
-    }
-
-    public Builder url(HttpUrl url) {
-      if (url == null) throw new NullPointerException("url == null");
-      this.url = url;
-      return this;
-    }
-
-    /**
-     * Sets the URL target of this request.
-     *
-     * @throws IllegalArgumentException if {@code url} is not a valid HTTP or HTTPS URL. Avoid this
-     * exception by calling {@link HttpUrl#parse}; it returns null for invalid URLs.
-     */
-    public Builder url(String url) {
-      if (url == null) throw new NullPointerException("url == null");
-
-      // Silently replace web socket URLs with HTTP URLs.
-      if (url.regionMatches(true, 0, "ws:", 0, 3)) {
-        url = "http:" + url.substring(3);
-      } else if (url.regionMatches(true, 0, "wss:", 0, 4)) {
-        url = "https:" + url.substring(4);
-      }
-
-      HttpUrl parsed = HttpUrl.parse(url);
-      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
-      return url(parsed);
-    }
-
-    /**
-     * Sets the URL target of this request.
-     *
-     * @throws IllegalArgumentException if the scheme of {@code url} is not {@code http} or {@code
-     * https}.
-     */
-    public Builder url(URL url) {
-      if (url == null) throw new NullPointerException("url == null");
-      HttpUrl parsed = HttpUrl.get(url);
-      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
-      return url(parsed);
-    }
-
-    /**
-     * Sets the header named {@code name} to {@code value}. If this request already has any headers
-     * with that name, they are all replaced.
-     */
-    public Builder header(String name, String value) {
-      headers.set(name, value);
-      return this;
-    }
-
-    /**
-     * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
-     * headers like "Cookie".
-     *
-     * <p>Note that for some headers including {@code Content-Length} and {@code Content-Encoding},
-     * OkHttp may replace {@code value} with a header derived from the request body.
-     */
-    public Builder addHeader(String name, String value) {
-      headers.add(name, value);
-      return this;
-    }
-
-    /** Removes all headers named {@code name} on this builder. */
-    public Builder removeHeader(String name) {
-      headers.removeAll(name);
-      return this;
-    }
-
-    /** Removes all headers on this builder and adds {@code headers}. */
-    public Builder headers(Headers headers) {
-      this.headers = headers.newBuilder();
-      return this;
-    }
-
-    /**
-     * Sets this request's {@code Cache-Control} header, replacing any cache control headers already
-     * present. If {@code cacheControl} doesn't define any directives, this clears this request's
-     * cache-control headers.
-     */
-    public Builder cacheControl(CacheControl cacheControl) {
-      String value = cacheControl.toString();
-      if (value.isEmpty()) return removeHeader("Cache-Control");
-      return header("Cache-Control", value);
-    }
-
-    public Builder get() {
-      return method("GET", null);
-    }
-
-    public Builder head() {
-      return method("HEAD", null);
-    }
-
-    public Builder post(RequestBody body) {
-      return method("POST", body);
-    }
-
-    public Builder delete(@Nullable RequestBody body) {
-      return method("DELETE", body);
-    }
-
-    public Builder delete() {
-      return delete(Util.EMPTY_REQUEST);
-    }
-
-    public Builder put(RequestBody body) {
-      return method("PUT", body);
-    }
-
-    public Builder patch(RequestBody body) {
-      return method("PATCH", body);
-    }
-
-    public Builder method(String method, @Nullable RequestBody body) {
-      if (method == null) throw new NullPointerException("method == null");
-      if (method.length() == 0) throw new IllegalArgumentException("method.length() == 0");
-      if (body != null && !HttpMethod.permitsRequestBody(method)) {
-        throw new IllegalArgumentException("method " + method + " must not have a request body.");
-      }
-      if (body == null && HttpMethod.requiresRequestBody(method)) {
-        throw new IllegalArgumentException("method " + method + " must have a request body.");
-      }
-      this.method = method;
-      this.body = body;
-      return this;
-    }
-
-    /**
-     * Attaches {@code tag} to the request. It can be used later to cancel the request. If the tag
-     * is unspecified or null, the request is canceled by using the request itself as the tag.
-     */
-    public Builder tag(Object tag) {
-      this.tag = tag;
-      return this;
-    }
-
-    public Request build() {
-      if (url == null) throw new IllegalStateException("url == null");
-      return new Request(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Request.kt b/okhttp/src/main/java/okhttp3/Request.kt
new file mode 100644
index 0000000000..244bd86aef
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Request.kt
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.Util
+import okhttp3.internal.http.HttpMethod
+import java.net.URL
+
+/**
+ * An HTTP request. Instances of this class are immutable if their [body] is null or itself
+ * immutable.
+ */
+class Request internal constructor(
+  internal val url: HttpUrl,
+  builder: Builder
+) {
+  internal val method: String = builder.method
+  internal val headers: Headers = builder.headers.build()
+  internal val body: RequestBody? = builder.body
+  internal val tags: Map<Class<*>, Any> = Util.immutableMap(builder.tags)
+
+  @Volatile
+  private var cacheControl: CacheControl? = null // Lazily initialized
+
+  val isHttps: Boolean
+    get() = url.isHttps
+
+  fun url(): HttpUrl = url
+
+  fun method(): String = method
+
+  fun headers(): Headers = headers
+
+  fun header(name: String): String? = headers[name]
+
+  fun headers(name: String): List<String> = headers.values(name)
+
+  fun body(): RequestBody? = body
+
+  /**
+   * Returns the tag attached with `Object.class` as a key, or null if no tag is attached with
+   * that key.
+   *
+   * Prior to OkHttp 3.11, this method never returned null if no tag was attached. Instead it
+   * returned either this request, or the request upon which this request was derived with
+   * [newBuilder].
+   */
+  fun tag(): Any? = tag(Any::class.java)
+
+  /**
+   * Returns the tag attached with [type] as a key, or null if no tag is attached with that
+   * key.
+   */
+  fun <T> tag(type: Class<out T>): T? = type.cast(tags[type])
+
+  fun newBuilder(): Builder = Builder(this)
+
+  /**
+   * Returns the cache control directives for this response. This is never null, even if this
+   * response contains no `Cache-Control` header.
+   */
+  fun cacheControl(): CacheControl {
+    return cacheControl ?: CacheControl.parse(headers).also {
+      this.cacheControl = it
+    }
+  }
+
+  override fun toString(): String = "Request{method=$method, url=$url, tags=$tags}"
+
+  open class Builder {
+    internal var url: HttpUrl? = null
+    internal var method: String
+    internal var headers: Headers.Builder
+    internal var body: RequestBody? = null
+
+    /** A mutable map of tags, or an immutable empty map if we don't have any. */
+    internal var tags: MutableMap<Class<*>, Any> = mutableMapOf()
+
+    constructor() {
+      this.method = "GET"
+      this.headers = Headers.Builder()
+    }
+
+    internal constructor(request: Request) {
+      this.url = request.url
+      this.method = request.method
+      this.body = request.body
+      this.tags = if (request.tags.isEmpty()) {
+        mutableMapOf()
+      } else {
+        request.tags.toMutableMap()
+      }
+      this.headers = request.headers.newBuilder()
+    }
+
+    open fun url(url: HttpUrl): Builder = apply {
+      this.url = url
+    }
+
+    /**
+     * Sets the URL target of this request.
+     *
+     * @throws IllegalArgumentException if [url] is not a valid HTTP or HTTPS URL. Avoid this
+     *     exception by calling [HttpUrl.parse]; it returns null for invalid URLs.
+     */
+    open fun url(url: String): Builder {
+      // Silently replace web socket URLs with HTTP URLs.
+      val finalUrl: String = when {
+        url.regionMatches(0, "ws:", 0, 3, ignoreCase = true) -> {
+          "http:${url.substring(3)}"
+        }
+        url.regionMatches(0, "wss:", 0, 4, ignoreCase = true) -> {
+          "https:${url.substring(4)}"
+        }
+        else -> url
+      }
+
+      return url(HttpUrl.get(finalUrl))
+    }
+
+    /**
+     * Sets the URL target of this request.
+     *
+     * @throws IllegalArgumentException if the scheme of [url] is not `http` or `https`.
+     */
+    open fun url(url: URL) = url(HttpUrl.get(url.toString()))
+
+    /**
+     * Sets the header named [name] to [value]. If this request already has any headers
+     * with that name, they are all replaced.
+     */
+    open fun header(name: String, value: String) = apply {
+      headers[name] = value
+    }
+
+    /**
+     * Adds a header with [name] and [value]. Prefer this method for multiply-valued
+     * headers like "Cookie".
+     *
+     * Note that for some headers including `Content-Length` and `Content-Encoding`,
+     * OkHttp may replace [value] with a header derived from the request body.
+     */
+    open fun addHeader(name: String, value: String) = apply {
+      headers.add(name, value)
+    }
+
+    /** Removes all headers named [name] on this builder. */
+    open fun removeHeader(name: String) = apply {
+      headers.removeAll(name)
+    }
+
+    /** Removes all headers on this builder and adds [headers]. */
+    open fun headers(headers: Headers) = apply {
+      this.headers = headers.newBuilder()
+    }
+
+    /**
+     * Sets this request's `Cache-Control` header, replacing any cache control headers already
+     * present. If [cacheControl] doesn't define any directives, this clears this request's
+     * cache-control headers.
+     */
+    open fun cacheControl(cacheControl: CacheControl): Builder {
+      val value = cacheControl.toString()
+      return when {
+        value.isEmpty() -> removeHeader("Cache-Control")
+        else -> header("Cache-Control", value)
+      }
+    }
+
+    open fun get() = method("GET", null)
+
+    open fun head() = method("HEAD", null)
+
+    open fun post(body: RequestBody) = method("POST", body)
+
+    @JvmOverloads
+    open fun delete(body: RequestBody? = Util.EMPTY_REQUEST) = method("DELETE", body)
+
+    open fun put(body: RequestBody) = method("PUT", body)
+
+    open fun patch(body: RequestBody) = method("PATCH", body)
+
+    open fun method(method: String, body: RequestBody?): Builder = apply {
+      require(method.isNotEmpty()) {
+        "method.isEmpty() == true"
+      }
+      if (body == null) {
+        require(!HttpMethod.requiresRequestBody(method)) {
+          "method $method must have a request body."
+        }
+      } else {
+        require(HttpMethod.permitsRequestBody(method)) {
+          "method $method must not have a request body."
+        }
+      }
+      this.method = method
+      this.body = body
+    }
+
+    /** Attaches [tag] to the request using `Object.class` as a key. */
+    open fun tag(tag: Any?): Builder = tag(Any::class.java, tag)
+
+    /**
+     * Attaches [tag] to the request using [type] as a key. Tags can be read from a
+     * request using [Request.tag]. Use null to remove any existing tag assigned for [type].
+     *
+     * Use this API to attach timing, debugging, or other application data to a request so that
+     * you may read it in interceptors, event listeners, or callbacks.
+     */
+    open fun <T> tag(type: Class<in T>, tag: T?) = apply {
+      if (tag == null) {
+        tags.remove(type)
+      } else {
+        if (tags.isEmpty()) {
+          tags = mutableMapOf()
+        }
+        tags[type] = type.cast(tag)!! // Force-unwrap due to lack of contracts on Class#cast()
+      }
+    }
+
+    open fun build(): Request = Request(
+        checkNotNull(url) { "url == null" },
+        this
+    )
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/RequestBody.java b/okhttp/src/main/java/okhttp3/RequestBody.java
deleted file mode 100644
index 3cb29477d3..0000000000
--- a/okhttp/src/main/java/okhttp3/RequestBody.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.File;
-import java.io.IOException;
-import java.nio.charset.Charset;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okio.BufferedSink;
-import okio.ByteString;
-import okio.Okio;
-import okio.Source;
-
-public abstract class RequestBody {
-  /** Returns the Content-Type header for this body. */
-  public abstract @Nullable MediaType contentType();
-
-  /**
-   * Returns the number of bytes that will be written to {@code sink} in a call to {@link #writeTo},
-   * or -1 if that count is unknown.
-   */
-  public long contentLength() throws IOException {
-    return -1;
-  }
-
-  /** Writes the content of this request to {@code sink}. */
-  public abstract void writeTo(BufferedSink sink) throws IOException;
-
-  /**
-   * Returns a new request body that transmits {@code content}. If {@code contentType} is non-null
-   * and lacks a charset, this will use UTF-8.
-   */
-  public static RequestBody create(@Nullable MediaType contentType, String content) {
-    Charset charset = Util.UTF_8;
-    if (contentType != null) {
-      charset = contentType.charset();
-      if (charset == null) {
-        charset = Util.UTF_8;
-        contentType = MediaType.parse(contentType + "; charset=utf-8");
-      }
-    }
-    byte[] bytes = content.getBytes(charset);
-    return create(contentType, bytes);
-  }
-
-  /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(
-      final @Nullable MediaType contentType, final ByteString content) {
-    return new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() throws IOException {
-        return content.size();
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.write(content);
-      }
-    };
-  }
-
-  /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final @Nullable MediaType contentType, final byte[] content) {
-    return create(contentType, content, 0, content.length);
-  }
-
-  /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final @Nullable MediaType contentType, final byte[] content,
-      final int offset, final int byteCount) {
-    if (content == null) throw new NullPointerException("content == null");
-    Util.checkOffsetAndCount(content.length, offset, byteCount);
-    return new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() {
-        return byteCount;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.write(content, offset, byteCount);
-      }
-    };
-  }
-
-  /** Returns a new request body that transmits the content of {@code file}. */
-  public static RequestBody create(final @Nullable MediaType contentType, final File file) {
-    if (file == null) throw new NullPointerException("content == null");
-
-    return new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() {
-        return file.length();
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        Source source = null;
-        try {
-          source = Okio.source(file);
-          sink.writeAll(source);
-        } finally {
-          Util.closeQuietly(source);
-        }
-      }
-    };
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/RequestBody.kt b/okhttp/src/main/java/okhttp3/RequestBody.kt
new file mode 100644
index 0000000000..5bf07ba1e9
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/RequestBody.kt
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.Util
+import okio.BufferedSink
+import okio.ByteString
+import okio.source
+import java.io.File
+import java.io.IOException
+import java.nio.charset.Charset
+import kotlin.text.Charsets.UTF_8
+
+abstract class RequestBody {
+
+  /** Returns the Content-Type header for this body. */
+  abstract fun contentType(): MediaType?
+
+  /**
+   * Returns the number of bytes that will be written to sink in a call to [writeTo],
+   * or -1 if that count is unknown.
+   */
+  @Throws(IOException::class)
+  open fun contentLength(): Long = -1
+
+  /** Writes the content of this request to [sink]. */
+  @Throws(IOException::class)
+  abstract fun writeTo(sink: BufferedSink)
+
+  /**
+   * A duplex request body is special in how it is **transmitted** on the network and
+   * in the **API contract** between OkHttp and the application.
+   *
+   * This method returns false unless it is overridden by a subclass.
+   *
+   * ### Duplex Transmission
+   *
+   * With regular HTTP calls the request always completes sending before the response may begin
+   * receiving. With duplex the request and response may be interleaved! That is, request body bytes
+   * may be sent after response headers or body bytes have been received.
+   *
+   * Though any call may be initiated as a duplex call, only web servers that are specially
+   * designed for this nonstandard interaction will use it. As of 2019-01, the only widely-used
+   * implementation of this pattern is [gRPC][grpc].
+   *
+   * Because the encoding of interleaved data is not well-defined for HTTP/1, duplex request
+   * bodies may only be used with HTTP/2. Calls to HTTP/1 servers will fail before the HTTP request
+   * is transmitted. If you cannot ensure that your client and server both support HTTP/2, do not
+   * use this feature.
+   *
+   * ### Duplex APIs
+   *
+   * With regular request bodies it is not legal to write bytes to the sink passed to
+   * [RequestBody.writeTo] after that method returns. For duplex requests bodies that condition is
+   * lifted. Such writes occur on an application-provided thread and may occur concurrently with
+   * reads of the [ResponseBody]. For duplex request bodies, [writeTo] should return
+   * quickly, possibly by handing off the provided request body to another thread to perform
+   * writing.
+   *
+   * [grpc]: https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md
+   */
+  open val isDuplex: Boolean = false
+
+  /**
+   * Returns true if this body expects at most one call to [writeTo] and can be transmitted
+   * at most once. This is typically used when writing the request body is destructive and it is not
+   * possible to recreate the request body after it has been sent.
+   *
+   * This method returns false unless it is overridden by a subclass.
+   *
+   * By default OkHttp will attempt to retransmit request bodies when the original request fails
+   * due to a stale connection, a client timeout (HTTP 408), a satisfied authorization challenge
+   * (HTTP 401 and 407), or a retryable server failure (HTTP 503 with a `Retry-After: 0`
+   * header).
+   */
+  open val isOneShot: Boolean = false
+
+  companion object {
+
+    /**
+     * Returns a new request body that transmits [content]. If [contentType] is non-null
+     * and lacks a charset, this will use UTF-8.
+     */
+    @JvmStatic
+    fun create(contentType: MediaType?, content: String): RequestBody {
+      var charset: Charset = UTF_8
+      var finalContentType: MediaType? = contentType
+      if (contentType != null) {
+        val resolvedCharset = contentType.charset()
+        if (resolvedCharset == null) {
+          charset = UTF_8
+          finalContentType = MediaType.parse("$contentType; charset=utf-8")
+        } else {
+          charset = resolvedCharset
+        }
+      }
+      val bytes = content.toByteArray(charset)
+      return create(finalContentType, bytes)
+    }
+
+    /** Returns a new request body that transmits [content]. */
+    @JvmStatic
+    fun create(
+      contentType: MediaType?,
+      content: ByteString
+    ): RequestBody = object : RequestBody() {
+      override fun contentType() = contentType
+
+      override fun contentLength() = content.size.toLong()
+
+      override fun writeTo(sink: BufferedSink) {
+        sink.write(content)
+      }
+    }
+
+    /** Returns a new request body that transmits [content]. */
+    @JvmOverloads
+    @JvmStatic
+    fun create(
+      contentType: MediaType?,
+      content: ByteArray,
+      offset: Int = 0,
+      byteCount: Int = content.size
+    ): RequestBody {
+      Util.checkOffsetAndCount(content.size.toLong(), offset.toLong(), byteCount.toLong())
+      return object : RequestBody() {
+        override fun contentType() = contentType
+
+        override fun contentLength() = byteCount.toLong()
+
+        override fun writeTo(sink: BufferedSink) {
+          sink.write(content, offset, byteCount)
+        }
+      }
+    }
+
+    /** Returns a new request body that transmits the content of [file]. */
+    @JvmStatic
+    fun create(contentType: MediaType?, file: File): RequestBody = object : RequestBody() {
+      override fun contentType() = contentType
+
+      override fun contentLength() = file.length()
+
+      override fun writeTo(sink: BufferedSink) {
+        file.source().use { source -> sink.writeAll(source) }
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
deleted file mode 100644
index 1e3ab454a5..0000000000
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ /dev/null
@@ -1,444 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.util.Collections;
-import java.util.List;
-import javax.annotation.Nullable;
-import okhttp3.internal.http.HttpHeaders;
-import okio.Buffer;
-import okio.BufferedSource;
-
-import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
-import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
-import static java.net.HttpURLConnection.HTTP_MULT_CHOICE;
-import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
-import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
-import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
-import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-
-/**
- * An HTTP response. Instances of this class are not immutable: the response body is a one-shot
- * value that may be consumed only once and then closed. All other properties are immutable.
- *
- * <p>This class implements {@link Closeable}. Closing it simply closes its response body. See
- * {@link ResponseBody} for an explanation and examples.
- */
-public final class Response implements Closeable {
-  final Request request;
-  final Protocol protocol;
-  final int code;
-  final String message;
-  final @Nullable Handshake handshake;
-  final Headers headers;
-  final @Nullable ResponseBody body;
-  final @Nullable Response networkResponse;
-  final @Nullable Response cacheResponse;
-  final @Nullable Response priorResponse;
-  final long sentRequestAtMillis;
-  final long receivedResponseAtMillis;
-
-  private volatile CacheControl cacheControl; // Lazily initialized.
-
-  Response(Builder builder) {
-    this.request = builder.request;
-    this.protocol = builder.protocol;
-    this.code = builder.code;
-    this.message = builder.message;
-    this.handshake = builder.handshake;
-    this.headers = builder.headers.build();
-    this.body = builder.body;
-    this.networkResponse = builder.networkResponse;
-    this.cacheResponse = builder.cacheResponse;
-    this.priorResponse = builder.priorResponse;
-    this.sentRequestAtMillis = builder.sentRequestAtMillis;
-    this.receivedResponseAtMillis = builder.receivedResponseAtMillis;
-  }
-
-  /**
-   * The wire-level request that initiated this HTTP response. This is not necessarily the same
-   * request issued by the application:
-   *
-   * <ul>
-   *     <li>It may be transformed by the HTTP client. For example, the client may copy headers like
-   *         {@code Content-Length} from the request body.
-   *     <li>It may be the request generated in response to an HTTP redirect or authentication
-   *         challenge. In this case the request URL may be different than the initial request URL.
-   * </ul>
-   */
-  public Request request() {
-    return request;
-  }
-
-  /**
-   * Returns the HTTP protocol, such as {@link Protocol#HTTP_1_1} or {@link Protocol#HTTP_1_0}.
-   */
-  public Protocol protocol() {
-    return protocol;
-  }
-
-  /** Returns the HTTP status code. */
-  public int code() {
-    return code;
-  }
-
-  /**
-   * Returns true if the code is in [200..300), which means the request was successfully received,
-   * understood, and accepted.
-   */
-  public boolean isSuccessful() {
-    return code >= 200 && code < 300;
-  }
-
-  /** Returns the HTTP status message. */
-  public String message() {
-    return message;
-  }
-
-  /**
-   * Returns the TLS handshake of the connection that carried this response, or null if the response
-   * was received without TLS.
-   */
-  public Handshake handshake() {
-    return handshake;
-  }
-
-  public List<String> headers(String name) {
-    return headers.values(name);
-  }
-
-  public @Nullable String header(String name) {
-    return header(name, null);
-  }
-
-  public @Nullable String header(String name, @Nullable String defaultValue) {
-    String result = headers.get(name);
-    return result != null ? result : defaultValue;
-  }
-
-  public Headers headers() {
-    return headers;
-  }
-
-  /**
-   * Peeks up to {@code byteCount} bytes from the response body and returns them as a new response
-   * body. If fewer than {@code byteCount} bytes are in the response body, the full response body is
-   * returned. If more than {@code byteCount} bytes are in the response body, the returned value
-   * will be truncated to {@code byteCount} bytes.
-   *
-   * <p>It is an error to call this method after the body has been consumed.
-   *
-   * <p><strong>Warning:</strong> this method loads the requested bytes into memory. Most
-   * applications should set a modest limit on {@code byteCount}, such as 1 MiB.
-   */
-  public ResponseBody peekBody(long byteCount) throws IOException {
-    BufferedSource source = body.source();
-    source.request(byteCount);
-    Buffer copy = source.buffer().clone();
-
-    // There may be more than byteCount bytes in source.buffer(). If there is, return a prefix.
-    Buffer result;
-    if (copy.size() > byteCount) {
-      result = new Buffer();
-      result.write(copy, byteCount);
-      copy.clear();
-    } else {
-      result = copy;
-    }
-
-    return ResponseBody.create(body.contentType(), result.size(), result);
-  }
-
-  /**
-   * Returns a non-null value if this response was passed to {@link Callback#onResponse} or returned
-   * from {@link Call#execute()}. Response bodies must be {@linkplain ResponseBody closed} and may
-   * be consumed only once.
-   *
-   * <p>This always returns null on responses returned from {@link #cacheResponse}, {@link
-   * #networkResponse}, and {@link #priorResponse()}.
-   */
-  public @Nullable ResponseBody body() {
-    return body;
-  }
-
-  public Builder newBuilder() {
-    return new Builder(this);
-  }
-
-  /** Returns true if this response redirects to another resource. */
-  public boolean isRedirect() {
-    switch (code) {
-      case HTTP_PERM_REDIRECT:
-      case HTTP_TEMP_REDIRECT:
-      case HTTP_MULT_CHOICE:
-      case HTTP_MOVED_PERM:
-      case HTTP_MOVED_TEMP:
-      case HTTP_SEE_OTHER:
-        return true;
-      default:
-        return false;
-    }
-  }
-
-  /**
-   * Returns the raw response received from the network. Will be null if this response didn't use
-   * the network, such as when the response is fully cached. The body of the returned response
-   * should not be read.
-   */
-  public @Nullable Response networkResponse() {
-    return networkResponse;
-  }
-
-  /**
-   * Returns the raw response received from the cache. Will be null if this response didn't use the
-   * cache. For conditional get requests the cache response and network response may both be
-   * non-null. The body of the returned response should not be read.
-   */
-  public @Nullable Response cacheResponse() {
-    return cacheResponse;
-  }
-
-  /**
-   * Returns the response for the HTTP redirect or authorization challenge that triggered this
-   * response, or null if this response wasn't triggered by an automatic retry. The body of the
-   * returned response should not be read because it has already been consumed by the redirecting
-   * client.
-   */
-  public @Nullable Response priorResponse() {
-    return priorResponse;
-  }
-
-  /**
-   * Returns the authorization challenges appropriate for this response's code. If the response code
-   * is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the response code is
-   * 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges. Otherwise this
-   * returns an empty list of challenges.
-   */
-  public List<Challenge> challenges() {
-    String responseField;
-    if (code == HTTP_UNAUTHORIZED) {
-      responseField = "WWW-Authenticate";
-    } else if (code == HTTP_PROXY_AUTH) {
-      responseField = "Proxy-Authenticate";
-    } else {
-      return Collections.emptyList();
-    }
-    return HttpHeaders.parseChallenges(headers(), responseField);
-  }
-
-  /**
-   * Returns the cache control directives for this response. This is never null, even if this
-   * response contains no {@code Cache-Control} header.
-   */
-  public CacheControl cacheControl() {
-    CacheControl result = cacheControl;
-    return result != null ? result : (cacheControl = CacheControl.parse(headers));
-  }
-
-  /**
-   * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately before OkHttp
-   * transmitted the initiating request over the network. If this response is being served from the
-   * cache then this is the timestamp of the original request.
-   */
-  public long sentRequestAtMillis() {
-    return sentRequestAtMillis;
-  }
-
-  /**
-   * Returns a {@linkplain System#currentTimeMillis() timestamp} taken immediately after OkHttp
-   * received this response's headers from the network. If this response is being served from the
-   * cache then this is the timestamp of the original response.
-   */
-  public long receivedResponseAtMillis() {
-    return receivedResponseAtMillis;
-  }
-
-  /**
-   * Closes the response body. Equivalent to {@code body().close()}.
-   *
-   * <p>It is an error to close a response that is not eligible for a body. This includes the
-   * responses returned from {@link #cacheResponse}, {@link #networkResponse}, and {@link
-   * #priorResponse()}.
-   */
-  @Override public void close() {
-    if (body == null) {
-      throw new IllegalStateException("response is not eligible for a body and must not be closed");
-    }
-    body.close();
-  }
-
-  @Override public String toString() {
-    return "Response{protocol="
-        + protocol
-        + ", code="
-        + code
-        + ", message="
-        + message
-        + ", url="
-        + request.url()
-        + '}';
-  }
-
-  public static class Builder {
-    Request request;
-    Protocol protocol;
-    int code = -1;
-    String message;
-    @Nullable Handshake handshake;
-    Headers.Builder headers;
-    ResponseBody body;
-    Response networkResponse;
-    Response cacheResponse;
-    Response priorResponse;
-    long sentRequestAtMillis;
-    long receivedResponseAtMillis;
-
-    public Builder() {
-      headers = new Headers.Builder();
-    }
-
-    Builder(Response response) {
-      this.request = response.request;
-      this.protocol = response.protocol;
-      this.code = response.code;
-      this.message = response.message;
-      this.handshake = response.handshake;
-      this.headers = response.headers.newBuilder();
-      this.body = response.body;
-      this.networkResponse = response.networkResponse;
-      this.cacheResponse = response.cacheResponse;
-      this.priorResponse = response.priorResponse;
-      this.sentRequestAtMillis = response.sentRequestAtMillis;
-      this.receivedResponseAtMillis = response.receivedResponseAtMillis;
-    }
-
-    public Builder request(Request request) {
-      this.request = request;
-      return this;
-    }
-
-    public Builder protocol(Protocol protocol) {
-      this.protocol = protocol;
-      return this;
-    }
-
-    public Builder code(int code) {
-      this.code = code;
-      return this;
-    }
-
-    public Builder message(String message) {
-      this.message = message;
-      return this;
-    }
-
-    public Builder handshake(@Nullable Handshake handshake) {
-      this.handshake = handshake;
-      return this;
-    }
-
-    /**
-     * Sets the header named {@code name} to {@code value}. If this request already has any headers
-     * with that name, they are all replaced.
-     */
-    public Builder header(String name, String value) {
-      headers.set(name, value);
-      return this;
-    }
-
-    /**
-     * Adds a header with {@code name} and {@code value}. Prefer this method for multiply-valued
-     * headers like "Set-Cookie".
-     */
-    public Builder addHeader(String name, String value) {
-      headers.add(name, value);
-      return this;
-    }
-
-    public Builder removeHeader(String name) {
-      headers.removeAll(name);
-      return this;
-    }
-
-    /** Removes all headers on this builder and adds {@code headers}. */
-    public Builder headers(Headers headers) {
-      this.headers = headers.newBuilder();
-      return this;
-    }
-
-    public Builder body(@Nullable ResponseBody body) {
-      this.body = body;
-      return this;
-    }
-
-    public Builder networkResponse(@Nullable Response networkResponse) {
-      if (networkResponse != null) checkSupportResponse("networkResponse", networkResponse);
-      this.networkResponse = networkResponse;
-      return this;
-    }
-
-    public Builder cacheResponse(@Nullable Response cacheResponse) {
-      if (cacheResponse != null) checkSupportResponse("cacheResponse", cacheResponse);
-      this.cacheResponse = cacheResponse;
-      return this;
-    }
-
-    private void checkSupportResponse(String name, Response response) {
-      if (response.body != null) {
-        throw new IllegalArgumentException(name + ".body != null");
-      } else if (response.networkResponse != null) {
-        throw new IllegalArgumentException(name + ".networkResponse != null");
-      } else if (response.cacheResponse != null) {
-        throw new IllegalArgumentException(name + ".cacheResponse != null");
-      } else if (response.priorResponse != null) {
-        throw new IllegalArgumentException(name + ".priorResponse != null");
-      }
-    }
-
-    public Builder priorResponse(@Nullable Response priorResponse) {
-      if (priorResponse != null) checkPriorResponse(priorResponse);
-      this.priorResponse = priorResponse;
-      return this;
-    }
-
-    private void checkPriorResponse(Response response) {
-      if (response.body != null) {
-        throw new IllegalArgumentException("priorResponse.body != null");
-      }
-    }
-
-    public Builder sentRequestAtMillis(long sentRequestAtMillis) {
-      this.sentRequestAtMillis = sentRequestAtMillis;
-      return this;
-    }
-
-    public Builder receivedResponseAtMillis(long receivedResponseAtMillis) {
-      this.receivedResponseAtMillis = receivedResponseAtMillis;
-      return this;
-    }
-
-    public Response build() {
-      if (request == null) throw new IllegalStateException("request == null");
-      if (protocol == null) throw new IllegalStateException("protocol == null");
-      if (code < 0) throw new IllegalStateException("code < 0: " + code);
-      if (message == null) throw new IllegalStateException("message == null");
-      return new Response(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Response.kt b/okhttp/src/main/java/okhttp3/Response.kt
new file mode 100644
index 0000000000..4844a87072
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Response.kt
@@ -0,0 +1,361 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.io.Closeable
+import java.io.IOException
+import okhttp3.internal.connection.Exchange
+import okhttp3.internal.http.HttpHeaders
+import okio.Buffer
+
+import java.net.HttpURLConnection.HTTP_MOVED_PERM
+import java.net.HttpURLConnection.HTTP_MOVED_TEMP
+import java.net.HttpURLConnection.HTTP_MULT_CHOICE
+import java.net.HttpURLConnection.HTTP_PROXY_AUTH
+import java.net.HttpURLConnection.HTTP_SEE_OTHER
+import java.net.HttpURLConnection.HTTP_UNAUTHORIZED
+import okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT
+import okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT
+
+/**
+ * An HTTP response. Instances of this class are not immutable: the response body is a one-shot
+ * value that may be consumed only once and then closed. All other properties are immutable.
+ *
+ * This class implements [Closeable]. Closing it simply closes its response body. See
+ * [ResponseBody] for an explanation and examples.
+ */
+class Response internal constructor(
+  internal val request: Request,
+  internal val protocol: Protocol,
+  internal val message: String,
+  builder: Builder
+) : Closeable {
+  internal val code: Int = builder.code
+  internal val handshake: Handshake? = builder.handshake
+  internal val headers: Headers = builder.headers.build()
+  internal val body: ResponseBody? = builder.body
+  internal val networkResponse: Response? = builder.networkResponse
+  internal val cacheResponse: Response? = builder.cacheResponse
+  internal val priorResponse: Response? = builder.priorResponse
+  internal val sentRequestAtMillis: Long = builder.sentRequestAtMillis
+  internal val receivedResponseAtMillis: Long = builder.receivedResponseAtMillis
+  internal val exchange: Exchange? = builder.exchange
+
+  @Volatile
+  private var cacheControl: CacheControl? = null // Lazily initialized.
+
+  /**
+   * The wire-level request that initiated this HTTP response. This is not necessarily the same
+   * request issued by the application:
+   *
+   * * It may be transformed by the HTTP client. For example, the client may copy headers like
+   *   `Content-Length` from the request body.
+   * * It may be the request generated in response to an HTTP redirect or authentication
+   *   challenge. In this case the request URL may be different than the initial request URL.
+   */
+  fun request(): Request = request
+
+  /** Returns the HTTP protocol, such as [Protocol.HTTP_1_1] or [Protocol.HTTP_1_0]. */
+  fun protocol(): Protocol = protocol
+
+  /** Returns the HTTP status code. */
+  fun code(): Int = code
+
+  /**
+   * Returns true if the code is in [200..300), which means the request was successfully received,
+   * understood, and accepted.
+   */
+  val isSuccessful: Boolean
+    get() = code in 200..299
+
+  /** Returns the HTTP status message. */
+  fun message(): String = message
+
+  /**
+   * Returns the TLS handshake of the connection that carried this response, or null if the
+   * response was received without TLS.
+   */
+  fun handshake(): Handshake? = handshake
+
+  fun headers(name: String): List<String>  = headers.values(name)
+
+  @JvmOverloads
+  fun header(name: String, defaultValue: String? = null): String? = headers[name] ?: defaultValue
+
+  fun headers(): Headers = headers
+
+  /**
+   * Returns the trailers after the HTTP response, which may be empty. It is an error to call this
+   * before the entire HTTP response body has been consumed.
+   */
+  @Throws(IOException::class)
+  fun trailers(): Headers = checkNotNull(exchange) { "trailers not available" }.trailers()
+
+  /**
+   * Peeks up to [byteCount] bytes from the response body and returns them as a new response
+   * body. If fewer than [byteCount] bytes are in the response body, the full response body is
+   * returned. If more than [byteCount] bytes are in the response body, the returned value
+   * will be truncated to [byteCount] bytes.
+   *
+   * It is an error to call this method after the body has been consumed.
+   *
+   * **Warning:** this method loads the requested bytes into memory. Most applications should set
+   * a modest limit on `byteCount`, such as 1 MiB.
+   */
+  @Throws(IOException::class)
+  fun peekBody(byteCount: Long): ResponseBody {
+    val peeked = body!!.source().peek()
+    val buffer = Buffer()
+    peeked.request(byteCount)
+    buffer.write(peeked, Math.min(byteCount, peeked.buffer.size))
+    return ResponseBody.create(body.contentType(), buffer.size, buffer)
+  }
+
+  /**
+   * Returns a non-null value if this response was passed to [Callback.onResponse] or returned
+   * from [Call.execute]. Response bodies must be [closed][ResponseBody] and may
+   * be consumed only once.
+   *
+   * This always returns null on responses returned from [cacheResponse], [networkResponse],
+   * and [priorResponse].
+   */
+  fun body(): ResponseBody? = body
+
+  fun newBuilder(): Builder = Builder(this)
+
+  /** Returns true if this response redirects to another resource. */
+  val isRedirect: Boolean
+    get() = when (code) {
+      HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT, HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -> true
+      else -> false
+    }
+
+  /**
+   * Returns the raw response received from the network. Will be null if this response didn't use
+   * the network, such as when the response is fully cached. The body of the returned response
+   * should not be read.
+   */
+  fun networkResponse(): Response? = networkResponse
+
+  /**
+   * Returns the raw response received from the cache. Will be null if this response didn't use
+   * the cache. For conditional get requests the cache response and network response may both be
+   * non-null. The body of the returned response should not be read.
+   */
+  fun cacheResponse(): Response? = cacheResponse
+
+  /**
+   * Returns the response for the HTTP redirect or authorization challenge that triggered this
+   * response, or null if this response wasn't triggered by an automatic retry. The body of the
+   * returned response should not be read because it has already been consumed by the redirecting
+   * client.
+   */
+  fun priorResponse(): Response? = priorResponse
+
+  /**
+   * Returns the RFC 7235 authorization challenges appropriate for this response's code. If the
+   * response code is 401 unauthorized, this returns the "WWW-Authenticate" challenges. If the
+   * response code is 407 proxy unauthorized, this returns the "Proxy-Authenticate" challenges.
+   * Otherwise this returns an empty list of challenges.
+   *
+   * If a challenge uses the `token68` variant instead of auth params, there is exactly one
+   * auth param in the challenge at key null. Invalid headers and challenges are ignored.
+   * No semantic validation is done, for example that `Basic` auth must have a `realm`
+   * auth param, this is up to the caller that interprets these challenges.
+   */
+  fun challenges(): List<Challenge> {
+    return HttpHeaders.parseChallenges(
+        headers(),
+        when (code) {
+          HTTP_UNAUTHORIZED -> "WWW-Authenticate"
+          HTTP_PROXY_AUTH -> "Proxy-Authenticate"
+          else -> return emptyList()
+        }
+    )
+  }
+
+  /**
+   * Returns the cache control directives for this response. This is never null, even if this
+   * response contains no `Cache-Control` header.
+   */
+  fun cacheControl(): CacheControl = cacheControl ?: CacheControl.parse(headers).also {
+    cacheControl = it
+  }
+
+  /**
+   * Returns a [timestamp][System.currentTimeMillis] taken immediately before OkHttp
+   * transmitted the initiating request over the network. If this response is being served from the
+   * cache then this is the timestamp of the original request.
+   */
+  fun sentRequestAtMillis(): Long = sentRequestAtMillis
+
+  /**
+   * Returns a [timestamp][System.currentTimeMillis] taken immediately after OkHttp
+   * received this response's headers from the network. If this response is being served from the
+   * cache then this is the timestamp of the original response.
+   */
+  fun receivedResponseAtMillis(): Long = receivedResponseAtMillis
+
+  /**
+   * Closes the response body. Equivalent to `body().close()`.
+   *
+   * It is an error to close a response that is not eligible for a body. This includes the
+   * responses returned from [cacheResponse], [networkResponse], and [priorResponse].
+   */
+  override fun close() {
+    checkNotNull(body) { "response is not eligible for a body and must not be closed" }.close()
+  }
+
+  override fun toString() =
+      "Response{protocol=$protocol, code=$code, message=$message, url=${request.url()}}"
+
+  open class Builder {
+    internal var request: Request? = null
+    internal var protocol: Protocol? = null
+    internal var code = -1
+    internal var message: String? = null
+    internal var handshake: Handshake? = null
+    internal var headers: Headers.Builder
+    internal var body: ResponseBody? = null
+    internal var networkResponse: Response? = null
+    internal var cacheResponse: Response? = null
+    internal var priorResponse: Response? = null
+    internal var sentRequestAtMillis: Long = 0
+    internal var receivedResponseAtMillis: Long = 0
+    internal var exchange: Exchange? = null
+
+    constructor() {
+      headers = Headers.Builder()
+    }
+
+    internal constructor(response: Response) {
+      this.request = response.request
+      this.protocol = response.protocol
+      this.code = response.code
+      this.message = response.message
+      this.handshake = response.handshake
+      this.headers = response.headers.newBuilder()
+      this.body = response.body
+      this.networkResponse = response.networkResponse
+      this.cacheResponse = response.cacheResponse
+      this.priorResponse = response.priorResponse
+      this.sentRequestAtMillis = response.sentRequestAtMillis
+      this.receivedResponseAtMillis = response.receivedResponseAtMillis
+      this.exchange = response.exchange
+    }
+
+    open fun request(request: Request) = apply {
+      this.request = request
+    }
+
+    open fun protocol(protocol: Protocol) = apply {
+      this.protocol = protocol
+    }
+
+    open fun code(code: Int) = apply {
+      this.code = code
+    }
+
+    open fun message(message: String) = apply {
+      this.message = message
+    }
+
+    open fun handshake(handshake: Handshake?) = apply {
+      this.handshake = handshake
+    }
+
+    /**
+     * Sets the header named [name] to [value]. If this request already has any headers
+     * with that name, they are all replaced.
+     */
+    open fun header(name: String, value: String) = apply {
+      headers[name] = value
+    }
+
+    /**
+     * Adds a header with [name] to [value]. Prefer this method for multiply-valued
+     * headers like "Set-Cookie".
+     */
+    open fun addHeader(name: String, value: String) = apply {
+      headers.add(name, value)
+    }
+
+    /** Removes all headers named [name] on this builder. */
+    open fun removeHeader(name: String) = apply {
+      headers.removeAll(name)
+    }
+
+    /** Removes all headers on this builder and adds [headers]. */
+    open fun headers(headers: Headers) = apply {
+      this.headers = headers.newBuilder()
+    }
+
+    open fun body(body: ResponseBody?) = apply {
+      this.body = body
+    }
+
+    open fun networkResponse(networkResponse: Response?) = apply {
+      checkSupportResponse("networkResponse", networkResponse)
+      this.networkResponse = networkResponse
+    }
+
+    open fun cacheResponse(cacheResponse: Response?) = apply {
+      checkSupportResponse("cacheResponse", cacheResponse)
+      this.cacheResponse = cacheResponse
+    }
+
+    private fun checkSupportResponse(name: String, response: Response?) {
+      response?.apply {
+        require(body == null) { "$name.body != null" }
+        require(networkResponse == null) { "$name.networkResponse != null" }
+        require(cacheResponse == null) { "$name.cacheResponse != null" }
+        require(priorResponse == null) { "$name.priorResponse != null" }
+      }
+    }
+
+    open fun priorResponse(priorResponse: Response?) = apply {
+      checkPriorResponse(priorResponse)
+      this.priorResponse = priorResponse
+    }
+
+    private fun checkPriorResponse(response: Response?) {
+      response?.apply {
+        require(body == null) { "priorResponse.body != null" }
+      }
+    }
+
+    open fun sentRequestAtMillis(sentRequestAtMillis: Long) = apply {
+      this.sentRequestAtMillis = sentRequestAtMillis
+    }
+
+    open fun receivedResponseAtMillis(receivedResponseAtMillis: Long) = apply {
+      this.receivedResponseAtMillis = receivedResponseAtMillis
+    }
+
+    internal fun initExchange(deferredTrailers: Exchange) {
+      this.exchange = deferredTrailers
+    }
+
+    open fun build(): Response {
+      check(code > 0) { "code < 0: $code" }
+      return Response(
+          checkNotNull(request) { "request == null" },
+          checkNotNull(protocol) { "protocol == null" },
+          checkNotNull(message) { "message == null" },
+          this)
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
deleted file mode 100644
index 2a78d7fbd8..0000000000
--- a/okhttp/src/main/java/okhttp3/ResponseBody.java
+++ /dev/null
@@ -1,264 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.nio.charset.Charset;
-import javax.annotation.Nullable;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSource;
-
-import static okhttp3.internal.Util.UTF_8;
-
-/**
- * A one-shot stream from the origin server to the client application with the raw bytes of the
- * response body. Each response body is supported by an active connection to the webserver. This
- * imposes both obligations and limits on the client application.
- *
- * <h3>The response body must be closed.</h3>
- *
- * Each response body is backed by a limited resource like a socket (live network responses) or
- * an open file (for cached responses). Failing to close the response body will leak resources and
- * may ultimately cause the application to slow down or crash.
- *
- * <p>Both this class and {@link Response} implement {@link Closeable}. Closing a response simply
- * closes its response body. If you invoke {@link Call#execute()} or implement {@link
- * Callback#onResponse} you must close this body by calling any of the following methods:
- *
- * <ul>
- *   <li>Response.close()</li>
- *   <li>Response.body().close()</li>
- *   <li>Response.body().source().close()</li>
- *   <li>Response.body().charStream().close()</li>
- *   <li>Response.body().byteStream().close()</li>
- *   <li>Response.body().bytes()</li>
- *   <li>Response.body().string()</li>
- * </ul>
- *
- * <p>There is no benefit to invoking multiple {@code close()} methods for the same response body.
- *
- * <p>For synchronous calls, the easiest way to make sure a response body is closed is with a {@code
- * try} block. With this structure the compiler inserts an implicit {@code finally} clause that
- * calls {@code close()} for you.
- *
- * <pre>   {@code
- *
- *   Call call = client.newCall(request);
- *   try (Response response = call.execute()) {
- *     ... // Use the response.
- *   }
- * }</pre>
- *
- * You can use a similar block for asynchronous calls: <pre>   {@code
- *
- *   Call call = client.newCall(request);
- *   call.enqueue(new Callback() {
- *     public void onResponse(Call call, Response response) throws IOException {
- *       try (ResponseBody responseBody = response.body()) {
- *         ... // Use the response.
- *       }
- *     }
- *
- *     public void onFailure(Call call, IOException e) {
- *       ... // Handle the failure.
- *     }
- *   });
- * }</pre>
- *
- * These examples will not work if you're consuming the response body on another thread. In such
- * cases the consuming thread must call {@link #close} when it has finished reading the response
- * body.
- *
- * <h3>The response body can be consumed only once.</h3>
- *
- * <p>This class may be used to stream very large responses. For example, it is possible to use this
- * class to read a response that is larger than the entire memory allocated to the current process.
- * It can even stream a response larger than the total storage on the current device, which is a
- * common requirement for video streaming applications.
- *
- * <p>Because this class does not buffer the full response in memory, the application may not
- * re-read the bytes of the response. Use this one shot to read the entire response into memory with
- * {@link #bytes()} or {@link #string()}. Or stream the response with either {@link #source()},
- * {@link #byteStream()}, or {@link #charStream()}.
- */
-public abstract class ResponseBody implements Closeable {
-  /** Multiple calls to {@link #charStream()} must return the same instance. */
-  private Reader reader;
-
-  public abstract @Nullable MediaType contentType();
-
-  /**
-   * Returns the number of bytes in that will returned by {@link #bytes}, or {@link #byteStream}, or
-   * -1 if unknown.
-   */
-  public abstract long contentLength();
-
-  public final InputStream byteStream() {
-    return source().inputStream();
-  }
-
-  public abstract BufferedSource source();
-
-  /**
-   * Returns the response as a byte array.
-   *
-   * <p>This method loads entire response body into memory. If the response body is very large this
-   * may trigger an {@link OutOfMemoryError}. Prefer to stream the response body if this is a
-   * possibility for your response.
-   */
-  public final byte[] bytes() throws IOException {
-    long contentLength = contentLength();
-    if (contentLength > Integer.MAX_VALUE) {
-      throw new IOException("Cannot buffer entire body for content length: " + contentLength);
-    }
-
-    BufferedSource source = source();
-    byte[] bytes;
-    try {
-      bytes = source.readByteArray();
-    } finally {
-      Util.closeQuietly(source);
-    }
-    if (contentLength != -1 && contentLength != bytes.length) {
-      throw new IOException("Content-Length ("
-          + contentLength
-          + ") and stream length ("
-          + bytes.length
-          + ") disagree");
-    }
-    return bytes;
-  }
-
-  /**
-   * Returns the response as a character stream decoded with the charset of the Content-Type header.
-   * If that header is either absent or lacks a charset, this will attempt to decode the response
-   * body in accordance to <a href="https://en.wikipedia.org/wiki/Byte_order_mark">its BOM</a> or
-   * UTF-8.
-   */
-  public final Reader charStream() {
-    Reader r = reader;
-    return r != null ? r : (reader = new BomAwareReader(source(), charset()));
-  }
-
-  /**
-   * Returns the response as a string decoded with the charset of the Content-Type header. If that
-   * header is either absent or lacks a charset, this will attempt to decode the response body in
-   * accordance to <a href="https://en.wikipedia.org/wiki/Byte_order_mark">its BOM</a> or UTF-8.
-   * Closes {@link ResponseBody} automatically.
-   *
-   * <p>This method loads entire response body into memory. If the response body is very large this
-   * may trigger an {@link OutOfMemoryError}. Prefer to stream the response body if this is a
-   * possibility for your response.
-   */
-  public final String string() throws IOException {
-    BufferedSource source = source();
-    try {
-      Charset charset = Util.bomAwareCharset(source, charset());
-      return source.readString(charset);
-    } finally {
-      Util.closeQuietly(source);
-    }
-  }
-
-  private Charset charset() {
-    MediaType contentType = contentType();
-    return contentType != null ? contentType.charset(UTF_8) : UTF_8;
-  }
-
-  @Override public void close() {
-    Util.closeQuietly(source());
-  }
-
-  /**
-   * Returns a new response body that transmits {@code content}. If {@code contentType} is non-null
-   * and lacks a charset, this will use UTF-8.
-   */
-  public static ResponseBody create(@Nullable MediaType contentType, String content) {
-    Charset charset = UTF_8;
-    if (contentType != null) {
-      charset = contentType.charset();
-      if (charset == null) {
-        charset = UTF_8;
-        contentType = MediaType.parse(contentType + "; charset=utf-8");
-      }
-    }
-    Buffer buffer = new Buffer().writeString(content, charset);
-    return create(contentType, buffer.size(), buffer);
-  }
-
-  /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(final @Nullable MediaType contentType, byte[] content) {
-    Buffer buffer = new Buffer().write(content);
-    return create(contentType, content.length, buffer);
-  }
-
-  /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(final @Nullable MediaType contentType,
-      final long contentLength, final BufferedSource content) {
-    if (content == null) throw new NullPointerException("source == null");
-    return new ResponseBody() {
-      @Override public @Nullable MediaType contentType() {
-        return contentType;
-      }
-
-      @Override public long contentLength() {
-        return contentLength;
-      }
-
-      @Override public BufferedSource source() {
-        return content;
-      }
-    };
-  }
-
-  static final class BomAwareReader extends Reader {
-    private final BufferedSource source;
-    private final Charset charset;
-
-    private boolean closed;
-    private Reader delegate;
-
-    BomAwareReader(BufferedSource source, Charset charset) {
-      this.source = source;
-      this.charset = charset;
-    }
-
-    @Override public int read(char[] cbuf, int off, int len) throws IOException {
-      if (closed) throw new IOException("Stream closed");
-
-      Reader delegate = this.delegate;
-      if (delegate == null) {
-        Charset charset = Util.bomAwareCharset(source, this.charset);
-        delegate = this.delegate = new InputStreamReader(source.inputStream(), charset);
-      }
-      return delegate.read(cbuf, off, len);
-    }
-
-    @Override public void close() throws IOException {
-      closed = true;
-      if (delegate != null) {
-        delegate.close();
-      } else {
-        source.close();
-      }
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.kt b/okhttp/src/main/java/okhttp3/ResponseBody.kt
new file mode 100644
index 0000000000..ce63dfb1a0
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.kt
@@ -0,0 +1,255 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.Util
+import okio.Buffer
+import okio.BufferedSource
+import okio.ByteString
+import java.io.Closeable
+import java.io.IOException
+import java.io.InputStream
+import java.io.InputStreamReader
+import java.io.Reader
+import java.nio.charset.Charset
+import kotlin.text.Charsets.UTF_8
+
+/**
+ * A one-shot stream from the origin server to the client application with the raw bytes of the
+ * response body. Each response body is supported by an active connection to the webserver. This
+ * imposes both obligations and limits on the client application.
+ *
+ * ### The response body must be closed.
+ *
+ * Each response body is backed by a limited resource like a socket (live network responses) or
+ * an open file (for cached responses). Failing to close the response body will leak resources and
+ * may ultimately cause the application to slow down or crash.
+ *
+ * Both this class and [Response] implement [Closeable]. Closing a response simply
+ * closes its response body. If you invoke [Call.execute] or implement [Callback.onResponse] you
+ * must close this body by calling any of the following methods:
+ *
+ * * `Response.close()`
+ * * `Response.body().close()`
+ * * `Response.body().source().close()`
+ * * `Response.body().charStream().close()`
+ * * `Response.body().byteStream().close()`
+ * * `Response.body().bytes()`
+ * * `Response.body().string()`
+ *
+ * There is no benefit to invoking multiple `close()` methods for the same response body.
+ *
+ * For synchronous calls, the easiest way to make sure a response body is closed is with a `try`
+ * block. With this structure the compiler inserts an implicit `finally` clause that calls
+ * [close()][Response.close] for you.
+ *
+ * ```
+ * Call call = client.newCall(request);
+ * try (Response response = call.execute()) {
+ * ... // Use the response.
+ * }
+ * ```
+ *
+ * You can use a similar block for asynchronous calls:
+ *
+ * ```
+ * Call call = client.newCall(request);
+ * call.enqueue(new Callback() {
+ *   public void onResponse(Call call, Response response) throws IOException {
+ *     try (ResponseBody responseBody = response.body()) {
+ *     ... // Use the response.
+ *     }
+ *   }
+ *
+ *   public void onFailure(Call call, IOException e) {
+ *   ... // Handle the failure.
+ *   }
+ * });
+ * ```
+ *
+ * These examples will not work if you're consuming the response body on another thread. In such
+ * cases the consuming thread must call [close] when it has finished reading the response
+ * body.
+ *
+ * ### The response body can be consumed only once.
+ *
+ * This class may be used to stream very large responses. For example, it is possible to use this
+ * class to read a response that is larger than the entire memory allocated to the current process.
+ * It can even stream a response larger than the total storage on the current device, which is a
+ * common requirement for video streaming applications.
+ *
+ * Because this class does not buffer the full response in memory, the application may not
+ * re-read the bytes of the response. Use this one shot to read the entire response into memory with
+ * [bytes] or [string]. Or stream the response with either [source], [byteStream], or [charStream].
+ */
+abstract class ResponseBody : Closeable {
+  /** Multiple calls to [charStream] must return the same instance. */
+  private var reader: Reader? = null
+
+  abstract fun contentType(): MediaType?
+
+  /**
+   * Returns the number of bytes in that will returned by [bytes], or [byteStream], or -1 if
+   * unknown.
+   */
+  abstract fun contentLength(): Long
+
+  fun byteStream(): InputStream = source().inputStream()
+
+  abstract fun source(): BufferedSource
+
+  /**
+   * Returns the response as a byte array.
+   *
+   * This method loads entire response body into memory. If the response body is very large this
+   * may trigger an [OutOfMemoryError]. Prefer to stream the response body if this is a
+   * possibility for your response.
+   */
+  @Throws(IOException::class)
+  fun bytes(): ByteArray {
+    val contentLength = contentLength()
+    if (contentLength > Integer.MAX_VALUE) {
+      throw IOException("Cannot buffer entire body for content length: $contentLength")
+    }
+
+    val bytes: ByteArray = source().use(BufferedSource::readByteArray)
+    if (contentLength != -1L && contentLength != bytes.size.toLong()) {
+      throw IOException(
+          "Content-Length ($contentLength) and stream length (${bytes.size}) disagree")
+    }
+    return bytes
+  }
+
+  /**
+   * Returns the response as a character stream.
+   *
+   * If the response starts with a
+   * [Byte Order Mark (BOM)](https://en.wikipedia.org/wiki/Byte_order_mark), it is consumed and
+   * used to determine the charset of the response bytes.
+   *
+   * Otherwise if the response has a `Content-Type` header that specifies a charset, that is used
+   * to determine the charset of the response bytes.
+   *
+   * Otherwise the response bytes are decoded as UTF-8.
+   */
+  fun charStream(): Reader = reader ?: BomAwareReader(source(), charset()).also {
+    reader = it
+  }
+
+  /**
+   * Returns the response as a string.
+   *
+   * If the response starts with a
+   * [Byte Order Mark (BOM)](https://en.wikipedia.org/wiki/Byte_order_mark), it is consumed and
+   * used to determine the charset of the response bytes.
+   *
+   * Otherwise if the response has a `Content-Type` header that specifies a charset, that is used
+   * to determine the charset of the response bytes.
+   *
+   * Otherwise the response bytes are decoded as UTF-8.
+   *
+   * This method loads entire response body into memory. If the response body is very large this
+   * may trigger an [OutOfMemoryError]. Prefer to stream the response body if this is a
+   * possibility for your response.
+   */
+  @Throws(IOException::class)
+  fun string(): String = source().use { source ->
+    source.readString(charset = Util.bomAwareCharset(source, charset()))
+  }
+
+  private fun charset() = contentType()?.charset(UTF_8) ?: UTF_8
+
+  override fun close() = Util.closeQuietly(source())
+
+  internal class BomAwareReader(
+    private val source: BufferedSource,
+    private val charset: Charset
+  ) : Reader() {
+
+    private var closed: Boolean = false
+    private var delegate: Reader? = null
+
+    @Throws(IOException::class)
+    override fun read(cbuf: CharArray, off: Int, len: Int): Int {
+      if (closed) throw IOException("Stream closed")
+
+      val finalDelegate = delegate ?: InputStreamReader(
+          source.inputStream(),
+          Util.bomAwareCharset(source, charset)).also {
+        delegate = it
+      }
+      return finalDelegate.read(cbuf, off, len)
+    }
+
+    @Throws(IOException::class)
+    override fun close() {
+      closed = true
+      delegate?.close() ?: run { source.close() }
+    }
+  }
+
+  companion object {
+
+    /**
+     * Returns a new response body that transmits [content]. If `contentType` is non-null
+     * and lacks a charset, this will use UTF-8.
+     */
+    @JvmStatic
+    fun create(contentType: MediaType?, content: String): ResponseBody {
+      var charset: Charset = UTF_8
+      var finalContentType: MediaType? = contentType
+      if (contentType != null) {
+        val resolvedCharset = contentType.charset()
+        if (resolvedCharset == null) {
+          charset = UTF_8
+          finalContentType = MediaType.parse("$contentType; charset=utf-8")
+        } else {
+          charset = resolvedCharset
+        }
+      }
+      val buffer = Buffer().writeString(content, charset)
+      return create(finalContentType, buffer.size, buffer)
+    }
+
+    /** Returns a new response body that transmits [content]. */
+    @JvmStatic
+    fun create(contentType: MediaType?, content: ByteArray): ResponseBody {
+      val buffer = Buffer().write(content)
+      return create(contentType, content.size.toLong(), buffer)
+    }
+
+    /** Returns a new response body that transmits [content]. */
+    @JvmStatic
+    fun create(contentType: MediaType?, content: ByteString): ResponseBody {
+      val buffer = Buffer().write(content)
+      return create(contentType, content.size.toLong(), buffer)
+    }
+
+    /** Returns a new response body that transmits [content]. */
+    @JvmStatic
+    fun create(
+      contentType: MediaType?,
+      contentLength: Long,
+      content: BufferedSource
+    ): ResponseBody = object : ResponseBody() {
+      override fun contentType() = contentType
+
+      override fun contentLength() = contentLength
+
+      override fun source() = content
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/Route.java b/okhttp/src/main/java/okhttp3/Route.java
deleted file mode 100644
index 14158673ca..0000000000
--- a/okhttp/src/main/java/okhttp3/Route.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import javax.annotation.Nullable;
-
-/**
- * The concrete route used by a connection to reach an abstract origin server. When creating a
- * connection the client has many options:
- *
- * <ul>
- *     <li><strong>HTTP proxy:</strong> a proxy server may be explicitly configured for the client.
- *         Otherwise the {@linkplain java.net.ProxySelector proxy selector} is used. It may return
- *         multiple proxies to attempt.
- *     <li><strong>IP address:</strong> whether connecting directly to an origin server or a proxy,
- *         opening a socket requires an IP address. The DNS server may return multiple IP addresses
- *         to attempt.
- * </ul>
- *
- * <p>Each route is a specific selection of these options.
- */
-public final class Route {
-  final Address address;
-  final Proxy proxy;
-  final InetSocketAddress inetSocketAddress;
-
-  public Route(Address address, Proxy proxy, InetSocketAddress inetSocketAddress) {
-    if (address == null) {
-      throw new NullPointerException("address == null");
-    }
-    if (proxy == null) {
-      throw new NullPointerException("proxy == null");
-    }
-    if (inetSocketAddress == null) {
-      throw new NullPointerException("inetSocketAddress == null");
-    }
-    this.address = address;
-    this.proxy = proxy;
-    this.inetSocketAddress = inetSocketAddress;
-  }
-
-  public Address address() {
-    return address;
-  }
-
-  /**
-   * Returns the {@link Proxy} of this route.
-   *
-   * <strong>Warning:</strong> This may disagree with {@link Address#proxy} when it is null. When
-   * the address's proxy is null, the proxy selector is used.
-   */
-  public Proxy proxy() {
-    return proxy;
-  }
-
-  public InetSocketAddress socketAddress() {
-    return inetSocketAddress;
-  }
-
-  /**
-   * Returns true if this route tunnels HTTPS through an HTTP proxy. See <a
-   * href="http://www.ietf.org/rfc/rfc2817.txt">RFC 2817, Section 5.2</a>.
-   */
-  public boolean requiresTunnel() {
-    return address.sslSocketFactory != null && proxy.type() == Proxy.Type.HTTP;
-  }
-
-  @Override public boolean equals(@Nullable Object other) {
-    return other instanceof Route
-        && ((Route) other).address.equals(address)
-        && ((Route) other).proxy.equals(proxy)
-        && ((Route) other).inetSocketAddress.equals(inetSocketAddress);
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + address.hashCode();
-    result = 31 * result + proxy.hashCode();
-    result = 31 * result + inetSocketAddress.hashCode();
-    return result;
-  }
-
-  @Override public String toString() {
-    return "Route{" + inetSocketAddress + "}";
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/Route.kt b/okhttp/src/main/java/okhttp3/Route.kt
new file mode 100644
index 0000000000..277dcc7609
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/Route.kt
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import java.net.InetSocketAddress
+import java.net.Proxy
+
+/**
+ * The concrete route used by a connection to reach an abstract origin server. When creating a
+ * connection the client has many options:
+ *
+ *  * **HTTP proxy:** a proxy server may be explicitly configured for the client.
+ * Otherwise the [proxy selector][java.net.ProxySelector] is used. It may return
+ * multiple proxies to attempt.
+ *  * **IP address:** whether connecting directly to an origin server or a proxy,
+ * opening a socket requires an IP address. The DNS server may return multiple IP addresses
+ * to attempt.
+ *
+ * Each route is a specific selection of these options.
+ */
+data class Route(
+  internal val address: Address,
+  internal val proxy: Proxy,
+  internal val inetSocketAddress: InetSocketAddress
+) {
+
+  fun address(): Address = address
+
+  /**
+   * Returns the [Proxy] of this route.
+   *
+   * **Warning:** This may disagree with [Address.proxy] when it is null. When
+   * the address's proxy is null, the proxy selector is used.
+   */
+  fun proxy(): Proxy = proxy
+
+  fun socketAddress(): InetSocketAddress = inetSocketAddress
+
+  /**
+   * Returns true if this route tunnels HTTPS through an HTTP proxy.
+   * See [RFC 2817, Section 5.2][rfc_2817].
+   *
+   * [rfc_2817]: http://www.ietf.org/rfc/rfc2817.txt
+   */
+  fun requiresTunnel(): Boolean = address.sslSocketFactory() != null && proxy.type() == Proxy.Type.HTTP
+
+  override fun toString(): String = "Route{$inetSocketAddress}"
+}
diff --git a/okhttp/src/main/java/okhttp3/TlsVersion.java b/okhttp/src/main/java/okhttp3/TlsVersion.java
deleted file mode 100644
index 02cbeca3d1..0000000000
--- a/okhttp/src/main/java/okhttp3/TlsVersion.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * Versions of TLS that can be offered when negotiating a secure socket. See {@link
- * javax.net.ssl.SSLSocket#setEnabledProtocols}.
- */
-public enum TlsVersion {
-  TLS_1_3("TLSv1.3"), // 2016.
-  TLS_1_2("TLSv1.2"), // 2008.
-  TLS_1_1("TLSv1.1"), // 2006.
-  TLS_1_0("TLSv1"),   // 1999.
-  SSL_3_0("SSLv3"),   // 1996.
-  ;
-
-  final String javaName;
-
-  TlsVersion(String javaName) {
-    this.javaName = javaName;
-  }
-
-  public static TlsVersion forJavaName(String javaName) {
-    switch (javaName) {
-      case "TLSv1.3":
-        return TLS_1_3;
-      case "TLSv1.2":
-        return TLS_1_2;
-      case "TLSv1.1":
-        return TLS_1_1;
-      case "TLSv1":
-        return TLS_1_0;
-      case "SSLv3":
-        return SSL_3_0;
-    }
-    throw new IllegalArgumentException("Unexpected TLS version: " + javaName);
-  }
-
-  static List<TlsVersion> forJavaNames(String... tlsVersions) {
-    List<TlsVersion> result = new ArrayList<>(tlsVersions.length);
-    for (String tlsVersion : tlsVersions) {
-      result.add(forJavaName(tlsVersion));
-    }
-    return Collections.unmodifiableList(result);
-  }
-
-  public String javaName() {
-    return javaName;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/TlsVersion.kt b/okhttp/src/main/java/okhttp3/TlsVersion.kt
new file mode 100644
index 0000000000..6213a4feb1
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/TlsVersion.kt
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+/**
+ * Versions of TLS that can be offered when negotiating a secure socket. See
+ * [javax.net.ssl.SSLSocket.setEnabledProtocols].
+ */
+enum class TlsVersion(private val javaName: String) {
+  TLS_1_3("TLSv1.3"), // 2016.
+  TLS_1_2("TLSv1.2"), // 2008.
+  TLS_1_1("TLSv1.1"), // 2006.
+  TLS_1_0("TLSv1"),   // 1999.
+  SSL_3_0("SSLv3");   // 1996.
+
+  fun javaName() = javaName
+
+  companion object {
+    @JvmStatic
+    fun forJavaName(javaName: String): TlsVersion {
+      return when (javaName) {
+        "TLSv1.3" -> TLS_1_3
+        "TLSv1.2" -> TLS_1_2
+        "TLSv1.1" -> TLS_1_1
+        "TLSv1" -> TLS_1_0
+        "SSLv3" -> SSL_3_0
+        else -> throw IllegalArgumentException("Unexpected TLS version: $javaName")
+      }
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/WebSocket.java b/okhttp/src/main/java/okhttp3/WebSocket.java
deleted file mode 100644
index 46d95dec3a..0000000000
--- a/okhttp/src/main/java/okhttp3/WebSocket.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import javax.annotation.Nullable;
-import okio.ByteString;
-
-/**
- * A non-blocking interface to a web socket. Use the {@linkplain WebSocket.Factory factory} to
- * create instances; usually this is {@link OkHttpClient}.
- *
- * <h3>Web Socket Lifecycle</h3>
- *
- * Upon normal operation each web socket progresses through a sequence of states:
- *
- * <ul>
- *   <li><strong>Connecting:</strong> the initial state of each web socket. Messages may be enqueued
- *       but they won't be transmitted until the web socket is open.
- *   <li><strong>Open:</strong> the web socket has been accepted by the remote peer and is fully
- *       operational. Messages in either direction are enqueued for immediate transmission.
- *   <li><strong>Closing:</strong> one of the peers on the web socket has initiated a graceful
- *       shutdown. The web socket will continue to transmit already-enqueued messages but will
- *       refuse to enqueue new ones.
- *   <li><strong>Closed:</strong> the web socket has transmitted all of its messages and has
- *       received all messages from the peer.
- * </ul>
- *
- * Web sockets may fail due to HTTP upgrade problems, connectivity problems, or if either peer
- * chooses to short-circuit the graceful shutdown process:
- *
- * <ul>
- *   <li><strong>Canceled:</strong> the web socket connection failed. Messages that were
- *       successfully enqueued by either peer may not have been transmitted to the other.
- * </ul>
- *
- * Note that the state progression is independent for each peer. Arriving at a gracefully-closed
- * state indicates that a peer has sent all of its outgoing messages and received all of its
- * incoming messages. But it does not guarantee that the other peer will successfully receive all of
- * its incoming messages.
- */
-public interface WebSocket {
-  /** Returns the original request that initiated this web socket. */
-  Request request();
-
-  /**
-   * Returns the size in bytes of all messages enqueued to be transmitted to the server. This
-   * doesn't include framing overhead. It also doesn't include any bytes buffered by the operating
-   * system or network intermediaries. This method returns 0 if no messages are waiting
-   * in the queue. If may return a nonzero value after the web socket has been canceled; this
-   * indicates that enqueued messages were not transmitted.
-   */
-  long queueSize();
-
-  /**
-   * Attempts to enqueue {@code text} to be UTF-8 encoded and sent as a the data of a text (type
-   * {@code 0x1}) message.
-   *
-   * <p>This method returns true if the message was enqueued. Messages that would overflow the
-   * outgoing message buffer will be rejected and trigger a {@linkplain #close graceful shutdown} of
-   * this web socket. This method returns false in that case, and in any other case where this
-   * web socket is closing, closed, or canceled.
-   *
-   * <p>This method returns immediately.
-   */
-  boolean send(String text);
-
-  /**
-   * Attempts to enqueue {@code bytes} to be sent as a the data of a binary (type {@code 0x2})
-   * message.
-   *
-   * <p>This method returns true if the message was enqueued. Messages that would overflow the
-   * outgoing message buffer (16 MiB) will be rejected and trigger a
-   * {@linkplain #close graceful shutdown} of this web socket. This method returns false in that
-   * case, and in any other case where this web socket is closing, closed, or canceled.
-   *
-   * <p>This method returns immediately.
-   */
-  boolean send(ByteString bytes);
-
-  /**
-   * Attempts to initiate a graceful shutdown of this web socket. Any already-enqueued messages will
-   * be transmitted before the close message is sent but subsequent calls to {@link #send} will
-   * return false and their messages will not be enqueued.
-   *
-   * <p>This returns true if a graceful shutdown was initiated by this call. It returns false and if
-   * a graceful shutdown was already underway or if the web socket is already closed or canceled.
-   *
-   * @param code Status code as defined by <a
-   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a>.
-   * @param reason Reason for shutting down or {@code null}.
-   * @throws IllegalArgumentException if code is invalid.
-   */
-  boolean close(int code, @Nullable String reason);
-
-  /**
-   * Immediately and violently release resources held by this web socket, discarding any enqueued
-   * messages. This does nothing if the web socket has already been closed or canceled.
-   */
-  void cancel();
-
-  interface Factory {
-    /**
-     * Creates a new web socket and immediately returns it. Creating a web socket initiates an
-     * asynchronous process to connect the socket. Once that succeeds or fails, {@code listener}
-     * will be notified. The caller must either close or cancel the returned web socket when it is
-     * no longer in use.
-     */
-    WebSocket newWebSocket(Request request, WebSocketListener listener);
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/WebSocket.kt b/okhttp/src/main/java/okhttp3/WebSocket.kt
new file mode 100644
index 0000000000..fa3524e907
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/WebSocket.kt
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okio.ByteString
+
+/**
+ * A non-blocking interface to a web socket. Use the [factory][WebSocket.Factory] to create
+ * instances; usually this is [OkHttpClient].
+ *
+ * ## Web Socket Lifecycle
+ *
+ * Upon normal operation each web socket progresses through a sequence of states:
+ *
+ *  * **Connecting:** the initial state of each web socket. Messages may be enqueued but they won't
+ *    be transmitted until the web socket is open.
+ *
+ *  * **Open:** the web socket has been accepted by the remote peer and is fully operational.
+ *    Messages in either direction are enqueued for immediate transmission.
+ *
+ *  * **Closing:** one of the peers on the web socket has initiated a graceful shutdown. The web
+ *    socket will continue to transmit already-enqueued messages but will refuse to enqueue new
+ *    ones.
+ *
+ *  * **Closed:** the web socket has transmitted all of its messages and has received all messages
+ *    from the peer.
+ *
+ * Web sockets may fail due to HTTP upgrade problems, connectivity problems, or if either peer
+ * chooses to short-circuit the graceful shutdown process:
+ *
+ *  * **Canceled:** the web socket connection failed. Messages that were successfully enqueued by
+ *    either peer may not have been transmitted to the other.
+ *
+ * Note that the state progression is independent for each peer. Arriving at a gracefully-closed
+ * state indicates that a peer has sent all of its outgoing messages and received all of its
+ * incoming messages. But it does not guarantee that the other peer will successfully receive all of
+ * its incoming messages.
+ */
+interface WebSocket {
+  /** Returns the original request that initiated this web socket. */
+  fun request(): Request
+
+  /**
+   * Returns the size in bytes of all messages enqueued to be transmitted to the server. This
+   * doesn't include framing overhead. It also doesn't include any bytes buffered by the operating
+   * system or network intermediaries. This method returns 0 if no messages are waiting in the
+   * queue. If may return a nonzero value after the web socket has been canceled; this indicates
+   * that enqueued messages were not transmitted.
+   */
+  fun queueSize(): Long
+
+  /**
+   * Attempts to enqueue `text` to be UTF-8 encoded and sent as a the data of a text (type `0x1`)
+   * message.
+   *
+   * This method returns true if the message was enqueued. Messages that would overflow the outgoing
+   * message buffer will be rejected and trigger a [graceful shutdown][close] of this web socket.
+   * This method returns false in that case, and in any other case where this web socket is closing,
+   * closed, or canceled.
+   *
+   * This method returns immediately.
+   */
+  fun send(text: String): Boolean
+
+  /**
+   * Attempts to enqueue `bytes` to be sent as a the data of a binary (type `0x2`) message.
+   *
+   * This method returns true if the message was enqueued. Messages that would overflow the outgoing
+   * message buffer (16 MiB) will be rejected and trigger a [graceful shutdown][close] of this web
+   * socket. This method returns false in that case, and in any other case where this web socket is
+   * closing, closed, or canceled.
+   *
+   * This method returns immediately.
+   */
+  fun send(bytes: ByteString): Boolean
+
+  /**
+   * Attempts to initiate a graceful shutdown of this web socket. Any already-enqueued messages will
+   * be transmitted before the close message is sent but subsequent calls to [send] will return
+   * false and their messages will not be enqueued.
+   *
+   * This returns true if a graceful shutdown was initiated by this call. It returns false if
+   * a graceful shutdown was already underway or if the web socket is already closed or canceled.
+   *
+   * @param code Status code as defined by
+   *     [Section 7.4 of RFC 6455](http://tools.ietf.org/html/rfc6455#section-7.4).
+   * @param reason Reason for shutting down or null.
+   * @throws IllegalArgumentException if code is invalid.
+   */
+  fun close(code: Int, reason: String?): Boolean
+
+  /**
+   * Immediately and violently release resources held by this web socket, discarding any enqueued
+   * messages. This does nothing if the web socket has already been closed or canceled.
+   */
+  fun cancel()
+
+  interface Factory {
+    /**
+     * Creates a new web socket and immediately returns it. Creating a web socket initiates an
+     * asynchronous process to connect the socket. Once that succeeds or fails, `listener` will be
+     * notified. The caller must either close or cancel the returned web socket when it is no longer
+     * in use.
+     */
+    fun newWebSocket(request: Request, listener: WebSocketListener): WebSocket
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/WebSocketListener.java b/okhttp/src/main/java/okhttp3/WebSocketListener.kt
similarity index 62%
rename from okhttp/src/main/java/okhttp3/WebSocketListener.java
rename to okhttp/src/main/java/okhttp3/WebSocketListener.kt
index 69276d933b..92fca88c91 100644
--- a/okhttp/src/main/java/okhttp3/WebSocketListener.java
+++ b/okhttp/src/main/java/okhttp3/WebSocketListener.kt
@@ -13,46 +13,38 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3;
+package okhttp3
 
-import javax.annotation.Nullable;
-import okio.ByteString;
+import okio.ByteString
 
-public abstract class WebSocketListener {
+abstract class WebSocketListener {
   /**
    * Invoked when a web socket has been accepted by the remote peer and may begin transmitting
    * messages.
    */
-  public void onOpen(WebSocket webSocket, Response response) {
-  }
+  open fun onOpen(webSocket: WebSocket, response: Response) {}
 
-  /** Invoked when a text (type {@code 0x1}) message has been received. */
-  public void onMessage(WebSocket webSocket, String text) {
-  }
+  /** Invoked when a text (type `0x1`) message has been received. */
+  open fun onMessage(webSocket: WebSocket, text: String) {}
 
-  /** Invoked when a binary (type {@code 0x2}) message has been received. */
-  public void onMessage(WebSocket webSocket, ByteString bytes) {
-  }
+  /** Invoked when a binary (type `0x2`) message has been received. */
+  open fun onMessage(webSocket: WebSocket, bytes: ByteString) {}
 
   /**
-   * Invoked when the remote peer has indicated that no more incoming messages will be
-   * transmitted.
+   * Invoked when the remote peer has indicated that no more incoming messages will be transmitted.
    */
-  public void onClosing(WebSocket webSocket, int code, String reason) {
-  }
+  open fun onClosing(webSocket: WebSocket, code: Int, reason: String) {}
 
   /**
    * Invoked when both peers have indicated that no more messages will be transmitted and the
    * connection has been successfully released. No further calls to this listener will be made.
    */
-  public void onClosed(WebSocket webSocket, int code, String reason) {
-  }
+  open fun onClosed(webSocket: WebSocket, code: Int, reason: String) {}
 
   /**
    * Invoked when a web socket has been closed due to an error reading from or writing to the
    * network. Both outgoing and incoming messages may have been lost. No further calls to this
    * listener will be made.
    */
-  public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response) {
-  }
+  open fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {}
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index 1be96fd3e7..44a16ae774 100644
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -15,24 +15,15 @@
  */
 package okhttp3.internal;
 
-import java.net.MalformedURLException;
-import java.net.Socket;
-import java.net.UnknownHostException;
-import javax.net.ssl.SSLSocket;
+import javax.annotation.Nullable;
 import okhttp3.Address;
 import okhttp3.Call;
 import okhttp3.ConnectionPool;
-import okhttp3.ConnectionSpec;
-import okhttp3.Headers;
-import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.Route;
-import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.connection.RouteDatabase;
-import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.connection.Exchange;
+import okhttp3.internal.connection.RealConnectionPool;
 
 /**
  * Escalate internal APIs in {@code okhttp3} so they can be used from OkHttp's implementation
@@ -47,35 +38,16 @@ public static void initializeInstanceForTests() {
 
   public static Internal instance;
 
-  public abstract void addLenient(Headers.Builder builder, String line);
-
-  public abstract void addLenient(Headers.Builder builder, String name, String value);
-
-  public abstract void setCache(OkHttpClient.Builder builder, InternalCache internalCache);
-
-  public abstract RealConnection get(ConnectionPool pool, Address address,
-      StreamAllocation streamAllocation, Route route);
+  public abstract RealConnectionPool realConnectionPool(ConnectionPool connectionPool);
 
   public abstract boolean equalsNonHost(Address a, Address b);
 
-  public abstract Socket deduplicate(
-      ConnectionPool pool, Address address, StreamAllocation streamAllocation);
-
-  public abstract void put(ConnectionPool pool, RealConnection connection);
-
-  public abstract boolean connectionBecameIdle(ConnectionPool pool, RealConnection connection);
-
-  public abstract RouteDatabase routeDatabase(ConnectionPool connectionPool);
-
   public abstract int code(Response.Builder responseBuilder);
 
-  public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
-      boolean isFallback);
-
-  public abstract HttpUrl getHttpUrlChecked(String url)
-      throws MalformedURLException, UnknownHostException;
+  public abstract Call newWebSocketCall(OkHttpClient client, Request request);
 
-  public abstract StreamAllocation streamAllocation(Call call);
+  public abstract void initExchange(
+      Response.Builder responseBuilder, Exchange exchange);
 
-  public abstract Call newWebSocketCall(OkHttpClient client, Request request);
+  public abstract @Nullable Exchange exchange(Response response);
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/InternalKt.kt b/okhttp/src/main/java/okhttp3/internal/InternalKt.kt
new file mode 100644
index 0000000000..d47c59ec97
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/InternalKt.kt
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal
+
+import okhttp3.Cache
+import okhttp3.ConnectionSpec
+import okhttp3.Cookie
+import okhttp3.Headers
+import okhttp3.HttpUrl
+import okhttp3.Request
+import javax.net.ssl.SSLSocket
+
+fun parseCookie(currentTimeMillis: Long, url: HttpUrl, setCookie: String): Cookie? =
+    Cookie.parse(currentTimeMillis, url, setCookie)
+
+fun cookieToString(cookie: Cookie, forObsoleteRfc2965: Boolean) =
+    cookie.toString(forObsoleteRfc2965)
+
+fun addHeaderLenient(builder: Headers.Builder, line: String) =
+    builder.addLenient(line)
+
+fun addHeaderLenient(builder: Headers.Builder, name: String, value: String) =
+    builder.addLenient(name, value)
+
+fun cacheGet(cache: Cache, request: Request) = cache.get(request)
+
+fun applyConnectionSpec(connectionSpec: ConnectionSpec, sslSocket: SSLSocket, isFallback: Boolean) =
+    connectionSpec.apply(sslSocket, isFallback)
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 2fcb93e510..51e982c408 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -24,54 +24,68 @@
 import java.net.Socket;
 import java.net.UnknownHostException;
 import java.nio.charset.Charset;
+import java.security.AccessControlException;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map;
 import java.util.TimeZone;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.EventListener;
+import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
+import okhttp3.internal.http2.Header;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
+import okio.Options;
 import okio.Source;
 
+import static java.nio.charset.StandardCharsets.UTF_16BE;
+import static java.nio.charset.StandardCharsets.UTF_16LE;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Arrays.asList;
+import static okhttp3.internal.InternalKtKt.addHeaderLenient;
+
 /** Junk drawer of utility methods. */
 public final class Util {
   public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
   public static final String[] EMPTY_STRING_ARRAY = new String[0];
+  public static final Headers EMPTY_HEADERS = Headers.of();
 
   public static final ResponseBody EMPTY_RESPONSE = ResponseBody.create(null, EMPTY_BYTE_ARRAY);
   public static final RequestBody EMPTY_REQUEST = RequestBody.create(null, EMPTY_BYTE_ARRAY);
 
-  private static final ByteString UTF_8_BOM = ByteString.decodeHex("efbbbf");
-  private static final ByteString UTF_16_BE_BOM = ByteString.decodeHex("feff");
-  private static final ByteString UTF_16_LE_BOM = ByteString.decodeHex("fffe");
-  private static final ByteString UTF_32_BE_BOM = ByteString.decodeHex("0000ffff");
-  private static final ByteString UTF_32_LE_BOM = ByteString.decodeHex("ffff0000");
+  /** Byte order marks. */
+  private static final Options UNICODE_BOMS = Options.of(
+      ByteString.decodeHex("efbbbf"),   // UTF-8
+      ByteString.decodeHex("feff"),     // UTF-16BE
+      ByteString.decodeHex("fffe"),     // UTF-16LE
+      ByteString.decodeHex("0000ffff"), // UTF-32BE
+      ByteString.decodeHex("ffff0000")  // UTF-32LE
+  );
 
-  public static final Charset UTF_8 = Charset.forName("UTF-8");
-  public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
-  private static final Charset UTF_16_BE = Charset.forName("UTF-16BE");
-  private static final Charset UTF_16_LE = Charset.forName("UTF-16LE");
-  private static final Charset UTF_32_BE = Charset.forName("UTF-32BE");
-  private static final Charset UTF_32_LE = Charset.forName("UTF-32LE");
+  private static final Charset UTF_32BE = Charset.forName("UTF-32BE");
+  private static final Charset UTF_32LE = Charset.forName("UTF-32LE");
 
   /** GMT and UTC are equivalent for our purposes. */
   public static final TimeZone UTC = TimeZone.getTimeZone("GMT");
 
-  public static final Comparator<String> NATURAL_ORDER = new Comparator<String>() {
-    @Override public int compare(String a, String b) {
-      return a.compareTo(b);
-    }
-  };
+  public static final Comparator<String> NATURAL_ORDER = String::compareTo;
 
   /**
    * Quick and dirty pattern to differentiate IP addresses from hostnames. This is an approximation
@@ -95,11 +109,6 @@ public static void checkOffsetAndCount(long arrayLength, long offset, long count
     }
   }
 
-  /** Returns true if two possibly-null objects are equal. */
-  public static boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
-  }
-
   /**
    * Closes {@code closeable}, ignoring any checked exceptions. Does nothing if {@code closeable} is
    * null.
@@ -192,18 +201,24 @@ public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) th
     return Collections.unmodifiableList(new ArrayList<>(list));
   }
 
+  /** Returns an immutable copy of {@code map}. */
+  public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {
+    return map.isEmpty()
+        ? Collections.emptyMap()
+        : Collections.unmodifiableMap(new LinkedHashMap<>(map));
+  }
+
   /** Returns an immutable list containing {@code elements}. */
+  @SafeVarargs
   public static <T> List<T> immutableList(T... elements) {
-    return Collections.unmodifiableList(Arrays.asList(elements.clone()));
+    return Collections.unmodifiableList(asList(elements.clone()));
   }
 
-  public static ThreadFactory threadFactory(final String name, final boolean daemon) {
-    return new ThreadFactory() {
-      @Override public Thread newThread(Runnable runnable) {
-        Thread result = new Thread(runnable, name);
-        result.setDaemon(daemon);
-        return result;
-      }
+  public static ThreadFactory threadFactory(String name, boolean daemon) {
+    return runnable -> {
+      Thread result = new Thread(runnable, name);
+      result.setDaemon(daemon);
+      return result;
     };
   }
 
@@ -211,7 +226,6 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
    * Returns an array containing only elements found in {@code first} and also in {@code
    * second}. The returned elements are in the same order as in {@code first}.
    */
-  @SuppressWarnings("unchecked")
   public static String[] intersect(
       Comparator<? super String> comparator, String[] first, String[] second) {
     List<String> result = new ArrayList<>();
@@ -223,7 +237,7 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
         }
       }
     }
-    return result.toArray(new String[result.size()]);
+    return result.toArray(new String[0]);
   }
 
   /**
@@ -273,8 +287,7 @@ public static int indexOf(Comparator<String> comparator, String[] array, String
   }
 
   public static String[] concat(String[] array, String value) {
-    String[] result = new String[array.length + 1];
-    System.arraycopy(array, 0, result, 0, array.length);
+    String[] result = Arrays.copyOf(array, array.length + 1);
     result[result.length - 1] = value;
     return result;
   }
@@ -366,6 +379,7 @@ public static String canonicalizeHost(String host) {
       if (inetAddress == null) return null;
       byte[] address = inetAddress.getAddress();
       if (address.length == 16) return inet6AddressToAscii(address);
+      if (address.length == 4) return inetAddress.getHostAddress(); // An IPv4-mapped IPv6 address.
       throw new AssertionError("Invalid IPv6 address: '" + host + "'");
     }
 
@@ -429,27 +443,15 @@ public static String format(String format, Object... args) {
   }
 
   public static Charset bomAwareCharset(BufferedSource source, Charset charset) throws IOException {
-    if (source.rangeEquals(0, UTF_8_BOM)) {
-      source.skip(UTF_8_BOM.size());
-      return UTF_8;
-    }
-    if (source.rangeEquals(0, UTF_16_BE_BOM)) {
-      source.skip(UTF_16_BE_BOM.size());
-      return UTF_16_BE;
-    }
-    if (source.rangeEquals(0, UTF_16_LE_BOM)) {
-      source.skip(UTF_16_LE_BOM.size());
-      return UTF_16_LE;
+    switch (source.select(UNICODE_BOMS)) {
+      case 0: return UTF_8;
+      case 1: return UTF_16BE;
+      case 2: return UTF_16LE;
+      case 3: return UTF_32BE;
+      case 4: return UTF_32LE;
+      case -1: return charset;
+      default: throw new AssertionError();
     }
-    if (source.rangeEquals(0, UTF_32_BE_BOM)) {
-      source.skip(UTF_32_BE_BOM.size());
-      return UTF_32_BE;
-    }
-    if (source.rangeEquals(0, UTF_32_LE_BOM)) {
-      source.skip(UTF_32_LE_BOM.size());
-      return UTF_32_LE;
-    }
-    return charset;
   }
 
   public static int checkDuration(String name, long duration, TimeUnit unit) {
@@ -461,16 +463,6 @@ public static int checkDuration(String name, long duration, TimeUnit unit) {
     return (int) millis;
   }
 
-  public static AssertionError assertionError(String message, Exception e) {
-    AssertionError assertionError = new AssertionError(message);
-    try {
-      assertionError.initCause(e);
-    } catch (IllegalStateException ise) {
-      // ignored, shouldn't happen
-    }
-    return assertionError;
-  }
-
   public static int decodeHexDigit(char c) {
     if (c >= '0' && c <= '9') return c - '0';
     if (c >= 'a' && c <= 'f') return c - 'a' + 10;
@@ -619,4 +611,61 @@ private static String inet6AddressToAscii(byte[] address) {
     }
     return result.readUtf8();
   }
+
+  public static X509TrustManager platformTrustManager() {
+    try {
+      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+          TrustManagerFactory.getDefaultAlgorithm());
+      trustManagerFactory.init((KeyStore) null);
+      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+        throw new IllegalStateException("Unexpected default trust managers:"
+            + Arrays.toString(trustManagers));
+      }
+      return (X509TrustManager) trustManagers[0];
+    } catch (GeneralSecurityException e) {
+      throw new AssertionError("No System TLS", e); // The system has no TLS. Just give up.
+    }
+  }
+
+  public static Headers toHeaders(List<Header> headerBlock) {
+    Headers.Builder builder = new Headers.Builder();
+    for (Header header : headerBlock) {
+      addHeaderLenient(builder, header.name.utf8(), header.value.utf8());
+    }
+    return builder.build();
+  }
+
+  public static List<Header> toHeaderBlock(Headers headers) {
+    List<Header> result = new ArrayList<>();
+    for (int i = 0; i < headers.size(); i++) {
+      result.add(new Header(headers.name(i), headers.value(i)));
+    }
+    return result;
+  }
+
+  /**
+   * Returns the system property, or {@code defaultValue} if the system property is null or
+   * cannot be read (e.g. because of security policy restrictions).
+   */
+  public static String getSystemProperty(String key, @Nullable String defaultValue) {
+    String value;
+    try {
+      value = System.getProperty(key);
+    } catch (AccessControlException ex) {
+      return defaultValue;
+    }
+    return value != null ? value : defaultValue;
+  }
+
+  /** Returns true if an HTTP request for {@code a} and {@code b} can reuse a connection. */
+  public static boolean sameConnection(HttpUrl a, HttpUrl b) {
+    return a.host().equals(b.host())
+        && a.port() == b.port()
+        && a.scheme().equals(b.scheme());
+  }
+
+  public static EventListener.Factory eventListenerFactory(EventListener listener) {
+    return call -> listener;
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java b/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java
new file mode 100644
index 0000000000..e97bb4d9cb
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/annotations/EverythingIsNonNull.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package okhttp3.internal.annotations;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import javax.annotation.Nonnull;
+import javax.annotation.meta.TypeQualifierDefault;
+
+/**
+ * Extends {@code ParametersAreNonnullByDefault} to also apply to Method results and fields.
+ *
+ * @see javax.annotation.ParametersAreNonnullByDefault
+ */
+@Documented
+@Nonnull
+@TypeQualifierDefault({
+    ElementType.FIELD,
+    ElementType.METHOD,
+    ElementType.PARAMETER
+})
+@Retention(RetentionPolicy.RUNTIME)
+public @interface EverythingIsNonNull { }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index d46494d95b..4b73f5464d 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -17,14 +17,14 @@
 package okhttp3.internal.cache;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
 import okhttp3.Headers;
 import okhttp3.Interceptor;
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.ExchangeCodec;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http.HttpMethod;
 import okhttp3.internal.http.RealResponseBody;
@@ -38,14 +38,15 @@
 
 import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.InternalKtKt.addHeaderLenient;
 import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.Util.discard;
 
 /** Serves requests from the cache and writes responses to the cache. */
 public final class CacheInterceptor implements Interceptor {
-  final InternalCache cache;
+  final @Nullable InternalCache cache;
 
-  public CacheInterceptor(InternalCache cache) {
+  public CacheInterceptor(@Nullable InternalCache cache) {
     this.cache = cache;
   }
 
@@ -199,7 +200,7 @@ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response
 
       @Override public void close() throws IOException {
         if (!cacheRequestClosed
-            && !discard(this, HttpCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
+            && !discard(this, ExchangeCodec.DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
           cacheRequestClosed = true;
           cacheRequest.abort();
         }
@@ -224,16 +225,17 @@ private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
       if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
         continue; // Drop 100-level freshness warnings.
       }
-      if (isContentSpecificHeader(fieldName) || !isEndToEnd(fieldName)
-              || networkHeaders.get(fieldName) == null) {
-        Internal.instance.addLenient(result, fieldName, value);
+      if (isContentSpecificHeader(fieldName)
+          || !isEndToEnd(fieldName)
+          || networkHeaders.get(fieldName) == null) {
+        addHeaderLenient(result, fieldName, value);
       }
     }
 
     for (int i = 0, size = networkHeaders.size(); i < size; i++) {
       String fieldName = networkHeaders.name(i);
       if (!isContentSpecificHeader(fieldName) && isEndToEnd(fieldName)) {
-        Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
+        addHeaderLenient(result, fieldName, networkHeaders.value(i));
       }
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.kt
similarity index 78%
rename from okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java
rename to okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.kt
index b4432b4e1d..245ccbf049 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheRequest.kt
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.cache;
+package okhttp3.internal.cache
 
-import java.io.IOException;
-import okio.Sink;
+import java.io.IOException
+import okio.Sink
 
-public interface CacheRequest {
-  Sink body() throws IOException;
+interface CacheRequest {
+  @Throws(IOException::class)
+  fun body(): Sink
 
-  void abort();
+  fun abort()
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
index 3ae1926650..2753cf27f4 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -21,7 +21,6 @@
 import okhttp3.Headers;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.Internal;
 import okhttp3.internal.http.HttpDate;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http.StatusLine;
@@ -38,6 +37,7 @@
 import static java.net.HttpURLConnection.HTTP_OK;
 import static java.net.HttpURLConnection.HTTP_REQ_TOO_LONG;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.internal.InternalKtKt.addHeaderLenient;
 
 /**
  * Given a request and cached response, this figures out whether to use the network, the cache, or
@@ -205,9 +205,6 @@ private CacheStrategy getCandidate() {
       }
 
       CacheControl responseCaching = cacheResponse.cacheControl();
-      if (responseCaching.immutable()) {
-        return new CacheStrategy(null, cacheResponse);
-      }
 
       long ageMillis = cacheResponseAge();
       long freshMillis = computeFreshnessLifetime();
@@ -256,7 +253,7 @@ private CacheStrategy getCandidate() {
       }
 
       Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();
-      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);
+      addHeaderLenient(conditionalRequestHeaders, conditionName, conditionValue);
 
       Request conditionalRequest = request.newBuilder()
           .headers(conditionalRequestHeaders.build())
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
index c3fb740e28..674056348f 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
@@ -167,6 +167,7 @@
   /** Used to run 'cleanupRunnable' for journal rebuilds. */
   private final Executor executor;
   private final Runnable cleanupRunnable = new Runnable() {
+    @Override
     public void run() {
       synchronized (DiskLruCache.this) {
         if (!initialized | closed) {
@@ -267,14 +268,13 @@ public static DiskLruCache create(FileSystem fileSystem, File directory, int app
 
     // Use a single background thread to evict entries.
     Executor executor = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
-        new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp DiskLruCache", true));
+        new LinkedBlockingQueue<>(), Util.threadFactory("OkHttp DiskLruCache", true));
 
     return new DiskLruCache(fileSystem, directory, appVersion, valueCount, maxSize, executor);
   }
 
   private void readJournal() throws IOException {
-    BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
-    try {
+    try (BufferedSource source = Okio.buffer(fileSystem.source(journalFile))) {
       String magic = source.readUtf8LineStrict();
       String version = source.readUtf8LineStrict();
       String appVersionString = source.readUtf8LineStrict();
@@ -306,8 +306,6 @@ private void readJournal() throws IOException {
       } else {
         journalWriter = newJournalWriter();
       }
-    } finally {
-      Util.closeQuietly(source);
     }
   }
 
@@ -393,8 +391,7 @@ synchronized void rebuildJournal() throws IOException {
       journalWriter.close();
     }
 
-    BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp));
-    try {
+    try (BufferedSink writer = Okio.buffer(fileSystem.sink(journalFileTmp))) {
       writer.writeUtf8(MAGIC).writeByte('\n');
       writer.writeUtf8(VERSION_1).writeByte('\n');
       writer.writeDecimalLong(appVersion).writeByte('\n');
@@ -413,8 +410,6 @@ synchronized void rebuildJournal() throws IOException {
           writer.writeByte('\n');
         }
       }
-    } finally {
-      writer.close();
     }
 
     if (fileSystem.exists(journalFile)) {
@@ -668,7 +663,7 @@ private synchronized void checkNotClosed() {
       return;
     }
     // Copying for safe iteration.
-    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
+    for (Entry entry : lruEntries.values().toArray(new Entry[0])) {
       if (entry.currentEditor != null) {
         entry.currentEditor.abort();
       }
@@ -703,7 +698,7 @@ public void delete() throws IOException {
   public synchronized void evictAll() throws IOException {
     initialize();
     // Copying for safe iteration.
-    for (Entry entry : lruEntries.values().toArray(new Entry[lruEntries.size()])) {
+    for (Entry entry : lruEntries.values().toArray(new Entry[0])) {
       removeEntry(entry);
     }
     mostRecentTrimFailed = false;
@@ -820,6 +815,7 @@ public long getLength(int index) {
       return lengths[index];
     }
 
+    @Override
     public void close() {
       for (Source in : sources) {
         Util.closeQuietly(in);
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
deleted file mode 100644
index 561a30507e..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.io.IOException;
-import okio.Buffer;
-import okio.ForwardingSink;
-import okio.Sink;
-
-/** A sink that never throws IOExceptions, even if the underlying sink does. */
-class FaultHidingSink extends ForwardingSink {
-  private boolean hasErrors;
-
-  FaultHidingSink(Sink delegate) {
-    super(delegate);
-  }
-
-  @Override public void write(Buffer source, long byteCount) throws IOException {
-    if (hasErrors) {
-      source.skip(byteCount);
-      return;
-    }
-    try {
-      super.write(source, byteCount);
-    } catch (IOException e) {
-      hasErrors = true;
-      onException(e);
-    }
-  }
-
-  @Override public void flush() throws IOException {
-    if (hasErrors) return;
-    try {
-      super.flush();
-    } catch (IOException e) {
-      hasErrors = true;
-      onException(e);
-    }
-  }
-
-  @Override public void close() throws IOException {
-    if (hasErrors) return;
-    try {
-      super.close();
-    } catch (IOException e) {
-      hasErrors = true;
-      onException(e);
-    }
-  }
-
-  protected void onException(IOException e) {
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.kt b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.kt
new file mode 100644
index 0000000000..757546d708
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.kt
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.cache
+
+import okio.Buffer
+import okio.ForwardingSink
+import okio.Sink
+import java.io.IOException
+
+/** A sink that never throws IOExceptions, even if the underlying sink does. */
+internal open class FaultHidingSink(delegate: Sink): ForwardingSink(delegate) {
+  private var hasErrors = false
+
+  override fun write(source: Buffer, byteCount: Long) {
+    if (hasErrors) {
+      source.skip(byteCount)
+      return
+    }
+    try {
+      super.write(source, byteCount)
+    } catch (e: IOException) {
+      hasErrors = true
+      onException(e)
+    }
+  }
+
+  override fun flush() {
+    if (hasErrors) {
+      return
+    }
+    try {
+      super.flush()
+    } catch (e: IOException) {
+      hasErrors = true
+      onException(e)
+    }
+  }
+
+  override fun close() {
+    if (hasErrors) {
+      return
+    }
+    try {
+      super.close()
+    } catch (e: IOException) {
+      hasErrors = true
+      onException(e)
+    }
+  }
+
+  protected open fun onException(e: IOException) {}
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.kt
similarity index 53%
rename from okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
rename to okhttp/src/main/java/okhttp3/internal/cache/InternalCache.kt
index 6c70465b59..f066062fec 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/InternalCache.kt
@@ -13,37 +13,40 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.cache;
+package okhttp3.internal.cache
 
-import java.io.IOException;
-import okhttp3.Request;
-import okhttp3.Response;
+import okhttp3.Request
+import okhttp3.Response
+import java.io.IOException
 
 /**
- * OkHttp's internal cache interface. Applications shouldn't implement this: instead use {@link
- * okhttp3.Cache}.
+ * OkHttp's internal cache interface. Applications shouldn't implement this: instead use [okhttp3.Cache].
  */
-public interface InternalCache {
-  Response get(Request request) throws IOException;
+interface InternalCache {
 
-  CacheRequest put(Response response) throws IOException;
+  @Throws(IOException::class)
+  fun get(request: Request): Response?
+
+  @Throws(IOException::class)
+  fun put(response: Response): CacheRequest?
 
   /**
-   * Remove any cache entries for the supplied {@code request}. This is invoked when the client
+   * Remove any cache entries for the supplied [request]. This is invoked when the client
    * invalidates the cache, such as when making POST requests.
    */
-  void remove(Request request) throws IOException;
+  @Throws(IOException::class)
+  fun remove(request: Request)
 
   /**
    * Handles a conditional request hit by updating the stored cache response with the headers from
-   * {@code network}. The cached response body is not updated. If the stored response has changed
-   * since {@code cached} was returned, this does nothing.
+   * [network]. The cached response body is not updated. If the stored response has changed
+   * since [cached] was returned, this does nothing.
    */
-  void update(Response cached, Response network);
+  fun update(cached: Response, network: Response)
 
   /** Track an conditional GET that was satisfied by this cache. */
-  void trackConditionalCacheHit();
+  fun trackConditionalCacheHit()
 
-  /** Track an HTTP response being satisfied with {@code cacheStrategy}. */
-  void trackResponse(CacheStrategy cacheStrategy);
+  /** Track an HTTP response being satisfied with [cacheStrategy]. */
+  fun trackResponse(cacheStrategy: CacheStrategy)
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
index b8a346c03a..3e071d46f1 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
@@ -21,7 +21,6 @@
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.http.HttpCodec;
 import okhttp3.internal.http.RealInterceptorChain;
 
 /** Opens a connection to the target server and proceeds to the next interceptor. */
@@ -35,13 +34,12 @@ public ConnectInterceptor(OkHttpClient client) {
   @Override public Response intercept(Chain chain) throws IOException {
     RealInterceptorChain realChain = (RealInterceptorChain) chain;
     Request request = realChain.request();
-    StreamAllocation streamAllocation = realChain.streamAllocation();
+    Transmitter transmitter = realChain.transmitter();
 
     // We need the network to satisfy this request. Possibly for validating a conditional GET.
     boolean doExtensiveHealthChecks = !request.method().equals("GET");
-    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);
-    RealConnection connection = streamAllocation.connection();
+    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);
 
-    return realChain.proceed(request, streamAllocation, httpCodec, connection);
+    return realChain.proceed(request, transmitter, exchange);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
index 0b438bfa1f..a40b41b59d 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
@@ -22,26 +22,25 @@
 import java.security.cert.CertificateException;
 import java.util.Arrays;
 import java.util.List;
+import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLProtocolException;
 import javax.net.ssl.SSLSocket;
 import okhttp3.ConnectionSpec;
-import okhttp3.internal.Internal;
+import okhttp3.internal.InternalKtKt;
 
 /**
  * Handles the connection spec fallback strategy: When a secure socket connection fails due to a
  * handshake / protocol problem the connection may be retried with different protocols. Instances
  * are stateful and should be created and used for a single connection attempt.
  */
-public final class ConnectionSpecSelector {
-
+final class ConnectionSpecSelector {
   private final List<ConnectionSpec> connectionSpecs;
   private int nextModeIndex;
   private boolean isFallbackPossible;
   private boolean isFallback;
 
-  public ConnectionSpecSelector(List<ConnectionSpec> connectionSpecs) {
+  ConnectionSpecSelector(List<ConnectionSpec> connectionSpecs) {
     this.nextModeIndex = 0;
     this.connectionSpecs = connectionSpecs;
   }
@@ -52,7 +51,7 @@ public ConnectionSpecSelector(List<ConnectionSpec> connectionSpecs) {
    *
    * @throws IOException if the socket does not support any of the TLS modes available
    */
-  public ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOException {
+  ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOException {
     ConnectionSpec tlsConfiguration = null;
     for (int i = nextModeIndex, size = connectionSpecs.size(); i < size; i++) {
       ConnectionSpec connectionSpec = connectionSpecs.get(i);
@@ -75,7 +74,7 @@ public ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOExcept
 
     isFallbackPossible = isFallbackPossible(sslSocket);
 
-    Internal.instance.apply(tlsConfiguration, sslSocket, isFallback);
+    InternalKtKt.applyConnectionSpec(tlsConfiguration, sslSocket, isFallback);
 
     return tlsConfiguration;
   }
@@ -87,7 +86,7 @@ public ConnectionSpec configureSecureSocket(SSLSocket sslSocket) throws IOExcept
    * @return {@code true} if the connection should be retried using {@link
    * #configureSecureSocket(SSLSocket)} or {@code false} if not
    */
-  public boolean connectionFailed(IOException e) {
+  boolean connectionFailed(IOException e) {
     // Any future attempt to connect using this strategy will be a fallback attempt.
     isFallback = true;
 
@@ -110,8 +109,7 @@ public boolean connectionFailed(IOException e) {
     // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
     // again with a different connection spec.
     if (e instanceof SSLHandshakeException) {
-      // If the problem was a CertificateException from the X509TrustManager,
-      // do not retry.
+      // If the problem was a CertificateException from the X509TrustManager, do not retry.
       if (e.getCause() instanceof CertificateException) {
         return false;
       }
@@ -121,9 +119,8 @@ public boolean connectionFailed(IOException e) {
       return false;
     }
 
-    // On Android, SSLProtocolExceptions can be caused by TLS_FALLBACK_SCSV failures, which means we
-    // retry those when we probably should not.
-    return (e instanceof SSLHandshakeException || e instanceof SSLProtocolException);
+    // Retry for all other SSL failures.
+    return e instanceof SSLException;
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/Exchange.java b/okhttp/src/main/java/okhttp3/internal/connection/Exchange.java
new file mode 100644
index 0000000000..a5c59fda4a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/Exchange.java
@@ -0,0 +1,326 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.net.SocketException;
+import javax.annotation.Nullable;
+import okhttp3.Call;
+import okhttp3.EventListener;
+import okhttp3.Headers;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Internal;
+import okhttp3.internal.http.ExchangeCodec;
+import okhttp3.internal.http.RealResponseBody;
+import okhttp3.internal.ws.RealWebSocket;
+import okio.Buffer;
+import okio.ForwardingSink;
+import okio.ForwardingSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+/**
+ * Transmits a single HTTP request and a response pair. This layers connection management and events
+ * on {@link ExchangeCodec}, which handles the actual I/O.
+ */
+public final class Exchange {
+  final Transmitter transmitter;
+  final Call call;
+  final EventListener eventListener;
+  final ExchangeFinder finder;
+  final ExchangeCodec codec;
+  private boolean duplex;
+
+  public Exchange(Transmitter transmitter, Call call, EventListener eventListener,
+      ExchangeFinder finder, ExchangeCodec codec) {
+    this.transmitter = transmitter;
+    this.call = call;
+    this.eventListener = eventListener;
+    this.finder = finder;
+    this.codec = codec;
+  }
+
+  public RealConnection connection() {
+    return codec.connection();
+  }
+
+  /** Returns true if the request body need not complete before the response body starts. */
+  public boolean isDuplex() {
+    return duplex;
+  }
+
+  public void writeRequestHeaders(Request request) throws IOException {
+    try {
+      eventListener.requestHeadersStart(call);
+      codec.writeRequestHeaders(request);
+      eventListener.requestHeadersEnd(call, request);
+    } catch (IOException e) {
+      eventListener.requestFailed(call, e);
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public Sink createRequestBody(Request request, boolean duplex) throws IOException {
+    this.duplex = duplex;
+    long contentLength = request.body().contentLength();
+    eventListener.requestBodyStart(call);
+    Sink rawRequestBody = codec.createRequestBody(request, contentLength);
+    return new RequestBodySink(rawRequestBody, contentLength);
+  }
+
+  public void flushRequest() throws IOException {
+    try {
+      codec.flushRequest();
+    } catch (IOException e) {
+      eventListener.requestFailed(call, e);
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public void finishRequest() throws IOException {
+    try {
+      codec.finishRequest();
+    } catch (IOException e) {
+      eventListener.requestFailed(call, e);
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public void responseHeadersStart() {
+    eventListener.responseHeadersStart(call);
+  }
+
+  public @Nullable Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
+    try {
+      Response.Builder result = codec.readResponseHeaders(expectContinue);
+      if (result != null) {
+        Internal.instance.initExchange(result, this);
+      }
+      return result;
+    } catch (IOException e) {
+      eventListener.responseFailed(call, e);
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public void responseHeadersEnd(Response response) {
+    eventListener.responseHeadersEnd(call, response);
+  }
+
+  public ResponseBody openResponseBody(Response response) throws IOException {
+    try {
+      eventListener.responseBodyStart(call);
+      String contentType = response.header("Content-Type");
+      long contentLength = codec.reportedContentLength(response);
+      Source rawSource = codec.openResponseBodySource(response);
+      ResponseBodySource source = new ResponseBodySource(rawSource, contentLength);
+      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
+    } catch (IOException e) {
+      eventListener.responseFailed(call, e);
+      trackFailure(e);
+      throw e;
+    }
+  }
+
+  public Headers trailers() throws IOException {
+    return codec.trailers();
+  }
+
+  public void timeoutEarlyExit() {
+    transmitter.timeoutEarlyExit();
+  }
+
+  public RealWebSocket.Streams newWebSocketStreams() throws SocketException {
+    transmitter.timeoutEarlyExit();
+    return codec.connection().newWebSocketStreams(this);
+  }
+
+  public void webSocketUpgradeFailed() {
+    bodyComplete(-1L, true, true, null);
+  }
+
+  public void noNewExchangesOnConnection() {
+    codec.connection().noNewExchanges();
+  }
+
+  public void cancel() {
+    codec.cancel();
+  }
+
+  /**
+   * Revoke this exchange's access to streams. This is necessary when a follow-up request is
+   * required but the preceding exchange hasn't completed yet.
+   */
+  public void detachWithViolence() {
+    codec.cancel();
+    transmitter.exchangeMessageDone(this, true, true, null);
+  }
+
+  void trackFailure(IOException e) {
+    finder.trackFailure();
+    codec.connection().trackFailure(e);
+  }
+
+  @Nullable IOException bodyComplete(
+      long bytesRead, boolean responseDone, boolean requestDone, @Nullable IOException e) {
+    if (e != null) {
+      trackFailure(e);
+    }
+    if (requestDone) {
+      if (e != null) {
+        eventListener.requestFailed(call, e);
+      } else {
+        eventListener.requestBodyEnd(call, bytesRead);
+      }
+    }
+    if (responseDone) {
+      if (e != null) {
+        eventListener.responseFailed(call, e);
+      } else {
+        eventListener.responseBodyEnd(call, bytesRead);
+      }
+    }
+    return transmitter.exchangeMessageDone(this, requestDone, responseDone, e);
+  }
+
+  public void noRequestBody() {
+    transmitter.exchangeMessageDone(this, true, false, null);
+  }
+
+  /** A request body that fires events when it completes. */
+  private final class RequestBodySink extends ForwardingSink {
+    private boolean completed;
+    /** The exact number of bytes to be written, or -1L if that is unknown. */
+    private long contentLength;
+    private long bytesReceived;
+    private boolean closed;
+
+    RequestBodySink(Sink delegate, long contentLength) {
+      super(delegate);
+      this.contentLength = contentLength;
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      if (closed) throw new IllegalStateException("closed");
+      if (contentLength != -1L && bytesReceived + byteCount > contentLength) {
+        throw new ProtocolException("expected " + contentLength
+            + " bytes but received " + (bytesReceived + byteCount));
+      }
+      try {
+        super.write(source, byteCount);
+        this.bytesReceived += byteCount;
+      } catch (IOException e) {
+        throw complete(e);
+      }
+    }
+
+    @Override public void flush() throws IOException {
+      try {
+        super.flush();
+      } catch (IOException e) {
+        throw complete(e);
+      }
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      closed = true;
+      if (contentLength != -1L && bytesReceived != contentLength) {
+        throw new ProtocolException("unexpected end of stream");
+      }
+      try {
+        super.close();
+        complete(null);
+      } catch (IOException e) {
+        throw complete(e);
+      }
+    }
+
+    private @Nullable IOException complete(@Nullable IOException e) {
+      if (completed) return e;
+      completed = true;
+      return bodyComplete(bytesReceived, false, true, e);
+    }
+  }
+
+  /** A response body that fires events when it completes. */
+  final class ResponseBodySource extends ForwardingSource {
+    private final long contentLength;
+    private long bytesReceived;
+    private boolean completed;
+    private boolean closed;
+
+    ResponseBodySource(Source delegate, long contentLength) {
+      super(delegate);
+      this.contentLength = contentLength;
+
+      if (contentLength == 0L) {
+        complete(null);
+      }
+    }
+
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      if (closed) throw new IllegalStateException("closed");
+      try {
+        long read = delegate().read(sink, byteCount);
+        if (read == -1L) {
+          complete(null);
+          return -1L;
+        }
+
+        long newBytesReceived = bytesReceived + read;
+        if (contentLength != -1L && newBytesReceived > contentLength) {
+          throw new ProtocolException("expected " + contentLength
+              + " bytes but received " + newBytesReceived);
+        }
+
+        bytesReceived = newBytesReceived;
+        if (newBytesReceived == contentLength) {
+          complete(null);
+        }
+
+        return read;
+      } catch (IOException e) {
+        throw complete(e);
+      }
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      closed = true;
+      try {
+        super.close();
+        complete(null);
+      } catch (IOException e) {
+        throw complete(e);
+      }
+    }
+
+    @Nullable IOException complete(@Nullable IOException e) {
+      if (completed) return e;
+      completed = true;
+      return bodyComplete(bytesReceived, true, false, e);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.java b/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.java
new file mode 100644
index 0000000000..08c804d707
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ExchangeFinder.java
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.net.Socket;
+import java.util.List;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.EventListener;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Route;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.ExchangeCodec;
+
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * Attempts to find the connections for a sequence of exchanges. This uses the following strategies:
+ *
+ * <ol>
+ *   <li>If the current call already has a connection that can satisfy the request it is used.
+ *       Using the same connection for an initial exchange and its follow-ups may improve locality.
+ *
+ *   <li>If there is a connection in the pool that can satisfy the request it is used. Note that
+ *       it is possible for shared exchanges to make requests to different host names! See {@link
+ *       RealConnection#isEligible} for details.
+ *
+ *   <li>If there's no existing connection, make a list of routes (which may require blocking DNS
+ *       lookups) and attempt a new connection them. When failures occur, retries iterate the list
+ *       of available routes.
+ * </ol>
+ *
+ * <p>If the pool gains an eligible connection while DNS, TCP, or TLS work is in flight, this finder
+ * will prefer pooled connections. Only pooled HTTP/2 connections are used for such de-duplication.
+ *
+ * <p>It is possible to cancel the finding process.
+ */
+final class ExchangeFinder {
+  private final Transmitter transmitter;
+  private final Address address;
+  private final RealConnectionPool connectionPool;
+  private final Call call;
+  private final EventListener eventListener;
+
+  private RouteSelector.Selection routeSelection;
+
+  // State guarded by connectionPool.
+  private final RouteSelector routeSelector;
+  private RealConnection connectingConnection;
+  private boolean hasStreamFailure;
+
+  ExchangeFinder(Transmitter transmitter, RealConnectionPool connectionPool,
+      Address address, Call call, EventListener eventListener) {
+    this.transmitter = transmitter;
+    this.connectionPool = connectionPool;
+    this.address = address;
+    this.call = call;
+    this.eventListener = eventListener;
+    this.routeSelector = new RouteSelector(
+        address, connectionPool.routeDatabase, call, eventListener);
+  }
+
+  public ExchangeCodec find(
+      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
+    int connectTimeout = chain.connectTimeoutMillis();
+    int readTimeout = chain.readTimeoutMillis();
+    int writeTimeout = chain.writeTimeoutMillis();
+    int pingIntervalMillis = client.pingIntervalMillis();
+    boolean connectionRetryEnabled = client.retryOnConnectionFailure();
+
+    try {
+      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
+          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
+      return resultConnection.newCodec(client, chain);
+    } catch (RouteException e) {
+      trackFailure();
+      throw e;
+    } catch (IOException e) {
+      trackFailure();
+      throw new RouteException(e);
+    }
+  }
+
+  /**
+   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
+   * until a healthy connection is found.
+   */
+  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
+      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
+      boolean doExtensiveHealthChecks) throws IOException {
+    while (true) {
+      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
+          pingIntervalMillis, connectionRetryEnabled);
+
+      // If this is a brand new connection, we can skip the extensive health checks.
+      synchronized (connectionPool) {
+        if (candidate.successCount == 0) {
+          return candidate;
+        }
+      }
+
+      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
+      // isn't, take it out of the pool and start again.
+      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
+        candidate.noNewExchanges();
+        continue;
+      }
+
+      return candidate;
+    }
+  }
+
+  /**
+   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
+   * then the pool, finally building a new connection.
+   */
+  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
+      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
+    boolean foundPooledConnection = false;
+    RealConnection result = null;
+    Route selectedRoute = null;
+    RealConnection releasedConnection;
+    Socket toClose;
+    synchronized (connectionPool) {
+      if (transmitter.isCanceled()) throw new IOException("Canceled");
+      hasStreamFailure = false; // This is a fresh attempt.
+
+      Route previousRoute = retryCurrentRoute()
+          ? transmitter.connection.route()
+          : null;
+
+      // Attempt to use an already-allocated connection. We need to be careful here because our
+      // already-allocated connection may have been restricted from creating new exchanges.
+      releasedConnection = transmitter.connection;
+      toClose = transmitter.connection != null && transmitter.connection.noNewExchanges
+          ? transmitter.releaseConnectionNoEvents()
+          : null;
+
+      if (transmitter.connection != null) {
+        // We had an already-allocated connection and it's good.
+        result = transmitter.connection;
+        releasedConnection = null;
+      }
+
+      if (result == null) {
+        // Attempt to get a connection from the pool.
+        if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) {
+          foundPooledConnection = true;
+          result = transmitter.connection;
+        } else {
+          selectedRoute = previousRoute;
+        }
+      }
+    }
+    closeQuietly(toClose);
+
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result);
+    }
+    if (result != null) {
+      // If we found an already-allocated or pooled connection, we're done.
+      return result;
+    }
+
+    // If we need a route selection, make one. This is a blocking operation.
+    boolean newRouteSelection = false;
+    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
+      newRouteSelection = true;
+      routeSelection = routeSelector.next();
+    }
+
+    List<Route> routes = null;
+    synchronized (connectionPool) {
+      if (transmitter.isCanceled()) throw new IOException("Canceled");
+
+      if (newRouteSelection) {
+        // Now that we have a set of IP addresses, make another attempt at getting a connection from
+        // the pool. This could match due to connection coalescing.
+        routes = routeSelection.getAll();
+        if (connectionPool.transmitterAcquirePooledConnection(
+            address, transmitter, routes, false)) {
+          foundPooledConnection = true;
+          result = transmitter.connection;
+        }
+      }
+
+      if (!foundPooledConnection) {
+        if (selectedRoute == null) {
+          selectedRoute = routeSelection.next();
+        }
+
+        // Create a connection and assign it to this allocation immediately. This makes it possible
+        // for an asynchronous cancel() to interrupt the handshake we're about to do.
+        result = new RealConnection(connectionPool, selectedRoute);
+        connectingConnection = result;
+      }
+    }
+
+    // If we found a pooled connection on the 2nd time around, we're done.
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result);
+      return result;
+    }
+
+    // Do TCP + TLS handshakes. This is a blocking operation.
+    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
+        connectionRetryEnabled, call, eventListener);
+    connectionPool.routeDatabase.connected(result.route());
+
+    Socket socket = null;
+    synchronized (connectionPool) {
+      connectingConnection = null;
+      // Last attempt at connection coalescing, which only occurs if we attempted multiple
+      // concurrent connections to the same host.
+      if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) {
+        // We lost the race! Close the connection we created and return the pooled connection.
+        result.noNewExchanges = true;
+        socket = result.socket();
+        result = transmitter.connection;
+      } else {
+        connectionPool.put(result);
+        transmitter.acquireConnectionNoEvents(result);
+      }
+    }
+    closeQuietly(socket);
+
+    eventListener.connectionAcquired(call, result);
+    return result;
+  }
+
+  RealConnection connectingConnection() {
+    assert (Thread.holdsLock(connectionPool));
+    return connectingConnection;
+  }
+
+  void trackFailure() {
+    assert (!Thread.holdsLock(connectionPool));
+    synchronized (connectionPool) {
+      hasStreamFailure = true; // Permit retries.
+    }
+  }
+
+  boolean canRetry() {
+    synchronized (connectionPool) {
+      // Don't try if the failure wasn't our fault!
+      if (!hasStreamFailure) return false;
+
+      return retryCurrentRoute()
+          || (routeSelection != null && routeSelection.hasNext())
+          || routeSelector.hasNext();
+    }
+  }
+
+  /**
+   * Return true if the route used for the current connection should be retried, even if the
+   * connection itself is unhealthy. The biggest gotcha here is that we shouldn't reuse routes from
+   * coalesced connections.
+   */
+  private boolean retryCurrentRoute() {
+    return transmitter.connection != null
+        && transmitter.connection.routeFailureCount == 0
+        && Util.sameConnection(transmitter.connection.route().address().url(), address.url());
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index 2531896b01..72bd8d6b12 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -19,16 +19,17 @@
 import java.io.IOException;
 import java.lang.ref.Reference;
 import java.net.ConnectException;
+import java.net.HttpURLConnection;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.Socket;
 import java.net.SocketException;
 import java.net.SocketTimeoutException;
 import java.net.UnknownServiceException;
+import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.concurrent.TimeUnit;
 import javax.annotation.Nullable;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSession;
@@ -38,7 +39,6 @@
 import okhttp3.Call;
 import okhttp3.CertificatePinner;
 import okhttp3.Connection;
-import okhttp3.ConnectionPool;
 import okhttp3.ConnectionSpec;
 import okhttp3.EventListener;
 import okhttp3.Handshake;
@@ -52,20 +52,20 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
-import okhttp3.internal.http.HttpCodec;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http1.Http1Codec;
+import okhttp3.internal.http.ExchangeCodec;
+import okhttp3.internal.http1.Http1ExchangeCodec;
+import okhttp3.internal.http2.ConnectionShutdownException;
 import okhttp3.internal.http2.ErrorCode;
-import okhttp3.internal.http2.Http2Codec;
 import okhttp3.internal.http2.Http2Connection;
+import okhttp3.internal.http2.Http2ExchangeCodec;
 import okhttp3.internal.http2.Http2Stream;
+import okhttp3.internal.http2.StreamResetException;
 import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.OkHostnameVerifier;
 import okhttp3.internal.ws.RealWebSocket;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.Okio;
-import okio.Source;
 
 import static java.net.HttpURLConnection.HTTP_OK;
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
@@ -76,7 +76,7 @@
   private static final String NPE_THROW_WITH_NULL = "throw with null exception";
   private static final int MAX_TUNNEL_ATTEMPTS = 21;
 
-  private final ConnectionPool connectionPool;
+  public final RealConnectionPool connectionPool;
   private final Route route;
 
   // The fields below are initialized by connect() and never reassigned.
@@ -97,30 +97,48 @@
 
   // The fields below track connection state and are guarded by connectionPool.
 
-  /** If true, no new streams can be created on this connection. Once true this is always true. */
-  public boolean noNewStreams;
+  /**
+   * If true, no new exchanges can be created on this connection. Once true this is always true.
+   * Guarded by {@link #connectionPool}.
+   */
+  boolean noNewExchanges;
+
+  /**
+   * The number of times there was a problem establishing a stream that could be due to route
+   * chosen. Guarded by {@link #connectionPool}.
+   */
+  int routeFailureCount;
 
-  public int successCount;
+  int successCount;
+  private int refusedStreamCount;
 
   /**
    * The maximum number of concurrent streams that can be carried by this connection. If {@code
    * allocations.size() < allocationLimit} then new streams can be created on this connection.
    */
-  public int allocationLimit = 1;
+  private int allocationLimit = 1;
 
-  /** Current streams carried by this connection. */
-  public final List<Reference<StreamAllocation>> allocations = new ArrayList<>();
+  /** Current calls carried by this connection. */
+  final List<Reference<Transmitter>> transmitters = new ArrayList<>();
 
   /** Nanotime timestamp when {@code allocations.size()} reached zero. */
-  public long idleAtNanos = Long.MAX_VALUE;
+  long idleAtNanos = Long.MAX_VALUE;
 
-  public RealConnection(ConnectionPool connectionPool, Route route) {
+  public RealConnection(RealConnectionPool connectionPool, Route route) {
     this.connectionPool = connectionPool;
     this.route = route;
   }
 
-  public static RealConnection testConnection(
-      ConnectionPool connectionPool, Route route, Socket socket, long idleAtNanos) {
+  /** Prevent further exchanges from being created on this connection. */
+  public void noNewExchanges() {
+    assert (!Thread.holdsLock(connectionPool));
+    synchronized (connectionPool) {
+      noNewExchanges = true;
+    }
+  }
+
+  static RealConnection testConnection(
+      RealConnectionPool connectionPool, Route route, Socket socket, long idleAtNanos) {
     RealConnection result = new RealConnection(connectionPool, route);
     result.socket = socket;
     result.idleAtNanos = idleAtNanos;
@@ -146,6 +164,11 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
         throw new RouteException(new UnknownServiceException(
             "CLEARTEXT communication to " + host + " not permitted by network security policy"));
       }
+    } else {
+      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
+        throw new RouteException(new UnknownServiceException(
+            "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS"));
+      }
     }
 
     while (true) {
@@ -261,9 +284,9 @@ private void connectSocket(int connectTimeout, int readTimeout, Call call,
   private void establishProtocol(ConnectionSpecSelector connectionSpecSelector,
       int pingIntervalMillis, Call call, EventListener eventListener) throws IOException {
     if (route.address().sslSocketFactory() == null) {
-      if (route.address().protocols().contains(Protocol.H2C)) {
+      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
         socket = rawSocket;
-        protocol = Protocol.H2C;
+        protocol = Protocol.H2_PRIOR_KNOWLEDGE;
         startHttp2(pingIntervalMillis);
         return;
       }
@@ -313,18 +336,22 @@ private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IO
       sslSocket.startHandshake();
       // block for session establishment
       SSLSession sslSocketSession = sslSocket.getSession();
-      if (!isValid(sslSocketSession)) {
-        throw new IOException("a valid ssl session was not established");
-      }
       Handshake unverifiedHandshake = Handshake.get(sslSocketSession);
 
       // Verify that the socket's certificates are acceptable for the target host.
       if (!address.hostnameVerifier().verify(address.url().host(), sslSocketSession)) {
-        X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0);
-        throw new SSLPeerUnverifiedException("Hostname " + address.url().host() + " not verified:"
-            + "\n    certificate: " + CertificatePinner.pin(cert)
-            + "\n    DN: " + cert.getSubjectDN().getName()
-            + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
+        List<Certificate> peerCertificates = unverifiedHandshake.peerCertificates();
+        if (!peerCertificates.isEmpty()) {
+          X509Certificate cert = (X509Certificate) peerCertificates.get(0);
+          throw new SSLPeerUnverifiedException(
+              "Hostname " + address.url().host() + " not verified:"
+                  + "\n    certificate: " + CertificatePinner.pin(cert)
+                  + "\n    DN: " + cert.getSubjectDN().getName()
+                  + "\n    subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert));
+        } else {
+          throw new SSLPeerUnverifiedException(
+              "Hostname " + address.url().host() + " not verified (no certificates)");
+        }
       }
 
       // Check that the certificate pinner is satisfied by the certificates presented.
@@ -356,12 +383,6 @@ private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IO
     }
   }
 
-  private boolean isValid(SSLSession sslSocketSession) {
-    // don't use SslSocket.getSession since for failed results it returns SSL_NULL_WITH_NULL_NULL
-    return !"NONE".equals(sslSocketSession.getProtocol()) && !"SSL_NULL_WITH_NULL_NULL".equals(
-        sslSocketSession.getCipherSuite());
-  }
-
   /**
    * To make an HTTPS connection over an HTTP proxy, send an unencrypted CONNECT request to create
    * the proxy connection. This may need to be retried if the proxy requires authorization.
@@ -371,23 +392,15 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
     // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.
     String requestLine = "CONNECT " + Util.hostHeader(url, true) + " HTTP/1.1";
     while (true) {
-      Http1Codec tunnelConnection = new Http1Codec(null, null, source, sink);
+      Http1ExchangeCodec tunnelCodec = new Http1ExchangeCodec(null, null, source, sink);
       source.timeout().timeout(readTimeout, MILLISECONDS);
       sink.timeout().timeout(writeTimeout, MILLISECONDS);
-      tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);
-      tunnelConnection.finishRequest();
-      Response response = tunnelConnection.readResponseHeaders(false)
+      tunnelCodec.writeRequest(tunnelRequest.headers(), requestLine);
+      tunnelCodec.finishRequest();
+      Response response = tunnelCodec.readResponseHeaders(false)
           .request(tunnelRequest)
           .build();
-      // The response body from a CONNECT should be empty, but if it is not then we should consume
-      // it before proceeding.
-      long contentLength = HttpHeaders.contentLength(response);
-      if (contentLength == -1L) {
-        contentLength = 0L;
-      }
-      Source body = tunnelConnection.newFixedLengthSource(contentLength);
-      Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
-      body.close();
+      tunnelCodec.skipConnectBody(response);
 
       switch (response.code()) {
         case HTTP_OK:
@@ -395,7 +408,7 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
           // that happens, then we will have buffered bytes that are needed by the SSLSocket!
           // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
           // that it will almost certainly fail because the proxy has sent unexpected data.
-          if (!source.buffer().exhausted() || !sink.buffer().exhausted()) {
+          if (!source.getBuffer().exhausted() || !sink.buffer().exhausted()) {
             throw new IOException("TLS tunnel buffered too many bytes!");
           }
           return null;
@@ -420,23 +433,46 @@ private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRe
    * Returns a request that creates a TLS tunnel via an HTTP proxy. Everything in the tunnel request
    * is sent unencrypted to the proxy server, so tunnels include only the minimum set of headers.
    * This avoids sending potentially sensitive data like HTTP cookies to the proxy unencrypted.
+   *
+   * <p>In order to support preemptive authentication we pass a fake ‚ÄúAuth Failed‚Äù response to the
+   * authenticator. This gives the authenticator the option to customize the CONNECT request. It can
+   * decline to do so by returning null, in which case OkHttp will use it as-is
    */
-  private Request createTunnelRequest() {
-    return new Request.Builder()
+  private Request createTunnelRequest() throws IOException {
+    Request proxyConnectRequest = new Request.Builder()
         .url(route.address().url())
+        .method("CONNECT", null)
         .header("Host", Util.hostHeader(route.address().url(), true))
         .header("Proxy-Connection", "Keep-Alive") // For HTTP/1.0 proxies like Squid.
         .header("User-Agent", Version.userAgent())
         .build();
+
+    Response fakeAuthChallengeResponse = new Response.Builder()
+        .request(proxyConnectRequest)
+        .protocol(Protocol.HTTP_1_1)
+        .code(HttpURLConnection.HTTP_PROXY_AUTH)
+        .message("Preemptive Authenticate")
+        .body(Util.EMPTY_RESPONSE)
+        .sentRequestAtMillis(-1L)
+        .receivedResponseAtMillis(-1L)
+        .header("Proxy-Authenticate", "OkHttp-Preemptive")
+        .build();
+
+    Request authenticatedRequest = route.address().proxyAuthenticator()
+        .authenticate(route, fakeAuthChallengeResponse);
+
+    return authenticatedRequest != null
+        ? authenticatedRequest
+        : proxyConnectRequest;
   }
 
   /**
    * Returns true if this connection can carry a stream allocation to {@code address}. If non-null
    * {@code route} is the resolved route for a connection.
    */
-  public boolean isEligible(Address address, @Nullable Route route) {
-    // If this connection is not accepting new streams, we're done.
-    if (allocations.size() >= allocationLimit || noNewStreams) return false;
+  boolean isEligible(Address address, @Nullable List<Route> routes) {
+    // If this connection is not accepting new exchanges, we're done.
+    if (transmitters.size() >= allocationLimit || noNewExchanges) return false;
 
     // If the non-host fields of the address don't overlap, we're done.
     if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false;
@@ -454,16 +490,11 @@ public boolean isEligible(Address address, @Nullable Route route) {
     // 1. This connection must be HTTP/2.
     if (http2Connection == null) return false;
 
-    // 2. The routes must share an IP address. This requires us to have a DNS address for both
-    // hosts, which only happens after route planning. We can't coalesce connections that use a
-    // proxy, since proxies don't tell us the origin server's IP address.
-    if (route == null) return false;
-    if (route.proxy().type() != Proxy.Type.DIRECT) return false;
-    if (this.route.proxy().type() != Proxy.Type.DIRECT) return false;
-    if (!this.route.socketAddress().equals(route.socketAddress())) return false;
+    // 2. The routes must share an IP address.
+    if (routes == null || !routeMatchesAny(routes)) return false;
 
     // 3. This connection's server certificate's must cover the new host.
-    if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;
+    if (address.hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;
     if (!supportsUrl(address.url())) return false;
 
     // 4. Certificate pinning must match the host.
@@ -476,6 +507,24 @@ public boolean isEligible(Address address, @Nullable Route route) {
     return true; // The caller's address can be carried by this connection.
   }
 
+  /**
+   * Returns true if this connection's route has the same address as any of {@code routes}. This
+   * requires us to have a DNS address for both hosts, which only happens after route planning. We
+   * can't coalesce connections that use a proxy, since proxies don't tell us the origin server's IP
+   * address.
+   */
+  private boolean routeMatchesAny(List<Route> candidates) {
+    for (int i = 0, size = candidates.size(); i < size; i++) {
+      Route candidate = candidates.get(i);
+      if (candidate.proxy().type() == Proxy.Type.DIRECT
+          && route.proxy().type() == Proxy.Type.DIRECT
+          && route.socketAddress().equals(candidate.socketAddress())) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   public boolean supportsUrl(HttpUrl url) {
     if (url.port() != route.address().url().port()) {
       return false; // Port mismatch.
@@ -490,22 +539,23 @@ public boolean supportsUrl(HttpUrl url) {
     return true; // Success. The URL is supported.
   }
 
-  public HttpCodec newCodec(OkHttpClient client, Interceptor.Chain chain,
-      StreamAllocation streamAllocation) throws SocketException {
+  ExchangeCodec newCodec(OkHttpClient client, Interceptor.Chain chain) throws SocketException {
     if (http2Connection != null) {
-      return new Http2Codec(client, chain, streamAllocation, http2Connection);
+      return new Http2ExchangeCodec(client, this, chain, http2Connection);
     } else {
       socket.setSoTimeout(chain.readTimeoutMillis());
       source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);
       sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);
-      return new Http1Codec(client, streamAllocation, source, sink);
+      return new Http1ExchangeCodec(client, this, source, sink);
     }
   }
 
-  public RealWebSocket.Streams newWebSocketStreams(final StreamAllocation streamAllocation) {
+  RealWebSocket.Streams newWebSocketStreams(Exchange exchange) throws SocketException {
+    socket.setSoTimeout(0);
+    noNewExchanges();
     return new RealWebSocket.Streams(true, source, sink) {
       @Override public void close() throws IOException {
-        streamAllocation.streamFinished(true, streamAllocation.codec(), -1L, null);
+        exchange.bodyComplete(-1L, true, true, null);
       }
     };
   }
@@ -557,7 +607,7 @@ public boolean isHealthy(boolean doExtensiveChecks) {
 
   /** Refuse incoming streams. */
   @Override public void onStream(Http2Stream stream) throws IOException {
-    stream.close(ErrorCode.REFUSED_STREAM);
+    stream.close(ErrorCode.REFUSED_STREAM, null);
   }
 
   /** When settings are received, adjust the allocation limit. */
@@ -579,6 +629,41 @@ public boolean isMultiplexed() {
     return http2Connection != null;
   }
 
+  /**
+   * Track a failure using this connection. This may prevent both the connection and its route from
+   * being used for future exchanges.
+   */
+  void trackFailure(@Nullable IOException e) {
+    assert (!Thread.holdsLock(connectionPool));
+    synchronized (connectionPool) {
+      if (e instanceof StreamResetException) {
+        ErrorCode errorCode = ((StreamResetException) e).errorCode;
+        if (errorCode == ErrorCode.REFUSED_STREAM) {
+          // Retry REFUSED_STREAM errors once on the same connection.
+          refusedStreamCount++;
+          if (refusedStreamCount > 1) {
+            noNewExchanges = true;
+            routeFailureCount++;
+          }
+        } else if (errorCode != ErrorCode.CANCEL) {
+          // Keep the connection for CANCEL errors. Everything else wants a fresh connection.
+          noNewExchanges = true;
+          routeFailureCount++;
+        }
+      } else if (!isMultiplexed() || e instanceof ConnectionShutdownException) {
+        noNewExchanges = true;
+
+        // If this route hasn't completed a call, avoid it for new connections.
+        if (successCount == 0) {
+          if (e != null) {
+            connectionPool.connectFailed(route, e);
+          }
+          routeFailureCount++;
+        }
+      }
+    }
+  }
+
   @Override public Protocol protocol() {
     return protocol;
   }
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.java
similarity index 63%
rename from okhttp/src/main/java/okhttp3/ConnectionPool.java
rename to okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.java
index 605f275661..366bc09f73 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnectionPool.java
@@ -14,10 +14,11 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package okhttp3;
+package okhttp3.internal.connection;
 
+import java.io.IOException;
 import java.lang.ref.Reference;
-import java.net.Socket;
+import java.net.Proxy;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Deque;
@@ -28,20 +29,15 @@
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import javax.annotation.Nullable;
+import okhttp3.Address;
+import okhttp3.Route;
 import okhttp3.internal.Util;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.connection.RouteDatabase;
-import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.connection.Transmitter.TransmitterReference;
 import okhttp3.internal.platform.Platform;
 
 import static okhttp3.internal.Util.closeQuietly;
 
-/**
- * Manages reuse of HTTP and HTTP/2 connections for reduced network latency. HTTP requests that
- * share the same {@link Address} may share a {@link Connection}. This class implements the policy
- * of which connections to keep open for future use.
- */
-public final class ConnectionPool {
+public final class RealConnectionPool {
   /**
    * Background threads are used to cleanup expired connections. There will be at most a single
    * thread running per connection pool. The thread pool executor permits the pool itself to be
@@ -49,24 +45,22 @@
    */
   private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,
       Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,
-      new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp ConnectionPool", true));
+      new SynchronousQueue<>(), Util.threadFactory("OkHttp ConnectionPool", true));
 
   /** The maximum number of idle connections for each address. */
   private final int maxIdleConnections;
   private final long keepAliveDurationNs;
-  private final Runnable cleanupRunnable = new Runnable() {
-    @Override public void run() {
-      while (true) {
-        long waitNanos = cleanup(System.nanoTime());
-        if (waitNanos == -1) return;
-        if (waitNanos > 0) {
-          long waitMillis = waitNanos / 1000000L;
-          waitNanos -= (waitMillis * 1000000L);
-          synchronized (ConnectionPool.this) {
-            try {
-              ConnectionPool.this.wait(waitMillis, (int) waitNanos);
-            } catch (InterruptedException ignored) {
-            }
+  private final Runnable cleanupRunnable = () -> {
+    while (true) {
+      long waitNanos = cleanup(System.nanoTime());
+      if (waitNanos == -1) return;
+      if (waitNanos > 0) {
+        long waitMillis = waitNanos / 1000000L;
+        waitNanos -= (waitMillis * 1000000L);
+        synchronized (RealConnectionPool.this) {
+          try {
+            RealConnectionPool.this.wait(waitMillis, (int) waitNanos);
+          } catch (InterruptedException ignored) {
           }
         }
       }
@@ -77,16 +71,7 @@
   final RouteDatabase routeDatabase = new RouteDatabase();
   boolean cleanupRunning;
 
-  /**
-   * Create a new connection pool with tuning parameters appropriate for a single-user application.
-   * The tuning parameters in this pool are subject to change in future OkHttp releases. Currently
-   * this pool holds up to 5 idle connections which will be evicted after 5 minutes of inactivity.
-   */
-  public ConnectionPool() {
-    this(5, 5, TimeUnit.MINUTES);
-  }
-
-  public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) {
+  public RealConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit timeUnit) {
     this.maxIdleConnections = maxIdleConnections;
     this.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);
 
@@ -96,54 +81,36 @@ public ConnectionPool(int maxIdleConnections, long keepAliveDuration, TimeUnit t
     }
   }
 
-  /** Returns the number of idle connections in the pool. */
   public synchronized int idleConnectionCount() {
     int total = 0;
     for (RealConnection connection : connections) {
-      if (connection.allocations.isEmpty()) total++;
+      if (connection.transmitters.isEmpty()) total++;
     }
     return total;
   }
 
-  /**
-   * Returns total number of connections in the pool. Note that prior to OkHttp 2.7 this included
-   * only idle connections and HTTP/2 connections. Since OkHttp 2.7 this includes all connections,
-   * both active and inactive. Use {@link #idleConnectionCount()} to count connections not currently
-   * in use.
-   */
   public synchronized int connectionCount() {
     return connections.size();
   }
 
   /**
-   * Returns a recycled connection to {@code address}, or null if no such connection exists. The
-   * route is null if the address has not yet been routed.
-   */
-  @Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {
-    assert (Thread.holdsLock(this));
-    for (RealConnection connection : connections) {
-      if (connection.isEligible(address, route)) {
-        streamAllocation.acquire(connection, true);
-        return connection;
-      }
-    }
-    return null;
-  }
-
-  /**
-   * Replaces the connection held by {@code streamAllocation} with a shared connection if possible.
-   * This recovers when multiple multiplexed connections are created concurrently.
+   * Attempts to acquire a recycled connection to {@code address} for {@code transmitter}. Returns
+   * true if a connection was acquired.
+   *
+   * <p>If {@code routes} is non-null these are the resolved routes (ie. IP addresses) for the
+   * connection. This is used to coalesce related domains to the same HTTP/2 connection, such as
+   * {@code square.com} and {@code square.ca}.
    */
-  @Nullable Socket deduplicate(Address address, StreamAllocation streamAllocation) {
+  boolean transmitterAcquirePooledConnection(Address address, Transmitter transmitter,
+      @Nullable List<Route> routes, boolean requireMultiplexed) {
     assert (Thread.holdsLock(this));
     for (RealConnection connection : connections) {
-      if (connection.isEligible(address, null)
-          && connection.isMultiplexed()
-          && connection != streamAllocation.connection()) {
-        return streamAllocation.releaseAndAcquire(connection);
-      }
+      if (requireMultiplexed && !connection.isMultiplexed()) continue;
+      if (!connection.isEligible(address, routes)) continue;
+      transmitter.acquireConnectionNoEvents(connection);
+      return true;
     }
-    return null;
+    return false;
   }
 
   void put(RealConnection connection) {
@@ -161,7 +128,7 @@ void put(RealConnection connection) {
    */
   boolean connectionBecameIdle(RealConnection connection) {
     assert (Thread.holdsLock(this));
-    if (connection.noNewStreams || maxIdleConnections == 0) {
+    if (connection.noNewExchanges || maxIdleConnections == 0) {
       connections.remove(connection);
       return true;
     } else {
@@ -170,14 +137,13 @@ boolean connectionBecameIdle(RealConnection connection) {
     }
   }
 
-  /** Close and remove all idle connections in the pool. */
   public void evictAll() {
     List<RealConnection> evictedConnections = new ArrayList<>();
     synchronized (this) {
       for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {
         RealConnection connection = i.next();
-        if (connection.allocations.isEmpty()) {
-          connection.noNewStreams = true;
+        if (connection.transmitters.isEmpty()) {
+          connection.noNewExchanges = true;
           evictedConnections.add(connection);
           i.remove();
         }
@@ -248,30 +214,29 @@ long cleanup(long now) {
   }
 
   /**
-   * Prunes any leaked allocations and then returns the number of remaining live allocations on
-   * {@code connection}. Allocations are leaked if the connection is tracking them but the
+   * Prunes any leaked transmitters and then returns the number of remaining live transmitters on
+   * {@code connection}. Transmitters are leaked if the connection is tracking them but the
    * application code has abandoned them. Leak detection is imprecise and relies on garbage
    * collection.
    */
   private int pruneAndGetAllocationCount(RealConnection connection, long now) {
-    List<Reference<StreamAllocation>> references = connection.allocations;
+    List<Reference<Transmitter>> references = connection.transmitters;
     for (int i = 0; i < references.size(); ) {
-      Reference<StreamAllocation> reference = references.get(i);
+      Reference<Transmitter> reference = references.get(i);
 
       if (reference.get() != null) {
         i++;
         continue;
       }
 
-      // We've discovered a leaked allocation. This is an application bug.
-      StreamAllocation.StreamAllocationReference streamAllocRef =
-          (StreamAllocation.StreamAllocationReference) reference;
+      // We've discovered a leaked transmitter. This is an application bug.
+      TransmitterReference transmitterRef = (TransmitterReference) reference;
       String message = "A connection to " + connection.route().address().url()
           + " was leaked. Did you forget to close a response body?";
-      Platform.get().logCloseableLeak(message, streamAllocRef.callStackTrace);
+      Platform.get().logCloseableLeak(message, transmitterRef.callStackTrace);
 
       references.remove(i);
-      connection.noNewStreams = true;
+      connection.noNewExchanges = true;
 
       // If this was the last allocation, the connection is eligible for immediate eviction.
       if (references.isEmpty()) {
@@ -282,4 +247,16 @@ private int pruneAndGetAllocationCount(RealConnection connection, long now) {
 
     return references.size();
   }
+
+  /** Track a bad route in the route database. Other routes will be attempted first. */
+  public void connectFailed(Route failedRoute, IOException failure) {
+    // Tell the proxy selector when we fail to connect on a fresh connection.
+    if (failedRoute.proxy().type() != Proxy.Type.DIRECT) {
+      Address address = failedRoute.address();
+      address.proxySelector().connectFailed(
+          address.url().uri(), failedRoute.proxy().address(), failure);
+    }
+
+    routeDatabase.failed(failedRoute);
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.kt
similarity index 57%
rename from okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
rename to okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.kt
index d0c1a9d79e..de36fc97b4 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.kt
@@ -13,11 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.connection;
+package okhttp3.internal.connection
 
-import java.util.LinkedHashSet;
-import java.util.Set;
-import okhttp3.Route;
+import okhttp3.Route
 
 /**
  * A blacklist of failed routes to avoid when creating a new connection to a target address. This is
@@ -25,21 +23,19 @@
  * a specific IP address or proxy server, that failure is remembered and alternate routes are
  * preferred.
  */
-public final class RouteDatabase {
-  private final Set<Route> failedRoutes = new LinkedHashSet<>();
+class RouteDatabase {
+  private val failedRoutes = mutableSetOf<Route>()
 
-  /** Records a failure connecting to {@code failedRoute}. */
-  public synchronized void failed(Route failedRoute) {
-    failedRoutes.add(failedRoute);
+  /** Records a failure connecting to [failedRoute]. */
+  @Synchronized fun failed(failedRoute: Route) {
+    failedRoutes.add(failedRoute)
   }
 
-  /** Records success connecting to {@code route}. */
-  public synchronized void connected(Route route) {
-    failedRoutes.remove(route);
+  /** Records success connecting to [route]. */
+  @Synchronized fun connected(route: Route) {
+    failedRoutes.remove(route)
   }
 
-  /** Returns true if {@code route} has failed recently and should be avoided. */
-  public synchronized boolean shouldPostpone(Route route) {
-    return failedRoutes.contains(route);
-  }
+  /** Returns true if [route] has failed recently and should be avoided. */
+  @Synchronized fun shouldPostpone(route: Route): Boolean = failedRoutes.contains(route)
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
deleted file mode 100644
index 5f50576611..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
-/**
- * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
- * have been made with alternative protocols, none of which were successful.
- */
-public final class RouteException extends RuntimeException {
-  private static final Method addSuppressedExceptionMethod;
-
-  static {
-    Method m;
-    try {
-      m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
-    } catch (Exception e) {
-      m = null;
-    }
-    addSuppressedExceptionMethod = m;
-  }
-
-  private IOException lastException;
-
-  public RouteException(IOException cause) {
-    super(cause);
-    lastException = cause;
-  }
-
-  public IOException getLastConnectException() {
-    return lastException;
-  }
-
-  public void addConnectException(IOException e) {
-    addSuppressedIfPossible(e, lastException);
-    lastException = e;
-  }
-
-  private void addSuppressedIfPossible(IOException e, IOException suppressed) {
-    if (addSuppressedExceptionMethod != null) {
-      try {
-        addSuppressedExceptionMethod.invoke(e, suppressed);
-      } catch (InvocationTargetException | IllegalAccessException ignored) {
-      }
-    }
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.kt
similarity index 51%
rename from okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java
rename to okhttp/src/main/java/okhttp3/internal/connection/RouteException.kt
index 3b077f8bc4..7859d8bd2b 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/URLFilter.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Square, Inc.
+ * Copyright (C) 2015 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,20 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.connection
+
 import java.io.IOException;
-import java.net.URL;
 
 /**
- * Request filter based on the request's URL.
- *
- * @deprecated use {@link okhttp3.Interceptor} for non-HttpURLConnection filtering.
+ * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
+ * have been made with alternative protocols, none of which were successful.
  */
-public interface URLFilter {
-  /**
-   * Check whether request to the provided URL is permitted to be issued.
-   *
-   * @throws IOException if the request to the provided URL is not permitted.
-   */
-  void checkURLPermitted(URL url) throws IOException;
+class RouteException internal constructor(val firstConnectException: IOException) :
+    RuntimeException(firstConnectException) {
+  var lastConnectException: IOException = firstConnectException
+    private set
+
+  fun addConnectException(e: IOException) {
+    firstConnectException.addSuppressed(e)
+    lastConnectException = e
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
index 40752ce23d..dde5cafc4d 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
@@ -37,7 +37,7 @@
  * Selects routes to connect to an origin server. Each connection requires a choice of proxy server,
  * IP address, and TLS mode. Connections may also be recycled.
  */
-public final class RouteSelector {
+final class RouteSelector {
   private final Address address;
   private final RouteDatabase routeDatabase;
   private final Call call;
@@ -53,7 +53,7 @@
   /* State for negotiating failed routes */
   private final List<Route> postponedRoutes = new ArrayList<>();
 
-  public RouteSelector(Address address, RouteDatabase routeDatabase, Call call,
+  RouteSelector(Address address, RouteDatabase routeDatabase, Call call,
       EventListener eventListener) {
     this.address = address;
     this.routeDatabase = routeDatabase;
@@ -105,20 +105,6 @@ public Selection next() throws IOException {
     return new Selection(routes);
   }
 
-  /**
-   * Clients should invoke this method when they encounter a connectivity failure on a connection
-   * returned by this route selector.
-   */
-  public void connectFailed(Route failedRoute, IOException failure) {
-    if (failedRoute.proxy().type() != Proxy.Type.DIRECT && address.proxySelector() != null) {
-      // Tell the proxy selector when we fail to connect on a fresh connection.
-      address.proxySelector().connectFailed(
-          address.url().uri(), failedRoute.proxy().address(), failure);
-    }
-
-    routeDatabase.failed(failedRoute);
-  }
-
   /** Prepares the proxy servers to try. */
   private void resetNextProxy(HttpUrl url, Proxy proxy) {
     if (proxy != null) {
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
deleted file mode 100644
index e6025fd8b2..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ /dev/null
@@ -1,534 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.lang.ref.Reference;
-import java.lang.ref.WeakReference;
-import java.net.Socket;
-import java.util.List;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.Connection;
-import okhttp3.ConnectionPool;
-import okhttp3.EventListener;
-import okhttp3.Interceptor;
-import okhttp3.OkHttpClient;
-import okhttp3.Route;
-import okhttp3.internal.Internal;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpCodec;
-import okhttp3.internal.http2.ConnectionShutdownException;
-import okhttp3.internal.http2.ErrorCode;
-import okhttp3.internal.http2.StreamResetException;
-
-import static okhttp3.internal.Util.closeQuietly;
-
-/**
- * This class coordinates the relationship between three entities:
- *
- * <ul>
- *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are
- *         potentially slow to establish so it is necessary to be able to cancel a connection
- *         currently being connected.
- *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on
- *         connections. Each connection has its own allocation limit, which defines how many
- *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream
- *         at a time, HTTP/2 typically carry multiple.
- *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and
- *         its follow up requests. We prefer to keep all streams of a single call on the same
- *         connection for better behavior and locality.
- * </ul>
- *
- * <p>Instances of this class act on behalf of the call, using one or more streams over one or more
- * connections. This class has APIs to release each of the above resources:
- *
- * <ul>
- *     <li>{@link #noNewStreams()} prevents the connection from being used for new streams in the
- *         future. Use this after a {@code Connection: close} header, or when the connection may be
- *         inconsistent.
- *     <li>{@link #streamFinished streamFinished()} releases the active stream from this allocation.
- *         Note that only one stream may be active at a given time, so it is necessary to call
- *         {@link #streamFinished streamFinished()} before creating a subsequent stream with {@link
- *         #newStream newStream()}.
- *     <li>{@link #release()} removes the call's hold on the connection. Note that this won't
- *         immediately free the connection if there is a stream still lingering. That happens when a
- *         call is complete but its response body has yet to be fully consumed.
- * </ul>
- *
- * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
- * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
- * but not the other streams sharing its connection. But if the TLS handshake is still in progress
- * then canceling may break the entire connection.
- */
-public final class StreamAllocation {
-  public final Address address;
-  private RouteSelector.Selection routeSelection;
-  private Route route;
-  private final ConnectionPool connectionPool;
-  public final Call call;
-  public final EventListener eventListener;
-  private final Object callStackTrace;
-
-  // State guarded by connectionPool.
-  private final RouteSelector routeSelector;
-  private int refusedStreamCount;
-  private RealConnection connection;
-  private boolean reportedAcquired;
-  private boolean released;
-  private boolean canceled;
-  private HttpCodec codec;
-
-  public StreamAllocation(ConnectionPool connectionPool, Address address, Call call,
-      EventListener eventListener, Object callStackTrace) {
-    this.connectionPool = connectionPool;
-    this.address = address;
-    this.call = call;
-    this.eventListener = eventListener;
-    this.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener);
-    this.callStackTrace = callStackTrace;
-  }
-
-  public HttpCodec newStream(
-      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
-    int connectTimeout = chain.connectTimeoutMillis();
-    int readTimeout = chain.readTimeoutMillis();
-    int writeTimeout = chain.writeTimeoutMillis();
-    int pingIntervalMillis = client.pingIntervalMillis();
-    boolean connectionRetryEnabled = client.retryOnConnectionFailure();
-
-    try {
-      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
-          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
-      HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);
-
-      synchronized (connectionPool) {
-        codec = resultCodec;
-        return resultCodec;
-      }
-    } catch (IOException e) {
-      throw new RouteException(e);
-    }
-  }
-
-  /**
-   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated
-   * until a healthy connection is found.
-   */
-  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
-      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
-      boolean doExtensiveHealthChecks) throws IOException {
-    while (true) {
-      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
-          pingIntervalMillis, connectionRetryEnabled);
-
-      // If this is a brand new connection, we can skip the extensive health checks.
-      synchronized (connectionPool) {
-        if (candidate.successCount == 0) {
-          return candidate;
-        }
-      }
-
-      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it
-      // isn't, take it out of the pool and start again.
-      if (!candidate.isHealthy(doExtensiveHealthChecks)) {
-        noNewStreams();
-        continue;
-      }
-
-      return candidate;
-    }
-  }
-
-  /**
-   * Returns a connection to host a new stream. This prefers the existing connection if it exists,
-   * then the pool, finally building a new connection.
-   */
-  private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
-    boolean foundPooledConnection = false;
-    RealConnection result = null;
-    Route selectedRoute = null;
-    Connection releasedConnection;
-    Socket toClose;
-    synchronized (connectionPool) {
-      if (released) throw new IllegalStateException("released");
-      if (codec != null) throw new IllegalStateException("codec != null");
-      if (canceled) throw new IOException("Canceled");
-
-      // Attempt to use an already-allocated connection. We need to be careful here because our
-      // already-allocated connection may have been restricted from creating new streams.
-      releasedConnection = this.connection;
-      toClose = releaseIfNoNewStreams();
-      if (this.connection != null) {
-        // We had an already-allocated connection and it's good.
-        result = this.connection;
-        releasedConnection = null;
-      }
-      if (!reportedAcquired) {
-        // If the connection was never reported acquired, don't report it as released!
-        releasedConnection = null;
-      }
-
-      if (result == null) {
-        // Attempt to get a connection from the pool.
-        Internal.instance.get(connectionPool, address, this, null);
-        if (connection != null) {
-          foundPooledConnection = true;
-          result = connection;
-        } else {
-          selectedRoute = route;
-        }
-      }
-    }
-    closeQuietly(toClose);
-
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-    if (foundPooledConnection) {
-      eventListener.connectionAcquired(call, result);
-    }
-    if (result != null) {
-      // If we found an already-allocated or pooled connection, we're done.
-      return result;
-    }
-
-    // If we need a route selection, make one. This is a blocking operation.
-    boolean newRouteSelection = false;
-    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
-      newRouteSelection = true;
-      routeSelection = routeSelector.next();
-    }
-
-    synchronized (connectionPool) {
-      if (canceled) throw new IOException("Canceled");
-
-      if (newRouteSelection) {
-        // Now that we have a set of IP addresses, make another attempt at getting a connection from
-        // the pool. This could match due to connection coalescing.
-        List<Route> routes = routeSelection.getAll();
-        for (int i = 0, size = routes.size(); i < size; i++) {
-          Route route = routes.get(i);
-          Internal.instance.get(connectionPool, address, this, route);
-          if (connection != null) {
-            foundPooledConnection = true;
-            result = connection;
-            this.route = route;
-            break;
-          }
-        }
-      }
-
-      if (!foundPooledConnection) {
-        if (selectedRoute == null) {
-          selectedRoute = routeSelection.next();
-        }
-
-        // Create a connection and assign it to this allocation immediately. This makes it possible
-        // for an asynchronous cancel() to interrupt the handshake we're about to do.
-        route = selectedRoute;
-        refusedStreamCount = 0;
-        result = new RealConnection(connectionPool, selectedRoute);
-        acquire(result, false);
-      }
-    }
-
-    // If we found a pooled connection on the 2nd time around, we're done.
-    if (foundPooledConnection) {
-      eventListener.connectionAcquired(call, result);
-      return result;
-    }
-
-    // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
-        connectionRetryEnabled, call, eventListener);
-    routeDatabase().connected(result.route());
-
-    Socket socket = null;
-    synchronized (connectionPool) {
-      reportedAcquired = true;
-
-      // Pool the connection.
-      Internal.instance.put(connectionPool, result);
-
-      // If another multiplexed connection to the same address was created concurrently, then
-      // release this connection and acquire that one.
-      if (result.isMultiplexed()) {
-        socket = Internal.instance.deduplicate(connectionPool, address, this);
-        result = connection;
-      }
-    }
-    closeQuietly(socket);
-
-    eventListener.connectionAcquired(call, result);
-    return result;
-  }
-
-  /**
-   * Releases the currently held connection and returns a socket to close if the held connection
-   * restricts new streams from being created. With HTTP/2 multiple requests share the same
-   * connection so it's possible that our connection is restricted from creating new streams during
-   * a follow-up request.
-   */
-  private Socket releaseIfNoNewStreams() {
-    assert (Thread.holdsLock(connectionPool));
-    RealConnection allocatedConnection = this.connection;
-    if (allocatedConnection != null && allocatedConnection.noNewStreams) {
-      return deallocate(false, false, true);
-    }
-    return null;
-  }
-
-  public void streamFinished(boolean noNewStreams, HttpCodec codec, long bytesRead, IOException e) {
-    eventListener.responseBodyEnd(call, bytesRead);
-
-    Socket socket;
-    Connection releasedConnection;
-    boolean callEnd;
-    synchronized (connectionPool) {
-      if (codec == null || codec != this.codec) {
-        throw new IllegalStateException("expected " + this.codec + " but was " + codec);
-      }
-      if (!noNewStreams) {
-        connection.successCount++;
-      }
-      releasedConnection = connection;
-      socket = deallocate(noNewStreams, false, true);
-      if (connection != null) releasedConnection = null;
-      callEnd = this.released;
-    }
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-
-    if (e != null) {
-      eventListener.callFailed(call, e);
-    } else if (callEnd) {
-      eventListener.callEnd(call);
-    }
-  }
-
-  public HttpCodec codec() {
-    synchronized (connectionPool) {
-      return codec;
-    }
-  }
-
-  private RouteDatabase routeDatabase() {
-    return Internal.instance.routeDatabase(connectionPool);
-  }
-
-  public Route route() {
-    return route;
-  }
-
-  public synchronized RealConnection connection() {
-    return connection;
-  }
-
-  public void release() {
-    Socket socket;
-    Connection releasedConnection;
-    synchronized (connectionPool) {
-      releasedConnection = connection;
-      socket = deallocate(false, true, false);
-      if (connection != null) releasedConnection = null;
-    }
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-  }
-
-  /** Forbid new streams from being created on the connection that hosts this allocation. */
-  public void noNewStreams() {
-    Socket socket;
-    Connection releasedConnection;
-    synchronized (connectionPool) {
-      releasedConnection = connection;
-      socket = deallocate(true, false, false);
-      if (connection != null) releasedConnection = null;
-    }
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-  }
-
-  /**
-   * Releases resources held by this allocation. If sufficient resources are allocated, the
-   * connection will be detached or closed. Callers must be synchronized on the connection pool.
-   *
-   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
-   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
-   */
-  private Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
-    assert (Thread.holdsLock(connectionPool));
-
-    if (streamFinished) {
-      this.codec = null;
-    }
-    if (released) {
-      this.released = true;
-    }
-    Socket socket = null;
-    if (connection != null) {
-      if (noNewStreams) {
-        connection.noNewStreams = true;
-      }
-      if (this.codec == null && (this.released || connection.noNewStreams)) {
-        release(connection);
-        if (connection.allocations.isEmpty()) {
-          connection.idleAtNanos = System.nanoTime();
-          if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
-            socket = connection.socket();
-          }
-        }
-        connection = null;
-      }
-    }
-    return socket;
-  }
-
-  public void cancel() {
-    HttpCodec codecToCancel;
-    RealConnection connectionToCancel;
-    synchronized (connectionPool) {
-      canceled = true;
-      codecToCancel = codec;
-      connectionToCancel = connection;
-    }
-    if (codecToCancel != null) {
-      codecToCancel.cancel();
-    } else if (connectionToCancel != null) {
-      connectionToCancel.cancel();
-    }
-  }
-
-  public void streamFailed(IOException e) {
-    Socket socket;
-    Connection releasedConnection;
-    boolean noNewStreams = false;
-
-    synchronized (connectionPool) {
-      if (e instanceof StreamResetException) {
-        StreamResetException streamResetException = (StreamResetException) e;
-        if (streamResetException.errorCode == ErrorCode.REFUSED_STREAM) {
-          refusedStreamCount++;
-        }
-        // On HTTP/2 stream errors, retry REFUSED_STREAM errors once on the same connection. All
-        // other errors must be retried on a new connection.
-        if (streamResetException.errorCode != ErrorCode.REFUSED_STREAM || refusedStreamCount > 1) {
-          noNewStreams = true;
-          route = null;
-        }
-      } else if (connection != null
-          && (!connection.isMultiplexed() || e instanceof ConnectionShutdownException)) {
-        noNewStreams = true;
-
-        // If this route hasn't completed a call, avoid it for new connections.
-        if (connection.successCount == 0) {
-          if (route != null && e != null) {
-            routeSelector.connectFailed(route, e);
-          }
-          route = null;
-        }
-      }
-      releasedConnection = connection;
-      socket = deallocate(noNewStreams, false, true);
-      if (connection != null || !reportedAcquired) releasedConnection = null;
-    }
-
-    closeQuietly(socket);
-    if (releasedConnection != null) {
-      eventListener.connectionReleased(call, releasedConnection);
-    }
-  }
-
-  /**
-   * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
-   * {@link #release} on the same connection.
-   */
-  public void acquire(RealConnection connection, boolean reportedAcquired) {
-    assert (Thread.holdsLock(connectionPool));
-    if (this.connection != null) throw new IllegalStateException();
-
-    this.connection = connection;
-    this.reportedAcquired = reportedAcquired;
-    connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
-  }
-
-  /** Remove this allocation from the connection's list of allocations. */
-  private void release(RealConnection connection) {
-    for (int i = 0, size = connection.allocations.size(); i < size; i++) {
-      Reference<StreamAllocation> reference = connection.allocations.get(i);
-      if (reference.get() == this) {
-        connection.allocations.remove(i);
-        return;
-      }
-    }
-    throw new IllegalStateException();
-  }
-
-  /**
-   * Release the connection held by this connection and acquire {@code newConnection} instead. It is
-   * only safe to call this if the held connection is newly connected but duplicated by {@code
-   * newConnection}. Typically this occurs when concurrently connecting to an HTTP/2 webserver.
-   *
-   * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
-   * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
-   */
-  public Socket releaseAndAcquire(RealConnection newConnection) {
-    assert (Thread.holdsLock(connectionPool));
-    if (codec != null || connection.allocations.size() != 1) throw new IllegalStateException();
-
-    // Release the old connection.
-    Reference<StreamAllocation> onlyAllocation = connection.allocations.get(0);
-    Socket socket = deallocate(true, false, false);
-
-    // Acquire the new connection.
-    this.connection = newConnection;
-    newConnection.allocations.add(onlyAllocation);
-
-    return socket;
-  }
-
-  public boolean hasMoreRoutes() {
-    return route != null
-        || (routeSelection != null && routeSelection.hasNext())
-        || routeSelector.hasNext();
-  }
-
-  @Override public String toString() {
-    RealConnection connection = connection();
-    return connection != null ? connection.toString() : address.toString();
-  }
-
-  public static final class StreamAllocationReference extends WeakReference<StreamAllocation> {
-    /**
-     * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
-     * identifying the origin of connection leaks.
-     */
-    public final Object callStackTrace;
-
-    StreamAllocationReference(StreamAllocation referent, Object callStackTrace) {
-      super(referent);
-      this.callStackTrace = callStackTrace;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java b/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java
new file mode 100644
index 0000000000..bc1cc1f87b
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/connection/Transmitter.java
@@ -0,0 +1,359 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.lang.ref.Reference;
+import java.lang.ref.WeakReference;
+import java.net.Socket;
+import javax.annotation.Nullable;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.CertificatePinner;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.internal.Internal;
+import okhttp3.internal.http.ExchangeCodec;
+import okhttp3.internal.platform.Platform;
+import okio.AsyncTimeout;
+import okio.Timeout;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.internal.Util.sameConnection;
+
+/**
+ * Bridge between OkHttp's application and network layers. This class exposes high-level application
+ * layer primitives: connections, requests, responses, and streams.
+ *
+ * <p>This class supports {@linkplain #cancel asynchronous canceling}. This is intended to have the
+ * smallest blast radius possible. If an HTTP/2 stream is active, canceling will cancel that stream
+ * but not the other streams sharing its connection. But if the TLS handshake is still in progress
+ * then canceling may break the entire connection.
+ */
+public final class Transmitter {
+  private final OkHttpClient client;
+  private final RealConnectionPool connectionPool;
+  private final Call call;
+  private final EventListener eventListener;
+  private final AsyncTimeout timeout = new AsyncTimeout() {
+    @Override protected void timedOut() {
+      cancel();
+    }
+  };
+
+  private @Nullable Object callStackTrace;
+
+  private Request request;
+  private ExchangeFinder exchangeFinder;
+
+  // Guarded by connectionPool.
+  public RealConnection connection;
+  private @Nullable Exchange exchange;
+  private boolean exchangeRequestDone;
+  private boolean exchangeResponseDone;
+  private boolean canceled;
+  private boolean timeoutEarlyExit;
+  private boolean noMoreExchanges;
+
+  public Transmitter(OkHttpClient client, Call call) {
+    this.client = client;
+    this.connectionPool = Internal.instance.realConnectionPool(client.connectionPool());
+    this.call = call;
+    this.eventListener = client.eventListenerFactory().create(call);
+    this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);
+  }
+
+  public Timeout timeout() {
+    return timeout;
+  }
+
+  public void timeoutEnter() {
+    timeout.enter();
+  }
+
+  /**
+   * Stops applying the timeout before the call is entirely complete. This is used for WebSockets
+   * and duplex calls where the timeout only applies to the initial setup.
+   */
+  public void timeoutEarlyExit() {
+    if (timeoutEarlyExit) throw new IllegalStateException();
+    timeoutEarlyExit = true;
+    timeout.exit();
+  }
+
+  private @Nullable IOException timeoutExit(@Nullable IOException cause) {
+    if (timeoutEarlyExit) return cause;
+    if (!timeout.exit()) return cause;
+
+    InterruptedIOException e = new InterruptedIOException("timeout");
+    if (cause != null) e.initCause(cause);
+
+    return e;
+  }
+
+  public void callStart() {
+    this.callStackTrace = Platform.get().getStackTraceForCloseable("response.body().close()");
+    eventListener.callStart(call);
+  }
+
+  /**
+   * Prepare to create a stream to carry {@code request}. This prefers to use the existing
+   * connection if it exists.
+   */
+  public void prepareToConnect(Request request) {
+    if (this.request != null) {
+      if (sameConnection(this.request.url(), request.url())) return; // Already ready.
+      if (exchange != null) throw new IllegalStateException();
+
+      if (exchangeFinder != null) {
+        maybeReleaseConnection(null, true);
+        exchangeFinder = null;
+      }
+    }
+
+    this.request = request;
+    this.exchangeFinder = new ExchangeFinder(this, connectionPool, createAddress(request.url()),
+        call, eventListener);
+  }
+
+  private Address createAddress(HttpUrl url) {
+    SSLSocketFactory sslSocketFactory = null;
+    HostnameVerifier hostnameVerifier = null;
+    CertificatePinner certificatePinner = null;
+    if (url.isHttps()) {
+      sslSocketFactory = client.sslSocketFactory();
+      hostnameVerifier = client.hostnameVerifier();
+      certificatePinner = client.certificatePinner();
+    }
+
+    return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
+        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
+        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
+  }
+
+  /** Returns a new exchange to carry a new request and response. */
+  Exchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
+    synchronized (connectionPool) {
+      if (noMoreExchanges) throw new IllegalStateException("released");
+      if (exchange != null) throw new IllegalStateException("exchange != null");
+    }
+
+    ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);
+    Exchange result = new Exchange(this, call, eventListener, exchangeFinder, codec);
+
+    synchronized (connectionPool) {
+      this.exchange = result;
+      this.exchangeRequestDone = false;
+      this.exchangeResponseDone = false;
+      return result;
+    }
+  }
+
+  void acquireConnectionNoEvents(RealConnection connection) {
+    assert (Thread.holdsLock(connectionPool));
+
+    if (this.connection != null) throw new IllegalStateException();
+    this.connection = connection;
+    connection.transmitters.add(new TransmitterReference(this, callStackTrace));
+  }
+
+  /**
+   * Remove the transmitter from the connection's list of allocations. Returns a socket that the
+   * caller should close.
+   */
+  @Nullable Socket releaseConnectionNoEvents() {
+    assert (Thread.holdsLock(connectionPool));
+
+    int index = -1;
+    for (int i = 0, size = this.connection.transmitters.size(); i < size; i++) {
+      Reference<Transmitter> reference = this.connection.transmitters.get(i);
+      if (reference.get() == this) {
+        index = i;
+        break;
+      }
+    }
+
+    if (index == -1) throw new IllegalStateException();
+
+    RealConnection released = this.connection;
+    released.transmitters.remove(index);
+    this.connection = null;
+
+    if (released.transmitters.isEmpty()) {
+      released.idleAtNanos = System.nanoTime();
+      if (connectionPool.connectionBecameIdle(released)) {
+        return released.socket();
+      }
+    }
+
+    return null;
+  }
+
+  public void exchangeDoneDueToException() {
+    synchronized (connectionPool) {
+      if (noMoreExchanges) throw new IllegalStateException();
+      exchange = null;
+    }
+  }
+
+  /**
+   * Releases resources held with the request or response of {@code exchange}. This should be called
+   * when the request completes normally or when it fails due to an exception, in which case {@code
+   * e} should be non-null.
+   *
+   * <p>If the exchange was canceled or timed out, this will wrap {@code e} in an exception that
+   * provides that additional context. Otherwise {@code e} is returned as-is.
+   */
+  @Nullable IOException exchangeMessageDone(
+      Exchange exchange, boolean requestDone, boolean responseDone, @Nullable IOException e) {
+    boolean exchangeDone = false;
+    synchronized (connectionPool) {
+      if (exchange != this.exchange) {
+        return e; // This exchange was detached violently!
+      }
+      boolean changed = false;
+      if (requestDone) {
+        if (!exchangeRequestDone) changed = true;
+        this.exchangeRequestDone = true;
+      }
+      if (responseDone) {
+        if (!exchangeResponseDone) changed = true;
+        this.exchangeResponseDone = true;
+      }
+      if (exchangeRequestDone && exchangeResponseDone && changed) {
+        exchangeDone = true;
+        this.exchange.connection().successCount++;
+        this.exchange = null;
+      }
+    }
+    if (exchangeDone) {
+      e = maybeReleaseConnection(e, false);
+    }
+    return e;
+  }
+
+  public @Nullable IOException noMoreExchanges(@Nullable IOException e) {
+    synchronized (connectionPool) {
+      noMoreExchanges = true;
+    }
+    return maybeReleaseConnection(e, false);
+  }
+
+  /**
+   * Release the connection if it is no longer needed. This is called after each exchange completes
+   * and after the call signals that no more exchanges are expected.
+   *
+   * <p>If the transmitter was canceled or timed out, this will wrap {@code e} in an exception that
+   * provides that additional context. Otherwise {@code e} is returned as-is.
+   *
+   * @param force true to release the connection even if more exchanges are expected for the call.
+   */
+  private @Nullable IOException maybeReleaseConnection(@Nullable IOException e, boolean force) {
+    Socket socket;
+    Connection releasedConnection;
+    boolean callEnd;
+    synchronized (connectionPool) {
+      if (force && exchange != null) {
+        throw new IllegalStateException("cannot release connection while it is in use");
+      }
+      releasedConnection = this.connection;
+      socket = this.connection != null && exchange == null && (force || noMoreExchanges)
+          ? releaseConnectionNoEvents()
+          : null;
+      if (this.connection != null) releasedConnection = null;
+      callEnd = noMoreExchanges && exchange == null;
+    }
+    closeQuietly(socket);
+
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+
+    if (callEnd) {
+      boolean callFailed = (e != null);
+      e = timeoutExit(e);
+      if (callFailed) {
+        eventListener.callFailed(call, e);
+      } else {
+        eventListener.callEnd(call);
+      }
+    }
+    return e;
+  }
+
+  public boolean canRetry() {
+    return exchangeFinder.canRetry();
+  }
+
+  public boolean hasExchange() {
+    synchronized (connectionPool) {
+      return exchange != null;
+    }
+  }
+
+  /**
+   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
+   * in-flight request from any thread. It's the caller's responsibility to close the request body
+   * and response body streams; otherwise resources may be leaked.
+   *
+   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
+   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
+   * Otherwise if a socket connection is being established, that is terminated.
+   */
+  public void cancel() {
+    Exchange exchangeToCancel;
+    RealConnection connectionToCancel;
+    synchronized (connectionPool) {
+      canceled = true;
+      exchangeToCancel = exchange;
+      connectionToCancel = exchangeFinder != null && exchangeFinder.connectingConnection() != null
+          ? exchangeFinder.connectingConnection()
+          : connection;
+    }
+    if (exchangeToCancel != null) {
+      exchangeToCancel.cancel();
+    } else if (connectionToCancel != null) {
+      connectionToCancel.cancel();
+    }
+  }
+
+  public boolean isCanceled() {
+    synchronized (connectionPool) {
+      return canceled;
+    }
+  }
+
+  static final class TransmitterReference extends WeakReference<Transmitter> {
+    /**
+     * Captures the stack trace at the time the Call is executed or enqueued. This is helpful for
+     * identifying the origin of connection leaks.
+     */
+    final Object callStackTrace;
+
+    TransmitterReference(Transmitter referent, Object callStackTrace) {
+      super(referent);
+      this.callStackTrace = callStackTrace;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index 62531aa514..c3d21611fb 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -21,13 +21,9 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.internal.Util;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.connection.StreamAllocation;
-import okio.Buffer;
+import okhttp3.internal.connection.Exchange;
 import okio.BufferedSink;
-import okio.ForwardingSink;
 import okio.Okio;
-import okio.Sink;
 
 /** This is the last interceptor in the chain. It makes a network call to the server. */
 public final class CallServerInterceptor implements Interceptor {
@@ -39,58 +35,68 @@ public CallServerInterceptor(boolean forWebSocket) {
 
   @Override public Response intercept(Chain chain) throws IOException {
     RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    HttpCodec httpCodec = realChain.httpStream();
-    StreamAllocation streamAllocation = realChain.streamAllocation();
-    RealConnection connection = (RealConnection) realChain.connection();
+    Exchange exchange = realChain.exchange();
     Request request = realChain.request();
 
     long sentRequestMillis = System.currentTimeMillis();
 
-    realChain.eventListener().requestHeadersStart(realChain.call());
-    httpCodec.writeRequestHeaders(request);
-    realChain.eventListener().requestHeadersEnd(realChain.call(), request);
+    exchange.writeRequestHeaders(request);
 
+    boolean responseHeadersStarted = false;
     Response.Builder responseBuilder = null;
     if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
       // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
       // Continue" response before transmitting the request body. If we don't get that, return
       // what we did get (such as a 4xx response) without ever transmitting the request body.
       if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
-        httpCodec.flushRequest();
-        realChain.eventListener().responseHeadersStart(realChain.call());
-        responseBuilder = httpCodec.readResponseHeaders(true);
+        exchange.flushRequest();
+        responseHeadersStarted = true;
+        exchange.responseHeadersStart();
+        responseBuilder = exchange.readResponseHeaders(true);
       }
 
       if (responseBuilder == null) {
-        // Write the request body if the "Expect: 100-continue" expectation was met.
-        realChain.eventListener().requestBodyStart(realChain.call());
-        long contentLength = request.body().contentLength();
-        CountingSink requestBodyOut =
-            new CountingSink(httpCodec.createRequestBody(request, contentLength));
-        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
-
-        request.body().writeTo(bufferedRequestBody);
-        bufferedRequestBody.close();
-        realChain.eventListener()
-            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);
-      } else if (!connection.isMultiplexed()) {
-        // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
-        // from being reused. Otherwise we're still obligated to transmit the request body to
-        // leave the connection in a consistent state.
-        streamAllocation.noNewStreams();
+        if (request.body().isDuplex()) {
+          // Prepare a duplex body so that the application can send a request body later.
+          exchange.flushRequest();
+          BufferedSink bufferedRequestBody = Okio.buffer(
+              exchange.createRequestBody(request, true));
+          request.body().writeTo(bufferedRequestBody);
+        } else {
+          // Write the request body if the "Expect: 100-continue" expectation was met.
+          BufferedSink bufferedRequestBody = Okio.buffer(
+              exchange.createRequestBody(request, false));
+          request.body().writeTo(bufferedRequestBody);
+          bufferedRequestBody.close();
+        }
+      } else {
+        exchange.noRequestBody();
+        if (!exchange.connection().isMultiplexed()) {
+          // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
+          // from being reused. Otherwise we're still obligated to transmit the request body to
+          // leave the connection in a consistent state.
+          exchange.noNewExchangesOnConnection();
+        }
       }
+    } else {
+      exchange.noRequestBody();
+    }
+
+    if (request.body() == null || !request.body().isDuplex()) {
+      exchange.finishRequest();
     }
 
-    httpCodec.finishRequest();
+    if (!responseHeadersStarted) {
+      exchange.responseHeadersStart();
+    }
 
     if (responseBuilder == null) {
-      realChain.eventListener().responseHeadersStart(realChain.call());
-      responseBuilder = httpCodec.readResponseHeaders(false);
+      responseBuilder = exchange.readResponseHeaders(false);
     }
 
     Response response = responseBuilder
         .request(request)
-        .handshake(streamAllocation.connection().handshake())
+        .handshake(exchange.connection().handshake())
         .sentRequestAtMillis(sentRequestMillis)
         .receivedResponseAtMillis(System.currentTimeMillis())
         .build();
@@ -99,20 +105,17 @@ public CallServerInterceptor(boolean forWebSocket) {
     if (code == 100) {
       // server sent a 100-continue even though we did not request one.
       // try again to read the actual response
-      responseBuilder = httpCodec.readResponseHeaders(false);
-
-      response = responseBuilder
-              .request(request)
-              .handshake(streamAllocation.connection().handshake())
-              .sentRequestAtMillis(sentRequestMillis)
-              .receivedResponseAtMillis(System.currentTimeMillis())
-              .build();
+      response = exchange.readResponseHeaders(false)
+          .request(request)
+          .handshake(exchange.connection().handshake())
+          .sentRequestAtMillis(sentRequestMillis)
+          .receivedResponseAtMillis(System.currentTimeMillis())
+          .build();
 
       code = response.code();
     }
 
-    realChain.eventListener()
-            .responseHeadersEnd(realChain.call(), response);
+    exchange.responseHeadersEnd(response);
 
     if (forWebSocket && code == 101) {
       // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
@@ -121,13 +124,13 @@ public CallServerInterceptor(boolean forWebSocket) {
           .build();
     } else {
       response = response.newBuilder()
-          .body(httpCodec.openResponseBody(response))
+          .body(exchange.openResponseBody(response))
           .build();
     }
 
     if ("close".equalsIgnoreCase(response.request().header("Connection"))
         || "close".equalsIgnoreCase(response.header("Connection"))) {
-      streamAllocation.noNewStreams();
+      exchange.noNewExchangesOnConnection();
     }
 
     if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
@@ -137,17 +140,4 @@ public CallServerInterceptor(boolean forWebSocket) {
 
     return response;
   }
-
-  static final class CountingSink extends ForwardingSink {
-    long successfulCount;
-
-    CountingSink(Sink delegate) {
-      super(delegate);
-    }
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      super.write(source, byteCount);
-      successfulCount += byteCount;
-    }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/ExchangeCode.kt b/okhttp/src/main/java/okhttp3/internal/http/ExchangeCode.kt
new file mode 100644
index 0000000000..9fa1a70dfb
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/ExchangeCode.kt
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http
+
+import java.io.IOException
+import okhttp3.Headers
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.internal.connection.RealConnection
+import okio.Sink
+import okio.Source
+
+/** Encodes HTTP requests and decodes HTTP responses.  */
+interface ExchangeCodec {
+
+  /** Returns the connection that carries this codec.  */
+  fun connection(): RealConnection
+
+  /** Returns an output stream where the request body can be streamed.  */
+  @Throws(IOException::class)
+  fun createRequestBody(request: Request, contentLength: Long): Sink
+
+  /** This should update the HTTP engine's sentRequestMillis field.  */
+  @Throws(IOException::class)
+  fun writeRequestHeaders(request: Request)
+
+  /** Flush the request to the underlying socket.  */
+  @Throws(IOException::class)
+  fun flushRequest()
+
+  /** Flush the request to the underlying socket and signal no more bytes will be transmitted.  */
+  @Throws(IOException::class)
+  fun finishRequest()
+
+  /**
+   * Parses bytes of a response header from an HTTP transport.
+   *
+   * @param expectContinue true to return null if this is an intermediate response with a "100"
+   * response code. Otherwise this method never returns null.
+   */
+  @Throws(IOException::class)
+  fun readResponseHeaders(expectContinue: Boolean): Response.Builder?
+
+  @Throws(IOException::class)
+  fun reportedContentLength(response: Response): Long
+
+  @Throws(IOException::class)
+  fun openResponseBodySource(response: Response): Source
+
+  /** Returns the trailers after the HTTP response. May be empty.  */
+  @Throws(IOException::class)
+  fun trailers(): Headers
+
+  /**
+   * Cancel this stream. Resources held by this stream will be cleaned up, though not synchronously.
+   * That may happen later by the connection pool thread.
+   */
+  fun cancel()
+
+  companion object {
+    /**
+     * The timeout to use while discarding a stream of input data. Since this is used for connection
+     * reuse, this timeout should be significantly less than the time it takes to establish a new
+     * connection.
+     */
+    const val DISCARD_STREAM_TIMEOUT_MILLIS = 100
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java b/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
deleted file mode 100644
index ad9759acce..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpCodec.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okio.Sink;
-
-/** Encodes HTTP requests and decodes HTTP responses. */
-public interface HttpCodec {
-  /**
-   * The timeout to use while discarding a stream of input data. Since this is used for connection
-   * reuse, this timeout should be significantly less than the time it takes to establish a new
-   * connection.
-   */
-  int DISCARD_STREAM_TIMEOUT_MILLIS = 100;
-
-  /** Returns an output stream where the request body can be streamed. */
-  Sink createRequestBody(Request request, long contentLength);
-
-  /** This should update the HTTP engine's sentRequestMillis field. */
-  void writeRequestHeaders(Request request) throws IOException;
-
-  /** Flush the request to the underlying socket. */
-  void flushRequest() throws IOException;
-
-  /** Flush the request to the underlying socket and signal no more bytes will be transmitted. */
-  void finishRequest() throws IOException;
-
-  /**
-   * Parses bytes of a response header from an HTTP transport.
-   *
-   * @param expectContinue true to return null if this is an intermediate response with a "100"
-   *     response code. Otherwise this method never returns null.
-   */
-  Response.Builder readResponseHeaders(boolean expectContinue) throws IOException;
-
-  /** Returns a stream that reads the response body. */
-  ResponseBody openResponseBody(Response response) throws IOException;
-
-  /**
-   * Cancel this stream. Resources held by this stream will be cleaned up, though not synchronously.
-   * That may happen later by the connection pool thread.
-   */
-  void cancel();
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
index a1d6712906..5e82d187a3 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
@@ -15,13 +15,16 @@
  */
 package okhttp3.internal.http;
 
+import java.io.EOFException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
 import java.util.TreeSet;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 import okhttp3.Challenge;
 import okhttp3.Cookie;
 import okhttp3.CookieJar;
@@ -29,19 +32,19 @@
 import okhttp3.HttpUrl;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+import okio.Buffer;
+import okio.ByteString;
 
 import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
 import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
-import static okhttp3.internal.Util.equal;
+import static okhttp3.internal.Util.EMPTY_HEADERS;
 import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
 
 /** Headers and utilities for internal use by OkHttp. */
 public final class HttpHeaders {
-  private static final String TOKEN = "([^ \"=]*)";
-  private static final String QUOTED_STRING = "\"([^\"]*)\"";
-  private static final Pattern PARAMETER
-      = Pattern.compile(" +" + TOKEN + "=(:?" + QUOTED_STRING + "|" + TOKEN + ") *(:?,|$)");
+  private static final ByteString QUOTED_STRING_DELIMITERS = ByteString.encodeUtf8("\"\\");
+  private static final ByteString TOKEN_DELIMITERS = ByteString.encodeUtf8("\t ,=");
 
   private HttpHeaders() {
   }
@@ -70,7 +73,7 @@ private static long stringToLong(String s) {
   public static boolean varyMatches(
       Response cachedResponse, Headers cachedRequest, Request newRequest) {
     for (String field : varyFields(cachedResponse)) {
-      if (!equal(cachedRequest.values(field), newRequest.headers(field))) return false;
+      if (!Objects.equals(cachedRequest.values(field), newRequest.headers(field))) return false;
     }
     return true;
   }
@@ -131,7 +134,7 @@ public static Headers varyHeaders(Response response) {
    */
   public static Headers varyHeaders(Headers requestHeaders, Headers responseHeaders) {
     Set<String> varyFields = varyFields(responseHeaders);
-    if (varyFields.isEmpty()) return new Headers.Builder().build();
+    if (varyFields.isEmpty()) return EMPTY_HEADERS;
 
     Headers.Builder result = new Headers.Builder();
     for (int i = 0, size = requestHeaders.size(); i < size; i++) {
@@ -144,55 +147,177 @@ public static Headers varyHeaders(Headers requestHeaders, Headers responseHeader
   }
 
   /**
-   * Parse RFC 7617 challenges, also wrong ordered ones.
-   * This API is only interested in the scheme name and realm.
+   * Parse RFC 7235 challenges. This is awkward because we need to look ahead to know how to
+   * interpret a token.
+   *
+   * <p>For example, the first line has a parameter name/value pair and the second line has a single
+   * token68:
+   *
+   * <pre>   {@code
+   *
+   *   WWW-Authenticate: Digest foo=bar
+   *   WWW-Authenticate: Digest foo=
+   * }</pre>
+   *
+   * <p>Similarly, the first line has one challenge and the second line has two challenges:
+   *
+   * <pre>   {@code
+   *
+   *   WWW-Authenticate: Digest ,foo=bar
+   *   WWW-Authenticate: Digest ,foo
+   * }</pre>
    */
-  public static List<Challenge> parseChallenges(Headers responseHeaders, String challengeHeader) {
-    // auth-scheme = token
-    // auth-param  = token "=" ( token | quoted-string )
-    // challenge   = auth-scheme 1*SP 1#auth-param
-    // realm       = "realm" "=" realm-value
-    // realm-value = quoted-string
-    List<Challenge> challenges = new ArrayList<>();
-    List<String> authenticationHeaders = responseHeaders.values(challengeHeader);
-    for (String header : authenticationHeaders) {
-      int index = header.indexOf(' ');
-      if (index == -1) continue;
-
-      String scheme = header.substring(0, index);
-      String realm = null;
-      String charset = null;
-
-      Matcher matcher = PARAMETER.matcher(header);
-      for (int i = index; matcher.find(i); i = matcher.end()) {
-        if (header.regionMatches(true, matcher.start(1), "realm", 0, 5)) {
-          realm = matcher.group(3);
-        } else if (header.regionMatches(true, matcher.start(1), "charset", 0, 7)) {
-          charset = matcher.group(3);
+  public static List<Challenge> parseChallenges(Headers responseHeaders, String headerName) {
+    List<Challenge> result = new ArrayList<>();
+    for (int h = 0; h < responseHeaders.size(); h++) {
+      if (headerName.equalsIgnoreCase(responseHeaders.name(h))) {
+        Buffer header = new Buffer().writeUtf8(responseHeaders.value(h));
+        try {
+          parseChallengeHeader(result, header);
+        } catch (EOFException e) {
+          Platform.get().log(Platform.WARN, "Unable to parse challenge", e);
         }
+      }
+    }
+    return result;
+  }
 
-        if (realm != null && charset != null) {
-          break;
-        }
+  private static void parseChallengeHeader(List<Challenge> result, Buffer header)
+      throws EOFException {
+    String peek = null;
+
+    while (true) {
+      // Read a scheme name for this challenge if we don't have one already.
+      if (peek == null) {
+        skipWhitespaceAndCommas(header);
+        peek = readToken(header);
+        if (peek == null) return;
       }
 
-      // "realm" is required.
-      if (realm == null) continue;
+      String schemeName = peek;
+
+      // Read a token68, a sequence of parameters, or nothing.
+      boolean commaPrefixed = skipWhitespaceAndCommas(header);
+      peek = readToken(header);
+      if (peek == null) {
+        if (!header.exhausted()) return; // Expected a token; got something else.
+        result.add(new Challenge(schemeName, Collections.emptyMap()));
+        return;
+      }
 
-      Challenge challenge = new Challenge(scheme, realm);
+      int eqCount = skipAll(header, (byte) '=');
+      boolean commaSuffixed = skipWhitespaceAndCommas(header);
 
-      // If a charset is provided, RFC 7617 says it must be "UTF-8".
-      if (charset != null) {
-        if (charset.equalsIgnoreCase("UTF-8")) {
-          challenge = challenge.withCharset(Util.UTF_8);
-        } else {
-          continue;
+      // It's a token68 because there isn't a value after it.
+      if (!commaPrefixed && (commaSuffixed || header.exhausted())) {
+        result.add(new Challenge(schemeName, Collections.singletonMap(
+            null, peek + repeat('=', eqCount))));
+        peek = null;
+        continue;
+      }
+
+      // It's a series of parameter names and values.
+      Map<String, String> parameters = new LinkedHashMap<>();
+      eqCount += skipAll(header, (byte) '=');
+      while (true) {
+        if (peek == null) {
+          peek = readToken(header);
+          if (skipWhitespaceAndCommas(header)) break; // We peeked a scheme name followed by ','.
+          eqCount = skipAll(header, (byte) '=');
         }
+        if (eqCount == 0) break; // We peeked a scheme name.
+        if (eqCount > 1) return; // Unexpected '=' characters.
+        if (skipWhitespaceAndCommas(header)) return; // Unexpected ','.
+
+        String parameterValue = !header.exhausted() && header.getByte(0) == '"'
+            ? readQuotedString(header)
+            : readToken(header);
+        if (parameterValue == null) return; // Expected a value.
+        String replaced = parameters.put(peek, parameterValue);
+        peek = null;
+        if (replaced != null) return; // Unexpected duplicate parameter.
+        if (!skipWhitespaceAndCommas(header) && !header.exhausted()) return; // Expected ',' or EOF.
       }
+      result.add(new Challenge(schemeName, parameters));
+    }
+  }
 
-      challenges.add(challenge);
+  /** Returns true if any commas were skipped. */
+  private static boolean skipWhitespaceAndCommas(Buffer buffer) throws EOFException {
+    boolean commaFound = false;
+    while (!buffer.exhausted()) {
+      byte b = buffer.getByte(0);
+      if (b == ',') {
+        // Consume ','.
+        buffer.readByte();
+        commaFound = true;
+      } else if (b == ' ' || b == '\t') {
+        // Consume space or tab.
+        buffer.readByte();
+      } else {
+        break;
+      }
     }
-    return challenges;
+    return commaFound;
+  }
+
+  private static int skipAll(Buffer buffer, byte b) throws EOFException {
+    int count = 0;
+    while (!buffer.exhausted() && buffer.getByte(0) == b) {
+      count++;
+      buffer.readByte();
+    }
+    return count;
+  }
+
+  /**
+   * Reads a double-quoted string, unescaping quoted pairs like {@code \"} to the 2nd character in
+   * each sequence. Returns the unescaped string, or null if the buffer isn't prefixed with a
+   * double-quoted string.
+   */
+  private static String readQuotedString(Buffer buffer) throws EOFException {
+    if (buffer.readByte() != '\"') throw new IllegalArgumentException();
+    Buffer result = new Buffer();
+    while (true) {
+      long i = buffer.indexOfElement(QUOTED_STRING_DELIMITERS);
+      if (i == -1L) return null; // Unterminated quoted string.
+
+      if (buffer.getByte(i) == '"') {
+        result.write(buffer, i);
+        // Consume '"'.
+        buffer.readByte();
+        return result.readUtf8();
+      }
+
+      if (buffer.size() == i + 1L) return null; // Dangling escape.
+      result.write(buffer, i);
+      // Consume '\'.
+      buffer.readByte();
+      result.write(buffer, 1L); // The escaped character.
+    }
+  }
+
+  /**
+   * Consumes and returns a non-empty token, terminating at special characters in {@link
+   * #TOKEN_DELIMITERS}. Returns null if the buffer is empty or prefixed with a delimiter.
+   */
+  private static String readToken(Buffer buffer) {
+    try {
+      long tokenSize = buffer.indexOfElement(TOKEN_DELIMITERS);
+      if (tokenSize == -1L) tokenSize = buffer.size();
+
+      return tokenSize != 0L
+          ? buffer.readUtf8(tokenSize)
+          : null;
+    } catch (EOFException e) {
+      throw new AssertionError();
+    }
+  }
+
+  private static String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
   }
 
   public static void receiveHeaders(CookieJar cookieJar, HttpUrl url, Headers headers) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
deleted file mode 100644
index da45901512..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-public final class HttpMethod {
-  public static boolean invalidatesCache(String method) {
-    return method.equals("POST")
-        || method.equals("PATCH")
-        || method.equals("PUT")
-        || method.equals("DELETE")
-        || method.equals("MOVE");     // WebDAV
-  }
-
-  public static boolean requiresRequestBody(String method) {
-    return method.equals("POST")
-        || method.equals("PUT")
-        || method.equals("PATCH")
-        || method.equals("PROPPATCH") // WebDAV
-        || method.equals("REPORT");   // CalDAV/CardDAV (defined in WebDAV Versioning)
-  }
-
-  public static boolean permitsRequestBody(String method) {
-    return !(method.equals("GET") || method.equals("HEAD"));
-  }
-
-  public static boolean redirectsWithBody(String method) {
-    return method.equals("PROPFIND"); // (WebDAV) redirects should also maintain the request body
-  }
-
-  public static boolean redirectsToGet(String method) {
-    // All requests but PROPFIND should redirect to a GET request.
-    return !method.equals("PROPFIND");
-  }
-
-  private HttpMethod() {
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.kt b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.kt
new file mode 100644
index 0000000000..2e62a0cd4f
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.kt
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http
+
+object HttpMethod {
+  @JvmStatic
+  fun invalidatesCache(method: String): Boolean = (method == "POST"
+      || method == "PATCH"
+      || method == "PUT"
+      || method == "DELETE"
+      || method == "MOVE")     // WebDAV
+
+  @JvmStatic
+  fun requiresRequestBody(method: String): Boolean = (method == "POST"
+      || method == "PUT"
+      || method == "PATCH"
+      || method == "PROPPATCH" // WebDAV
+      || method == "REPORT")   // CalDAV/CardDAV (defined in WebDAV Versioning)
+
+  @JvmStatic
+  fun permitsRequestBody(method: String): Boolean = !(method == "GET" || method == "HEAD")
+
+  @JvmStatic
+  fun redirectsWithBody(method: String): Boolean =
+      // (WebDAV) redirects should also maintain the request body
+      method == "PROPFIND"
+
+  @JvmStatic
+  fun redirectsToGet(method: String): Boolean =
+      // All requests but PROPFIND should redirect to a GET request.
+      method != "PROPFIND"
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
deleted file mode 100644
index 52f9880892..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Call;
-import okhttp3.Connection;
-import okhttp3.EventListener;
-import okhttp3.Interceptor;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.connection.StreamAllocation;
-
-import static okhttp3.internal.Util.checkDuration;
-
-/**
- * A concrete interceptor chain that carries the entire interceptor chain: all application
- * interceptors, the OkHttp core, all network interceptors, and finally the network caller.
- */
-public final class RealInterceptorChain implements Interceptor.Chain {
-  private final List<Interceptor> interceptors;
-  private final StreamAllocation streamAllocation;
-  private final HttpCodec httpCodec;
-  private final RealConnection connection;
-  private final int index;
-  private final Request request;
-  private final Call call;
-  private final EventListener eventListener;
-  private final int connectTimeout;
-  private final int readTimeout;
-  private final int writeTimeout;
-  private int calls;
-
-  public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,
-      HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,
-      EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) {
-    this.interceptors = interceptors;
-    this.connection = connection;
-    this.streamAllocation = streamAllocation;
-    this.httpCodec = httpCodec;
-    this.index = index;
-    this.request = request;
-    this.call = call;
-    this.eventListener = eventListener;
-    this.connectTimeout = connectTimeout;
-    this.readTimeout = readTimeout;
-    this.writeTimeout = writeTimeout;
-  }
-
-  @Override public Connection connection() {
-    return connection;
-  }
-
-  @Override public int connectTimeoutMillis() {
-    return connectTimeout;
-  }
-
-  @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) {
-    int millis = checkDuration("timeout", timeout, unit);
-    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
-        request, call, eventListener, millis, readTimeout, writeTimeout);
-  }
-
-  @Override public int readTimeoutMillis() {
-    return readTimeout;
-  }
-
-  @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) {
-    int millis = checkDuration("timeout", timeout, unit);
-    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
-        request, call, eventListener, connectTimeout, millis, writeTimeout);
-  }
-
-  @Override public int writeTimeoutMillis() {
-    return writeTimeout;
-  }
-
-  @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) {
-    int millis = checkDuration("timeout", timeout, unit);
-    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
-        request, call, eventListener, connectTimeout, readTimeout, millis);
-  }
-
-  public StreamAllocation streamAllocation() {
-    return streamAllocation;
-  }
-
-  public HttpCodec httpStream() {
-    return httpCodec;
-  }
-
-  @Override public Call call() {
-    return call;
-  }
-
-  public EventListener eventListener() {
-    return eventListener;
-  }
-
-  @Override public Request request() {
-    return request;
-  }
-
-  @Override public Response proceed(Request request) throws IOException {
-    return proceed(request, streamAllocation, httpCodec, connection);
-  }
-
-  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
-      RealConnection connection) throws IOException {
-    if (index >= interceptors.size()) throw new AssertionError();
-
-    calls++;
-
-    // If we already have a stream, confirm that the incoming request will use it.
-    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {
-      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
-          + " must retain the same host and port");
-    }
-
-    // If we already have a stream, confirm that this is the only call to chain.proceed().
-    if (this.httpCodec != null && calls > 1) {
-      throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
-          + " must call proceed() exactly once");
-    }
-
-    // Call the next interceptor in the chain.
-    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
-        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
-        writeTimeout);
-    Interceptor interceptor = interceptors.get(index);
-    Response response = interceptor.intercept(next);
-
-    // Confirm that the next interceptor made its required call to chain.proceed().
-    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {
-      throw new IllegalStateException("network interceptor " + interceptor
-          + " must call proceed() exactly once");
-    }
-
-    // Confirm that the intercepted response isn't null.
-    if (response == null) {
-      throw new NullPointerException("interceptor " + interceptor + " returned null");
-    }
-
-    if (response.body() == null) {
-      throw new IllegalStateException(
-          "interceptor " + interceptor + " returned a response with no body");
-    }
-
-    return response;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.kt b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.kt
new file mode 100644
index 0000000000..81a82dcde4
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.kt
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http
+
+import okhttp3.Interceptor
+import okhttp3.Request
+import okhttp3.Call
+import okhttp3.Connection
+import okhttp3.Response
+import okhttp3.internal.Util.checkDuration
+import okhttp3.internal.connection.Exchange
+import okhttp3.internal.connection.Transmitter
+import java.io.IOException
+import java.util.concurrent.TimeUnit
+
+/**
+ * A concrete interceptor chain that carries the entire interceptor chain: all application
+ * interceptors, the OkHttp core, all network interceptors, and finally the network caller.
+ *
+ * If the chain is for an application interceptor then [connection] must be null.
+ * Otherwise it is for a network interceptor and [connection] must be non-null.
+ */
+class RealInterceptorChain(
+  private val interceptors: List<Interceptor>,
+  private val transmitter: Transmitter,
+  private val exchange: Exchange?,
+  private val index: Int,
+  private val request: Request,
+  private val call: Call,
+  private val connectTimeout: Int,
+  private val readTimeout: Int,
+  private val writeTimeout: Int
+): Interceptor.Chain {
+
+  private var calls: Int = 0
+
+  override fun connection(): Connection? {
+    return exchange?.connection()
+  }
+
+  override fun connectTimeoutMillis(): Int = connectTimeout
+
+  override fun withConnectTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain {
+    val millis = checkDuration("timeout", timeout.toLong(), unit)
+    return RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
+        millis, readTimeout, writeTimeout)
+  }
+
+  override fun readTimeoutMillis(): Int = readTimeout
+
+  override fun withReadTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain {
+    val millis = checkDuration("timeout", timeout.toLong(), unit)
+    return RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
+        connectTimeout, millis, writeTimeout)
+  }
+
+  override fun writeTimeoutMillis(): Int = writeTimeout
+
+  override fun withWriteTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain {
+    val millis = checkDuration("timeout", timeout.toLong(), unit)
+    return RealInterceptorChain(interceptors, transmitter, exchange, index, request, call,
+        connectTimeout, readTimeout, millis)
+  }
+
+  fun transmitter(): Transmitter = transmitter
+
+  fun exchange(): Exchange {
+    if (exchange == null) throw IllegalStateException()
+    return exchange
+  }
+
+  override fun call(): Call = call
+
+  override fun request(): Request = request
+
+  override fun proceed(request: Request): Response {
+    return proceed(request, transmitter, exchange)
+  }
+
+  @Throws(IOException::class)
+  fun proceed(request: Request, transmitter: Transmitter, exchange: Exchange?): Response {
+    if (index >= interceptors.size) throw AssertionError()
+
+    calls++
+
+    // If we already have a stream, confirm that the incoming request will use it.
+    if (this.exchange != null && !this.exchange.connection().supportsUrl(request.url())) {
+      throw IllegalStateException("network interceptor " + interceptors[index - 1]
+          + " must retain the same host and port")
+    }
+
+    // If we already have a stream, confirm that this is the only call to chain.proceed().
+    if (this.exchange != null && calls > 1) {
+      throw IllegalStateException("network interceptor " + interceptors[index - 1]
+          + " must call proceed() exactly once")
+    }
+
+    // Call the next interceptor in the chain.
+    val next = RealInterceptorChain(interceptors, transmitter, exchange,
+        index + 1, request, call, connectTimeout, readTimeout, writeTimeout)
+    val interceptor = interceptors[index]
+    val response = interceptor.intercept(next)
+
+    // Confirm that the next interceptor made its required call to chain.proceed().
+    if (exchange != null && index + 1 < interceptors.size && next.calls != 1) {
+      throw IllegalStateException("network interceptor " + interceptor
+          + " must call proceed() exactly once")
+    }
+
+    // Confirm that the intercepted response isn't null.
+    if (response == null) {
+      throw NullPointerException("interceptor $interceptor returned null")
+    }
+
+    if (response.body() == null) {
+      throw IllegalStateException(
+          "interceptor $interceptor returned a response with no body")
+    }
+
+    return response
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.kt
similarity index 55%
rename from okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
rename to okhttp/src/main/java/okhttp3/internal/http/RequestLine.kt
index 3e09098097..a303cf6573 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RequestLine.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RequestLine.kt
@@ -13,52 +13,53 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.http
 
-import java.net.HttpURLConnection;
-import java.net.Proxy;
-import okhttp3.HttpUrl;
-import okhttp3.Request;
+import java.net.HttpURLConnection
+import java.net.Proxy
+import okhttp3.HttpUrl
+import okhttp3.Request
 
-public final class RequestLine {
-  private RequestLine() {
-  }
+object RequestLine {
 
   /**
    * Returns the request status line, like "GET / HTTP/1.1". This is exposed to the application by
-   * {@link HttpURLConnection#getHeaderFields}, so it needs to be set even if the transport is
+   * [HttpURLConnection.getHeaderFields], so it needs to be set even if the transport is
    * HTTP/2.
    */
-  public static String get(Request request, Proxy.Type proxyType) {
-    StringBuilder result = new StringBuilder();
-    result.append(request.method());
-    result.append(' ');
+  @JvmStatic
+  operator fun get(request: Request, proxyType: Proxy.Type): String {
+    val result = StringBuilder()
+    result.append(request.method())
+    result.append(' ')
 
     if (includeAuthorityInRequestLine(request, proxyType)) {
-      result.append(request.url());
+      result.append(request.url())
     } else {
-      result.append(requestPath(request.url()));
+      result.append(requestPath(request.url()))
     }
 
-    result.append(" HTTP/1.1");
-    return result.toString();
+    result.append(" HTTP/1.1")
+    return result.toString()
   }
 
   /**
    * Returns true if the request line should contain the full URL with host and port (like "GET
    * http://android.com/foo HTTP/1.1") or only the path (like "GET /foo HTTP/1.1").
    */
-  private static boolean includeAuthorityInRequestLine(Request request, Proxy.Type proxyType) {
-    return !request.isHttps() && proxyType == Proxy.Type.HTTP;
+  @JvmStatic
+  private fun includeAuthorityInRequestLine(request: Request, proxyType: Proxy.Type): Boolean {
+    return !request.isHttps && proxyType == Proxy.Type.HTTP
   }
 
   /**
    * Returns the path to request, like the '/' in 'GET / HTTP/1.1'. Never empty, even if the request
    * URL is. Includes the query component if it exists.
    */
-  public static String requestPath(HttpUrl url) {
-    String path = url.encodedPath();
-    String query = url.encodedQuery();
-    return query != null ? (path + '?' + query) : path;
+  @JvmStatic
+  fun requestPath(url: HttpUrl): String {
+    val path = url.encodedPath()
+    val query = url.encodedQuery()
+    return if (query != null) "$path?$query" else path
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 07df5e9b08..65da93ce23 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -15,21 +15,16 @@
  */
 package okhttp3.internal.http;
 
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InterruptedIOException;
-import java.net.HttpRetryException;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.SocketTimeoutException;
 import java.security.cert.CertificateException;
-import javax.net.ssl.HostnameVerifier;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.CertificatePinner;
-import okhttp3.EventListener;
 import okhttp3.HttpUrl;
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
@@ -37,8 +32,10 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.Route;
+import okhttp3.internal.Internal;
+import okhttp3.internal.connection.Exchange;
 import okhttp3.internal.connection.RouteException;
-import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.connection.Transmitter;
 import okhttp3.internal.http2.ConnectionShutdownException;
 
 import static java.net.HttpURLConnection.HTTP_CLIENT_TIMEOUT;
@@ -50,6 +47,7 @@
 import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
 import static java.net.HttpURLConnection.HTTP_UNAVAILABLE;
 import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.internal.Util.sameConnection;
 import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
 import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 
@@ -65,84 +63,45 @@
   private static final int MAX_FOLLOW_UPS = 20;
 
   private final OkHttpClient client;
-  private final boolean forWebSocket;
-  private volatile StreamAllocation streamAllocation;
-  private Object callStackTrace;
-  private volatile boolean canceled;
 
-  public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) {
+  public RetryAndFollowUpInterceptor(OkHttpClient client) {
     this.client = client;
-    this.forWebSocket = forWebSocket;
-  }
-
-  /**
-   * Immediately closes the socket connection if it's currently held. Use this to interrupt an
-   * in-flight request from any thread. It's the caller's responsibility to close the request body
-   * and response body streams; otherwise resources may be leaked.
-   *
-   * <p>This method is safe to be called concurrently, but provides limited guarantees. If a
-   * transport layer connection has been established (such as a HTTP/2 stream) that is terminated.
-   * Otherwise if a socket connection is being established, that is terminated.
-   */
-  public void cancel() {
-    canceled = true;
-    StreamAllocation streamAllocation = this.streamAllocation;
-    if (streamAllocation != null) streamAllocation.cancel();
-  }
-
-  public boolean isCanceled() {
-    return canceled;
-  }
-
-  public void setCallStackTrace(Object callStackTrace) {
-    this.callStackTrace = callStackTrace;
-  }
-
-  public StreamAllocation streamAllocation() {
-    return streamAllocation;
   }
 
   @Override public Response intercept(Chain chain) throws IOException {
     Request request = chain.request();
     RealInterceptorChain realChain = (RealInterceptorChain) chain;
-    Call call = realChain.call();
-    EventListener eventListener = realChain.eventListener();
-
-    StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),
-        createAddress(request.url()), call, eventListener, callStackTrace);
-    this.streamAllocation = streamAllocation;
+    Transmitter transmitter = realChain.transmitter();
 
     int followUpCount = 0;
     Response priorResponse = null;
     while (true) {
-      if (canceled) {
-        streamAllocation.release();
+      transmitter.prepareToConnect(request);
+
+      if (transmitter.isCanceled()) {
         throw new IOException("Canceled");
       }
 
       Response response;
-      boolean releaseConnection = true;
+      boolean success = false;
       try {
-        response = realChain.proceed(request, streamAllocation, null, null);
-        releaseConnection = false;
+        response = realChain.proceed(request, transmitter, null);
+        success = true;
       } catch (RouteException e) {
         // The attempt to connect via a route failed. The request will not have been sent.
-        if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {
-          throw e.getLastConnectException();
+        if (!recover(e.getLastConnectException(), transmitter, false, request)) {
+          throw e.getFirstConnectException();
         }
-        releaseConnection = false;
         continue;
       } catch (IOException e) {
         // An attempt to communicate with a server failed. The request may have been sent.
         boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
-        if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;
-        releaseConnection = false;
+        if (!recover(e, transmitter, requestSendStarted, request)) throw e;
         continue;
       } finally {
-        // We're throwing an unchecked exception. Release any resources.
-        if (releaseConnection) {
-          streamAllocation.streamFailed(null);
-          streamAllocation.release();
+        // The network call threw an exception. Release any resources.
+        if (!success) {
+          transmitter.exchangeDoneDueToException();
         }
       }
 
@@ -155,35 +114,29 @@ public StreamAllocation streamAllocation() {
             .build();
       }
 
-      Request followUp = followUpRequest(response, streamAllocation.route());
+      Exchange exchange = Internal.instance.exchange(response);
+      Route route = exchange != null ? exchange.connection().route() : null;
+      Request followUp = followUpRequest(response, route);
 
       if (followUp == null) {
-        if (!forWebSocket) {
-          streamAllocation.release();
+        if (exchange != null && exchange.isDuplex()) {
+          transmitter.timeoutEarlyExit();
         }
         return response;
       }
 
-      closeQuietly(response.body());
-
-      if (++followUpCount > MAX_FOLLOW_UPS) {
-        streamAllocation.release();
-        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
+      RequestBody followUpBody = followUp.body();
+      if (followUpBody != null && followUpBody.isOneShot()) {
+        return response;
       }
 
-      if (followUp.body() instanceof UnrepeatableRequestBody) {
-        streamAllocation.release();
-        throw new HttpRetryException("Cannot retry streamed HTTP body", response.code());
+      closeQuietly(response.body());
+      if (transmitter.hasExchange()) {
+        exchange.detachWithViolence();
       }
 
-      if (!sameConnection(response, followUp.url())) {
-        streamAllocation.release();
-        streamAllocation = new StreamAllocation(client.connectionPool(),
-            createAddress(followUp.url()), call, eventListener, callStackTrace);
-        this.streamAllocation = streamAllocation;
-      } else if (streamAllocation.codec() != null) {
-        throw new IllegalStateException("Closing the body of " + response
-            + " didn't close its backing stream. Bad interceptor?");
+      if (++followUpCount > MAX_FOLLOW_UPS) {
+        throw new ProtocolException("Too many follow-up requests: " + followUpCount);
       }
 
       request = followUp;
@@ -191,47 +144,36 @@ public StreamAllocation streamAllocation() {
     }
   }
 
-  private Address createAddress(HttpUrl url) {
-    SSLSocketFactory sslSocketFactory = null;
-    HostnameVerifier hostnameVerifier = null;
-    CertificatePinner certificatePinner = null;
-    if (url.isHttps()) {
-      sslSocketFactory = client.sslSocketFactory();
-      hostnameVerifier = client.hostnameVerifier();
-      certificatePinner = client.certificatePinner();
-    }
-
-    return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),
-        sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),
-        client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());
-  }
-
   /**
    * Report and attempt to recover from a failure to communicate with a server. Returns true if
    * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only
    * be recovered if the body is buffered or if the failure occurred before the request has been
    * sent.
    */
-  private boolean recover(IOException e, StreamAllocation streamAllocation,
+  private boolean recover(IOException e, Transmitter transmitter,
       boolean requestSendStarted, Request userRequest) {
-    streamAllocation.streamFailed(e);
-
     // The application layer has forbidden retries.
     if (!client.retryOnConnectionFailure()) return false;
 
     // We can't send the request body again.
-    if (requestSendStarted && userRequest.body() instanceof UnrepeatableRequestBody) return false;
+    if (requestSendStarted && requestIsOneShot(e, userRequest)) return false;
 
     // This exception is fatal.
     if (!isRecoverable(e, requestSendStarted)) return false;
 
     // No more routes to attempt.
-    if (!streamAllocation.hasMoreRoutes()) return false;
+    if (!transmitter.canRetry()) return false;
 
     // For failure recovery, use the same route selector with a new connection.
     return true;
   }
 
+  private boolean requestIsOneShot(IOException e, Request userRequest) {
+    RequestBody requestBody = userRequest.body();
+    return (requestBody != null && requestBody.isOneShot())
+        || e instanceof FileNotFoundException;
+  }
+
   private boolean isRecoverable(IOException e, boolean requestSendStarted) {
     // If there was a protocol problem, don't recover.
     if (e instanceof ProtocolException) {
@@ -269,7 +211,7 @@ private boolean isRecoverable(IOException e, boolean requestSendStarted) {
    * either add authentication headers, follow redirects or handle a client request timeout. If a
    * follow-up is either unnecessary or not applicable, this returns null.
    */
-  private Request followUpRequest(Response userResponse, Route route) throws IOException {
+  private Request followUpRequest(Response userResponse, @Nullable Route route) throws IOException {
     if (userResponse == null) throw new IllegalStateException();
     int responseCode = userResponse.code();
 
@@ -333,7 +275,7 @@ private Request followUpRequest(Response userResponse, Route route) throws IOExc
         // When redirecting across hosts, drop all authentication headers. This
         // is potentially annoying to the application layer since they have no
         // way to retain them.
-        if (!sameConnection(userResponse, url)) {
+        if (!sameConnection(userResponse.request().url(), url)) {
           requestBuilder.removeHeader("Authorization");
         }
 
@@ -348,7 +290,8 @@ private Request followUpRequest(Response userResponse, Route route) throws IOExc
           return null;
         }
 
-        if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
+        RequestBody requestBody = userResponse.request().body();
+        if (requestBody != null && requestBody.isOneShot()) {
           return null;
         }
 
@@ -398,15 +341,4 @@ private int retryAfter(Response userResponse, int defaultDelay) {
 
     return Integer.MAX_VALUE;
   }
-
-  /**
-   * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
-   * engine.
-   */
-  private boolean sameConnection(Response response, HttpUrl followUp) {
-    HttpUrl url = response.request().url();
-    return url.host().equals(followUp.host())
-        && url.port() == followUp.port()
-        && url.scheme().equals(followUp.scheme());
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1ExchangeCodec.java
similarity index 77%
rename from okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
rename to okhttp/src/main/java/okhttp3/internal/http1/Http1ExchangeCodec.java
index 6c7b4373c4..6dfef02576 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1ExchangeCodec.java
@@ -18,31 +18,28 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
+import java.util.concurrent.TimeUnit;
 import okhttp3.Headers;
 import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.connection.StreamAllocation;
-import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.ExchangeCodec;
 import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.RealResponseBody;
 import okhttp3.internal.http.RequestLine;
 import okhttp3.internal.http.StatusLine;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ForwardingTimeout;
-import okio.Okio;
 import okio.Sink;
 import okio.Source;
 import okio.Timeout;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.InternalKtKt.addHeaderLenient;
 import static okhttp3.internal.Util.checkOffsetAndCount;
 import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
 
@@ -52,8 +49,8 @@
  *
  * <ol>
  *     <li>{@linkplain #writeRequest Send request headers}.
- *     <li>Open a sink to write the request body. Either {@linkplain #newFixedLengthSink
- *         fixed-length} or {@link #newChunkedSink chunked}.
+ *     <li>Open a sink to write the request body. Either {@linkplain #newKnownLengthSink known
+ *         length} or {@link #newChunkedSink chunked}.
  *     <li>Write to and then close that sink.
  *     <li>{@linkplain #readResponseHeaders Read response headers}.
  *     <li>Open a source to read the response body. Either {@linkplain #newFixedLengthSource
@@ -66,7 +63,7 @@
  * Exchanges that do not have a response body can call {@link #newFixedLengthSource(long)
  * newFixedLengthSource(0)} and may skip reading and closing that source.
  */
-public final class Http1Codec implements HttpCodec {
+public final class Http1ExchangeCodec implements ExchangeCodec {
   private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
   private static final int STATE_OPEN_REQUEST_BODY = 1;
   private static final int STATE_WRITING_REQUEST_BODY = 2;
@@ -77,32 +74,47 @@
   private static final int HEADER_LIMIT = 256 * 1024;
 
   /** The client that configures this stream. May be null for HTTPS proxy tunnels. */
-  final OkHttpClient client;
-  /** The stream allocation that owns this stream. May be null for HTTPS proxy tunnels. */
-  final StreamAllocation streamAllocation;
+  private final OkHttpClient client;
 
-  final BufferedSource source;
-  final BufferedSink sink;
-  int state = STATE_IDLE;
+  /** The connection that carries this stream. */
+  private final RealConnection realConnection;
+
+  private final BufferedSource source;
+  private final BufferedSink sink;
+  private int state = STATE_IDLE;
   private long headerLimit = HEADER_LIMIT;
 
-  public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
-      BufferedSink sink) {
+  /**
+   * Received trailers. Null unless the response body uses chunked transfer-encoding and includes
+   * trailers. Undefined until the end of the response body.
+   */
+  private Headers trailers;
+
+  public Http1ExchangeCodec(OkHttpClient client, RealConnection realConnection,
+      BufferedSource source, BufferedSink sink) {
     this.client = client;
-    this.streamAllocation = streamAllocation;
+    this.realConnection = realConnection;
     this.source = source;
     this.sink = sink;
   }
 
-  @Override public Sink createRequestBody(Request request, long contentLength) {
+  @Override public RealConnection connection() {
+    return realConnection;
+  }
+
+  @Override public Sink createRequestBody(Request request, long contentLength) throws IOException {
+    if (request.body() != null && request.body().isDuplex()) {
+      throw new ProtocolException("Duplex connections are not supported for HTTP/1");
+    }
+
     if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
       // Stream a request body of unknown length.
       return newChunkedSink();
     }
 
-    if (contentLength != -1) {
+    if (contentLength != -1L) {
       // Stream a request body of a known length.
-      return newFixedLengthSink(contentLength);
+      return newKnownLengthSink();
     }
 
     throw new IllegalStateException(
@@ -110,8 +122,7 @@ public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, Buffer
   }
 
   @Override public void cancel() {
-    RealConnection connection = streamAllocation.connection();
-    if (connection != null) connection.cancel();
+    if (realConnection != null) realConnection.cancel();
   }
 
   /**
@@ -126,31 +137,44 @@ public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, Buffer
    */
   @Override public void writeRequestHeaders(Request request) throws IOException {
     String requestLine = RequestLine.get(
-        request, streamAllocation.connection().route().proxy().type());
+        request, realConnection.route().proxy().type());
     writeRequest(request.headers(), requestLine);
   }
 
-  @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
-    String contentType = response.header("Content-Type");
+  @Override public long reportedContentLength(Response response) {
+    if (!HttpHeaders.hasBody(response)) {
+      return 0L;
+    }
+
+    if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
+      return -1L;
+    }
+
+    return HttpHeaders.contentLength(response);
+  }
 
+  @Override public Source openResponseBodySource(Response response) {
     if (!HttpHeaders.hasBody(response)) {
-      Source source = newFixedLengthSource(0);
-      return new RealResponseBody(contentType, 0, Okio.buffer(source));
+      return newFixedLengthSource(0);
     }
 
     if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      Source source = newChunkedSource(response.request().url());
-      return new RealResponseBody(contentType, -1L, Okio.buffer(source));
+      return newChunkedSource(response.request().url());
     }
 
     long contentLength = HttpHeaders.contentLength(response);
     if (contentLength != -1) {
-      Source source = newFixedLengthSource(contentLength);
-      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
+      return newFixedLengthSource(contentLength);
     }
 
-    return new RealResponseBody(contentType, -1L, Okio.buffer(newUnknownLengthSource()));
+    return newUnknownLengthSource();
+  }
+
+  @Override public Headers trailers() {
+    if (state != STATE_CLOSED) {
+      throw new IllegalStateException("too early; can't read the trailers yet");
+    }
+    return trailers != null ? trailers : Util.EMPTY_HEADERS;
   }
 
   /** Returns true if this connection is closed. */
@@ -205,9 +229,8 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
       return responseBuilder;
     } catch (EOFException e) {
       // Provide more context if the server ends the stream before sending a response.
-      IOException exception = new IOException("unexpected end of stream on " + streamAllocation);
-      exception.initCause(e);
-      throw exception;
+      throw new IOException("unexpected end of stream on "
+          + realConnection.route().address().url().redact(), e);
     }
   }
 
@@ -218,44 +241,43 @@ private String readHeaderLine() throws IOException {
   }
 
   /** Reads headers or trailers. */
-  public Headers readHeaders() throws IOException {
+  private Headers readHeaders() throws IOException {
     Headers.Builder headers = new Headers.Builder();
     // parse the result headers until the first blank line
     for (String line; (line = readHeaderLine()).length() != 0; ) {
-      Internal.instance.addLenient(headers, line);
+      addHeaderLenient(headers, line);
     }
     return headers.build();
   }
 
-  public Sink newChunkedSink() {
+  private Sink newChunkedSink() {
     if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_WRITING_REQUEST_BODY;
     return new ChunkedSink();
   }
 
-  public Sink newFixedLengthSink(long contentLength) {
+  private Sink newKnownLengthSink() {
     if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_WRITING_REQUEST_BODY;
-    return new FixedLengthSink(contentLength);
+    return new KnownLengthSink();
   }
 
-  public Source newFixedLengthSource(long length) throws IOException {
+  private Source newFixedLengthSource(long length) {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_READING_RESPONSE_BODY;
     return new FixedLengthSource(length);
   }
 
-  public Source newChunkedSource(HttpUrl url) throws IOException {
+  private Source newChunkedSource(HttpUrl url) {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
     state = STATE_READING_RESPONSE_BODY;
     return new ChunkedSource(url);
   }
 
-  public Source newUnknownLengthSource() throws IOException {
+  private Source newUnknownLengthSource() {
     if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
-    if (streamAllocation == null) throw new IllegalStateException("streamAllocation == null");
     state = STATE_READING_RESPONSE_BODY;
-    streamAllocation.noNewStreams();
+    realConnection.noNewExchanges();
     return new UnknownLengthSource();
   }
 
@@ -264,22 +286,29 @@ public Source newUnknownLengthSource() throws IOException {
    * to the default configuration. Use this to avoid unexpected sharing of timeouts between pooled
    * connections.
    */
-  void detachTimeout(ForwardingTimeout timeout) {
+  private void detachTimeout(ForwardingTimeout timeout) {
     Timeout oldDelegate = timeout.delegate();
     timeout.setDelegate(Timeout.NONE);
     oldDelegate.clearDeadline();
     oldDelegate.clearTimeout();
   }
 
-  /** An HTTP body with a fixed length known in advance. */
-  private final class FixedLengthSink implements Sink {
+  /**
+   * The response body from a CONNECT should be empty, but if it is not then we should consume it
+   * before proceeding.
+   */
+  public void skipConnectBody(Response response) throws IOException {
+    long contentLength = HttpHeaders.contentLength(response);
+    if (contentLength == -1L) return;
+    Source body = newFixedLengthSource(contentLength);
+    Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
+    body.close();
+  }
+
+  /** An HTTP request body. */
+  private final class KnownLengthSink implements Sink {
     private final ForwardingTimeout timeout = new ForwardingTimeout(sink.timeout());
     private boolean closed;
-    private long bytesRemaining;
-
-    FixedLengthSink(long bytesRemaining) {
-      this.bytesRemaining = bytesRemaining;
-    }
 
     @Override public Timeout timeout() {
       return timeout;
@@ -288,12 +317,7 @@ void detachTimeout(ForwardingTimeout timeout) {
     @Override public void write(Buffer source, long byteCount) throws IOException {
       if (closed) throw new IllegalStateException("closed");
       checkOffsetAndCount(source.size(), 0, byteCount);
-      if (byteCount > bytesRemaining) {
-        throw new ProtocolException("expected " + bytesRemaining
-            + " bytes but received " + byteCount);
-      }
       sink.write(source, byteCount);
-      bytesRemaining -= byteCount;
     }
 
     @Override public void flush() throws IOException {
@@ -304,7 +328,6 @@ void detachTimeout(ForwardingTimeout timeout) {
     @Override public void close() throws IOException {
       if (closed) return;
       closed = true;
-      if (bytesRemaining > 0) throw new ProtocolException("unexpected end of stream");
       detachTimeout(timeout);
       state = STATE_READ_RESPONSE_HEADERS;
     }
@@ -352,7 +375,6 @@ void detachTimeout(ForwardingTimeout timeout) {
   private abstract class AbstractSource implements Source {
     protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
     protected boolean closed;
-    protected long bytesRead = 0;
 
     @Override public Timeout timeout() {
       return timeout;
@@ -360,13 +382,10 @@ void detachTimeout(ForwardingTimeout timeout) {
 
     @Override public long read(Buffer sink, long byteCount) throws IOException {
       try {
-        long read = source.read(sink, byteCount);
-        if (read > 0) {
-          bytesRead += read;
-        }
-        return read;
+        return source.read(sink, byteCount);
       } catch (IOException e) {
-        endOfInput(false, e);
+        realConnection.noNewExchanges();
+        responseBodyComplete();
         throw e;
       }
     }
@@ -375,16 +394,13 @@ void detachTimeout(ForwardingTimeout timeout) {
      * Closes the cache entry and makes the socket available for reuse. This should be invoked when
      * the end of the body has been reached.
      */
-    protected final void endOfInput(boolean reuseConnection, IOException e) throws IOException {
+    final void responseBodyComplete() {
       if (state == STATE_CLOSED) return;
       if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
 
       detachTimeout(timeout);
 
       state = STATE_CLOSED;
-      if (streamAllocation != null) {
-        streamAllocation.streamFinished(!reuseConnection, Http1Codec.this, bytesRead, e);
-      }
     }
   }
 
@@ -392,10 +408,10 @@ protected final void endOfInput(boolean reuseConnection, IOException e) throws I
   private class FixedLengthSource extends AbstractSource {
     private long bytesRemaining;
 
-    FixedLengthSource(long length) throws IOException {
+    FixedLengthSource(long length) {
       bytesRemaining = length;
       if (bytesRemaining == 0) {
-        endOfInput(true, null);
+        responseBodyComplete();
       }
     }
 
@@ -406,14 +422,15 @@ protected final void endOfInput(boolean reuseConnection, IOException e) throws I
 
       long read = super.read(sink, Math.min(bytesRemaining, byteCount));
       if (read == -1) {
+        realConnection.noNewExchanges(); // The server didn't supply the promised content length.
         ProtocolException e = new ProtocolException("unexpected end of stream");
-        endOfInput(false, e); // The server didn't supply the promised content length.
+        responseBodyComplete();
         throw e;
       }
 
       bytesRemaining -= read;
       if (bytesRemaining == 0) {
-        endOfInput(true, null);
+        responseBodyComplete();
       }
       return read;
     }
@@ -422,7 +439,8 @@ protected final void endOfInput(boolean reuseConnection, IOException e) throws I
       if (closed) return;
 
       if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        endOfInput(false, null);
+        realConnection.noNewExchanges(); // Unread bytes remain on the stream.
+        responseBodyComplete();
       }
 
       closed = true;
@@ -452,8 +470,9 @@ protected final void endOfInput(boolean reuseConnection, IOException e) throws I
 
       long read = super.read(sink, Math.min(byteCount, bytesRemainingInChunk));
       if (read == -1) {
+        realConnection.noNewExchanges(); // The server didn't supply the promised chunk length.
         ProtocolException e = new ProtocolException("unexpected end of stream");
-        endOfInput(false, e); // The server didn't supply the promised chunk length.
+        responseBodyComplete();
         throw e;
       }
       bytesRemainingInChunk -= read;
@@ -477,15 +496,17 @@ private void readChunkSize() throws IOException {
       }
       if (bytesRemainingInChunk == 0L) {
         hasMoreChunks = false;
-        HttpHeaders.receiveHeaders(client.cookieJar(), url, readHeaders());
-        endOfInput(true, null);
+        trailers = readHeaders();
+        HttpHeaders.receiveHeaders(client.cookieJar(), url, trailers);
+        responseBodyComplete();
       }
     }
 
     @Override public void close() throws IOException {
       if (closed) return;
       if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        endOfInput(false, null);
+        realConnection.noNewExchanges(); // Unread bytes remain on the stream.
+        responseBodyComplete();
       }
       closed = true;
     }
@@ -495,9 +516,6 @@ private void readChunkSize() throws IOException {
   private class UnknownLengthSource extends AbstractSource {
     private boolean inputExhausted;
 
-    UnknownLengthSource() {
-    }
-
     @Override public long read(Buffer sink, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
@@ -507,7 +525,7 @@ private void readChunkSize() throws IOException {
       long read = super.read(sink, byteCount);
       if (read == -1) {
         inputExhausted = true;
-        endOfInput(true, null);
+        responseBodyComplete();
         return -1;
       }
       return read;
@@ -516,7 +534,7 @@ private void readChunkSize() throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
       if (!inputExhausted) {
-        endOfInput(false, null);
+        responseBodyComplete();
       }
       closed = true;
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java b/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.kt
similarity index 85%
rename from okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java
rename to okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.kt
index 00c4f2441c..ceeea4f1c3 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/ConnectionShutdownException.kt
@@ -13,13 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http2;
+package okhttp3.internal.http2
 
-import java.io.IOException;
+import java.io.IOException
 
 /**
  * Thrown when an HTTP/2 connection is shutdown (either explicitly or if the peer has sent a GOAWAY
  * frame) and an attempt is made to use the connection.
  */
-public final class ConnectionShutdownException extends IOException {
-}
+class ConnectionShutdownException : IOException()
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Header.java b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
deleted file mode 100644
index 3cfd7be8d7..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Header.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import okhttp3.internal.Util;
-import okio.ByteString;
-
-/** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
-public final class Header {
-  // Special header names defined in HTTP/2 spec.
-  public static final ByteString PSEUDO_PREFIX = ByteString.encodeUtf8(":");
-  public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(":status");
-  public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(":method");
-  public static final ByteString TARGET_PATH = ByteString.encodeUtf8(":path");
-  public static final ByteString TARGET_SCHEME = ByteString.encodeUtf8(":scheme");
-  public static final ByteString TARGET_AUTHORITY = ByteString.encodeUtf8(":authority");
-
-  /** Name in case-insensitive ASCII encoding. */
-  public final ByteString name;
-  /** Value in UTF-8 encoding. */
-  public final ByteString value;
-  final int hpackSize;
-
-  // TODO: search for toLowerCase and consider moving logic here.
-  public Header(String name, String value) {
-    this(ByteString.encodeUtf8(name), ByteString.encodeUtf8(value));
-  }
-
-  public Header(ByteString name, String value) {
-    this(name, ByteString.encodeUtf8(value));
-  }
-
-  public Header(ByteString name, ByteString value) {
-    this.name = name;
-    this.value = value;
-    this.hpackSize = 32 + name.size() + value.size();
-  }
-
-  @Override public boolean equals(Object other) {
-    if (other instanceof Header) {
-      Header that = (Header) other;
-      return this.name.equals(that.name)
-          && this.value.equals(that.value);
-    }
-    return false;
-  }
-
-  @Override public int hashCode() {
-    int result = 17;
-    result = 31 * result + name.hashCode();
-    result = 31 * result + value.hashCode();
-    return result;
-  }
-
-  @Override public String toString() {
-    return Util.format("%s: %s", name.utf8(), value.utf8());
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Header.kt b/okhttp/src/main/java/okhttp3/internal/http2/Header.kt
new file mode 100644
index 0000000000..fcf0225938
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Header.kt
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2
+
+import okhttp3.internal.Util
+import okio.ByteString
+import okio.ByteString.Companion.encodeUtf8
+
+/** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
+data class Header(
+  /** Name in case-insensitive ASCII encoding. */
+  @JvmField val name: ByteString,
+  /** Value in UTF-8 encoding. */
+  @JvmField val value: ByteString
+) {
+  @JvmField internal val hpackSize = 32 + name.size + value.size
+
+  // TODO: search for toLowerCase and consider moving logic here.
+  constructor(name: String, value: String) : this(name.encodeUtf8(), value.encodeUtf8())
+
+  constructor(name: ByteString, value: String) : this(name, value.encodeUtf8())
+
+  override fun toString(): String {
+    return Util.format("%s: %s", name.utf8(), value.utf8())
+  }
+
+  companion object {
+    // Special header names defined in HTTP/2 spec.
+    @JvmField val PSEUDO_PREFIX: ByteString = ":".encodeUtf8()
+
+    const val RESPONSE_STATUS_UTF8 = ":status"
+    const val TARGET_METHOD_UTF8 = ":method"
+    const val TARGET_PATH_UTF8 = ":path"
+    const val TARGET_SCHEME_UTF8 = ":scheme"
+    const val TARGET_AUTHORITY_UTF8 = ":authority"
+
+    @JvmField val RESPONSE_STATUS: ByteString = RESPONSE_STATUS_UTF8.encodeUtf8()
+    @JvmField val TARGET_METHOD: ByteString = TARGET_METHOD_UTF8.encodeUtf8()
+    @JvmField val TARGET_PATH: ByteString = TARGET_PATH_UTF8.encodeUtf8()
+    @JvmField val TARGET_SCHEME: ByteString = TARGET_SCHEME_UTF8.encodeUtf8()
+    @JvmField val TARGET_AUTHORITY: ByteString = TARGET_AUTHORITY_UTF8.encodeUtf8()
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
index 258ac9b269..615756cc48 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
@@ -22,7 +22,7 @@
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import okhttp3.internal.Util;
+import java.util.Objects;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -483,9 +483,9 @@ void writeHeaders(List<Header> headerBlock) throws IOException {
             // it's unnecessary to waste cycles looking at them. This check is built on the
             // observation that the header entries we care about are in adjacent pairs, and we
             // always know the first index of the pair.
-            if (Util.equal(STATIC_HEADER_TABLE[headerNameIndex - 1].value, value)) {
+            if (Objects.equals(STATIC_HEADER_TABLE[headerNameIndex - 1].value, value)) {
               headerIndex = headerNameIndex;
-            } else if (Util.equal(STATIC_HEADER_TABLE[headerNameIndex].value, value)) {
+            } else if (Objects.equals(STATIC_HEADER_TABLE[headerNameIndex].value, value)) {
               headerIndex = headerNameIndex + 1;
             }
           }
@@ -493,8 +493,8 @@ void writeHeaders(List<Header> headerBlock) throws IOException {
 
         if (headerIndex == -1) {
           for (int j = nextHeaderIndex + 1, length = dynamicTable.length; j < length; j++) {
-            if (Util.equal(dynamicTable[j].name, name)) {
-              if (Util.equal(dynamicTable[j].value, value)) {
+            if (Objects.equals(dynamicTable[j].name, name)) {
+              if (Objects.equals(dynamicTable[j].value, value)) {
                 headerIndex = j - nextHeaderIndex + STATIC_HEADER_TABLE.length;
                 break;
               } else if (headerNameIndex == -1) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index fa693232f6..69a47eca3d 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -20,6 +20,7 @@
 import java.io.InterruptedIOException;
 import java.net.InetSocketAddress;
 import java.net.Socket;
+import java.net.SocketAddress;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
@@ -33,7 +34,8 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import okhttp3.Protocol;
+import javax.annotation.Nullable;
+import okhttp3.Headers;
 import okhttp3.internal.NamedRunnable;
 import okhttp3.internal.Util;
 import okhttp3.internal.platform.Platform;
@@ -71,14 +73,14 @@
   // operations must synchronize on 'this' last. This ensures that we never
   // wait for a blocking operation while holding 'this'.
 
-  private static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
+  static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
 
   /**
    * Shared executor to send notifications of incoming streams. This executor requires multiple
    * threads because listeners are not required to return promptly.
    */
   private static final ExecutorService listenerExecutor = new ThreadPoolExecutor(0,
-      Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
+      Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<>(),
       Util.threadFactory("OkHttp Http2Connection", true));
 
   /** True if this peer initiated the connection. */
@@ -90,7 +92,7 @@
    */
   final Listener listener;
   final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
-  final String hostname;
+  final String connectionName;
   int lastGoodStreamId;
   int nextStreamId;
   boolean shutdown;
@@ -152,19 +154,18 @@
       okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, OKHTTP_CLIENT_WINDOW_SIZE);
     }
 
-    hostname = builder.hostname;
+    connectionName = builder.connectionName;
 
     writerExecutor = new ScheduledThreadPoolExecutor(1,
-        Util.threadFactory(Util.format("OkHttp %s Writer", hostname), false));
+        Util.threadFactory(Util.format("OkHttp %s Writer", connectionName), false));
     if (builder.pingIntervalMillis != 0) {
       writerExecutor.scheduleAtFixedRate(new PingRunnable(false, 0, 0),
           builder.pingIntervalMillis, builder.pingIntervalMillis, MILLISECONDS);
     }
 
     // Like newSingleThreadExecutor, except lazy creates the thread.
-    pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
-        new LinkedBlockingQueue<Runnable>(),
-        Util.threadFactory(Util.format("OkHttp %s Push Observer", hostname), true));
+    pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<>(),
+        Util.threadFactory(Util.format("OkHttp %s Push Observer", connectionName), true));
     peerSettings.set(Settings.INITIAL_WINDOW_SIZE, DEFAULT_INITIAL_WINDOW_SIZE);
     peerSettings.set(Settings.MAX_FRAME_SIZE, Http2.INITIAL_MAX_FRAME_SIZE);
     bytesLeftInWriteWindow = peerSettings.getInitialWindowSize();
@@ -174,11 +175,6 @@
     readerRunnable = new ReaderRunnable(new Http2Reader(builder.source, client));
   }
 
-  /** The protocol as selected using ALPN. */
-  public Protocol getProtocol() {
-    return Protocol.HTTP_2;
-  }
-
   /**
    * Returns the number of {@link Http2Stream#isOpen() open streams} on this connection.
    */
@@ -200,6 +196,14 @@ public synchronized int maxConcurrentStreams() {
     return peerSettings.getMaxConcurrentStreams(Integer.MAX_VALUE);
   }
 
+  synchronized void updateConnectionFlowControl(long read) {
+    unacknowledgedBytesRead += read;
+    if (unacknowledgedBytesRead >= okHttpSettings.getInitialWindowSize() / 2) {
+      writeWindowUpdateLater(0, unacknowledgedBytesRead);
+      unacknowledgedBytesRead = 0;
+    }
+  }
+
   /**
    * Returns a new server-initiated stream.
    *
@@ -240,14 +244,14 @@ private Http2Stream newStream(
         }
         streamId = nextStreamId;
         nextStreamId += 2;
-        stream = new Http2Stream(streamId, this, outFinished, inFinished, requestHeaders);
+        stream = new Http2Stream(streamId, this, outFinished, inFinished, null);
         flushHeaders = !out || bytesLeftInWriteWindow == 0L || stream.bytesLeftInWriteWindow == 0L;
         if (stream.isOpen()) {
           streams.put(streamId, stream);
         }
       }
       if (associatedStreamId == 0) {
-        writer.synStream(outFinished, streamId, associatedStreamId, requestHeaders);
+        writer.headers(outFinished, streamId, requestHeaders);
       } else if (client) {
         throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
       } else { // HTTP/2 has a PUSH_PROMISE frame.
@@ -262,9 +266,9 @@ private Http2Stream newStream(
     return stream;
   }
 
-  void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
+  void writeHeaders(int streamId, boolean outFinished, List<Header> alternating)
       throws IOException {
-    writer.synReply(outFinished, streamId, alternating);
+    writer.headers(outFinished, streamId, alternating);
   }
 
   /**
@@ -299,6 +303,7 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
             Http2Connection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
           }
         } catch (InterruptedException e) {
+          Thread.currentThread().interrupt(); // Retain interrupted status.
           throw new InterruptedIOException();
         }
 
@@ -314,12 +319,12 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
 
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
     try {
-      writerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
+      writerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", connectionName, streamId) {
         @Override public void execute() {
           try {
             writeSynReset(streamId, errorCode);
           } catch (IOException e) {
-            failConnection();
+            failConnection(e);
           }
         }
       });
@@ -335,12 +340,12 @@ void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
   void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
     try {
       writerExecutor.execute(
-          new NamedRunnable("OkHttp Window Update %s stream %d", hostname, streamId) {
+          new NamedRunnable("OkHttp Window Update %s stream %d", connectionName, streamId) {
             @Override public void execute() {
               try {
                 writer.windowUpdate(streamId, unacknowledgedBytesRead);
               } catch (IOException e) {
-                failConnection();
+                failConnection(e);
               }
             }
           });
@@ -355,7 +360,7 @@ void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRe
     final int payload2;
 
     PingRunnable(boolean reply, int payload1, int payload2) {
-      super("OkHttp %s ping %08x%08x", hostname, payload1, payload2);
+      super("OkHttp %s ping %08x%08x", connectionName, payload1, payload2);
       this.reply = reply;
       this.payload1 = payload1;
       this.payload2 = payload2;
@@ -374,7 +379,7 @@ void writePing(boolean reply, int payload1, int payload2) {
         awaitingPong = true;
       }
       if (failedDueToMissingPong) {
-        failConnection();
+        failConnection(null);
         return;
       }
     }
@@ -382,18 +387,18 @@ void writePing(boolean reply, int payload1, int payload2) {
     try {
       writer.ping(reply, payload1, payload2);
     } catch (IOException e) {
-      failConnection();
+      failConnection(e);
     }
   }
 
   /** For testing: sends a ping and waits for a pong. */
-  void writePingAndAwaitPong() throws IOException, InterruptedException {
+  void writePingAndAwaitPong() throws InterruptedException {
     writePing(false, 0x4f4b6f6b /* "OKok" */, 0xf09f8da9 /* donut */);
     awaitPong();
   }
 
   /** For testing: waits until {@code requiredPongCount} pings have been received from the peer. */
-  synchronized void awaitPong() throws IOException, InterruptedException {
+  synchronized void awaitPong() throws InterruptedException {
     while (awaitingPong) {
       wait();
     }
@@ -428,23 +433,21 @@ public void shutdown(ErrorCode statusCode) throws IOException {
    * Closes this connection. This cancels all open streams and unanswered pings. It closes the
    * underlying input and output streams and shuts down internal executor services.
    */
-  @Override public void close() throws IOException {
-    close(ErrorCode.NO_ERROR, ErrorCode.CANCEL);
+  @Override public void close() {
+    close(ErrorCode.NO_ERROR, ErrorCode.CANCEL, null);
   }
 
-  void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
+  void close(ErrorCode connectionCode, ErrorCode streamCode, @Nullable IOException cause) {
     assert (!Thread.holdsLock(this));
-    IOException thrown = null;
     try {
       shutdown(connectionCode);
-    } catch (IOException e) {
-      thrown = e;
+    } catch (IOException ignored) {
     }
 
     Http2Stream[] streamsToClose = null;
     synchronized (this) {
       if (!streams.isEmpty()) {
-        streamsToClose = streams.values().toArray(new Http2Stream[streams.size()]);
+        streamsToClose = streams.values().toArray(new Http2Stream[0]);
         streams.clear();
       }
     }
@@ -452,9 +455,8 @@ void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
     if (streamsToClose != null) {
       for (Http2Stream stream : streamsToClose) {
         try {
-          stream.close(streamCode);
-        } catch (IOException e) {
-          if (thrown != null) thrown = e;
+          stream.close(streamCode, cause);
+        } catch (IOException ignored) {
         }
       }
     }
@@ -462,29 +464,22 @@ void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
     // Close the writer to release its resources (such as deflaters).
     try {
       writer.close();
-    } catch (IOException e) {
-      if (thrown == null) thrown = e;
+    } catch (IOException ignored) {
     }
 
     // Close the socket to break out the reader thread, which will clean up after itself.
     try {
       socket.close();
-    } catch (IOException e) {
-      thrown = e;
+    } catch (IOException ignored) {
     }
 
     // Release the threads.
     writerExecutor.shutdown();
     pushExecutor.shutdown();
-
-    if (thrown != null) throw thrown;
   }
 
-  private void failConnection() {
-    try {
-      close(ErrorCode.PROTOCOL_ERROR, ErrorCode.PROTOCOL_ERROR);
-    } catch (IOException ignored) {
-    }
+  private void failConnection(@Nullable IOException e) {
+    close(ErrorCode.PROTOCOL_ERROR, ErrorCode.PROTOCOL_ERROR, e);
   }
 
   /**
@@ -530,7 +525,7 @@ public synchronized boolean isShutdown() {
 
   public static class Builder {
     Socket socket;
-    String hostname;
+    String connectionName;
     BufferedSource source;
     BufferedSink sink;
     Listener listener = Listener.REFUSE_INCOMING_STREAMS;
@@ -547,14 +542,18 @@ public Builder(boolean client) {
     }
 
     public Builder socket(Socket socket) throws IOException {
-      return socket(socket, ((InetSocketAddress) socket.getRemoteSocketAddress()).getHostName(),
+      SocketAddress remoteSocketAddress = socket.getRemoteSocketAddress();
+      String connectionName = remoteSocketAddress instanceof InetSocketAddress
+          ? ((InetSocketAddress) remoteSocketAddress).getHostName()
+          : remoteSocketAddress.toString();
+      return socket(socket, connectionName,
           Okio.buffer(Okio.source(socket)), Okio.buffer(Okio.sink(socket)));
     }
 
     public Builder socket(
-        Socket socket, String hostname, BufferedSource source, BufferedSink sink) {
+        Socket socket, String connectionName, BufferedSource source, BufferedSink sink) {
       this.socket = socket;
-      this.hostname = hostname;
+      this.connectionName = connectionName;
       this.source = source;
       this.sink = sink;
       return this;
@@ -588,13 +587,14 @@ public Http2Connection build() {
     final Http2Reader reader;
 
     ReaderRunnable(Http2Reader reader) {
-      super("OkHttp %s", hostname);
+      super("OkHttp %s", connectionName);
       this.reader = reader;
     }
 
     @Override protected void execute() {
       ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
       ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
+      IOException errorException = null;
       try {
         reader.readConnectionPreface(this);
         while (reader.nextFrame(false, this)) {
@@ -602,13 +602,11 @@ public Http2Connection build() {
         connectionErrorCode = ErrorCode.NO_ERROR;
         streamErrorCode = ErrorCode.CANCEL;
       } catch (IOException e) {
+        errorException = e;
         connectionErrorCode = ErrorCode.PROTOCOL_ERROR;
         streamErrorCode = ErrorCode.PROTOCOL_ERROR;
       } finally {
-        try {
-          close(connectionErrorCode, streamErrorCode);
-        } catch (IOException ignored) {
-        }
+        close(connectionErrorCode, streamErrorCode, errorException);
         Util.closeQuietly(reader);
       }
     }
@@ -622,12 +620,13 @@ public Http2Connection build() {
       Http2Stream dataStream = getStream(streamId);
       if (dataStream == null) {
         writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
+        updateConnectionFlowControl(length);
         source.skip(length);
         return;
       }
       dataStream.receiveData(source, length);
       if (inFinished) {
-        dataStream.receiveFin();
+        dataStream.receiveHeaders(Util.EMPTY_HEADERS, true);
       }
     }
 
@@ -652,18 +651,21 @@ public Http2Connection build() {
           if (streamId % 2 == nextStreamId % 2) return;
 
           // Create a stream.
+          Headers headers = Util.toHeaders(headerBlock);
           final Http2Stream newStream = new Http2Stream(streamId, Http2Connection.this,
-              false, inFinished, headerBlock);
+              false, inFinished, headers);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
-          listenerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
+          listenerExecutor.execute(new NamedRunnable(
+              "OkHttp %s stream %d", connectionName, streamId) {
             @Override public void execute() {
               try {
                 listener.onStream(newStream);
               } catch (IOException e) {
-                Platform.get().log(INFO, "Http2Connection.Listener failure for " + hostname, e);
+                Platform.get().log(
+                    INFO, "Http2Connection.Listener failure for " + connectionName, e);
                 try {
-                  newStream.close(ErrorCode.PROTOCOL_ERROR);
+                  newStream.close(ErrorCode.PROTOCOL_ERROR, e);
                 } catch (IOException ignored) {
                 }
               }
@@ -674,8 +676,7 @@ public Http2Connection build() {
       }
 
       // Update an existing stream.
-      stream.receiveHeaders(headerBlock);
-      if (inFinished) stream.receiveFin();
+      stream.receiveHeaders(Util.toHeaders(headerBlock), inFinished);
     }
 
     @Override public void rstStream(int streamId, ErrorCode errorCode) {
@@ -704,10 +705,10 @@ public Http2Connection build() {
             receivedInitialPeerSettings = true;
           }
           if (!streams.isEmpty()) {
-            streamsToNotify = streams.values().toArray(new Http2Stream[streams.size()]);
+            streamsToNotify = streams.values().toArray(new Http2Stream[0]);
           }
         }
-        listenerExecutor.execute(new NamedRunnable("OkHttp %s settings", hostname) {
+        listenerExecutor.execute(new NamedRunnable("OkHttp %s settings", connectionName) {
           @Override public void execute() {
             listener.onSettings(Http2Connection.this);
           }
@@ -724,12 +725,12 @@ public Http2Connection build() {
 
     private void applyAndAckSettings(final Settings peerSettings) {
       try {
-        writerExecutor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostname) {
+        writerExecutor.execute(new NamedRunnable("OkHttp %s ACK Settings", connectionName) {
           @Override public void execute() {
             try {
               writer.applyAndAckSettings(peerSettings);
             } catch (IOException e) {
-              failConnection();
+              failConnection(e);
             }
           }
         });
@@ -765,7 +766,7 @@ private void applyAndAckSettings(final Settings peerSettings) {
       // Copy the streams first. We don't want to hold a lock when we call receiveRstStream().
       Http2Stream[] streamsCopy;
       synchronized (Http2Connection.this) {
-        streamsCopy = streams.values().toArray(new Http2Stream[streams.size()]);
+        streamsCopy = streams.values().toArray(new Http2Stream[0]);
         shutdown = true;
       }
 
@@ -827,7 +828,8 @@ void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
       currentPushRequests.add(streamId);
     }
     try {
-      pushExecutorExecute(new NamedRunnable("OkHttp %s Push Request[%s]", hostname, streamId) {
+      pushExecutorExecute(new NamedRunnable(
+          "OkHttp %s Push Request[%s]", connectionName, streamId) {
         @Override public void execute() {
           boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
           try {
@@ -849,7 +851,8 @@ void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
   void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
       final boolean inFinished) {
     try {
-      pushExecutorExecute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostname, streamId) {
+      pushExecutorExecute(new NamedRunnable(
+          "OkHttp %s Push Headers[%s]", connectionName, streamId) {
         @Override public void execute() {
           boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
           try {
@@ -878,7 +881,7 @@ void pushDataLater(final int streamId, final BufferedSource source, final int by
     source.require(byteCount); // Eagerly read the frame before firing client thread.
     source.read(buffer, byteCount);
     if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Data[%s]", hostname, streamId) {
+    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Data[%s]", connectionName, streamId) {
       @Override public void execute() {
         try {
           boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
@@ -895,7 +898,7 @@ void pushDataLater(final int streamId, final BufferedSource source, final int by
   }
 
   void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostname, streamId) {
+    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Reset[%s]", connectionName, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
         synchronized (Http2Connection.this) {
@@ -915,13 +918,13 @@ private synchronized void pushExecutorExecute(NamedRunnable namedRunnable) {
   public abstract static class Listener {
     public static final Listener REFUSE_INCOMING_STREAMS = new Listener() {
       @Override public void onStream(Http2Stream stream) throws IOException {
-        stream.close(REFUSED_STREAM);
+        stream.close(REFUSED_STREAM, null);
       }
     };
 
     /**
      * Handle a new stream from this connection's peer. Implementations should respond by either
-     * {@linkplain Http2Stream#sendResponseHeaders replying to the stream} or {@linkplain
+     * {@linkplain Http2Stream#writeHeaders replying to the stream} or {@linkplain
      * Http2Stream#close closing it}. This response does not need to be synchronous.
      */
     public abstract void onStream(Http2Stream stream) throws IOException;
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2ExchangeCodec.java
similarity index 55%
rename from okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
rename to okhttp/src/main/java/okhttp3/internal/http2/Http2ExchangeCodec.java
index 1ba93a9650..453e26e0dc 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2ExchangeCodec.java
@@ -27,42 +27,41 @@
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.ResponseBody;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
-import okhttp3.internal.connection.StreamAllocation;
-import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.connection.RealConnection;
+import okhttp3.internal.http.ExchangeCodec;
 import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.RealResponseBody;
 import okhttp3.internal.http.RequestLine;
 import okhttp3.internal.http.StatusLine;
-import okio.Buffer;
-import okio.ByteString;
-import okio.ForwardingSource;
-import okio.Okio;
 import okio.Sink;
 import okio.Source;
 
+import static okhttp3.internal.InternalKtKt.addHeaderLenient;
 import static okhttp3.internal.http.StatusLine.HTTP_CONTINUE;
-import static okhttp3.internal.http2.Header.RESPONSE_STATUS;
+import static okhttp3.internal.http2.Header.RESPONSE_STATUS_UTF8;
 import static okhttp3.internal.http2.Header.TARGET_AUTHORITY;
+import static okhttp3.internal.http2.Header.TARGET_AUTHORITY_UTF8;
 import static okhttp3.internal.http2.Header.TARGET_METHOD;
+import static okhttp3.internal.http2.Header.TARGET_METHOD_UTF8;
 import static okhttp3.internal.http2.Header.TARGET_PATH;
+import static okhttp3.internal.http2.Header.TARGET_PATH_UTF8;
 import static okhttp3.internal.http2.Header.TARGET_SCHEME;
+import static okhttp3.internal.http2.Header.TARGET_SCHEME_UTF8;
 
 /** Encode requests and responses using HTTP/2 frames. */
-public final class Http2Codec implements HttpCodec {
-  private static final ByteString CONNECTION = ByteString.encodeUtf8("connection");
-  private static final ByteString HOST = ByteString.encodeUtf8("host");
-  private static final ByteString KEEP_ALIVE = ByteString.encodeUtf8("keep-alive");
-  private static final ByteString PROXY_CONNECTION = ByteString.encodeUtf8("proxy-connection");
-  private static final ByteString TRANSFER_ENCODING = ByteString.encodeUtf8("transfer-encoding");
-  private static final ByteString TE = ByteString.encodeUtf8("te");
-  private static final ByteString ENCODING = ByteString.encodeUtf8("encoding");
-  private static final ByteString UPGRADE = ByteString.encodeUtf8("upgrade");
+public final class Http2ExchangeCodec implements ExchangeCodec {
+  private static final String CONNECTION = "connection";
+  private static final String HOST = "host";
+  private static final String KEEP_ALIVE = "keep-alive";
+  private static final String PROXY_CONNECTION = "proxy-connection";
+  private static final String TRANSFER_ENCODING = "transfer-encoding";
+  private static final String TE = "te";
+  private static final String ENCODING = "encoding";
+  private static final String UPGRADE = "upgrade";
 
   /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
-  private static final List<ByteString> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
+  private static final List<String> HTTP_2_SKIPPED_REQUEST_HEADERS = Util.immutableList(
       CONNECTION,
       HOST,
       KEEP_ALIVE,
@@ -71,11 +70,11 @@
       TRANSFER_ENCODING,
       ENCODING,
       UPGRADE,
-      TARGET_METHOD,
-      TARGET_PATH,
-      TARGET_SCHEME,
-      TARGET_AUTHORITY);
-  private static final List<ByteString> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
+      TARGET_METHOD_UTF8,
+      TARGET_PATH_UTF8,
+      TARGET_SCHEME_UTF8,
+      TARGET_AUTHORITY_UTF8);
+  private static final List<String> HTTP_2_SKIPPED_RESPONSE_HEADERS = Util.immutableList(
       CONNECTION,
       HOST,
       KEEP_ALIVE,
@@ -85,21 +84,25 @@
       ENCODING,
       UPGRADE);
 
-  private final OkHttpClient client;
   private final Interceptor.Chain chain;
-  final StreamAllocation streamAllocation;
+  private final RealConnection realConnection;
   private final Http2Connection connection;
-  private Http2Stream stream;
+  private volatile Http2Stream stream;
   private final Protocol protocol;
+  private volatile boolean canceled;
 
-  public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation streamAllocation,
-      Http2Connection connection) {
-    this.client = client;
+  public Http2ExchangeCodec(OkHttpClient client, RealConnection realConnection,
+      Interceptor.Chain chain, Http2Connection connection) {
+    this.realConnection = realConnection;
     this.chain = chain;
-    this.streamAllocation = streamAllocation;
     this.connection = connection;
+    this.protocol = client.protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)
+        ? Protocol.H2_PRIOR_KNOWLEDGE
+        : Protocol.HTTP_2;
+  }
 
-    protocol = client.protocols().contains(Protocol.H2C) ? Protocol.H2C : Protocol.HTTP_2;
+  @Override public RealConnection connection() {
+    return realConnection;
   }
 
   @Override public Sink createRequestBody(Request request, long contentLength) {
@@ -112,6 +115,12 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
     boolean hasRequestBody = request.body() != null;
     List<Header> requestHeaders = http2HeadersList(request);
     stream = connection.newStream(requestHeaders, hasRequestBody);
+    // We may have been asked to cancel while creating the new stream and sending the request
+    // headers, but there was still no stream to close.
+    if (canceled) {
+      stream.closeLater(ErrorCode.CANCEL);
+      throw new IOException("Canceled");
+    }
     stream.readTimeout().timeout(chain.readTimeoutMillis(), TimeUnit.MILLISECONDS);
     stream.writeTimeout().timeout(chain.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
   }
@@ -125,7 +134,7 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
   }
 
   @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
-    List<Header> headers = stream.takeResponseHeaders();
+    Headers headers = stream.takeHeaders();
     Response.Builder responseBuilder = readHttp2HeadersList(headers, protocol);
     if (expectContinue && Internal.instance.code(responseBuilder) == HTTP_CONTINUE) {
       return null;
@@ -146,8 +155,9 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
 
     for (int i = 0, size = headers.size(); i < size; i++) {
       // header names must be lowercase.
-      ByteString name = ByteString.encodeUtf8(headers.name(i).toLowerCase(Locale.US));
-      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name)) {
+      String name = headers.name(i).toLowerCase(Locale.US);
+      if (!HTTP_2_SKIPPED_REQUEST_HEADERS.contains(name)
+          || name.equals(TE) && headers.value(i).equals("trailers")) {
         result.add(new Header(name, headers.value(i)));
       }
     }
@@ -155,29 +165,17 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
   }
 
   /** Returns headers for a name value block containing an HTTP/2 response. */
-  public static Response.Builder readHttp2HeadersList(List<Header> headerBlock,
+  public static Response.Builder readHttp2HeadersList(Headers headerBlock,
       Protocol protocol) throws IOException {
     StatusLine statusLine = null;
     Headers.Builder headersBuilder = new Headers.Builder();
     for (int i = 0, size = headerBlock.size(); i < size; i++) {
-      Header header = headerBlock.get(i);
-
-      // If there were multiple header blocks they will be delimited by nulls. Discard existing
-      // header blocks if the existing header block is a '100 Continue' intermediate response.
-      if (header == null) {
-        if (statusLine != null && statusLine.code == HTTP_CONTINUE) {
-          statusLine = null;
-          headersBuilder = new Headers.Builder();
-        }
-        continue;
-      }
-
-      ByteString name = header.name;
-      String value = header.value.utf8();
-      if (name.equals(RESPONSE_STATUS)) {
+      String name = headerBlock.name(i);
+      String value = headerBlock.value(i);
+      if (name.equals(RESPONSE_STATUS_UTF8)) {
         statusLine = StatusLine.parse("HTTP/1.1 " + value);
       } else if (!HTTP_2_SKIPPED_RESPONSE_HEADERS.contains(name)) {
-        Internal.instance.addLenient(headersBuilder, name.utf8(), value);
+        addHeaderLenient(headersBuilder, name, value);
       }
     }
     if (statusLine == null) throw new ProtocolException("Expected ':status' header not present");
@@ -189,48 +187,20 @@ public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation
         .headers(headersBuilder.build());
   }
 
-  @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
-    String contentType = response.header("Content-Type");
-    long contentLength = HttpHeaders.contentLength(response);
-    Source source = new StreamFinishingSource(stream.getSource());
-    return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
+  @Override public long reportedContentLength(Response response) {
+    return HttpHeaders.contentLength(response);
   }
 
-  @Override public void cancel() {
-    if (stream != null) stream.closeLater(ErrorCode.CANCEL);
+  @Override public Source openResponseBodySource(Response response) {
+    return stream.getSource();
   }
 
-  class StreamFinishingSource extends ForwardingSource {
-    boolean completed = false;
-    long bytesRead = 0;
-
-    StreamFinishingSource(Source delegate) {
-      super(delegate);
-    }
-
-    @Override public long read(Buffer sink, long byteCount) throws IOException {
-      try {
-        long read = delegate().read(sink, byteCount);
-        if (read > 0) {
-          bytesRead += read;
-        }
-        return read;
-      } catch (IOException e) {
-        endOfInput(e);
-        throw e;
-      }
-    }
-
-    @Override public void close() throws IOException {
-      super.close();
-      endOfInput(null);
-    }
+  @Override public Headers trailers() throws IOException {
+    return stream.trailers();
+  }
 
-    private void endOfInput(IOException e) {
-      if (completed) return;
-      completed = true;
-      streamAllocation.streamFinished(false, Http2Codec.this, bytesRead, e);
-    }
+  @Override public void cancel() {
+    canceled = true;
+    if (stream != null) stream.closeLater(ErrorCode.CANCEL);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
index 1484a269eb..3137131126 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
@@ -16,6 +16,7 @@
 package okhttp3.internal.http2;
 
 import java.io.Closeable;
+import java.io.EOFException;
 import java.io.IOException;
 import java.util.List;
 import java.util.logging.Logger;
@@ -93,7 +94,7 @@ public void readConnectionPreface(Handler handler) throws IOException {
   public boolean nextFrame(boolean requireSettings, Handler handler) throws IOException {
     try {
       source.require(9); // Frame header size
-    } catch (IOException e) {
+    } catch (EOFException e) {
       return false; // This might be a normal socket close.
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
index 19ac954d7e..c8049e9ace 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -19,8 +19,12 @@
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.SocketTimeoutException;
-import java.util.ArrayList;
+import java.util.ArrayDeque;
+import java.util.Deque;
 import java.util.List;
+import javax.annotation.Nullable;
+import okhttp3.Headers;
+import okhttp3.internal.Util;
 import okio.AsyncTimeout;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -51,11 +55,11 @@
   final int id;
   final Http2Connection connection;
 
-  /** Request headers. Immutable and non null. */
-  private final List<Header> requestHeaders;
-
-  /** Response headers yet to be {@linkplain #takeResponseHeaders taken}. */
-  private List<Header> responseHeaders;
+  /**
+   * Received headers yet to be {@linkplain #takeHeaders taken}, or {@linkplain FramingSource#read
+   * read}.
+   */
+  private final Deque<Headers> headersQueue = new ArrayDeque<>();
 
   /** True if response headers have been sent or received. */
   private boolean hasResponseHeaders;
@@ -70,12 +74,15 @@
    * close this stream (such as both peers closing it near-simultaneously) then this is the first
    * reason known to this peer.
    */
-  ErrorCode errorCode = null;
+  @Nullable ErrorCode errorCode;
+
+  /** The exception that explains {@code errorCode}. Null if no exception was provided. */
+  @Nullable IOException errorException;
 
   Http2Stream(int id, Http2Connection connection, boolean outFinished, boolean inFinished,
-      List<Header> requestHeaders) {
+      @Nullable Headers headers) {
     if (connection == null) throw new NullPointerException("connection == null");
-    if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
+
     this.id = id;
     this.connection = connection;
     this.bytesLeftInWriteWindow =
@@ -84,7 +91,15 @@
     this.sink = new FramingSink();
     this.source.finished = inFinished;
     this.sink.finished = outFinished;
-    this.requestHeaders = requestHeaders;
+    if (headers != null) {
+      headersQueue.add(headers);
+    }
+
+    if (isLocallyInitiated() && headers != null) {
+      throw new IllegalStateException("locally-initiated streams shouldn't have headers yet");
+    } else if (!isLocallyInitiated() && headers == null) {
+      throw new IllegalStateException("remotely-initiated streams should have headers");
+    }
   }
 
   public int getId() {
@@ -124,33 +139,38 @@ public Http2Connection getConnection() {
     return connection;
   }
 
-  public List<Header> getRequestHeaders() {
-    return requestHeaders;
-  }
-
   /**
    * Removes and returns the stream's received response headers, blocking if necessary until headers
    * have been received. If the returned list contains multiple blocks of headers the blocks will be
    * delimited by 'null'.
    */
-  public synchronized List<Header> takeResponseHeaders() throws IOException {
-    if (!isLocallyInitiated()) {
-      throw new IllegalStateException("servers cannot read response headers");
-    }
+  public synchronized Headers takeHeaders() throws IOException {
     readTimeout.enter();
     try {
-      while (responseHeaders == null && errorCode == null) {
+      while (headersQueue.isEmpty() && errorCode == null) {
         waitForIo();
       }
     } finally {
       readTimeout.exitAndThrowIfTimedOut();
     }
-    List<Header> result = responseHeaders;
-    if (result != null) {
-      responseHeaders = null;
-      return result;
+    if (!headersQueue.isEmpty()) {
+      return headersQueue.removeFirst();
+    }
+    throw errorException != null ? errorException : new StreamResetException(errorCode);
+  }
+
+  /**
+   * Returns the trailers. It is only safe to call this once the source stream has been completely
+   * exhausted.
+   */
+  public synchronized Headers trailers() throws IOException {
+    if (errorCode != null) {
+      throw errorException != null ? errorException : new StreamResetException(errorCode);
+    }
+    if (!source.finished || !source.receiveBuffer.exhausted() || !source.readBuffer.exhausted()) {
+      throw new IllegalStateException("too early; can't read the trailers yet");
     }
-    throw new StreamResetException(errorCode);
+    return source.trailers != null ? source.trailers : Util.EMPTY_HEADERS;
   }
 
   /**
@@ -164,29 +184,47 @@ public synchronized ErrorCode getErrorCode() {
   /**
    * Sends a reply to an incoming stream.
    *
-   * @param out true to create an output stream that we can use to send data to the remote peer.
-   * Corresponds to {@code FLAG_FIN}.
+   * @param outFinished true to eagerly finish the output stream to send data to the remote peer.
+   *     Corresponds to {@code FLAG_FIN}.
+   * @param flushHeaders true to force flush the response headers. This should be true unless the
+   *     response body exists and will be written immediately.
    */
-  public void sendResponseHeaders(List<Header> responseHeaders, boolean out) throws IOException {
+  public void writeHeaders(List<Header> responseHeaders, boolean outFinished, boolean flushHeaders)
+      throws IOException {
     assert (!Thread.holdsLock(Http2Stream.this));
     if (responseHeaders == null) {
-      throw new NullPointerException("responseHeaders == null");
+      throw new NullPointerException("headers == null");
     }
-    boolean outFinished = false;
     synchronized (this) {
       this.hasResponseHeaders = true;
-      if (!out) {
+      if (outFinished) {
         this.sink.finished = true;
-        outFinished = true;
       }
     }
-    connection.writeSynReply(id, outFinished, responseHeaders);
 
-    if (outFinished) {
+    // Only DATA frames are subject to flow-control. Transmit the HEADER frame if the connection
+    // flow-control window is fully depleted.
+    if (!flushHeaders) {
+      synchronized (connection) {
+        flushHeaders = connection.bytesLeftInWriteWindow == 0L;
+      }
+    }
+
+    connection.writeHeaders(id, outFinished, responseHeaders);
+
+    if (flushHeaders) {
       connection.flush();
     }
   }
 
+  public void enqueueTrailers(Headers trailers) {
+    synchronized (this) {
+      if (sink.finished) throw new IllegalStateException("already finished");
+      if (trailers.size() == 0) throw new IllegalArgumentException("trailers.size() == 0");
+      this.sink.trailers = trailers;
+    }
+  }
+
   public Timeout readTimeout() {
     return readTimeout;
   }
@@ -204,7 +242,7 @@ public Source getSource() {
    * Returns a sink that can be used to write data to the peer.
    *
    * @throws IllegalStateException if this stream was initiated by the peer and a {@link
-   * #sendResponseHeaders} has not yet been sent.
+   *     #writeHeaders} has not yet been sent.
    */
   public Sink getSink() {
     synchronized (this) {
@@ -219,8 +257,9 @@ public Sink getSink() {
    * Abnormally terminate this stream. This blocks until the {@code RST_STREAM} frame has been
    * transmitted.
    */
-  public void close(ErrorCode rstStatusCode) throws IOException {
-    if (!closeInternal(rstStatusCode)) {
+  public void close(ErrorCode rstStatusCode, @Nullable IOException errorException)
+      throws IOException {
+    if (!closeInternal(rstStatusCode, errorException)) {
       return; // Already closed.
     }
     connection.writeSynReset(id, rstStatusCode);
@@ -231,14 +270,14 @@ public void close(ErrorCode rstStatusCode) throws IOException {
    * immediately.
    */
   public void closeLater(ErrorCode errorCode) {
-    if (!closeInternal(errorCode)) {
+    if (!closeInternal(errorCode, null)) {
       return; // Already closed.
     }
     connection.writeSynResetLater(id, errorCode);
   }
 
   /** Returns true if this stream was closed. */
-  private boolean closeInternal(ErrorCode errorCode) {
+  private boolean closeInternal(ErrorCode errorCode, @Nullable IOException errorException) {
     assert (!Thread.holdsLock(this));
     synchronized (this) {
       if (this.errorCode != null) {
@@ -248,44 +287,35 @@ private boolean closeInternal(ErrorCode errorCode) {
         return false;
       }
       this.errorCode = errorCode;
+      this.errorException = errorException;
       notifyAll();
     }
     connection.removeStream(id);
     return true;
   }
 
-  void receiveHeaders(List<Header> headers) {
-    assert (!Thread.holdsLock(Http2Stream.this));
-    boolean open = true;
-    synchronized (this) {
-      hasResponseHeaders = true;
-      if (responseHeaders == null) {
-        responseHeaders = headers;
-        open = isOpen();
-        notifyAll();
-      } else {
-        List<Header> newHeaders = new ArrayList<>();
-        newHeaders.addAll(responseHeaders);
-        newHeaders.add(null); // Delimit separate blocks of headers with null.
-        newHeaders.addAll(headers);
-        this.responseHeaders = newHeaders;
-      }
-    }
-    if (!open) {
-      connection.removeStream(id);
-    }
-  }
-
   void receiveData(BufferedSource in, int length) throws IOException {
     assert (!Thread.holdsLock(Http2Stream.this));
     this.source.receive(in, length);
   }
 
-  void receiveFin() {
+  /**
+   * Accept headers from the network and store them until the client calls {@link #takeHeaders}, or
+   * {@link FramingSource#read} them.
+   */
+  void receiveHeaders(Headers headers, boolean inFinished) {
     assert (!Thread.holdsLock(Http2Stream.this));
     boolean open;
     synchronized (this) {
-      this.source.finished = true;
+      if (!hasResponseHeaders || !inFinished) {
+        hasResponseHeaders = true;
+        headersQueue.add(headers);
+      } else {
+        this.source.trailers = headers;
+      }
+      if (inFinished) {
+        this.source.finished = true;
+      }
       open = isOpen();
       notifyAll();
     }
@@ -316,6 +346,12 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     /** Maximum number of bytes to buffer before reporting a flow control error. */
     private final long maxByteCount;
 
+    /**
+     * Received trailers. Null unless the server has provided trailers. Undefined until the stream
+     * is exhausted. Guarded by Http2Stream.this.
+     */
+    private Headers trailers;
+
     /** True if the caller has closed this stream. */
     boolean closed;
 
@@ -332,49 +368,73 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     @Override public long read(Buffer sink, long byteCount) throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
 
-      long read;
-      synchronized (Http2Stream.this) {
-        waitUntilReadable();
-        checkNotClosed();
-        if (readBuffer.size() == 0) return -1; // This source is exhausted.
-
-        // Move bytes from the read buffer into the caller's buffer.
-        read = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
-
-        // Flow control: notify the peer that we're ready for more data!
-        unacknowledgedBytesRead += read;
-        if (unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
-          connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
-          unacknowledgedBytesRead = 0;
-        }
-      }
+      while (true) {
+        long readBytesDelivered = -1;
+        IOException errorExceptionToDeliver = null;
 
-      // Update connection.unacknowledgedBytesRead outside the stream lock.
-      synchronized (connection) { // Multiple application threads may hit this section.
-        connection.unacknowledgedBytesRead += read;
-        if (connection.unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
-          connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
-          connection.unacknowledgedBytesRead = 0;
+        // 1. Decide what to do in a synchronized block.
+
+        synchronized (Http2Stream.this) {
+          readTimeout.enter();
+          try {
+            if (errorCode != null) {
+              // Prepare to deliver an error.
+              errorExceptionToDeliver = errorException != null
+                  ? errorException
+                  : new StreamResetException(errorCode);
+            }
+
+            if (closed) {
+              throw new IOException("stream closed");
+
+            } else if (readBuffer.size() > 0) {
+              // Prepare to read bytes. Start by moving them to the caller's buffer.
+              readBytesDelivered = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
+              unacknowledgedBytesRead += readBytesDelivered;
+
+              if (errorExceptionToDeliver == null
+                  && unacknowledgedBytesRead
+                  >= connection.okHttpSettings.getInitialWindowSize() / 2) {
+                // Flow control: notify the peer that we're ready for more data! Only send a
+                // WINDOW_UPDATE if the stream isn't in error.
+                connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
+                unacknowledgedBytesRead = 0;
+              }
+            } else if (!finished && errorExceptionToDeliver == null) {
+              // Nothing to do. Wait until that changes then try again.
+              waitForIo();
+              continue;
+            }
+          } finally {
+            readTimeout.exitAndThrowIfTimedOut();
+          }
         }
-      }
 
-      return read;
-    }
+        // 2. Do it outside of the synchronized block and timeout.
 
-    /** Returns once the source is either readable or finished. */
-    private void waitUntilReadable() throws IOException {
-      readTimeout.enter();
-      try {
-        while (readBuffer.size() == 0 && !finished && !closed && errorCode == null) {
-          waitForIo();
+        if (readBytesDelivered != -1) {
+          // Update connection.unacknowledgedBytesRead outside the synchronized block.
+          updateConnectionFlowControl(readBytesDelivered);
+          return readBytesDelivered;
         }
-      } finally {
-        readTimeout.exitAndThrowIfTimedOut();
+
+        if (errorExceptionToDeliver != null) {
+          // We defer throwing the exception until now so that we can refill the connection
+          // flow-control window. This is necessary because we don't transmit window updates until
+          // the application reads the data. If we throw this prior to updating the connection
+          // flow-control window, we risk having it go to 0 preventing the server from sending data.
+          throw errorExceptionToDeliver;
+        }
+
+        return -1; // This source is exhausted.
       }
     }
 
+    private void updateConnectionFlowControl(long read) {
+      assert (!Thread.holdsLock(Http2Stream.this));
+      connection.updateConnectionFlowControl(read);
+    }
+
     void receive(BufferedSource in, long byteCount) throws IOException {
       assert (!Thread.holdsLock(Http2Stream.this));
 
@@ -420,21 +480,17 @@ void receive(BufferedSource in, long byteCount) throws IOException {
     }
 
     @Override public void close() throws IOException {
+      long bytesDiscarded;
       synchronized (Http2Stream.this) {
         closed = true;
+        bytesDiscarded = readBuffer.size();
         readBuffer.clear();
-        Http2Stream.this.notifyAll();
+        Http2Stream.this.notifyAll(); // TODO(jwilson): Unnecessary?
       }
-      cancelStreamIfNecessary();
-    }
-
-    private void checkNotClosed() throws IOException {
-      if (closed) {
-        throw new IOException("stream closed");
-      }
-      if (errorCode != null) {
-        throw new StreamResetException(errorCode);
+      if (bytesDiscarded > 0) {
+        updateConnectionFlowControl(bytesDiscarded);
       }
+      cancelStreamIfNecessary();
     }
   }
 
@@ -451,7 +507,7 @@ void cancelStreamIfNecessary() throws IOException {
       // is safe because the input stream is closed (we won't use any
       // further bytes) and the output stream is either finished or closed
       // (so RSTing both streams doesn't cause harm).
-      Http2Stream.this.close(ErrorCode.CANCEL);
+      Http2Stream.this.close(ErrorCode.CANCEL, null);
     } else if (!open) {
       connection.removeStream(id);
     }
@@ -467,6 +523,9 @@ void cancelStreamIfNecessary() throws IOException {
      */
     private final Buffer sendBuffer = new Buffer();
 
+    /** Trailers to send at the end of the stream. */
+    private Headers trailers;
+
     boolean closed;
 
     /**
@@ -486,7 +545,7 @@ void cancelStreamIfNecessary() throws IOException {
      * Emit a single data frame to the connection. The frame's size be limited by this stream's
      * write window. This method will block until the write window is nonempty.
      */
-    private void emitFrame(boolean outFinished) throws IOException {
+    private void emitFrame(boolean outFinishedOnLastFrame) throws IOException {
       long toWrite;
       synchronized (Http2Stream.this) {
         writeTimeout.enter();
@@ -505,7 +564,8 @@ private void emitFrame(boolean outFinished) throws IOException {
 
       writeTimeout.enter();
       try {
-        connection.writeData(id, outFinished && toWrite == sendBuffer.size(), sendBuffer, toWrite);
+        boolean outFinished = outFinishedOnLastFrame && toWrite == sendBuffer.size();
+        connection.writeData(id, outFinished, sendBuffer, toWrite);
       } finally {
         writeTimeout.exitAndThrowIfTimedOut();
       }
@@ -532,13 +592,21 @@ private void emitFrame(boolean outFinished) throws IOException {
         if (closed) return;
       }
       if (!sink.finished) {
-        // Emit the remaining data, setting the END_STREAM flag on the last frame.
-        if (sendBuffer.size() > 0) {
+        // We have 0 or more frames of data, and 0 or more frames of trailers. We need to send at
+        // least one frame with the END_STREAM flag set. That must be the last frame, and the
+        // trailers must be sent after all of the data.
+        boolean hasData = sendBuffer.size() > 0;
+        boolean hasTrailers = trailers != null;
+        if (hasTrailers) {
+          while (sendBuffer.size() > 0) {
+            emitFrame(false);
+          }
+          connection.writeHeaders(id, true, Util.toHeaderBlock(trailers));
+        } else if (hasData) {
           while (sendBuffer.size() > 0) {
             emitFrame(true);
           }
         } else {
-          // Send an empty frame just so we can set the END_STREAM flag.
           connection.writeData(id, true, null, 0);
         }
       }
@@ -564,7 +632,7 @@ void checkOutNotClosed() throws IOException {
     } else if (sink.finished) {
       throw new IOException("stream finished");
     } else if (errorCode != null) {
-      throw new StreamResetException(errorCode);
+      throw errorException != null ? errorException : new StreamResetException(errorCode);
     }
   }
 
@@ -576,6 +644,7 @@ void waitForIo() throws InterruptedIOException {
     try {
       wait();
     } catch (InterruptedException e) {
+      Thread.currentThread().interrupt(); // Retain interrupted status.
       throw new InterruptedIOException();
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
index 5ef6bb9c4a..b6456949de 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
@@ -121,24 +121,6 @@ public synchronized void flush() throws IOException {
     sink.flush();
   }
 
-  public synchronized void synStream(boolean outFinished, int streamId,
-      int associatedStreamId, List<Header> headerBlock) throws IOException {
-    if (closed) throw new IOException("closed");
-    headers(outFinished, streamId, headerBlock);
-  }
-
-  public synchronized void synReply(boolean outFinished, int streamId,
-      List<Header> headerBlock) throws IOException {
-    if (closed) throw new IOException("closed");
-    headers(outFinished, streamId, headerBlock);
-  }
-
-  public synchronized void headers(int streamId, List<Header> headerBlock)
-      throws IOException {
-    if (closed) throw new IOException("closed");
-    headers(false, streamId, headerBlock);
-  }
-
   public synchronized void rstStream(int streamId, ErrorCode errorCode)
       throws IOException {
     if (closed) throw new IOException("closed");
@@ -294,7 +276,8 @@ private void writeContinuationFrames(int streamId, long byteCount) throws IOExce
     }
   }
 
-  void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
+  public synchronized void headers(
+      boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
     if (closed) throw new IOException("closed");
     hpackWriter.writeHeaders(headerBlock);
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java b/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java
deleted file mode 100644
index 8c08ddb56a..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import java.util.List;
-import okhttp3.Protocol;
-import okio.BufferedSource;
-
-/**
- * {@link Protocol#HTTP_2 HTTP/2} only. Processes server-initiated HTTP requests on the client.
- * Implementations must quickly dispatch callbacks to avoid creating a bottleneck.
- *
- * <p>While {@link #onReset} may occur at any time, the following callbacks are expected in order,
- * correlated by stream ID.
- *
- * <ul>
- *     <li>{@link #onRequest}</li> <li>{@link #onHeaders} (unless canceled)
- *     <li>{@link #onData} (optional sequence of data frames)
- * </ul>
- *
- * <p>As a stream ID is scoped to a single HTTP/2 connection, implementations which target multiple
- * connections should expect repetition of stream IDs.
- *
- * <p>Return true to request cancellation of a pushed stream.  Note that this does not guarantee
- * future frames won't arrive on the stream ID.
- */
-public interface PushObserver {
-  /**
-   * Describes the request that the server intends to push a response for.
-   *
-   * @param streamId server-initiated stream ID: an even number.
-   * @param requestHeaders minimally includes {@code :method}, {@code :scheme}, {@code :authority},
-   * and {@code :path}.
-   */
-  boolean onRequest(int streamId, List<Header> requestHeaders);
-
-  /**
-   * The response headers corresponding to a pushed request.  When {@code last} is true, there are
-   * no data frames to follow.
-   *
-   * @param streamId server-initiated stream ID: an even number.
-   * @param responseHeaders minimally includes {@code :status}.
-   * @param last when true, there is no response data.
-   */
-  boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last);
-
-  /**
-   * A chunk of response data corresponding to a pushed request.  This data must either be read or
-   * skipped.
-   *
-   * @param streamId server-initiated stream ID: an even number.
-   * @param source location of data corresponding with this stream ID.
-   * @param byteCount number of bytes to read or skip from the source.
-   * @param last when true, there are no data frames to follow.
-   */
-  boolean onData(int streamId, BufferedSource source, int byteCount, boolean last)
-      throws IOException;
-
-  /** Indicates the reason why this stream was canceled. */
-  void onReset(int streamId, ErrorCode errorCode);
-
-  PushObserver CANCEL = new PushObserver() {
-
-    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
-      return true;
-    }
-
-    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
-      return true;
-    }
-
-    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
-        boolean last) throws IOException {
-      source.skip(byteCount);
-      return true;
-    }
-
-    @Override public void onReset(int streamId, ErrorCode errorCode) {
-    }
-  };
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.kt b/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.kt
new file mode 100644
index 0000000000..4d88822968
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/http2/PushObserver.kt
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.http2
+
+import java.io.IOException
+import okhttp3.Protocol
+import okio.BufferedSource
+
+/**
+ * [HTTP/2][Protocol.HTTP_2] only. Processes server-initiated HTTP requests on the client.
+ * Implementations must quickly dispatch callbacks to avoid creating a bottleneck.
+ *
+ * While [onReset] may occur at any time, the following callbacks are expected in order,
+ * correlated by stream ID.
+ *
+ *  * [onRequest]
+ *  * [onHeaders] (unless canceled)
+ *  * [onData] (optional sequence of data frames)
+ *
+ * As a stream ID is scoped to a single HTTP/2 connection, implementations which target multiple
+ * connections should expect repetition of stream IDs.
+ *
+ * Return true to request cancellation of a pushed stream.  Note that this does not guarantee
+ * future frames won't arrive on the stream ID.
+ */
+interface PushObserver {
+  /**
+   * Describes the request that the server intends to push a response for.
+   *
+   * @param streamId server-initiated stream ID: an even number.
+   * @param requestHeaders minimally includes `:method`, `:scheme`, `:authority`,
+   * and `:path`.
+   */
+  fun onRequest(streamId: Int, requestHeaders: List<Header>): Boolean
+
+  /**
+   * The response headers corresponding to a pushed request.  When [last] is true, there are
+   * no data frames to follow.
+   *
+   * @param streamId server-initiated stream ID: an even number.
+   * @param responseHeaders minimally includes `:status`.
+   * @param last when true, there is no response data.
+   */
+  fun onHeaders(streamId: Int, responseHeaders: List<Header>, last: Boolean): Boolean
+
+  /**
+   * A chunk of response data corresponding to a pushed request.  This data must either be read or
+   * skipped.
+   *
+   * @param streamId server-initiated stream ID: an even number.
+   * @param source location of data corresponding with this stream ID.
+   * @param byteCount number of bytes to read or skip from the source.
+   * @param last when true, there are no data frames to follow.
+   */
+  @Throws(IOException::class)
+  fun onData(streamId: Int, source: BufferedSource, byteCount: Int, last: Boolean): Boolean
+
+  /** Indicates the reason why this stream was canceled.  */
+  fun onReset(streamId: Int, errorCode: ErrorCode)
+
+  companion object {
+    @JvmField val CANCEL: PushObserver = object : PushObserver {
+
+      override fun onRequest(streamId: Int, requestHeaders: List<Header>): Boolean {
+        return true
+      }
+
+      override fun onHeaders(streamId: Int, responseHeaders: List<Header>, last: Boolean): Boolean {
+        return true
+      }
+
+      @Throws(IOException::class)
+      override fun onData(streamId: Int, source: BufferedSource, byteCount: Int, last: Boolean): Boolean {
+        source.skip(byteCount.toLong())
+        return true
+      }
+
+      override fun onReset(streamId: Int, errorCode: ErrorCode) {}
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java b/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java
deleted file mode 100644
index 299f81e1b9..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-
-/** Thrown when an HTTP/2 stream is canceled without damage to the socket that carries it. */
-public final class StreamResetException extends IOException {
-  public final ErrorCode errorCode;
-
-  public StreamResetException(ErrorCode errorCode) {
-    super("stream was reset: " + errorCode);
-    this.errorCode = errorCode;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.kt
similarity index 69%
rename from okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
rename to okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.kt
index 499f120e33..814c2add07 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/StreamResetException.kt
@@ -13,11 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.tls;
+package okhttp3.internal.http2
 
-import java.security.cert.X509Certificate;
+import java.io.IOException
 
-public interface TrustRootIndex {
-  /** Returns the trusted CA certificate that signed {@code cert}. */
-  X509Certificate findByIssuerAndSignature(X509Certificate cert);
-}
+/** Thrown when an HTTP/2 stream is canceled without damage to the socket that carries it.  */
+class StreamResetException(@JvmField val errorCode: ErrorCode) : IOException("stream was reset: $errorCode")
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
deleted file mode 100644
index a6f7242ab5..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
+++ /dev/null
@@ -1,430 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import android.os.Build;
-import android.util.Log;
-import java.io.IOException;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.security.Security;
-import java.security.cert.Certificate;
-import java.security.cert.TrustAnchor;
-import java.security.cert.X509Certificate;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Protocol;
-import okhttp3.internal.Util;
-import okhttp3.internal.tls.BasicTrustRootIndex;
-import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.internal.tls.TrustRootIndex;
-
-import static okhttp3.internal.Util.assertionError;
-
-/** Android 2.3 or better. */
-class AndroidPlatform extends Platform {
-  private static final int MAX_LOG_LENGTH = 4000;
-
-  private final Class<?> sslParametersClass;
-  private final OptionalMethod<Socket> setUseSessionTickets;
-  private final OptionalMethod<Socket> setHostname;
-
-  // Non-null on Android 5.0+.
-  private final OptionalMethod<Socket> getAlpnSelectedProtocol;
-  private final OptionalMethod<Socket> setAlpnProtocols;
-
-  private final CloseGuard closeGuard = CloseGuard.get();
-
-  AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSessionTickets,
-      OptionalMethod<Socket> setHostname, OptionalMethod<Socket> getAlpnSelectedProtocol,
-      OptionalMethod<Socket> setAlpnProtocols) {
-    this.sslParametersClass = sslParametersClass;
-    this.setUseSessionTickets = setUseSessionTickets;
-    this.setHostname = setHostname;
-    this.getAlpnSelectedProtocol = getAlpnSelectedProtocol;
-    this.setAlpnProtocols = setAlpnProtocols;
-  }
-
-  @Override public void connectSocket(Socket socket, InetSocketAddress address,
-      int connectTimeout) throws IOException {
-    try {
-      socket.connect(address, connectTimeout);
-    } catch (AssertionError e) {
-      if (Util.isAndroidGetsocknameError(e)) throw new IOException(e);
-      throw e;
-    } catch (SecurityException e) {
-      // Before android 4.3, socket.connect could throw a SecurityException
-      // if opening a socket resulted in an EACCES error.
-      IOException ioException = new IOException("Exception in connect");
-      ioException.initCause(e);
-      throw ioException;
-    } catch (ClassCastException e) {
-      // On android 8.0, socket.connect throws a ClassCastException due to a bug
-      // see https://issuetracker.google.com/issues/63649622
-      if (Build.VERSION.SDK_INT == 26) {
-        IOException ioException = new IOException("Exception in connect");
-        ioException.initCause(e);
-        throw ioException;
-      } else {
-        throw e;
-      }
-    }
-  }
-
-  @Override protected X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
-    Object context = readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters");
-    if (context == null) {
-      // If that didn't work, try the Google Play Services SSL provider before giving up. This
-      // must be loaded by the SSLSocketFactory's class loader.
-      try {
-        Class<?> gmsSslParametersClass = Class.forName(
-            "com.google.android.gms.org.conscrypt.SSLParametersImpl", false,
-            sslSocketFactory.getClass().getClassLoader());
-        context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass, "sslParameters");
-      } catch (ClassNotFoundException e) {
-        return super.trustManager(sslSocketFactory);
-      }
-    }
-
-    X509TrustManager x509TrustManager = readFieldOrNull(
-        context, X509TrustManager.class, "x509TrustManager");
-    if (x509TrustManager != null) return x509TrustManager;
-
-    return readFieldOrNull(context, X509TrustManager.class, "trustManager");
-  }
-
-  @Override public void configureTlsExtensions(
-      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-    // Enable SNI and session tickets.
-    if (hostname != null) {
-      setUseSessionTickets.invokeOptionalWithoutCheckedException(sslSocket, true);
-      setHostname.invokeOptionalWithoutCheckedException(sslSocket, hostname);
-    }
-
-    // Enable ALPN.
-    if (setAlpnProtocols != null && setAlpnProtocols.isSupported(sslSocket)) {
-      Object[] parameters = {concatLengthPrefixed(protocols)};
-      setAlpnProtocols.invokeWithoutCheckedException(sslSocket, parameters);
-    }
-  }
-
-  @Override public @Nullable String getSelectedProtocol(SSLSocket socket) {
-    if (getAlpnSelectedProtocol == null) return null;
-    if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
-
-    byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invokeWithoutCheckedException(socket);
-    return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
-  }
-
-  @Override public void log(int level, String message, Throwable t) {
-    int logLevel = level == WARN ? Log.WARN : Log.DEBUG;
-    if (t != null) message = message + '\n' + Log.getStackTraceString(t);
-
-    // Split by line, then ensure each line can fit into Log's maximum length.
-    for (int i = 0, length = message.length(); i < length; i++) {
-      int newline = message.indexOf('\n', i);
-      newline = newline != -1 ? newline : length;
-      do {
-        int end = Math.min(newline, i + MAX_LOG_LENGTH);
-        Log.println(logLevel, "OkHttp", message.substring(i, end));
-        i = end;
-      } while (i < newline);
-    }
-  }
-
-  @Override public Object getStackTraceForCloseable(String closer) {
-    return closeGuard.createAndOpen(closer);
-  }
-
-  @Override public void logCloseableLeak(String message, Object stackTrace) {
-    boolean reported = closeGuard.warnIfOpen(stackTrace);
-    if (!reported) {
-      // Unable to report via CloseGuard. As a last-ditch effort, send it to the logger.
-      log(WARN, message, null);
-    }
-  }
-
-  @Override public boolean isCleartextTrafficPermitted(String hostname) {
-    try {
-      Class<?> networkPolicyClass = Class.forName("android.security.NetworkSecurityPolicy");
-      Method getInstanceMethod = networkPolicyClass.getMethod("getInstance");
-      Object networkSecurityPolicy = getInstanceMethod.invoke(null);
-      return api24IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
-    } catch (ClassNotFoundException | NoSuchMethodException e) {
-      return super.isCleartextTrafficPermitted(hostname);
-    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
-      throw assertionError("unable to determine cleartext support", e);
-    }
-  }
-
-  private boolean api24IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
-      Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
-    try {
-      Method isCleartextTrafficPermittedMethod = networkPolicyClass
-          .getMethod("isCleartextTrafficPermitted", String.class);
-      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy, hostname);
-    } catch (NoSuchMethodException e) {
-      return api23IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
-    }
-  }
-
-  private boolean api23IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
-      Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
-    try {
-      Method isCleartextTrafficPermittedMethod = networkPolicyClass
-          .getMethod("isCleartextTrafficPermitted");
-      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy);
-    } catch (NoSuchMethodException e) {
-      return super.isCleartextTrafficPermitted(hostname);
-    }
-  }
-
-  /**
-   * Checks to see if Google Play Services Dynamic Security Provider is present which provides ALPN
-   * support. If it isn't checks to see if device is Android 5.0+ since 4.x device have broken
-   * ALPN support.
-   */
-  private static boolean supportsAlpn() {
-    if (Security.getProvider("GMSCore_OpenSSL") != null) {
-      return true;
-    } else {
-      try {
-        Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
-        return true;
-      } catch (ClassNotFoundException ignored) { }
-    }
-    return false;
-  }
-
-  public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
-    try {
-      Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");
-      Constructor<?> constructor = extensionsClass.getConstructor(X509TrustManager.class);
-      Object extensions = constructor.newInstance(trustManager);
-      Method checkServerTrusted = extensionsClass.getMethod(
-          "checkServerTrusted", X509Certificate[].class, String.class, String.class);
-      return new AndroidCertificateChainCleaner(extensions, checkServerTrusted);
-    } catch (Exception e) {
-      return super.buildCertificateChainCleaner(trustManager);
-    }
-  }
-
-  public static Platform buildIfSupported() {
-    // Attempt to find Android 2.3+ APIs.
-    try {
-      Class<?> sslParametersClass;
-      try {
-        sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl");
-      } catch (ClassNotFoundException e) {
-        // Older platform before being unbundled.
-        sslParametersClass = Class.forName(
-            "org.apache.harmony.xnet.provider.jsse.SSLParametersImpl");
-      }
-
-      OptionalMethod<Socket> setUseSessionTickets = new OptionalMethod<>(
-          null, "setUseSessionTickets", boolean.class);
-      OptionalMethod<Socket> setHostname = new OptionalMethod<>(
-          null, "setHostname", String.class);
-      OptionalMethod<Socket> getAlpnSelectedProtocol = null;
-      OptionalMethod<Socket> setAlpnProtocols = null;
-
-      if (supportsAlpn()) {
-        getAlpnSelectedProtocol
-            = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
-        setAlpnProtocols
-            = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
-      }
-
-      return new AndroidPlatform(sslParametersClass, setUseSessionTickets, setHostname,
-          getAlpnSelectedProtocol, setAlpnProtocols);
-    } catch (ClassNotFoundException ignored) {
-      // This isn't an Android runtime.
-    }
-
-    return null;
-  }
-
-  @Override
-  public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
-
-    try {
-      // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
-      // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
-      Method method = trustManager.getClass().getDeclaredMethod(
-              "findTrustAnchorByIssuerAndSignature", X509Certificate.class);
-      method.setAccessible(true);
-      return new AndroidTrustRootIndex(trustManager, method);
-    } catch (NoSuchMethodException e) {
-      return super.buildTrustRootIndex(trustManager);
-    }
-  }
-
-  /**
-   * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
-   * This is the best way to get a clean chain on Android because it uses the same code as the TLS
-   * handshake.
-   */
-  static final class AndroidCertificateChainCleaner extends CertificateChainCleaner {
-    private final Object x509TrustManagerExtensions;
-    private final Method checkServerTrusted;
-
-    AndroidCertificateChainCleaner(Object x509TrustManagerExtensions, Method checkServerTrusted) {
-      this.x509TrustManagerExtensions = x509TrustManagerExtensions;
-      this.checkServerTrusted = checkServerTrusted;
-    }
-
-    @SuppressWarnings({"unchecked", "SuspiciousToArrayCall"}) // Reflection on List<Certificate>.
-    @Override public List<Certificate> clean(List<Certificate> chain, String hostname)
-        throws SSLPeerUnverifiedException {
-      try {
-        X509Certificate[] certificates = chain.toArray(new X509Certificate[chain.size()]);
-        return (List<Certificate>) checkServerTrusted.invoke(
-            x509TrustManagerExtensions, certificates, "RSA", hostname);
-      } catch (InvocationTargetException e) {
-        SSLPeerUnverifiedException exception = new SSLPeerUnverifiedException(e.getMessage());
-        exception.initCause(e);
-        throw exception;
-      } catch (IllegalAccessException e) {
-        throw new AssertionError(e);
-      }
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof AndroidCertificateChainCleaner; // All instances are equivalent.
-    }
-
-    @Override public int hashCode() {
-      return 0;
-    }
-  }
-
-  /**
-   * Provides access to the internal dalvik.system.CloseGuard class. Android uses this in
-   * combination with android.os.StrictMode to report on leaked java.io.Closeable's. Available since
-   * Android API 11.
-   */
-  static final class CloseGuard {
-    private final Method getMethod;
-    private final Method openMethod;
-    private final Method warnIfOpenMethod;
-
-    CloseGuard(Method getMethod, Method openMethod, Method warnIfOpenMethod) {
-      this.getMethod = getMethod;
-      this.openMethod = openMethod;
-      this.warnIfOpenMethod = warnIfOpenMethod;
-    }
-
-    Object createAndOpen(String closer) {
-      if (getMethod != null) {
-        try {
-          Object closeGuardInstance = getMethod.invoke(null);
-          openMethod.invoke(closeGuardInstance, closer);
-          return closeGuardInstance;
-        } catch (Exception ignored) {
-        }
-      }
-      return null;
-    }
-
-    boolean warnIfOpen(Object closeGuardInstance) {
-      boolean reported = false;
-      if (closeGuardInstance != null) {
-        try {
-          warnIfOpenMethod.invoke(closeGuardInstance);
-          reported = true;
-        } catch (Exception ignored) {
-        }
-      }
-      return reported;
-    }
-
-    static CloseGuard get() {
-      Method getMethod;
-      Method openMethod;
-      Method warnIfOpenMethod;
-
-      try {
-        Class<?> closeGuardClass = Class.forName("dalvik.system.CloseGuard");
-        getMethod = closeGuardClass.getMethod("get");
-        openMethod = closeGuardClass.getMethod("open", String.class);
-        warnIfOpenMethod = closeGuardClass.getMethod("warnIfOpen");
-      } catch (Exception ignored) {
-        getMethod = null;
-        openMethod = null;
-        warnIfOpenMethod = null;
-      }
-      return new CloseGuard(getMethod, openMethod, warnIfOpenMethod);
-    }
-  }
-
-  /**
-   * An index of trusted root certificates that exploits knowledge of Android implementation
-   * details. This class is potentially much faster to initialize than {@link BasicTrustRootIndex}
-   * because it doesn't need to load and index trusted CA certificates.
-   *
-   * <p>This class uses APIs added to Android in API 14 (Android 4.0, released October 2011). This
-   * class shouldn't be used in Android API 17 or better because those releases are better served by
-   * {@link AndroidPlatform.AndroidCertificateChainCleaner}.
-   */
-  static final class AndroidTrustRootIndex implements TrustRootIndex {
-    private final X509TrustManager trustManager;
-    private final Method findByIssuerAndSignatureMethod;
-
-    AndroidTrustRootIndex(X509TrustManager trustManager, Method findByIssuerAndSignatureMethod) {
-      this.findByIssuerAndSignatureMethod = findByIssuerAndSignatureMethod;
-      this.trustManager = trustManager;
-    }
-
-    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
-      try {
-        TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
-                trustManager, cert);
-        return trustAnchor != null
-                ? trustAnchor.getTrustedCert()
-                : null;
-      } catch (IllegalAccessException e) {
-        throw assertionError("unable to get issues and signature", e);
-      } catch (InvocationTargetException e) {
-        return null;
-      }
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-      if (obj == this) {
-        return true;
-      }
-      if (!(obj instanceof AndroidTrustRootIndex)) {
-        return false;
-      }
-      AndroidTrustRootIndex that = (AndroidTrustRootIndex) obj;
-      return trustManager.equals(that.trustManager)
-              && findByIssuerAndSignatureMethod.equals(that.findByIssuerAndSignatureMethod);
-    }
-
-    @Override
-    public int hashCode() {
-      return trustManager.hashCode() + 31 * findByIssuerAndSignatureMethod.hashCode();
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
new file mode 100644
index 0000000000..404bd1b887
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.kt
@@ -0,0 +1,399 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform
+
+import android.os.Build
+import android.util.Log
+import okhttp3.Protocol
+import okhttp3.internal.Util
+import okhttp3.internal.tls.BasicTrustRootIndex
+import okhttp3.internal.tls.CertificateChainCleaner
+import okhttp3.internal.tls.TrustRootIndex
+import java.io.IOException
+import java.lang.reflect.InvocationTargetException
+import java.lang.reflect.Method
+import java.net.InetSocketAddress
+import java.net.Socket
+import java.nio.charset.StandardCharsets.UTF_8
+import java.security.NoSuchAlgorithmException
+import java.security.cert.Certificate
+import java.security.cert.TrustAnchor
+import java.security.cert.X509Certificate
+import javax.net.ssl.SSLContext
+import javax.net.ssl.SSLPeerUnverifiedException
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/** Android 5+.  */
+class AndroidPlatform(
+  private val sslParametersClass: Class<*>,
+  private val sslSocketClass: Class<*>,
+  private val setUseSessionTickets: Method,
+  private val setHostname: Method,
+  private val getAlpnSelectedProtocol: Method,
+  private val setAlpnProtocols: Method
+) : Platform() {
+  private val closeGuard = CloseGuard.get()
+
+  // Not a real Android runtime; probably RoboVM or MoE
+  // Try to load TLS 1.2 explicitly.
+  // fallback to TLS
+  override fun getSSLContext(): SSLContext {
+    val tryTls12: Boolean = try {
+      Build.VERSION.SDK_INT in 16..21
+    } catch (e: NoClassDefFoundError) {
+      true
+    }
+
+    if (tryTls12) {
+      try {
+        return SSLContext.getInstance("TLSv1.2")
+      } catch (e: NoSuchAlgorithmException) {
+      }
+    }
+
+    try {
+      return SSLContext.getInstance("TLS")
+    } catch (e: NoSuchAlgorithmException) {
+      throw IllegalStateException("No TLS provider", e)
+    }
+  }
+
+  @Throws(IOException::class)
+  override fun connectSocket(
+    socket: Socket, address: InetSocketAddress,
+    connectTimeout: Int
+  ) {
+    try {
+      socket.connect(address, connectTimeout)
+    } catch (e: AssertionError) {
+      if (Util.isAndroidGetsocknameError(e)) throw IOException(e)
+      throw e
+    } catch (e: ClassCastException) {
+      // On android 8.0, socket.connect throws a ClassCastException due to a bug
+      // see https://issuetracker.google.com/issues/63649622
+      if (Build.VERSION.SDK_INT == 26) {
+        throw IOException("Exception in connect", e)
+      } else {
+        throw e
+      }
+    }
+  }
+
+  override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {
+    var context: Any? =
+        readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters")
+    if (context == null) {
+      // If that didn't work, try the Google Play Services SSL provider before giving up. This
+      // must be loaded by the SSLSocketFactory's class loader.
+      try {
+        val gmsSslParametersClass = Class.forName(
+            "com.google.android.gms.org.conscrypt.SSLParametersImpl", false,
+            sslSocketFactory.javaClass.classLoader)
+        context = readFieldOrNull(sslSocketFactory, gmsSslParametersClass,
+            "sslParameters")
+      } catch (e: ClassNotFoundException) {
+        return super.trustManager(sslSocketFactory)
+      }
+    }
+
+    val x509TrustManager = readFieldOrNull(
+        context!!, X509TrustManager::class.java, "x509TrustManager")
+    return x509TrustManager ?: readFieldOrNull(context, X509TrustManager::class.java,
+        "trustManager")
+  }
+
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket, hostname: String?, protocols: List<Protocol>
+  ) {
+    if (!sslSocketClass.isInstance(sslSocket)) {
+      return  // No TLS extensions if the socket class is custom.
+    }
+    try {
+      // Enable SNI and session tickets.
+      if (hostname != null) {
+        setUseSessionTickets.invoke(sslSocket, true)
+        // This is SSLParameters.setServerNames() in API 24+.
+        setHostname.invoke(sslSocket, hostname)
+      }
+
+      // Enable ALPN.
+      setAlpnProtocols.invoke(sslSocket, concatLengthPrefixed(protocols))
+    } catch (e: IllegalAccessException) {
+      throw AssertionError(e)
+    } catch (e: InvocationTargetException) {
+      throw AssertionError(e)
+    }
+  }
+
+  override fun getSelectedProtocol(socket: SSLSocket): String? {
+    return if (sslSocketClass.isInstance(socket))
+      try {
+        val alpnResult = getAlpnSelectedProtocol.invoke(socket) as ByteArray?
+        if (alpnResult != null) String(alpnResult, UTF_8) else null
+      } catch (e: IllegalAccessException) {
+        throw AssertionError(e)
+      } catch (e: InvocationTargetException) {
+        throw AssertionError(e)
+      }
+    else {
+      null // No TLS extensions if the socket class is custom.
+    }
+  }
+
+  override fun log(level: Int, message: String, t: Throwable?) {
+    var logMessage = message
+    val logLevel = if (level == WARN) Log.WARN else Log.DEBUG
+    if (t != null) logMessage = logMessage + '\n'.toString() + Log.getStackTraceString(t)
+
+    // Split by line, then ensure each line can fit into Log's maximum length.
+    var i = 0
+    val length = logMessage.length
+    while (i < length) {
+      var newline = logMessage.indexOf('\n', i)
+      newline = if (newline != -1) newline else length
+      do {
+        val end = Math.min(newline, i + MAX_LOG_LENGTH)
+        Log.println(logLevel, "OkHttp", logMessage.substring(i, end))
+        i = end
+      } while (i < newline)
+      i++
+    }
+  }
+
+  override fun getStackTraceForCloseable(closer: String): Any? = closeGuard.createAndOpen(closer)
+
+  override fun logCloseableLeak(message: String, stackTrace: Any?) {
+    val reported = closeGuard.warnIfOpen(stackTrace)
+    if (!reported) {
+      // Unable to report via CloseGuard. As a last-ditch effort, send it to the logger.
+      log(WARN, message, null)
+    }
+  }
+
+  override fun isCleartextTrafficPermitted(hostname: String): Boolean {
+    return try {
+      val networkPolicyClass = Class.forName("android.security.NetworkSecurityPolicy")
+      val getInstanceMethod = networkPolicyClass.getMethod("getInstance")
+      val networkSecurityPolicy = getInstanceMethod.invoke(null)
+      api24IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy)
+    } catch (e: ClassNotFoundException) {
+      super.isCleartextTrafficPermitted(hostname)
+    } catch (e: NoSuchMethodException) {
+      super.isCleartextTrafficPermitted(hostname)
+    } catch (e: IllegalAccessException) {
+      throw AssertionError("unable to determine cleartext support", e)
+    } catch (e: IllegalArgumentException) {
+      throw AssertionError("unable to determine cleartext support", e)
+    } catch (e: InvocationTargetException) {
+      throw AssertionError("unable to determine cleartext support", e)
+    }
+  }
+
+  @Throws(InvocationTargetException::class, IllegalAccessException::class)
+  private fun api24IsCleartextTrafficPermitted(
+    hostname: String, networkPolicyClass: Class<*>,
+    networkSecurityPolicy: Any
+  ): Boolean = try {
+    val isCleartextTrafficPermittedMethod = networkPolicyClass
+        .getMethod("isCleartextTrafficPermitted", String::class.java)
+    isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy, hostname) as Boolean
+  } catch (e: NoSuchMethodException) {
+    api23IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy)
+  }
+
+  @Throws(InvocationTargetException::class, IllegalAccessException::class)
+  private fun api23IsCleartextTrafficPermitted(
+    hostname: String, networkPolicyClass: Class<*>,
+    networkSecurityPolicy: Any
+  ): Boolean = try {
+    val isCleartextTrafficPermittedMethod = networkPolicyClass
+        .getMethod("isCleartextTrafficPermitted")
+    isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy) as Boolean
+  } catch (e: NoSuchMethodException) {
+    super.isCleartextTrafficPermitted(hostname)
+  }
+
+  override fun buildCertificateChainCleaner(trustManager: X509TrustManager): CertificateChainCleaner =
+      try {
+        val extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions")
+        val constructor = extensionsClass.getConstructor(X509TrustManager::class.java)
+        val extensions = constructor.newInstance(trustManager)
+        val checkServerTrusted = extensionsClass.getMethod(
+            "checkServerTrusted", Array<X509Certificate>::class.java, String::class.java,
+            String::class.java)
+        AndroidCertificateChainCleaner(extensions, checkServerTrusted)
+      } catch (e: Exception) {
+        super.buildCertificateChainCleaner(trustManager)
+      }
+
+  override fun buildTrustRootIndex(trustManager: X509TrustManager): TrustRootIndex = try {
+    // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
+    // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
+    val method = trustManager.javaClass.getDeclaredMethod(
+        "findTrustAnchorByIssuerAndSignature", X509Certificate::class.java)
+    method.isAccessible = true
+    CustomTrustRootIndex(trustManager, method)
+  } catch (e: NoSuchMethodException) {
+    super.buildTrustRootIndex(trustManager)
+  }
+
+  /**
+   * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
+   * This is the best way to get a clean chain on Android because it uses the same code as the TLS
+   * handshake.
+   */
+  internal class AndroidCertificateChainCleaner(
+    private val x509TrustManagerExtensions: Any,
+    private val checkServerTrusted: Method
+  ) : CertificateChainCleaner() {
+
+    @Suppress("UNCHECKED_CAST")
+    @Throws(SSLPeerUnverifiedException::class)
+    override// Reflection on List<Certificate>.
+    fun clean(chain: List<Certificate>, hostname: String): List<Certificate> = try {
+      val certificates = (chain as List<X509Certificate>).toTypedArray()
+      checkServerTrusted.invoke(
+          x509TrustManagerExtensions, certificates, "RSA", hostname) as List<Certificate>
+    } catch (e: InvocationTargetException) {
+      val exception = SSLPeerUnverifiedException(e.message)
+      exception.initCause(e)
+      throw exception
+    } catch (e: IllegalAccessException) {
+      throw AssertionError(e)
+    }
+
+    override fun equals(other: Any?): Boolean =
+        other is AndroidCertificateChainCleaner // All instances are equivalent.
+
+    override fun hashCode(): Int = 0
+  }
+
+  /**
+   * Provides access to the internal dalvik.system.CloseGuard class. Android uses this in
+   * combination with android.os.StrictMode to report on leaked java.io.Closeable's. Available since
+   * Android API 11.
+   */
+  internal class CloseGuard(
+    private val getMethod: Method?,
+    private val openMethod: Method?,
+    private val warnIfOpenMethod: Method?
+  ) {
+
+    fun createAndOpen(closer: String): Any? {
+      if (getMethod != null) {
+        try {
+          val closeGuardInstance = getMethod.invoke(null)
+          openMethod!!.invoke(closeGuardInstance, closer)
+          return closeGuardInstance
+        } catch (ignored: Exception) {
+        }
+      }
+      return null
+    }
+
+    fun warnIfOpen(closeGuardInstance: Any?): Boolean {
+      var reported = false
+      if (closeGuardInstance != null) {
+        try {
+          warnIfOpenMethod!!.invoke(closeGuardInstance)
+          reported = true
+        } catch (ignored: Exception) {
+        }
+      }
+      return reported
+    }
+
+    companion object {
+      fun get(): CloseGuard {
+        var getMethod: Method?
+        var openMethod: Method?
+        var warnIfOpenMethod: Method?
+
+        try {
+          val closeGuardClass = Class.forName("dalvik.system.CloseGuard")
+          getMethod = closeGuardClass.getMethod("get")
+          openMethod = closeGuardClass.getMethod("open", String::class.java)
+          warnIfOpenMethod = closeGuardClass.getMethod("warnIfOpen")
+        } catch (ignored: Exception) {
+          getMethod = null
+          openMethod = null
+          warnIfOpenMethod = null
+        }
+
+        return CloseGuard(getMethod, openMethod, warnIfOpenMethod)
+      }
+    }
+  }
+
+  /**
+   * A trust manager for Android applications that customize the trust manager.
+   *
+   *
+   * This class exploits knowledge of Android implementation details. This class is potentially
+   * much faster to initialize than [BasicTrustRootIndex] because it doesn't need to load and
+   * index trusted CA certificates.
+   */
+  internal data class CustomTrustRootIndex(
+    private val trustManager: X509TrustManager,
+    private val findByIssuerAndSignatureMethod: Method
+  ) : TrustRootIndex {
+
+    override fun findByIssuerAndSignature(cert: X509Certificate): X509Certificate? {
+      return try {
+        val trustAnchor = findByIssuerAndSignatureMethod.invoke(
+            trustManager, cert) as TrustAnchor
+        trustAnchor.trustedCert
+      } catch (e: IllegalAccessException) {
+        throw AssertionError("unable to get issues and signature", e)
+      } catch (e: InvocationTargetException) {
+        null
+      }
+    }
+  }
+
+  companion object {
+    private const val MAX_LOG_LENGTH = 4000
+
+    fun buildIfSupported(): Platform? {
+      // Attempt to find Android 5+ APIs.
+      val sslParametersClass: Class<*>
+      val sslSocketClass: Class<*>
+      try {
+        sslParametersClass = Class.forName("com.android.org.conscrypt.SSLParametersImpl")
+        sslSocketClass = Class.forName("com.android.org.conscrypt.OpenSSLSocketImpl")
+      } catch (ignored: ClassNotFoundException) {
+        return null // Not an Android runtime.
+      }
+
+      if (Build.VERSION.SDK_INT >= 21) {
+        try {
+          val setUseSessionTickets = sslSocketClass.getDeclaredMethod(
+              "setUseSessionTickets", Boolean::class.javaPrimitiveType)
+          val setHostname = sslSocketClass.getMethod("setHostname", String::class.java)
+          val getAlpnSelectedProtocol = sslSocketClass.getMethod("getAlpnSelectedProtocol")
+          val setAlpnProtocols = sslSocketClass.getMethod("setAlpnProtocols", ByteArray::class.java)
+          return AndroidPlatform(sslParametersClass, sslSocketClass, setUseSessionTickets,
+              setHostname, getAlpnSelectedProtocol, setAlpnProtocols)
+        } catch (ignored: NoSuchMethodException) {
+        }
+      }
+      throw IllegalStateException(
+          "Expected Android API level 21+ but was " + Build.VERSION.SDK_INT)
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java
deleted file mode 100644
index 9ed9b1d57e..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import java.security.NoSuchAlgorithmException;
-import java.security.Provider;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Protocol;
-import org.conscrypt.Conscrypt;
-import org.conscrypt.OpenSSLProvider;
-
-/**
- * Platform using Conscrypt (conscrypt.org) if installed as the first Security Provider.
- *
- * Requires org.conscrypt:conscrypt-openjdk-uber on the classpath.
- */
-public class ConscryptPlatform extends Platform {
-  private ConscryptPlatform() {
-  }
-
-  private Provider getProvider() {
-    return new OpenSSLProvider();
-  }
-
-  @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
-    if (!Conscrypt.isConscrypt(sslSocketFactory)) {
-      return super.trustManager(sslSocketFactory);
-    }
-
-    try {
-      // org.conscrypt.SSLParametersImpl
-      Object sp =
-          readFieldOrNull(sslSocketFactory, Object.class, "sslParameters");
-
-      if (sp != null) {
-        return readFieldOrNull(sp, X509TrustManager.class, "x509TrustManager");
-      }
-
-      return null;
-    } catch (Exception e) {
-      throw new UnsupportedOperationException(
-          "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on Conscrypt", e);
-    }
-  }
-
-  @Override public void configureTlsExtensions(
-      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-    if (Conscrypt.isConscrypt(sslSocket)) {
-      // Enable SNI and session tickets.
-      if (hostname != null) {
-        Conscrypt.setUseSessionTickets(sslSocket, true);
-        Conscrypt.setHostname(sslSocket, hostname);
-      }
-
-      // Enable ALPN.
-      List<String> names = Platform.alpnProtocolNames(protocols);
-      Conscrypt.setApplicationProtocols(sslSocket, names.toArray(new String[0]));
-    } else {
-      super.configureTlsExtensions(sslSocket, hostname, protocols);
-    }
-  }
-
-  @Override public @Nullable String getSelectedProtocol(SSLSocket sslSocket) {
-    if (Conscrypt.isConscrypt(sslSocket)) {
-      return Conscrypt.getApplicationProtocol(sslSocket);
-    } else {
-      return super.getSelectedProtocol(sslSocket);
-    }
-  }
-
-  @Override public SSLContext getSSLContext() {
-    try {
-      return SSLContext.getInstance("TLS", getProvider());
-    } catch (NoSuchAlgorithmException e) {
-      throw new IllegalStateException("No TLS provider", e);
-    }
-  }
-
-  public static Platform buildIfSupported() {
-    try {
-      // trigger early exception over a fatal error
-      Class.forName("org.conscrypt.ConscryptEngineSocket");
-
-      if (!Conscrypt.isAvailable()) {
-        return null;
-      }
-
-      return new ConscryptPlatform();
-    } catch (ClassNotFoundException e) {
-      return null;
-    }
-  }
-
-  @Override
-  public void configureSslSocketFactory(SSLSocketFactory socketFactory) {
-    if (Conscrypt.isConscrypt(socketFactory)) {
-      Conscrypt.setUseEngineSocket(socketFactory, true);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt
new file mode 100644
index 0000000000..e6e0962696
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.kt
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform
+
+import okhttp3.Protocol
+import org.conscrypt.Conscrypt
+import java.security.NoSuchAlgorithmException
+import java.security.Provider
+import javax.net.ssl.SSLContext
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Platform using Conscrypt (conscrypt.org) if installed as the first Security Provider.
+ *
+ * Requires org.conscrypt:conscrypt-openjdk-uber on the classpath.
+ */
+class ConscryptPlatform private constructor() : Platform() {
+
+  @Suppress("DEPRECATION")
+  private val provider: Provider
+    // defaults to true, but allow for older versions of conscrypt if still compatible
+    // new form with boolean is only present in >= 2.0.0
+    get() = Conscrypt.newProviderBuilder().provideTrustManager().build()
+
+  override fun getSSLContext(): SSLContext {
+    // Allow for Conscrypt 1.2
+    return try {
+      SSLContext.getInstance("TLSv1.3", provider)
+    } catch (e: NoSuchAlgorithmException) {
+      try {
+        SSLContext.getInstance("TLS", provider)
+      } catch (e2: NoSuchAlgorithmException) {
+        throw IllegalStateException("No TLS provider", e)
+      }
+    }
+  }
+
+  public override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? =
+      if (!Conscrypt.isConscrypt(sslSocketFactory)) {
+        super.trustManager(sslSocketFactory)
+      } else {
+        try {
+          // org.conscrypt.SSLParametersImpl
+          val sp = readFieldOrNull(sslSocketFactory, Any::class.java, "sslParameters")
+
+          when {
+            sp != null -> readFieldOrNull(sp, X509TrustManager::class.java, "x509TrustManager")
+            else -> null
+          }
+        } catch (e: Exception) {
+          throw UnsupportedOperationException(
+              "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on Conscrypt", e)
+        }
+      }
+
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket, hostname: String?, protocols: List<Protocol>
+  ) {
+    if (Conscrypt.isConscrypt(sslSocket)) {
+      // Enable SNI and session tickets.
+      if (hostname != null) {
+        Conscrypt.setUseSessionTickets(sslSocket, true)
+        Conscrypt.setHostname(sslSocket, hostname)
+      }
+
+      // Enable ALPN.
+      val names = alpnProtocolNames(protocols)
+      Conscrypt.setApplicationProtocols(sslSocket, names.toTypedArray())
+    } else {
+      super.configureTlsExtensions(sslSocket, hostname, protocols)
+    }
+  }
+
+  override fun getSelectedProtocol(socket: SSLSocket): String? =
+      if (Conscrypt.isConscrypt(socket)) {
+        Conscrypt.getApplicationProtocol(socket)
+      } else {
+        super.getSelectedProtocol(socket)
+      }
+
+  override fun configureSslSocketFactory(socketFactory: SSLSocketFactory) {
+    if (Conscrypt.isConscrypt(socketFactory)) {
+      Conscrypt.setUseEngineSocket(socketFactory, true)
+    }
+  }
+
+  companion object {
+    @JvmStatic
+    fun buildIfSupported(): ConscryptPlatform? = try {
+      // Trigger an early exception over a fatal error, prefer a RuntimeException over Error.
+      Class.forName("org.conscrypt.Conscrypt")
+
+      when {
+        Conscrypt.isAvailable() -> ConscryptPlatform()
+        else -> null
+      }
+    } catch (e: ClassNotFoundException) {
+      null
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt
new file mode 100644
index 0000000000..a3b78c8b00
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatform.kt
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform
+
+import okhttp3.Protocol
+import java.lang.reflect.InvocationHandler
+import java.lang.reflect.InvocationTargetException
+import java.lang.reflect.Method
+import java.lang.reflect.Proxy
+import javax.net.ssl.SSLSocket
+
+/** OpenJDK 8 with `org.mortbay.jetty.alpn:alpn-boot` in the boot class path.  */
+class Jdk8WithJettyBootPlatform(
+  private val putMethod: Method, private val getMethod: Method, private val removeMethod: Method,
+  private val clientProviderClass: Class<*>, private val serverProviderClass: Class<*>
+) : Platform() {
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket, hostname: String?, protocols: List<Protocol>
+  ) {
+    val names = alpnProtocolNames(protocols)
+
+    try {
+      val alpnProvider = Proxy.newProxyInstance(Platform::class.java.classLoader,
+          arrayOf(clientProviderClass, serverProviderClass), AlpnProvider(names))
+      putMethod.invoke(null, sslSocket, alpnProvider)
+    } catch (e: InvocationTargetException) {
+      throw AssertionError("failed to set ALPN", e)
+    } catch (e: IllegalAccessException) {
+      throw AssertionError("failed to set ALPN", e)
+    }
+  }
+
+  override fun afterHandshake(sslSocket: SSLSocket) {
+    try {
+      removeMethod.invoke(null, sslSocket)
+    } catch (e: IllegalAccessException) {
+      throw AssertionError("failed to remove ALPN", e)
+    } catch (e: InvocationTargetException) {
+      throw AssertionError("failed to remove ALPN", e)
+    }
+
+  }
+
+  override fun getSelectedProtocol(socket: SSLSocket): String? {
+    try {
+      val provider = Proxy.getInvocationHandler(getMethod.invoke(null, socket)) as AlpnProvider
+      if (!provider.unsupported && provider.selected == null) {
+        Platform.get().log(INFO,
+            "ALPN callback dropped: HTTP/2 is disabled. " + "Is alpn-boot on the boot class path?",
+            null)
+        return null
+      }
+      return if (provider.unsupported) null else provider.selected
+    } catch (e: InvocationTargetException) {
+      throw AssertionError("failed to get ALPN selected protocol", e)
+    } catch (e: IllegalAccessException) {
+      throw AssertionError("failed to get ALPN selected protocol", e)
+    }
+  }
+
+  /**
+   * Handle the methods of ALPN's ClientProvider and ServerProvider without a compile-time
+   * dependency on those interfaces.
+   */
+  private class AlpnProvider internal constructor(
+    /** This peer's supported protocols.  */
+    private val protocols: List<String>
+  ) : InvocationHandler {
+    /** Set when remote peer notifies ALPN is unsupported.  */
+    internal var unsupported: Boolean = false
+    /** The protocol the server selected.  */
+    internal var selected: String? = null
+
+    @Throws(Throwable::class)
+    override fun invoke(proxy: Any, method: Method, args: Array<Any>?): Any? {
+      val callArgs = args ?: arrayOf<Any?>()
+      val methodName = method.name
+      val returnType = method.returnType
+      if (methodName == "supports" && Boolean::class.javaPrimitiveType == returnType) {
+        return true // ALPN is supported.
+      } else if (methodName == "unsupported" && Void.TYPE == returnType) {
+        this.unsupported = true // Peer doesn't support ALPN.
+        return null
+      } else if (methodName == "protocols" && callArgs.isEmpty()) {
+        return protocols // Client advertises these protocols.
+      } else if ((methodName == "selectProtocol" || methodName == "select")
+          && String::class.java == returnType && callArgs.size == 1 && callArgs[0] is List<*>) {
+        val peerProtocols = callArgs[0] as List<*>
+        // Pick the first known protocol the peer advertises.
+        for (i in 0..peerProtocols.size) {
+          val protocol = peerProtocols[i] as String
+          if (protocols.contains(protocol)) {
+            selected = protocol
+            return selected
+          }
+        }
+        selected = protocols[0] // On no intersection, try peer's first protocol.
+        return selected
+      } else if ((methodName == "protocolSelected" || methodName == "selected") && callArgs.size == 1) {
+        this.selected = callArgs[0] as String // Server selected this protocol.
+        return null
+      } else {
+        return method.invoke(this, *callArgs)
+      }
+    }
+  }
+
+  companion object {
+    @JvmStatic
+    fun buildIfSupported(): Platform? {
+      // Find Jetty's ALPN extension for OpenJDK.
+      try {
+        val alpnClassName = "org.eclipse.jetty.alpn.ALPN"
+        val alpnClass = Class.forName(alpnClassName, true, null)
+        val providerClass = Class.forName("$alpnClassName\$Provider", true, null)
+        val clientProviderClass = Class.forName("$alpnClassName\$ClientProvider", true, null)
+        val serverProviderClass = Class.forName("$alpnClassName\$ServerProvider", true, null)
+        val putMethod = alpnClass.getMethod("put", SSLSocket::class.java, providerClass)
+        val getMethod = alpnClass.getMethod("get", SSLSocket::class.java)
+        val removeMethod = alpnClass.getMethod("remove", SSLSocket::class.java)
+        return Jdk8WithJettyBootPlatform(
+            putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass)
+      } catch (ignored: ClassNotFoundException) {
+      } catch (ignored: NoSuchMethodException) {
+      }
+
+      return null
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
deleted file mode 100644
index 455e8bcbb8..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLParameters;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Protocol;
-
-import static okhttp3.internal.Util.assertionError;
-
-/**
- * OpenJDK 9+.
- */
-final class Jdk9Platform extends Platform {
-  final Method setProtocolMethod;
-  final Method getProtocolMethod;
-
-  Jdk9Platform(Method setProtocolMethod, Method getProtocolMethod) {
-    this.setProtocolMethod = setProtocolMethod;
-    this.getProtocolMethod = getProtocolMethod;
-  }
-
-  @Override
-  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
-      List<Protocol> protocols) {
-    try {
-      SSLParameters sslParameters = sslSocket.getSSLParameters();
-
-      List<String> names = alpnProtocolNames(protocols);
-
-      setProtocolMethod.invoke(sslParameters,
-          new Object[] {names.toArray(new String[names.size()])});
-
-      sslSocket.setSSLParameters(sslParameters);
-    } catch (IllegalAccessException | InvocationTargetException e) {
-      throw assertionError("unable to set ssl parameters", e);
-    }
-  }
-
-  @Override
-  public @Nullable String getSelectedProtocol(SSLSocket socket) {
-    try {
-      String protocol = (String) getProtocolMethod.invoke(socket);
-
-      // SSLSocket.getApplicationProtocol returns "" if application protocols values will not
-      // be used. Observed if you didn't specify SSLParameters.setApplicationProtocols
-      if (protocol == null || protocol.equals("")) {
-        return null;
-      }
-
-      return protocol;
-    } catch (IllegalAccessException | InvocationTargetException e) {
-      throw assertionError("unable to get selected protocols", e);
-    }
-  }
-
-  @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
-    // Not supported due to access checks on JDK 9+:
-    // java.lang.reflect.InaccessibleObjectException: Unable to make member of class
-    // sun.security.ssl.SSLSocketFactoryImpl accessible:  module java.base does not export
-    // sun.security.ssl to unnamed module @xxx
-    throw new UnsupportedOperationException(
-        "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on JDK 9+");
-  }
-
-  public static Jdk9Platform buildIfSupported() {
-    // Find JDK 9 new methods
-    try {
-      Method setProtocolMethod =
-          SSLParameters.class.getMethod("setApplicationProtocols", String[].class);
-      Method getProtocolMethod = SSLSocket.class.getMethod("getApplicationProtocol");
-
-      return new Jdk9Platform(setProtocolMethod, getProtocolMethod);
-    } catch (NoSuchMethodException ignored) {
-      // pre JDK 9
-    }
-
-    return null;
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.kt
new file mode 100644
index 0000000000..7d42f627b8
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.kt
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform
+
+import java.lang.reflect.InvocationTargetException
+import java.lang.reflect.Method
+import javax.net.ssl.SSLParameters
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+import okhttp3.Protocol
+
+/** OpenJDK 9+.  */
+class Jdk9Platform(
+  @JvmField val setProtocolMethod: Method,
+  @JvmField val getProtocolMethod: Method
+) : Platform() {
+  override fun configureTlsExtensions(
+    sslSocket: SSLSocket, hostname: String?,
+    protocols: List<Protocol>
+  ) {
+    try {
+      val sslParameters = sslSocket.sslParameters
+
+      val names = alpnProtocolNames(protocols)
+
+      setProtocolMethod.invoke(sslParameters, names.toTypedArray())
+
+      sslSocket.sslParameters = sslParameters
+    } catch (e: IllegalAccessException) {
+      throw AssertionError("failed to set SSL parameters", e)
+    } catch (e: InvocationTargetException) {
+      throw AssertionError("failed to set SSL parameters", e)
+    }
+  }
+
+  override fun getSelectedProtocol(socket: SSLSocket): String? = try {
+    val protocol = getProtocolMethod.invoke(socket) as String?
+
+    // SSLSocket.getApplicationProtocol returns "" if application protocols values will not
+    // be used. Observed if you didn't specify SSLParameters.setApplicationProtocols
+    when (protocol) {
+      null, "" -> null
+      else -> protocol
+    }
+  } catch (e: IllegalAccessException) {
+    throw AssertionError("failed to get ALPN selected protocol", e)
+  } catch (e: InvocationTargetException) {
+    throw AssertionError("failed to get ALPN selected protocol", e)
+  }
+
+  public override fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {
+    // Not supported due to access checks on JDK 9+:
+    // java.lang.reflect.InaccessibleObjectException: Unable to make member of class
+    // sun.security.ssl.SSLSocketFactoryImpl accessible:  module java.base does not export
+    // sun.security.ssl to unnamed module @xxx
+    throw UnsupportedOperationException(
+        "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on JDK 9+")
+  }
+
+  companion object {
+    @JvmStatic
+    fun buildIfSupported(): Jdk9Platform? =
+        try {
+          // Find JDK 9 methods
+          val setProtocolMethod = SSLParameters::class.java.getMethod("setApplicationProtocols",
+              Array<String>::class.java)
+          val getProtocolMethod = SSLSocket::class.java.getMethod("getApplicationProtocol")
+
+          Jdk9Platform(setProtocolMethod, getProtocolMethod)
+        } catch (ignored: NoSuchMethodException) {
+          // pre JDK 9
+          null
+        }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
deleted file mode 100644
index dee0b3fe53..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
-import java.util.List;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLSocket;
-import okhttp3.Protocol;
-import okhttp3.internal.Util;
-
-import static okhttp3.internal.Util.assertionError;
-
-/**
- * OpenJDK 7 or OpenJDK 8 with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
- */
-class JdkWithJettyBootPlatform extends Platform {
-  private final Method putMethod;
-  private final Method getMethod;
-  private final Method removeMethod;
-  private final Class<?> clientProviderClass;
-  private final Class<?> serverProviderClass;
-
-  JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
-      Class<?> clientProviderClass, Class<?> serverProviderClass) {
-    this.putMethod = putMethod;
-    this.getMethod = getMethod;
-    this.removeMethod = removeMethod;
-    this.clientProviderClass = clientProviderClass;
-    this.serverProviderClass = serverProviderClass;
-  }
-
-  @Override public void configureTlsExtensions(
-      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
-    List<String> names = alpnProtocolNames(protocols);
-
-    try {
-      Object provider = Proxy.newProxyInstance(Platform.class.getClassLoader(),
-          new Class[] {clientProviderClass, serverProviderClass}, new JettyNegoProvider(names));
-      putMethod.invoke(null, sslSocket, provider);
-    } catch (InvocationTargetException | IllegalAccessException e) {
-      throw assertionError("unable to set alpn", e);
-    }
-  }
-
-  @Override public void afterHandshake(SSLSocket sslSocket) {
-    try {
-      removeMethod.invoke(null, sslSocket);
-    } catch (IllegalAccessException | InvocationTargetException e) {
-      throw assertionError("unable to remove alpn", e);
-    }
-  }
-
-  @Override public @Nullable String getSelectedProtocol(SSLSocket socket) {
-    try {
-      JettyNegoProvider provider =
-          (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
-      if (!provider.unsupported && provider.selected == null) {
-        Platform.get().log(INFO, "ALPN callback dropped: HTTP/2 is disabled. "
-            + "Is alpn-boot on the boot class path?", null);
-        return null;
-      }
-      return provider.unsupported ? null : provider.selected;
-    } catch (InvocationTargetException | IllegalAccessException e) {
-      throw assertionError("unable to get selected protocol", e);
-    }
-  }
-
-  public static Platform buildIfSupported() {
-    // Find Jetty's ALPN extension for OpenJDK.
-    try {
-      String negoClassName = "org.eclipse.jetty.alpn.ALPN";
-      Class<?> negoClass = Class.forName(negoClassName);
-      Class<?> providerClass = Class.forName(negoClassName + "$Provider");
-      Class<?> clientProviderClass = Class.forName(negoClassName + "$ClientProvider");
-      Class<?> serverProviderClass = Class.forName(negoClassName + "$ServerProvider");
-      Method putMethod = negoClass.getMethod("put", SSLSocket.class, providerClass);
-      Method getMethod = negoClass.getMethod("get", SSLSocket.class);
-      Method removeMethod = negoClass.getMethod("remove", SSLSocket.class);
-      return new JdkWithJettyBootPlatform(
-          putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);
-    } catch (ClassNotFoundException | NoSuchMethodException ignored) {
-    }
-
-    return null;
-  }
-
-  /**
-   * Handle the methods of ALPN's ClientProvider and ServerProvider without a compile-time
-   * dependency on those interfaces.
-   */
-  private static class JettyNegoProvider implements InvocationHandler {
-    /** This peer's supported protocols. */
-    private final List<String> protocols;
-    /** Set when remote peer notifies ALPN is unsupported. */
-    boolean unsupported;
-    /** The protocol the server selected. */
-    String selected;
-
-    JettyNegoProvider(List<String> protocols) {
-      this.protocols = protocols;
-    }
-
-    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-      String methodName = method.getName();
-      Class<?> returnType = method.getReturnType();
-      if (args == null) {
-        args = Util.EMPTY_STRING_ARRAY;
-      }
-      if (methodName.equals("supports") && boolean.class == returnType) {
-        return true; // ALPN is supported.
-      } else if (methodName.equals("unsupported") && void.class == returnType) {
-        this.unsupported = true; // Peer doesn't support ALPN.
-        return null;
-      } else if (methodName.equals("protocols") && args.length == 0) {
-        return protocols; // Client advertises these protocols.
-      } else if ((methodName.equals("selectProtocol") || methodName.equals("select"))
-          && String.class == returnType && args.length == 1 && args[0] instanceof List) {
-        List<String> peerProtocols = (List) args[0];
-        // Pick the first known protocol the peer advertises.
-        for (int i = 0, size = peerProtocols.size(); i < size; i++) {
-          if (protocols.contains(peerProtocols.get(i))) {
-            return selected = peerProtocols.get(i);
-          }
-        }
-        return selected = protocols.get(0); // On no intersection, try peer's first protocol.
-      } else if ((methodName.equals("protocolSelected") || methodName.equals("selected"))
-          && args.length == 1) {
-        this.selected = (String) args[0]; // Server selected this protocol.
-        return null;
-      } else {
-        return method.invoke(this, args);
-      }
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java b/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
deleted file mode 100644
index c26132fedb..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package okhttp3.internal.platform;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-
-/**
- * Duck-typing for methods: Represents a method that may or may not be present on an object.
- *
- * @param <T> the type of the object the method might be on, typically an interface or base class
- */
-class OptionalMethod<T> {
-
-  /** The return type of the method. null means "don't care". */
-  private final Class<?> returnType;
-
-  private final String methodName;
-
-  private final Class[] methodParams;
-
-  /**
-   * Creates an optional method.
-   *
-   * @param returnType the return type to required, null if it does not matter
-   * @param methodName the name of the method
-   * @param methodParams the method parameter types
-   */
-  OptionalMethod(Class<?> returnType, String methodName, Class... methodParams) {
-    this.returnType = returnType;
-    this.methodName = methodName;
-    this.methodParams = methodParams;
-  }
-
-  /**
-   * Returns true if the method exists on the supplied {@code target}.
-   */
-  public boolean isSupported(T target) {
-    return getMethod(target.getClass()) != null;
-  }
-
-  /**
-   * Invokes the method on {@code target} with {@code args}. If the method does not exist or is not
-   * public then {@code null} is returned. See also {@link #invokeOptionalWithoutCheckedException}.
-   *
-   * @throws IllegalArgumentException if the arguments are invalid
-   * @throws InvocationTargetException if the invocation throws an exception
-   */
-  public Object invokeOptional(T target, Object... args) throws InvocationTargetException {
-    Method m = getMethod(target.getClass());
-    if (m == null) {
-      return null;
-    }
-    try {
-      return m.invoke(target, args);
-    } catch (IllegalAccessException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Invokes the method on {@code target}.  If the method does not exist or is not public then
-   * {@code null} is returned. Any RuntimeException thrown by the method is thrown, checked
-   * exceptions are wrapped in an {@link AssertionError}.
-   *
-   * @throws IllegalArgumentException if the arguments are invalid
-   */
-  public Object invokeOptionalWithoutCheckedException(T target, Object... args) {
-    try {
-      return invokeOptional(target, args);
-    } catch (InvocationTargetException e) {
-      Throwable targetException = e.getTargetException();
-      if (targetException instanceof RuntimeException) {
-        throw (RuntimeException) targetException;
-      }
-      AssertionError error = new AssertionError("Unexpected exception");
-      error.initCause(targetException);
-      throw error;
-    }
-  }
-
-  /**
-   * Invokes the method on {@code target} with {@code args}. Throws an error if the method is not
-   * supported. See also {@link #invokeWithoutCheckedException(Object, Object...)}.
-   *
-   * @throws IllegalArgumentException if the arguments are invalid
-   * @throws InvocationTargetException if the invocation throws an exception
-   */
-  public Object invoke(T target, Object... args) throws InvocationTargetException {
-    Method m = getMethod(target.getClass());
-    if (m == null) {
-      throw new AssertionError("Method " + methodName + " not supported for object " + target);
-    }
-    try {
-      return m.invoke(target, args);
-    } catch (IllegalAccessException e) {
-      // Method should be public: we checked.
-      AssertionError error = new AssertionError("Unexpectedly could not call: " + m);
-      error.initCause(e);
-      throw error;
-    }
-  }
-
-  /**
-   * Invokes the method on {@code target}. Throws an error if the method is not supported. Any
-   * RuntimeException thrown by the method is thrown, checked exceptions are wrapped in an {@link
-   * AssertionError}.
-   *
-   * @throws IllegalArgumentException if the arguments are invalid
-   */
-  public Object invokeWithoutCheckedException(T target, Object... args) {
-    try {
-      return invoke(target, args);
-    } catch (InvocationTargetException e) {
-      Throwable targetException = e.getTargetException();
-      if (targetException instanceof RuntimeException) {
-        throw (RuntimeException) targetException;
-      }
-      AssertionError error = new AssertionError("Unexpected exception");
-      error.initCause(targetException);
-      throw error;
-    }
-  }
-
-  /**
-   * Perform a lookup for the method. No caching. In order to return a method the method name and
-   * arguments must match those specified when the {@link OptionalMethod} was created. If the return
-   * type is specified (i.e. non-null) it must also be compatible. The method must also be public.
-   */
-  private Method getMethod(Class<?> clazz) {
-    Method method = null;
-    if (methodName != null) {
-      method = getPublicMethod(clazz, methodName, methodParams);
-      if (method != null
-          && returnType != null
-          && !returnType.isAssignableFrom(method.getReturnType())) {
-
-        // If the return type is non-null it must be compatible.
-        method = null;
-      }
-    }
-    return method;
-  }
-
-  private static Method getPublicMethod(Class<?> clazz, String methodName, Class[] parameterTypes) {
-    Method method = null;
-    try {
-      method = clazz.getMethod(methodName, parameterTypes);
-      if ((method.getModifiers() & Modifier.PUBLIC) == 0) {
-        method = null;
-      }
-    } catch (NoSuchMethodException e) {
-      // None.
-    }
-    return method;
-  }
-}
-
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
deleted file mode 100644
index 1a5311f63c..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
+++ /dev/null
@@ -1,281 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import java.io.IOException;
-import java.lang.reflect.Field;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.security.NoSuchAlgorithmException;
-import java.security.Security;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.internal.tls.BasicCertificateChainCleaner;
-import okhttp3.internal.tls.BasicTrustRootIndex;
-import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.internal.tls.TrustRootIndex;
-import okio.Buffer;
-
-/**
- * Access to platform-specific features.
- *
- * <h3>Server name indication (SNI)</h3>
- *
- * <p>Supported on Android 2.3+.
- *
- * Supported on OpenJDK 7+
- *
- * <h3>Session Tickets</h3>
- *
- * <p>Supported on Android 2.3+.
- *
- * <h3>Android Traffic Stats (Socket Tagging)</h3>
- *
- * <p>Supported on Android 4.0+.
- *
- * <h3>ALPN (Application Layer Protocol Negotiation)</h3>
- *
- * <p>Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
- * unstable.
- *
- * Supported on OpenJDK 7 and 8 (via the JettyALPN-boot library).
- *
- * Supported on OpenJDK 9 via SSLParameters and SSLSocket features.
- *
- * <h3>Trust Manager Extraction</h3>
- *
- * <p>Supported on Android 2.3+ and OpenJDK 7+. There are no public APIs to recover the trust
- * manager that was used to create an {@link SSLSocketFactory}.
- *
- * <h3>Android Cleartext Permit Detection</h3>
- *
- * <p>Supported on Android 6.0+ via {@code NetworkSecurityPolicy}.
- */
-public class Platform {
-  private static final Platform PLATFORM = findPlatform();
-  public static final int INFO = 4;
-  public static final int WARN = 5;
-  private static final Logger logger = Logger.getLogger(OkHttpClient.class.getName());
-
-  public static Platform get() {
-    return PLATFORM;
-  }
-
-  /** Prefix used on custom headers. */
-  public String getPrefix() {
-    return "OkHttp";
-  }
-
-  protected X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
-    // Attempt to get the trust manager from an OpenJDK socket factory. We attempt this on all
-    // platforms in order to support Robolectric, which mixes classes from both Android and the
-    // Oracle JDK. Note that we don't support HTTP/2 or other nice features on Robolectric.
-    try {
-      Class<?> sslContextClass = Class.forName("sun.security.ssl.SSLContextImpl");
-      Object context = readFieldOrNull(sslSocketFactory, sslContextClass, "context");
-      if (context == null) return null;
-      return readFieldOrNull(context, X509TrustManager.class, "trustManager");
-    } catch (ClassNotFoundException e) {
-      return null;
-    }
-  }
-
-  /**
-   * Configure TLS extensions on {@code sslSocket} for {@code route}.
-   *
-   * @param hostname non-null for client-side handshakes; null for server-side handshakes.
-   */
-  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
-      List<Protocol> protocols) {
-  }
-
-  /**
-   * Called after the TLS handshake to release resources allocated by {@link
-   * #configureTlsExtensions}.
-   */
-  public void afterHandshake(SSLSocket sslSocket) {
-  }
-
-  /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  public @Nullable String getSelectedProtocol(SSLSocket socket) {
-    return null;
-  }
-
-  public void connectSocket(Socket socket, InetSocketAddress address,
-      int connectTimeout) throws IOException {
-    socket.connect(address, connectTimeout);
-  }
-
-  public void log(int level, String message, Throwable t) {
-    Level logLevel = level == WARN ? Level.WARNING : Level.INFO;
-    logger.log(logLevel, message, t);
-  }
-
-  public boolean isCleartextTrafficPermitted(String hostname) {
-    return true;
-  }
-
-  /**
-   * Returns an object that holds a stack trace created at the moment this method is executed. This
-   * should be used specifically for {@link java.io.Closeable} objects and in conjunction with
-   * {@link #logCloseableLeak(String, Object)}.
-   */
-  public Object getStackTraceForCloseable(String closer) {
-    if (logger.isLoggable(Level.FINE)) {
-      return new Throwable(closer); // These are expensive to allocate.
-    }
-    return null;
-  }
-
-  public void logCloseableLeak(String message, Object stackTrace) {
-    if (stackTrace == null) {
-      message += " To see where this was allocated, set the OkHttpClient logger level to FINE: "
-          + "Logger.getLogger(OkHttpClient.class.getName()).setLevel(Level.FINE);";
-    }
-    log(WARN, message, (Throwable) stackTrace);
-  }
-
-  public static List<String> alpnProtocolNames(List<Protocol> protocols) {
-    List<String> names = new ArrayList<>(protocols.size());
-    for (int i = 0, size = protocols.size(); i < size; i++) {
-      Protocol protocol = protocols.get(i);
-      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
-      names.add(protocol.toString());
-    }
-    return names;
-  }
-
-  public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
-    return new BasicCertificateChainCleaner(buildTrustRootIndex(trustManager));
-  }
-
-  public CertificateChainCleaner buildCertificateChainCleaner(SSLSocketFactory sslSocketFactory) {
-    X509TrustManager trustManager = trustManager(sslSocketFactory);
-
-    if (trustManager == null) {
-      throw new IllegalStateException("Unable to extract the trust manager on " + Platform.get()
-          + ", sslSocketFactory is " + sslSocketFactory.getClass());
-    }
-
-    return buildCertificateChainCleaner(trustManager);
-  }
-
-  public static boolean isConscryptPreferred() {
-    // mainly to allow tests to run cleanly
-    if ("conscrypt".equals(System.getProperty("okhttp.platform"))) {
-      return true;
-    }
-
-    // check if Provider manually installed
-    String preferredProvider = Security.getProviders()[0].getName();
-    return "Conscrypt".equals(preferredProvider);
-  }
-
-  /** Attempt to match the host runtime to a capable Platform implementation. */
-  private static Platform findPlatform() {
-    Platform android = AndroidPlatform.buildIfSupported();
-
-    if (android != null) {
-      return android;
-    }
-
-    if (isConscryptPreferred()) {
-      Platform conscrypt = ConscryptPlatform.buildIfSupported();
-
-      if (conscrypt != null) {
-        return conscrypt;
-      }
-    }
-
-    Platform jdk9 = Jdk9Platform.buildIfSupported();
-
-    if (jdk9 != null) {
-      return jdk9;
-    }
-
-    Platform jdkWithJettyBoot = JdkWithJettyBootPlatform.buildIfSupported();
-
-    if (jdkWithJettyBoot != null) {
-      return jdkWithJettyBoot;
-    }
-
-    // Probably an Oracle JDK like OpenJDK.
-    return new Platform();
-  }
-
-  /**
-   * Returns the concatenation of 8-bit, length prefixed protocol names.
-   * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
-   */
-  static byte[] concatLengthPrefixed(List<Protocol> protocols) {
-    Buffer result = new Buffer();
-    for (int i = 0, size = protocols.size(); i < size; i++) {
-      Protocol protocol = protocols.get(i);
-      if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for ALPN.
-      result.writeByte(protocol.toString().length());
-      result.writeUtf8(protocol.toString());
-    }
-    return result.readByteArray();
-  }
-
-  static <T> T readFieldOrNull(Object instance, Class<T> fieldType, String fieldName) {
-    for (Class<?> c = instance.getClass(); c != Object.class; c = c.getSuperclass()) {
-      try {
-        Field field = c.getDeclaredField(fieldName);
-        field.setAccessible(true);
-        Object value = field.get(instance);
-        if (value == null || !fieldType.isInstance(value)) return null;
-        return fieldType.cast(value);
-      } catch (NoSuchFieldException ignored) {
-      } catch (IllegalAccessException e) {
-        throw new AssertionError();
-      }
-    }
-
-    // Didn't find the field we wanted. As a last gasp attempt, try to find the value on a delegate.
-    if (!fieldName.equals("delegate")) {
-      Object delegate = readFieldOrNull(instance, Object.class, "delegate");
-      if (delegate != null) return readFieldOrNull(delegate, fieldType, fieldName);
-    }
-
-    return null;
-  }
-
-  public SSLContext getSSLContext() {
-    try {
-      return SSLContext.getInstance("TLS");
-    } catch (NoSuchAlgorithmException e) {
-      throw new IllegalStateException("No TLS provider", e);
-    }
-  }
-
-  public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
-    return new BasicTrustRootIndex(trustManager.getAcceptedIssuers());
-  }
-
-  public void configureSslSocketFactory(SSLSocketFactory socketFactory) {
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt b/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
new file mode 100644
index 0000000000..f467d5652a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Platform.kt
@@ -0,0 +1,267 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform
+
+import okhttp3.OkHttpClient
+import okhttp3.Protocol
+import okhttp3.internal.Util
+import okhttp3.internal.tls.BasicCertificateChainCleaner
+import okhttp3.internal.tls.BasicTrustRootIndex
+import okhttp3.internal.tls.CertificateChainCleaner
+import okhttp3.internal.tls.TrustRootIndex
+import okio.Buffer
+import java.io.IOException
+import java.net.InetSocketAddress
+import java.net.Socket
+import java.security.NoSuchAlgorithmException
+import java.security.Security
+import java.util.logging.Level
+import java.util.logging.Logger
+import javax.net.ssl.SSLContext
+import javax.net.ssl.SSLSocket
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+
+/**
+ * Access to platform-specific features.
+ *
+ * <h3>Server name indication (SNI)</h3>
+ *
+ * Supported on Android 2.3+.
+ *
+ * Supported on OpenJDK 7+
+ *
+ * <h3>Session Tickets</h3>
+ *
+ * Supported on Android 2.3+.
+ *
+ * <h3>Android Traffic Stats (Socket Tagging)</h3>
+ *
+ * Supported on Android 4.0+.
+ *
+ * <h3>ALPN (Application Layer Protocol Negotiation)</h3>
+ *
+ * Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was
+ * unstable.
+ *
+ * Supported on OpenJDK 8 via the JettyALPN-boot library.
+ *
+ * Supported on OpenJDK 9+ via SSLParameters and SSLSocket features.
+ *
+ * <h3>Trust Manager Extraction</h3>
+ *
+ * Supported on Android 2.3+ and OpenJDK 7+. There are no public APIs to recover the trust
+ * manager that was used to create an [SSLSocketFactory].
+ *
+ * <h3>Android Cleartext Permit Detection</h3>
+ *
+ * Supported on Android 6.0+ via `NetworkSecurityPolicy`.
+ */
+open class Platform {
+
+  /** Prefix used on custom headers.  */
+  fun getPrefix() = "OkHttp"
+
+  open fun getSSLContext(): SSLContext = try {
+    SSLContext.getInstance("TLS")
+  } catch (e: NoSuchAlgorithmException) {
+    throw IllegalStateException("No TLS provider", e)
+  }
+
+  protected open fun trustManager(sslSocketFactory: SSLSocketFactory): X509TrustManager? {
+    return try {
+      // Attempt to get the trust manager from an OpenJDK socket factory. We attempt this on all
+      // platforms in order to support Robolectric, which mixes classes from both Android and the
+      // Oracle JDK. Note that we don't support HTTP/2 or other nice features on Robolectric.
+      val sslContextClass = Class.forName("sun.security.ssl.SSLContextImpl")
+      val context = readFieldOrNull(sslSocketFactory, sslContextClass, "context") ?: return null
+      readFieldOrNull(context, X509TrustManager::class.java, "trustManager")
+    } catch (e: ClassNotFoundException) {
+      null
+    }
+  }
+
+  /**
+   * Configure TLS extensions on `sslSocket` for `route`.
+   *
+   * @param hostname non-null for client-side handshakes; null for server-side handshakes.
+   */
+  open fun configureTlsExtensions(
+    sslSocket: SSLSocket, hostname: String?,
+    protocols: List<@JvmSuppressWildcards Protocol>
+  ) {
+  }
+
+  /** Called after the TLS handshake to release resources allocated by [configureTlsExtensions]. */
+  open fun afterHandshake(sslSocket: SSLSocket) {}
+
+  /** Returns the negotiated protocol, or null if no protocol was negotiated.  */
+  open fun getSelectedProtocol(socket: SSLSocket): String? = null
+
+  @Throws(IOException::class)
+  open fun connectSocket(socket: Socket, address: InetSocketAddress, connectTimeout: Int) {
+    socket.connect(address, connectTimeout)
+  }
+
+  open fun log(level: Int, message: String, t: Throwable?) {
+    val logLevel = if (level == WARN) Level.WARNING else Level.INFO
+    logger.log(logLevel, message, t)
+  }
+
+  open fun isCleartextTrafficPermitted(hostname: String): Boolean = true
+
+  /**
+   * Returns an object that holds a stack trace created at the moment this method is executed. This
+   * should be used specifically for [java.io.Closeable] objects and in conjunction with
+   * [logCloseableLeak].
+   */
+  open fun getStackTraceForCloseable(closer: String): Any? =
+      when {
+        logger.isLoggable(Level.FINE) -> Throwable(closer) // These are expensive to allocate.
+        else -> null
+      }
+
+  open fun logCloseableLeak(message: String, stackTrace: Any?) {
+    var logMessage = message
+    if (stackTrace == null) {
+      logMessage += " To see where this was allocated, set the OkHttpClient logger level to FINE: " +
+          "Logger.getLogger(OkHttpClient.class.getName()).setLevel(Level.FINE);"
+    }
+    log(WARN, logMessage, stackTrace as Throwable?)
+  }
+
+  open fun buildCertificateChainCleaner(trustManager: X509TrustManager): CertificateChainCleaner =
+      BasicCertificateChainCleaner(buildTrustRootIndex(trustManager))
+
+  fun buildCertificateChainCleaner(sslSocketFactory: SSLSocketFactory): CertificateChainCleaner {
+    val trustManager = trustManager(sslSocketFactory) ?: throw IllegalStateException(
+        "Unable to extract the trust manager on "
+            + get()
+            + ", sslSocketFactory is "
+            + sslSocketFactory.javaClass)
+
+    return buildCertificateChainCleaner(trustManager)
+  }
+
+  open fun buildTrustRootIndex(trustManager: X509TrustManager): TrustRootIndex =
+      BasicTrustRootIndex(*trustManager.acceptedIssuers)
+
+  open fun configureSslSocketFactory(socketFactory: SSLSocketFactory) {}
+
+  override fun toString(): String = javaClass.simpleName
+
+  companion object {
+    private val PLATFORM = findPlatform()
+
+    const val INFO = 4
+    const val WARN = 5
+
+    private val logger = Logger.getLogger(OkHttpClient::class.java.name)
+
+    @JvmStatic
+    fun get(): Platform = PLATFORM
+
+    fun alpnProtocolNames(protocols: List<Protocol>) =
+        protocols.filter { it != Protocol.HTTP_1_0 }.map { it.toString() }
+
+    // mainly to allow tests to run cleanly
+    // check if Provider manually installed
+    @JvmStatic
+    val isConscryptPreferred: Boolean
+      get() {
+        if ("conscrypt" == Util.getSystemProperty("okhttp.platform", null)) {
+          return true
+        }
+        val preferredProvider = Security.getProviders()[0].name
+        return "Conscrypt" == preferredProvider
+      }
+
+    /** Attempt to match the host runtime to a capable Platform implementation.  */
+    @JvmStatic
+    private fun findPlatform(): Platform {
+      val android = AndroidPlatform.buildIfSupported()
+
+      if (android != null) {
+        return android
+      }
+
+      if (isConscryptPreferred) {
+        val conscrypt = ConscryptPlatform.buildIfSupported()
+
+        if (conscrypt != null) {
+          return conscrypt
+        }
+      }
+
+      val jdk9 = Jdk9Platform.buildIfSupported()
+
+      if (jdk9 != null) {
+        return jdk9
+      }
+
+      val jdkWithJettyBoot = Jdk8WithJettyBootPlatform.buildIfSupported()
+
+      return if (jdkWithJettyBoot != null) {
+        jdkWithJettyBoot
+      } else {
+        // Probably an Oracle JDK like OpenJDK.
+        Platform()
+      }
+    }
+
+    /**
+     * Returns the concatenation of 8-bit, length prefixed protocol names.
+     * http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04#page-4
+     */
+    @JvmStatic
+    fun concatLengthPrefixed(protocols: List<Protocol>): ByteArray {
+      val result = Buffer()
+      alpnProtocolNames(protocols).forEach { protocol ->
+        result.writeByte(protocol.length)
+        result.writeUtf8(protocol)
+      }
+      return result.readByteArray()
+    }
+
+    @JvmStatic
+    fun <T> readFieldOrNull(instance: Any, fieldType: Class<T>, fieldName: String): T? {
+      var c: Class<*> = instance.javaClass
+      while (c != Any::class.java) {
+        try {
+          val field = c.getDeclaredField(fieldName)
+          field.isAccessible = true
+          val value = field.get(instance)
+          return if (!fieldType.isInstance(value)) null else fieldType.cast(value)
+        } catch (ignored: NoSuchFieldException) {
+        } catch (e: IllegalAccessException) {
+          throw AssertionError()
+        }
+
+        c = c.superclass
+      }
+
+      // Didn't find the field we wanted. As a last gasp attempt,
+      // try to find the value on a delegate.
+      if (fieldName != "delegate") {
+        val delegate = readFieldOrNull(instance, Any::class.java, "delegate")
+        if (delegate != null) return readFieldOrNull(delegate, fieldType, fieldName)
+      }
+
+      return null
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java b/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java
similarity index 50%
rename from okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
rename to okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java
index 03e8ce08e9..d18b6335f1 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/SingleInetAddressDns.java
+++ b/okhttp/src/main/java/okhttp3/internal/proxy/NullProxySelector.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Square, Inc.
+ * Copyright (C) 2018 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,21 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal;
+package okhttp3.internal.proxy;
 
-import java.net.InetAddress;
-import java.net.UnknownHostException;
+import java.io.IOException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
 import java.util.Collections;
 import java.util.List;
-import okhttp3.Dns;
 
 /**
- * A network that resolves only one IP address per host. Use this when testing route selection
- * fallbacks to prevent the host machine's various IP addresses from interfering.
+ * A proxy selector that always returns the {@link Proxy#NO_PROXY}.
  */
-public class SingleInetAddressDns implements Dns {
-  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-    List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
-    return Collections.singletonList(addresses.get(0));
+public class NullProxySelector extends ProxySelector {
+  @Override public List<Proxy> select(URI uri) {
+    if (uri == null) {
+      throw new IllegalArgumentException("uri must not be null");
+    }
+    return Collections.singletonList(Proxy.NO_PROXY);
+  }
+
+  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
index 75dafdd0a3..74fbd89b79 100644
--- a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
@@ -21,13 +21,12 @@
 import java.net.IDN;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
-import okhttp3.internal.Util;
 import okhttp3.internal.platform.Platform;
 import okio.BufferedSource;
 import okio.GzipSource;
 import okio.Okio;
 
-import static okhttp3.internal.Util.closeQuietly;
+import static java.nio.charset.StandardCharsets.UTF_8;
 
 /**
  * A database of public suffixes provided by
@@ -63,12 +62,14 @@ public static PublicSuffixDatabase get() {
 
   /**
    * Returns the effective top-level domain plus one (eTLD+1) by referencing the public suffix list.
-   * Returns null if the domain is a public suffix.
+   * Returns null if the domain is a public suffix or a private address.
    *
    * <p>Here are some examples: <pre>{@code
    * assertEquals("google.com", getEffectiveTldPlusOne("google.com"));
    * assertEquals("google.com", getEffectiveTldPlusOne("www.google.com"));
    * assertNull(getEffectiveTldPlusOne("com"));
+   * assertNull(getEffectiveTldPlusOne("localhost"));
+   * assertNull(getEffectiveTldPlusOne("mymacbook"));
    * }</pre>
    *
    * @param domain A canonicalized domain. An International Domain Name (IDN) should be punycode
@@ -112,6 +113,7 @@ public String getEffectiveTldPlusOne(String domain) {
       try {
         readCompleteLatch.await();
       } catch (InterruptedException ignored) {
+        Thread.currentThread().interrupt(); // Retain interrupted status.
       }
     }
 
@@ -125,7 +127,7 @@ public String getEffectiveTldPlusOne(String domain) {
     // Break apart the domain into UTF-8 labels, i.e. foo.bar.com turns into [foo, bar, com].
     byte[][] domainLabelsUtf8Bytes = new byte[domainLabels.length][];
     for (int i = 0; i < domainLabels.length; i++) {
-      domainLabelsUtf8Bytes[i] = domainLabels[i].getBytes(Util.UTF_8);
+      domainLabelsUtf8Bytes[i] = domainLabels[i].getBytes(UTF_8);
     }
 
     // Start by looking for exact matches. We start at the leftmost label. For example, foo.bar.com
@@ -268,7 +270,7 @@ private static String binarySearchBytes(byte[] bytesToSearch, byte[][] labels, i
           low = mid + end + 1;
         } else {
           // Found a match.
-          match = new String(bytesToSearch, mid, publicSuffixLength, Util.UTF_8);
+          match = new String(bytesToSearch, mid, publicSuffixLength, UTF_8);
           break;
         }
       }
@@ -289,6 +291,7 @@ private void readTheListUninterruptibly() {
           readTheList();
           return;
         } catch (InterruptedIOException e) {
+          Thread.interrupted(); // Temporarily clear the interrupted state.
           interrupted = true;
         } catch (IOException e) {
           Platform.get().log(Platform.WARN, "Failed to read public suffix list", e);
@@ -297,7 +300,7 @@ private void readTheListUninterruptibly() {
       }
     } finally {
       if (interrupted) {
-        Thread.currentThread().interrupt();
+        Thread.currentThread().interrupt(); // Retain interrupted status.
       }
     }
   }
@@ -309,8 +312,7 @@ private void readTheList() throws IOException {
     InputStream resource = PublicSuffixDatabase.class.getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
     if (resource == null) return;
 
-    BufferedSource bufferedSource = Okio.buffer(new GzipSource(Okio.source(resource)));
-    try {
+    try (BufferedSource bufferedSource = Okio.buffer(new GzipSource(Okio.source(resource)))) {
       int totalBytes = bufferedSource.readInt();
       publicSuffixListBytes = new byte[totalBytes];
       bufferedSource.readFully(publicSuffixListBytes);
@@ -318,8 +320,6 @@ private void readTheList() throws IOException {
       int totalExceptionBytes = bufferedSource.readInt();
       publicSuffixExceptionListBytes = new byte[totalExceptionBytes];
       bufferedSource.readFully(publicSuffixExceptionListBytes);
-    } finally {
-      closeQuietly(bufferedSource);
     }
 
     synchronized (this) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.kt
similarity index 71%
rename from okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java
rename to okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.kt
index 60b893fbf3..3586029bb4 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/UnrepeatableRequestBody.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.kt
@@ -13,7 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.http;
+package okhttp3.internal.tls
 
-public interface UnrepeatableRequestBody {
+import java.security.cert.X509Certificate
+
+interface TrustRootIndex {
+  /** Returns the trusted CA certificate that signed [cert].  */
+  fun findByIssuerAndSignature(cert: X509Certificate): X509Certificate?
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
index 092dc5775e..d056ad67e2 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -39,7 +39,7 @@
 import okhttp3.WebSocketListener;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
-import okhttp3.internal.connection.StreamAllocation;
+import okhttp3.internal.connection.Exchange;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -153,14 +153,12 @@ public RealWebSocket(Request request, WebSocketListener listener, Random random,
     random.nextBytes(nonce);
     this.key = ByteString.of(nonce).base64();
 
-    this.writerRunnable = new Runnable() {
-      @Override public void run() {
-        try {
-          while (writeOneFrame()) {
-          }
-        } catch (IOException e) {
-          failWebSocket(e, null);
+    this.writerRunnable = () -> {
+      try {
+        while (writeOneFrame()) {
         }
+      } catch (IOException e) {
+        failWebSocket(e, null);
       }
     };
   }
@@ -191,25 +189,23 @@ public void connect(OkHttpClient client) {
     call = Internal.instance.newWebSocketCall(client, request);
     call.enqueue(new Callback() {
       @Override public void onResponse(Call call, Response response) {
+        Exchange exchange = Internal.instance.exchange(response);
+        Streams streams;
         try {
-          checkResponse(response);
-        } catch (ProtocolException e) {
+          checkUpgradeSuccess(response, exchange);
+          streams = exchange.newWebSocketStreams();
+        } catch (IOException e) {
+          if (exchange != null) exchange.webSocketUpgradeFailed();
           failWebSocket(e, response);
           closeQuietly(response);
           return;
         }
 
-        // Promote the HTTP streams into web socket streams.
-        StreamAllocation streamAllocation = Internal.instance.streamAllocation(call);
-        streamAllocation.noNewStreams(); // Prevent connection pooling!
-        Streams streams = streamAllocation.connection().newWebSocketStreams(streamAllocation);
-
         // Process all web socket messages.
         try {
-          listener.onOpen(RealWebSocket.this, response);
           String name = "OkHttp WebSocket " + request.url().redact();
           initReaderAndWriter(name, streams);
-          streamAllocation.connection().socket().setSoTimeout(0);
+          listener.onOpen(RealWebSocket.this, response);
           loopReader();
         } catch (Exception e) {
           failWebSocket(e, null);
@@ -222,7 +218,7 @@ public void connect(OkHttpClient client) {
     });
   }
 
-  void checkResponse(Response response) throws ProtocolException {
+  void checkUpgradeSuccess(Response response, @Nullable Exchange exchange) throws IOException {
     if (response.code() != 101) {
       throw new ProtocolException("Expected HTTP 101 response but was '"
           + response.code() + " " + response.message() + "'");
@@ -247,6 +243,10 @@ void checkResponse(Response response) throws ProtocolException {
       throw new ProtocolException("Expected 'Sec-WebSocket-Accept' header value '"
           + acceptExpected + "' but was '" + headerAccept + "'");
     }
+
+    if (exchange == null) {
+      throw new ProtocolException("Web Socket exchange missing: bad interceptor?");
+    }
   }
 
   public void initReaderAndWriter(String name, Streams streams) throws IOException {
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
index baffe06b19..3ba1204987 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -246,7 +246,6 @@ void writeMessageFrame(int formatOpcode, long byteCount, boolean isFirstFrame,
       return sink.timeout();
     }
 
-    @SuppressWarnings("PointlessBitwiseExpression")
     @Override public void close() throws IOException {
       if (closed) throw new IOException("closed");
 
diff --git a/okhttp/src/main/java/okhttp3/package-info.java b/okhttp/src/main/java/okhttp3/package-info.java
index a34c5bbf86..725b054363 100644
--- a/okhttp/src/main/java/okhttp3/package-info.java
+++ b/okhttp/src/main/java/okhttp3/package-info.java
@@ -1,3 +1,3 @@
 /** An HTTP+HTTP/2 client for Android and Java applications. */
-@javax.annotation.ParametersAreNonnullByDefault
+@okhttp3.internal.annotations.EverythingIsNonNull
 package okhttp3;
diff --git a/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro b/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
new file mode 100644
index 0000000000..0c6f707575
--- /dev/null
+++ b/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
@@ -0,0 +1,11 @@
+# JSR 305 annotations are for embedding nullability information.
+-dontwarn javax.annotation.**
+
+# A resource is loaded with a relative path so the package of this class must be preserved.
+-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase
+
+# Animal Sniffer compileOnly dependency to ensure APIs are compatible with older versions of Java.
+-dontwarn org.codehaus.mojo.animal_sniffer.*
+
+# OkHttp platform used only on JVM and when Conscrypt dependency is available.
+-dontwarn okhttp3.internal.platform.ConscryptPlatform
diff --git a/okhttp/src/main/resources/okhttp3/internal/publicsuffix/NOTICE b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/NOTICE
new file mode 100644
index 0000000000..94973fde8a
--- /dev/null
+++ b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/NOTICE
@@ -0,0 +1,5 @@
+Note that publicsuffixes.gz is compiled from The Public Suffix List:
+https://publicsuffix.org/list/public_suffix_list.dat
+
+It is subject to the terms of the Mozilla Public License, v. 2.0:
+https://mozilla.org/MPL/2.0/
diff --git a/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz
index 3d9b2c9ccf..795e941ae6 100644
Binary files a/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz and b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz differ
diff --git a/okhttp-tests/src/test/java/okhttp3/AddressTest.java b/okhttp/src/test/java/okhttp3/AddressTest.java
similarity index 86%
rename from okhttp-tests/src/test/java/okhttp3/AddressTest.java
rename to okhttp/src/test/java/okhttp3/AddressTest.java
index ad07b78241..9d3bf4165b 100644
--- a/okhttp-tests/src/test/java/okhttp3/AddressTest.java
+++ b/okhttp/src/test/java/okhttp3/AddressTest.java
@@ -22,8 +22,7 @@
 import okhttp3.internal.http.RecordingProxySelector;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class AddressTest {
   private Dns dns = Dns.SYSTEM;
@@ -38,8 +37,8 @@
         authenticator, null, protocols, connectionSpecs, proxySelector);
     Address b = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, proxySelector);
-    assertEquals(a, b);
-    assertEquals(a.hashCode(), b.hashCode());
+    assertThat(b).isEqualTo(a);
+    assertThat(b.hashCode()).isEqualTo(a.hashCode());
   }
 
   @Test public void differentProxySelectorsAreDifferent() throws Exception {
@@ -47,19 +46,20 @@
         authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
     Address b = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
-    assertFalse(a.equals(b));
+    assertThat(b).isNotEqualTo(a);
   }
 
   @Test public void addressToString() throws Exception {
     Address address = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, proxySelector);
-    assertEquals("Address{square.com:80, proxySelector=RecordingProxySelector}",
-        address.toString());
+    assertThat(address.toString()).isEqualTo(
+        "Address{square.com:80, proxySelector=RecordingProxySelector}");
   }
 
   @Test public void addressWithProxyToString() throws Exception {
     Address address = new Address("square.com", 80, dns, socketFactory, null, null, null,
         authenticator, Proxy.NO_PROXY, protocols, connectionSpecs, proxySelector);
-    assertEquals("Address{square.com:80, proxy=" + Proxy.NO_PROXY + "}", address.toString());
+    assertThat(address.toString()).isEqualTo(
+        "Address{square.com:80, proxy=" + Proxy.NO_PROXY + "}");
   }
 }
diff --git a/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java b/okhttp/src/test/java/okhttp3/AutobahnTester.java
similarity index 100%
rename from okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
rename to okhttp/src/test/java/okhttp3/AutobahnTester.java
diff --git a/okhttp/src/test/java/okhttp3/CacheControlTest.java b/okhttp/src/test/java/okhttp3/CacheControlTest.java
new file mode 100644
index 0000000000..e0f37e952b
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/CacheControlTest.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.util.concurrent.TimeUnit;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CacheControlTest {
+  @Test public void emptyBuilderIsEmpty() throws Exception {
+    CacheControl cacheControl = new CacheControl.Builder().build();
+    assertThat(cacheControl.toString()).isEqualTo("");
+    assertThat(cacheControl.noCache()).isFalse();
+    assertThat(cacheControl.noStore()).isFalse();
+    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.isPrivate()).isFalse();
+    assertThat(cacheControl.isPublic()).isFalse();
+    assertThat(cacheControl.mustRevalidate()).isFalse();
+    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.minFreshSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.onlyIfCached()).isFalse();
+    assertThat(cacheControl.mustRevalidate()).isFalse();
+  }
+
+  @Test public void completeBuilder() throws Exception {
+    CacheControl cacheControl = new CacheControl.Builder()
+        .noCache()
+        .noStore()
+        .maxAge(1, TimeUnit.SECONDS)
+        .maxStale(2, TimeUnit.SECONDS)
+        .minFresh(3, TimeUnit.SECONDS)
+        .onlyIfCached()
+        .noTransform()
+        .immutable()
+        .build();
+    assertThat(cacheControl.toString()).isEqualTo(
+        ("no-cache, no-store, max-age=1, max-stale=2, min-fresh=3, only-if-cached, "
+        + "no-transform, immutable"));
+    assertThat(cacheControl.noCache()).isTrue();
+    assertThat(cacheControl.noStore()).isTrue();
+    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(1);
+    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(2);
+    assertThat(cacheControl.minFreshSeconds()).isEqualTo(3);
+    assertThat(cacheControl.onlyIfCached()).isTrue();
+    assertThat(cacheControl.noTransform()).isTrue();
+    assertThat(cacheControl.immutable()).isTrue();
+
+    // These members are accessible to response headers only.
+    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.isPrivate()).isFalse();
+    assertThat(cacheControl.isPublic()).isFalse();
+    assertThat(cacheControl.mustRevalidate()).isFalse();
+  }
+
+  @Test public void parseEmpty() throws Exception {
+    CacheControl cacheControl = CacheControl.parse(
+        new Headers.Builder().set("Cache-Control", "").build());
+    assertThat(cacheControl.toString()).isEqualTo("");
+    assertThat(cacheControl.noCache()).isFalse();
+    assertThat(cacheControl.noStore()).isFalse();
+    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.isPublic()).isFalse();
+    assertThat(cacheControl.mustRevalidate()).isFalse();
+    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.minFreshSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.onlyIfCached()).isFalse();
+    assertThat(cacheControl.mustRevalidate()).isFalse();
+  }
+
+  @Test public void parse() throws Exception {
+    String header = "no-cache, no-store, max-age=1, s-maxage=2, private, public, must-revalidate, "
+        + "max-stale=3, min-fresh=4, only-if-cached, no-transform";
+    CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
+        .set("Cache-Control", header)
+        .build());
+    assertThat(cacheControl.noCache()).isTrue();
+    assertThat(cacheControl.noStore()).isTrue();
+    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(1);
+    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(2);
+    assertThat(cacheControl.isPrivate()).isTrue();
+    assertThat(cacheControl.isPublic()).isTrue();
+    assertThat(cacheControl.mustRevalidate()).isTrue();
+    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(3);
+    assertThat(cacheControl.minFreshSeconds()).isEqualTo(4);
+    assertThat(cacheControl.onlyIfCached()).isTrue();
+    assertThat(cacheControl.noTransform()).isTrue();
+    assertThat(cacheControl.toString()).isEqualTo(header);
+  }
+
+  @Test public void parseIgnoreCacheControlExtensions() throws Exception {
+    // Example from http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.6
+    String header = "private, community=\"UCI\"";
+    CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
+        .set("Cache-Control", header)
+        .build());
+    assertThat(cacheControl.noCache()).isFalse();
+    assertThat(cacheControl.noStore()).isFalse();
+    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.isPrivate()).isTrue();
+    assertThat(cacheControl.isPublic()).isFalse();
+    assertThat(cacheControl.mustRevalidate()).isFalse();
+    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.minFreshSeconds()).isEqualTo(-1);
+    assertThat(cacheControl.onlyIfCached()).isFalse();
+    assertThat(cacheControl.noTransform()).isFalse();
+    assertThat(cacheControl.immutable()).isFalse();
+    assertThat(cacheControl.toString()).isEqualTo(header);
+  }
+
+  @Test public void parseCacheControlAndPragmaAreCombined() {
+    Headers headers =
+        Headers.of("Cache-Control", "max-age=12", "Pragma", "must-revalidate", "Pragma", "public");
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertThat(cacheControl.toString()).isEqualTo("max-age=12, public, must-revalidate");
+  }
+
+  @SuppressWarnings("RedundantStringConstructorCall") // Testing instance equality.
+  @Test public void parseCacheControlHeaderValueIsRetained() {
+    String value = new String("max-age=12");
+    Headers headers = Headers.of("Cache-Control", value);
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertThat(cacheControl.toString()).isSameAs(value);
+  }
+
+  @Test public void parseCacheControlHeaderValueInvalidatedByPragma() {
+    Headers headers = Headers.of(
+        "Cache-Control", "max-age=12",
+        "Pragma", "must-revalidate"
+    );
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertThat(cacheControl.toString()).isEqualTo("max-age=12, must-revalidate");
+  }
+
+  @Test public void parseCacheControlHeaderValueInvalidatedByTwoValues() {
+    Headers headers = Headers.of(
+        "Cache-Control", "max-age=12",
+        "Cache-Control", "must-revalidate"
+    );
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertThat(cacheControl.toString()).isEqualTo("max-age=12, must-revalidate");
+  }
+
+  @Test public void parsePragmaHeaderValueIsNotRetained() {
+    Headers headers = Headers.of("Pragma", "must-revalidate");
+    CacheControl cacheControl = CacheControl.parse(headers);
+    assertThat(cacheControl.toString()).isEqualTo("must-revalidate");
+  }
+
+  @Test public void computedHeaderValueIsCached() {
+    CacheControl cacheControl = new CacheControl.Builder()
+        .maxAge(2, TimeUnit.DAYS)
+        .build();
+    assertThat(cacheControl.toString()).isEqualTo("max-age=172800");
+    assertThat(cacheControl.toString()).isSameAs(cacheControl.toString());
+  }
+
+  @Test public void timeDurationTruncatedToMaxValue() throws Exception {
+    CacheControl cacheControl = new CacheControl.Builder()
+        .maxAge(365 * 100, TimeUnit.DAYS) // Longer than Integer.MAX_VALUE seconds.
+        .build();
+    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(Integer.MAX_VALUE);
+  }
+
+  @Test public void secondsMustBeNonNegative() throws Exception {
+    CacheControl.Builder builder = new CacheControl.Builder();
+    try {
+      builder.maxAge(-1, TimeUnit.SECONDS);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void timePrecisionIsTruncatedToSeconds() throws Exception {
+    CacheControl cacheControl = new CacheControl.Builder()
+        .maxAge(4999, TimeUnit.MILLISECONDS)
+        .build();
+    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(4);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp/src/test/java/okhttp3/CacheTest.java
similarity index 76%
rename from okhttp-tests/src/test/java/okhttp3/CacheTest.java
rename to okhttp/src/test/java/okhttp3/CacheTest.java
index 1537717124..e39fb55e1a 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ b/okhttp/src/test/java/okhttp3/CacheTest.java
@@ -34,14 +34,13 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
-import okhttp3.internal.Internal;
+import okhttp3.internal.InternalKtKt;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.internal.platform.Platform;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -52,27 +51,22 @@
 import org.junit.Rule;
 import org.junit.Test;
 
-import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.internal.InternalKtKt.cacheGet;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 import static org.junit.Assert.fail;
 
 public final class CacheTest {
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
-    @Override public boolean verify(String s, SSLSession sslSession) {
-      return true;
-    }
-  };
+  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = (name, session) -> true;
 
   @Rule public MockWebServer server = new MockWebServer();
   @Rule public MockWebServer server2 = new MockWebServer();
   @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
-  private final SslClient sslClient = SslClient.localhost();
+  private final HandshakeCertificates handshakeCertificates = localhost();
   private OkHttpClient client;
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
@@ -80,7 +74,7 @@
   @Before public void setUp() throws Exception {
     server.setProtocolNegotiationEnabled(false);
     cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-    client = defaultClient().newBuilder()
+    client = clientTestRule.client.newBuilder()
         .cache(cache)
         .cookieJar(new JavaNetCookieJar(cookieManager))
         .build();
@@ -185,17 +179,17 @@ private void assertCached(boolean shouldPut, int responseCode) throws Exception
         .url(server.url("/"))
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals(expectedResponseCode, response.code());
+    assertThat(response.code()).isEqualTo(expectedResponseCode);
 
     // Exhaust the content stream.
     response.body().string();
 
-    Response cached = cache.get(request);
+    Response cached = cacheGet(cache, request);
     if (shouldPut) {
-      assertNotNull(Integer.toString(responseCode), cached);
+      assertThat(cached).isNotNull();
       cached.body().close();
     } else {
-      assertNull(Integer.toString(responseCode), cached);
+      assertThat(cached).isNull();
     }
     server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
   }
@@ -229,45 +223,46 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Response response1 = client.newCall(request).execute();
 
     BufferedSource in1 = response1.body().source();
-    assertEquals("I love ", in1.readUtf8("I love ".length()));
+    assertThat(in1.readUtf8("I love ".length())).isEqualTo("I love ");
     in1.skip("puppies but hate ".length());
-    assertEquals("spiders", in1.readUtf8("spiders".length()));
-    assertTrue(in1.exhausted());
+    assertThat(in1.readUtf8("spiders".length())).isEqualTo("spiders");
+    assertThat(in1.exhausted()).isTrue();
     in1.close();
-    assertEquals(1, cache.writeSuccessCount());
-    assertEquals(0, cache.writeAbortCount());
+    assertThat(cache.writeSuccessCount()).isEqualTo(1);
+    assertThat(cache.writeAbortCount()).isEqualTo(0);
 
     Response response2 = client.newCall(request).execute();
     BufferedSource in2 = response2.body().source();
-    assertEquals("I love puppies but hate spiders",
-        in2.readUtf8("I love puppies but hate spiders".length()));
-    assertEquals(200, response2.code());
-    assertEquals("Fantastic", response2.message());
+    assertThat(in2.readUtf8("I love puppies but hate spiders".length())).isEqualTo(
+        "I love puppies but hate spiders");
+    assertThat(response2.code()).isEqualTo(200);
+    assertThat(response2.message()).isEqualTo("Fantastic");
 
-    assertTrue(in2.exhausted());
+    assertThat(in2.exhausted()).isTrue();
     in2.close();
-    assertEquals(1, cache.writeSuccessCount());
-    assertEquals(0, cache.writeAbortCount());
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.hitCount());
+    assertThat(cache.writeSuccessCount()).isEqualTo(1);
+    assertThat(cache.writeAbortCount()).isEqualTo(0);
+    assertThat(cache.requestCount()).isEqualTo(2);
+    assertThat(cache.hitCount()).isEqualTo(1);
   }
 
   @Test public void secureResponseCaching() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
     Request request = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request).execute();
     BufferedSource in = response1.body().source();
-    assertEquals("ABC", in.readUtf8());
+    assertThat(in.readUtf8()).isEqualTo("ABC");
 
     // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
     CipherSuite cipherSuite = response1.handshake().cipherSuite();
@@ -277,17 +272,17 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Principal localPrincipal = response1.handshake().localPrincipal();
 
     Response response2 = client.newCall(request).execute(); // Cached!
-    assertEquals("ABC", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("ABC");
 
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(1, cache.hitCount());
+    assertThat(cache.requestCount()).isEqualTo(2);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(1);
 
-    assertEquals(cipherSuite, response2.handshake().cipherSuite());
-    assertEquals(localCerts, response2.handshake().localCertificates());
-    assertEquals(serverCerts, response2.handshake().peerCertificates());
-    assertEquals(peerPrincipal, response2.handshake().peerPrincipal());
-    assertEquals(localPrincipal, response2.handshake().localPrincipal());
+    assertThat(response2.handshake().cipherSuite()).isEqualTo(cipherSuite);
+    assertThat(response2.handshake().localCertificates()).isEqualTo(localCerts);
+    assertThat(response2.handshake().peerCertificates()).isEqualTo(serverCerts);
+    assertThat(response2.handshake().peerPrincipal()).isEqualTo(peerPrincipal);
+    assertThat(response2.handshake().localPrincipal()).isEqualTo(localPrincipal);
   }
 
   @Test public void responseCachingAndRedirects() throws Exception {
@@ -305,14 +300,15 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
     Request request = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request).execute();
-    assertEquals("ABC", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("ABC");
 
     Response response2 = client.newCall(request).execute(); // Cached!
-    assertEquals("ABC", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("ABC");
 
-    assertEquals(4, cache.requestCount()); // 2 requests + 2 redirects
-    assertEquals(2, cache.networkCount());
-    assertEquals(2, cache.hitCount());
+    // 2 requests + 2 redirects
+    assertThat(cache.requestCount()).isEqualTo(4);
+    assertThat(cache.networkCount()).isEqualTo(2);
+    assertThat(cache.hitCount()).isEqualTo(2);
   }
 
   @Test public void redirectToCachedResult() throws Exception {
@@ -327,29 +323,29 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
     Request request1 = new Request.Builder().url(server.url("/foo")).build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals("ABC", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("ABC");
     RecordedRequest recordedRequest1 = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", recordedRequest1.getRequestLine());
-    assertEquals(0, recordedRequest1.getSequenceNumber());
+    assertThat(recordedRequest1.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(recordedRequest1.getSequenceNumber()).isEqualTo(0);
 
     Request request2 = new Request.Builder().url(server.url("/bar")).build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals("ABC", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("ABC");
     RecordedRequest recordedRequest2 = server.takeRequest();
-    assertEquals("GET /bar HTTP/1.1", recordedRequest2.getRequestLine());
-    assertEquals(1, recordedRequest2.getSequenceNumber());
+    assertThat(recordedRequest2.getRequestLine()).isEqualTo("GET /bar HTTP/1.1");
+    assertThat(recordedRequest2.getSequenceNumber()).isEqualTo(1);
 
     // an unrelated request should reuse the pooled connection
     Request request3 = new Request.Builder().url(server.url("/baz")).build();
     Response response3 = client.newCall(request3).execute();
-    assertEquals("DEF", response3.body().string());
+    assertThat(response3.body().string()).isEqualTo("DEF");
     RecordedRequest recordedRequest3 = server.takeRequest();
-    assertEquals("GET /baz HTTP/1.1", recordedRequest3.getRequestLine());
-    assertEquals(2, recordedRequest3.getSequenceNumber());
+    assertThat(recordedRequest3.getRequestLine()).isEqualTo("GET /baz HTTP/1.1");
+    assertThat(recordedRequest3.getSequenceNumber()).isEqualTo(2);
   }
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -363,22 +359,25 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("DEF"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
     Response response1 = get(server.url("/"));
-    assertEquals("ABC", response1.body().string());
-    assertNotNull(response1.handshake().cipherSuite());
+    assertThat(response1.body().string()).isEqualTo("ABC");
+    assertThat(response1.handshake().cipherSuite()).isNotNull();
 
     // Cached!
     Response response2 = get(server.url("/"));
-    assertEquals("ABC", response2.body().string());
-    assertNotNull(response2.handshake().cipherSuite());
+    assertThat(response2.body().string()).isEqualTo("ABC");
+    assertThat(response2.handshake().cipherSuite()).isNotNull();
 
-    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.hitCount());
-    assertEquals(response1.handshake().cipherSuite(), response2.handshake().cipherSuite());
+    // 2 direct + 2 redirect = 4
+    assertThat(cache.requestCount()).isEqualTo(4);
+    assertThat(cache.hitCount()).isEqualTo(2);
+    assertThat(response2.handshake().cipherSuite()).isEqualTo(
+        response1.handshake().cipherSuite());
   }
 
   /**
@@ -389,7 +388,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
    * https://github.com/square/okhttp/issues/214
    */
   @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslClient.socketFactory, false);
+    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server2.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -404,19 +403,21 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Location: " + server2.url("/")));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
     Response response1 = get(server.url("/"));
-    assertEquals("ABC", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("ABC");
 
     // Cached!
     Response response2 = get(server.url("/"));
-    assertEquals("ABC", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("ABC");
 
-    assertEquals(4, cache.requestCount()); // 2 direct + 2 redirect = 4
-    assertEquals(2, cache.hitCount());
+    // 2 direct + 2 redirect = 4
+    assertThat(cache.requestCount()).isEqualTo(4);
+    assertThat(cache.hitCount()).isEqualTo(2);
   }
 
   @Test public void foundCachedWithExpiresHeader() throws Exception {
@@ -458,8 +459,8 @@ private void temporaryRedirectCachedWithCachingHeader(
         .setBody("c"));
 
     HttpUrl url = server.url("/");
-    assertEquals("a", get(url).body().string());
-    assertEquals("a", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("a");
+    assertThat(get(url).body().string()).isEqualTo("a");
   }
 
   private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) throws Exception {
@@ -472,8 +473,8 @@ private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) th
         .setBody("b"));
 
     HttpUrl url = server.url("/");
-    assertEquals("a", get(url).body().string());
-    assertEquals("b", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("a");
+    assertThat(get(url).body().string()).isEqualTo("b");
   }
 
   /** https://github.com/square/okhttp/issues/2198 */
@@ -489,11 +490,11 @@ private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) th
 
     Request request1 = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals("ABC", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("ABC");
 
     Request request2 = new Request.Builder().url(server.url("/")).build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals("ABC", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("ABC");
   }
 
   @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
@@ -518,21 +519,21 @@ private void testServerPrematureDisconnect(TransferKind transferKind) throws IOE
         .setBody("Request #2"));
 
     BufferedSource bodySource = get(server.url("/")).body().source();
-    assertEquals("ABCDE", bodySource.readUtf8Line());
+    assertThat(bodySource.readUtf8Line()).isEqualTo("ABCDE");
     try {
-      bodySource.readUtf8Line();
+      bodySource.readUtf8(21);
       fail("This implementation silently ignored a truncated HTTP body.");
     } catch (IOException expected) {
     } finally {
       bodySource.close();
     }
 
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(0, cache.writeSuccessCount());
+    assertThat(cache.writeAbortCount()).isEqualTo(1);
+    assertThat(cache.writeSuccessCount()).isEqualTo(0);
     Response response = get(server.url("/"));
-    assertEquals("Request #2", response.body().string());
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(1, cache.writeSuccessCount());
+    assertThat(response.body().string()).isEqualTo("Request #2");
+    assertThat(cache.writeAbortCount()).isEqualTo(1);
+    assertThat(cache.writeSuccessCount()).isEqualTo(1);
   }
 
   @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
@@ -558,7 +559,7 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
 
     Response response1 = get(server.url("/"));
     BufferedSource in = response1.body().source();
-    assertEquals("ABCDE", in.readUtf8(5));
+    assertThat(in.readUtf8(5)).isEqualTo("ABCDE");
     in.close();
     try {
       in.readByte();
@@ -566,12 +567,12 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     } catch (IllegalStateException expected) {
     }
 
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(0, cache.writeSuccessCount());
+    assertThat(cache.writeAbortCount()).isEqualTo(1);
+    assertThat(cache.writeSuccessCount()).isEqualTo(0);
     Response response2 = get(server.url("/"));
-    assertEquals("Request #2", response2.body().string());
-    assertEquals(1, cache.writeAbortCount());
-    assertEquals(1, cache.writeSuccessCount());
+    assertThat(response2.body().string()).isEqualTo("Request #2");
+    assertThat(cache.writeAbortCount()).isEqualTo(1);
+    assertThat(cache.writeSuccessCount()).isEqualTo(1);
   }
 
   @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
@@ -586,11 +587,11 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
 
     HttpUrl url = server.url("/");
     Response response1 = get(url);
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
 
     Response response2 = get(url);
-    assertEquals("A", response2.body().string());
-    assertNull(response2.header("Warning"));
+    assertThat(response2.body().string()).isEqualTo("A");
+    assertThat(response2.header("Warning")).isNull();
   }
 
   @Test public void defaultExpirationDateConditionallyCached() throws Exception {
@@ -602,7 +603,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
+        lastModifiedDate);
   }
 
   @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
@@ -615,10 +617,11 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
         .setBody("A"));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
     Response response = get(server.url("/"));
-    assertEquals("A", response.body().string());
-    assertEquals("113 HttpURLConnection \"Heuristic expiration\"", response.header("Warning"));
+    assertThat(response.body().string()).isEqualTo("A");
+    assertThat(response.header("Warning")).isEqualTo(
+        "113 HttpURLConnection \"Heuristic expiration\"");
   }
 
   @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
@@ -630,8 +633,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .setBody("B"));
 
     HttpUrl url = server.url("/").newBuilder().addQueryParameter("foo", "bar").build();
-    assertEquals("A", get(url).body().string());
-    assertEquals("B", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("B");
   }
 
   @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
@@ -639,7 +642,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
     RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
+        lastModifiedDate);
   }
 
   @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
@@ -665,7 +669,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
         .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Cache-Control: max-age=60"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
+        lastModifiedDate);
   }
 
   @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
@@ -761,20 +766,20 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
         .build();
     Response response1 = client.newCall(request).execute();
     response1.body().close();
-    assertEquals("1", response1.header("X-Response-ID"));
+    assertThat(response1.header("X-Response-ID")).isEqualTo("1");
 
     Response response2 = get(url);
     response2.body().close();
     if (expectCached) {
-      assertEquals("1", response2.header("X-Response-ID"));
+      assertThat(response2.header("X-Response-ID")).isEqualTo("1");
     } else {
-      assertEquals("2", response2.header("X-Response-ID"));
+      assertThat(response2.header("X-Response-ID")).isEqualTo("2");
     }
   }
 
   private RequestBody requestBodyOrNull(String requestMethod) {
     return (requestMethod.equals("POST") || requestMethod.equals("PUT"))
-        ? RequestBody.create(MediaType.parse("text/plain"), "foo")
+        ? RequestBody.create(MediaType.get("text/plain"), "foo")
         : null;
   }
 
@@ -804,16 +809,16 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
     HttpUrl url = server.url("/");
 
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
 
     Request request = new Request.Builder()
         .url(url)
         .method(requestMethod, requestBodyOrNull(requestMethod))
         .build();
     Response invalidate = client.newCall(request).execute();
-    assertEquals("B", invalidate.body().string());
+    assertThat(invalidate.body().string()).isEqualTo("B");
 
-    assertEquals("C", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("C");
   }
 
   @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
@@ -831,16 +836,16 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
     HttpUrl url = server.url("/");
 
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
 
     Request request = new Request.Builder()
         .url(url)
         .method("POST", requestBodyOrNull("POST"))
         .build();
     Response invalidate = client.newCall(request).execute();
-    assertEquals("B", invalidate.body().string());
+    assertThat(invalidate.body().string()).isEqualTo("B");
 
-    assertEquals("C", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("C");
   }
 
   @Test public void putInvalidatesWithNoContentResponse() throws Exception {
@@ -858,22 +863,22 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
     HttpUrl url = server.url("/");
 
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
 
     Request request = new Request.Builder()
         .url(url)
-        .put(RequestBody.create(MediaType.parse("text/plain"), "foo"))
+        .put(RequestBody.create(MediaType.get("text/plain"), "foo"))
         .build();
     Response invalidate = client.newCall(request).execute();
-    assertEquals("", invalidate.body().string());
+    assertThat(invalidate.body().string()).isEqualTo("");
 
-    assertEquals("C", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("C");
   }
 
   @Test public void etag() throws Exception {
     RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
         .addHeader("ETag: v1"));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
+    assertThat(conditionalRequest.getHeader("If-None-Match")).isEqualTo("v1");
   }
 
   /** If both If-Modified-Since and If-None-Match conditions apply, send only If-None-Match. */
@@ -883,8 +888,8 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .addHeader("ETag: v1")
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertEquals("v1", conditionalRequest.getHeader("If-None-Match"));
-    assertNull(conditionalRequest.getHeader("If-Modified-Since"));
+    assertThat(conditionalRequest.getHeader("If-None-Match")).isEqualTo("v1");
+    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isNull();
   }
 
   @Test public void etagAndExpirationDateInTheFuture() throws Exception {
@@ -905,7 +910,8 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("Cache-Control: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
+        lastModifiedDate);
   }
 
   @Test public void pragmaNoCache() throws Exception {
@@ -919,7 +925,8 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .addHeader("Last-Modified: " + lastModifiedDate)
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("Pragma: no-cache"));
-    assertEquals(lastModifiedDate, conditionalRequest.getHeader("If-Modified-Since"));
+    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
+        lastModifiedDate);
   }
 
   @Test public void cacheControlNoStore() throws Exception {
@@ -952,9 +959,9 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .header("Range", "bytes=1000-1001")
         .build();
     Response range = client.newCall(request).execute();
-    assertEquals("AA", range.body().string());
+    assertThat(range.body().string()).isEqualTo("AA");
 
-    assertEquals("BB", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("BB");
   }
 
   /**
@@ -977,9 +984,9 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
 
     HttpUrl url = server.url("/");
 
-    assertEquals("A", get(url).body().string());
-    assertEquals("B", get(url).body().string());
-    assertEquals("B", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("B");
+    assertThat(get(url).body().string()).isEqualTo("B");
   }
 
   @Test public void clientSideNoStore() throws Exception {
@@ -995,13 +1002,13 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
         .cacheControl(new CacheControl.Builder().noStore().build())
         .build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
 
     Request request2 = new Request.Builder()
         .url(server.url("/"))
         .build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals("B", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("B");
   }
 
   @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
@@ -1028,9 +1035,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     // At least three request/response pairs are required because after the first request is cached
     // a different execution path might be taken. Thus modifications to the cache applied during
     // the second request might not be visible until another request is performed.
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
   }
 
   @Test public void previouslyNotGzippedContentIsNotModifiedAndSpecifiesGzipEncoding() throws Exception {
@@ -1046,9 +1053,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
             .setBody("DEFDEFDEF"));
 
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("DEFDEFDEF", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("DEFDEFDEF");
   }
 
   @Test public void changedGzippedContentIsNotModifiedAndSpecifiesNewEncoding() throws Exception {
@@ -1065,9 +1072,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
             .setBody("DEFDEFDEF"));
 
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("DEFDEFDEF", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("DEFDEFDEF");
   }
 
   @Test public void notModifiedSpecifiesEncoding() throws Exception {
@@ -1082,9 +1089,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("DEFDEFDEF"));
 
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("DEFDEFDEF", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("DEFDEFDEF");
   }
 
   /** https://github.com/square/okhttp/issues/947 */
@@ -1097,14 +1104,12 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("FAIL"));
 
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
-    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
   }
 
   @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
-    // Ensure that the (shared) connection pool is in a consistent state.
-    client.connectionPool().evictAll();
-    assertEquals(0, client.connectionPool().idleConnectionCount());
+    TestUtil.ensureAllConnectionsReleased(client);
 
     server.enqueue(new MockResponse()
         .addHeader("ETag: v1")
@@ -1113,9 +1118,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .clearHeaders()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, client.connectionPool().idleConnectionCount());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(1);
   }
 
   @Test public void expiresDateBeforeModifiedDate() throws Exception {
@@ -1133,14 +1138,14 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
 
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Cache-Control", "max-age=30")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
+    assertThat(response.body().string()).isEqualTo("B");
   }
 
   @Test public void requestMinFresh() throws IOException {
@@ -1151,14 +1156,14 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
 
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Cache-Control", "min-fresh=120")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
+    assertThat(response.body().string()).isEqualTo("B");
   }
 
   @Test public void requestMaxStale() throws IOException {
@@ -1169,15 +1174,16 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
 
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Cache-Control", "max-stale=180")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("A", response.body().string());
-    assertEquals("110 HttpURLConnection \"Response is stale\"", response.header("Warning"));
+    assertThat(response.body().string()).isEqualTo("A");
+    assertThat(response.header("Warning")).isEqualTo(
+        "110 HttpURLConnection \"Response is stale\"");
   }
 
   @Test public void requestMaxStaleDirectiveWithNoValue() throws IOException {
@@ -1189,7 +1195,7 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
 
     // With max-stale, we'll return that stale response.
     Request request = new Request.Builder()
@@ -1197,8 +1203,9 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .header("Cache-Control", "max-stale")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("A", response.body().string());
-    assertEquals("110 HttpURLConnection \"Response is stale\"", response.header("Warning"));
+    assertThat(response.body().string()).isEqualTo("A");
+    assertThat(response.header("Warning")).isEqualTo(
+        "110 HttpURLConnection \"Response is stale\"");
   }
 
   @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
@@ -1209,14 +1216,14 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
 
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Cache-Control", "max-stale=180")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
+    assertThat(response.body().string()).isEqualTo("B");
   }
 
   @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
@@ -1227,11 +1234,11 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
-    assertTrue(response.body().source().exhausted());
-    assertEquals(504, response.code());
-    assertEquals(1, cache.requestCount());
-    assertEquals(0, cache.networkCount());
-    assertEquals(0, cache.hitCount());
+    assertThat(response.body().source().exhausted()).isTrue();
+    assertThat(response.code()).isEqualTo(504);
+    assertThat(cache.requestCount()).isEqualTo(1);
+    assertThat(cache.networkCount()).isEqualTo(0);
+    assertThat(cache.hitCount()).isEqualTo(0);
   }
 
   @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
@@ -1240,16 +1247,16 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("A", response.body().string());
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(1, cache.hitCount());
+    assertThat(response.body().string()).isEqualTo("A");
+    assertThat(cache.requestCount()).isEqualTo(2);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(1);
   }
 
   @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
@@ -1258,34 +1265,34 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
-    assertTrue(response.body().source().exhausted());
-    assertEquals(504, response.code());
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
+    assertThat(response.body().source().exhausted()).isTrue();
+    assertThat(response.code()).isEqualTo(504);
+    assertThat(cache.requestCount()).isEqualTo(2);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(0);
   }
 
   @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("A"));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
-    assertTrue(response.body().source().exhausted());
-    assertEquals(504, response.code());
-    assertEquals(2, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
+    assertThat(response.body().source().exhausted()).isTrue();
+    assertThat(response.code()).isEqualTo(504);
+    assertThat(cache.requestCount()).isEqualTo(2);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(0);
   }
 
   @Test public void requestCacheControlNoCache() throws Exception {
@@ -1298,13 +1305,13 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .setBody("B"));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
     Request request = new Request.Builder()
         .url(url)
         .header("Cache-Control", "no-cache")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
+    assertThat(response.body().string()).isEqualTo("B");
   }
 
   @Test public void requestPragmaNoCache() throws Exception {
@@ -1317,13 +1324,13 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .setBody("B"));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
     Request request = new Request.Builder()
         .url(url)
         .header("Pragma", "no-cache")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
+    assertThat(response.body().string()).isEqualTo("B");
   }
 
   @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
@@ -1333,8 +1340,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
     RecordedRequest request =
         assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
-    assertEquals(ifModifiedSinceDate, request.getHeader("If-Modified-Since"));
-    assertNull(request.getHeader("If-None-Match"));
+    assertThat(request.getHeader("If-Modified-Since")).isEqualTo(ifModifiedSinceDate);
+    assertThat(request.getHeader("If-None-Match")).isNull();
   }
 
   @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
@@ -1344,8 +1351,8 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
         .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
         .addHeader("Cache-Control: max-age=0");
     RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
-    assertEquals("v1", request.getHeader("If-None-Match"));
-    assertNull(request.getHeader("If-Modified-Since"));
+    assertThat(request.getHeader("If-None-Match")).isEqualTo("v1");
+    assertThat(request.getHeader("If-Modified-Since")).isNull();
   }
 
   private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
@@ -1355,15 +1362,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
 
     Request request = new Request.Builder()
         .url(url)
         .header(conditionName, conditionValue)
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, response.code());
-    assertEquals("", response.body().string());
+    assertThat(response.code()).isEqualTo(HttpURLConnection.HTTP_NOT_MODIFIED);
+    assertThat(response.body().string()).isEqualTo("");
 
     server.takeRequest(); // seed
     return server.takeRequest();
@@ -1378,7 +1385,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
     Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
     DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
     String lastModifiedString = dateFormat.format(lastModifiedDate);
     String servedString = dateFormat.format(servedDate);
 
@@ -1390,16 +1397,16 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
 
     // The first request has no conditions.
     RecordedRequest request1 = server.takeRequest();
-    assertNull(request1.getHeader("If-Modified-Since"));
+    assertThat(request1.getHeader("If-Modified-Since")).isNull();
 
     // The 2nd request uses the server's date format.
     RecordedRequest request2 = server.takeRequest();
-    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
+    assertThat(request2.getHeader("If-Modified-Since")).isEqualTo(lastModifiedString);
   }
 
   @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
@@ -1411,8 +1418,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("If-Modified-Since", formatDate(-24, TimeUnit.HOURS))
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, response.code());
-    assertEquals("", response.body().string());
+    assertThat(response.code()).isEqualTo(HttpURLConnection.HTTP_NOT_MODIFIED);
+    assertThat(response.body().string()).isEqualTo("");
   }
 
   @Test public void authorizationRequestFullyCached() throws Exception {
@@ -1428,8 +1435,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Authorization", "password")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("A", response.body().string());
-    assertEquals("A", get(url).body().string());
+    assertThat(response.body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("A");
   }
 
   @Test public void contentLocationDoesNotPopulateCache() throws Exception {
@@ -1440,8 +1447,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/foo")).body().string());
-    assertEquals("B", get(server.url("/bar")).body().string());
+    assertThat(get(server.url("/foo")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/bar")).body().string()).isEqualTo("B");
   }
 
   @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
@@ -1454,13 +1461,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/a")).body().string());
-    assertEquals("A", get(server.url("/a")).body().string());
-    assertEquals("B", get(server.url("/b")).body().string());
+    assertThat(get(server.url("/a")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/a")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/b")).body().string()).isEqualTo("B");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
   }
 
   @Test public void statisticsConditionalCacheMiss() throws Exception {
@@ -1473,15 +1480,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("C"));
 
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("B", get(server.url("/")).body().string());
-    assertEquals("C", get(server.url("/")).body().string());
-    assertEquals(3, cache.requestCount());
-    assertEquals(3, cache.networkCount());
-    assertEquals(0, cache.hitCount());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(cache.requestCount()).isEqualTo(1);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(0);
+    assertThat(get(server.url("/")).body().string()).isEqualTo("B");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("C");
+    assertThat(cache.requestCount()).isEqualTo(3);
+    assertThat(cache.networkCount()).isEqualTo(3);
+    assertThat(cache.hitCount()).isEqualTo(0);
   }
 
   @Test public void statisticsConditionalCacheHit() throws Exception {
@@ -1494,15 +1501,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(3, cache.requestCount());
-    assertEquals(3, cache.networkCount());
-    assertEquals(2, cache.hitCount());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(cache.requestCount()).isEqualTo(1);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(0);
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(cache.requestCount()).isEqualTo(3);
+    assertThat(cache.networkCount()).isEqualTo(3);
+    assertThat(cache.hitCount()).isEqualTo(2);
   }
 
   @Test public void statisticsFullCacheHit() throws Exception {
@@ -1510,15 +1517,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Cache-Control: max-age=60")
         .setBody("A"));
 
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals(3, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(2, cache.hitCount());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(cache.requestCount()).isEqualTo(1);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(0);
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(cache.requestCount()).isEqualTo(3);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(2);
   }
 
   @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
@@ -1535,14 +1542,14 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Accept-Language", "fr-CA")
         .build();
     Response frResponse = client.newCall(frRequest).execute();
-    assertEquals("A", frResponse.body().string());
+    assertThat(frResponse.body().string()).isEqualTo("A");
 
     Request enRequest = new Request.Builder()
         .url(url)
         .header("Accept-Language", "en-US")
         .build();
     Response enResponse = client.newCall(enRequest).execute();
-    assertEquals("B", enResponse.body().string());
+    assertThat(enResponse.body().string()).isEqualTo("B");
   }
 
   @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
@@ -1559,13 +1566,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Accept-Language", "fr-CA")
         .build();
     Response response1 = client.newCall(request).execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
     Request request1 = new Request.Builder()
         .url(url)
         .header("Accept-Language", "fr-CA")
         .build();
     Response response2 = client.newCall(request1).execute();
-    assertEquals("A", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("A");
   }
 
   @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
@@ -1576,8 +1583,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
   }
 
   @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
@@ -1588,12 +1595,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
     Request request = new Request.Builder()
         .url(server.url("/")).header("Foo", "bar")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("B", response.body().string());
+    assertThat(response.body().string()).isEqualTo("B");
   }
 
   @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
@@ -1608,8 +1615,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .url(server.url("/")).header("Foo", "bar")
         .build();
     Response fooresponse = client.newCall(request).execute();
-    assertEquals("A", fooresponse.body().string());
-    assertEquals("B", get(server.url("/")).body().string());
+    assertThat(fooresponse.body().string()).isEqualTo("A");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("B");
   }
 
   @Test public void varyFieldsAreCaseInsensitive() throws Exception {
@@ -1626,13 +1633,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Accept-Language", "fr-CA")
         .build();
     Response response1 = client.newCall(request).execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
     Request request1 = new Request.Builder()
         .url(url)
         .header("accept-language", "fr-CA")
         .build();
     Response response2 = client.newCall(request1).execute();
-    assertEquals("A", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("A");
   }
 
   @Test public void varyMultipleFieldsWithMatch() throws Exception {
@@ -1652,7 +1659,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Accept-Encoding", "identity")
         .build();
     Response response1 = client.newCall(request).execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
     Request request1 = new Request.Builder()
         .url(url)
         .header("Accept-Language", "fr-CA")
@@ -1660,7 +1667,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Accept-Encoding", "identity")
         .build();
     Response response2 = client.newCall(request1).execute();
-    assertEquals("A", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("A");
   }
 
   @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
@@ -1680,7 +1687,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Accept-Encoding", "identity")
         .build();
     Response frResponse = client.newCall(frRequest).execute();
-    assertEquals("A", frResponse.body().string());
+    assertThat(frResponse.body().string()).isEqualTo("A");
     Request enRequest = new Request.Builder()
         .url(url)
         .header("Accept-Language", "en-CA")
@@ -1688,7 +1695,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Accept-Encoding", "identity")
         .build();
     Response enResponse = client.newCall(enRequest).execute();
-    assertEquals("B", enResponse.body().string());
+    assertThat(enResponse.body().string()).isEqualTo("B");
   }
 
   @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
@@ -1706,7 +1713,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Accept-Language", "en-US")
         .build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
 
     Request request2 = new Request.Builder()
         .url(url)
@@ -1714,7 +1721,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Accept-Language", "en-US")
         .build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals("A", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("A");
   }
 
   @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
@@ -1732,7 +1739,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Accept-Language", "en-US")
         .build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
 
     Request request2 = new Request.Builder()
         .url(url)
@@ -1740,7 +1747,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Accept-Language", "en-US")
         .build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals("B", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("B");
   }
 
   @Test public void varyAsterisk() throws Exception {
@@ -1751,12 +1758,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("B"));
 
-    assertEquals("A", get(server.url("/")).body().string());
-    assertEquals("B", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
+    assertThat(get(server.url("/")).body().string()).isEqualTo("B");
   }
 
   @Test public void varyAndHttps() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
@@ -1765,7 +1772,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("B"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -1775,14 +1783,14 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .header("Accept-Language", "en-US")
         .build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
 
     Request request2 = new Request.Builder()
         .url(url)
         .header("Accept-Language", "en-US")
         .build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals("A", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("A");
   }
 
   @Test public void cachePlusCookies() throws Exception {
@@ -1801,9 +1809,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
     cookieJar.assertResponseCookies("a=FIRST; path=/");
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
     cookieJar.assertResponseCookies("a=SECOND; path=/");
   }
 
@@ -1818,12 +1826,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     Response response1 = get(server.url("/"));
-    assertEquals("A", response1.body().string());
-    assertEquals("GET, HEAD", response1.header("Allow"));
+    assertThat(response1.body().string()).isEqualTo("A");
+    assertThat(response1.header("Allow")).isEqualTo("GET, HEAD");
 
     Response response2 = get(server.url("/"));
-    assertEquals("A", response2.body().string());
-    assertEquals("GET, HEAD, PUT", response2.header("Allow"));
+    assertThat(response2.body().string()).isEqualTo("A");
+    assertThat(response2.header("Allow")).isEqualTo("GET, HEAD, PUT");
   }
 
   @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
@@ -1837,12 +1845,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     Response response1 = get(server.url("/"));
-    assertEquals("A", response1.body().string());
-    assertEquals("identity", response1.header("Transfer-Encoding"));
+    assertThat(response1.body().string()).isEqualTo("A");
+    assertThat(response1.header("Transfer-Encoding")).isEqualTo("identity");
 
     Response response2 = get(server.url("/"));
-    assertEquals("A", response2.body().string());
-    assertEquals("identity", response2.header("Transfer-Encoding"));
+    assertThat(response2.body().string()).isEqualTo("A");
+    assertThat(response2.header("Transfer-Encoding")).isEqualTo("identity");
   }
 
   @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
@@ -1855,12 +1863,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     Response response1 = get(server.url("/"));
-    assertEquals("A", response1.body().string());
-    assertEquals("199 test danger", response1.header("Warning"));
+    assertThat(response1.body().string()).isEqualTo("A");
+    assertThat(response1.header("Warning")).isEqualTo("199 test danger");
 
     Response response2 = get(server.url("/"));
-    assertEquals("A", response2.body().string());
-    assertEquals(null, response2.header("Warning"));
+    assertThat(response2.body().string()).isEqualTo("A");
+    assertThat(response2.header("Warning")).isNull();
   }
 
   @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
@@ -1873,12 +1881,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     Response response1 = get(server.url("/"));
-    assertEquals("A", response1.body().string());
-    assertEquals("299 test danger", response1.header("Warning"));
+    assertThat(response1.body().string()).isEqualTo("A");
+    assertThat(response1.header("Warning")).isEqualTo("299 test danger");
 
     Response response2 = get(server.url("/"));
-    assertEquals("A", response2.body().string());
-    assertEquals("299 test danger", response2.header("Warning"));
+    assertThat(response2.body().string()).isEqualTo("A");
+    assertThat(response2.header("Warning")).isEqualTo("299 test danger");
   }
 
   @Test public void doNotCachePartialResponse() throws Exception {
@@ -1904,28 +1912,31 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     // A cache miss writes the cache.
     long t0 = System.currentTimeMillis();
     Response response1 = get(server.url("/a"));
-    assertEquals("A", response1.body().string());
-    assertEquals(null, response1.header("Allow"));
-    assertEquals(0, response1.receivedResponseAtMillis() - t0, 250.0);
+    assertThat(response1.body().string()).isEqualTo("A");
+    assertThat(response1.header("Allow")).isNull();
+    assertThat((double) (response1.receivedResponseAtMillis() - t0)).isCloseTo(
+        (double) 0, offset(250.0));
 
     // A conditional cache hit updates the cache.
     Thread.sleep(500); // Make sure t0 and t1 are distinct.
     long t1 = System.currentTimeMillis();
     Response response2 = get(server.url("/a"));
-    assertEquals(HttpURLConnection.HTTP_OK, response2.code());
-    assertEquals("A", response2.body().string());
-    assertEquals("GET, HEAD", response2.header("Allow"));
-    assertEquals(0, response2.receivedResponseAtMillis() - t1, 250.0);
+    assertThat(response2.code()).isEqualTo(HttpURLConnection.HTTP_OK);
+    assertThat(response2.body().string()).isEqualTo("A");
+    assertThat(response2.header("Allow")).isEqualTo("GET, HEAD");
+    assertThat((double) (response2.receivedResponseAtMillis() - t1)).isCloseTo(
+        (double) 0, offset(250.0));
 
     // A full cache hit reads the cache.
     Thread.sleep(500); // Make sure t1 and t2 are distinct.
     long t2 = System.currentTimeMillis();
     Response response3 = get(server.url("/a"));
-    assertEquals("A", response3.body().string());
-    assertEquals("GET, HEAD", response3.header("Allow"));
-    assertEquals(0, response3.receivedResponseAtMillis() - t1, 250.0);
+    assertThat(response3.body().string()).isEqualTo("A");
+    assertThat(response3.header("Allow")).isEqualTo("GET, HEAD");
+    assertThat((double) (response3.receivedResponseAtMillis() - t1)).isCloseTo(
+        (double) 0, offset(250.0));
 
-    assertEquals(2, server.getRequestCount());
+    assertThat(server.getRequestCount()).isEqualTo(2);
   }
 
   @Test public void responseSourceHeaderCached() throws IOException {
@@ -1934,12 +1945,12 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
     Request request = new Request.Builder()
         .url(server.url("/")).header("Cache-Control", "only-if-cached")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("A", response.body().string());
+    assertThat(response.body().string()).isEqualTo("A");
   }
 
   @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
@@ -1952,9 +1963,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Cache-Control: max-age=30")
         .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
     Response response = get(server.url("/"));
-    assertEquals("B", response.body().string());
+    assertThat(response.body().string()).isEqualTo("B");
   }
 
   @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
@@ -1965,9 +1976,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setResponseCode(304));
 
-    assertEquals("A", get(server.url("/")).body().string());
+    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
     Response response = get(server.url("/"));
-    assertEquals("A", response.body().string());
+    assertThat(response.body().string()).isEqualTo("A");
   }
 
   @Test public void responseSourceHeaderFetched() throws IOException {
@@ -1975,20 +1986,20 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("A"));
 
     Response response = get(server.url("/"));
-    assertEquals("A", response.body().string());
+    assertThat(response.body().string()).isEqualTo("A");
   }
 
   @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
     Headers.Builder headers = new Headers.Builder()
         .add("Cache-Control: max-age=120");
-    Internal.instance.addLenient(headers, ": A");
+    InternalKtKt.addHeaderLenient(headers, ": A");
     server.enqueue(new MockResponse()
         .setHeaders(headers.build())
         .setBody("body"));
 
     Response response = get(server.url("/"));
-    assertEquals("A", response.header(""));
-    assertEquals("body", response.body().string());
+    assertThat(response.header("")).isEqualTo("A");
+    assertThat(response.body().string()).isEqualTo("body");
   }
 
   /**
@@ -2047,9 +2058,9 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .build();
 
     Response response = get(url);
-    assertEquals(entryBody, response.body().string());
-    assertEquals("3", response.header("Content-Length"));
-    assertEquals("foo", response.header("etag"));
+    assertThat(response.body().string()).isEqualTo(entryBody);
+    assertThat(response.header("Content-Length")).isEqualTo("3");
+    assertThat(response.header("etag")).isEqualTo("foo");
   }
 
   /** Exercise the cache format in OkHttp 2.7 and all earlier releases. */
@@ -2097,8 +2108,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .build();
 
     Response response = get(url);
-    assertEquals(entryBody, response.body().string());
-    assertEquals("3", response.header("Content-Length"));
+    assertThat(response.body().string()).isEqualTo(entryBody);
+    assertThat(response.header("Content-Length")).isEqualTo("3");
   }
 
   /** The TLS version is present in OkHttp 3.0 and beyond. */
@@ -2147,8 +2158,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .build();
 
     Response response = get(url);
-    assertEquals(entryBody, response.body().string());
-    assertEquals("3", response.header("Content-Length"));
+    assertThat(response.body().string()).isEqualTo(entryBody);
+    assertThat(response.header("Content-Length")).isEqualTo("3");
   }
 
   @Test public void testGoldenCacheHttpResponseOkHttp30() throws Exception {
@@ -2184,8 +2195,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .build();
 
     Response response = get(url);
-    assertEquals(entryBody, response.body().string());
-    assertEquals("3", response.header("Content-Length"));
+    assertThat(response.body().string()).isEqualTo(entryBody);
+    assertThat(response.header("Content-Length")).isEqualTo("3");
   }
 
   @Test public void evictAll() throws Exception {
@@ -2196,10 +2207,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("B"));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
     client.cache().evictAll();
-    assertEquals(0, client.cache().size());
-    assertEquals("B", get(url).body().string());
+    assertThat(client.cache().size()).isEqualTo(0);
+    assertThat(get(url).body().string()).isEqualTo("B");
   }
 
   @Test public void networkInterceptorInvokedForConditionalGet() throws Exception {
@@ -2211,20 +2222,19 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
 
     // Seed the cache.
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
 
     final AtomicReference<String> ifNoneMatch = new AtomicReference<>();
     client = client.newBuilder()
-        .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            ifNoneMatch.compareAndSet(null, chain.request().header("If-None-Match"));
-            return chain.proceed(chain.request());
-          }
-        }).build();
+        .addNetworkInterceptor(chain -> {
+          ifNoneMatch.compareAndSet(null, chain.request().header("If-None-Match"));
+          return chain.proceed(chain.request());
+        })
+        .build();
 
     // Confirm the value is cached and intercepted.
-    assertEquals("A", get(url).body().string());
-    assertEquals("v1", ifNoneMatch.get());
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(ifNoneMatch.get()).isEqualTo("v1");
   }
 
   @Test public void networkInterceptorNotInvokedForFullyCached() throws Exception {
@@ -2234,16 +2244,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
 
     // Seed the cache.
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
 
     // Confirm the interceptor isn't exercised.
     client = client.newBuilder()
-        .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            throw new AssertionError();
-          }
-        }).build();
-    assertEquals("A", get(url).body().string());
+        .addNetworkInterceptor(chain -> { throw new AssertionError(); })
+        .build();
+    assertThat(get(url).body().string()).isEqualTo("A");
   }
 
   @Test public void iterateCache() throws Exception {
@@ -2251,29 +2258,29 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("a"));
     HttpUrl urlA = server.url("/a");
-    assertEquals("a", get(urlA).body().string());
+    assertThat(get(urlA).body().string()).isEqualTo("a");
 
     server.enqueue(new MockResponse()
         .setBody("b"));
     HttpUrl urlB = server.url("/b");
-    assertEquals("b", get(urlB).body().string());
+    assertThat(get(urlB).body().string()).isEqualTo("b");
 
     server.enqueue(new MockResponse()
         .setBody("c"));
     HttpUrl urlC = server.url("/c");
-    assertEquals("c", get(urlC).body().string());
+    assertThat(get(urlC).body().string()).isEqualTo("c");
 
     // Confirm the iterator returns those responses...
     Iterator<String> i = cache.urls();
-    assertTrue(i.hasNext());
-    assertEquals(urlA.toString(), i.next());
-    assertTrue(i.hasNext());
-    assertEquals(urlB.toString(), i.next());
-    assertTrue(i.hasNext());
-    assertEquals(urlC.toString(), i.next());
+    assertThat(i.hasNext()).isTrue();
+    assertThat(i.next()).isEqualTo(urlA.toString());
+    assertThat(i.hasNext()).isTrue();
+    assertThat(i.next()).isEqualTo(urlB.toString());
+    assertThat(i.hasNext()).isTrue();
+    assertThat(i.next()).isEqualTo(urlC.toString());
 
     // ... and nothing else.
-    assertFalse(i.hasNext());
+    assertThat(i.hasNext()).isFalse();
     try {
       i.next();
       fail();
@@ -2287,17 +2294,17 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .addHeader("Cache-Control: max-age=60")
         .setBody("a"));
     HttpUrl url = server.url("/a");
-    assertEquals("a", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("a");
 
     // Remove it with iteration.
     Iterator<String> i = cache.urls();
-    assertEquals(url.toString(), i.next());
+    assertThat(i.next()).isEqualTo(url.toString());
     i.remove();
 
     // Confirm that subsequent requests suffer a cache miss.
     server.enqueue(new MockResponse()
         .setBody("b"));
-    assertEquals("b", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("b");
   }
 
   @Test public void iteratorRemoveWithoutNextThrows() throws Exception {
@@ -2305,10 +2312,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("a"));
     HttpUrl url = server.url("/a");
-    assertEquals("a", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("a");
 
     Iterator<String> i = cache.urls();
-    assertTrue(i.hasNext());
+    assertThat(i.hasNext()).isTrue();
     try {
       i.remove();
       fail();
@@ -2321,10 +2328,10 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("a"));
     HttpUrl url = server.url("/a");
-    assertEquals("a", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("a");
 
     Iterator<String> i = cache.urls();
-    assertEquals(url.toString(), i.next());
+    assertThat(i.next()).isEqualTo(url.toString());
     i.remove();
 
     // Too many calls to remove().
@@ -2340,15 +2347,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("a"));
     HttpUrl url = server.url("/a");
-    assertEquals("a", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("a");
 
     // The URL will remain available if hasNext() returned true...
     Iterator<String> i = cache.urls();
-    assertTrue(i.hasNext());
+    assertThat(i.hasNext()).isTrue();
 
     // ...so even when we evict the element, we still get something back.
     cache.evictAll();
-    assertEquals(url.toString(), i.next());
+    assertThat(i.next()).isEqualTo(url.toString());
 
     // Remove does nothing. But most importantly, it doesn't throw!
     i.remove();
@@ -2359,13 +2366,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     server.enqueue(new MockResponse()
         .setBody("a"));
     HttpUrl url = server.url("/a");
-    assertEquals("a", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("a");
 
     Iterator<String> i = cache.urls();
     cache.evictAll();
 
     // The URL was evicted before hasNext() made any promises.
-    assertFalse(i.hasNext());
+    assertThat(i.hasNext()).isFalse();
     try {
       i.next();
       fail();
@@ -2387,15 +2394,15 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    assertEquals("A", get(url).body().string());
-    assertEquals("B", get(url).body().string());
-    assertEquals("B", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("B");
+    assertThat(get(url).body().string()).isEqualTo("B");
 
-    assertEquals(null, server.takeRequest().getHeader("If-None-Match"));
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
-    assertEquals("v2", server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v2");
   }
 
   @Test public void combinedCacheHeadersCanBeNonAscii() throws Exception {
@@ -2412,16 +2419,16 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     Response response1 = get(server.url("/"));
-    assertEquals("Œ±", response1.header("Alpha"));
-    assertEquals("Beta", response1.header("Œ≤"));
-    assertEquals("abcd", response1.body().string());
+    assertThat(response1.header("Alpha")).isEqualTo("Œ±");
+    assertThat(response1.header("Œ≤")).isEqualTo("Beta");
+    assertThat(response1.body().string()).isEqualTo("abcd");
 
     Response response2 = get(server.url("/"));
-    assertEquals("Œ±", response2.header("Alpha"));
-    assertEquals("Beta", response2.header("Œ≤"));
-    assertEquals("Œì", response2.header("Gamma"));
-    assertEquals("Delta", response2.header("Œî"));
-    assertEquals("abcd", response2.body().string());
+    assertThat(response2.header("Alpha")).isEqualTo("Œ±");
+    assertThat(response2.header("Œ≤")).isEqualTo("Beta");
+    assertThat(response2.header("Gamma")).isEqualTo("Œì");
+    assertThat(response2.header("Œî")).isEqualTo("Delta");
+    assertThat(response2.body().string()).isEqualTo("abcd");
   }
 
   @Test public void etagConditionCanBeNonAscii() throws Exception {
@@ -2433,13 +2440,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
 
     Response response1 = get(server.url("/"));
-    assertEquals("abcd", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("abcd");
 
     Response response2 = get(server.url("/"));
-    assertEquals("abcd", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("abcd");
 
-    assertEquals(null, server.takeRequest().getHeader("If-None-Match"));
-    assertEquals("Œ±", server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("Œ±");
   }
 
   private Response get(HttpUrl url) throws IOException {
@@ -2475,8 +2482,8 @@ private void assertNotCached(MockResponse response) throws Exception {
         .setBody("B"));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    assertEquals("B", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("B");
   }
 
   /** @return the request with the conditional get headers. */
@@ -2495,23 +2502,23 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
 
     HttpUrl valid = server.url("/valid");
     Response response1 = get(valid);
-    assertEquals("A", response1.body().string());
-    assertEquals(HttpURLConnection.HTTP_OK, response1.code());
-    assertEquals("A-OK", response1.message());
+    assertThat(response1.body().string()).isEqualTo("A");
+    assertThat(response1.code()).isEqualTo(HttpURLConnection.HTTP_OK);
+    assertThat(response1.message()).isEqualTo("A-OK");
     Response response2 = get(valid);
-    assertEquals("A", response2.body().string());
-    assertEquals(HttpURLConnection.HTTP_OK, response2.code());
-    assertEquals("A-OK", response2.message());
+    assertThat(response2.body().string()).isEqualTo("A");
+    assertThat(response2.code()).isEqualTo(HttpURLConnection.HTTP_OK);
+    assertThat(response2.message()).isEqualTo("A-OK");
 
     HttpUrl invalid = server.url("/invalid");
     Response response3 = get(invalid);
-    assertEquals("B", response3.body().string());
-    assertEquals(HttpURLConnection.HTTP_OK, response3.code());
-    assertEquals("B-OK", response3.message());
+    assertThat(response3.body().string()).isEqualTo("B");
+    assertThat(response3.code()).isEqualTo(HttpURLConnection.HTTP_OK);
+    assertThat(response3.message()).isEqualTo("B-OK");
     Response response4 = get(invalid);
-    assertEquals("C", response4.body().string());
-    assertEquals(HttpURLConnection.HTTP_OK, response4.code());
-    assertEquals("C-OK", response4.message());
+    assertThat(response4.body().string()).isEqualTo("C");
+    assertThat(response4.code()).isEqualTo(HttpURLConnection.HTTP_OK);
+    assertThat(response4.message()).isEqualTo("C-OK");
 
     server.takeRequest(); // regular get
     return server.takeRequest(); // conditional get
@@ -2519,29 +2526,43 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
 
   @Test public void immutableIsCached() throws Exception {
     server.enqueue(new MockResponse()
-        .addHeader("Cache-Control", "immutable")
+        .addHeader("Cache-Control", "immutable, max-age=10")
         .setBody("A"));
     server.enqueue(new MockResponse()
         .setBody("B"));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("A");
   }
 
   @Test public void immutableIsCachedAfterMultipleCalls() throws Exception {
     server.enqueue(new MockResponse()
         .setBody("A"));
     server.enqueue(new MockResponse()
-        .addHeader("Cache-Control", "immutable")
+        .addHeader("Cache-Control", "immutable, max-age=10")
         .setBody("B"));
     server.enqueue(new MockResponse()
         .setBody("C"));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    assertEquals("B", get(url).body().string());
-    assertEquals("B", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("B");
+    assertThat(get(url).body().string()).isEqualTo("B");
+  }
+
+  @Test public void immutableIsNotCachedBeyondFreshnessLifetime() throws Exception {
+    //      last modified: 115 seconds ago
+    //             served:  15 seconds ago
+    //   default lifetime: (115 - 15) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds ago
+    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
+        .addHeader("Cache-Control: immutable")
+        .addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
+    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
+        lastModifiedDate);
   }
 
   private void assertFullyCached(MockResponse response) throws Exception {
@@ -2549,8 +2570,8 @@ private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("B"));
 
     HttpUrl url = server.url("/");
-    assertEquals("A", get(url).body().string());
-    assertEquals("A", get(url).body().string());
+    assertThat(get(url).body().string()).isEqualTo("A");
+    assertThat(get(url).body().string()).isEqualTo("A");
   }
 
   /**
@@ -2568,18 +2589,17 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
   }
 
   enum TransferKind {
-    CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
+    CHUNKED {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setChunkedBody(content, chunkSize);
       }
     },
-    FIXED_LENGTH() {
+    FIXED_LENGTH {
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
       }
     },
-    END_OF_STREAM() {
+    END_OF_STREAM {
       @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setBody(content);
         response.setSocketPolicy(DISCONNECT_AT_END);
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp/src/test/java/okhttp3/CallTest.java
similarity index 68%
rename from okhttp-tests/src/test/java/okhttp3/CallTest.java
rename to okhttp/src/test/java/okhttp3/CallTest.java
index df729b5510..288d4ca235 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp/src/test/java/okhttp3/CallTest.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.File;
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InterruptedIOException;
@@ -36,7 +37,6 @@
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -44,32 +44,39 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import java.util.logging.SimpleFormatter;
+import javax.annotation.Nullable;
+import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLProtocolException;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import okhttp3.RecordingEventListener.CallEnd;
+import okhttp3.RecordingEventListener.ConnectionAcquired;
+import okhttp3.RecordingEventListener.ConnectionReleased;
+import okhttp3.RecordingEventListener.ResponseFailed;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.internal.Util;
 import okhttp3.internal.Version;
 import okhttp3.internal.http.RecordingProxySelector;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.QueueDispatcher;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.mockwebserver.internal.tls.HeldCertificate;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
+import okio.ForwardingSource;
 import okio.GzipSink;
 import okio.Okio;
 import org.junit.After;
@@ -81,25 +88,30 @@
 import org.junit.rules.Timeout;
 
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static java.util.Arrays.asList;
+import static okhttp3.CipherSuite.TLS_DH_anon_WITH_AES_128_GCM_SHA256;
 import static okhttp3.TestUtil.awaitGarbageCollection;
-import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.internal.InternalKtKt.addHeaderLenient;
+import static okhttp3.internal.platform.PlatformTest.getJvmSpecVersion;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeFalse;
 
 public final class CallTest {
   @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
   @Rule public final MockWebServer server = new MockWebServer();
   @Rule public final MockWebServer server2 = new MockWebServer();
   @Rule public final InMemoryFileSystem fileSystem = new InMemoryFileSystem();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
-  private SslClient sslClient = SslClient.localhost();
-  private OkHttpClient client = defaultClient();
+  private RecordingEventListener listener = new RecordingEventListener();
+  private HandshakeCertificates handshakeCertificates = localhost();
+  private OkHttpClient client = clientTestRule.client.newBuilder()
+      .eventListener(listener)
+      .build();
   private RecordingCallback callback = new RecordingCallback();
   private TestLogHandler logHandler = new TestLogHandler();
   private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
@@ -136,10 +148,10 @@
         .assertReceivedResponseAtMillis(sentAt, receivedAt);
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("GET", recordedRequest.getMethod());
-    assertEquals("SyncApiTest", recordedRequest.getHeader("User-Agent"));
-    assertEquals(0, recordedRequest.getBody().size());
-    assertNull(recordedRequest.getHeader("Content-Length"));
+    assertThat(recordedRequest.getMethod()).isEqualTo("GET");
+    assertThat(recordedRequest.getHeader("User-Agent")).isEqualTo("SyncApiTest");
+    assertThat(recordedRequest.getBody().size()).isEqualTo(0);
+    assertThat(recordedRequest.getHeader("Content-Length")).isNull();
   }
 
   @Test public void buildRequestUsingHttpUrl() throws Exception {
@@ -153,7 +165,8 @@
       requestBuilder.url("ftp://hostname/path");
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals(expected.getMessage(), "unexpected url: ftp://hostname/path");
+      assertThat(expected.getMessage()).isEqualTo(
+          "Expected URL scheme 'http' or 'https' but was 'ftp'");
     }
   }
 
@@ -163,7 +176,7 @@
       requestBuilder.url("http://localhost:65536/");
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals(expected.getMessage(), "unexpected url: http://localhost:65536/");
+      assertThat(expected.getMessage()).isEqualTo("Invalid URL port: \"65536\"");
     }
   }
 
@@ -194,7 +207,7 @@
         .assertHeader("B", "123", "234");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(Arrays.asList("345", "456"), recordedRequest.getHeaders().values("A"));
+    assertThat(recordedRequest.getHeaders().values("A")).containsExactly("345", "456");
   }
 
   @Test public void repeatedHeaderNames_HTTP_2() throws Exception {
@@ -206,7 +219,7 @@
     server.enqueue(new MockResponse());
 
     try {
-      new Request.Builder().method("GET", RequestBody.create(MediaType.parse("text/plain"), "abc"));
+      new Request.Builder().method("GET", RequestBody.create(MediaType.get("text/plain"), "abc"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -226,10 +239,10 @@
         .assertHeader("Content-Type", "text/plain");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("HEAD", recordedRequest.getMethod());
-    assertEquals("SyncApiTest", recordedRequest.getHeader("User-Agent"));
-    assertEquals(0, recordedRequest.getBody().size());
-    assertNull(recordedRequest.getHeader("Content-Length"));
+    assertThat(recordedRequest.getMethod()).isEqualTo("HEAD");
+    assertThat(recordedRequest.getHeader("User-Agent")).isEqualTo("SyncApiTest");
+    assertThat(recordedRequest.getBody().size()).isEqualTo(0);
+    assertThat(recordedRequest.getHeader("Content-Length")).isNull();
   }
 
   @Test public void headResponseContentLengthIsIgnored() throws Exception {
@@ -244,7 +257,7 @@
         .head()
         .build();
     Response response = client.newCall(headRequest).execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     assertArrayEquals(new byte[0], response.body().bytes());
 
     Request getRequest = new Request.Builder()
@@ -254,8 +267,8 @@
         .assertCode(200)
         .assertBody("abc");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void headResponseContentEncodingIsIgnored() throws Exception {
@@ -281,8 +294,8 @@
         .assertCode(200)
         .assertBody("abc");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void head_HTTPS() throws Exception {
@@ -300,7 +313,7 @@
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -308,10 +321,11 @@
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("POST", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getBody().readUtf8());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+    assertThat(recordedRequest.getMethod()).isEqualTo("POST");
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
+    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
+    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
+        "text/plain; charset=utf-8");
   }
 
   @Test public void post_HTTPS() throws Exception {
@@ -337,10 +351,10 @@
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("POST", recordedRequest.getMethod());
-    assertEquals(0, recordedRequest.getBody().size());
-    assertEquals("0", recordedRequest.getHeader("Content-Length"));
-    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+    assertThat(recordedRequest.getMethod()).isEqualTo("POST");
+    assertThat(recordedRequest.getBody().size()).isEqualTo(0);
+    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("0");
+    assertThat(recordedRequest.getHeader("Content-Type")).isNull();
   }
 
   @Test public void postZerolength_HTTPS() throws Exception {
@@ -393,22 +407,22 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     String credential = Credentials.basic("jesse", "secret");
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build();
 
     Response response = client.newCall(request).execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     RecordedRequest recordedRequest1 = server.takeRequest();
-    assertEquals("POST", recordedRequest1.getMethod());
-    assertEquals(body, recordedRequest1.getBody().readUtf8());
-    assertNull(recordedRequest1.getHeader("Authorization"));
+    assertThat(recordedRequest1.getMethod()).isEqualTo("POST");
+    assertThat(recordedRequest1.getBody().readUtf8()).isEqualTo(body);
+    assertThat(recordedRequest1.getHeader("Authorization")).isNull();
 
     RecordedRequest recordedRequest2 = server.takeRequest();
-    assertEquals("POST", recordedRequest2.getMethod());
-    assertEquals(body, recordedRequest2.getBody().readUtf8());
-    assertEquals(credential, recordedRequest2.getHeader("Authorization"));
+    assertThat(recordedRequest2.getMethod()).isEqualTo("POST");
+    assertThat(recordedRequest2.getBody().readUtf8()).isEqualTo(body);
+    assertThat(recordedRequest2.getHeader("Authorization")).isEqualTo(credential);
   }
 
   @Test public void attemptAuthorization20Times() throws Exception {
@@ -419,7 +433,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     String credential = Credentials.basic("jesse", "secret");
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build();
 
     executeSynchronously("/")
@@ -434,14 +448,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     String credential = Credentials.basic("jesse", "secret");
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, null))
         .build();
 
     try {
       client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
       fail();
     } catch (IOException expected) {
-      assertEquals("Too many follow-up requests: 21", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("Too many follow-up requests: 21");
     }
   }
 
@@ -455,7 +469,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setResponseCode(401)
         .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
 
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(null);
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(null, null);
 
     client = client.newBuilder()
         .authenticator(authenticator)
@@ -464,7 +478,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously("/")
         .assertCode(401);
 
-    assertNotNull(authenticator.onlyRoute());
+    assertThat(authenticator.onlyRoute()).isNotNull();
   }
 
   @Test public void delete() throws Exception {
@@ -480,10 +494,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("DELETE", recordedRequest.getMethod());
-    assertEquals(0, recordedRequest.getBody().size());
-    assertEquals("0", recordedRequest.getHeader("Content-Length"));
-    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+    assertThat(recordedRequest.getMethod()).isEqualTo("DELETE");
+    assertThat(recordedRequest.getBody().size()).isEqualTo(0);
+    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("0");
+    assertThat(recordedRequest.getHeader("Content-Type")).isNull();
   }
 
   @Test public void delete_HTTPS() throws Exception {
@@ -501,7 +515,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .method("DELETE", RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .method("DELETE", RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -509,8 +523,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("DELETE", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getBody().readUtf8());
+    assertThat(recordedRequest.getMethod()).isEqualTo("DELETE");
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
   }
 
   @Test public void put() throws Exception {
@@ -518,7 +532,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .put(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .put(RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -526,10 +540,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("PUT", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getBody().readUtf8());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+    assertThat(recordedRequest.getMethod()).isEqualTo("PUT");
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
+    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
+    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
+        "text/plain; charset=utf-8");
   }
 
   @Test public void put_HTTPS() throws Exception {
@@ -547,7 +562,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .patch(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .patch(RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -555,10 +570,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("PATCH", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getBody().readUtf8());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+    assertThat(recordedRequest.getMethod()).isEqualTo("PATCH");
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
+    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
+    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
+        "text/plain; charset=utf-8");
   }
 
   @Test public void patch_HTTP_2() throws Exception {
@@ -576,7 +592,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .method("CUSTOM", RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .method("CUSTOM", RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -584,10 +600,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("CUSTOM", recordedRequest.getMethod());
-    assertEquals("def", recordedRequest.getBody().readUtf8());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+    assertThat(recordedRequest.getMethod()).isEqualTo("CUSTOM");
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
+    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
+    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
+        "text/plain; charset=utf-8");
   }
 
   @Test public void unspecifiedRequestBodyContentTypeDoesNotGetDefault() throws Exception {
@@ -601,9 +618,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously(request).assertCode(200);
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(null, recordedRequest.getHeader("Content-Type"));
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("abc", recordedRequest.getBody().readUtf8());
+    assertThat(recordedRequest.getHeader("Content-Type")).isNull();
+    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("abc");
   }
 
   @Test public void illegalToExecuteTwice() throws Exception {
@@ -624,17 +641,17 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       call.execute();
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Already Executed", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Already Executed");
     }
 
     try {
       call.enqueue(callback);
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Already Executed", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Already Executed");
     }
 
-    assertEquals("SyncApiTest", server.takeRequest().getHeader("User-Agent"));
+    assertThat(server.takeRequest().getHeader("User-Agent")).isEqualTo("SyncApiTest");
   }
 
   @Test public void illegalToExecuteTwice_Async() throws Exception {
@@ -654,17 +671,19 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       call.execute();
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Already Executed", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Already Executed");
     }
 
     try {
       call.enqueue(callback);
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Already Executed", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Already Executed");
     }
 
-    assertEquals("SyncApiTest", server.takeRequest().getHeader("User-Agent"));
+    assertThat(server.takeRequest().getHeader("User-Agent")).isEqualTo("SyncApiTest");
+
+    callback.await(request.url()).assertSuccessful();
   }
 
   @Test public void legalToExecuteTwiceCloning() throws Exception {
@@ -681,8 +700,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     Call cloned = call.clone();
     Response response2 = cloned.execute();
 
-    assertEquals(response1.body().string(), "abc");
-    assertEquals(response2.body().string(), "def");
+    assertThat("abc").isEqualTo(response1.body().string());
+    assertThat("def").isEqualTo(response2.body().string());
   }
 
   @Test public void legalToExecuteTwiceCloning_Async() throws Exception {
@@ -706,8 +725,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     bodies.add(firstResponse.getBody());
     bodies.add(secondResponse.getBody());
 
-    assertTrue(bodies.contains("abc"));
-    assertTrue(bodies.contains("def"));
+    assertThat(bodies).contains("abc");
+    assertThat(bodies).contains("def");
   }
 
   @Test public void get_Async() throws Exception {
@@ -726,7 +745,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertHeader("Content-Type", "text/plain")
         .assertBody("abc");
 
-    assertEquals("AsyncApiTest", server.takeRequest().getHeader("User-Agent"));
+    assertThat(server.takeRequest().getHeader("User-Agent")).isEqualTo("AsyncApiTest");
   }
 
   @Test public void exceptionThrownByOnResponseIsRedactedAndLogged() throws Exception {
@@ -746,8 +765,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       }
     });
 
-    assertEquals("INFO: Callback failure for call to " + server.url("/") + "...",
-        logHandler.take());
+    assertThat(logHandler.take()).isEqualTo(
+        ("INFO: Callback failure for call to " + server.url("/") + "..."));
   }
 
   @Test public void connectionPooling() throws Exception {
@@ -759,9 +778,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously("/b").assertBody("def");
     executeSynchronously("/c").assertBody("ghi");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
   }
 
   @Test public void connectionPooling_Async() throws Exception {
@@ -778,9 +797,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     client.newCall(new Request.Builder().url(server.url("/c")).build()).enqueue(callback);
     callback.await(server.url("/c")).assertBody("ghi");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
   }
 
   @Test public void connectionReuseWhenResponseBodyConsumed_Async() throws Exception {
@@ -795,9 +814,9 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
       @Override public void onResponse(Call call, Response response) throws IOException {
         InputStream bytes = response.body().byteStream();
-        assertEquals('a', bytes.read());
-        assertEquals('b', bytes.read());
-        assertEquals('c', bytes.read());
+        assertThat(bytes.read()).isEqualTo('a');
+        assertThat(bytes.read()).isEqualTo('b');
+        assertThat(bytes.read()).isEqualTo('c');
 
         // This request will share a connection with 'A' cause it's all done.
         client.newCall(new Request.Builder().url(server.url("/b")).build()).enqueue(callback);
@@ -805,8 +824,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     });
 
     callback.await(server.url("/b")).assertCode(200).assertBody("def");
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reuse!
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Connection reuse!
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void timeoutsUpdatedOnReusedConnections() throws Exception {
@@ -826,7 +847,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     Request request = new Request.Builder().url(server.url("/b")).build();
     Response response = client.newCall(request).execute();
     BufferedSource bodySource = response.body().source();
-    assertEquals('d', bodySource.readByte());
+    assertThat(bodySource.readByte()).isEqualTo((byte) 'd');
 
     // The second byte of this request will be delayed by 750ms so we should time out after 250ms.
     long startNanos = System.nanoTime();
@@ -837,7 +858,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       // Timed out as expected.
       long elapsedNanos = System.nanoTime() - startNanos;
       long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(elapsedNanos);
-      assertTrue(Util.format("Timed out: %sms", elapsedMillis), elapsedMillis < 500);
+      assertThat(elapsedMillis).isLessThan(500);
     } finally {
       bodySource.close();
     }
@@ -917,17 +938,13 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
   /** https://github.com/square/okhttp/issues/1801 */
   @Test public void asyncCallEngineInitialized() throws Exception {
-    OkHttpClient c = defaultClient().newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            throw new IOException();
-          }
-        })
+    OkHttpClient c = clientTestRule.client.newBuilder()
+        .addInterceptor(chain -> { throw new IOException(); })
         .build();
     Request request = new Request.Builder().url(server.url("/")).build();
     c.newCall(request).enqueue(callback);
     RecordedResponse response = callback.await(request.url());
-    assertEquals(request, response.request);
+    assertThat(response.request).isEqualTo(request);
   }
 
   @Test public void reusedSinksGetIndependentTimeoutInstances() throws Exception {
@@ -937,7 +954,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     // Call 1: set a deadline on the request body.
     RequestBody requestBody1 = new RequestBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain");
+        return MediaType.get("text/plain");
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
@@ -950,16 +967,16 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .method("POST", requestBody1)
         .build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals(200, response1.code());
+    assertThat(response1.code()).isEqualTo(200);
 
     // Call 2: check for the absence of a deadline on the request body.
     RequestBody requestBody2 = new RequestBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain");
+        return MediaType.get("text/plain");
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
-        assertFalse(sink.timeout().hasDeadline());
+        assertThat(sink.timeout().hasDeadline()).isFalse();
         sink.writeUtf8("def");
       }
     };
@@ -968,11 +985,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .method("POST", requestBody2)
         .build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals(200, response2.code());
+    assertThat(response2.code()).isEqualTo(200);
 
     // Use sequence numbers to confirm the connection was pooled.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void reusedSourcesGetIndependentTimeoutInstances() throws Exception {
@@ -983,19 +1000,19 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     Request request1 = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request1).execute();
     BufferedSource body1 = response1.body().source();
-    assertEquals("abc", body1.readUtf8());
+    assertThat(body1.readUtf8()).isEqualTo("abc");
     body1.timeout().deadline(5, TimeUnit.SECONDS);
 
     // Call 2: check for the absence of a deadline on the request body.
     Request request2 = new Request.Builder().url(server.url("/")).build();
     Response response2 = client.newCall(request2).execute();
     BufferedSource body2 = response2.body().source();
-    assertEquals("def", body2.readUtf8());
-    assertFalse(body2.timeout().hasDeadline());
+    assertThat(body2.readUtf8()).isEqualTo("def");
+    assertThat(body2.timeout().hasDeadline()).isFalse();
 
     // Use sequence numbers to confirm the connection was pooled.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void tls() throws Exception {
@@ -1022,17 +1039,48 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void recoverWhenRetryOnConnectionFailureIsTrue() throws Exception {
-    server.enqueue(new MockResponse().setBody("seed connection pool"));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse().setBody("retry success"));
+    // Set to 2 because the seeding request will count down before the retried request does.
+    CountDownLatch requestFinished = new CountDownLatch(2);
+
+    QueueDispatcher dispatcher = new QueueDispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        if (peek().getSocketPolicy() == SocketPolicy.DISCONNECT_AFTER_REQUEST) {
+          requestFinished.await();
+        }
+        return super.dispatch(request);
+      }
+    };
+    dispatcher.enqueueResponse(new MockResponse().setBody("seed connection pool"));
+    dispatcher.enqueueResponse(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
+    dispatcher.enqueueResponse(new MockResponse().setBody("retry success"));
+    server.setDispatcher(dispatcher);
+
+    listener = new RecordingEventListener() {
+      @Override public void responseHeadersStart(Call call) {
+        requestFinished.countDown();
+        super.responseHeadersStart(call);
+      }
+    };
 
     client = client.newBuilder()
         .dns(new DoubleInetAddressDns())
+        .eventListener(listener)
         .build();
-    assertTrue(client.retryOnConnectionFailure());
+    assertThat(client.retryOnConnectionFailure()).isTrue();
 
     executeSynchronously("/").assertBody("seed connection pool");
     executeSynchronously("/").assertBody("retry success");
+
+    // The call that seeds the connection pool.
+    listener.removeUpToEvent(CallEnd.class);
+
+    // The ResponseFailed event is not necessarily fatal!
+    listener.removeUpToEvent(ConnectionAcquired.class);
+    listener.removeUpToEvent(ResponseFailed.class);
+    listener.removeUpToEvent(ConnectionReleased.class);
+    listener.removeUpToEvent(ConnectionAcquired.class);
+    listener.removeUpToEvent(ConnectionReleased.class);
+    listener.removeUpToEvent(CallEnd.class);
   }
 
   @Test public void recoverWhenRetryOnConnectionFailureIsTrue_HTTP2() throws Exception {
@@ -1056,8 +1104,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously("/")
         .assertFailure(IOException.class)
         .assertFailureMatches("stream was reset: CANCEL",
-            "unexpected end of stream on Connection.*"
-                + server.getHostName() + ":" + server.getPort() + ".*");
+            "unexpected end of stream on " + server.url("/").redact());
   }
 
   @Test public void recoverWhenRetryOnConnectionFailureIsFalse_HTTP2() throws Exception {
@@ -1066,28 +1113,29 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void tlsHandshakeFailure_noFallbackByDefault() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("response that will never be received"));
     RecordedResponse response = executeSynchronously("/");
     response.assertFailure(
+            SSLException.class, // JDK 11 response to the FAIL_HANDSHAKE
             SSLProtocolException.class, // RI response to the FAIL_HANDSHAKE
             SSLHandshakeException.class // Android's response to the FAIL_HANDSHAKE
     );
-    assertFalse(client.connectionSpecs().contains(ConnectionSpec.COMPATIBLE_TLS));
+    assertThat(client.connectionSpecs()).doesNotContain(ConnectionSpec.COMPATIBLE_TLS);
   }
 
   @Test public void recoverFromTlsHandshakeFailure() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("abc"));
 
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .dns(new SingleInetAddressDns())
-        // opt-in to fallback to COMPATIBLE_TLS
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build();
 
     executeSynchronously("/").assertBody("abc");
@@ -1096,23 +1144,22 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   @Test public void recoverFromTlsHandshakeFailure_tlsFallbackScsvEnabled() throws Exception {
     final String tlsFallbackScsv = "TLS_FALLBACK_SCSV";
     List<String> supportedCiphers =
-        Arrays.asList(sslClient.socketFactory.getSupportedCipherSuites());
+        asList(handshakeCertificates.sslSocketFactory().getSupportedCipherSuites());
     if (!supportedCiphers.contains(tlsFallbackScsv)) {
       // This only works if the client socket supports TLS_FALLBACK_SCSV.
       return;
     }
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
 
     RecordingSSLSocketFactory clientSocketFactory =
-        new RecordingSSLSocketFactory(sslClient.socketFactory);
+        new RecordingSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     client = client.newBuilder()
-        .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
-        // opt-in to fallback to COMPATIBLE_TLS
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+        .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .dns(new SingleInetAddressDns())
         .build();
 
     Request request = new Request.Builder().url(server.url("/")).build();
@@ -1124,20 +1171,22 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     List<SSLSocket> clientSockets = clientSocketFactory.getSocketsCreated();
     SSLSocket firstSocket = clientSockets.get(0);
-    assertFalse(Arrays.asList(firstSocket.getEnabledCipherSuites()).contains(tlsFallbackScsv));
+    assertThat(asList(firstSocket.getEnabledCipherSuites())).doesNotContain(tlsFallbackScsv);
     SSLSocket secondSocket = clientSockets.get(1);
-    assertTrue(Arrays.asList(secondSocket.getEnabledCipherSuites()).contains(tlsFallbackScsv));
+    assertThat(asList(secondSocket.getEnabledCipherSuites())).contains(tlsFallbackScsv);
   }
 
   @Test public void recoverFromTlsHandshakeFailure_Async() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("abc"));
 
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build();
 
     Request request = new Request.Builder()
@@ -1150,13 +1199,13 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
   @Test public void noRecoveryFromTlsHandshakeFailureWhenTlsFallbackIsDisabled() throws Exception {
     client = client.newBuilder()
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT))
+        .connectionSpecs(asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT))
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .dns(new SingleInetAddressDns())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build();
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
 
     Request request = new Request.Builder().url(server.url("/")).build();
@@ -1167,13 +1216,75 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       // RI response to the FAIL_HANDSHAKE
     } catch (SSLHandshakeException expected) {
       // Android's response to the FAIL_HANDSHAKE
+    } catch (SSLException expected) {
+      // JDK 11 response to the FAIL_HANDSHAKE
+      String jvmVersion = System.getProperty("java.specification.version");
+      assertThat(jvmVersion).isEqualTo("11");
     }
   }
 
+  @Test public void tlsHostnameVerificationFailure() throws Exception {
+    server.enqueue(new MockResponse());
+
+    HeldCertificate serverCertificate = new HeldCertificate.Builder()
+        .commonName("localhost") // Unusued for hostname verification.
+        .addSubjectAlternativeName("wronghostname")
+        .build();
+
+    HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(serverCertificate)
+        .build();
+
+    HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(serverCertificate.certificate())
+        .build();
+
+    client = client.newBuilder()
+        .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+        .build();
+    server.useHttps(serverCertificates.sslSocketFactory(), false);
+
+    executeSynchronously("/")
+        .assertFailureMatches("(?s)Hostname localhost not verified.*");
+  }
+
+  /**
+   * Anonymous cipher suites were disabled in OpenJDK because they're rarely used and permit
+   * man-in-the-middle attacks. https://bugs.openjdk.java.net/browse/JDK-8212823
+   */
+  @Test public void anonCipherSuiteUnsupported() throws Exception {
+    // The _anon_ suites became unsupported in "1.8.0_201" and "11.0.2".
+    assumeFalse(System.getProperty("java.version", "unknown").matches("1\\.8\\.0_1\\d\\d"));
+    assumeFalse(System.getProperty("java.version", "unknown").matches("11"));
+
+    server.enqueue(new MockResponse());
+
+    CipherSuite cipherSuite = TLS_DH_anon_WITH_AES_128_GCM_SHA256;
+
+    HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+        .build();
+    client = client.newBuilder()
+        .sslSocketFactory(
+            socketFactoryWithCipherSuite(clientCertificates.sslSocketFactory(), cipherSuite),
+            clientCertificates.trustManager())
+        .connectionSpecs(asList(new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+            .cipherSuites(cipherSuite)
+            .build()))
+        .build();
+
+    HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+        .build();
+    server.useHttps(socketFactoryWithCipherSuite(
+        serverCertificates.sslSocketFactory(), cipherSuite), false);
+
+    executeSynchronously("/")
+        .assertFailure(SSLHandshakeException.class);
+  }
+
   @Test public void cleartextCallsFailWhenCleartextIsDisabled() throws Exception {
     // Configure the client with only TLS configurations. No cleartext!
     client = client.newBuilder()
-        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+        .connectionSpecs(asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
         .build();
 
     server.enqueue(new MockResponse());
@@ -1183,7 +1294,28 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       client.newCall(request).execute();
       fail();
     } catch (UnknownServiceException expected) {
-      assertEquals("CLEARTEXT communication not enabled for client", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "CLEARTEXT communication not enabled for client");
+    }
+  }
+
+  @Test public void httpsCallsFailWhenProtocolIsH2PriorKnowledge() throws Exception {
+    client = client.newBuilder()
+        .protocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE))
+        .build();
+
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (UnknownServiceException expected) {
+      assertThat(expected.getMessage()).isEqualTo(
+          "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS");
     }
   }
 
@@ -1199,11 +1331,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder().url(server.url("/")).build();
     Response response = client.newCall(request).execute();
-    assertEquals(301, response.code());
+    assertThat(response.code()).isEqualTo(301);
     response.body().close();
   }
 
   @Test public void matchingPinnedCertificate() throws Exception {
+    // TODO https://github.com/square/okhttp/issues/4703
+    assumeFalse(getJvmSpecVersion().equals("11"));
+
     enableTls();
     server.enqueue(new MockResponse());
     server.enqueue(new MockResponse());
@@ -1223,7 +1358,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     Request request2 = new Request.Builder().url(server.url("/")).build();
     Response response2 = client.newCall(request2).execute();
-    assertNotSame(response2.handshake(), response1.handshake());
+    assertThat(response1.handshake()).isNotSameAs(response2.handshake());
     response2.body().close();
   }
 
@@ -1244,7 +1379,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       client.newCall(request).execute();
       fail();
     } catch (SSLPeerUnverifiedException expected) {
-      assertTrue(expected.getMessage().startsWith("Certificate pinning failure!"));
+      assertThat(expected.getMessage()).startsWith("Certificate pinning failure!");
     }
   }
 
@@ -1253,7 +1388,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
     client.newCall(request).enqueue(callback);
 
@@ -1262,9 +1397,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertBody("abc");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("def", recordedRequest.getBody().readUtf8());
-    assertEquals("3", recordedRequest.getHeader("Content-Length"));
-    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
+    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
+    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
+        "text/plain; charset=utf-8");
   }
 
   @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
@@ -1275,25 +1411,25 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     // Seed the connection pool so we have something that can fail.
     Request request1 = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals("abc", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("abc");
 
     Request request2 = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "body!"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "body!"))
         .build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals("def", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("def");
 
     RecordedRequest get = server.takeRequest();
-    assertEquals(0, get.getSequenceNumber());
+    assertThat(get.getSequenceNumber()).isEqualTo(0);
 
     RecordedRequest post1 = server.takeRequest();
-    assertEquals("body!", post1.getBody().readUtf8());
-    assertEquals(1, post1.getSequenceNumber());
+    assertThat(post1.getBody().readUtf8()).isEqualTo("body!");
+    assertThat(post1.getSequenceNumber()).isEqualTo(1);
 
     RecordedRequest post2 = server.takeRequest();
-    assertEquals("body!", post2.getBody().readUtf8());
-    assertEquals(0, post2.getSequenceNumber());
+    assertThat(post2.getBody().readUtf8()).isEqualTo("body!");
+    assertThat(post2.getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void postBodyRetransmittedOnFailureRecovery_HTTP2() throws Exception {
@@ -1319,7 +1455,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertCode(200)
         .assertBody("A");
     long request1ReceivedAt = System.currentTimeMillis();
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
 
     // Hit that stored response. It's different, but Vary says it doesn't matter.
     Thread.sleep(10); // Make sure the timestamps are unique.
@@ -1381,7 +1517,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertHeader("Donut", "a")
         .assertBody("A");
     long request1ReceivedAt = System.currentTimeMillis();
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
 
     // Hit that stored response. It's different, but Vary says it doesn't matter.
     Thread.sleep(10); // Make sure the timestamps are unique.
@@ -1389,7 +1525,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     RecordedResponse cacheHit = executeSynchronously(
         "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
     long request2ReceivedAt = System.currentTimeMillis();
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
 
     // Check the merged response. The request is the application's original request.
     cacheHit.assertCode(200)
@@ -1440,14 +1576,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     client.newCall(request1).enqueue(callback);
     callback.await(request1.url()).assertCode(200).assertBody("A");
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
 
     Request request2 = new Request.Builder()
         .url(server.url("/"))
         .build();
     client.newCall(request2).enqueue(callback);
     callback.await(request2.url()).assertCode(200).assertBody("A");
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
   }
 
   @Test public void conditionalCacheMiss() throws Exception {
@@ -1469,7 +1605,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertCode(200)
         .assertBody("A");
     long request1ReceivedAt = System.currentTimeMillis();
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
 
     // Different request, but Vary says it doesn't matter.
     Thread.sleep(10); // Make sure the timestamps are unique.
@@ -1477,7 +1613,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     RecordedResponse cacheMiss = executeSynchronously(
         "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
     long request2ReceivedAt = System.currentTimeMillis();
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
 
     // Check the user response. It has the application's original request.
     cacheMiss.assertCode(200)
@@ -1519,14 +1655,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     client.newCall(request1).enqueue(callback);
     callback.await(request1.url()).assertCode(200).assertBody("A");
-    assertNull(server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
 
     Request request2 = new Request.Builder()
         .url(server.url("/"))
         .build();
     client.newCall(request2).enqueue(callback);
     callback.await(request2.url()).assertCode(200).assertBody("B");
-    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
   }
 
   @Test public void onlyIfCachedReturns504WhenNotCached() throws Exception {
@@ -1551,7 +1687,6 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertBody("A");
 
     // Attempt conditional cache validation and a DNS miss.
-    client.connectionPool().evictAll();
     client = client.newBuilder()
         .dns(new FakeDns())
         .build();
@@ -1581,9 +1716,12 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertCode(301)
         .assertHeader("Test", "Redirect from /a to /b");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
-    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Connection reused.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    // Connection reused again!
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
   }
 
   @Test public void postRedirectsToGet() throws Exception {
@@ -1595,16 +1733,16 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Response response = client.newCall(new Request.Builder()
         .url(server.url("/page1"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "Request Body"))
         .build()).execute();
-    assertEquals("Page 2", response.body().string());
+    assertThat(response.body().string()).isEqualTo("Page 2");
 
     RecordedRequest page1 = server.takeRequest();
-    assertEquals("POST /page1 HTTP/1.1", page1.getRequestLine());
-    assertEquals("Request Body", page1.getBody().readUtf8());
+    assertThat(page1.getRequestLine()).isEqualTo("POST /page1 HTTP/1.1");
+    assertThat(page1.getBody().readUtf8()).isEqualTo("Request Body");
 
     RecordedRequest page2 = server.takeRequest();
-    assertEquals("GET /page2 HTTP/1.1", page2.getRequestLine());
+    assertThat(page2.getRequestLine()).isEqualTo("GET /page2 HTTP/1.1");
   }
 
   @Test public void getClientRequestTimeout() throws Exception {
@@ -1620,7 +1758,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     Response response = client.newCall(request).execute();
 
-    assertEquals("Body", response.body().string());
+    assertThat(response.body().string()).isEqualTo("Body");
   }
 
   @Test public void getClientRequestTimeoutWithBackPressure() throws Exception {
@@ -1636,7 +1774,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     Response response = client.newCall(request).execute();
 
-    assertEquals("You took too long!", response.body().string());
+    assertThat(response.body().string()).isEqualTo("You took too long!");
   }
 
   @Test public void requestBodyRetransmittedOnClientRequestTimeout() throws Exception {
@@ -1649,17 +1787,17 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "Hello"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "Hello"))
         .build();
     Response response = client.newCall(request).execute();
 
-    assertEquals("Body", response.body().string());
+    assertThat(response.body().string()).isEqualTo("Body");
 
     RecordedRequest request1 = server.takeRequest();
-    assertEquals("Hello", request1.getBody().readUtf8());
+    assertThat(request1.getBody().readUtf8()).isEqualTo("Hello");
 
     RecordedRequest request2 = server.takeRequest();
-    assertEquals("Hello", request2.getBody().readUtf8());
+    assertThat(request2.getBody().readUtf8()).isEqualTo("Hello");
   }
 
   @Test public void disableClientRequestTimeoutRetry() throws IOException {
@@ -1678,8 +1816,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     Response response = client.newCall(request).execute();
 
-    assertEquals(408, response.code());
-    assertEquals("You took too long!", response.body().string());
+    assertThat(response.code()).isEqualTo(408);
+    assertThat(response.body().string()).isEqualTo("You took too long!");
   }
 
   @Test public void maxClientRequestTimeoutRetries() throws IOException {
@@ -1699,10 +1837,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     Response response = client.newCall(request).execute();
 
-    assertEquals(408, response.code());
-    assertEquals("You took too long!", response.body().string());
+    assertThat(response.code()).isEqualTo(408);
+    assertThat(response.body().string()).isEqualTo("You took too long!");
 
-    assertEquals(2, server.getRequestCount());
+    assertThat(server.getRequestCount()).isEqualTo(2);
   }
 
   @Test public void maxUnavailableTimeoutRetries() throws IOException {
@@ -1724,10 +1862,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     Response response = client.newCall(request).execute();
 
-    assertEquals(503, response.code());
-    assertEquals("You took too long!", response.body().string());
+    assertThat(response.code()).isEqualTo(503);
+    assertThat(response.body().string()).isEqualTo("You took too long!");
 
-    assertEquals(2, server.getRequestCount());
+    assertThat(server.getRequestCount()).isEqualTo(2);
   }
 
   @Test public void retryOnUnavailableWith0RetryAfter() throws IOException {
@@ -1744,7 +1882,72 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
     Response response = client.newCall(request).execute();
 
-    assertEquals("Body", response.body().string());
+    assertThat(response.body().string()).isEqualTo("Body");
+  }
+
+  @Test public void canRetryNormalRequestBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(503)
+        .setHeader("Retry-After", "0")
+        .setBody("please retry"));
+    server.enqueue(new MockResponse()
+        .setBody("thank you for retrying"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(new RequestBody() {
+          int attempt = 0;
+
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.writeUtf8("attempt " + (attempt++));
+          }
+        })
+        .build();
+    Response response = client.newCall(request).execute();
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.body().string()).isEqualTo("thank you for retrying");
+
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("attempt 0");
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("attempt 1");
+    assertThat(server.getRequestCount()).isEqualTo(2);
+  }
+
+  @Test public void cannotRetryOneShotRequestBody() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(503)
+        .setHeader("Retry-After", "0")
+        .setBody("please retry"));
+    server.enqueue(new MockResponse()
+        .setBody("thank you for retrying"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(new RequestBody() {
+          int attempt = 0;
+
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.writeUtf8("attempt " + (attempt++));
+          }
+
+          @Override public boolean isOneShot() {
+            return true;
+          }
+        })
+        .build();
+    Response response = client.newCall(request).execute();
+    assertThat(response.code()).isEqualTo(503);
+    assertThat(response.body().string()).isEqualTo("please retry");
+
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("attempt 0");
+    assertThat(server.getRequestCount()).isEqualTo(1);
   }
 
   @Test public void propfindRedirectsToPropfindAndMaintainsRequestBody() throws Exception {
@@ -1758,19 +1961,19 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     // when
     Response response = client.newCall(new Request.Builder()
         .url(server.url("/page1"))
-        .method("PROPFIND", RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
+        .method("PROPFIND", RequestBody.create(MediaType.get("text/plain"), "Request Body"))
         .build()).execute();
 
     // then
-    assertEquals("Page 2", response.body().string());
+    assertThat(response.body().string()).isEqualTo("Page 2");
 
     RecordedRequest page1 = server.takeRequest();
-    assertEquals("PROPFIND /page1 HTTP/1.1", page1.getRequestLine());
-    assertEquals("Request Body", page1.getBody().readUtf8());
+    assertThat(page1.getRequestLine()).isEqualTo("PROPFIND /page1 HTTP/1.1");
+    assertThat(page1.getBody().readUtf8()).isEqualTo("Request Body");
 
     RecordedRequest page2 = server.takeRequest();
-    assertEquals("PROPFIND /page2 HTTP/1.1", page2.getRequestLine());
-    assertEquals("Request Body", page2.getBody().readUtf8());
+    assertThat(page2.getRequestLine()).isEqualTo("PROPFIND /page2 HTTP/1.1");
+    assertThat(page2.getBody().readUtf8()).isEqualTo("Request Body");
   }
 
   @Test public void responseCookies() throws Exception {
@@ -1786,11 +1989,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously("/").assertCode(200);
 
     List<Cookie> responseCookies = cookieJar.takeResponseCookies();
-    assertEquals(2, responseCookies.size());
-    assertEquals("a=b; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/",
-        responseCookies.get(0).toString());
-    assertEquals("c=d; expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure",
-        responseCookies.get(1).toString());
+    assertThat(responseCookies.size()).isEqualTo(2);
+    assertThat(responseCookies.get(0).toString()).isEqualTo(
+        "a=b; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/");
+    assertThat(responseCookies.get(1).toString()).isEqualTo(
+        "c=d; expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure");
   }
 
   @Test public void requestCookies() throws Exception {
@@ -1808,7 +2011,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     executeSynchronously("/").assertCode(200);
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("a=b; c=d", recordedRequest.getHeader("Cookie"));
+    assertThat(recordedRequest.getHeader("Cookie")).isEqualTo("a=b; c=d");
   }
 
   @Test public void redirectsDoNotIncludeTooManyCookies() throws Exception {
@@ -1831,13 +2034,13 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     Response response = client.newCall(new Request.Builder()
         .url(server.url("/page1"))
         .build()).execute();
-    assertEquals("Page 2", response.body().string());
+    assertThat(response.body().string()).isEqualTo("Page 2");
 
     RecordedRequest request1 = server.takeRequest();
-    assertEquals("c=cookie", request1.getHeader("Cookie"));
+    assertThat(request1.getHeader("Cookie")).isEqualTo("c=cookie");
 
     RecordedRequest request2 = server2.takeRequest();
-    assertNull(request2.getHeader("Cookie"));
+    assertThat(request2.getHeader("Cookie")).isNull();
   }
 
   @Test public void redirectsDoNotIncludeTooManyAuthHeaders() throws Exception {
@@ -1849,16 +2052,16 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .addHeader("Location: " + server2.url("/b")));
 
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")))
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret"), null))
         .build();
 
     Request request = new Request.Builder().url(server.url("/a")).build();
     Response response = client.newCall(request).execute();
-    assertEquals("Page 2", response.body().string());
+    assertThat(response.body().string()).isEqualTo("Page 2");
 
     RecordedRequest redirectRequest = server2.takeRequest();
-    assertNull(redirectRequest.getHeader("Authorization"));
-    assertEquals("/b", redirectRequest.getPath());
+    assertThat(redirectRequest.getHeader("Authorization")).isNull();
+    assertThat(redirectRequest.getPath()).isEqualTo("/b");
   }
 
   @Test public void redirect_Async() throws Exception {
@@ -1887,9 +2090,12 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertCode(301)
         .assertHeader("Test", "Redirect from /a to /b");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
-    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Connection reused.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    // Connection reused again!
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
   }
 
   @Test public void follow20Redirects() throws Exception {
@@ -1934,7 +2140,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
       fail();
     } catch (IOException expected) {
-      assertEquals("Too many follow-up requests: 21", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("Too many follow-up requests: 21");
     }
   }
 
@@ -1979,7 +2185,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .setBody("I'm not even supposed to be here today."));
 
     executeSynchronously("/")
-        .assertFailureMatches(".*unexpected end of stream on Connection.*");
+        .assertFailureMatches(".*unexpected end of stream on " + server.url("/").redact());
   }
 
   private String stringFill(char fillChar, int length) {
@@ -1997,7 +2203,7 @@ private String stringFill(char fillChar, int length) {
       fail();
     } catch (IOException expected) {
     }
-    assertEquals(0, server.getRequestCount());
+    assertThat(server.getRequestCount()).isEqualTo(0);
   }
 
   @Test public void cancelDuringHttpConnect() throws Exception {
@@ -2026,16 +2232,31 @@ private void cancelDuringConnect(String scheme) throws Exception {
     } catch (IOException expected) {
     }
     long elapsedNanos = System.nanoTime() - startNanos;
-    assertEquals(cancelDelayMillis, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 100f);
+    assertThat((float) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(
+        (float) cancelDelayMillis, offset(100f));
   }
 
   @Test public void cancelImmediatelyAfterEnqueue() throws Exception {
     server.enqueue(new MockResponse());
+    final CountDownLatch latch = new CountDownLatch(1);
+    client = client.newBuilder()
+        .addNetworkInterceptor(chain -> {
+          try {
+            latch.await();
+          } catch (InterruptedException e) {
+            throw new AssertionError(e);
+          }
+          return chain.proceed(chain.request());
+        })
+        .build();
+
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/a"))
         .build());
     call.enqueue(callback);
     call.cancel();
+    latch.countDown();
+
     callback.await(server.url("/a")).assertFailure("Canceled", "Socket closed");
   }
 
@@ -2048,16 +2269,42 @@ private void cancelDuringConnect(String scheme) throws Exception {
     callback.await(server.url("/")).assertFailure("Canceled", "Socket closed");
   }
 
+  @Test
+  public void cancelWhileRequestHeadersAreSent() throws Exception {
+    server.enqueue(new MockResponse().setBody("A"));
+
+    EventListener listener = new EventListener() {
+      @Override public void requestHeadersStart(Call call) {
+        try {
+          // Cancel call from another thread to avoid reentrance.
+          cancelLater(call, 0).join();
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+      }
+    };
+    client = client.newBuilder().eventListener(listener).build();
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test
+  public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    cancelWhileRequestHeadersAreSent();
+  }
+
   @Test public void cancelBeforeBodyIsRead() throws Exception {
     server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
 
     final Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
     ExecutorService executor = Executors.newSingleThreadExecutor();
-    Future<Response> result = executor.submit(new Callable<Response>() {
-      @Override public Response call() throws Exception {
-        return call.execute();
-      }
-    });
+    Future<Response> result = executor.submit(call::execute);
 
     Thread.sleep(100); // wait for it to go in flight.
 
@@ -2067,7 +2314,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
       fail();
     } catch (IOException expected) {
     }
-    assertEquals(1, server.getRequestCount());
+    assertThat(server.getRequestCount()).isEqualTo(1);
   }
 
   @Test public void cancelInFlightBeforeResponseReadThrowsIOE() throws Exception {
@@ -2126,7 +2373,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
     callA.enqueue(callback);
     callB.enqueue(callback);
-    assertEquals("/a", server.takeRequest().getPath());
+    assertThat(server.takeRequest().getPath()).isEqualTo("/a");
 
     callback.await(requestA.url()).assertBody("A");
     // At this point we know the callback is ready, and that it will receive a cancel failure.
@@ -2154,7 +2401,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
     });
 
     call.enqueue(callback);
-    assertEquals("/a", server.takeRequest().getPath());
+    assertThat(server.takeRequest().getPath()).isEqualTo("/a");
 
     callback.await(requestA.url()).assertFailure("Canceled", "stream was reset: CANCEL",
         "Socket closed");
@@ -2203,8 +2450,8 @@ private void cancelDuringConnect(String scheme) throws Exception {
     });
 
     latch.await();
-    assertEquals("A", bodyRef.get());
-    assertFalse(failureRef.get());
+    assertThat(bodyRef.get()).isEqualTo("A");
+    assertThat(failureRef.get()).isFalse();
   }
 
   @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTPS()
@@ -2221,12 +2468,11 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
   @Test public void cancelWithInterceptor() throws Exception {
     client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            chain.proceed(chain.request());
-            throw new AssertionError(); // We expect an exception.
-          }
-        }).build();
+        .addInterceptor(chain -> {
+          chain.proceed(chain.request());
+          throw new AssertionError(); // We expect an exception.
+        })
+        .build();
 
     Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
     call.cancel();
@@ -2236,7 +2482,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
       fail();
     } catch (IOException expected) {
     }
-    assertEquals(0, server.getRequestCount());
+    assertThat(server.getRequestCount()).isEqualTo(0);
   }
 
   @Test public void gzip() throws Exception {
@@ -2271,7 +2517,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .setBody(gzip("abcabcabc"))
         .addHeader("Content-Encoding: gzip"));
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator("password"))
+        .authenticator(new RecordingOkAuthenticator("password", null))
         .build();
 
     executeSynchronously("/").assertBody("abcabcabc");
@@ -2296,12 +2542,12 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
     // The response is not decompressed.
     Response response = call.execute();
-    assertEquals("gzip", response.header("Content-Encoding"));
-    assertEquals(gzippedBody.snapshot(), response.body().source().readByteString());
+    assertThat(response.header("Content-Encoding")).isEqualTo("gzip");
+    assertThat(response.body().source().readByteString()).isEqualTo(gzippedBody.snapshot());
 
     // The request did not offer gzip support.
     RecordedRequest recordedRequest = server.takeRequest();
-    assertNull(recordedRequest.getHeader("Accept-Encoding"));
+    assertThat(recordedRequest.getHeader("Accept-Encoding")).isNull();
   }
 
   @Test public void asyncResponseCanBeConsumedLater() throws Exception {
@@ -2329,13 +2575,15 @@ private void cancelDuringConnect(String scheme) throws Exception {
     });
 
     Response response = responseRef.take();
-    assertEquals(200, response.code());
-    assertEquals("abc", response.body().string());
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.body().string()).isEqualTo("abc");
 
     // Make another request just to confirm that that connection can be reused...
     executeSynchronously("/").assertBody("def");
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Connection reused.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
 
     // ... even before we close the response body!
     response.body().close();
@@ -2347,8 +2595,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
     executeSynchronously("/");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertTrue(recordedRequest.getHeader("User-Agent")
-        .matches(Version.userAgent()));
+    assertThat(recordedRequest.getHeader("User-Agent")).matches(Version.userAgent());
   }
 
   @Test public void setFollowRedirectsFalse() throws Exception {
@@ -2373,14 +2620,14 @@ private void cancelDuringConnect(String scheme) throws Exception {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     executeSynchronously(request)
         .assertCode(200)
         .assertSuccessful();
 
-    assertEquals("abc", server.takeRequest().getBody().readUtf8());
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("abc");
   }
 
   @Test public void expect100ContinueEmptyRequestBody() throws Exception {
@@ -2389,7 +2636,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), ""))
+        .post(RequestBody.create(MediaType.get("text/plain"), ""))
         .build();
 
     executeSynchronously(request)
@@ -2413,7 +2660,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     Call call = client.newCall(request);
@@ -2424,7 +2671,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
     }
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("", recordedRequest.getBody().readUtf8());
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("");
   }
 
   @Test public void expect100ContinueTimesOutWithoutContinue_HTTP2() throws Exception {
@@ -2438,7 +2685,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     executeSynchronously(request)
@@ -2446,7 +2693,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .assertSuccessful();
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("abc", recordedRequest.getBody().readUtf8());
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("abc");
   }
 
   @Test public void serverRespondsWithUnsolicited100Continue_HTTP2() throws Exception {
@@ -2464,7 +2711,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     Call call = client.newCall(request);
@@ -2475,7 +2722,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
     }
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("abc", recordedRequest.getBody().readUtf8());
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("abc");
   }
 
   @Test public void serverRespondsWith100ContinueOnly_HTTP2() throws Exception {
@@ -2491,14 +2738,14 @@ private void cancelDuringConnect(String scheme) throws Exception {
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build());
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
         .build());
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void successfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
@@ -2513,14 +2760,14 @@ private void cancelDuringConnect(String scheme) throws Exception {
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build());
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
         .build());
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void unsuccessfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
@@ -2532,24 +2779,24 @@ private void cancelDuringConnect(String scheme) throws Exception {
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build());
     executeSynchronously(new Request.Builder()
         .url(server.url("/"))
         .build());
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   /** We forbid non-ASCII characters in outgoing request headers, but accept UTF-8. */
   @Test public void responseHeaderParsingIsLenient() throws Exception {
-    Headers headers = new Headers.Builder()
-        .add("Content-Length", "0")
-        .addLenient("a\tb: c\u007fd")
-        .addLenient(": ef")
-        .addLenient("\ud83c\udf69: \u2615\ufe0f")
-        .build();
+    Headers.Builder headersBuilder = new Headers.Builder();
+    headersBuilder.add("Content-Length", "0");
+    addHeaderLenient(headersBuilder, "a\tb: c\u007fd");
+    addHeaderLenient(headersBuilder, ": ef");
+    addHeaderLenient(headersBuilder, "\ud83c\udf69: \u2615\ufe0f");
+    Headers headers = headersBuilder.build();
     server.enqueue(new MockResponse().setHeaders(headers));
 
     executeSynchronously("/")
@@ -2618,12 +2865,12 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .url(server.url("/"))
         .post(requestBody)
         .build());
-    assertEquals("Response 1", call.execute().body().string());
+    assertThat(call.execute().body().string()).isEqualTo("Response 1");
   }
 
   /** Test which headers are sent unencrypted to the HTTP proxy. */
   @Test public void proxyConnectOmitsApplicationHeaders() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
         .clearHeaders());
@@ -2632,7 +2879,8 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
         .hostnameVerifier(hostnameVerifier)
         .build();
@@ -2643,24 +2891,25 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .header("User-Agent", "App 1.0")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("encrypted response from the origin server", response.body().string());
+    assertThat(response.body().string()).isEqualTo(
+        "encrypted response from the origin server");
 
     RecordedRequest connect = server.takeRequest();
-    assertNull(connect.getHeader("Private"));
-    assertEquals(Version.userAgent(), connect.getHeader("User-Agent"));
-    assertEquals("Keep-Alive", connect.getHeader("Proxy-Connection"));
-    assertEquals("android.com:443", connect.getHeader("Host"));
+    assertThat(connect.getHeader("Private")).isNull();
+    assertThat(connect.getHeader("User-Agent")).isEqualTo(Version.userAgent());
+    assertThat(connect.getHeader("Proxy-Connection")).isEqualTo("Keep-Alive");
+    assertThat(connect.getHeader("Host")).isEqualTo("android.com:443");
 
     RecordedRequest get = server.takeRequest();
-    assertEquals("Secret", get.getHeader("Private"));
-    assertEquals("App 1.0", get.getHeader("User-Agent"));
+    assertThat(get.getHeader("Private")).isEqualTo("Secret");
+    assertThat(get.getHeader("User-Agent")).isEqualTo("App 1.0");
 
-    assertEquals(Arrays.asList("verify android.com"), hostnameVerifier.calls);
+    assertThat(hostnameVerifier.calls).containsExactly("verify android.com");
   }
 
   /** Respond to a proxy authorization challenge. */
   @Test public void proxyAuthenticateOnConnect() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(new MockResponse()
         .setResponseCode(407)
         .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
@@ -2671,9 +2920,10 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
@@ -2681,19 +2931,19 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .url("https://android.com/foo")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("response body", response.body().string());
+    assertThat(response.body().string()).isEqualTo("response body");
 
     RecordedRequest connect1 = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect1.getRequestLine());
-    assertNull(connect1.getHeader("Proxy-Authorization"));
+    assertThat(connect1.getRequestLine()).isEqualTo("CONNECT android.com:443 HTTP/1.1");
+    assertThat(connect1.getHeader("Proxy-Authorization")).isNull();
 
     RecordedRequest connect2 = server.takeRequest();
-    assertEquals("CONNECT android.com:443 HTTP/1.1", connect2.getRequestLine());
-    assertEquals("password", connect2.getHeader("Proxy-Authorization"));
+    assertThat(connect2.getRequestLine()).isEqualTo("CONNECT android.com:443 HTTP/1.1");
+    assertThat(connect2.getHeader("Proxy-Authorization")).isEqualTo("password");
 
     RecordedRequest get = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", get.getRequestLine());
-    assertNull(get.getHeader("Proxy-Authorization"));
+    assertThat(get.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(get.getHeader("Proxy-Authorization")).isNull();
   }
 
   /** Confirm that the proxy authenticator works for unencrypted HTTP proxies. */
@@ -2706,22 +2956,22 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
     client = client.newBuilder()
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .build();
 
     Request request = new Request.Builder()
         .url("http://android.com/foo")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("response body", response.body().string());
+    assertThat(response.body().string()).isEqualTo("response body");
 
     RecordedRequest get1 = server.takeRequest();
-    assertEquals("GET http://android.com/foo HTTP/1.1", get1.getRequestLine());
-    assertNull(get1.getHeader("Proxy-Authorization"));
+    assertThat(get1.getRequestLine()).isEqualTo("GET http://android.com/foo HTTP/1.1");
+    assertThat(get1.getHeader("Proxy-Authorization")).isNull();
 
     RecordedRequest get2 = server.takeRequest();
-    assertEquals("GET http://android.com/foo HTTP/1.1", get2.getRequestLine());
-    assertEquals("password", get2.getHeader("Proxy-Authorization"));
+    assertThat(get2.getRequestLine()).isEqualTo("GET http://android.com/foo HTTP/1.1");
+    assertThat(get2.getHeader("Proxy-Authorization")).isEqualTo("password");
   }
 
   /**
@@ -2729,7 +2979,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
    * TLS tunnel. https://github.com/square/okhttp/issues/2426
    */
   @Test public void proxyAuthenticateOnConnectWithConnectionClose() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
     server.enqueue(new MockResponse()
         .setResponseCode(407)
@@ -2742,9 +2992,10 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
@@ -2752,20 +3003,20 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .url("https://android.com/foo")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("response body", response.body().string());
+    assertThat(response.body().string()).isEqualTo("response body");
 
     // First CONNECT call needs a new connection.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
 
     // Second CONNECT call needs a new connection.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
 
     // GET reuses the connection from the second connect.
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void tooManyProxyAuthFailuresWithConnectionClose() throws IOException {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
     for (int i = 0; i < 21; i++) {
       server.enqueue(new MockResponse()
@@ -2775,9 +3026,10 @@ private void cancelDuringConnect(String scheme) throws Exception {
     }
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
@@ -2796,8 +3048,8 @@ private void cancelDuringConnect(String scheme) throws Exception {
    * We used to have that behavior but it is problematic because unrelated requests end up sharing
    * credentials. Worse, that approach leaks proxy credentials to the origin server.
    */
-  @Test public void noProactiveProxyAuthorization() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+  @Test public void noPreemptiveProxyAuthorization() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
         .clearHeaders());
@@ -2805,7 +3057,8 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
@@ -2815,13 +3068,105 @@ private void cancelDuringConnect(String scheme) throws Exception {
         .header("Proxy-Authorization", "password")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("response body", response.body().string());
+    assertThat(response.body().string()).isEqualTo("response body");
+
+    RecordedRequest connect1 = server.takeRequest();
+    assertThat(connect1.getHeader("Proxy-Authorization")).isNull();
+
+    RecordedRequest connect2 = server.takeRequest();
+    assertThat(connect2.getHeader("Proxy-Authorization")).isEqualTo("password");
+  }
+
+  /** Confirm that we can send authentication information without being prompted first. */
+  @Test public void preemptiveProxyAuthentication() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("encrypted response from the origin server"));
+
+    final String credential = Credentials.basic("jesse", "password1");
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .proxy(server.toProxyAddress())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxyAuthenticator((route, response) -> {
+          assertThat(response.request().method()).isEqualTo("CONNECT");
+          assertThat(response.code()).isEqualTo(HttpURLConnection.HTTP_PROXY_AUTH);
+          assertThat(response.request().url().host()).isEqualTo("android.com");
+
+          List<Challenge> challenges = response.challenges();
+          assertThat(challenges.get(0).scheme()).isEqualTo("OkHttp-Preemptive");
+
+          return response.request().newBuilder()
+              .header("Proxy-Authorization", credential)
+              .build();
+        })
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+
+    executeSynchronously(request).assertSuccessful();
 
     RecordedRequest connect = server.takeRequest();
-    assertNull(connect.getHeader("Proxy-Authorization"));
+    assertThat(connect.getMethod()).isEqualTo("CONNECT");
+    assertThat(connect.getHeader("Proxy-Authorization")).isEqualTo(credential);
+    assertThat(connect.getPath()).isEqualTo("/");
 
     RecordedRequest get = server.takeRequest();
-    assertEquals("password", get.getHeader("Proxy-Authorization"));
+    assertThat(get.getMethod()).isEqualTo("GET");
+    assertThat(get.getHeader("Proxy-Authorization")).isNull();
+    assertThat(get.getPath()).isEqualTo("/foo");
+  }
+
+  @Test public void preemptiveThenReactiveProxyAuthentication() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_PROXY_AUTH)
+        .addHeader("Proxy-Authenticate", "Basic realm=\"localhost\"")
+        .setBody("proxy auth required"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse());
+
+    final List<String> challengeSchemes = new ArrayList<>();
+    final String credential = Credentials.basic("jesse", "password1");
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .proxy(server.toProxyAddress())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxyAuthenticator((route, response) -> {
+          List<Challenge> challenges = response.challenges();
+          challengeSchemes.add(challenges.get(0).scheme());
+          return response.request().newBuilder()
+              .header("Proxy-Authorization", credential)
+              .build();
+        })
+        .build();
+
+    Request request = new Request.Builder()
+        .url("https://android.com/foo")
+        .build();
+
+    executeSynchronously(request).assertSuccessful();
+
+    RecordedRequest connect1 = server.takeRequest();
+    assertThat(connect1.getMethod()).isEqualTo("CONNECT");
+    assertThat(connect1.getHeader("Proxy-Authorization")).isEqualTo(credential);
+
+    RecordedRequest connect2 = server.takeRequest();
+    assertThat(connect2.getMethod()).isEqualTo("CONNECT");
+    assertThat(connect2.getHeader("Proxy-Authorization")).isEqualTo(credential);
+
+    assertThat(challengeSchemes).containsExactly("OkHttp-Preemptive", "Basic");
   }
 
   @Test public void interceptorGetsHttp2() throws Exception {
@@ -2829,11 +3174,9 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
     // Capture the protocol as it is observed by the interceptor.
     final AtomicReference<Protocol> protocolRef = new AtomicReference<>();
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        protocolRef.set(chain.connection().protocol());
-        return chain.proceed(chain.request());
-      }
+    Interceptor interceptor = chain -> {
+      protocolRef.set(chain.connection().protocol());
+      return chain.proceed(chain.request());
     };
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -2842,7 +3185,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
     // Make an HTTP/2 request and confirm that the protocol matches.
     server.enqueue(new MockResponse());
     executeSynchronously("/");
-    assertEquals(Protocol.HTTP_2, protocolRef.get());
+    assertThat(protocolRef.get()).isEqualTo(Protocol.HTTP_2);
   }
 
   @Test public void serverSendsInvalidResponseHeaders() throws Exception {
@@ -2882,7 +3225,8 @@ private void cancelDuringConnect(String scheme) throws Exception {
       new Request.Builder().addHeader("a b", "c");
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("Unexpected char 0x20 at 1 in header name: a b", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0x20 at 1 in header name: a b");
     }
   }
 
@@ -2891,7 +3235,8 @@ private void cancelDuringConnect(String scheme) throws Exception {
       new Request.Builder().addHeader("a\tb", "c");
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("Unexpected char 0x09 at 1 in header name: a\tb", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0x09 at 1 in header name: a\tb");
     }
   }
 
@@ -2903,7 +3248,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals("c", response.header("a b"));
+    assertThat(response.header("a b")).isEqualTo("c");
   }
 
   @Test public void responseHeaderNameWithTabPermitted() throws Exception {
@@ -2914,7 +3259,7 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals("c", response.header("a\tb"));
+    assertThat(response.header("a\tb")).isEqualTo("c");
   }
 
   @Test public void connectFails() throws Exception {
@@ -2937,17 +3282,17 @@ private void cancelDuringConnect(String scheme) throws Exception {
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     executeSynchronously(request);
-    assertEquals("abc", server.takeRequest().getBody().readUtf8());
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("abc");
   }
 
   @Ignore // This may fail in DNS lookup, which we don't have timeouts for.
   @Test public void invalidHost() throws Exception {
     Request request = new Request.Builder()
-        .url(HttpUrl.parse("http://1234.1.1.1/"))
+        .url(HttpUrl.get("http://1234.1.1.1/"))
         .build();
 
     executeSynchronously(request)
@@ -2957,29 +3302,29 @@ private void cancelDuringConnect(String scheme) throws Exception {
   @Test public void uploadBodySmallChunkedEncoding() throws Exception {
     upload(true, 1048576, 256);
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(1048576, recordedRequest.getBodySize());
-    assertFalse(recordedRequest.getChunkSizes().isEmpty());
+    assertThat(recordedRequest.getBodySize()).isEqualTo(1048576);
+    assertThat(recordedRequest.getChunkSizes()).isNotEmpty();
   }
 
   @Test public void uploadBodyLargeChunkedEncoding() throws Exception {
     upload(true, 1048576, 65536);
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(1048576, recordedRequest.getBodySize());
-    assertFalse(recordedRequest.getChunkSizes().isEmpty());
+    assertThat(recordedRequest.getBodySize()).isEqualTo(1048576);
+    assertThat(recordedRequest.getChunkSizes()).isNotEmpty();
   }
 
   @Test public void uploadBodySmallFixedLength() throws Exception {
     upload(false, 1048576, 256);
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(1048576, recordedRequest.getBodySize());
-    assertTrue(recordedRequest.getChunkSizes().isEmpty());
+    assertThat(recordedRequest.getBodySize()).isEqualTo(1048576);
+    assertThat(recordedRequest.getChunkSizes()).isEmpty();
   }
 
   @Test public void uploadBodyLargeFixedLength() throws Exception {
     upload(false, 1048576, 65536);
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(1048576, recordedRequest.getBodySize());
-    assertTrue(recordedRequest.getChunkSizes().isEmpty());
+    assertThat(recordedRequest.getBodySize()).isEqualTo(1048576);
+    assertThat(recordedRequest.getChunkSizes()).isEmpty();
   }
 
   private void upload(
@@ -2994,7 +3339,7 @@ private void upload(
   /** https://github.com/square/okhttp/issues/2344 */
   @Test public void ipv6HostHasSquareBraces() throws Exception {
     // Use a proxy to fake IPv6 connectivity, even if localhost doesn't have IPv6.
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
@@ -3003,7 +3348,8 @@ private void upload(
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .proxy(server.toProxyAddress())
         .build();
@@ -3012,15 +3358,15 @@ private void upload(
         .url("https://[::1]/")
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("response body", response.body().string());
+    assertThat(response.body().string()).isEqualTo("response body");
 
     RecordedRequest connect = server.takeRequest();
-    assertEquals("CONNECT [::1]:443 HTTP/1.1", connect.getRequestLine());
-    assertEquals("[::1]:443", connect.getHeader("Host"));
+    assertThat(connect.getRequestLine()).isEqualTo("CONNECT [::1]:443 HTTP/1.1");
+    assertThat(connect.getHeader("Host")).isEqualTo("[::1]:443");
 
     RecordedRequest get = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", get.getRequestLine());
-    assertEquals("[::1]", get.getHeader("Host"));
+    assertThat(get.getRequestLine()).isEqualTo("GET / HTTP/1.1");
+    assertThat(get.getHeader("Host")).isEqualTo("[::1]");
   }
 
   private RequestBody requestBody(final boolean chunked, final long size, final int writeSize) {
@@ -3029,7 +3375,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
 
     return new RequestBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain; charset=utf-8");
+        return MediaType.get("text/plain; charset=utf-8");
       }
 
       @Override public long contentLength() throws IOException {
@@ -3057,7 +3403,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     server.enqueue(new MockResponse()
         .setBody("This gets leaked."));
 
-    client = defaultClient().newBuilder()
+    client = clientTestRule.client.newBuilder()
         .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
         .build();
 
@@ -3073,10 +3419,10 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
       awaitGarbageCollection();
 
       String message = logHandler.take();
-      assertTrue(message.contains("A connection to " + server.url("/") + " was leaked."
-          + " Did you forget to close a response body?"));
-      assertTrue(message.contains("okhttp3.RealCall.execute("));
-      assertTrue(message.contains("okhttp3.CallTest.leakedResponseBodyLogsStackTrace("));
+      assertThat(message).contains("A connection to " + server.url("/") + " was leaked."
+            + " Did you forget to close a response body?");
+      assertThat(message).contains("okhttp3.RealCall.execute(");
+      assertThat(message).contains("okhttp3.CallTest.leakedResponseBodyLogsStackTrace(");
     } finally {
       logger.setLevel(original);
     }
@@ -3086,7 +3432,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     server.enqueue(new MockResponse()
         .setBody("This gets leaked."));
 
-    client = defaultClient().newBuilder()
+    client = clientTestRule.client.newBuilder()
         .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
         .build();
 
@@ -3116,32 +3462,69 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
       awaitGarbageCollection();
 
       String message = logHandler.take();
-      assertTrue(message.contains("A connection to " + server.url("/") + " was leaked."
-          + " Did you forget to close a response body?"));
-      assertTrue(message.contains("okhttp3.RealCall.enqueue("));
-      assertTrue(message.contains("okhttp3.CallTest.asyncLeakedResponseBodyLogsStackTrace("));
+      assertThat(message).contains("A connection to " + server.url("/") + " was leaked."
+            + " Did you forget to close a response body?");
+      assertThat(message).contains("okhttp3.RealCall.enqueue(");
+      assertThat(message).contains("okhttp3.CallTest.asyncLeakedResponseBodyLogsStackTrace(");
     } finally {
       logger.setLevel(original);
     }
   }
 
+  @Test public void failedAuthenticatorReleasesConnection() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+
+    client = client.newBuilder()
+        .authenticator((route, response) -> { throw new IOException("IOException!"); })
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    executeSynchronously(request)
+        .assertFailure(IOException.class);
+
+    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(1);
+  }
+
+  @Test public void failedProxyAuthenticatorReleasesConnection() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(407));
+
+    client = client.newBuilder()
+        .proxyAuthenticator((route, response) -> { throw new IOException("IOException!"); })
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    executeSynchronously(request)
+        .assertFailure(IOException.class);
+
+    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(1);
+  }
+
   @Test public void httpsWithIpAddress() throws Exception {
     String localIpAddress = InetAddress.getLoopbackAddress().getHostAddress();
 
     // Create a certificate with an IP address in the subject alt name.
     HeldCertificate heldCertificate = new HeldCertificate.Builder()
         .commonName("example.com")
-        .subjectAlternativeName(localIpAddress)
+        .addSubjectAlternativeName(localIpAddress)
         .build();
-    SslClient sslClient = new SslClient.Builder()
-        .certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
-        .addTrustedCertificate(heldCertificate.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(heldCertificate)
+        .addTrustedCertificate(heldCertificate.certificate())
         .build();
 
     // Use that certificate on the server and trust it on the client.
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .protocols(Collections.singletonList(Protocol.HTTP_1_1))
         .build();
@@ -3159,7 +3542,144 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
 
     // Confirm that the IP address was used in the host header.
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(localIpAddress + ":" + server.getPort(), recordedRequest.getHeader("Host"));
+    assertThat(recordedRequest.getHeader("Host")).isEqualTo(
+        (localIpAddress + ":" + server.getPort()));
+  }
+
+  @Test public void postWithFileNotFound() throws Exception {
+    final AtomicInteger called = new AtomicInteger(0);
+
+    RequestBody body = new RequestBody() {
+      @Nullable @Override public MediaType contentType() {
+        return MediaType.get("application/octet-stream");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        called.incrementAndGet();
+        throw new FileNotFoundException();
+      }
+    };
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(body)
+        .build();
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    executeSynchronously(request)
+        .assertFailure(FileNotFoundException.class);
+
+    assertThat(called.get()).isEqualTo(1L);
+  }
+
+  @Test public void clientReadsHeadersDataTrailersHttp1ChunkedTransferEncoding() throws Exception {
+    MockResponse mockResponse = new MockResponse()
+        .clearHeaders()
+        .addHeader("h1", "v1")
+        .addHeader("h2", "v2")
+        .setChunkedBody("HelloBonjour", 1024)
+        .setTrailers(Headers.of("trailers", "boom"));
+    server.enqueue(mockResponse);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    BufferedSource source = response.body().source();
+
+    assertThat(response.header("h1")).isEqualTo("v1");
+    assertThat(response.header("h2")).isEqualTo("v2");
+
+    assertThat(source.readUtf8(5)).isEqualTo("Hello");
+    assertThat(source.readUtf8(7)).isEqualTo("Bonjour");
+
+    assertThat(source.exhausted()).isTrue();
+    assertThat(response.trailers()).isEqualTo(Headers.of("trailers", "boom"));
+  }
+
+  @Test public void clientReadsHeadersDataTrailersHttp2() throws IOException {
+    MockResponse mockResponse = new MockResponse()
+        .clearHeaders()
+        .addHeader("h1", "v1")
+        .addHeader("h2", "v2")
+        .setBody("HelloBonjour")
+        .setTrailers(Headers.of("trailers", "boom"));
+    server.enqueue(mockResponse);
+    enableProtocol(Protocol.HTTP_2);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    try (Response response = call.execute()) {
+      BufferedSource source = response.body().source();
+
+      assertThat(response.header("h1")).isEqualTo("v1");
+      assertThat(response.header("h2")).isEqualTo("v2");
+
+      assertThat(source.readUtf8(5)).isEqualTo("Hello");
+      assertThat(source.readUtf8(7)).isEqualTo("Bonjour");
+
+      assertThat(source.exhausted()).isTrue();
+      assertThat(response.trailers()).isEqualTo(Headers.of("trailers", "boom"));
+    }
+  }
+
+  @Test public void requestBodyThrowsUnrelatedToNetwork() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(new RequestBody() {
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            throw new IOException("boom");
+          }
+        })
+        .build();
+
+    executeSynchronously(request).assertFailure("boom");
+  }
+
+  @Test public void requestBodyThrowsUnrelatedToNetwork_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    requestBodyThrowsUnrelatedToNetwork();
+  }
+
+  /** https://github.com/square/okhttp/issues/4583 */
+  @Test public void lateCancelCallsOnFailure() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    AtomicBoolean closed = new AtomicBoolean();
+
+    client = client.newBuilder()
+        .addInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            Response response = chain.proceed(chain.request());
+            chain.call().cancel(); // Cancel after we have the response.
+            ForwardingSource closeTrackingSource = new ForwardingSource(response.body().source()) {
+              @Override public void close() throws IOException {
+                closed.set(true);
+                super.close();
+              }
+            };
+            return response.newBuilder()
+                .body(ResponseBody.create(null, -1L, Okio.buffer(closeTrackingSource)))
+                .build();
+          }
+        })
+        .build();
+
+    executeSynchronously("/").assertFailure("Canceled");
+    assertThat(closed.get()).isTrue();
   }
 
   private void makeFailingCall() {
@@ -3187,7 +3707,7 @@ private void makeFailingCall() {
       call.execute();
       fail();
     } catch (IOException expected) {
-      assertEquals("write body fail!", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("write body fail!");
     }
   }
 
@@ -3218,17 +3738,18 @@ private RecordedResponse executeSynchronously(Request request) throws IOExceptio
   private void enableProtocol(Protocol protocol) {
     enableTls();
     client = client.newBuilder()
-        .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
+        .protocols(asList(protocol, Protocol.HTTP_1_1))
         .build();
     server.setProtocols(client.protocols());
   }
 
   private void enableTls() {
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
   }
 
   private Buffer gzip(String data) throws IOException {
@@ -3239,8 +3760,8 @@ private Buffer gzip(String data) throws IOException {
     return result;
   }
 
-  private void cancelLater(final Call call, final long delay) {
-    new Thread("canceler") {
+  private Thread cancelLater(final Call call, final long delay) {
+    Thread thread = new Thread("canceler") {
       @Override public void run() {
         try {
           Thread.sleep(delay);
@@ -3249,7 +3770,19 @@ private void cancelLater(final Call call, final long delay) {
         }
         call.cancel();
       }
-    }.start();
+    };
+    thread.start();
+    return thread;
+  }
+
+  private SSLSocketFactory socketFactoryWithCipherSuite(
+      final SSLSocketFactory sslSocketFactory, final CipherSuite cipherSuite) {
+    return new DelegatingSSLSocketFactory(sslSocketFactory) {
+      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
+        sslSocket.setEnabledCipherSuites(new String[] { cipherSuite.javaName() });
+        return super.configureSocket(sslSocket);
+      }
+    };
   }
 
   private static class RecordingSSLSocketFactory extends DelegatingSSLSocketFactory {
@@ -3277,6 +3810,6 @@ protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
    * for details.
    */
   private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(sslClient.socketFactory);
+    return new FallbackTestClientSocketFactory(handshakeCertificates.sslSocketFactory());
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp/src/test/java/okhttp3/CertificateChainCleanerTest.java
similarity index 59%
rename from okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
rename to okhttp/src/test/java/okhttp3/CertificateChainCleanerTest.java
index e76f0c2cdf..a2185a9348 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
+++ b/okhttp/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -15,7 +15,6 @@
  */
 package okhttp3;
 
-import java.security.GeneralSecurityException;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
@@ -23,45 +22,43 @@
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.mockwebserver.internal.tls.HeldCertificate;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class CertificateChainCleanerTest {
-  @Test public void equalsFromCertificate() throws Exception {
+  @Test public void equalsFromCertificate() {
     HeldCertificate rootA = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate rootB = new HeldCertificate.Builder()
-        .serialNumber("2")
+        .serialNumber(2L)
         .build();
-    assertEquals(
-        CertificateChainCleaner.get(rootA.certificate, rootB.certificate),
-        CertificateChainCleaner.get(rootB.certificate, rootA.certificate));
+    assertThat(CertificateChainCleaner.get(rootB.certificate(), rootA.certificate())).isEqualTo(
+        CertificateChainCleaner.get(rootA.certificate(), rootB.certificate()));
   }
 
-  @Test public void equalsFromTrustManager() throws Exception {
-    SslClient client = new SslClient.Builder().build();
-    X509TrustManager x509TrustManager = client.trustManager;
-    assertEquals(
-        CertificateChainCleaner.get(x509TrustManager),
+  @Test public void equalsFromTrustManager() {
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder().build();
+    X509TrustManager x509TrustManager = handshakeCertificates.trustManager();
+    assertThat(CertificateChainCleaner.get(x509TrustManager)).isEqualTo(
         CertificateChainCleaner.get(x509TrustManager));
   }
 
   @Test public void normalizeSingleSelfSignedCertificate() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
-    assertEquals(list(root), cleaner.clean(list(root), "hostname"));
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
+    assertThat(cleaner.clean(list(root), "hostname")).isEqualTo(list(root));
   }
 
-  @Test public void normalizeUnknownSelfSignedCertificate() throws Exception {
+  @Test public void normalizeUnknownSelfSignedCertificate() {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     CertificateChainCleaner cleaner = CertificateChainCleaner.get();
 
@@ -74,176 +71,179 @@
 
   @Test public void orderedChainOfCertificatesWithRoot() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
-    assertEquals(list(certB, certA, root), cleaner.clean(list(certB, certA, root), "hostname"));
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
+    assertThat(cleaner.clean(list(certB, certA, root), "hostname")).isEqualTo(
+        list(certB, certA, root));
   }
 
   @Test public void orderedChainOfCertificatesWithoutRoot() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
-    assertEquals(list(certB, certA, root),
-        cleaner.clean(list(certB, certA), "hostname")); // Root is added!
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
+    // Root is added!
+    assertThat(cleaner.clean(list(certB, certA), "hostname")).isEqualTo(
+        list(certB, certA, root));
   }
 
   @Test public void unorderedChainOfCertificatesWithRoot() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
     HeldCertificate certC = new HeldCertificate.Builder()
-        .serialNumber("4")
-        .issuedBy(certB)
+        .serialNumber(4L)
+        .signedBy(certB)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
-    assertEquals(list(certC, certB, certA, root),
-        cleaner.clean(list(certC, certA, root, certB), "hostname"));
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
+    assertThat(cleaner.clean(list(certC, certA, root, certB), "hostname")).isEqualTo(
+        list(certC, certB, certA, root));
   }
 
   @Test public void unorderedChainOfCertificatesWithoutRoot() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
     HeldCertificate certC = new HeldCertificate.Builder()
-        .serialNumber("4")
-        .issuedBy(certB)
+        .serialNumber(4L)
+        .signedBy(certB)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
-    assertEquals(list(certC, certB, certA, root),
-        cleaner.clean(list(certC, certA, certB), "hostname"));
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
+    assertThat(cleaner.clean(list(certC, certA, certB), "hostname")).isEqualTo(
+        list(certC, certB, certA, root));
   }
 
   @Test public void unrelatedCertificatesAreOmitted() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
     HeldCertificate certUnnecessary = new HeldCertificate.Builder()
-        .serialNumber("4")
+        .serialNumber(4L)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
-    assertEquals(list(certB, certA, root),
-        cleaner.clean(list(certB, certUnnecessary, certA, root), "hostname"));
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
+    assertThat(cleaner.clean(list(certB, certUnnecessary, certA, root), "hostname")).isEqualTo(
+        list(certB, certA, root));
   }
 
   @Test public void chainGoesAllTheWayToSelfSignedRoot() throws Exception {
     HeldCertificate selfSigned = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate trusted = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(selfSigned)
+        .serialNumber(2L)
+        .signedBy(selfSigned)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(trusted)
+        .serialNumber(3L)
+        .signedBy(trusted)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("4")
-        .issuedBy(certA)
+        .serialNumber(4L)
+        .signedBy(certA)
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(
-        selfSigned.certificate, trusted.certificate);
-    assertEquals(list(certB, certA, trusted, selfSigned),
-        cleaner.clean(list(certB, certA), "hostname"));
-    assertEquals(list(certB, certA, trusted, selfSigned),
-        cleaner.clean(list(certB, certA, trusted), "hostname"));
-    assertEquals(list(certB, certA, trusted, selfSigned),
-        cleaner.clean(list(certB, certA, trusted, selfSigned), "hostname"));
+        selfSigned.certificate(), trusted.certificate());
+    assertThat(cleaner.clean(list(certB, certA), "hostname")).isEqualTo(
+        list(certB, certA, trusted, selfSigned));
+    assertThat(cleaner.clean(list(certB, certA, trusted), "hostname")).isEqualTo(
+        list(certB, certA, trusted, selfSigned));
+    assertThat(cleaner.clean(list(certB, certA, trusted, selfSigned), "hostname")).isEqualTo(
+        list(certB, certA, trusted, selfSigned));
   }
 
   @Test public void trustedRootNotSelfSigned() throws Exception {
     HeldCertificate unknownSigner = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate trusted = new HeldCertificate.Builder()
-        .issuedBy(unknownSigner)
-        .serialNumber("2")
+        .signedBy(unknownSigner)
+        .serialNumber(2L)
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(trusted)
-        .serialNumber("3")
+        .signedBy(trusted)
+        .serialNumber(3L)
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
-        .serialNumber("4")
+        .signedBy(intermediateCa)
+        .serialNumber(4L)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(trusted.certificate);
-    assertEquals(list(certificate, intermediateCa, trusted),
-        cleaner.clean(list(certificate, intermediateCa), "hostname"));
-    assertEquals(list(certificate, intermediateCa, trusted),
-        cleaner.clean(list(certificate, intermediateCa, trusted), "hostname"));
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(trusted.certificate());
+    assertThat(cleaner.clean(list(certificate, intermediateCa), "hostname")).isEqualTo(
+        list(certificate, intermediateCa, trusted));
+    assertThat(cleaner.clean(list(certificate, intermediateCa, trusted), "hostname")).isEqualTo(
+        list(certificate, intermediateCa, trusted));
   }
 
   @Test public void chainMaxLength() throws Exception {
     List<HeldCertificate> heldCertificates = chainOfLength(10);
     List<Certificate> certificates = new ArrayList<>();
     for (HeldCertificate heldCertificate : heldCertificates) {
-      certificates.add(heldCertificate.certificate);
+      certificates.add(heldCertificate.certificate());
     }
 
-    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate();
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
-    assertEquals(certificates, cleaner.clean(certificates, "hostname"));
-    assertEquals(certificates, cleaner.clean(certificates.subList(0, 9), "hostname"));
+    assertThat(cleaner.clean(certificates, "hostname")).isEqualTo(certificates);
+    assertThat(cleaner.clean(certificates.subList(0, 9), "hostname")).isEqualTo(
+        certificates);
   }
 
-  @Test public void chainTooLong() throws Exception {
+  @Test public void chainTooLong() {
     List<HeldCertificate> heldCertificates = chainOfLength(11);
     List<Certificate> certificates = new ArrayList<>();
     for (HeldCertificate heldCertificate : heldCertificates) {
-      certificates.add(heldCertificate.certificate);
+      certificates.add(heldCertificate.certificate());
     }
 
-    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate();
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
     try {
       cleaner.clean(certificates, "hostname");
@@ -253,12 +253,12 @@
   }
 
   /** Returns a chain starting at the leaf certificate and progressing to the root. */
-  private List<HeldCertificate> chainOfLength(int length) throws GeneralSecurityException {
+  private List<HeldCertificate> chainOfLength(int length) {
     List<HeldCertificate> result = new ArrayList<>();
     for (int i = 1; i <= length; i++) {
       result.add(0, new HeldCertificate.Builder()
-          .issuedBy(!result.isEmpty() ? result.get(0) : null)
-          .serialNumber(Integer.toString(i))
+          .signedBy(!result.isEmpty() ? result.get(0) : null)
+          .serialNumber(i)
           .build());
     }
     return result;
@@ -267,7 +267,7 @@
   private List<Certificate> list(HeldCertificate... heldCertificates) {
     List<Certificate> result = new ArrayList<>();
     for (HeldCertificate heldCertificate : heldCertificates) {
-      result.add(heldCertificate.certificate);
+      result.add(heldCertificate.certificate());
     }
     return result;
   }
diff --git a/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt b/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt
new file mode 100644
index 0000000000..6ad1bac9d3
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.CertificatePinner.Pin
+import okhttp3.tls.HeldCertificate
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+
+class CertificatePinnerKotlinTest {
+
+  @Test
+  fun successfulCheckSha1Pin() {
+    val certificatePinner = CertificatePinner.Builder()
+        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate()).base64())
+        .build()
+
+    certificatePinner.check("example.com", certA1.certificate())
+  }
+
+  @Test fun successfulFindMatchingPins() {
+    val certificatePinner = CertificatePinner.Builder()
+        .add("first.com", certA1Sha256Pin, certB1Sha256Pin)
+        .add("second.com", certC1Sha256Pin)
+        .build()
+
+    val expectedPins = listOf(
+        Pin("first.com", certA1Sha256Pin),
+        Pin("first.com", certB1Sha256Pin))
+    assertThat(certificatePinner.findMatchingPins("first.com")).isEqualTo(expectedPins)
+  }
+
+  @Test fun successfulFindMatchingPinsForWildcardAndDirectCertificates() {
+    val certificatePinner = CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
+        .add("b.example.com", certC1Sha256Pin)
+        .build()
+
+    val expectedPins = listOf(
+        Pin("*.example.com", certA1Sha256Pin),
+        Pin("a.example.com", certB1Sha256Pin))
+    assertThat(certificatePinner.findMatchingPins("a.example.com")).isEqualTo(expectedPins)
+  }
+
+  @Test
+  fun wildcardHostnameShouldNotMatchThroughDot() {
+    val certificatePinner = CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build()
+
+    assertThat(certificatePinner.findMatchingPins("example.com")).isEmpty()
+    assertThat(certificatePinner.findMatchingPins("a.b.example.com")).isEmpty()
+  }
+
+  @Test fun successfulFindMatchingPinsIgnoresCase() {
+    val certificatePinner = CertificatePinner.Builder()
+        .add("EXAMPLE.com", certA1Sha256Pin)
+        .add("*.MyExample.Com", certB1Sha256Pin)
+        .build()
+
+    val expectedPin1 = listOf(Pin("EXAMPLE.com", certA1Sha256Pin))
+    assertThat(certificatePinner.findMatchingPins("example.com")).isEqualTo(expectedPin1)
+
+    val expectedPin2 = listOf(Pin("*.MyExample.Com", certB1Sha256Pin))
+    assertThat(certificatePinner.findMatchingPins("a.myexample.com")).isEqualTo(expectedPin2)
+  }
+
+  @Test fun successfulFindMatchingPinPunycode() {
+    val certificatePinner = CertificatePinner.Builder()
+        .add("œÉkhttp.com", certA1Sha256Pin)
+        .build()
+
+    val expectedPin = listOf(Pin("œÉkhttp.com", certA1Sha256Pin))
+    assertThat(certificatePinner.findMatchingPins("xn--khttp-fde.com")).isEqualTo(expectedPin)
+  }
+
+  /** https://github.com/square/okhttp/issues/3324  */
+  @Test
+  fun checkSubstringMatch() {
+    val certificatePinner = CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build()
+
+    assertThat(certificatePinner.findMatchingPins("a.example.com.notexample.com")).isEmpty()
+    assertThat(certificatePinner.findMatchingPins("example.com.notexample.com")).isEmpty()
+    assertThat(certificatePinner.findMatchingPins("notexample.com")).isEmpty()
+    assertThat(certificatePinner.findMatchingPins("example.com")).isEmpty()
+    assertThat(certificatePinner.findMatchingPins("a.b.example.com")).isEmpty()
+    assertThat(certificatePinner.findMatchingPins("ple.com")).isEmpty()
+    assertThat(certificatePinner.findMatchingPins("com")).isEmpty()
+
+    val expectedPin = Pin("*.example.com", certA1Sha256Pin)
+    assertThat(certificatePinner.findMatchingPins("a.example.com")).containsExactly(expectedPin)
+    assertThat(certificatePinner.findMatchingPins("example.example.com"))
+        .containsExactly(expectedPin)
+  }
+
+  companion object {
+    internal var certA1: HeldCertificate = HeldCertificate.Builder()
+        .serialNumber(100L)
+        .build()
+    internal var certA1Sha256Pin = CertificatePinner.pin(certA1.certificate())
+
+    internal var certB1 = HeldCertificate.Builder()
+        .serialNumber(200L)
+        .build()
+    internal var certB1Sha256Pin = CertificatePinner.pin(certB1.certificate())
+
+    internal var certC1 = HeldCertificate.Builder()
+        .serialNumber(300L)
+        .build()
+    internal var certC1Sha256Pin = CertificatePinner.pin(certC1.certificate())
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp/src/test/java/okhttp3/CertificatePinnerTest.java
new file mode 100644
index 0000000000..77dacfe9bb
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/CertificatePinnerTest.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import javax.net.ssl.SSLPeerUnverifiedException;
+import okhttp3.tls.HeldCertificate;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CertificatePinnerTest {
+  static HeldCertificate certA1 = new HeldCertificate.Builder()
+      .serialNumber(100L)
+      .build();
+  static String certA1Sha256Pin = CertificatePinner.pin(certA1.certificate());
+
+  static HeldCertificate certB1 = new HeldCertificate.Builder()
+      .serialNumber(200L)
+      .build();
+  static String certB1Sha256Pin = CertificatePinner.pin(certB1.certificate());
+
+  static HeldCertificate certC1 = new HeldCertificate.Builder()
+      .serialNumber(300L)
+      .build();
+  static String certC1Sha256Pin = CertificatePinner.pin(certC1.certificate());
+
+  @Test public void malformedPin() throws Exception {
+    CertificatePinner.Builder builder = new CertificatePinner.Builder();
+    try {
+      builder.add("example.com", "md5/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void malformedBase64() throws Exception {
+    CertificatePinner.Builder builder = new CertificatePinner.Builder();
+    try {
+      builder.add("example.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw*");
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  /** Multiple certificates generated from the same keypair have the same pin. */
+  @Test public void sameKeypairSamePin() throws Exception {
+    HeldCertificate heldCertificateA2 = new HeldCertificate.Builder()
+        .keyPair(certA1.keyPair())
+        .serialNumber(101L)
+        .build();
+    String keypairACertificate2Pin = CertificatePinner.pin(heldCertificateA2.certificate());
+
+    HeldCertificate heldCertificateB2 = new HeldCertificate.Builder()
+        .keyPair(certB1.keyPair())
+        .serialNumber(201L)
+        .build();
+    String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate());
+
+    assertThat(keypairACertificate2Pin).isEqualTo(certA1Sha256Pin);
+    assertThat(keypairBCertificate2Pin).isEqualTo(certB1Sha256Pin);
+    assertThat(certB1Sha256Pin).isNotEqualTo(certA1Sha256Pin);
+  }
+
+  @Test public void successfulCheck() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certA1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate());
+  }
+
+  @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate(), certB1.certificate());
+  }
+
+  @Test public void unsuccessfulCheck() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certA1Sha256Pin)
+        .build();
+
+    try {
+      certificatePinner.check("example.com", certB1.certificate());
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void multipleCertificatesForOneHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certA1Sha256Pin, certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate());
+    certificatePinner.check("example.com", certB1.certificate());
+  }
+
+  @Test public void multipleHostnamesForOneCertificate() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("example.com", certA1Sha256Pin)
+        .add("www.example.com", certA1Sha256Pin)
+        .build();
+
+    certificatePinner.check("example.com", certA1.certificate());
+    certificatePinner.check("www.example.com", certA1.certificate());
+  }
+
+  @Test public void absentHostnameMatches() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder().build();
+    certificatePinner.check("example.com", certA1.certificate());
+  }
+
+  @Test public void successfulCheckForWildcardHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", certA1.certificate());
+  }
+
+  @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname()
+      throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", certA1.certificate(), certB1.certificate());
+  }
+
+  @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build();
+
+    try {
+      certificatePinner.check("a.example.com", certB1.certificate());
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+
+  @Test public void multipleCertificatesForOneWildcardHostname() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin, certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", certA1.certificate());
+    certificatePinner.check("a.example.com", certB1.certificate());
+  }
+
+  @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate()
+      throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
+        .build();
+
+    certificatePinner.check("a.example.com", certA1.certificate());
+    certificatePinner.check("a.example.com", certB1.certificate());
+  }
+
+  @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate()
+      throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .add("a.example.com", certB1Sha256Pin)
+        .build();
+
+    try {
+      certificatePinner.check("a.example.com", certC1.certificate());
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java b/okhttp/src/test/java/okhttp3/CipherSuiteTest.java
similarity index 76%
rename from okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
rename to okhttp/src/test/java/okhttp3/CipherSuiteTest.java
index 63b3023253..35d7843811 100644
--- a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
+++ b/okhttp/src/test/java/okhttp3/CipherSuiteTest.java
@@ -21,10 +21,9 @@
 import static okhttp3.CipherSuite.TLS_RSA_EXPORT_WITH_RC4_40_MD5;
 import static okhttp3.CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA256;
 import static okhttp3.CipherSuite.forJavaName;
+import static okhttp3.internal.InternalKtKt.applyConnectionSpec;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertSame;
 import static org.junit.Assert.fail;
 
 public class CipherSuiteTest {
@@ -32,24 +31,26 @@
     try {
       forJavaName(null);
       fail("Should have thrown");
-    } catch (NullPointerException expected) {
+    } catch (IllegalArgumentException expected) {
     }
   }
 
   @Test public void hashCode_usesIdentityHashCode_legacyCase() {
     CipherSuite cs = TLS_RSA_EXPORT_WITH_RC4_40_MD5; // This one's javaName starts with "SSL_".
-    assertEquals(cs.toString(), System.identityHashCode(cs), cs.hashCode());
+    assertThat(cs.hashCode()).overridingErrorMessage(cs.toString()).isEqualTo(
+        System.identityHashCode(cs));
   }
 
   @Test public void hashCode_usesIdentityHashCode_regularCase() {
     CipherSuite cs = TLS_RSA_WITH_AES_128_CBC_SHA256; // This one's javaName matches the identifier.
-    assertEquals(cs.toString(), System.identityHashCode(cs), cs.hashCode());
+    assertThat(cs.hashCode()).overridingErrorMessage(cs.toString()).isEqualTo(
+        System.identityHashCode(cs));
   }
 
   @Test public void instancesAreInterned() {
-    assertSame(forJavaName("TestCipherSuite"), forJavaName("TestCipherSuite"));
-    assertSame(CipherSuite.TLS_KRB5_WITH_DES_CBC_MD5,
-        forJavaName(TLS_KRB5_WITH_DES_CBC_MD5.javaName()));
+    assertThat(forJavaName("TestCipherSuite")).isSameAs(forJavaName("TestCipherSuite"));
+    assertThat(forJavaName(TLS_KRB5_WITH_DES_CBC_MD5.javaName()))
+        .isSameAs(TLS_KRB5_WITH_DES_CBC_MD5);
   }
 
   /**
@@ -61,14 +62,16 @@
     // We're not holding onto a reference to this String instance outside of the CipherSuite...
     CipherSuite cs = forJavaName(new String("FakeCipherSuite_instancesAreInterned"));
     System.gc(); // Unless cs references the String instance, it may now be garbage collected.
-    assertSame(cs, forJavaName(new String(cs.javaName())));
+    assertThat(forJavaName(new String(cs.javaName()))).isSameAs(cs);
   }
 
   @Test public void equals() {
-    assertEquals(forJavaName("cipher"), forJavaName("cipher"));
-    assertNotEquals(forJavaName("cipherA"), forJavaName("cipherB"));
-    assertEquals(forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"), TLS_RSA_EXPORT_WITH_RC4_40_MD5);
-    assertNotEquals(TLS_RSA_EXPORT_WITH_RC4_40_MD5, TLS_RSA_WITH_AES_128_CBC_SHA256);
+    assertThat(forJavaName("cipher")).isEqualTo(forJavaName("cipher"));
+    assertThat(forJavaName("cipherB")).isNotEqualTo(forJavaName("cipherA"));
+    assertThat(TLS_RSA_EXPORT_WITH_RC4_40_MD5).isEqualTo(
+        forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"));
+    assertThat(TLS_RSA_WITH_AES_128_CBC_SHA256).isNotEqualTo(
+        TLS_RSA_EXPORT_WITH_RC4_40_MD5);
   }
 
   @Test public void forJavaName_acceptsArbitraryStrings() {
@@ -77,16 +80,18 @@
   }
 
   @Test public void javaName_examples() {
-    assertEquals("SSL_RSA_EXPORT_WITH_RC4_40_MD5", TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName());
-    assertEquals("TLS_RSA_WITH_AES_128_CBC_SHA256", TLS_RSA_WITH_AES_128_CBC_SHA256.javaName());
-    assertEquals("TestCipherSuite", forJavaName("TestCipherSuite").javaName());
+    assertThat(TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName()).isEqualTo(
+        "SSL_RSA_EXPORT_WITH_RC4_40_MD5");
+    assertThat(TLS_RSA_WITH_AES_128_CBC_SHA256.javaName()).isEqualTo(
+        "TLS_RSA_WITH_AES_128_CBC_SHA256");
+    assertThat(forJavaName("TestCipherSuite").javaName()).isEqualTo("TestCipherSuite");
   }
 
   @Test public void javaName_equalsToString() {
-    assertEquals(TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName,
-        TLS_RSA_EXPORT_WITH_RC4_40_MD5.toString());
-    assertEquals(TLS_RSA_WITH_AES_128_CBC_SHA256.javaName,
-        TLS_RSA_WITH_AES_128_CBC_SHA256.toString());
+    assertThat(TLS_RSA_EXPORT_WITH_RC4_40_MD5.toString()).isEqualTo(
+        TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName());
+    assertThat(TLS_RSA_WITH_AES_128_CBC_SHA256.toString()).isEqualTo(
+        TLS_RSA_WITH_AES_128_CBC_SHA256.javaName());
   }
 
   /**
@@ -98,15 +103,12 @@
    */
   @Test public void forJavaName_fromLegacyEnumName() {
     // These would have been considered equal in OkHttp 3.3.1, but now aren't.
-    assertEquals(
-        forJavaName("TLS_RSA_EXPORT_WITH_RC4_40_MD5"),
-        forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"));
-    assertEquals(
-        forJavaName("TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"),
-        forJavaName("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"));
-    assertEquals(
-        forJavaName("TLS_FAKE_NEW_CIPHER"),
-        forJavaName("SSL_FAKE_NEW_CIPHER"));
+    assertThat(forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5")).isEqualTo(
+        forJavaName("TLS_RSA_EXPORT_WITH_RC4_40_MD5"));
+    assertThat(forJavaName("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA")).isEqualTo(
+        forJavaName("TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"));
+    assertThat(forJavaName("SSL_FAKE_NEW_CIPHER")).isEqualTo(
+        forJavaName("TLS_FAKE_NEW_CIPHER"));
   }
 
   @Test public void applyIntersectionRetainsSslPrefixes() throws Exception {
@@ -119,7 +121,7 @@
         .tlsVersions(TlsVersion.TLS_1_0)
         .cipherSuites("TLS_A", "TLS_C", "TLS_E")
         .build();
-    connectionSpec.apply(socket, false);
+    applyConnectionSpec(connectionSpec, socket, false);
 
     assertArrayEquals(new String[] { "SSL_A", "SSL_C" }, socket.enabledCipherSuites);
   }
@@ -134,7 +136,7 @@
         .tlsVersions(TlsVersion.TLS_1_0)
         .cipherSuites("SSL_A", "SSL_C", "SSL_E")
         .build();
-    connectionSpec.apply(socket, false);
+    applyConnectionSpec(connectionSpec, socket, false);
 
     assertArrayEquals(new String[] { "TLS_A", "TLS_C" }, socket.enabledCipherSuites);
   }
@@ -149,7 +151,7 @@
         .tlsVersions(TlsVersion.TLS_1_0)
         .cipherSuites("SSL_A")
         .build();
-    connectionSpec.apply(socket, true);
+    applyConnectionSpec(connectionSpec, socket, true);
 
     assertArrayEquals(new String[] { "SSL_A", "SSL_FALLBACK_SCSV" }, socket.enabledCipherSuites);
   }
@@ -164,7 +166,7 @@
         .tlsVersions(TlsVersion.TLS_1_0)
         .cipherSuites("TLS_A")
         .build();
-    connectionSpec.apply(socket, true);
+    applyConnectionSpec(connectionSpec, socket, true);
 
     assertArrayEquals(new String[] { "TLS_A", "TLS_FALLBACK_SCSV" }, socket.enabledCipherSuites);
   }
@@ -179,7 +181,7 @@
         .tlsVersions(TlsVersion.TLS_1_1, TlsVersion.TLS_1_2, TlsVersion.TLS_1_3)
         .cipherSuites("TLS_A")
         .build();
-    connectionSpec.apply(socket, false);
+    applyConnectionSpec(connectionSpec, socket, false);
 
     assertArrayEquals(new String[] { "TLSv1.1", "TLSv1.2" }, socket.enabledProtocols);
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java b/okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java
similarity index 77%
rename from okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
rename to okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java
index cbb0152552..bc2d0c6712 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
+++ b/okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java
@@ -19,27 +19,27 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
-import okhttp3.mockwebserver.internal.tls.HeldCertificate;
-import okhttp3.mockwebserver.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ConnectionCoalescingTest {
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   private OkHttpClient client;
 
@@ -51,18 +51,18 @@
 
   @Before public void setUp() throws Exception {
     rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(0)
         .commonName("root")
         .build();
     certificate = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .serialNumber("2")
+        .signedBy(rootCa)
+        .serialNumber(2L)
         .commonName(server.getHostName())
-        .subjectAlternativeName(server.getHostName())
-        .subjectAlternativeName("san.com")
-        .subjectAlternativeName("*.wildcard.com")
-        .subjectAlternativeName("differentdns.com")
+        .addSubjectAlternativeName(server.getHostName())
+        .addSubjectAlternativeName("san.com")
+        .addSubjectAlternativeName("*.wildcard.com")
+        .addSubjectAlternativeName("differentdns.com")
         .build();
 
     serverIps = Dns.SYSTEM.lookup(server.getHostName());
@@ -71,20 +71,22 @@
     dns.set("san.com", serverIps);
     dns.set("nonsan.com", serverIps);
     dns.set("www.wildcard.com", serverIps);
-    dns.set("differentdns.com", Collections.<InetAddress>emptyList());
+    dns.set("differentdns.com", Collections.emptyList());
 
-    SslClient sslClient = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
         .build();
 
     client = new OkHttpClient.Builder().dns(dns)
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .build();
+    clientTestRule.client = client;
 
-    SslClient serverSslClient = new SslClient.Builder()
-        .certificateChain(certificate, rootCa)
+    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(certificate)
         .build();
-    server.useHttps(serverSslClient.socketFactory, false);
+    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
 
     url = server.url("/robots.txt");
   }
@@ -102,7 +104,7 @@
     HttpUrl sanUrl = url.newBuilder().host("san.com").build();
     assert200Http2Response(execute(sanUrl), "san.com");
 
-    assertEquals(1, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
   /**
@@ -118,7 +120,7 @@
 
     assert200Http2Response(execute(url), server.getHostName());
 
-    assertEquals(1, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
   /** Test a previously coalesced connection that's no longer healthy. */
@@ -126,13 +128,11 @@
     server.enqueue(new MockResponse().setResponseCode(200));
     server.enqueue(new MockResponse().setResponseCode(200));
 
-    final AtomicReference<Connection> connection = new AtomicReference<>();
+    AtomicReference<Connection> connection = new AtomicReference<>();
     client = client.newBuilder()
-        .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            connection.set(chain.connection());
-            return chain.proceed(chain.request());
-          }
+        .addNetworkInterceptor(chain -> {
+          connection.set(chain.connection());
+          return chain.proceed(chain.request());
         })
         .build();
     dns.set("san.com", Dns.SYSTEM.lookup(server.getHostName()).subList(0, 1));
@@ -145,7 +145,7 @@
     HttpUrl sanUrl = url.newBuilder().host("san.com").build();
     assert200Http2Response(execute(sanUrl), "san.com");
 
-    assertEquals(1, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
   /** If the existing connection matches a SAN but not a match for DNS then skip. */
@@ -180,7 +180,7 @@
   /** Can still coalesce when pinning is used if pins match. */
   @Test public void coalescesWhenCertificatePinsMatch() throws Exception {
     CertificatePinner pinner = new CertificatePinner.Builder()
-        .add("san.com", "sha1/" + CertificatePinner.sha1(certificate.certificate).base64())
+        .add("san.com", CertificatePinner.pin(certificate.certificate()))
         .build();
     client = client.newBuilder().certificatePinner(pinner).build();
 
@@ -193,7 +193,7 @@
 
     assert200Http2Response(execute(sanUrl), "san.com");
 
-    assertEquals(1, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
   /** Certificate pinning used and not a match will avoid coalescing and try to connect. */
@@ -221,11 +221,7 @@
    * verification is a black box.
    */
   @Test public void skipsWhenHostnameVerifierUsed() throws Exception {
-    HostnameVerifier verifier = new HostnameVerifier() {
-      @Override public boolean verify(String s, SSLSession sslSession) {
-        return true;
-      }
-    };
+    HostnameVerifier verifier = (name, session) -> true;
     client = client.newBuilder().hostnameVerifier(verifier).build();
 
     server.enqueue(new MockResponse().setResponseCode(200));
@@ -237,7 +233,7 @@
 
     assert200Http2Response(execute(sanUrl), "san.com");
 
-    assertEquals(2, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(2);
   }
 
   /**
@@ -248,10 +244,10 @@
     server.enqueue(new MockResponse().setResponseCode(200));
     server.enqueue(new MockResponse().setResponseCode(200));
 
-    final AtomicInteger connectCount = new AtomicInteger();
+    AtomicInteger connectCount = new AtomicInteger();
     EventListener listener = new EventListener() {
-      @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
-          Proxy proxy) {
+      @Override public void connectStart(
+          Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
         connectCount.getAndIncrement();
       }
     };
@@ -263,12 +259,12 @@
 
     HttpUrl sanUrl = url.newBuilder().host("san.com").build();
     dns.set("san.com",
-        Arrays.asList(InetAddress.getByAddress("san.com", new byte[] {0, 0, 0, 0}),
+        asList(InetAddress.getByAddress("san.com", new byte[] {0, 0, 0, 0}),
             serverIps.get(0)));
     assert200Http2Response(execute(sanUrl), "san.com");
 
-    assertEquals(1, client.connectionPool().connectionCount());
-    assertEquals(1, connectCount.get());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
+    assertThat(connectCount.get()).isEqualTo(1);
   }
 
   /** Check that wildcard SANs are supported. */
@@ -282,16 +278,14 @@
     HttpUrl sanUrl = url.newBuilder().host("www.wildcard.com").build();
     assert200Http2Response(execute(sanUrl), "www.wildcard.com");
 
-    assertEquals(1, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
   /** Network interceptors check for changes to target. */
   @Test public void worksWithNetworkInterceptors() throws Exception {
-    client = client.newBuilder().addNetworkInterceptor(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return chain.proceed(chain.request());
-      }
-    }).build();
+    client = client.newBuilder()
+        .addNetworkInterceptor(chain -> chain.proceed(chain.request()))
+        .build();
 
     server.enqueue(new MockResponse().setResponseCode(200));
     server.enqueue(new MockResponse().setResponseCode(200));
@@ -301,7 +295,7 @@
     HttpUrl sanUrl = url.newBuilder().host("san.com").build();
     assert200Http2Response(execute(sanUrl), "san.com");
 
-    assertEquals(1, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
   /** Run against public external sites, doesn't run by default. */
@@ -315,11 +309,11 @@
     assert200Http2Response(execute("https://messenger.com/robots.txt"), "messenger.com");
     assert200Http2Response(execute("https://m.facebook.com/robots.txt"), "m.facebook.com");
 
-    assertEquals(3, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(3);
   }
 
   private Response execute(String url) throws IOException {
-    return execute(HttpUrl.parse(url));
+    return execute(HttpUrl.get(url));
   }
 
   private Response execute(HttpUrl url) throws IOException {
@@ -327,9 +321,9 @@ private Response execute(HttpUrl url) throws IOException {
   }
 
   private void assert200Http2Response(Response response, String expectedHost) {
-    assertEquals(200, response.code());
-    assertEquals(expectedHost, response.request().url().host());
-    assertEquals(Protocol.HTTP_2, response.protocol());
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.request().url().host()).isEqualTo(expectedHost);
+    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_2);
     response.body().close();
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
similarity index 73%
rename from okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
rename to okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
index 399fbb2860..498f8b3bc7 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
+++ b/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
@@ -15,30 +15,33 @@
  */
 package okhttp3;
 
-import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLException;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.internal.Util;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
 import org.junit.rules.Timeout;
 
-import static okhttp3.TestUtil.defaultClient;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static java.util.Arrays.asList;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ConnectionReuseTest {
   @Rule public final TestRule timeout = new Timeout(30_000);
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
-  private SslClient sslClient = SslClient.localhost();
-  private OkHttpClient client = defaultClient();
+  private HandshakeCertificates handshakeCertificates = localhost();
+  private OkHttpClient client = clientTestRule.client;
 
   @Test public void connectionsAreReused() throws Exception {
     server.enqueue(new MockResponse().setBody("a"));
@@ -130,9 +133,9 @@
         .url(server.url("/"))
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("b", response.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(response.body().string()).isEqualTo("b");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void connectionsNotReusedWithRedirectIfDiscardingResponseIsSlow() throws Exception {
@@ -150,9 +153,9 @@
         .url(server.url("/"))
         .build();
     Response response = client.newCall(request).execute();
-    assertEquals("b", response.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(response.body().string()).isEqualTo("b");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void silentRetryWhenIdempotentRequestFailsOnReusedConnection() throws Exception {
@@ -165,13 +168,13 @@
         .build();
 
     Response responseA = client.newCall(request).execute();
-    assertEquals("a", responseA.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(responseA.body().string()).isEqualTo("a");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
 
     Response responseB = client.newCall(request).execute();
-    assertEquals("b", responseB.body().string());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(responseB.body().string()).isEqualTo("b");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void staleConnectionNotReusedForNonIdempotentRequest() throws Exception {
@@ -183,19 +186,19 @@
         .url(server.url("/"))
         .build();
     Response responseA = client.newCall(requestA).execute();
-    assertEquals("a", responseA.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(responseA.body().string()).isEqualTo("a");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
 
     // Give the socket a chance to become stale.
     Thread.sleep(250);
 
     Request requestB = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "b"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "b"))
         .build();
     Response responseB = client.newCall(requestB).execute();
-    assertEquals("b", responseB.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(responseB.body().string()).isEqualTo("b");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void http2ConnectionsAreSharedBeforeResponseIsConsumed() throws Exception {
@@ -210,8 +213,8 @@
     Response response2 = client.newCall(request).execute();
     response1.body().string(); // Discard the response body.
     response2.body().string(); // Discard the response body.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void connectionsAreEvicted() throws Exception {
@@ -226,16 +229,16 @@
         .build();
 
     Response response1 = client.newCall(request).execute();
-    assertEquals("a", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("a");
 
     // Give the thread pool a chance to evict.
     Thread.sleep(500);
 
     Response response2 = client.newCall(request).execute();
-    assertEquals("b", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("b");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void connectionsAreNotReusedIfSslSocketFactoryChanges() throws Exception {
@@ -251,9 +254,10 @@
     response.body().close();
 
     // This client shares a connection pool but has a different SSL socket factory.
-    SslClient sslClient2 = new SslClient.Builder().build();
+    HandshakeCertificates handshakeCertificates2 = new HandshakeCertificates.Builder().build();
     OkHttpClient anotherClient = client.newBuilder()
-        .sslSocketFactory(sslClient2.socketFactory, sslClient2.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates2.sslSocketFactory(), handshakeCertificates2.trustManager())
         .build();
 
     // This client fails to connect because the new SSL socket factory refuses.
@@ -284,8 +288,8 @@
     Response response2 = anotherClient.newCall(request).execute();
     response2.body().close();
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   /**
@@ -299,14 +303,21 @@
    * https://github.com/square/okhttp/issues/2409
    */
   @Test public void connectionsAreNotReusedIfNetworkInterceptorInterferes() throws Exception {
-    client = client.newBuilder().addNetworkInterceptor(new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Response response = chain.proceed(chain.request());
-        return response.newBuilder()
-            .body(ResponseBody.create(null, "unrelated response body!"))
-            .build();
-      }
-    }).build();
+    List<Response> responsesNotClosed = new ArrayList<>();
+
+    client = client.newBuilder()
+        // Since this test knowingly leaks a connection, avoid using the default shared connection
+        // pool, which should remain clean for subsequent tests.
+        .connectionPool(new ConnectionPool())
+        .addNetworkInterceptor(chain -> {
+          Response response = chain.proceed(chain.request());
+          responsesNotClosed.add(response);
+          return response
+              .newBuilder()
+              .body(ResponseBody.create(null, "unrelated response body!"))
+              .build();
+        })
+        .build();
 
     server.enqueue(new MockResponse()
         .setResponseCode(301)
@@ -319,11 +330,16 @@
         .url(server.url("/"))
         .build();
     Call call = client.newCall(request);
-    try {
-      call.execute();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertTrue(expected.getMessage().startsWith("Closing the body of"));
+    try (Response response = call.execute()) {
+      assertThat(response.body().string()).isEqualTo("unrelated response body!");
+    }
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // No connection reuse.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+
+    for (Response response : responsesNotClosed) {
+      Util.closeQuietly(response);
     }
   }
 
@@ -337,11 +353,12 @@ private void enableHttp2() {
 
   private void enableHttpsAndAlpn(Protocol... protocols) {
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .protocols(Arrays.asList(protocols))
+        .protocols(asList(protocols))
         .build();
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.setProtocols(client.protocols());
   }
 
@@ -349,7 +366,7 @@ private void assertConnectionReused(Request... requests) throws Exception {
     for (int i = 0; i < requests.length; i++) {
       Response response = client.newCall(requests[i]).execute();
       response.body().string(); // Discard the response body.
-      assertEquals(i, server.takeRequest().getSequenceNumber());
+      assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(i);
     }
   }
 
@@ -357,7 +374,7 @@ private void assertConnectionNotReused(Request... requests) throws Exception {
     for (Request request : requests) {
       Response response = client.newCall(request).execute();
       response.body().string(); // Discard the response body.
-      assertEquals(0, server.takeRequest().getSequenceNumber());
+      assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
     }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java b/okhttp/src/test/java/okhttp3/ConnectionSpecTest.java
similarity index 55%
rename from okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
rename to okhttp/src/test/java/okhttp3/ConnectionSpecTest.java
index c74a6b314c..61bc82cb3c 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionSpecTest.java
+++ b/okhttp/src/test/java/okhttp3/ConnectionSpecTest.java
@@ -15,18 +15,17 @@
  */
 package okhttp3;
 
-import java.util.Arrays;
-import java.util.LinkedHashSet;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Set;
 import java.util.concurrent.CopyOnWriteArraySet;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static java.util.Arrays.asList;
+import static okhttp3.internal.InternalKtKt.applyConnectionSpec;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ConnectionSpecTest {
@@ -37,7 +36,7 @@
           .build();
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("At least one TLS version is required", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("At least one TLS version is required");
     }
   }
 
@@ -48,13 +47,13 @@
           .build();
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("At least one cipher suite is required", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("At least one cipher suite is required");
     }
   }
 
   @Test public void cleartextBuilder() throws Exception {
     ConnectionSpec cleartextSpec = new ConnectionSpec.Builder(false).build();
-    assertFalse(cleartextSpec.isTls());
+    assertThat(cleartextSpec.isTls()).isFalse();
   }
 
   @Test public void tlsBuilder_explicitCiphers() throws Exception {
@@ -63,9 +62,9 @@
         .tlsVersions(TlsVersion.TLS_1_2)
         .supportsTlsExtensions(true)
         .build();
-    assertEquals(Arrays.asList(CipherSuite.TLS_RSA_WITH_RC4_128_MD5), tlsSpec.cipherSuites());
-    assertEquals(Arrays.asList(TlsVersion.TLS_1_2), tlsSpec.tlsVersions());
-    assertTrue(tlsSpec.supportsTlsExtensions());
+    assertThat(tlsSpec.cipherSuites()).containsExactly(CipherSuite.TLS_RSA_WITH_RC4_128_MD5);
+    assertThat(tlsSpec.tlsVersions()).containsExactly(TlsVersion.TLS_1_2);
+    assertThat(tlsSpec.supportsTlsExtensions()).isTrue();
   }
 
   @Test public void tlsBuilder_defaultCiphers() throws Exception {
@@ -73,9 +72,9 @@
         .tlsVersions(TlsVersion.TLS_1_2)
         .supportsTlsExtensions(true)
         .build();
-    assertNull(tlsSpec.cipherSuites());
-    assertEquals(Arrays.asList(TlsVersion.TLS_1_2), tlsSpec.tlsVersions());
-    assertTrue(tlsSpec.supportsTlsExtensions());
+    assertThat(tlsSpec.cipherSuites()).isNull();
+    assertThat(tlsSpec.tlsVersions()).containsExactly(TlsVersion.TLS_1_2);
+    assertThat(tlsSpec.supportsTlsExtensions()).isTrue();
   }
 
   @Test public void tls_defaultCiphers_noFallbackIndicator() throws Exception {
@@ -86,24 +85,22 @@
 
     SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
     socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
     });
     socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName,
-        TlsVersion.TLS_1_1.javaName,
+        TlsVersion.TLS_1_2.javaName(),
+        TlsVersion.TLS_1_1.javaName(),
     });
 
-    assertTrue(tlsSpec.isCompatible(socket));
-    tlsSpec.apply(socket, false /* isFallback */);
+    assertThat(tlsSpec.isCompatible(socket)).isTrue();
+    applyConnectionSpec(tlsSpec, socket, false /* isFallback */);
 
-    assertEquals(set(TlsVersion.TLS_1_2.javaName), set(socket.getEnabledProtocols()));
+    assertThat(socket.getEnabledProtocols()).containsExactly(TlsVersion.TLS_1_2.javaName());
 
-    Set<String> expectedCipherSet =
-        set(
-            CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-            CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName);
-    assertEquals(expectedCipherSet, expectedCipherSet);
+    assertThat(socket.getEnabledCipherSuites()).containsExactlyInAnyOrder(
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName());
   }
 
   @Test public void tls_defaultCiphers_withFallbackIndicator() throws Exception {
@@ -114,27 +111,26 @@
 
     SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
     socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
     });
     socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName,
-        TlsVersion.TLS_1_1.javaName,
+        TlsVersion.TLS_1_2.javaName(),
+        TlsVersion.TLS_1_1.javaName(),
     });
 
-    assertTrue(tlsSpec.isCompatible(socket));
-    tlsSpec.apply(socket, true /* isFallback */);
+    assertThat(tlsSpec.isCompatible(socket)).isTrue();
+    applyConnectionSpec(tlsSpec, socket, true /* isFallback */);
 
-    assertEquals(set(TlsVersion.TLS_1_2.javaName), set(socket.getEnabledProtocols()));
+    assertThat(socket.getEnabledProtocols()).containsExactly(TlsVersion.TLS_1_2.javaName());
 
-    Set<String> expectedCipherSet =
-        set(
-            CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-            CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName);
-    if (Arrays.asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
-      expectedCipherSet.add("TLS_FALLBACK_SCSV");
+    List<String> expectedCipherSuites = new ArrayList<>();
+    expectedCipherSuites.add(CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName());
+    expectedCipherSuites.add(CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName());
+    if (asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
+      expectedCipherSuites.add("TLS_FALLBACK_SCSV");
     }
-    assertEquals(expectedCipherSet, expectedCipherSet);
+    assertThat(socket.getEnabledCipherSuites()).containsExactlyElementsOf(expectedCipherSuites);
   }
 
   @Test public void tls_explicitCiphers() throws Exception {
@@ -146,24 +142,25 @@
 
     SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
     socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
     });
     socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName,
-        TlsVersion.TLS_1_1.javaName,
+        TlsVersion.TLS_1_2.javaName(),
+        TlsVersion.TLS_1_1.javaName(),
     });
 
-    assertTrue(tlsSpec.isCompatible(socket));
-    tlsSpec.apply(socket, true /* isFallback */);
+    assertThat(tlsSpec.isCompatible(socket)).isTrue();
+    applyConnectionSpec(tlsSpec, socket, true /* isFallback */);
 
-    assertEquals(set(TlsVersion.TLS_1_2.javaName), set(socket.getEnabledProtocols()));
+    assertThat(socket.getEnabledProtocols()).containsExactly(TlsVersion.TLS_1_2.javaName());
 
-    Set<String> expectedCipherSet = set(CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName);
-    if (Arrays.asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
-      expectedCipherSet.add("TLS_FALLBACK_SCSV");
+    List<String> expectedCipherSuites = new ArrayList<>();
+    expectedCipherSuites.add(CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName());
+    if (asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
+      expectedCipherSuites.add("TLS_FALLBACK_SCSV");
     }
-    assertEquals(expectedCipherSet, expectedCipherSet);
+    assertThat(socket.getEnabledCipherSuites()).containsExactlyElementsOf(expectedCipherSuites);
   }
 
   @Test public void tls_stringCiphersAndVersions() throws Exception {
@@ -184,46 +181,45 @@
 
     SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
     socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName,
-        TlsVersion.TLS_1_1.javaName,
+        TlsVersion.TLS_1_2.javaName(),
+        TlsVersion.TLS_1_1.javaName(),
     });
 
     socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
     });
-    assertTrue(tlsSpec.isCompatible(socket));
+    assertThat(tlsSpec.isCompatible(socket)).isTrue();
 
     socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
     });
-    assertFalse(tlsSpec.isCompatible(socket));
+    assertThat(tlsSpec.isCompatible(socket)).isFalse();
   }
 
   @Test public void allEnabledCipherSuites() throws Exception {
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
         .allEnabledCipherSuites()
         .build();
-    assertNull(tlsSpec.cipherSuites());
+    assertThat(tlsSpec.cipherSuites()).isNull();
 
     SSLSocket sslSocket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
     sslSocket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
     });
 
-    tlsSpec.apply(sslSocket, false);
-    assertEquals(Arrays.asList(
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName,
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName),
-        Arrays.asList(sslSocket.getEnabledCipherSuites()));
+    applyConnectionSpec(tlsSpec, sslSocket, false);
+    assertThat(sslSocket.getEnabledCipherSuites()).containsExactly(
+        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName());
   }
 
   @Test public void allEnabledTlsVersions() throws Exception {
     ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
         .allEnabledTlsVersions()
         .build();
-    assertNull(tlsSpec.tlsVersions());
+    assertThat(tlsSpec.tlsVersions()).isNull();
 
     SSLSocket sslSocket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
     sslSocket.setEnabledProtocols(new String[] {
@@ -231,9 +227,9 @@
         TlsVersion.TLS_1_1.javaName()
     });
 
-    tlsSpec.apply(sslSocket, false);
-    assertEquals(Arrays.asList(TlsVersion.SSL_3_0.javaName(), TlsVersion.TLS_1_1.javaName()),
-        Arrays.asList(sslSocket.getEnabledProtocols()));
+    applyConnectionSpec(tlsSpec, sslSocket, false);
+    assertThat(sslSocket.getEnabledProtocols()).containsExactly(
+        TlsVersion.SSL_3_0.javaName(), TlsVersion.TLS_1_1.javaName());
   }
 
   @Test public void tls_missingTlsVersion() throws Exception {
@@ -245,15 +241,15 @@
 
     SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
     socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName,
+        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
     });
 
     socket.setEnabledProtocols(
-        new String[] {TlsVersion.TLS_1_2.javaName, TlsVersion.TLS_1_1.javaName});
-    assertTrue(tlsSpec.isCompatible(socket));
+        new String[] {TlsVersion.TLS_1_2.javaName(), TlsVersion.TLS_1_1.javaName()});
+    assertThat(tlsSpec.isCompatible(socket)).isTrue();
 
-    socket.setEnabledProtocols(new String[] {TlsVersion.TLS_1_1.javaName});
-    assertFalse(tlsSpec.isCompatible(socket));
+    socket.setEnabledProtocols(new String[] {TlsVersion.TLS_1_1.javaName()});
+    assertThat(tlsSpec.isCompatible(socket)).isFalse();
   }
 
   @Test public void equalsAndHashCode() throws Exception {
@@ -265,18 +261,18 @@
         .build();
 
     Set<Object> set = new CopyOnWriteArraySet<>();
-    assertTrue(set.add(ConnectionSpec.MODERN_TLS));
-    assertTrue(set.add(ConnectionSpec.COMPATIBLE_TLS));
-    assertTrue(set.add(ConnectionSpec.CLEARTEXT));
-    assertTrue(set.add(allTlsVersions));
-    assertTrue(set.add(allCipherSuites));
-
-    assertTrue(set.remove(ConnectionSpec.MODERN_TLS));
-    assertTrue(set.remove(ConnectionSpec.COMPATIBLE_TLS));
-    assertTrue(set.remove(ConnectionSpec.CLEARTEXT));
-    assertTrue(set.remove(allTlsVersions));
-    assertTrue(set.remove(allCipherSuites));
-    assertTrue(set.isEmpty());
+    assertThat(set.add(ConnectionSpec.MODERN_TLS)).isTrue();
+    assertThat(set.add(ConnectionSpec.COMPATIBLE_TLS)).isTrue();
+    assertThat(set.add(ConnectionSpec.CLEARTEXT)).isTrue();
+    assertThat(set.add(allTlsVersions)).isTrue();
+    assertThat(set.add(allCipherSuites)).isTrue();
+
+    assertThat(set.remove(ConnectionSpec.MODERN_TLS)).isTrue();
+    assertThat(set.remove(ConnectionSpec.COMPATIBLE_TLS)).isTrue();
+    assertThat(set.remove(ConnectionSpec.CLEARTEXT)).isTrue();
+    assertThat(set.remove(allTlsVersions)).isTrue();
+    assertThat(set.remove(allCipherSuites)).isTrue();
+    assertThat(set).isEmpty();
   }
 
   @Test public void allEnabledToString() throws Exception {
@@ -284,8 +280,9 @@
         .allEnabledTlsVersions()
         .allEnabledCipherSuites()
         .build();
-    assertEquals("ConnectionSpec(cipherSuites=[all enabled], tlsVersions=[all enabled], "
-        + "supportsTlsExtensions=true)", connectionSpec.toString());
+    assertThat(connectionSpec.toString()).isEqualTo(
+        ("ConnectionSpec(cipherSuites=[all enabled], tlsVersions=[all enabled], "
+        + "supportsTlsExtensions=true)"));
   }
 
   @Test public void simpleToString() throws Exception {
@@ -293,11 +290,8 @@
         .tlsVersions(TlsVersion.TLS_1_2)
         .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
         .build();
-    assertEquals("ConnectionSpec(cipherSuites=[SSL_RSA_WITH_RC4_128_MD5], tlsVersions=[TLS_1_2], "
-        + "supportsTlsExtensions=true)", connectionSpec.toString());
-  }
-
-  private static <T> Set<T> set(T... values) {
-    return new LinkedHashSet<>(Arrays.asList(values));
+    assertThat(connectionSpec.toString()).isEqualTo(
+        ("ConnectionSpec(cipherSuites=[SSL_RSA_WITH_RC4_128_MD5], tlsVersions=[TLS_1_2], "
+        + "supportsTlsExtensions=true)"));
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java b/okhttp/src/test/java/okhttp3/ConscryptTest.java
similarity index 82%
rename from okhttp-tests/src/test/java/okhttp3/ConscryptTest.java
rename to okhttp/src/test/java/okhttp3/ConscryptTest.java
index 572af5cb4b..2d2a53566f 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java
+++ b/okhttp/src/test/java/okhttp3/ConscryptTest.java
@@ -23,12 +23,12 @@
 import okhttp3.internal.platform.ConscryptPlatform;
 import okhttp3.internal.platform.Platform;
 import org.conscrypt.OpenSSLProvider;
+import org.junit.After;
 import org.junit.Assume;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class ConscryptTest {
   public static final CipherSuite[] MANDATORY_CIPHER_SUITES = new CipherSuite[] {
@@ -42,14 +42,19 @@
 
   private OkHttpClient client = buildClient();
 
+  @After
+  public void tearDown() {
+    TestUtil.ensureAllConnectionsReleased(client);
+  }
+
   private OkHttpClient buildClient() {
     ConnectionSpec spec = new ConnectionSpec.Builder(true)
         .cipherSuites(MANDATORY_CIPHER_SUITES) // Check we are using strong ciphers
-        .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2) // and modern TLS
+        .tlsVersions(TlsVersion.TLS_1_2) // and modern TLS
         .supportsTlsExtensions(true)
         .build();
 
-    return new OkHttpClient.Builder().connectionSpecs(Arrays.asList(spec)).build();
+    return new OkHttpClient.Builder().connectionSpecs(asList(spec)).build();
   }
 
   private static void assumeConscrypt() {
@@ -73,7 +78,7 @@ public void testMozilla() throws IOException {
 
     Response response = client.newCall(request).execute();
 
-    assertEquals(Protocol.HTTP_2, response.protocol());
+    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_2);
   }
 
   @Test
@@ -85,12 +90,12 @@ public void testGoogle() throws IOException {
 
     Response response = client.newCall(request).execute();
 
-    assertEquals(Protocol.HTTP_2, response.protocol());
+    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_2);
   }
 
   @Test
   public void testBuild() {
-    assertNotNull(ConscryptPlatform.buildIfSupported());
+    assertThat(ConscryptPlatform.buildIfSupported()).isNotNull();
   }
 
   @Test
@@ -99,7 +104,7 @@ public void testPreferred() {
 
     try {
       Security.insertProviderAt(new OpenSSLProvider(), 1);
-      assertTrue(Platform.isConscryptPreferred());
+      assertThat(Platform.isConscryptPreferred()).isTrue();
     } finally {
       Security.removeProvider("Conscrypt");
     }
diff --git a/okhttp/src/test/java/okhttp3/CookieTest.java b/okhttp/src/test/java/okhttp3/CookieTest.java
new file mode 100644
index 0000000000..a1f591360f
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/CookieTest.java
@@ -0,0 +1,587 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.List;
+import java.util.Objects;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpDate;
+import org.junit.Test;
+
+import static java.util.Arrays.asList;
+import static okhttp3.internal.InternalKtKt.parseCookie;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class CookieTest {
+  HttpUrl url = HttpUrl.get("https://example.com/");
+
+  @Test public void simpleCookie() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42");
+    assertThat(cookie.toString()).isEqualTo("SID=31d4d96e407aad42; path=/");
+  }
+
+  @Test public void noEqualsSign() throws Exception {
+    assertThat(Cookie.parse(url, "foo")).isNull();
+    assertThat(Cookie.parse(url, "foo; Path=/")).isNull();
+  }
+
+  @Test public void emptyName() throws Exception {
+    assertThat(Cookie.parse(url, "=b")).isNull();
+    assertThat(Cookie.parse(url, " =b")).isNull();
+    assertThat(Cookie.parse(url, "\r\t \n=b")).isNull();
+  }
+
+  @Test public void spaceInName() throws Exception {
+    assertThat(Cookie.parse(url, "a b=cd").name()).isEqualTo("a b");
+  }
+
+  @Test public void spaceInValue() throws Exception {
+    assertThat(Cookie.parse(url, "ab=c d").value()).isEqualTo("c d");
+  }
+
+  @Test public void trimLeadingAndTrailingWhitespaceFromName() throws Exception {
+    assertThat(Cookie.parse(url, " a=b").name()).isEqualTo("a");
+    assertThat(Cookie.parse(url, "a =b").name()).isEqualTo("a");
+    assertThat(Cookie.parse(url, "\r\t \na\n\t \n=b").name()).isEqualTo("a");
+  }
+
+  @Test public void emptyValue() throws Exception {
+    assertThat(Cookie.parse(url, "a=").value()).isEqualTo("");
+    assertThat(Cookie.parse(url, "a= ").value()).isEqualTo("");
+    assertThat(Cookie.parse(url, "a=\r\t \n").value()).isEqualTo("");
+  }
+
+  @Test public void trimLeadingAndTrailingWhitespaceFromValue() throws Exception {
+    assertThat(Cookie.parse(url, "a= ").value()).isEqualTo("");
+    assertThat(Cookie.parse(url, "a= b").value()).isEqualTo("b");
+    assertThat(Cookie.parse(url, "a=b ").value()).isEqualTo("b");
+    assertThat(Cookie.parse(url, "a=\r\t \nb\n\t \n").value()).isEqualTo("b");
+  }
+
+  @Test public void invalidCharacters() throws Exception {
+    assertThat(Cookie.parse(url, "a\u0000b=cd")).isNull();
+    assertThat(Cookie.parse(url, "ab=c\u0000d")).isNull();
+    assertThat(Cookie.parse(url, "a\u0001b=cd")).isNull();
+    assertThat(Cookie.parse(url, "ab=c\u0001d")).isNull();
+    assertThat(Cookie.parse(url, "a\u0009b=cd")).isNull();
+    assertThat(Cookie.parse(url, "ab=c\u0009d")).isNull();
+    assertThat(Cookie.parse(url, "a\u001fb=cd")).isNull();
+    assertThat(Cookie.parse(url, "ab=c\u001fd")).isNull();
+    assertThat(Cookie.parse(url, "a\u007fb=cd")).isNull();
+    assertThat(Cookie.parse(url, "ab=c\u007fd")).isNull();
+    assertThat(Cookie.parse(url, "a\u0080b=cd")).isNull();
+    assertThat(Cookie.parse(url, "ab=c\u0080d")).isNull();
+    assertThat(Cookie.parse(url, "a\u00ffb=cd")).isNull();
+    assertThat(Cookie.parse(url, "ab=c\u00ffd")).isNull();
+  }
+
+  @Test public void maxAge() throws Exception {
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=1").expiresAt()).isEqualTo(51000L);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=9223372036854724").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=9223372036854725").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=9223372036854726").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(parseCookie(9223372036854773807L, url, "a=b; Max-Age=1").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(parseCookie(9223372036854773807L, url, "a=b; Max-Age=2").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(parseCookie(9223372036854773807L, url, "a=b; Max-Age=3").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=10000000000000000000").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+  }
+
+  @Test public void maxAgeNonPositive() throws Exception {
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-1").expiresAt()).isEqualTo(Long.MIN_VALUE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=0").expiresAt()).isEqualTo(Long.MIN_VALUE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-9223372036854775808").expiresAt()).isEqualTo(
+        Long.MIN_VALUE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-9223372036854775809").expiresAt()).isEqualTo(
+        Long.MIN_VALUE);
+    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-10000000000000000000").expiresAt()).isEqualTo(
+        Long.MIN_VALUE);
+  }
+
+  @Test public void domainAndPath() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Domain=example.com");
+    assertThat(cookie.domain()).isEqualTo("example.com");
+    assertThat(cookie.path()).isEqualTo("/");
+    assertThat(cookie.hostOnly()).isFalse();
+    assertThat(cookie.toString()).isEqualTo(
+        "SID=31d4d96e407aad42; domain=example.com; path=/");
+  }
+
+  @Test public void secureAndHttpOnly() throws Exception {
+    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Secure; HttpOnly");
+    assertThat(cookie.secure()).isTrue();
+    assertThat(cookie.httpOnly()).isTrue();
+    assertThat(cookie.toString()).isEqualTo(
+        "SID=31d4d96e407aad42; path=/; secure; httponly");
+  }
+
+  @Test public void expiresDate() throws Exception {
+    assertThat(new Date(
+        Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT").expiresAt())).isEqualTo(
+        date("1970-01-01T00:00:00.000+0000"));
+    assertThat(new Date(
+        Cookie.parse(url, "a=b; Expires=Wed, 09 Jun 2021 10:18:14 GMT").expiresAt())).isEqualTo(
+        date("2021-06-09T10:18:14.000+0000"));
+    assertThat(new Date(
+        Cookie.parse(url, "a=b; Expires=Sun, 06 Nov 1994 08:49:37 GMT").expiresAt())).isEqualTo(
+        date("1994-11-06T08:49:37.000+0000"));
+  }
+
+  @Test public void awkwardDates() throws Exception {
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 70 00:00:00 GMT").expiresAt()).isEqualTo(
+        0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 January 1970 00:00:00 GMT").expiresAt()).isEqualTo(
+        0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Janucember 1970 00:00:00 GMT").expiresAt()).isEqualTo(
+        0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 1 Jan 1970 00:00:00 GMT").expiresAt()).isEqualTo(
+        0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 0:00:00 GMT").expiresAt()).isEqualTo(
+        0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:0:00 GMT").expiresAt()).isEqualTo(
+        0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:0 GMT").expiresAt()).isEqualTo(
+        0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 Thu, 01 Jan 1970 GMT").expiresAt()).isEqualTo(
+        0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 01").expiresAt()).isEqualTo(0L);
+    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 1").expiresAt()).isEqualTo(0L);
+  }
+
+  @Test public void invalidYear() throws Exception {
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1600 00:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 19999 00:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 00:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+  }
+
+  @Test public void invalidMonth() throws Exception {
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Foo 1970 00:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Foocember 1970 00:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 1970 00:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+  }
+
+  @Test public void invalidDayOfMonth() throws Exception {
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 32 Jan 1970 00:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, Jan 1970 00:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+  }
+
+  @Test public void invalidHour() throws Exception {
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 24:00:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+  }
+
+  @Test public void invalidMinute() throws Exception {
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:60:00 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+  }
+
+  @Test public void invalidSecond() throws Exception {
+    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:60 GMT").expiresAt()).isEqualTo(
+        HttpDate.MAX_DATE);
+  }
+
+  @Test public void domainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com");
+    assertThat(cookie.matches(HttpUrl.get("http://example.com"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://www.example.com"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://square.com"))).isFalse();
+  }
+
+  /** If no domain is present, match only the origin domain. */
+  @Test public void domainMatchesNoDomain() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b");
+    assertThat(cookie.matches(HttpUrl.get("http://example.com"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://www.example.com"))).isFalse();
+    assertThat(cookie.matches(HttpUrl.get("http://square.com"))).isFalse();
+  }
+
+  /** Ignore an optional leading `.` in the domain. */
+  @Test public void domainMatchesIgnoresLeadingDot() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=.example.com");
+    assertThat(cookie.matches(HttpUrl.get("http://example.com"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://www.example.com"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://square.com"))).isFalse();
+  }
+
+  /** Ignore the entire attribute if the domain ends with `.`. */
+  @Test public void domainIgnoredWithTrailingDot() throws Exception {
+    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com.");
+    assertThat(cookie.matches(HttpUrl.get("http://example.com"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://www.example.com"))).isFalse();
+    assertThat(cookie.matches(HttpUrl.get("http://square.com"))).isFalse();
+  }
+
+  @Test public void idnDomainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://‚òÉ.net/"), "a=b; domain=‚òÉ.net");
+    assertThat(cookie.matches(HttpUrl.get("http://‚òÉ.net/"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://xn--n3h.net/"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://www.‚òÉ.net/"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://www.xn--n3h.net/"))).isTrue();
+  }
+
+  @Test public void punycodeDomainMatches() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://xn--n3h.net/"), "a=b; domain=xn--n3h.net");
+    assertThat(cookie.matches(HttpUrl.get("http://‚òÉ.net/"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://xn--n3h.net/"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://www.‚òÉ.net/"))).isTrue();
+    assertThat(cookie.matches(HttpUrl.get("http://www.xn--n3h.net/"))).isTrue();
+  }
+
+  @Test public void domainMatchesIpAddress() throws Exception {
+    HttpUrl urlWithIp = HttpUrl.get("http://123.45.234.56/");
+    assertThat(Cookie.parse(urlWithIp, "a=b; domain=234.56")).isNull();
+    assertThat(Cookie.parse(urlWithIp, "a=b; domain=123.45.234.56").domain()).isEqualTo(
+        "123.45.234.56");
+  }
+
+  @Test public void domainMatchesIpv6Address() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::1");
+    assertThat(cookie.domain()).isEqualTo("::1");
+    assertThat(cookie.matches(HttpUrl.get("http://[::1]/"))).isTrue();
+  }
+
+  @Test public void domainMatchesIpv6AddressWithCompression() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[0001:0000::]/"), "a=b; domain=0001:0000::");
+    assertThat(cookie.domain()).isEqualTo("1::");
+    assertThat(cookie.matches(HttpUrl.get("http://[1::]/"))).isTrue();
+  }
+
+  @Test public void domainMatchesIpv6AddressWithIpv4Suffix() throws Exception {
+    Cookie cookie = Cookie.parse(
+        HttpUrl.get("http://[::1:ffff:ffff]/"), "a=b; domain=::1:255.255.255.255");
+    assertThat(cookie.domain()).isEqualTo("::1:ffff:ffff");
+    assertThat(cookie.matches(HttpUrl.get("http://[::1:ffff:ffff]/"))).isTrue();
+  }
+
+  @Test public void ipv6AddressDoesntMatch() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::2");
+    assertThat(cookie).isNull();
+  }
+
+  @Test public void ipv6AddressMalformed() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::2::2");
+    assertThat(cookie.domain()).isEqualTo("::1");
+  }
+
+  /**
+   * These public suffixes were selected by inspecting the publicsuffix.org list. It's possible they
+   * may change in the future. If this test begins to fail, please double check they are still
+   * present in the public suffix list.
+   */
+  @Test public void domainIsPublicSuffix() {
+    HttpUrl ascii = HttpUrl.get("https://foo1.foo.bar.elb.amazonaws.com");
+    assertThat(Cookie.parse(ascii, "a=b; domain=foo.bar.elb.amazonaws.com")).isNotNull();
+    assertThat(Cookie.parse(ascii, "a=b; domain=bar.elb.amazonaws.com")).isNull();
+    assertThat(Cookie.parse(ascii, "a=b; domain=com")).isNull();
+
+    HttpUrl unicode = HttpUrl.get("https://Èï∑.Èï∑.Èï∑Â¥é.jp");
+    assertThat(Cookie.parse(unicode, "a=b; domain=Èï∑.Èï∑Â¥é.jp")).isNotNull();
+    assertThat(Cookie.parse(unicode, "a=b; domain=Èï∑Â¥é.jp")).isNull();
+
+    HttpUrl punycode = HttpUrl.get("https://xn--ue5a.xn--ue5a.xn--8ltr62k.jp");
+    assertThat(Cookie.parse(punycode, "a=b; domain=xn--ue5a.xn--8ltr62k.jp")).isNotNull();
+    assertThat(Cookie.parse(punycode, "a=b; domain=xn--8ltr62k.jp")).isNull();
+  }
+
+  @Test public void hostOnly() throws Exception {
+    assertThat(Cookie.parse(url, "a=b").hostOnly()).isTrue();
+    assertThat(Cookie.parse(url, "a=b; domain=example.com").hostOnly()).isFalse();
+  }
+
+  @Test public void defaultPath() throws Exception {
+    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/bar"), "a=b").path()).isEqualTo(
+        "/foo");
+    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/"), "a=b").path()).isEqualTo(
+        "/foo");
+    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo"), "a=b").path()).isEqualTo(
+        "/");
+    assertThat(Cookie.parse(HttpUrl.get("http://example.com/"), "a=b").path()).isEqualTo(
+        "/");
+  }
+
+  @Test public void defaultPathIsUsedIfPathDoesntHaveLeadingSlash() throws Exception {
+    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
+        "a=b; path=quux").path()).isEqualTo("/foo");
+    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
+        "a=b; path=").path()).isEqualTo("/foo");
+  }
+
+  @Test public void pathAttributeDoesntNeedToMatch() throws Exception {
+    assertThat(Cookie.parse(HttpUrl.get("http://example.com/"),
+        "a=b; path=/quux").path()).isEqualTo("/quux");
+    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
+        "a=b; path=/quux").path()).isEqualTo("/quux");
+  }
+
+  @Test public void httpOnly() throws Exception {
+    assertThat(Cookie.parse(url, "a=b").httpOnly()).isFalse();
+    assertThat(Cookie.parse(url, "a=b; HttpOnly").httpOnly()).isTrue();
+  }
+
+  @Test public void secure() throws Exception {
+    assertThat(Cookie.parse(url, "a=b").secure()).isFalse();
+    assertThat(Cookie.parse(url, "a=b; Secure").secure()).isTrue();
+  }
+
+  @Test public void maxAgeTakesPrecedenceOverExpires() throws Exception {
+    // Max-Age = 1, Expires = 2. In either order.
+    assertThat(parseCookie(
+        0L, url, "a=b; Max-Age=1; Expires=Thu, 01 Jan 1970 00:00:02 GMT").expiresAt()).isEqualTo(
+        1000L);
+    assertThat(parseCookie(
+        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:02 GMT; Max-Age=1").expiresAt()).isEqualTo(
+        1000L);
+    // Max-Age = 2, Expires = 1. In either order.
+    assertThat(parseCookie(
+        0L, url, "a=b; Max-Age=2; Expires=Thu, 01 Jan 1970 00:00:01 GMT").expiresAt()).isEqualTo(
+        2000L);
+    assertThat(parseCookie(
+        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Max-Age=2").expiresAt()).isEqualTo(
+        2000L);
+  }
+
+  /** If a cookie incorrectly defines multiple 'Max-Age' attributes, the last one defined wins. */
+  @Test public void lastMaxAgeWins() throws Exception {
+    assertThat(parseCookie(
+        0L, url, "a=b; Max-Age=2; Max-Age=4; Max-Age=1; Max-Age=3").expiresAt()).isEqualTo(3000L);
+  }
+
+  /** If a cookie incorrectly defines multiple 'Expires' attributes, the last one defined wins. */
+  @Test public void lastExpiresAtWins() throws Exception {
+    assertThat(parseCookie(0L, url, "a=b; "
+        + "Expires=Thu, 01 Jan 1970 00:00:02 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:04 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:01 GMT; "
+        + "Expires=Thu, 01 Jan 1970 00:00:03 GMT").expiresAt()).isEqualTo(3000L);
+  }
+
+  @Test public void maxAgeOrExpiresMakesCookiePersistent() throws Exception {
+    assertThat(parseCookie(0L, url, "a=b").persistent()).isFalse();
+    assertThat(parseCookie(0L, url, "a=b; Max-Age=1").persistent()).isTrue();
+    assertThat(parseCookie(0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT").persistent()).isTrue();
+  }
+
+  @Test public void parseAll() throws Exception {
+    Headers headers = new Headers.Builder()
+        .add("Set-Cookie: a=b")
+        .add("Set-Cookie: c=d")
+        .build();
+    List<Cookie> cookies = Cookie.parseAll(url, headers);
+    assertThat(cookies.size()).isEqualTo(2);
+    assertThat(cookies.get(0).toString()).isEqualTo("a=b; path=/");
+    assertThat(cookies.get(1).toString()).isEqualTo("c=d; path=/");
+  }
+
+  @Test public void builder() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain("example.com")
+        .build();
+    assertThat(cookie.name()).isEqualTo("a");
+    assertThat(cookie.value()).isEqualTo("b");
+    assertThat(cookie.expiresAt()).isEqualTo(HttpDate.MAX_DATE);
+    assertThat(cookie.domain()).isEqualTo("example.com");
+    assertThat(cookie.path()).isEqualTo("/");
+    assertThat(cookie.secure()).isFalse();
+    assertThat(cookie.httpOnly()).isFalse();
+    assertThat(cookie.persistent()).isFalse();
+    assertThat(cookie.hostOnly()).isFalse();
+  }
+
+  @Test public void builderNameValidation() throws Exception {
+    try {
+      new Cookie.Builder().name(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Cookie.Builder().name(" a ");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderValueValidation() throws Exception {
+    try {
+      new Cookie.Builder().value(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Cookie.Builder().value(" b ");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderClampsMaxDate() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(Long.MAX_VALUE)
+        .build();
+    assertThat(cookie.toString()).isEqualTo(
+        "a=b; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/");
+  }
+
+  @Test public void builderExpiresAt() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(date("1970-01-01T00:00:01.000+0000").getTime())
+        .build();
+    assertThat(cookie.toString()).isEqualTo(
+        "a=b; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/");
+  }
+
+  @Test public void builderClampsMinDate() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .expiresAt(date("1970-01-01T00:00:00.000+0000").getTime())
+        .build();
+    assertThat(cookie.toString()).isEqualTo("a=b; max-age=0; path=/");
+  }
+
+  @Test public void builderDomainValidation() throws Exception {
+    try {
+      new Cookie.Builder().hostOnlyDomain(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Cookie.Builder().hostOnlyDomain("a/b");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderDomain() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("squareup.com")
+        .build();
+    assertThat(cookie.domain()).isEqualTo("squareup.com");
+    assertThat(cookie.hostOnly()).isTrue();
+  }
+
+  @Test public void builderPath() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .path("/foo")
+        .build();
+    assertThat(cookie.path()).isEqualTo("/foo");
+  }
+
+  @Test public void builderPathValidation() throws Exception {
+    try {
+      new Cookie.Builder().path(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Cookie.Builder().path("foo");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void builderSecure() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .secure()
+        .build();
+    assertThat(cookie.secure()).isTrue();
+  }
+
+  @Test public void builderHttpOnly() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .hostOnlyDomain("example.com")
+        .httpOnly()
+        .build();
+    assertThat(cookie.httpOnly()).isTrue();
+  }
+
+  @Test public void builderIpv6() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain("0:0:0:0:0:0:0:1")
+        .build();
+    assertThat(cookie.domain()).isEqualTo("::1");
+  }
+
+  @Test public void equalsAndHashCode() throws Exception {
+    List<String> cookieStrings = asList(
+        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
+        "a= ; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
+        "a=b;          Domain=example.com; Max-Age=5; Secure; HttpOnly",
+        "a=b; Path=/c;                     Max-Age=5; Secure; HttpOnly",
+        "a=b; Path=/c; Domain=example.com;            Secure; HttpOnly",
+        "a=b; Path=/c; Domain=example.com; Max-Age=5;         HttpOnly",
+        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure;         "
+    );
+    for (String stringA : cookieStrings) {
+      Cookie cookieA = parseCookie(0, url, stringA);
+      for (String stringB : cookieStrings) {
+        Cookie cookieB = parseCookie(0, url, stringB);
+        if (Objects.equals(stringA, stringB)) {
+          assertThat(cookieB.hashCode()).isEqualTo(cookieA.hashCode());
+          assertThat(cookieB).isEqualTo(cookieA);
+        } else {
+          assertThat(cookieB.hashCode()).isNotEqualTo((long) cookieA.hashCode());
+          assertThat(cookieB).isNotEqualTo(cookieA);
+        }
+      }
+      assertThat(cookieA).isNotEqualTo(null);
+    }
+  }
+
+  private Date date(String s) throws ParseException {
+    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
+    format.setTimeZone(Util.UTC);
+    return format.parse(s);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CookiesTest.java b/okhttp/src/test/java/okhttp3/CookiesTest.java
similarity index 74%
rename from okhttp-tests/src/test/java/okhttp3/CookiesTest.java
rename to okhttp/src/test/java/okhttp3/CookiesTest.java
index ab2a955273..be8d238382 100644
--- a/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
+++ b/okhttp/src/test/java/okhttp3/CookiesTest.java
@@ -23,7 +23,6 @@
 import java.net.HttpURLConnection;
 import java.net.InetAddress;
 import java.net.URI;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -31,18 +30,21 @@
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import org.junit.Rule;
 import org.junit.Test;
 
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
-import static okhttp3.TestUtil.defaultClient;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 import static org.junit.Assert.fail;
 
 /** Derived from Android's CookiesTest. */
 public class CookiesTest {
-  private OkHttpClient client = defaultClient();
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+
+  private OkHttpClient client = clientTestRule.client;
 
   @Test
   public void testNetscapeResponse() throws Exception {
@@ -50,8 +52,6 @@ public void testNetscapeResponse() throws Exception {
     client = client.newBuilder()
         .cookieJar(new JavaNetCookieJar(cookieManager))
         .build();
-    MockWebServer server = new MockWebServer();
-    server.start();
 
     HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
     server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
@@ -62,17 +62,17 @@ public void testNetscapeResponse() throws Exception {
     get(urlWithIpAddress);
 
     List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertEquals(1, cookies.size());
+    assertThat(cookies.size()).isEqualTo(1);
     HttpCookie cookie = cookies.get(0);
-    assertEquals("a", cookie.getName());
-    assertEquals("android", cookie.getValue());
-    assertEquals(null, cookie.getComment());
-    assertEquals(null, cookie.getCommentURL());
-    assertEquals(false, cookie.getDiscard());
-    assertTrue(cookie.getMaxAge() > 100000000000L);
-    assertEquals("/path", cookie.getPath());
-    assertEquals(true, cookie.getSecure());
-    assertEquals(0, cookie.getVersion());
+    assertThat(cookie.getName()).isEqualTo("a");
+    assertThat(cookie.getValue()).isEqualTo("android");
+    assertThat(cookie.getComment()).isNull();
+    assertThat(cookie.getCommentURL()).isNull();
+    assertThat(cookie.getDiscard()).isFalse();
+    assertThat(cookie.getMaxAge()).isGreaterThan(100000000000L);
+    assertThat(cookie.getPath()).isEqualTo("/path");
+    assertThat(cookie.getSecure()).isTrue();
+    assertThat(cookie.getVersion()).isEqualTo(0);
   }
 
   @Test public void testRfc2109Response() throws Exception {
@@ -80,8 +80,6 @@ public void testNetscapeResponse() throws Exception {
     client = client.newBuilder()
         .cookieJar(new JavaNetCookieJar(cookieManager))
         .build();
-    MockWebServer server = new MockWebServer();
-    server.start();
 
     HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
     server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
@@ -94,15 +92,16 @@ public void testNetscapeResponse() throws Exception {
     get(urlWithIpAddress);
 
     List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertEquals(1, cookies.size());
+    assertThat(cookies.size()).isEqualTo(1);
     HttpCookie cookie = cookies.get(0);
-    assertEquals("a", cookie.getName());
-    assertEquals("android", cookie.getValue());
-    assertEquals(null, cookie.getCommentURL());
-    assertEquals(false, cookie.getDiscard());
-    assertEquals(60.0, cookie.getMaxAge(), 1.0); // Converting to a fixed date can cause rounding!
-    assertEquals("/path", cookie.getPath());
-    assertEquals(true, cookie.getSecure());
+    assertThat(cookie.getName()).isEqualTo("a");
+    assertThat(cookie.getValue()).isEqualTo("android");
+    assertThat(cookie.getCommentURL()).isNull();
+    assertThat(cookie.getDiscard()).isFalse();
+    // Converting to a fixed date can cause rounding!
+    assertThat((double) cookie.getMaxAge()).isCloseTo(60.0, offset(5.0));
+    assertThat(cookie.getPath()).isEqualTo("/path");
+    assertThat(cookie.getSecure()).isTrue();
   }
 
   @Test public void testQuotedAttributeValues() throws Exception {
@@ -110,8 +109,6 @@ public void testNetscapeResponse() throws Exception {
     client = client.newBuilder()
         .cookieJar(new JavaNetCookieJar(cookieManager))
         .build();
-    MockWebServer server = new MockWebServer();
-    server.start();
 
     HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
     server.enqueue(new MockResponse().addHeader("Set-Cookie: a=\"android\"; "
@@ -127,19 +124,18 @@ public void testNetscapeResponse() throws Exception {
     get(urlWithIpAddress);
 
     List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertEquals(1, cookies.size());
+    assertThat(cookies.size()).isEqualTo(1);
     HttpCookie cookie = cookies.get(0);
-    assertEquals("a", cookie.getName());
-    assertEquals("android", cookie.getValue());
-    assertEquals(60.0, cookie.getMaxAge(), 1.0); // Converting to a fixed date can cause rounding!
-    assertEquals("/path", cookie.getPath());
-    assertEquals(true, cookie.getSecure());
+    assertThat(cookie.getName()).isEqualTo("a");
+    assertThat(cookie.getValue()).isEqualTo("android");
+    // Converting to a fixed date can cause rounding!
+    assertThat((double) cookie.getMaxAge()).isCloseTo(60.0, offset(1.0));
+    assertThat(cookie.getPath()).isEqualTo("/path");
+    assertThat(cookie.getSecure()).isTrue();
   }
 
   @Test public void testSendingCookiesFromStore() throws Exception {
-    MockWebServer server = new MockWebServer();
     server.enqueue(new MockResponse());
-    server.start();
     HttpUrl serverUrl = urlWithIpAddress(server, "/");
 
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
@@ -158,13 +154,11 @@ public void testNetscapeResponse() throws Exception {
     get(serverUrl);
     RecordedRequest request = server.takeRequest();
 
-    assertEquals("a=android; b=banana", request.getHeader("Cookie"));
+    assertThat(request.getHeader("Cookie")).isEqualTo("a=android; b=banana");
   }
 
   @Test public void cookieHandlerLikeAndroid() throws Exception {
-    final MockWebServer server = new MockWebServer();
     server.enqueue(new MockResponse());
-    server.start();
     final HttpUrl serverUrl = urlWithIpAddress(server, "/");
 
     CookieHandler androidCookieHandler = new CookieHandler() {
@@ -186,16 +180,14 @@ public void testNetscapeResponse() throws Exception {
     get(serverUrl);
     RecordedRequest request = server.takeRequest();
 
-    assertEquals("a=android; b=banana", request.getHeader("Cookie"));
+    assertThat(request.getHeader("Cookie")).isEqualTo("a=android; b=banana");
   }
 
   @Test public void receiveAndSendMultipleCookies() throws Exception {
-    MockWebServer server = new MockWebServer();
     server.enqueue(new MockResponse()
         .addHeader("Set-Cookie", "a=android")
         .addHeader("Set-Cookie", "b=banana"));
     server.enqueue(new MockResponse());
-    server.start();
 
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     client = client.newBuilder()
@@ -204,11 +196,11 @@ public void testNetscapeResponse() throws Exception {
 
     get(urlWithIpAddress(server, "/"));
     RecordedRequest request1 = server.takeRequest();
-    assertNull(request1.getHeader("Cookie"));
+    assertThat(request1.getHeader("Cookie")).isNull();
 
     get(urlWithIpAddress(server, "/"));
     RecordedRequest request2 = server.takeRequest();
-    assertEquals("a=android; b=banana", request2.getHeader("Cookie"));
+    assertThat(request2.getHeader("Cookie")).isEqualTo("a=android; b=banana");
   }
 
   @Test public void testRedirectsDoNotIncludeTooManyCookies() throws Exception {
@@ -238,7 +230,7 @@ public void testNetscapeResponse() throws Exception {
     get(redirectSourceUrl);
     RecordedRequest request = redirectSource.takeRequest();
 
-    assertEquals("c=cookie", request.getHeader("Cookie"));
+    assertThat(request.getHeader("Cookie")).isEqualTo("c=cookie");
 
     for (String header : redirectTarget.takeRequest().getHeaders().names()) {
       if (header.startsWith("Cookie")) {
@@ -260,68 +252,66 @@ public void testNetscapeResponse() throws Exception {
         }))
         .build();
 
-    MockWebServer server = new MockWebServer();
     server.enqueue(new MockResponse());
-    server.start();
 
     get(server.url("/"));
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("Bar=bar; Baz=baz", request.getHeader("Cookie"));
-    assertNull(request.getHeader("Cookie2"));
-    assertNull(request.getHeader("Quux"));
+    assertThat(request.getHeader("Cookie")).isEqualTo("Bar=bar; Baz=baz");
+    assertThat(request.getHeader("Cookie2")).isNull();
+    assertThat(request.getHeader("Quux")).isNull();
   }
 
   @Test public void acceptOriginalServerMatchesSubdomain() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
-    HttpUrl url = HttpUrl.parse("https://www.squareup.com/");
-    cookieJar.saveFromResponse(url, Arrays.asList(
+    HttpUrl url = HttpUrl.get("https://www.squareup.com/");
+    cookieJar.saveFromResponse(url, asList(
         Cookie.parse(url, "a=android; Domain=squareup.com")));
     List<Cookie> actualCookies = cookieJar.loadForRequest(url);
-    assertEquals(1, actualCookies.size());
-    assertEquals("a", actualCookies.get(0).name());
-    assertEquals("android", actualCookies.get(0).value());
+    assertThat(actualCookies.size()).isEqualTo(1);
+    assertThat(actualCookies.get(0).name()).isEqualTo("a");
+    assertThat(actualCookies.get(0).value()).isEqualTo("android");
   }
 
   @Test public void acceptOriginalServerMatchesRfc2965Dot() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
-    HttpUrl url = HttpUrl.parse("https://www.squareup.com/");
-    cookieJar.saveFromResponse(url, Arrays.asList(
+    HttpUrl url = HttpUrl.get("https://www.squareup.com/");
+    cookieJar.saveFromResponse(url, asList(
         Cookie.parse(url, "a=android; Domain=.squareup.com")));
     List<Cookie> actualCookies = cookieJar.loadForRequest(url);
-    assertEquals(1, actualCookies.size());
-    assertEquals("a", actualCookies.get(0).name());
-    assertEquals("android", actualCookies.get(0).value());
+    assertThat(actualCookies.size()).isEqualTo(1);
+    assertThat(actualCookies.get(0).name()).isEqualTo("a");
+    assertThat(actualCookies.get(0).value()).isEqualTo("android");
   }
 
   @Test public void acceptOriginalServerMatchesExactly() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
-    HttpUrl url = HttpUrl.parse("https://squareup.com/");
-    cookieJar.saveFromResponse(url, Arrays.asList(
+    HttpUrl url = HttpUrl.get("https://squareup.com/");
+    cookieJar.saveFromResponse(url, asList(
         Cookie.parse(url, "a=android; Domain=squareup.com")));
     List<Cookie> actualCookies = cookieJar.loadForRequest(url);
-    assertEquals(1, actualCookies.size());
-    assertEquals("a", actualCookies.get(0).name());
-    assertEquals("android", actualCookies.get(0).value());
+    assertThat(actualCookies.size()).isEqualTo(1);
+    assertThat(actualCookies.get(0).name()).isEqualTo("a");
+    assertThat(actualCookies.get(0).value()).isEqualTo("android");
   }
 
   @Test public void acceptOriginalServerDoesNotMatchDifferentServer() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
-    HttpUrl url1 = HttpUrl.parse("https://api.squareup.com/");
-    cookieJar.saveFromResponse(url1, Arrays.asList(
+    HttpUrl url1 = HttpUrl.get("https://api.squareup.com/");
+    cookieJar.saveFromResponse(url1, asList(
         Cookie.parse(url1, "a=android; Domain=api.squareup.com")));
 
-    HttpUrl url2 = HttpUrl.parse("https://www.squareup.com/");
+    HttpUrl url2 = HttpUrl.get("https://www.squareup.com/");
     List<Cookie> actualCookies = cookieJar.loadForRequest(url2);
-    assertEquals(Collections.<Cookie>emptyList(), actualCookies);
+    assertThat(actualCookies).isEmpty();
   }
 
   private HttpUrl urlWithIpAddress(MockWebServer server, String path) throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java b/okhttp/src/test/java/okhttp3/DelegatingSSLSocket.java
similarity index 94%
rename from okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
rename to okhttp/src/test/java/okhttp3/DelegatingSSLSocket.java
index fc863c2022..6647dfc4d9 100644
--- a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocket.java
+++ b/okhttp/src/test/java/okhttp3/DelegatingSSLSocket.java
@@ -287,6 +287,7 @@ public DelegatingSSLSocket(SSLSocket delegate) {
 
   // Java 9 methods.
 
+  @SuppressWarnings("MissingOverride") // Can only override with JDK 9+
   public SSLSession getHandshakeSession() {
     try {
       return (SSLSession) SSLSocket.class.getMethod("getHandshakeSession").invoke(delegate);
@@ -295,6 +296,7 @@ public SSLSession getHandshakeSession() {
     }
   }
 
+  @SuppressWarnings("MissingOverride") // Can only override with JDK 9+
   public String getApplicationProtocol() {
     try {
       return (String) SSLSocket.class.getMethod("getApplicationProtocol").invoke(delegate);
@@ -303,6 +305,7 @@ public String getApplicationProtocol() {
     }
   }
 
+  @SuppressWarnings("MissingOverride") // Can only override with JDK 9+
   public String getHandshakeApplicationProtocol() {
     try {
       return (String) SSLSocket.class.getMethod("getHandshakeApplicationProtocol").invoke(delegate);
@@ -311,6 +314,7 @@ public String getHandshakeApplicationProtocol() {
     }
   }
 
+  @SuppressWarnings("MissingOverride") // Can only override with JDK 9+
   public <T> Socket setOption(SocketOption<T> name, T value) throws IOException {
     try {
       SSLSocket.class.getMethod("setOption", SocketOption.class, Object.class).invoke(delegate, name, value);
@@ -320,6 +324,10 @@ public String getHandshakeApplicationProtocol() {
     }
   }
 
+  @SuppressWarnings({
+      "MissingOverride", // Can only override with JDK 9+
+      "unchecked" // Using reflection to delegate.
+  })
   public <T> T getOption(SocketOption<T> name) throws IOException {
     try {
       return (T) SSLSocket.class.getMethod("getOption", SocketOption.class).invoke(delegate, name);
@@ -328,6 +336,10 @@ public String getHandshakeApplicationProtocol() {
     }
   }
 
+  @SuppressWarnings({
+      "MissingOverride", // Can only override with JDK 9+
+      "unchecked" // Using reflection to delegate.
+  })
   public Set<SocketOption<?>> supportedOptions() {
     try {
       return (Set<SocketOption<?>>) SSLSocket.class.getMethod("supportedOptions").invoke(delegate);
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java b/okhttp/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
rename to okhttp/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingServerSocketFactory.java b/okhttp/src/test/java/okhttp3/DelegatingServerSocketFactory.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/DelegatingServerSocketFactory.java
rename to okhttp/src/test/java/okhttp3/DelegatingServerSocketFactory.java
diff --git a/okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java b/okhttp/src/test/java/okhttp3/DelegatingSocketFactory.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/DelegatingSocketFactory.java
rename to okhttp/src/test/java/okhttp3/DelegatingSocketFactory.java
diff --git a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java b/okhttp/src/test/java/okhttp3/DispatcherTest.java
similarity index 56%
rename from okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
rename to okhttp/src/test/java/okhttp3/DispatcherTest.java
index 5c5350e61c..b7d0291113 100644
--- a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
+++ b/okhttp/src/test/java/okhttp3/DispatcherTest.java
@@ -1,40 +1,34 @@
 package okhttp3;
 
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.AbstractExecutorService;
+import java.io.InterruptedIOException;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
-import okhttp3.RealCall.AsyncCall;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
-import static okhttp3.TestUtil.defaultClient;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class DispatcherTest {
-  RecordingExecutor executor = new RecordingExecutor();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+
+  RecordingExecutor executor = new RecordingExecutor(this);
   RecordingCallback callback = new RecordingCallback();
   RecordingWebSocketListener webSocketListener = new RecordingWebSocketListener();
   Dispatcher dispatcher = new Dispatcher(executor);
-  OkHttpClient client = defaultClient().newBuilder()
+  RecordingEventListener listener = new RecordingEventListener();
+  OkHttpClient client = clientTestRule.client.newBuilder()
       .dispatcher(dispatcher)
+      .eventListener(listener)
       .build();
 
   @Before public void setUp() throws Exception {
     dispatcher.setMaxRequests(20);
     dispatcher.setMaxRequestsPerHost(10);
+    listener.forbidLock(dispatcher);
   }
 
   @Test public void maxRequestsZero() throws Exception {
@@ -133,6 +127,18 @@
     executor.assertJobs("http://a/1");
   }
 
+  @Test public void enqueuedCallsStillRespectMaxCallsPerHost() throws Exception {
+    dispatcher.setMaxRequests(1);
+    dispatcher.setMaxRequestsPerHost(1);
+    client.newCall(newRequest("http://a/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/1")).enqueue(callback);
+    client.newCall(newRequest("http://b/2")).enqueue(callback);
+    client.newCall(newRequest("http://b/3")).enqueue(callback);
+    dispatcher.setMaxRequests(3);
+    executor.finishJob("http://a/1");
+    executor.assertJobs("http://b/1");
+  }
+
   @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
     dispatcher.setMaxRequests(1);
     Call c1 = client.newCall(newRequest("http://a/1", "tag1"));
@@ -157,28 +163,25 @@
     a3.enqueue(callback);
     a4.enqueue(callback);
     a5.enqueue(callback);
-    assertEquals(3, dispatcher.runningCallsCount());
-    assertEquals(2, dispatcher.queuedCallsCount());
-    assertEquals(set(a1, a2, a3), set(dispatcher.runningCalls()));
-    assertEquals(set(a4, a5), set(dispatcher.queuedCalls()));
+    assertThat(dispatcher.runningCallsCount()).isEqualTo(3);
+    assertThat(dispatcher.queuedCallsCount()).isEqualTo(2);
+    assertThat(dispatcher.runningCalls()).containsExactlyInAnyOrder(a1, a2, a3);
+    assertThat(dispatcher.queuedCalls()).containsExactlyInAnyOrder(a4, a5);
   }
 
   @Test public void synchronousCallAccessors() throws Exception {
-    final CountDownLatch ready = new CountDownLatch(2);
-    final CountDownLatch waiting = new CountDownLatch(1);
+    CountDownLatch ready = new CountDownLatch(2);
+    CountDownLatch waiting = new CountDownLatch(1);
     client = client.newBuilder()
-        .addInterceptor(
-            new Interceptor() {
-              @Override public Response intercept(Chain chain) throws IOException {
-                try {
-                  ready.countDown();
-                  waiting.await();
-                } catch (InterruptedException e) {
-                  throw new AssertionError();
-                }
-                throw new IOException();
-              }
-            })
+        .addInterceptor(chain -> {
+          try {
+            ready.countDown();
+            waiting.await();
+          } catch (InterruptedException e) {
+            throw new AssertionError();
+          }
+          throw new IOException();
+        })
         .build();
 
     Call a1 = client.newCall(newRequest("http://a/1"));
@@ -190,16 +193,16 @@
 
     // We created 4 calls and started 2 of them. That's 2 running calls and 0 queued.
     ready.await();
-    assertEquals(2, dispatcher.runningCallsCount());
-    assertEquals(0, dispatcher.queuedCallsCount());
-    assertEquals(set(a1, a2), set(dispatcher.runningCalls()));
-    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+    assertThat(dispatcher.runningCallsCount()).isEqualTo(2);
+    assertThat(dispatcher.queuedCallsCount()).isEqualTo(0);
+    assertThat(dispatcher.runningCalls()).containsExactlyInAnyOrder(a1, a2);
+    assertThat(dispatcher.queuedCalls()).isEmpty();
 
     // Cancel some calls. That doesn't impact running or queued.
     a2.cancel();
     a3.cancel();
-    assertEquals(set(a1, a2), set(dispatcher.runningCalls()));
-    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+    assertThat(dispatcher.runningCalls()).containsExactlyInAnyOrder(a1, a2);
+    assertThat(dispatcher.queuedCalls()).isEmpty();
 
     // Let the calls finish.
     waiting.countDown();
@@ -207,132 +210,115 @@
     t2.join();
 
     // Now we should have 0 running calls and 0 queued calls.
-    assertEquals(0, dispatcher.runningCallsCount());
-    assertEquals(0, dispatcher.queuedCallsCount());
-    assertEquals(Collections.emptyList(), dispatcher.runningCalls());
-    assertEquals(Collections.emptyList(), dispatcher.queuedCalls());
+    assertThat(dispatcher.runningCallsCount()).isEqualTo(0);
+    assertThat(dispatcher.queuedCallsCount()).isEqualTo(0);
+    assertThat(dispatcher.runningCalls()).isEmpty();
+    assertThat(dispatcher.queuedCalls()).isEmpty();
 
-    assertTrue(a1.isExecuted());
-    assertFalse(a1.isCanceled());
+    assertThat(a1.isExecuted()).isTrue();
+    assertThat(a1.isCanceled()).isFalse();
 
-    assertTrue(a2.isExecuted());
-    assertTrue(a2.isCanceled());
+    assertThat(a2.isExecuted()).isTrue();
+    assertThat(a2.isCanceled()).isTrue();
 
-    assertFalse(a3.isExecuted());
-    assertTrue(a3.isCanceled());
+    assertThat(a3.isExecuted()).isFalse();
+    assertThat(a3.isCanceled()).isTrue();
 
-    assertFalse(a4.isExecuted());
-    assertFalse(a4.isCanceled());
+    assertThat(a4.isExecuted()).isFalse();
+    assertThat(a4.isCanceled()).isFalse();
   }
 
-  @Test public void idleCallbackInvokedWhenIdle() throws InterruptedException {
-    final AtomicBoolean idle = new AtomicBoolean();
-    dispatcher.setIdleCallback(new Runnable() {
-      @Override public void run() {
-        idle.set(true);
-      }
-    });
+  @Test public void idleCallbackInvokedWhenIdle() throws Exception {
+    AtomicBoolean idle = new AtomicBoolean();
+    dispatcher.setIdleCallback(() -> idle.set(true));
 
     client.newCall(newRequest("http://a/1")).enqueue(callback);
     client.newCall(newRequest("http://a/2")).enqueue(callback);
     executor.finishJob("http://a/1");
-    assertFalse(idle.get());
+    assertThat(idle.get()).isFalse();
 
-    final CountDownLatch ready = new CountDownLatch(1);
-    final CountDownLatch proceed = new CountDownLatch(1);
+    CountDownLatch ready = new CountDownLatch(1);
+    CountDownLatch proceed = new CountDownLatch(1);
     client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            ready.countDown();
-            try {
-              proceed.await(5, SECONDS);
-            } catch (InterruptedException e) {
-              throw new RuntimeException(e);
-            }
-            return chain.proceed(chain.request());
+        .addInterceptor(chain -> {
+          ready.countDown();
+          try {
+            proceed.await(5, SECONDS);
+          } catch (InterruptedException e) {
+            throw new RuntimeException(e);
           }
+          return chain.proceed(chain.request());
         })
         .build();
 
     Thread t1 = makeSynchronousCall(client.newCall(newRequest("http://a/3")));
     ready.await(5, SECONDS);
     executor.finishJob("http://a/2");
-    assertFalse(idle.get());
+    assertThat(idle.get()).isFalse();
 
     proceed.countDown();
     t1.join();
-    assertTrue(idle.get());
+    assertThat(idle.get()).isTrue();
   }
 
-  private <T> Set<T> set(T... values) {
-    return set(Arrays.asList(values));
+  @Test public void executionRejectedImmediately() throws Exception {
+    Request request = newRequest("http://a/1");
+    executor.shutdown();
+    client.newCall(request).enqueue(callback);
+    callback.await(request.url()).assertFailure(InterruptedIOException.class);
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallFailed");
   }
 
-  private <T> Set<T> set(List<T> list) {
-    return new LinkedHashSet<>(list);
+  @Test public void executionRejectedAfterMaxRequestsChange() throws Exception {
+    Request request1 = newRequest("http://a/1");
+    Request request2 = newRequest("http://a/2");
+    dispatcher.setMaxRequests(1);
+    client.newCall(request1).enqueue(callback);
+    executor.shutdown();
+    client.newCall(request2).enqueue(callback);
+    dispatcher.setMaxRequests(2); // Trigger promotion.
+    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
+
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallStart",
+        "CallFailed");
   }
 
-  private Thread makeSynchronousCall(final Call call) {
-    Thread thread = new Thread() {
-      @Override public void run() {
-        try {
-          call.execute();
-          throw new AssertionError();
-        } catch (IOException expected) {
-        }
-      }
-    };
-    thread.start();
-    return thread;
+  @Test public void executionRejectedAfterMaxRequestsPerHostChange() throws Exception {
+    Request request1 = newRequest("http://a/1");
+    Request request2 = newRequest("http://a/2");
+    dispatcher.setMaxRequestsPerHost(1);
+    client.newCall(request1).enqueue(callback);
+    executor.shutdown();
+    client.newCall(request2).enqueue(callback);
+    dispatcher.setMaxRequestsPerHost(2); // Trigger promotion.
+    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallStart",
+        "CallFailed");
   }
 
-  class RecordingExecutor extends AbstractExecutorService {
-    private List<AsyncCall> calls = new ArrayList<>();
-
-    @Override public void execute(Runnable command) {
-      calls.add((AsyncCall) command);
-    }
-
-    public void assertJobs(String... expectedUrls) {
-      List<String> actualUrls = new ArrayList<>();
-      for (AsyncCall call : calls) {
-        actualUrls.add(call.request().url().toString());
-      }
-      assertEquals(Arrays.asList(expectedUrls), actualUrls);
-    }
+  @Test public void executionRejectedAfterPrecedingCallFinishes() throws Exception {
+    Request request1 = newRequest("http://a/1");
+    Request request2 = newRequest("http://a/2");
+    dispatcher.setMaxRequests(1);
+    client.newCall(request1).enqueue(callback);
+    executor.shutdown();
+    client.newCall(request2).enqueue(callback);
+    executor.finishJob("http://a/1"); // Trigger promotion.
+    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallStart",
+        "CallFailed");
+  }
 
-    public void finishJob(String url) {
-      for (Iterator<AsyncCall> i = calls.iterator(); i.hasNext(); ) {
-        AsyncCall call = i.next();
-        if (call.request().url().toString().equals(url)) {
-          i.remove();
-          dispatcher.finished(call);
-          return;
-        }
+  private Thread makeSynchronousCall(Call call) {
+    Thread thread = new Thread(() -> {
+      try {
+        call.execute();
+        throw new AssertionError();
+      } catch (IOException expected) {
       }
-      throw new AssertionError("No such job: " + url);
-    }
-
-    @Override public void shutdown() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public List<Runnable> shutdownNow() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public boolean isShutdown() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public boolean isTerminated() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override public boolean awaitTermination(long timeout, TimeUnit unit)
-        throws InterruptedException {
-      throw new UnsupportedOperationException();
-    }
+    });
+    thread.start();
+    return thread;
   }
 
   private Request newRequest(String url) {
diff --git a/okhttp/src/test/java/okhttp3/DuplexTest.java b/okhttp/src/test/java/okhttp3/DuplexTest.java
new file mode 100644
index 0000000000..c97d2752f3
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/DuplexTest.java
@@ -0,0 +1,528 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.ProtocolException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.duplex.AsyncRequestBody;
+import okhttp3.internal.duplex.MwsDuplexAccess;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.mockwebserver.internal.duplex.MockDuplexResponseBody;
+import okhttp3.tls.HandshakeCertificates;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.junit.rules.Timeout;
+
+import static java.util.Arrays.asList;
+import static junit.framework.TestCase.assertTrue;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class DuplexTest {
+  @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+
+  private RecordingEventListener listener = new RecordingEventListener();
+  private HandshakeCertificates handshakeCertificates = localhost();
+  private OkHttpClient client = clientTestRule.client
+      .newBuilder()
+      .eventListener(listener)
+      .build();
+
+  @Test public void http1DoesntSupportDuplex() throws IOException {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
+  @Test public void trueDuplexClientWritesFirst() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders(),
+        new MockDuplexResponseBody()
+            .receiveRequest("request A\n")
+            .sendResponse("response B\n")
+            .receiveRequest("request C\n")
+            .sendResponse("response D\n")
+            .receiveRequest("request E\n")
+            .sendResponse("response F\n")
+            .exhaustRequest()
+            .exhaustResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build());
+
+    try (Response response = call.execute()) {
+      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
+      requestBody.writeUtf8("request A\n");
+      requestBody.flush();
+
+      BufferedSource responseBody = response.body().source();
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response B");
+
+      requestBody.writeUtf8("request C\n");
+      requestBody.flush();
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response D");
+
+      requestBody.writeUtf8("request E\n");
+      requestBody.flush();
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response F");
+
+      requestBody.close();
+      assertThat(responseBody.readUtf8Line()).isNull();
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+  }
+
+  @Test public void trueDuplexServerWritesFirst() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders(),
+        new MockDuplexResponseBody()
+            .sendResponse("response A\n")
+            .receiveRequest("request B\n")
+            .sendResponse("response C\n")
+            .receiveRequest("request D\n")
+            .sendResponse("response E\n")
+            .receiveRequest("request F\n")
+            .exhaustResponse()
+            .exhaustRequest());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build());
+
+    try (Response response = call.execute()) {
+      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
+      BufferedSource responseBody = response.body().source();
+
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response A");
+      requestBody.writeUtf8("request B\n");
+      requestBody.flush();
+
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response C");
+      requestBody.writeUtf8("request D\n");
+      requestBody.flush();
+
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response E");
+      requestBody.writeUtf8("request F\n");
+      requestBody.flush();
+
+      assertThat(responseBody.readUtf8Line()).isNull();
+      requestBody.close();
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+  }
+
+  @Test public void clientReadsHeadersDataTrailers() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders()
+            .addHeader("h1", "v1")
+            .addHeader("h2", "v2")
+            .setTrailers(Headers.of("trailers", "boom")),
+        new MockDuplexResponseBody()
+            .sendResponse("ok")
+            .exhaustResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    try (Response response = call.execute()) {
+      assertThat(response.headers()).isEqualTo(Headers.of("h1", "v1", "h2", "v2"));
+
+      BufferedSource responseBody = response.body().source();
+      assertThat(responseBody.readUtf8(2)).isEqualTo("ok");
+      assertTrue(responseBody.exhausted());
+      assertThat(response.trailers()).isEqualTo(Headers.of("trailers", "boom"));
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+  }
+
+  @Test public void serverReadsHeadersData() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders()
+            .addHeader("h1", "v1")
+            .addHeader("h2", "v2"),
+        new MockDuplexResponseBody()
+            .exhaustResponse()
+            .receiveRequest("hey\n")
+            .receiveRequest("whats going on\n")
+            .exhaustRequest());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method("POST", new AsyncRequestBody())
+        .build();
+    Call call = client.newCall(request);
+
+    try (Response response = call.execute()) {
+      BufferedSink sink = ((AsyncRequestBody) request.body()).takeSink();
+      sink.writeUtf8("hey\n");
+      sink.writeUtf8("whats going on\n");
+      sink.close();
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+  }
+
+  @Test public void requestBodyEndsAfterResponseBody() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders(),
+        new MockDuplexResponseBody()
+            .exhaustResponse()
+            .receiveRequest("request A\n")
+            .exhaustRequest());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build());
+
+    try (Response response = call.execute()) {
+      BufferedSource responseBody = response.body().source();
+      assertTrue(responseBody.exhausted());
+
+      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
+      requestBody.writeUtf8("request A\n");
+      requestBody.close();
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+
+    assertThat(listener.recordedEventTypes()).containsExactly(
+        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
+        "RequestHeadersStart", "RequestHeadersEnd", "RequestBodyStart", "ResponseHeadersStart",
+        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "RequestBodyEnd",
+        "ConnectionReleased", "CallEnd");
+  }
+
+  @Test public void duplexWith100Continue() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders()
+            .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE),
+        new MockDuplexResponseBody()
+            .receiveRequest("request body\n")
+            .sendResponse("response body\n")
+            .exhaustRequest());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(new AsyncRequestBody())
+        .build());
+
+    try (Response response = call.execute()) {
+      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
+      requestBody.writeUtf8("request body\n");
+      requestBody.flush();
+
+      BufferedSource responseBody = response.body().source();
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response body");
+
+      requestBody.close();
+      assertThat(responseBody.readUtf8Line()).isNull();
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+  }
+
+  /**
+   * Duplex calls that have follow-ups are weird. By the time we know there's a follow-up we've
+   * already split off another thread to stream the request body. Because we permit at most one
+   * exchange at a time we break the request stream out from under that writer.
+   */
+  @Test public void duplexWithRedirect() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    CountDownLatch duplexResponseSent = new CountDownLatch(1);
+    listener = new RecordingEventListener() {
+      @Override public void responseHeadersEnd(Call call, Response response) {
+        try {
+          // Wait for the server to send the duplex response before acting on the 301 response
+          // and resetting the stream.
+          duplexResponseSent.await();
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+        super.responseHeadersEnd(call, response);
+      }
+    };
+
+    client = client.newBuilder()
+        .eventListener(listener)
+        .build();
+
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders()
+            .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+            .addHeader("Location: /b"),
+        new MockDuplexResponseBody()
+            .sendResponse("/a has moved!\n", duplexResponseSent)
+            .requestIOException()
+            .exhaustResponse());
+    server.enqueue(new MockResponse()
+        .setBody("this is /b"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build());
+
+    try (Response response = call.execute()) {
+      BufferedSource responseBody = response.body().source();
+      assertThat(responseBody.readUtf8Line()).isEqualTo("this is /b");
+    }
+
+    BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
+    try {
+      requestBody.writeUtf8("request body\n");
+      requestBody.flush();
+      fail();
+    } catch (IOException expected) {
+      assertThat(expected.getMessage()).isEqualTo("stream was reset: CANCEL");
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+
+    assertThat(listener.recordedEventTypes()).containsExactly(
+        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
+        "RequestHeadersStart", "RequestHeadersEnd", "RequestBodyStart", "ResponseHeadersStart",
+        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd", "RequestFailed");
+  }
+
+  /**
+   * Auth requires follow-ups. Unlike redirects, the auth follow-up also has a request body. This
+   * test makes a single call with two duplex requests!
+   */
+  @Test public void duplexWithAuthChallenge() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    String credential = Credentials.basic("jesse", "secret");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential, null))
+        .build();
+
+    MockDuplexResponseBody mockResponseBody1 = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders()
+            .setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED),
+        new MockDuplexResponseBody()
+            .sendResponse("please authenticate!\n")
+            .requestIOException()
+            .exhaustResponse());
+    MockDuplexResponseBody mockResponseBody2 = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders(),
+        new MockDuplexResponseBody()
+            .sendResponse("response body\n")
+            .exhaustResponse()
+            .receiveRequest("request body\n")
+            .exhaustRequest());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build());
+
+    Response response2 = call.execute();
+
+    // First duplex request is detached with violence.
+    BufferedSink requestBody1 = ((AsyncRequestBody) call.request().body()).takeSink();
+    try {
+      requestBody1.writeUtf8("not authenticated\n");
+      requestBody1.flush();
+      fail();
+    } catch (IOException expected) {
+      assertThat(expected.getMessage()).isEqualTo("stream was reset: CANCEL");
+    }
+    mockResponseBody1.awaitSuccess();
+
+    // Second duplex request proceeds normally.
+    BufferedSink requestBody2 = ((AsyncRequestBody) call.request().body()).takeSink();
+    requestBody2.writeUtf8("request body\n");
+    requestBody2.close();
+    BufferedSource responseBody2 = response2.body().source();
+    assertThat(responseBody2.readUtf8Line()).isEqualTo("response body");
+    assertTrue(responseBody2.exhausted());
+    mockResponseBody2.awaitSuccess();
+
+    // No more requests attempted!
+    ((AsyncRequestBody) call.request().body()).assertNoMoreSinks();
+  }
+
+  @Test public void fullCallTimeoutAppliesToSetup() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e.getMessage()).isEqualTo("timeout");
+      assertTrue(call.isCanceled());
+    }
+  }
+
+  @Test public void fullCallTimeoutDoesNotApplyOnceConnected() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders(),
+        new MockDuplexResponseBody()
+            .sendResponse("response A\n")
+            .sleep(750, TimeUnit.MILLISECONDS)
+            .sendResponse("response B\n")
+            .receiveRequest("request C\n")
+            .exhaustResponse()
+            .exhaustRequest());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(500, TimeUnit.MILLISECONDS); // Long enough for the first TLS handshake.
+
+    try (Response response = call.execute()) {
+      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
+
+      BufferedSource responseBody = response.body().source();
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response A");
+      assertThat(responseBody.readUtf8Line()).isEqualTo("response B");
+
+      requestBody.writeUtf8("request C\n");
+      requestBody.close();
+      assertThat(responseBody.readUtf8Line()).isNull();
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+  }
+
+  @Test public void duplexWithRewriteInterceptors() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
+        new MockResponse()
+            .clearHeaders(),
+        new MockDuplexResponseBody()
+            .receiveRequest("REQUEST A\n")
+            .sendResponse("response B\n")
+            .exhaustRequest()
+            .exhaustResponse());
+
+    client = client.newBuilder()
+        .addInterceptor(new UppercaseRequestInterceptor())
+        .addInterceptor(new UppercaseResponseInterceptor())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new AsyncRequestBody())
+        .build());
+
+    try (Response response = call.execute()) {
+      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
+      requestBody.writeUtf8("request A\n");
+      requestBody.flush();
+
+      BufferedSource responseBody = response.body().source();
+      assertThat(responseBody.readUtf8Line()).isEqualTo("RESPONSE B");
+
+      requestBody.close();
+      assertThat(responseBody.readUtf8Line()).isNull();
+    }
+
+    mockDuplexResponseBody.awaitSuccess();
+  }
+
+  private MockDuplexResponseBody enqueueResponseWithBody(
+      MockResponse response, MockDuplexResponseBody body) {
+    MwsDuplexAccess.instance.setBody(response, body);
+    server.enqueue(response);
+    return body;
+  }
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
+   */
+  private void enableProtocol(Protocol protocol) {
+    enableTls();
+    client = client.newBuilder()
+        .protocols(asList(protocol, Protocol.HTTP_1_1))
+        .build();
+    server.setProtocols(client.protocols());
+  }
+
+  private void enableTls() {
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp/src/test/java/okhttp3/EventListenerTest.java
similarity index 58%
rename from okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
rename to okhttp/src/test/java/okhttp3/EventListenerTest.java
index c31746a57c..36b081a99b 100644
--- a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp/src/test/java/okhttp3/EventListenerTest.java
@@ -16,11 +16,11 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.net.HttpURLConnection;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
 import java.net.UnknownHostException;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
@@ -37,16 +37,18 @@
 import okhttp3.RecordingEventListener.RequestBodyEnd;
 import okhttp3.RecordingEventListener.RequestHeadersEnd;
 import okhttp3.RecordingEventListener.ResponseBodyEnd;
+import okhttp3.RecordingEventListener.ResponseFailed;
 import okhttp3.RecordingEventListener.ResponseHeadersEnd;
 import okhttp3.RecordingEventListener.SecureConnectEnd;
 import okhttp3.RecordingEventListener.SecureConnectStart;
 import okhttp3.internal.DoubleInetAddressDns;
+import okhttp3.internal.Internal;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.logging.HttpLoggingInterceptor;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import org.hamcrest.BaseMatcher;
@@ -54,44 +56,38 @@
 import org.hamcrest.Description;
 import org.hamcrest.Matcher;
 import org.junit.After;
+import org.junit.Assert;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.Timeout;
 
 import static java.util.Arrays.asList;
-import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.hamcrest.CoreMatchers.any;
-import static org.hamcrest.CoreMatchers.either;
 import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertThat;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.junit.Assume.assumeThat;
 
 public final class EventListenerTest {
   public static final Matcher<Response> anyResponse = CoreMatchers.any(Response.class);
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+  @Rule public final Timeout timeoutRule = new Timeout(20, TimeUnit.SECONDS);
 
-  private final SingleInetAddressDns singleDns = new SingleInetAddressDns();
   private final RecordingEventListener listener = new RecordingEventListener();
-  private final SslClient sslClient = SslClient.localhost();
+  private final HandshakeCertificates handshakeCertificates = localhost();
 
-  private OkHttpClient client;
+  private OkHttpClient client = clientTestRule.client;
   private SocksProxy socksProxy;
 
-  @Before public void setUp() throws IOException {
-    client = defaultClient().newBuilder()
-        .dns(singleDns)
+  @Before public void setUp() {
+    client = clientTestRule.client.newBuilder()
         .eventListener(listener)
         .build();
 
-    listener.forbidLock(client.connectionPool());
+    listener.forbidLock(Internal.instance.realConnectionPool(client.connectionPool()));
     listener.forbidLock(client.dispatcher());
   }
 
@@ -109,15 +105,14 @@
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
-    assertEquals("abc", response.body().string());
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.body().string()).isEqualTo("abc");
     response.body().close();
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
   @Test public void successfulCallEventSequenceForEnqueue() throws Exception {
@@ -134,7 +129,7 @@
         completionLatch.countDown();
       }
 
-      @Override public void onResponse(Call call, Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) {
         response.close();
         completionLatch.countDown();
       }
@@ -144,15 +139,14 @@
 
     completionLatch.await();
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
-  @Test public void failedCallEventSequence() throws IOException {
-    server.enqueue(new MockResponse().setBodyDelay(2, TimeUnit.SECONDS));
+  @Test public void failedCallEventSequence() {
+    server.enqueue(new MockResponse().setHeadersDelay(2, TimeUnit.SECONDS));
 
     client = client.newBuilder().readTimeout(250, TimeUnit.MILLISECONDS).build();
 
@@ -163,16 +157,46 @@
       call.execute();
       fail();
     } catch (IOException expected) {
-      assertThat(expected.getMessage(), either(equalTo("timeout")).or(equalTo("Read timed out")));
+      assertThat(expected.getMessage()).isIn("timeout", "Read timed out");
     }
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ConnectionReleased", "CallFailed");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseFailed", "ConnectionReleased",
+        "CallFailed");
   }
 
-  @Test public void canceledCallEventSequence() throws IOException {
+  @Test public void failedDribbledCallEventSequence() throws IOException {
+    server.enqueue(new MockResponse().setBody("0123456789")
+        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    client = client.newBuilder()
+        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
+        .readTimeout(250, TimeUnit.MILLISECONDS)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    try {
+      response.body().string();
+      fail();
+    } catch (IOException expected) {
+      assertThat(expected.getMessage()).isEqualTo("unexpected end of stream");
+    }
+
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseFailed", "ConnectionReleased", "CallFailed");
+    ResponseFailed responseFailed = listener.removeUpToEvent(ResponseFailed.class);
+    assertThat(responseFailed.ioe.getMessage()).isEqualTo("unexpected end of stream");
+  }
+
+  @Test public void canceledCallEventSequence() {
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
@@ -181,11 +205,10 @@
       call.execute();
       fail();
     } catch (IOException expected) {
-      assertEquals("Canceled", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("Canceled");
     }
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "CallFailed");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallFailed");
   }
 
   private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throws IOException {
@@ -193,23 +216,22 @@ private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throw
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().string();
     response.body().close();
 
     assumeThat(response, responseMatcher);
 
-    List<String> expectedEvents = asList("CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+    assertThat(listener.recordedEventTypes()).containsExactly(
+        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
         "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
         "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
         "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-
-    assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
   @Test public void secondCallEventSequence() throws IOException {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
     server.enqueue(new MockResponse());
     server.enqueue(new MockResponse());
 
@@ -225,11 +247,9 @@ private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throw
     Response response = call.execute();
     response.close();
 
-    List<String> expectedEvents = asList("CallStart", "ConnectionAcquired",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "ConnectionAcquired",
         "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
         "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-
-    assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
   private void assertBytesReadWritten(RecordingEventListener listener,
@@ -238,33 +258,32 @@ private void assertBytesReadWritten(RecordingEventListener listener,
 
     if (requestHeaderLength != null) {
       RequestHeadersEnd responseHeadersEnd = listener.removeUpToEvent(RequestHeadersEnd.class);
-      assertThat("request header length", responseHeadersEnd.headerLength, requestHeaderLength);
+      Assert.assertThat("request header length", responseHeadersEnd.headerLength,
+          requestHeaderLength);
     } else {
-      assertFalse("Found RequestHeadersEnd",
-          listener.recordedEventTypes().contains("RequestHeadersEnd"));
+      assertThat(listener.recordedEventTypes()).doesNotContain("RequestHeadersEnd");
     }
 
     if (requestBodyBytes != null) {
       RequestBodyEnd responseBodyEnd = listener.removeUpToEvent(RequestBodyEnd.class);
-      assertThat("request body bytes", responseBodyEnd.bytesWritten, requestBodyBytes);
+      Assert.assertThat("request body bytes", responseBodyEnd.bytesWritten, requestBodyBytes);
     } else {
-      assertFalse("Found RequestBodyEnd", listener.recordedEventTypes().contains("RequestBodyEnd"));
+      assertThat(listener.recordedEventTypes()).doesNotContain("RequestBodyEnd");
     }
 
     if (responseHeaderLength != null) {
       ResponseHeadersEnd responseHeadersEnd = listener.removeUpToEvent(ResponseHeadersEnd.class);
-      assertThat("response header length", responseHeadersEnd.headerLength, responseHeaderLength);
+      Assert.assertThat("response header length", responseHeadersEnd.headerLength,
+          responseHeaderLength);
     } else {
-      assertFalse("Found ResponseHeadersEnd",
-          listener.recordedEventTypes().contains("ResponseHeadersEnd"));
+      assertThat(listener.recordedEventTypes()).doesNotContain("ResponseHeadersEnd");
     }
 
     if (responseBodyBytes != null) {
       ResponseBodyEnd responseBodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);
-      assertThat("response body bytes", responseBodyEnd.bytesRead, responseBodyBytes);
+      Assert.assertThat("response body bytes", responseBodyEnd.bytesRead, responseBodyBytes);
     } else {
-      assertFalse("Found ResponseBodyEnd",
-          listener.recordedEventTypes().contains("ResponseBodyEnd"));
+      assertThat(listener.recordedEventTypes()).doesNotContain("ResponseBodyEnd");
     }
   }
 
@@ -275,7 +294,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
       }
 
       @Override public boolean matches(Object o) {
-        return ((Long)o) > value;
+        return ((Long) o) > value;
       }
     };
   }
@@ -287,7 +306,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
       }
 
       @Override public boolean matches(Object o) {
-        return ((Long)o) < value;
+        return ((Long) o) < value;
       }
     };
   }
@@ -299,14 +318,14 @@ private void assertBytesReadWritten(RecordingEventListener listener,
       }
 
       @Override public boolean matches(Object o) {
-        return ((Response)o).protocol == protocol;
+        return ((Response) o).protocol() == protocol;
       }
     };
   }
 
   @Test public void successfulEmptyH2CallEventSequence() throws IOException {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
     server.enqueue(new MockResponse());
 
     assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));
@@ -317,7 +336,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
 
   @Test public void successfulEmptyHttpsCallEventSequence() throws IOException {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    server.setProtocols(asList(Protocol.HTTP_1_1));
     server.enqueue(new MockResponse()
         .setBody("abc"));
 
@@ -329,7 +348,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
 
   @Test public void successfulChunkedHttpsCallEventSequence() throws IOException {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    server.setProtocols(asList(Protocol.HTTP_1_1));
     server.enqueue(
         new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
 
@@ -341,7 +360,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
 
   @Test public void successfulChunkedH2CallEventSequence() throws IOException {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
     server.enqueue(
         new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
 
@@ -358,17 +377,17 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     DnsStart dnsStart = listener.removeUpToEvent(DnsStart.class);
-    assertSame(call, dnsStart.call);
-    assertEquals(server.getHostName(), dnsStart.domainName);
+    assertThat(dnsStart.call).isSameAs(call);
+    assertThat(dnsStart.domainName).isEqualTo(server.getHostName());
 
     DnsEnd dnsEnd = listener.removeUpToEvent(DnsEnd.class);
-    assertSame(call, dnsEnd.call);
-    assertEquals(server.getHostName(), dnsEnd.domainName);
-    assertEquals(1, dnsEnd.inetAddressList.size());
+    assertThat(dnsEnd.call).isSameAs(call);
+    assertThat(dnsEnd.domainName).isEqualTo(server.getHostName());
+    assertThat(dnsEnd.inetAddressList.size()).isEqualTo(1);
   }
 
   @Test public void noDnsLookupOnPooledConnection() throws IOException {
@@ -380,7 +399,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response1 = call1.execute();
-    assertEquals(200, response1.code());
+    assertThat(response1.code()).isEqualTo(200);
     response1.body().close();
 
     listener.clearAllEvents();
@@ -389,12 +408,12 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals(200, response2.code());
+    assertThat(response2.code()).isEqualTo(200);
     response2.body().close();
 
     List<String> recordedEvents = listener.recordedEventTypes();
-    assertFalse(recordedEvents.contains("DnsStart"));
-    assertFalse(recordedEvents.contains("DnsEnd"));
+    assertThat(recordedEvents).doesNotContain("DnsStart");
+    assertThat(recordedEvents).doesNotContain("DnsEnd");
   }
 
   @Test public void multipleDnsLookupsForSingleCall() throws IOException {
@@ -404,8 +423,8 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     server.enqueue(new MockResponse());
 
     FakeDns dns = new FakeDns();
-    dns.set("fakeurl", singleDns.lookup(server.getHostName()));
-    dns.set("www.fakeurl", singleDns.lookup(server.getHostName()));
+    dns.set("fakeurl", client.dns().lookup(server.getHostName()));
+    dns.set("www.fakeurl", client.dns().lookup(server.getHostName()));
 
     client = client.newBuilder()
         .dns(dns)
@@ -415,7 +434,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url("http://fakeurl:" + server.getPort())
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     listener.removeUpToEvent(DnsStart.class);
@@ -440,16 +459,12 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     listener.removeUpToEvent(DnsStart.class);
 
     CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    assertSame(call, callFailed.call);
-    assertTrue(callFailed.ioe instanceof UnknownHostException);
+    assertThat(callFailed.call).isSameAs(call);
+    assertThat(callFailed.ioe).isInstanceOf(UnknownHostException.class);
   }
 
   @Test public void emptyDnsLookup() {
-    Dns emptyDns = new Dns() {
-      @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-        return Collections.emptyList();
-      }
-    };
+    Dns emptyDns = hostname -> Collections.emptyList();
 
     client = client.newBuilder()
         .dns(emptyDns)
@@ -466,8 +481,8 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     listener.removeUpToEvent(DnsStart.class);
 
     CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    assertSame(call, callFailed.call);
-    assertTrue(callFailed.ioe instanceof UnknownHostException);
+    assertThat(callFailed.call).isSameAs(call);
+    assertThat(callFailed.ioe).isInstanceOf(UnknownHostException.class);
   }
 
   @Test public void successfulConnect() throws IOException {
@@ -477,21 +492,21 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
-    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
     InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
 
     ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
-    assertSame(call, connectStart.call);
-    assertEquals(expectedAddress, connectStart.inetSocketAddress);
-    assertEquals(Proxy.NO_PROXY, connectStart.proxy);
+    assertThat(connectStart.call).isSameAs(call);
+    assertThat(connectStart.inetSocketAddress).isEqualTo(expectedAddress);
+    assertThat(connectStart.proxy).isEqualTo(Proxy.NO_PROXY);
 
     ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
-    assertSame(call, connectEnd.call);
-    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
-    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+    assertThat(connectEnd.call).isSameAs(call);
+    assertThat(connectEnd.inetSocketAddress).isEqualTo(expectedAddress);
+    assertThat(connectEnd.protocol).isEqualTo(Protocol.HTTP_1_1);
   }
 
   @Test public void failedConnect() throws UnknownHostException {
@@ -508,19 +523,19 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     } catch (IOException expected) {
     }
 
-    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
     InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
 
     ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
-    assertSame(call, connectStart.call);
-    assertEquals(expectedAddress, connectStart.inetSocketAddress);
-    assertEquals(Proxy.NO_PROXY, connectStart.proxy);
+    assertThat(connectStart.call).isSameAs(call);
+    assertThat(connectStart.inetSocketAddress).isEqualTo(expectedAddress);
+    assertThat(connectStart.proxy).isEqualTo(Proxy.NO_PROXY);
 
     ConnectFailed connectFailed = listener.removeUpToEvent(ConnectFailed.class);
-    assertSame(call, connectFailed.call);
-    assertEquals(expectedAddress, connectFailed.inetSocketAddress);
-    assertNull(connectFailed.protocol);
-    assertNotNull(connectFailed.ioe);
+    assertThat(connectFailed.call).isSameAs(call);
+    assertThat(connectFailed.inetSocketAddress).isEqualTo(expectedAddress);
+    assertThat(connectFailed.protocol).isNull();
+    assertThat(connectFailed.ioe).isNotNull();
   }
 
   @Test public void multipleConnectsForSingleCall() throws IOException {
@@ -537,7 +552,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     listener.removeUpToEvent(ConnectStart.class);
@@ -557,21 +572,21 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url("http://www.fakeurl")
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
-    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
     InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
 
     ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
-    assertSame(call, connectStart.call);
-    assertEquals(expectedAddress, connectStart.inetSocketAddress);
-    assertEquals(server.toProxyAddress(), connectStart.proxy);
+    assertThat(connectStart.call).isSameAs(call);
+    assertThat(connectStart.inetSocketAddress).isEqualTo(expectedAddress);
+    assertThat(connectStart.proxy).isEqualTo(server.toProxyAddress());
 
     ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
-    assertSame(call, connectEnd.call);
-    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
-    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+    assertThat(connectEnd.call).isSameAs(call);
+    assertThat(connectEnd.inetSocketAddress).isEqualTo(expectedAddress);
+    assertThat(connectEnd.protocol).isEqualTo(Protocol.HTTP_1_1);
   }
 
   @Test public void successfulSocksProxyConnect() throws Exception {
@@ -589,21 +604,21 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url("http://" + SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS + ":" + server.getPort())
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     InetSocketAddress expectedAddress = InetSocketAddress.createUnresolved(
         SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS, server.getPort());
 
     ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
-    assertSame(call, connectStart.call);
-    assertEquals(expectedAddress, connectStart.inetSocketAddress);
-    assertEquals(proxy, connectStart.proxy);
+    assertThat(connectStart.call).isSameAs(call);
+    assertThat(connectStart.inetSocketAddress).isEqualTo(expectedAddress);
+    assertThat(connectStart.proxy).isEqualTo(proxy);
 
     ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
-    assertSame(call, connectEnd.call);
-    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
-    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+    assertThat(connectEnd.call).isSameAs(call);
+    assertThat(connectEnd.inetSocketAddress).isEqualTo(expectedAddress);
+    assertThat(connectEnd.protocol).isEqualTo(Protocol.HTTP_1_1);
   }
 
   @Test public void authenticatingTunnelProxyConnect() throws IOException {
@@ -618,20 +633,20 @@ private void assertBytesReadWritten(RecordingEventListener listener,
 
     client = client.newBuilder()
         .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
         .build();
 
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     listener.removeUpToEvent(ConnectStart.class);
 
     ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
-    assertNull(connectEnd.protocol);
+    assertThat(connectEnd.protocol).isNull();
 
     listener.removeUpToEvent(ConnectStart.class);
     listener.removeUpToEvent(ConnectEnd.class);
@@ -645,15 +660,15 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
-    assertSame(call, secureStart.call);
+    assertThat(secureStart.call).isSameAs(call);
 
     SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
-    assertSame(call, secureEnd.call);
-    assertNotNull(secureEnd.handshake);
+    assertThat(secureEnd.call).isSameAs(call);
+    assertThat(secureEnd.handshake).isNotNull();
   }
 
   @Test public void failedSecureConnect() {
@@ -671,11 +686,11 @@ private void assertBytesReadWritten(RecordingEventListener listener,
     }
 
     SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
-    assertSame(call, secureStart.call);
+    assertThat(secureStart.call).isSameAs(call);
 
     CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    assertSame(call, callFailed.call);
-    assertNotNull(callFailed.ioe);
+    assertThat(callFailed.call).isSameAs(call);
+    assertThat(callFailed.ioe).isNotNull();
   }
 
   @Test public void secureConnectWithTunnel() throws IOException {
@@ -692,15 +707,15 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
-    assertSame(call, secureStart.call);
+    assertThat(secureStart.call).isSameAs(call);
 
     SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
-    assertSame(call, secureEnd.call);
-    assertNotNull(secureEnd.handshake);
+    assertThat(secureEnd.call).isSameAs(call);
+    assertThat(secureEnd.handshake).isNotNull();
   }
 
   @Test public void multipleSecureConnectsForSingleCall() throws IOException {
@@ -717,7 +732,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     listener.removeUpToEvent(SecureConnectStart.class);
@@ -741,7 +756,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response1 = call1.execute();
-    assertEquals(200, response1.code());
+    assertThat(response1.code()).isEqualTo(200);
     response1.body().close();
 
     listener.clearAllEvents();
@@ -750,12 +765,12 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals(200, response2.code());
+    assertThat(response2.code()).isEqualTo(200);
     response2.body().close();
 
     List<String> recordedEvents = listener.recordedEventTypes();
-    assertFalse(recordedEvents.contains("SecureConnectStart"));
-    assertFalse(recordedEvents.contains("SecureConnectEnd"));
+    assertThat(recordedEvents).doesNotContain("SecureConnectStart");
+    assertThat(recordedEvents).doesNotContain("SecureConnectEnd");
   }
 
   @Test public void successfulConnectionFound() throws IOException {
@@ -765,12 +780,12 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals(200, response.code());
+    assertThat(response.code()).isEqualTo(200);
     response.body().close();
 
     ConnectionAcquired connectionAcquired = listener.removeUpToEvent(ConnectionAcquired.class);
-    assertSame(call, connectionAcquired.call);
-    assertNotNull(connectionAcquired.connection);
+    assertThat(connectionAcquired.call).isSameAs(call);
+    assertThat(connectionAcquired.connection).isNotNull();
   }
 
   @Test public void noConnectionFoundOnFollowUp() throws IOException {
@@ -784,12 +799,12 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("ABC", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABC");
 
     listener.removeUpToEvent(ConnectionAcquired.class);
 
     List<String> remainingEvents = listener.recordedEventTypes();
-    assertFalse(remainingEvents.contains("ConnectionAcquired"));
+    assertThat(remainingEvents).doesNotContain("ConnectionAcquired");
   }
 
   @Test public void pooledConnectionFound() throws IOException {
@@ -801,7 +816,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response1 = call1.execute();
-    assertEquals(200, response1.code());
+    assertThat(response1.code()).isEqualTo(200);
     response1.body().close();
 
     ConnectionAcquired connectionAcquired1 = listener.removeUpToEvent(ConnectionAcquired.class);
@@ -811,11 +826,12 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals(200, response2.code());
+    assertThat(response2.code()).isEqualTo(200);
     response2.body().close();
 
     ConnectionAcquired connectionAcquired2 = listener.removeUpToEvent(ConnectionAcquired.class);
-    assertSame(connectionAcquired1.connection, connectionAcquired2.connection);
+    assertThat(connectionAcquired2.connection).isSameAs(
+        connectionAcquired1.connection);
   }
 
   @Test public void multipleConnectionsFoundForSingleCall() throws IOException {
@@ -830,7 +846,7 @@ private void assertBytesReadWritten(RecordingEventListener listener,
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("ABC", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABC");
 
     listener.removeUpToEvent(ConnectionAcquired.class);
     listener.removeUpToEvent(ConnectionAcquired.class);
@@ -838,13 +854,13 @@ private void assertBytesReadWritten(RecordingEventListener listener,
 
   @Test public void responseBodyFailHttp1OverHttps() throws IOException {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    server.setProtocols(asList(Protocol.HTTP_1_1));
     responseBodyFail(Protocol.HTTP_1_1);
   }
 
   @Test public void responseBodyFailHttp2OverHttps() throws IOException {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
     responseBodyFail(Protocol.HTTP_2);
   }
 
@@ -867,18 +883,17 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
       // soft failure since client may not support depending on Platform
       assumeThat(response, matchesProtocol(Protocol.HTTP_2));
     }
-    assertEquals(expectedProtocol, response.protocol());
+    assertThat(response.protocol()).isEqualTo(expectedProtocol);
     try {
-      response.body.string();
+      response.body().string();
       fail();
     } catch (IOException expected) {
     }
 
     CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    assertNotNull(callFailed.ioe);
+    assertThat(callFailed.ioe).isNotNull();
   }
 
-  @Ignore("the CallEnd event is omitted")
   @Test public void emptyResponseBody() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("")
@@ -891,14 +906,29 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
     Response response = call.execute();
     response.body().close();
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+  }
+
+  @Test public void emptyResponseBodyConnectionClose() throws IOException {
+    server.enqueue(new MockResponse()
+        .addHeader("Connection", "close")
+        .setBody(""));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    response.body().close();
+
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
-  @Ignore("this reports CallFailed not CallEnd")
   @Test public void responseBodyClosedClosedWithoutReadingAllData() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("abc")
@@ -911,44 +941,108 @@ private void responseBodyFail(Protocol expectedProtocol) throws IOException {
     Response response = call.execute();
     response.body().close();
 
-    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
         "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
         "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
         "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-    assertEquals(expectedEvents, listener.recordedEventTypes());
   }
 
-  @Test public void requestBodyFailHttp1OverHttps() throws IOException {
+  @Test public void requestBodyFailHttp1OverHttps() {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
-    requestBodyFail();
+    server.setProtocols(asList(Protocol.HTTP_1_1));
+
+    requestBodyFail(Protocol.HTTP_1_1);
   }
 
-  @Test public void requestBodyFailHttp2OverHttps() throws IOException {
+  @Test public void requestBodyFailHttp2OverHttps() {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    requestBodyFail();
+    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+
+    requestBodyFail(Protocol.HTTP_2);
+  }
+
+  @Test public void requestBodyFailHttp() {
+    requestBodyFail(null);
   }
 
-  @Test public void requestBodyFailHttp() throws IOException {
-    requestBodyFail();
+  private void requestBodyFail(@Nullable Protocol expectedProtocol) {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
+
+    NonCompletingRequestBody request = new NonCompletingRequestBody();
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(request)
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    if (expectedProtocol != null) {
+      ConnectionAcquired connectionAcquired = listener.removeUpToEvent(ConnectionAcquired.class);
+      assertThat(connectionAcquired.connection.protocol()).isEqualTo(expectedProtocol);
+    }
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertThat(callFailed.ioe).isNotNull();
+
+    assertThat(request.ioe).isNotNull();
+  }
+
+  private class NonCompletingRequestBody extends RequestBody {
+    IOException ioe;
+
+    @Override public MediaType contentType() {
+      return MediaType.get("text/plain");
+    }
+
+    @Override public long contentLength() {
+      return 1024 * 1024 * 4;
+    }
+
+    @Override public void writeTo(BufferedSink sink) throws IOException {
+      try {
+        writeChunk(sink);
+        writeChunk(sink);
+        writeChunk(sink);
+        writeChunk(sink);
+        Thread.sleep(1000);
+        writeChunk(sink);
+        writeChunk(sink);
+      } catch (IOException e) {
+        ioe = e;
+      } catch (InterruptedException e) {
+      }
+    }
+
+    private void writeChunk(BufferedSink sink) throws IOException {
+      sink.write(new byte[1024 * 512]);
+      sink.flush();
+    }
   }
 
-  private void requestBodyFail() throws IOException {
-    // Stream a 8 MiB body so the disconnect will happen before the server has read everything.
+  @Test public void requestBodyMultipleFailuresReportedOnlyOnce() {
     RequestBody requestBody = new RequestBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain");
+        return MediaType.get("text/plain");
       }
 
-      @Override public long contentLength() throws IOException {
-        return 1024 * 8192;
+      @Override public long contentLength() {
+        return 1024 * 1024 * 256;
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
+        int failureCount = 0;
         for (int i = 0; i < 1024; i++) {
-          sink.write(new byte[8192]);
-          sink.flush();
+          try {
+            sink.write(new byte[1024 * 256]);
+            sink.flush();
+          } catch (IOException e) {
+            failureCount++;
+            if (failureCount == 3) throw e;
+          }
         }
       }
     };
@@ -966,33 +1060,35 @@ private void requestBodyFail() throws IOException {
     } catch (IOException expected) {
     }
 
-    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    assertNotNull(callFailed.ioe);
+    assertThat(listener.recordedEventTypes()).containsExactly(
+        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
+        "RequestBodyStart", "RequestFailed", "ConnectionReleased", "CallFailed");
   }
 
   @Test public void requestBodySuccessHttp1OverHttps() throws IOException {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
-    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), "Hello"), equalTo(5L),
+    server.setProtocols(asList(Protocol.HTTP_1_1));
+    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
         equalTo(19L));
   }
 
   @Test public void requestBodySuccessHttp2OverHttps() throws IOException {
     enableTlsWithTunnel(false);
-    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), "Hello"), equalTo(5L),
+    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
         equalTo(19L));
   }
 
   @Test public void requestBodySuccessHttp() throws IOException {
-    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), "Hello"), equalTo(5L),
+    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
         equalTo(19L));
   }
 
   @Test public void requestBodySuccessStreaming() throws IOException {
     RequestBody requestBody = new RequestBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain");
+        return MediaType.get("text/plain");
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
@@ -1005,10 +1101,31 @@ private void requestBodyFail() throws IOException {
   }
 
   @Test public void requestBodySuccessEmpty() throws IOException {
-    requestBodySuccess(RequestBody.create(MediaType.parse("text/plain"), ""), equalTo(0L),
+    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), ""), equalTo(0L),
         equalTo(19L));
   }
 
+  @Test public void successfulCallEventSequenceWithListener() throws IOException {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    client = client.newBuilder()
+        .addNetworkInterceptor(new HttpLoggingInterceptor()
+            .setLevel(HttpLoggingInterceptor.Level.BODY))
+        .build();
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.body().string()).isEqualTo("abc");
+    response.body().close();
+
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+  }
+
   private void requestBodySuccess(RequestBody body, Matcher<Long> requestBodyBytes,
       Matcher<Long> responseHeaderLength) throws IOException {
     server.enqueue(new MockResponse().setResponseCode(200).setBody("World!"));
@@ -1018,7 +1135,7 @@ private void requestBodySuccess(RequestBody body, Matcher<Long> requestBodyBytes
         .post(body)
         .build());
     Response response = call.execute();
-    assertEquals("World!", response.body().string());
+    assertThat(response.body().string()).isEqualTo("World!");
 
     assertBytesReadWritten(listener, any(Long.class), requestBodyBytes, responseHeaderLength,
         equalTo(6L));
@@ -1026,9 +1143,116 @@ private void requestBodySuccess(RequestBody body, Matcher<Long> requestBodyBytes
 
   private void enableTlsWithTunnel(boolean tunnelProxy) {
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
-    server.useHttps(sslClient.socketFactory, tunnelProxy);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), tunnelProxy);
+  }
+
+  @Test public void redirectUsingSameConnectionEventSequence() throws IOException {
+    server.enqueue(
+        new MockResponse()
+            .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+            .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    call.execute();
+
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
+        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
+        "CallEnd");
+  }
+
+  @Test
+  public void redirectUsingNewConnectionEventSequence() throws IOException {
+    MockWebServer otherServer = new MockWebServer();
+    server.enqueue(
+        new MockResponse()
+            .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+            .addHeader("Location: " + otherServer.url("/foo")));
+    otherServer.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    call.execute();
+
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "DnsStart", "DnsEnd", "ConnectStart", "ConnectEnd",
+        "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
+        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
+        "CallEnd");
+  }
+
+  @Test public void applicationInterceptorProceedsMultipleTimes() throws Exception {
+    server.enqueue(new MockResponse().setBody("a"));
+    server.enqueue(new MockResponse().setBody("b"));
+
+    client = client.newBuilder()
+        .addInterceptor(chain -> {
+          try (Response a = chain.proceed(chain.request())) {
+            assertThat(a.body().string()).isEqualTo("a");
+          }
+          return chain.proceed(chain.request());
+        })
+        .build();
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertThat(response.body().string()).isEqualTo("b");
+
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
+        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
+        "CallEnd");
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+  }
+
+  @Test public void applicationInterceptorShortCircuit() throws Exception {
+    client = client.newBuilder()
+        .addInterceptor(chain -> new Response.Builder()
+            .request(chain.request())
+            .protocol(Protocol.HTTP_1_1)
+            .code(200)
+            .message("OK")
+            .body(ResponseBody.create(null, "a"))
+            .build())
+        .build();
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+    Response response = call.execute();
+    assertThat(response.body().string()).isEqualTo("a");
+
+    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallEnd");
+  }
+
+  /** Response headers start, then the entire request body, then response headers end. */
+  @Test public void expectContinueStartsResponseHeadersEarly() throws Exception {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.execute();
+
+    assertThat(listener.recordedEventTypes()).containsExactly(
+        "CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
+        "ResponseHeadersStart", "RequestBodyStart", "RequestBodyEnd", "ResponseHeadersEnd",
+        "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java b/okhttp/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
rename to okhttp/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
diff --git a/okhttp/src/test/java/okhttp3/FormBodyTest.java b/okhttp/src/test/java/okhttp3/FormBodyTest.java
new file mode 100644
index 0000000000..e352298f0e
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/FormBodyTest.java
@@ -0,0 +1,218 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import okio.Buffer;
+import org.junit.Test;
+import java.nio.charset.Charset;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class FormBodyTest {
+  @Test public void urlEncoding() throws Exception {
+    FormBody body = new FormBody.Builder()
+        .add("a+=& b", "c+=& d")
+        .add("space, the", "final frontier")
+        .add("%25", "%25")
+        .build();
+
+    assertThat(body.size()).isEqualTo(3);
+
+    assertThat(body.encodedName(0)).isEqualTo("a%2B%3D%26%20b");
+    assertThat(body.encodedName(1)).isEqualTo("space%2C%20the");
+    assertThat(body.encodedName(2)).isEqualTo("%2525");
+
+    assertThat(body.name(0)).isEqualTo("a+=& b");
+    assertThat(body.name(1)).isEqualTo("space, the");
+    assertThat(body.name(2)).isEqualTo("%25");
+
+    assertThat(body.encodedValue(0)).isEqualTo("c%2B%3D%26%20d");
+    assertThat(body.encodedValue(1)).isEqualTo("final%20frontier");
+    assertThat(body.encodedValue(2)).isEqualTo("%2525");
+
+    assertThat(body.value(0)).isEqualTo("c+=& d");
+    assertThat(body.value(1)).isEqualTo("final frontier");
+    assertThat(body.value(2)).isEqualTo("%25");
+
+    assertThat(body.contentType().toString()).isEqualTo(
+        "application/x-www-form-urlencoded");
+
+    String expected = "a%2B%3D%26%20b=c%2B%3D%26%20d&space%2C%20the=final%20frontier&%2525=%2525";
+    assertThat(body.contentLength()).isEqualTo(expected.length());
+
+    Buffer out = new Buffer();
+    body.writeTo(out);
+    assertThat(out.readUtf8()).isEqualTo(expected);
+  }
+
+  @Test public void addEncoded() throws Exception {
+    FormBody body = new FormBody.Builder()
+        .addEncoded("a+=& b", "c+=& d")
+        .addEncoded("e+=& f", "g+=& h")
+        .addEncoded("%25", "%25")
+        .build();
+
+    String expected = "a+%3D%26%20b=c+%3D%26%20d&e+%3D%26%20f=g+%3D%26%20h&%25=%25";
+    Buffer out = new Buffer();
+    body.writeTo(out);
+    assertThat(out.readUtf8()).isEqualTo(expected);
+  }
+
+  @Test public void encodedPair() throws Exception {
+    FormBody body = new FormBody.Builder()
+        .add("sim", "ple")
+        .build();
+
+    String expected = "sim=ple";
+    assertThat(body.contentLength()).isEqualTo(expected.length());
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
+  }
+
+  @Test public void encodeMultiplePairs() throws Exception {
+    FormBody body = new FormBody.Builder()
+        .add("sim", "ple")
+        .add("hey", "there")
+        .add("help", "me")
+        .build();
+
+    String expected = "sim=ple&hey=there&help=me";
+    assertThat(body.contentLength()).isEqualTo(expected.length());
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
+  }
+
+  @Test public void buildEmptyForm() throws Exception {
+    FormBody body = new FormBody.Builder().build();
+
+    String expected = "";
+    assertThat(body.contentLength()).isEqualTo(expected.length());
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
+  }
+
+  @Test public void characterEncoding() throws Exception {
+    // Browsers convert '\u0000' to '%EF%BF%BD'.
+    assertThat(formEncode(0)).isEqualTo("%00");
+    assertThat(formEncode(1)).isEqualTo("%01");
+    assertThat(formEncode(2)).isEqualTo("%02");
+    assertThat(formEncode(3)).isEqualTo("%03");
+    assertThat(formEncode(4)).isEqualTo("%04");
+    assertThat(formEncode(5)).isEqualTo("%05");
+    assertThat(formEncode(6)).isEqualTo("%06");
+    assertThat(formEncode(7)).isEqualTo("%07");
+    assertThat(formEncode(8)).isEqualTo("%08");
+    assertThat(formEncode(9)).isEqualTo("%09");
+    // Browsers convert '\n' to '\r\n'
+    assertThat(formEncode(10)).isEqualTo("%0A");
+    assertThat(formEncode(11)).isEqualTo("%0B");
+    assertThat(formEncode(12)).isEqualTo("%0C");
+    // Browsers convert '\r' to '\r\n'
+    assertThat(formEncode(13)).isEqualTo("%0D");
+    assertThat(formEncode(14)).isEqualTo("%0E");
+    assertThat(formEncode(15)).isEqualTo("%0F");
+    assertThat(formEncode(16)).isEqualTo("%10");
+    assertThat(formEncode(17)).isEqualTo("%11");
+    assertThat(formEncode(18)).isEqualTo("%12");
+    assertThat(formEncode(19)).isEqualTo("%13");
+    assertThat(formEncode(20)).isEqualTo("%14");
+    assertThat(formEncode(21)).isEqualTo("%15");
+    assertThat(formEncode(22)).isEqualTo("%16");
+    assertThat(formEncode(23)).isEqualTo("%17");
+    assertThat(formEncode(24)).isEqualTo("%18");
+    assertThat(formEncode(25)).isEqualTo("%19");
+    assertThat(formEncode(26)).isEqualTo("%1A");
+    assertThat(formEncode(27)).isEqualTo("%1B");
+    assertThat(formEncode(28)).isEqualTo("%1C");
+    assertThat(formEncode(29)).isEqualTo("%1D");
+    assertThat(formEncode(30)).isEqualTo("%1E");
+    assertThat(formEncode(31)).isEqualTo("%1F");
+    // Browsers use '+' for space.
+    assertThat(formEncode(32)).isEqualTo("%20");
+    assertThat(formEncode(33)).isEqualTo("%21");
+    assertThat(formEncode(34)).isEqualTo("%22");
+    assertThat(formEncode(35)).isEqualTo("%23");
+    assertThat(formEncode(36)).isEqualTo("%24");
+    assertThat(formEncode(37)).isEqualTo("%25");
+    assertThat(formEncode(38)).isEqualTo("%26");
+    assertThat(formEncode(39)).isEqualTo("%27");
+    assertThat(formEncode(40)).isEqualTo("%28");
+    assertThat(formEncode(41)).isEqualTo("%29");
+    assertThat(formEncode(42)).isEqualTo("*");
+    assertThat(formEncode(43)).isEqualTo("%2B");
+    assertThat(formEncode(44)).isEqualTo("%2C");
+    assertThat(formEncode(45)).isEqualTo("-");
+    assertThat(formEncode(46)).isEqualTo(".");
+    assertThat(formEncode(47)).isEqualTo("%2F");
+    assertThat(formEncode(48)).isEqualTo("0");
+    assertThat(formEncode(57)).isEqualTo("9");
+    assertThat(formEncode(58)).isEqualTo("%3A");
+    assertThat(formEncode(59)).isEqualTo("%3B");
+    assertThat(formEncode(60)).isEqualTo("%3C");
+    assertThat(formEncode(61)).isEqualTo("%3D");
+    assertThat(formEncode(62)).isEqualTo("%3E");
+    assertThat(formEncode(63)).isEqualTo("%3F");
+    assertThat(formEncode(64)).isEqualTo("%40");
+    assertThat(formEncode(65)).isEqualTo("A");
+    assertThat(formEncode(90)).isEqualTo("Z");
+    assertThat(formEncode(91)).isEqualTo("%5B");
+    assertThat(formEncode(92)).isEqualTo("%5C");
+    assertThat(formEncode(93)).isEqualTo("%5D");
+    assertThat(formEncode(94)).isEqualTo("%5E");
+    assertThat(formEncode(95)).isEqualTo("_");
+    assertThat(formEncode(96)).isEqualTo("%60");
+    assertThat(formEncode(97)).isEqualTo("a");
+    assertThat(formEncode(122)).isEqualTo("z");
+    assertThat(formEncode(123)).isEqualTo("%7B");
+    assertThat(formEncode(124)).isEqualTo("%7C");
+    assertThat(formEncode(125)).isEqualTo("%7D");
+    assertThat(formEncode(126)).isEqualTo("%7E");
+    assertThat(formEncode(127)).isEqualTo("%7F");
+    assertThat(formEncode(128)).isEqualTo("%C2%80");
+    assertThat(formEncode(255)).isEqualTo("%C3%BF");
+  }
+
+  private String formEncode(int codePoint) throws IOException {
+    // Wrap the codepoint with regular printable characters to prevent trimming.
+    FormBody body = new FormBody.Builder()
+        .add("a", new String(new int[] {'b', codePoint, 'c'}, 0, 3))
+        .build();
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    buffer.skip(3); // Skip "a=b" prefix.
+    return buffer.readUtf8(buffer.size() - 1); // Skip the "c" suffix.
+  }
+
+  @Test public void manualCharset() throws Exception {
+    FormBody body = new FormBody.Builder(Charset.forName("ISO-8859-1"))
+        .add("name", "Nicol√°s")
+        .build();
+
+    String expected = "name=Nicol%E1s";
+    assertThat(body.contentLength()).isEqualTo(expected.length());
+
+    Buffer out = new Buffer();
+    body.writeTo(out);
+    assertThat(out.readUtf8()).isEqualTo(expected);
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/HeadersTest.java b/okhttp/src/test/java/okhttp3/HeadersTest.java
new file mode 100644
index 0000000000..fb244c31be
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/HeadersTest.java
@@ -0,0 +1,900 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.time.Instant;
+import java.util.Collections;
+import java.util.Date;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.http2.Header;
+import okhttp3.internal.http2.Http2ExchangeCodec;
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static java.util.Collections.emptyList;
+import static java.util.Collections.emptyMap;
+import static java.util.Collections.singletonList;
+import static java.util.Collections.singletonMap;
+import static okhttp3.TestUtil.headerEntries;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class HeadersTest {
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
+  @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
+    Headers headerBlock = Headers.of(
+        ":status", "200 OK",
+        ":version", "HTTP/1.1",
+        "connection", "close");
+    Request request = new Request.Builder().url("http://square.com/").build();
+    Response response = Http2ExchangeCodec.readHttp2HeadersList(headerBlock, Protocol.HTTP_2).request(request).build();
+    Headers headers = response.headers();
+    assertThat(headers.size()).isEqualTo(1);
+    assertThat(headers.name(0)).isEqualTo(":version");
+    assertThat(headers.value(0)).isEqualTo("HTTP/1.1");
+  }
+
+  @Test public void http2HeadersListDropsForbiddenHeadersHttp2() {
+    Request request = new Request.Builder()
+        .url("http://square.com/")
+        .header("Connection", "upgrade")
+        .header("Upgrade", "websocket")
+        .header("Host", "square.com")
+        .header("TE", "gzip")
+        .build();
+    List<Header> expected = headerEntries(
+        ":method", "GET",
+        ":path", "/",
+        ":authority", "square.com",
+        ":scheme", "http");
+    assertThat(Http2ExchangeCodec.http2HeadersList(request)).isEqualTo(expected);
+  }
+
+  @Test public void http2HeadersListDontDropTeIfTrailersHttp2() {
+    Request request = new Request.Builder()
+        .url("http://square.com/")
+        .header("TE", "trailers")
+        .build();
+    List<Header> expected = headerEntries(
+        ":method", "GET",
+        ":path", "/",
+        ":scheme", "http",
+        "te", "trailers");
+    assertThat(Http2ExchangeCodec.http2HeadersList(request)).isEqualTo(expected);
+  }
+
+  @Test public void ofTrims() {
+    Headers headers = Headers.of("\t User-Agent \n", " \r OkHttp ");
+    assertThat(headers.name(0)).isEqualTo("User-Agent");
+    assertThat(headers.value(0)).isEqualTo("OkHttp");
+  }
+
+  @Test public void addParsing() {
+    Headers headers = new Headers.Builder()
+        .add("foo: bar")
+        .add(" foo: baz") // Name leading whitespace is trimmed.
+        .add("foo : bak") // Name trailing whitespace is trimmed.
+        .add("\tkey\t:\tvalue\t") // '\t' also counts as whitespace
+        .add("ping:  pong  ") // Value whitespace is trimmed.
+        .add("kit:kat") // Space after colon is not required.
+        .build();
+    assertThat(headers.values("foo")).containsExactly("bar", "baz", "bak");
+    assertThat(headers.values("key")).containsExactly("value");
+    assertThat(headers.values("ping")).containsExactly("pong");
+    assertThat(headers.values("kit")).containsExactly("kat");
+  }
+
+  @Test public void addThrowsOnEmptyName() {
+    try {
+      new Headers.Builder().add(": bar");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Headers.Builder().add(" : bar");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void addThrowsOnNoColon() {
+    try {
+      new Headers.Builder().add("foo bar");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void addThrowsOnMultiColon() {
+    try {
+      new Headers.Builder().add(":status: 200 OK");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void addUnsafeNonAsciiRejectsUnicodeName() {
+    try {
+      Headers headers = new Headers.Builder()
+          .addUnsafeNonAscii("h√©ader1", "value1")
+          .build();
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0xe9 at 1 in header name: h√©ader1");
+    }
+  }
+
+  @Test public void addUnsafeNonAsciiAcceptsUnicodeValue() {
+    Headers headers = new Headers.Builder()
+        .addUnsafeNonAscii("header1", "valu√©1")
+        .build();
+    assertThat(headers.toString()).isEqualTo("header1: valu√©1\n");
+  }
+
+  @Test public void ofThrowsOddNumberOfHeaders() {
+    try {
+      Headers.of("User-Agent", "OkHttp", "Content-Length");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofThrowsOnNull() {
+    try {
+      Headers.of("User-Agent", null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofThrowsOnEmptyName() {
+    try {
+      Headers.of("", "OkHttp");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofAcceptsEmptyValue() {
+    Headers headers = Headers.of("User-Agent", "");
+    assertThat(headers.value(0)).isEqualTo("");
+  }
+
+  @Test public void ofMakesDefensiveCopy() {
+    String[] namesAndValues = {
+        "User-Agent",
+        "OkHttp"
+    };
+    Headers headers = Headers.of(namesAndValues);
+    namesAndValues[1] = "Chrome";
+    assertThat(headers.value(0)).isEqualTo("OkHttp");
+  }
+
+  @Test public void ofRejectsNullChar() {
+    try {
+      Headers.of("User-Agent", "Square\u0000OkHttp");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofMapThrowsOnNull() {
+    try {
+      Headers.of(Collections.singletonMap("User-Agent", null));
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test public void ofMapThrowsOnEmptyName() {
+    try {
+      Headers.of(singletonMap("", "OkHttp"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofMapThrowsOnBlankName() {
+    try {
+      Headers.of(singletonMap(" ", "OkHttp"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofMapAcceptsEmptyValue() {
+    Headers headers = Headers.of(singletonMap("User-Agent", ""));
+    assertThat(headers.value(0)).isEqualTo("");
+  }
+
+  @Test public void ofMapTrimsKey() {
+    Headers headers = Headers.of(singletonMap(" User-Agent ", "OkHttp"));
+    assertThat(headers.name(0)).isEqualTo("User-Agent");
+  }
+
+  @Test public void ofMapTrimsValue() {
+    Headers headers = Headers.of(singletonMap("User-Agent", " OkHttp "));
+    assertThat(headers.value(0)).isEqualTo("OkHttp");
+  }
+
+  @Test public void ofMapMakesDefensiveCopy() {
+    Map<String, String> namesAndValues = new LinkedHashMap<>();
+    namesAndValues.put("User-Agent", "OkHttp");
+
+    Headers headers = Headers.of(namesAndValues);
+    namesAndValues.put("User-Agent", "Chrome");
+    assertThat(headers.value(0)).isEqualTo("OkHttp");
+  }
+
+  @Test public void ofMapRejectsNullCharInName() {
+    try {
+      Headers.of(singletonMap("User-\u0000Agent", "OkHttp"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofMapRejectsNullCharInValue() {
+    try {
+      Headers.of(singletonMap("User-Agent", "Square\u0000OkHttp"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void toMultimapGroupsHeaders() {
+    Headers headers = Headers.of(
+        "cache-control", "no-cache",
+        "cache-control", "no-store",
+        "user-agent", "OkHttp");
+    Map<String, List<String>> headerMap = headers.toMultimap();
+    assertThat(headerMap.get("cache-control").size()).isEqualTo(2);
+    assertThat(headerMap.get("user-agent").size()).isEqualTo(1);
+  }
+
+  @Test public void toMultimapUsesCanonicalCase() {
+    Headers headers = Headers.of(
+        "cache-control", "no-store",
+        "Cache-Control", "no-cache",
+        "User-Agent", "OkHttp");
+    Map<String, List<String>> headerMap = headers.toMultimap();
+    assertThat(headerMap.get("cache-control").size()).isEqualTo(2);
+    assertThat(headerMap.get("user-agent").size()).isEqualTo(1);
+  }
+
+  @Test public void toMultimapAllowsCaseInsensitiveGet() {
+    Headers headers = Headers.of(
+        "cache-control", "no-store",
+        "Cache-Control", "no-cache");
+    Map<String, List<String>> headerMap = headers.toMultimap();
+    assertThat(headerMap.get("cache-control").size()).isEqualTo(2);
+    assertThat(headerMap.get("Cache-Control").size()).isEqualTo(2);
+  }
+
+  @Test public void nameIndexesAreStrict() {
+    Headers headers = Headers.of("a", "b", "c", "d");
+    try {
+      headers.name(-1);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+    assertThat(headers.name(0)).isEqualTo("a");
+    assertThat(headers.name(1)).isEqualTo("c");
+    try {
+      headers.name(2);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void valueIndexesAreStrict() {
+    Headers headers = Headers.of("a", "b", "c", "d");
+    try {
+      headers.value(-1);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+    assertThat(headers.value(0)).isEqualTo("b");
+    assertThat(headers.value(1)).isEqualTo("d");
+    try {
+      headers.value(2);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void builderRejectsUnicodeInHeaderName() {
+    try {
+      new Headers.Builder().add("h√©ader1", "value1");
+      fail("Should have complained about invalid name");
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0xe9 at 1 in header name: h√©ader1");
+    }
+  }
+
+  @Test public void builderRejectsUnicodeInHeaderValue() {
+    try {
+      new Headers.Builder().add("header1", "valu√©1");
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0xe9 at 4 in header1 value: valu√©1");
+    }
+  }
+
+  @Test public void varargFactoryRejectsUnicodeInHeaderName() {
+    try {
+      Headers.of("h√©ader1", "value1");
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0xe9 at 1 in header name: h√©ader1");
+    }
+  }
+
+  @Test public void varargFactoryRejectsUnicodeInHeaderValue() {
+    try {
+      Headers.of("header1", "valu√©1");
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0xe9 at 4 in header1 value: valu√©1");
+    }
+  }
+
+  @Test public void mapFactoryRejectsUnicodeInHeaderName() {
+    try {
+      Headers.of(singletonMap("h√©ader1", "value1"));
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0xe9 at 1 in header name: h√©ader1");
+    }
+  }
+
+  @Test public void mapFactoryRejectsUnicodeInHeaderValue() {
+    try {
+      Headers.of(singletonMap("header1", "valu√©1"));
+      fail("Should have complained about invalid value");
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected.getMessage()).isEqualTo(
+          "Unexpected char 0xe9 at 4 in header1 value: valu√©1");
+    }
+  }
+
+  @Test public void headersEquals() {
+    Headers headers1 = new Headers.Builder()
+        .add("Connection", "close")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    Headers headers2 = new Headers.Builder()
+        .add("Connection", "close")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    assertThat(headers2).isEqualTo(headers1);
+    assertThat(headers2.hashCode()).isEqualTo(headers1.hashCode());
+  }
+
+  @Test public void headersNotEquals() {
+    Headers headers1 = new Headers.Builder()
+        .add("Connection", "close")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    Headers headers2 = new Headers.Builder()
+        .add("Connection", "keep-alive")
+        .add("Transfer-Encoding", "chunked")
+        .build();
+    assertThat(headers2).isNotEqualTo(headers1);
+    assertThat(headers2.hashCode()).isNotEqualTo((long) headers1.hashCode());
+  }
+
+  @Test public void headersToString() {
+    Headers headers = new Headers.Builder()
+        .add("A", "a")
+        .add("B", "bb")
+        .build();
+    assertThat(headers.toString()).isEqualTo("A: a\nB: bb\n");
+  }
+
+  @Test public void headersAddAll() {
+    Headers sourceHeaders = new Headers.Builder()
+        .add("A", "aa")
+        .add("a", "aa")
+        .add("B", "bb")
+        .build();
+    Headers headers = new Headers.Builder()
+        .add("A", "a")
+        .addAll(sourceHeaders)
+        .add("C", "c")
+        .build();
+    assertThat(headers.toString()).isEqualTo("A: a\nA: aa\na: aa\nB: bb\nC: c\n");
+  }
+
+  /** See https://github.com/square/okhttp/issues/2780. */
+  @Test public void testDigestChallengeWithStrictRfc2617Header() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
+            + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
+        .build();
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
+    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
+  }
+
+  @Test public void testDigestChallengeWithDifferentlyOrderedAuthParams() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest qop=\"auth\", realm=\"myrealm\", nonce=\"fjalskdflwejrlask"
+            + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
+        .build();
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
+    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
+  }
+
+  @Test public void testDigestChallengeWithDifferentlyOrderedAuthParams2() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest qop=\"auth\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaksjdflk"
+            + "asdf\", realm=\"myrealm\", stale=\"FALSE\"")
+        .build();
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
+    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
+  }
+
+  @Test public void testDigestChallengeWithMissingRealm() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest qop=\"auth\", underrealm=\"myrealm\", nonce=\"fjalskdflwej"
+            + "rlaskdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
+        .build();
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
+    assertThat(challenges.get(0).realm()).isNull();
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("underrealm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
+  }
+
+  @Test public void testDigestChallengeWithAdditionalSpaces() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest qop=\"auth\",    realm=\"myrealm\", nonce=\"fjalskdflwejrl"
+            + "askdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
+        .build();
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
+    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
+  }
+
+  @Test public void testDigestChallengeWithAdditionalSpacesBeforeFirstAuthParam() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest    realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjfl"
+            + "aksjdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
+        .build();
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
+    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
+  }
+
+  @Test public void testDigestChallengeWithCamelCasedNames() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "DiGeSt qop=\"auth\", rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlask"
+            + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
+        .build();
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("DiGeSt");
+    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
+  }
+
+  @Test public void testDigestChallengeWithCamelCasedNames2() {
+    // Strict RFC 2617 camelcased.
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "DIgEsT rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
+            + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
+        .build();
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("DIgEsT");
+    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
+    expectedAuthParams.put("qop", "auth");
+    expectedAuthParams.put("stale", "FALSE");
+    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
+  }
+
+  @Test public void testDigestChallengeWithTokenFormOfAuthParam() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest realm=myrealm").build();
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
+    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
+    assertThat(challenges.get(0).authParams()).isEqualTo(singletonMap("realm", "myrealm"));
+  }
+
+  @Test public void testDigestChallengeWithoutAuthParams() {
+    // Scheme only.
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest").build();
+    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
+    assertThat(challenges.size()).isEqualTo(1);
+    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
+    assertThat(challenges.get(0).realm()).isNull();
+    assertThat(challenges.get(0).authParams()).isEqualTo(emptyMap());
+  }
+
+  @Test public void basicChallenge() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\"")
+        .build();
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
+        singletonList(new Challenge("Basic", singletonMap("realm", "protected area"))));
+  }
+
+  @Test public void basicChallengeWithCharset() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
+        .build();
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "protected area");
+    expectedAuthParams.put("charset", "UTF-8");
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
+        singletonList(new Challenge("Basic", expectedAuthParams)));
+  }
+
+  @Test public void basicChallengeWithUnexpectedCharset() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"US-ASCII\"")
+        .build();
+
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "protected area");
+    expectedAuthParams.put("charset", "US-ASCII");
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
+        singletonList(new Challenge("Basic", expectedAuthParams)));
+  }
+
+  @Test public void separatorsBeforeFirstChallenge() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", " ,  , Basic realm=myrealm")
+        .build();
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
+        singletonList(new Challenge("Basic", singletonMap("realm", "myrealm"))));
+  }
+
+  @Test public void spacesAroundKeyValueSeparator() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm = \"myrealm\"")
+        .build();
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
+        singletonList(new Challenge("Basic", singletonMap("realm", "myrealm"))));
+  }
+
+  @Test public void multipleChallengesInOneHeader() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm = \"myrealm\",Digest")
+        .build();
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Basic", singletonMap("realm", "myrealm")),
+        new Challenge("Digest", Collections.emptyMap()));
+  }
+
+  @Test public void multipleChallengesWithSameSchemeButDifferentRealmInOneHeader() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm = \"myrealm\",Basic realm=myotherrealm")
+        .build();
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Basic", singletonMap("realm", "myrealm")),
+        new Challenge("Basic", singletonMap("realm", "myotherrealm")));
+  }
+
+  @Test public void separatorsBeforeFirstAuthParam() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest, Basic ,,realm=\"myrealm\"")
+        .build();
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Digest", Collections.emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "myrealm")));
+  }
+
+  @Test public void onlyCommaBetweenChallenges() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,Basic realm=\"myrealm\"")
+        .build();
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Digest", Collections.emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "myrealm")));
+  }
+
+  @Test public void multipleSeparatorsBetweenChallenges() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,realm=\"myrealm\"")
+        .build();
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Digest", Collections.emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "myrealm")));
+  }
+
+  @Test public void unknownAuthParams() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,foo=bar,realm=\"myrealm\"")
+        .build();
+
+    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
+    expectedAuthParams.put("realm", "myrealm");
+    expectedAuthParams.put("foo", "bar");
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Digest", Collections.emptyMap()),
+        new Challenge("Basic", expectedAuthParams));
+  }
+
+  @Test public void escapedCharactersInQuotedString() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\\\\\\\"r\\ealm\"")
+        .build();
+
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Digest", Collections.emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "my\\\"realm")));
+  }
+
+  @Test public void commaInQuotedStringAndBeforeFirstChallenge() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", ",Digest,,,, Basic ,,,realm=\"my, realm,\"")
+        .build();
+
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Digest", Collections.emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "my, realm,")));
+  }
+
+  @Test public void unescapedDoubleQuoteInQuotedStringWithEvenNumberOfBackslashesInFront() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\\\\\\\\\"r\\ealm\"")
+        .build();
+
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Digest", Collections.emptyMap()));
+  }
+
+  @Test public void unescapedDoubleQuoteInQuotedString() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\"realm\"")
+        .build();
+
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Digest", Collections.emptyMap()));
+  }
+
+  @Ignore("TODO(jwilson): reject parameters that use invalid characters")
+  @Test public void doubleQuoteInToken() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=my\"realm")
+        .build();
+
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Digest", Collections.emptyMap()));
+  }
+
+  @Test public void token68InsteadOfAuthParams() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Other abc==")
+        .build();
+
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
+        singletonList(
+        new Challenge("Other", singletonMap(null, "abc=="))));
+  }
+
+  @Test public void token68AndAuthParams() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Other abc==, realm=myrealm")
+        .build();
+
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Other", singletonMap(null, "abc==")));
+  }
+
+  @Test public void repeatedAuthParamKey() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Other realm=myotherrealm, realm=myrealm")
+        .build();
+
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
+        emptyList());
+  }
+
+  @Test public void multipleAuthenticateHeaders() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Digest")
+        .add("WWW-Authenticate", "Basic realm=myrealm")
+        .build();
+
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Digest", Collections.emptyMap()),
+        new Challenge("Basic", singletonMap("realm", "myrealm")));
+  }
+
+  @Test public void multipleAuthenticateHeadersInDifferentOrder() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm=myrealm")
+        .add("WWW-Authenticate", "Digest")
+        .build();
+
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Basic", singletonMap("realm", "myrealm")),
+        new Challenge("Digest", Collections.emptyMap()));
+  }
+
+  @Test public void multipleBasicAuthenticateHeaders() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate", "Basic realm=myrealm")
+        .add("WWW-Authenticate", "Basic realm=myotherrealm")
+        .build();
+
+    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
+        new Challenge("Basic", singletonMap("realm", "myrealm")),
+        new Challenge("Basic", singletonMap("realm", "myotherrealm")));
+  }
+
+  @Test public void byteCount() {
+    assertThat(Util.EMPTY_HEADERS.byteCount()).isEqualTo(0L);
+    assertThat(new Headers.Builder()
+        .add("abc", "def")
+        .build()
+        .byteCount()).isEqualTo(10L);
+    assertThat(new Headers.Builder()
+        .add("abc", "def")
+        .add("ghi", "jkl")
+        .build()
+        .byteCount()).isEqualTo(20L);
+  }
+
+  @Test public void addDate() {
+    Date expected = new Date(0L);
+    Headers headers = new Headers.Builder()
+        .add("testDate", expected)
+        .build();
+    assertThat(headers.get("testDate")).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT");
+    assertThat(headers.getDate("testDate")).isEqualTo(new Date(0L));
+  }
+
+  @Test public void addDateNull() {
+    try {
+      new Headers.Builder()
+          .add("testDate", (Date) null)
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void addInstant() {
+    Instant expected = Instant.ofEpochMilli(0L);
+    Headers headers = new Headers.Builder()
+        .add("Test-Instant", expected)
+        .build();
+    assertThat(headers.get("Test-Instant")).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT");
+    assertThat(headers.getInstant("Test-Instant")).isEqualTo(expected);
+  }
+
+  @Test public void addInstantNull() {
+    try {
+      new Headers.Builder()
+          .add("Test-Instant", (Instant) null)
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setDate() {
+    Date expected = new Date(1000);
+    Headers headers = new Headers.Builder()
+        .add("testDate", new Date(0L))
+        .set("testDate", expected)
+        .build();
+    assertThat(headers.get("testDate")).isEqualTo("Thu, 01 Jan 1970 00:00:01 GMT");
+    assertThat(headers.getDate("testDate")).isEqualTo(expected);
+  }
+
+  @Test public void setDateNull() {
+    try {
+      new Headers.Builder()
+          .set("testDate", (Date) null)
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setInstant() {
+    Instant expected = Instant.ofEpochMilli(1000L);
+    Headers headers = new Headers.Builder()
+        .add("Test-Instant", Instant.ofEpochMilli(0L))
+        .set("Test-Instant", expected)
+        .build();
+    assertThat(headers.get("Test-Instant")).isEqualTo("Thu, 01 Jan 1970 00:00:01 GMT");
+    assertThat(headers.getInstant("Test-Instant")).isEqualTo(expected);
+  }
+
+  @Test public void setInstantNull() {
+    try {
+      new Headers.Builder()
+          .set("Test-Instant", (Instant) null)
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/HttpUrlTest.java b/okhttp/src/test/java/okhttp3/HttpUrlTest.java
new file mode 100644
index 0000000000..f6db518bdd
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/HttpUrlTest.java
@@ -0,0 +1,1728 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.net.URI;
+import java.net.URL;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import okhttp3.UrlComponentEncodingTester.Component;
+import okhttp3.UrlComponentEncodingTester.Encoding;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static java.util.Arrays.asList;
+import static java.util.Collections.singletonList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(Parameterized.class)
+public final class HttpUrlTest {
+  @Parameterized.Parameters(name = "Use get = {0}")
+  public static Collection<Object[]> parameters() {
+    return asList(
+        new Object[] { true },
+        new Object[] { false }
+    );
+  }
+
+  @Parameterized.Parameter
+  public boolean useGet;
+
+  HttpUrl parse(String url) {
+    return useGet
+        ? HttpUrl.get(url)
+        : HttpUrl.parse(url);
+  }
+
+  @Test public void parseTrimsAsciiWhitespace() throws Exception {
+    HttpUrl expected = parse("http://host/");
+    // Leading.
+    assertThat(parse("http://host/\f\n\t \r")).isEqualTo(expected);
+    // Trailing.
+    assertThat(parse("\r\n\f \thttp://host/")).isEqualTo(expected);
+    // Both.
+    assertThat(parse(" http://host/ ")).isEqualTo(expected);
+    // Both.
+    assertThat(parse("    http://host/    ")).isEqualTo(expected);
+    assertThat(parse("http://host/").resolve("   ")).isEqualTo(expected);
+    assertThat(parse("http://host/").resolve("  .  ")).isEqualTo(expected);
+  }
+
+  @Test public void parseHostAsciiNonPrintable() throws Exception {
+    String host = "host\u0001";
+    assertInvalid("http://" + host + "/", "Invalid URL host: \"host\u0001\"");
+    // TODO make exception message escape non-printable characters
+  }
+
+  @Test public void parseDoesNotTrimOtherWhitespaceCharacters() throws Exception {
+    // Whitespace characters list from Google's Guava team: http://goo.gl/IcR9RD
+    // line tabulation
+    assertThat(parse("http://h/\u000b").encodedPath()).isEqualTo("/%0B");
+    // information separator 4
+    assertThat(parse("http://h/\u001c").encodedPath()).isEqualTo("/%1C");
+    // information separator 3
+    assertThat(parse("http://h/\u001d").encodedPath()).isEqualTo("/%1D");
+    // information separator 2
+    assertThat(parse("http://h/\u001e").encodedPath()).isEqualTo("/%1E");
+    // information separator 1
+    assertThat(parse("http://h/\u001f").encodedPath()).isEqualTo("/%1F");
+    // next line
+    assertThat(parse("http://h/\u0085").encodedPath()).isEqualTo("/%C2%85");
+    // non-breaking space
+    assertThat(parse("http://h/\u00a0").encodedPath()).isEqualTo("/%C2%A0");
+    // ogham space mark
+    assertThat(parse("http://h/\u1680").encodedPath()).isEqualTo("/%E1%9A%80");
+    // mongolian vowel separator
+    assertThat(parse("http://h/\u180e").encodedPath()).isEqualTo("/%E1%A0%8E");
+    // en quad
+    assertThat(parse("http://h/\u2000").encodedPath()).isEqualTo("/%E2%80%80");
+    // em quad
+    assertThat(parse("http://h/\u2001").encodedPath()).isEqualTo("/%E2%80%81");
+    // en space
+    assertThat(parse("http://h/\u2002").encodedPath()).isEqualTo("/%E2%80%82");
+    // em space
+    assertThat(parse("http://h/\u2003").encodedPath()).isEqualTo("/%E2%80%83");
+    // three-per-em space
+    assertThat(parse("http://h/\u2004").encodedPath()).isEqualTo("/%E2%80%84");
+    // four-per-em space
+    assertThat(parse("http://h/\u2005").encodedPath()).isEqualTo("/%E2%80%85");
+    // six-per-em space
+    assertThat(parse("http://h/\u2006").encodedPath()).isEqualTo("/%E2%80%86");
+    // figure space
+    assertThat(parse("http://h/\u2007").encodedPath()).isEqualTo("/%E2%80%87");
+    // punctuation space
+    assertThat(parse("http://h/\u2008").encodedPath()).isEqualTo("/%E2%80%88");
+    // thin space
+    assertThat(parse("http://h/\u2009").encodedPath()).isEqualTo("/%E2%80%89");
+    // hair space
+    assertThat(parse("http://h/\u200a").encodedPath()).isEqualTo("/%E2%80%8A");
+    // zero-width space
+    assertThat(parse("http://h/\u200b").encodedPath()).isEqualTo("/%E2%80%8B");
+    // zero-width non-joiner
+    assertThat(parse("http://h/\u200c").encodedPath()).isEqualTo("/%E2%80%8C");
+    // zero-width joiner
+    assertThat(parse("http://h/\u200d").encodedPath()).isEqualTo("/%E2%80%8D");
+    // left-to-right mark
+    assertThat(parse("http://h/\u200e").encodedPath()).isEqualTo("/%E2%80%8E");
+    // right-to-left mark
+    assertThat(parse("http://h/\u200f").encodedPath()).isEqualTo("/%E2%80%8F");
+    // line separator
+    assertThat(parse("http://h/\u2028").encodedPath()).isEqualTo("/%E2%80%A8");
+    // paragraph separator
+    assertThat(parse("http://h/\u2029").encodedPath()).isEqualTo("/%E2%80%A9");
+    // narrow non-breaking space
+    assertThat(parse("http://h/\u202f").encodedPath()).isEqualTo("/%E2%80%AF");
+    // medium mathematical space
+    assertThat(parse("http://h/\u205f").encodedPath()).isEqualTo("/%E2%81%9F");
+    // ideographic space
+    assertThat(parse("http://h/\u3000").encodedPath()).isEqualTo("/%E3%80%80");
+  }
+
+  @Test public void scheme() throws Exception {
+    assertThat(parse("http://host/")).isEqualTo(parse("http://host/"));
+    assertThat(parse("Http://host/")).isEqualTo(parse("http://host/"));
+    assertThat(parse("http://host/")).isEqualTo(parse("http://host/"));
+    assertThat(parse("HTTP://host/")).isEqualTo(parse("http://host/"));
+    assertThat(parse("https://host/")).isEqualTo(parse("https://host/"));
+    assertThat(parse("HTTPS://host/")).isEqualTo(parse("https://host/"));
+
+    assertInvalid("image640://480.png", "Expected URL scheme 'http' or 'https' but was 'image640'");
+    assertInvalid("httpp://host/", "Expected URL scheme 'http' or 'https' but was 'httpp'");
+    assertInvalid("0ttp://host/", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("ht+tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht+tp'");
+    assertInvalid("ht.tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht.tp'");
+    assertInvalid("ht-tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht-tp'");
+    assertInvalid("ht1tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht1tp'");
+    assertInvalid("httpss://host/", "Expected URL scheme 'http' or 'https' but was 'httpss'");
+  }
+
+  @Test public void parseNoScheme() throws Exception {
+    assertInvalid("//host", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("/path", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("path", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("?query", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("#fragment", "Expected URL scheme 'http' or 'https' but no colon was found");
+  }
+
+  @Test public void newBuilderResolve() throws Exception {
+    // Non-exhaustive tests because implementation is the same as resolve.
+    HttpUrl base = parse("http://host/a/b");
+    assertThat(base.newBuilder("https://host2").build()).isEqualTo(parse("https://host2/"));
+    assertThat(base.newBuilder("//host2").build()).isEqualTo(parse("http://host2/"));
+    assertThat(base.newBuilder("/path").build()).isEqualTo(parse("http://host/path"));
+    assertThat(base.newBuilder("path").build()).isEqualTo(parse("http://host/a/path"));
+    assertThat(base.newBuilder("?query").build()).isEqualTo(parse("http://host/a/b?query"));
+    assertThat(base.newBuilder("#fragment").build())
+        .isEqualTo(parse("http://host/a/b#fragment"));
+    assertThat(base.newBuilder("").build()).isEqualTo(parse("http://host/a/b"));
+    assertThat(base.newBuilder("ftp://b")).isNull();
+    assertThat(base.newBuilder("ht+tp://b")).isNull();
+    assertThat(base.newBuilder("ht-tp://b")).isNull();
+    assertThat(base.newBuilder("ht.tp://b")).isNull();
+  }
+
+  @Test public void redactedUrl() {
+    HttpUrl baseWithPasswordAndUsername = parse("http://username:password@host/a/b#fragment");
+    HttpUrl baseWithUsernameOnly = parse("http://username@host/a/b#fragment");
+    HttpUrl baseWithPasswordOnly = parse("http://password@host/a/b#fragment");
+    assertThat(baseWithPasswordAndUsername.redact()).isEqualTo("http://host/...");
+    assertThat(baseWithUsernameOnly.redact()).isEqualTo("http://host/...");
+    assertThat(baseWithPasswordOnly.redact()).isEqualTo("http://host/...");
+  }
+
+  @Test public void resolveNoScheme() throws Exception {
+    HttpUrl base = parse("http://host/a/b");
+    assertThat(base.resolve("//host2")).isEqualTo(parse("http://host2/"));
+    assertThat(base.resolve("/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("path")).isEqualTo(parse("http://host/a/path"));
+    assertThat(base.resolve("?query")).isEqualTo(parse("http://host/a/b?query"));
+    assertThat(base.resolve("#fragment")).isEqualTo(parse("http://host/a/b#fragment"));
+    assertThat(base.resolve("")).isEqualTo(parse("http://host/a/b"));
+    assertThat(base.resolve("\\path")).isEqualTo(parse("http://host/path"));
+  }
+
+  @Test public void resolveUnsupportedScheme() throws Exception {
+    HttpUrl base = parse("http://a/");
+    assertThat(base.resolve("ftp://b")).isNull();
+    assertThat(base.resolve("ht+tp://b")).isNull();
+    assertThat(base.resolve("ht-tp://b")).isNull();
+    assertThat(base.resolve("ht.tp://b")).isNull();
+  }
+
+  @Test public void resolveSchemeLikePath() throws Exception {
+    HttpUrl base = parse("http://a/");
+    assertThat(base.resolve("http//b/")).isEqualTo(parse("http://a/http//b/"));
+    assertThat(base.resolve("ht+tp//b/")).isEqualTo(parse("http://a/ht+tp//b/"));
+    assertThat(base.resolve("ht-tp//b/")).isEqualTo(parse("http://a/ht-tp//b/"));
+    assertThat(base.resolve("ht.tp//b/")).isEqualTo(parse("http://a/ht.tp//b/"));
+  }
+
+  /** https://tools.ietf.org/html/rfc3986#section-5.4.1 */
+  @Test public void rfc3886NormalExamples() {
+    HttpUrl url = parse("http://a/b/c/d;p?q");
+    // No 'g:' scheme in HttpUrl.
+    assertThat(url.resolve("g:h")).isNull();
+    assertThat(url.resolve("g")).isEqualTo(parse("http://a/b/c/g"));
+    assertThat(url.resolve("./g")).isEqualTo(parse("http://a/b/c/g"));
+    assertThat(url.resolve("g/")).isEqualTo(parse("http://a/b/c/g/"));
+    assertThat(url.resolve("/g")).isEqualTo(parse("http://a/g"));
+    assertThat(url.resolve("//g")).isEqualTo(parse("http://g"));
+    assertThat(url.resolve("?y")).isEqualTo(parse("http://a/b/c/d;p?y"));
+    assertThat(url.resolve("g?y")).isEqualTo(parse("http://a/b/c/g?y"));
+    assertThat(url.resolve("#s")).isEqualTo(parse("http://a/b/c/d;p?q#s"));
+    assertThat(url.resolve("g#s")).isEqualTo(parse("http://a/b/c/g#s"));
+    assertThat(url.resolve("g?y#s")).isEqualTo(parse("http://a/b/c/g?y#s"));
+    assertThat(url.resolve(";x")).isEqualTo(parse("http://a/b/c/;x"));
+    assertThat(url.resolve("g;x")).isEqualTo(parse("http://a/b/c/g;x"));
+    assertThat(url.resolve("g;x?y#s")).isEqualTo(parse("http://a/b/c/g;x?y#s"));
+    assertThat(url.resolve("")).isEqualTo(parse("http://a/b/c/d;p?q"));
+    assertThat(url.resolve(".")).isEqualTo(parse("http://a/b/c/"));
+    assertThat(url.resolve("./")).isEqualTo(parse("http://a/b/c/"));
+    assertThat(url.resolve("..")).isEqualTo(parse("http://a/b/"));
+    assertThat(url.resolve("../")).isEqualTo(parse("http://a/b/"));
+    assertThat(url.resolve("../g")).isEqualTo(parse("http://a/b/g"));
+    assertThat(url.resolve("../..")).isEqualTo(parse("http://a/"));
+    assertThat(url.resolve("../../")).isEqualTo(parse("http://a/"));
+    assertThat(url.resolve("../../g")).isEqualTo(parse("http://a/g"));
+  }
+
+  /** https://tools.ietf.org/html/rfc3986#section-5.4.2 */
+  @Test public void rfc3886AbnormalExamples() {
+    HttpUrl url = parse("http://a/b/c/d;p?q");
+    assertThat(url.resolve("../../../g")).isEqualTo(parse("http://a/g"));
+    assertThat(url.resolve("../../../../g")).isEqualTo(parse("http://a/g"));
+    assertThat(url.resolve("/./g")).isEqualTo(parse("http://a/g"));
+    assertThat(url.resolve("/../g")).isEqualTo(parse("http://a/g"));
+    assertThat(url.resolve("g.")).isEqualTo(parse("http://a/b/c/g."));
+    assertThat(url.resolve(".g")).isEqualTo(parse("http://a/b/c/.g"));
+    assertThat(url.resolve("g..")).isEqualTo(parse("http://a/b/c/g.."));
+    assertThat(url.resolve("..g")).isEqualTo(parse("http://a/b/c/..g"));
+    assertThat(url.resolve("./../g")).isEqualTo(parse("http://a/b/g"));
+    assertThat(url.resolve("./g/.")).isEqualTo(parse("http://a/b/c/g/"));
+    assertThat(url.resolve("g/./h")).isEqualTo(parse("http://a/b/c/g/h"));
+    assertThat(url.resolve("g/../h")).isEqualTo(parse("http://a/b/c/h"));
+    assertThat(url.resolve("g;x=1/./y")).isEqualTo(parse("http://a/b/c/g;x=1/y"));
+    assertThat(url.resolve("g;x=1/../y")).isEqualTo(parse("http://a/b/c/y"));
+    assertThat(url.resolve("g?y/./x")).isEqualTo(parse("http://a/b/c/g?y/./x"));
+    assertThat(url.resolve("g?y/../x")).isEqualTo(parse("http://a/b/c/g?y/../x"));
+    assertThat(url.resolve("g#s/./x")).isEqualTo(parse("http://a/b/c/g#s/./x"));
+    assertThat(url.resolve("g#s/../x")).isEqualTo(parse("http://a/b/c/g#s/../x"));
+    // "http:g" also okay.
+    assertThat(url.resolve("http:g")).isEqualTo(parse("http://a/b/c/g"));
+  }
+
+  @Test public void parseAuthoritySlashCountDoesntMatter() throws Exception {
+    assertThat(parse("http:host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http://host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:/\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:///host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:\\//host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:/\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http://\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:\\\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:/\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:\\\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http:////host/path")).isEqualTo(parse("http://host/path"));
+  }
+
+  @Test public void resolveAuthoritySlashCountDoesntMatterWithDifferentScheme() throws Exception {
+    HttpUrl base = parse("https://a/b/c");
+    assertThat(base.resolve("http:host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http://host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:/\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:///host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\//host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:/\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http://\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:/\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:////host/path")).isEqualTo(parse("http://host/path"));
+  }
+
+  @Test public void resolveAuthoritySlashCountMattersWithSameScheme() throws Exception {
+    HttpUrl base = parse("http://a/b/c");
+    assertThat(base.resolve("http:host/path")).isEqualTo(parse("http://a/b/host/path"));
+    assertThat(base.resolve("http:/host/path")).isEqualTo(parse("http://a/host/path"));
+    assertThat(base.resolve("http:\\host/path")).isEqualTo(parse("http://a/host/path"));
+    assertThat(base.resolve("http://host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:/\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:///host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\//host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:/\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http://\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\\\/host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:/\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:\\\\\\host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(base.resolve("http:////host/path")).isEqualTo(parse("http://host/path"));
+  }
+
+  @Test public void username() throws Exception {
+    assertThat(parse("http://@host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http://user@host/path")).isEqualTo(parse("http://user@host/path"));
+  }
+
+  /** Given multiple '@' characters, the last one is the delimiter. */
+  @Test public void authorityWithMultipleAtSigns() throws Exception {
+    HttpUrl httpUrl = parse("http://foo@bar@baz/path");
+    assertThat(httpUrl.username()).isEqualTo("foo@bar");
+    assertThat(httpUrl.password()).isEqualTo("");
+    assertThat(httpUrl).isEqualTo(parse("http://foo%40bar@baz/path"));
+  }
+
+  /** Given multiple ':' characters, the first one is the delimiter. */
+  @Test public void authorityWithMultipleColons() throws Exception {
+    HttpUrl httpUrl = parse("http://foo:pass1@bar:pass2@baz/path");
+    assertThat(httpUrl.username()).isEqualTo("foo");
+    assertThat(httpUrl.password()).isEqualTo("pass1@bar:pass2");
+    assertThat(httpUrl).isEqualTo(parse("http://foo:pass1%40bar%3Apass2@baz/path"));
+  }
+
+  @Test public void usernameAndPassword() throws Exception {
+    assertThat(parse("http://username:password@host/path"))
+        .isEqualTo(parse("http://username:password@host/path"));
+    assertThat(parse("http://username:@host/path"))
+        .isEqualTo(parse("http://username@host/path"));
+  }
+
+  @Test public void passwordWithEmptyUsername() throws Exception {
+    // Chrome doesn't mind, but Firefox rejects URLs with empty usernames and non-empty passwords.
+    assertThat(parse("http://:@host/path")).isEqualTo(parse("http://host/path"));
+    assertThat(parse("http://:password@@host/path").encodedPassword())
+        .isEqualTo("password%40");
+  }
+
+  @Test public void unprintableCharactersArePercentEncoded() throws Exception {
+    assertThat(parse("http://host/\u0000").encodedPath()).isEqualTo("/%00");
+    assertThat(parse("http://host/\u0008").encodedPath()).isEqualTo("/%08");
+    assertThat(parse("http://host/\ufffd").encodedPath()).isEqualTo("/%EF%BF%BD");
+  }
+
+  @Test public void usernameCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.PERCENT, '[', ']', '{', '}', '|', '^', '\'', ';', '=', '@')
+        .override(Encoding.SKIP, ':', '/', '\\', '?', '#')
+        .skipForUri('%')
+        .test(Component.USER);
+  }
+
+  @Test public void passwordCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.PERCENT, '[', ']', '{', '}', '|', '^', '\'', ':', ';', '=', '@')
+        .override(Encoding.SKIP, '/', '\\', '?', '#')
+        .skipForUri('%')
+        .test(Component.PASSWORD);
+  }
+
+  @Test public void hostContainsIllegalCharacter() throws Exception {
+    assertInvalid("http://\n/", "Invalid URL host: \"\n\"");
+    assertInvalid("http:// /", "Invalid URL host: \" \"");
+    assertInvalid("http://%20/", "Invalid URL host: \"%20\"");
+  }
+
+  @Test public void hostnameLowercaseCharactersMappedDirectly() throws Exception {
+    assertThat(parse("http://abcd").host()).isEqualTo("abcd");
+    assertThat(parse("http://œÉ").host()).isEqualTo("xn--4xa");
+  }
+
+  @Test public void hostnameUppercaseCharactersConvertedToLowercase() throws Exception {
+    assertThat(parse("http://ABCD").host()).isEqualTo("abcd");
+    assertThat(parse("http://Œ£").host()).isEqualTo("xn--4xa");
+  }
+
+  @Test public void hostnameIgnoredCharacters() throws Exception {
+    // The soft hyphen (¬≠) should be ignored.
+    assertThat(parse("http://AB\u00adCD").host()).isEqualTo("abcd");
+  }
+
+  @Test public void hostnameMultipleCharacterMapping() throws Exception {
+    // Map the single character telephone symbol (‚Ñ°) to the string "tel".
+    assertThat(parse("http://\u2121").host()).isEqualTo("tel");
+  }
+
+  @Test public void hostnameMappingLastMappedCodePoint() throws Exception {
+    assertThat(parse("http://\uD87E\uDE1D").host()).isEqualTo("xn--pu5l");
+  }
+
+  @Ignore("The java.net.IDN implementation doesn't ignore characters that it should.")
+  @Test public void hostnameMappingLastIgnoredCodePoint() throws Exception {
+    assertThat(parse("http://ab\uDB40\uDDEFcd").host()).isEqualTo("abcd");
+  }
+
+  @Test public void hostnameMappingLastDisallowedCodePoint() throws Exception {
+    assertInvalid("http://\uDBFF\uDFFF", "Invalid URL host: \"\uDBFF\uDFFF\"");
+  }
+
+  @Test public void hostIpv6() throws Exception {
+    // Square braces are absent from host()...
+    assertThat(parse("http://[::1]/").host()).isEqualTo("::1");
+
+    // ... but they're included in toString().
+    assertThat(parse("http://[::1]/").toString()).isEqualTo("http://[::1]/");
+
+    // IPv6 colons don't interfere with port numbers or passwords.
+    assertThat(parse("http://[::1]:8080/").port()).isEqualTo(8080);
+    assertThat(parse("http://user:password@[::1]/").password()).isEqualTo("password");
+    assertThat(parse("http://user:password@[::1]:8080/").host()).isEqualTo("::1");
+
+    // Permit the contents of IPv6 addresses to be percent-encoded...
+    assertThat(parse("http://[%3A%3A%31]/").host()).isEqualTo("::1");
+
+    // Including the Square braces themselves! (This is what Chrome does.)
+    assertThat(parse("http://%5B%3A%3A1%5D/").host()).isEqualTo("::1");
+  }
+
+  @Test public void hostIpv6AddressDifferentFormats() throws Exception {
+    // Multiple representations of the same address; see http://tools.ietf.org/html/rfc5952.
+    String a3 = "2001:db8::1:0:0:1";
+    assertThat(parse("http://[2001:db8:0:0:1:0:0:1]").host()).isEqualTo(a3);
+    assertThat(parse("http://[2001:0db8:0:0:1:0:0:1]").host()).isEqualTo(a3);
+    assertThat(parse("http://[2001:db8::1:0:0:1]").host()).isEqualTo(a3);
+    assertThat(parse("http://[2001:db8::0:1:0:0:1]").host()).isEqualTo(a3);
+    assertThat(parse("http://[2001:0db8::1:0:0:1]").host()).isEqualTo(a3);
+    assertThat(parse("http://[2001:db8:0:0:1::1]").host()).isEqualTo(a3);
+    assertThat(parse("http://[2001:db8:0000:0:1::1]").host()).isEqualTo(a3);
+    assertThat(parse("http://[2001:DB8:0:0:1::1]").host()).isEqualTo(a3);
+  }
+
+  @Test public void hostIpv6AddressLeadingCompression() throws Exception {
+    assertThat(parse("http://[::0001]").host()).isEqualTo("::1");
+    assertThat(parse("http://[0000::0001]").host()).isEqualTo("::1");
+    assertThat(parse("http://[0000:0000:0000:0000:0000:0000:0000:0001]").host())
+        .isEqualTo("::1");
+    assertThat(parse("http://[0000:0000:0000:0000:0000:0000::0001]").host())
+        .isEqualTo("::1");
+  }
+
+  @Test public void hostIpv6AddressTrailingCompression() throws Exception {
+    assertThat(parse("http://[0001:0000::]").host()).isEqualTo("1::");
+    assertThat(parse("http://[0001::0000]").host()).isEqualTo("1::");
+    assertThat(parse("http://[0001::]").host()).isEqualTo("1::");
+    assertThat(parse("http://[1::]").host()).isEqualTo("1::");
+  }
+
+  @Test public void hostIpv6AddressTooManyDigitsInGroup() throws Exception {
+    assertInvalid("http://[00000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[00000:0000:0000:0000:0000:0000:0000:0001]\"");
+    assertInvalid("http://[::00001]", "Invalid URL host: \"[::00001]\"");
+  }
+
+  @Test public void hostIpv6AddressMisplacedColons() throws Exception {
+    assertInvalid("http://[:0000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[:0000:0000:0000:0000:0000:0000:0000:0001]\"");
+    assertInvalid("http://[:::0000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[:::0000:0000:0000:0000:0000:0000:0000:0001]\"");
+    assertInvalid("http://[:1]", "Invalid URL host: \"[:1]\"");
+    assertInvalid("http://[:::1]", "Invalid URL host: \"[:::1]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0001:]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0001:]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001:]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001:]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001::]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001::]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001:::]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001:::]\"");
+    assertInvalid("http://[1:]", "Invalid URL host: \"[1:]\"");
+    assertInvalid("http://[1:::]", "Invalid URL host: \"[1:::]\"");
+    assertInvalid("http://[1:::1]", "Invalid URL host: \"[1:::1]\"");
+    assertInvalid("http://[0000:0000:0000:0000::0000:0000:0000:0001]",
+        "Invalid URL host: \"[0000:0000:0000:0000::0000:0000:0000:0001]\"");
+  }
+
+  @Test public void hostIpv6AddressTooManyGroups() throws Exception {
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0000:0001]\"");
+  }
+
+  @Test public void hostIpv6AddressTooMuchCompression() throws Exception {
+    assertInvalid("http://[0000::0000:0000:0000:0000::0001]",
+        "Invalid URL host: \"[0000::0000:0000:0000:0000::0001]\"");
+    assertInvalid("http://[::0000:0000:0000:0000::0001]",
+        "Invalid URL host: \"[::0000:0000:0000:0000::0001]\"");
+  }
+
+  @Test public void hostIpv6ScopedAddress() throws Exception {
+    // java.net.InetAddress parses scoped addresses. These aren't valid in URLs.
+    assertInvalid("http://[::1%2544]", "Invalid URL host: \"[::1%2544]\"");
+  }
+
+  @Test public void hostIpv6AddressTooManyLeadingZeros() throws Exception {
+    // Guava's been buggy on this case. https://github.com/google/guava/issues/3116
+    assertInvalid("http://[2001:db8:0:0:1:0:0:00001]",
+        "Invalid URL host: \"[2001:db8:0:0:1:0:0:00001]\"");
+  }
+
+  @Test public void hostIpv6WithIpv4Suffix() throws Exception {
+    assertThat(parse("http://[::1:255.255.255.255]/").host()).isEqualTo("::1:ffff:ffff");
+    assertThat(parse("http://[0:0:0:0:0:1:0.0.0.0]/").host()).isEqualTo("::1:0:0");
+  }
+
+  @Test public void hostIpv6WithIpv4SuffixWithOctalPrefix() throws Exception {
+    // Chrome interprets a leading '0' as octal; Firefox rejects them. (We reject them.)
+    assertInvalid("http://[0:0:0:0:0:1:0.0.0.000000]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.0.0.000000]\"");
+    assertInvalid("http://[0:0:0:0:0:1:0.010.0.010]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.010.0.010]\"");
+    assertInvalid("http://[0:0:0:0:0:1:0.0.0.000001]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.0.0.000001]\"");
+  }
+
+  @Test public void hostIpv6WithIpv4SuffixWithHexadecimalPrefix() throws Exception {
+    // Chrome interprets a leading '0x' as hexadecimal; Firefox rejects them. (We reject them.)
+    assertInvalid("http://[0:0:0:0:0:1:0.0x10.0.0x10]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.0x10.0.0x10]\"");
+  }
+
+  @Test public void hostIpv6WithMalformedIpv4Suffix() throws Exception {
+    assertInvalid("http://[0:0:0:0:0:1:0.0:0.0]/", "Invalid URL host: \"[0:0:0:0:0:1:0.0:0.0]\"");
+    assertInvalid("http://[0:0:0:0:0:1:0.0-0.0]/", "Invalid URL host: \"[0:0:0:0:0:1:0.0-0.0]\"");
+    assertInvalid("http://[0:0:0:0:0:1:.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:255..255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255..255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:255.255..255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255.255..255]\"");
+    assertInvalid("http://[0:0:0:0:0:0:1:255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:0:1:255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:256.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:256.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:ff.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:ff.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:0:1:255.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:0:1:255.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:1:255.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:1:255.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:1:0.0.0.0:1]/", "Invalid URL host: \"[0:0:0:0:1:0.0.0.0:1]\"");
+    assertInvalid("http://[0:0.0.0.0:1:0:0:0:0:1]/",
+        "Invalid URL host: \"[0:0.0.0.0:1:0:0:0:0:1]\"");
+    assertInvalid("http://[0.0.0.0:0:0:0:0:0:1]/", "Invalid URL host: \"[0.0.0.0:0:0:0:0:0:1]\"");
+  }
+
+  @Test public void hostIpv6WithIncompleteIpv4Suffix() throws Exception {
+    // To Chrome & Safari these are well-formed; Firefox disagrees. (We're consistent with Firefox).
+    assertInvalid("http://[0:0:0:0:0:1:255.255.255.]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255.255.255.]\"");
+    assertInvalid("http://[0:0:0:0:0:1:255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255.255.255]\"");
+  }
+
+  @Test public void hostIpv6Malformed() throws Exception {
+    assertInvalid("http://[::g]/", "Invalid URL host: \"[::g]\"");
+  }
+
+  @Test public void hostIpv6CanonicalForm() throws Exception {
+    assertThat(parse("http://[abcd:ef01:2345:6789:abcd:ef01:2345:6789]/").host())
+        .isEqualTo("abcd:ef01:2345:6789:abcd:ef01:2345:6789");
+    assertThat(parse("http://[a:0:0:0:b:0:0:0]/").host()).isEqualTo("a::b:0:0:0");
+    assertThat(parse("http://[a:b:0:0:c:0:0:0]/").host()).isEqualTo("a:b:0:0:c::");
+    assertThat(parse("http://[a:b:0:0:0:c:0:0]/").host()).isEqualTo("a:b::c:0:0");
+    assertThat(parse("http://[a:0:0:0:b:0:0:0]/").host()).isEqualTo("a::b:0:0:0");
+    assertThat(parse("http://[0:0:0:a:b:0:0:0]/").host()).isEqualTo("::a:b:0:0:0");
+    assertThat(parse("http://[0:0:0:a:0:0:0:b]/").host()).isEqualTo("::a:0:0:0:b");
+    assertThat(parse("http://[0:a:b:c:d:e:f:1]/").host()).isEqualTo("0:a:b:c:d:e:f:1");
+    assertThat(parse("http://[a:b:c:d:e:f:1:0]/").host()).isEqualTo("a:b:c:d:e:f:1:0");
+    assertThat(parse("http://[FF01:0:0:0:0:0:0:101]/").host()).isEqualTo("ff01::101");
+    assertThat(parse("http://[2001:db8::1]/").host()).isEqualTo("2001:db8::1");
+    assertThat(parse("http://[2001:db8:0:0:0:0:2:1]/").host()).isEqualTo("2001:db8::2:1");
+    assertThat(parse("http://[2001:db8:0:1:1:1:1:1]/").host())
+        .isEqualTo("2001:db8:0:1:1:1:1:1");
+    assertThat(parse("http://[2001:db8:0:0:1:0:0:1]/").host())
+        .isEqualTo("2001:db8::1:0:0:1");
+    assertThat(parse("http://[2001:0:0:1:0:0:0:1]/").host()).isEqualTo("2001:0:0:1::1");
+    assertThat(parse("http://[1:0:0:0:0:0:0:0]/").host()).isEqualTo("1::");
+    assertThat(parse("http://[0:0:0:0:0:0:0:1]/").host()).isEqualTo("::1");
+    assertThat(parse("http://[0:0:0:0:0:0:0:0]/").host()).isEqualTo("::");
+    assertThat(parse("http://[::ffff:c0a8:1fe]/").host()).isEqualTo("192.168.1.254");
+  }
+
+  /** The builder permits square braces but does not require them. */
+  @Test public void hostIpv6Builder() throws Exception {
+    HttpUrl base = parse("http://example.com/");
+    assertThat(base.newBuilder().host("[::1]").build().toString())
+        .isEqualTo("http://[::1]/");
+    assertThat(base.newBuilder().host("[::0001]").build().toString())
+        .isEqualTo("http://[::1]/");
+    assertThat(base.newBuilder().host("::1").build().toString()).isEqualTo("http://[::1]/");
+    assertThat(base.newBuilder().host("::0001").build().toString())
+        .isEqualTo("http://[::1]/");
+  }
+
+  @Test public void hostIpv4CanonicalForm() throws Exception {
+    assertThat(parse("http://255.255.255.255/").host()).isEqualTo("255.255.255.255");
+    assertThat(parse("http://1.2.3.4/").host()).isEqualTo("1.2.3.4");
+    assertThat(parse("http://0.0.0.0/").host()).isEqualTo("0.0.0.0");
+  }
+
+  @Test public void hostWithTrailingDot() throws Exception {
+    assertThat(parse("http://host./").host()).isEqualTo("host.");
+  }
+
+  @Test public void port() throws Exception {
+    assertThat(parse("http://host:80/")).isEqualTo(parse("http://host/"));
+    assertThat(parse("http://host:99/")).isEqualTo(parse("http://host:99/"));
+    assertThat(parse("http://host:/")).isEqualTo(parse("http://host/"));
+    assertThat(parse("http://host:65535/").port()).isEqualTo(65535);
+    assertInvalid("http://host:0/", "Invalid URL port: \"0\"");
+    assertInvalid("http://host:65536/", "Invalid URL port: \"65536\"");
+    assertInvalid("http://host:-1/", "Invalid URL port: \"-1\"");
+    assertInvalid("http://host:a/", "Invalid URL port: \"a\"");
+    assertInvalid("http://host:%39%39/", "Invalid URL port: \"%39%39\"");
+  }
+
+  @Test public void pathCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.PERCENT, '^', '{', '}', '|')
+        .override(Encoding.SKIP, '\\', '?', '#')
+        .skipForUri('%', '[', ']')
+        .test(Component.PATH);
+  }
+
+  @Test public void queryCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.IDENTITY, '?', '`')
+        .override(Encoding.PERCENT, '\'')
+        .override(Encoding.SKIP, '#', '+')
+        .skipForUri('%', '\\', '^', '`', '{', '|', '}')
+        .test(Component.QUERY);
+  }
+
+  @Test public void queryValueCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.IDENTITY, '?', '`')
+        .override(Encoding.PERCENT, '\'')
+        .override(Encoding.SKIP, '#', '+')
+        .skipForUri('%', '\\', '^', '`', '{', '|', '}')
+        .test(Component.QUERY_VALUE);
+  }
+
+  @Test public void fragmentCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.IDENTITY, ' ', '"', '#', '<', '>', '?', '`')
+        .skipForUri('%', ' ', '"', '#', '<', '>', '\\', '^', '`', '{', '|', '}')
+        .identityForNonAscii()
+        .test(Component.FRAGMENT);
+  }
+
+  @Test public void fragmentNonAscii() throws Exception {
+    HttpUrl url = parse("http://host/#Œ£");
+    assertThat(url.toString()).isEqualTo("http://host/#Œ£");
+    assertThat(url.fragment()).isEqualTo("Œ£");
+    assertThat(url.encodedFragment()).isEqualTo("Œ£");
+    assertThat(url.uri().toString()).isEqualTo("http://host/#Œ£");
+  }
+
+  @Test public void fragmentNonAsciiThatOffendsJavaNetUri() throws Exception {
+    HttpUrl url = parse("http://host/#\u0080");
+    assertThat(url.toString()).isEqualTo("http://host/#\u0080");
+    assertThat(url.fragment()).isEqualTo("\u0080");
+    assertThat(url.encodedFragment()).isEqualTo("\u0080");
+    // Control characters may be stripped!
+    assertThat(url.uri()).isEqualTo(new URI("http://host/#"));
+  }
+
+  @Test public void fragmentPercentEncodedNonAscii() throws Exception {
+    HttpUrl url = parse("http://host/#%C2%80");
+    assertThat(url.toString()).isEqualTo("http://host/#%C2%80");
+    assertThat(url.fragment()).isEqualTo("\u0080");
+    assertThat(url.encodedFragment()).isEqualTo("%C2%80");
+    assertThat(url.uri().toString()).isEqualTo("http://host/#%C2%80");
+  }
+
+  @Test public void fragmentPercentEncodedPartialCodePoint() throws Exception {
+    HttpUrl url = parse("http://host/#%80");
+    assertThat(url.toString()).isEqualTo("http://host/#%80");
+    // Unicode replacement character.
+    assertThat(url.fragment()).isEqualTo("\ufffd");
+    assertThat(url.encodedFragment()).isEqualTo("%80");
+    assertThat(url.uri().toString()).isEqualTo("http://host/#%80");
+  }
+
+  @Test public void relativePath() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.resolve("d/e/f")).isEqualTo(parse("http://host/a/b/d/e/f"));
+    assertThat(base.resolve("../../d/e/f")).isEqualTo(parse("http://host/d/e/f"));
+    assertThat(base.resolve("..")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve("../..")).isEqualTo(parse("http://host/"));
+    assertThat(base.resolve("../../..")).isEqualTo(parse("http://host/"));
+    assertThat(base.resolve(".")).isEqualTo(parse("http://host/a/b/"));
+    assertThat(base.resolve("././..")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve("c/d/../e/../")).isEqualTo(parse("http://host/a/b/c/"));
+    assertThat(base.resolve("..e/")).isEqualTo(parse("http://host/a/b/..e/"));
+    assertThat(base.resolve("e/f../")).isEqualTo(parse("http://host/a/b/e/f../"));
+    assertThat(base.resolve("%2E.")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve(".%2E")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve("%2E%2E")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve("%2e.")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve(".%2e")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve("%2e%2e")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve("%2E")).isEqualTo(parse("http://host/a/b/"));
+    assertThat(base.resolve("%2e")).isEqualTo(parse("http://host/a/b/"));
+  }
+
+  @Test public void relativePathWithTrailingSlash() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c/");
+    assertThat(base.resolve("..")).isEqualTo(parse("http://host/a/b/"));
+    assertThat(base.resolve("../")).isEqualTo(parse("http://host/a/b/"));
+    assertThat(base.resolve("../..")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve("../../")).isEqualTo(parse("http://host/a/"));
+    assertThat(base.resolve("../../..")).isEqualTo(parse("http://host/"));
+    assertThat(base.resolve("../../../")).isEqualTo(parse("http://host/"));
+    assertThat(base.resolve("../../../..")).isEqualTo(parse("http://host/"));
+    assertThat(base.resolve("../../../../")).isEqualTo(parse("http://host/"));
+    assertThat(base.resolve("../../../../a")).isEqualTo(parse("http://host/a"));
+    assertThat(base.resolve("../../../../a/..")).isEqualTo(parse("http://host/"));
+    assertThat(base.resolve("../../../../a/b/..")).isEqualTo(parse("http://host/a/"));
+  }
+
+  @Test public void pathWithBackslash() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.resolve("d\\e\\f")).isEqualTo(parse("http://host/a/b/d/e/f"));
+    assertThat(base.resolve("../..\\d\\e\\f")).isEqualTo(parse("http://host/d/e/f"));
+    assertThat(base.resolve("..\\..")).isEqualTo(parse("http://host/"));
+  }
+
+  @Test public void relativePathWithSameScheme() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.resolve("http:d/e/f")).isEqualTo(parse("http://host/a/b/d/e/f"));
+    assertThat(base.resolve("http:../../d/e/f")).isEqualTo(parse("http://host/d/e/f"));
+  }
+
+  @Test public void decodeUsername() {
+    assertThat(parse("http://user@host/").username()).isEqualTo("user");
+    assertThat(parse("http://%F0%9F%8D%A9@host/").username()).isEqualTo("\uD83C\uDF69");
+  }
+
+  @Test public void decodePassword() {
+    assertThat(parse("http://user:password@host/").password()).isEqualTo("password");
+    assertThat(parse("http://user:@host/").password()).isEqualTo("");
+    assertThat(parse("http://user:%F0%9F%8D%A9@host/").password())
+        .isEqualTo("\uD83C\uDF69");
+  }
+
+  @Test public void decodeSlashCharacterInDecodedPathSegment() {
+    assertThat(parse("http://host/a%2Fb%2Fc").pathSegments()).containsExactly("a/b/c");
+  }
+
+  @Test public void decodeEmptyPathSegments() {
+    assertThat(parse("http://host/").pathSegments()).containsExactly("");
+  }
+
+  @Test public void percentDecode() throws Exception {
+    assertThat(parse("http://host/%00").pathSegments()).containsExactly("\u0000");
+    assertThat(parse("http://host/a/%E2%98%83/c").pathSegments()).containsExactly("a", "\u2603", "c");
+    assertThat(parse("http://host/a/%F0%9F%8D%A9/c").pathSegments()).containsExactly("a", "\uD83C\uDF69", "c");
+    assertThat(parse("http://host/a/%62/c").pathSegments()).containsExactly("a", "b", "c");
+    assertThat(parse("http://host/a/%7A/c").pathSegments()).containsExactly("a", "z", "c");
+    assertThat(parse("http://host/a/%7a/c").pathSegments()).containsExactly("a", "z", "c");
+  }
+
+  @Test public void malformedPercentEncoding() {
+    assertThat(parse("http://host/a%f/b").pathSegments()).containsExactly("a%f", "b");
+    assertThat(parse("http://host/%/b").pathSegments()).containsExactly("%", "b");
+    assertThat(parse("http://host/%").pathSegments()).containsExactly("%");
+    assertThat(parse("http://github.com/%%30%30").pathSegments()).containsExactly("%00");
+  }
+
+  @Test public void malformedUtf8Encoding() {
+    // Replace a partial UTF-8 sequence with the Unicode replacement character.
+    assertThat(parse("http://host/a/%E2%98x/c").pathSegments())
+        .containsExactly("a", "\ufffdx", "c");
+  }
+
+  @Test public void incompleteUrlComposition() throws Exception {
+    try {
+      new HttpUrl.Builder().scheme("http").build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertThat(expected.getMessage()).isEqualTo("host == null");
+    }
+    try {
+      new HttpUrl.Builder().host("host").build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertThat(expected.getMessage()).isEqualTo("scheme == null");
+    }
+  }
+
+  @Test public void builderToString() {
+    assertThat(parse("https://host.com/path").newBuilder().toString())
+        .isEqualTo("https://host.com/path");
+  }
+
+  @Test public void incompleteBuilderToString() {
+    assertThat(new HttpUrl.Builder().scheme("https").encodedPath("/path").toString())
+        .isEqualTo("https:///path");
+    assertThat(new HttpUrl.Builder().host("host.com").encodedPath("/path").toString())
+        .isEqualTo("//host.com/path");
+    assertThat(new HttpUrl.Builder().host("host.com").encodedPath("/path").port(8080).toString())
+        .isEqualTo("//host.com:8080/path");
+  }
+
+  @Test public void minimalUrlComposition() throws Exception {
+    HttpUrl url = new HttpUrl.Builder().scheme("http").host("host").build();
+    assertThat(url.toString()).isEqualTo("http://host/");
+    assertThat(url.scheme()).isEqualTo("http");
+    assertThat(url.username()).isEqualTo("");
+    assertThat(url.password()).isEqualTo("");
+    assertThat(url.host()).isEqualTo("host");
+    assertThat(url.port()).isEqualTo(80);
+    assertThat(url.encodedPath()).isEqualTo("/");
+    assertThat(url.query()).isNull();
+    assertThat(url.fragment()).isNull();
+  }
+
+  @Test public void fullUrlComposition() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("username")
+        .password("password")
+        .host("host")
+        .port(8080)
+        .addPathSegment("path")
+        .query("query")
+        .fragment("fragment")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo("http://username:password@host:8080/path?query#fragment");
+    assertThat(url.scheme()).isEqualTo("http");
+    assertThat(url.username()).isEqualTo("username");
+    assertThat(url.password()).isEqualTo("password");
+    assertThat(url.host()).isEqualTo("host");
+    assertThat(url.port()).isEqualTo(8080);
+    assertThat(url.encodedPath()).isEqualTo("/path");
+    assertThat(url.query()).isEqualTo("query");
+    assertThat(url.fragment()).isEqualTo("fragment");
+  }
+
+  @Test public void changingSchemeChangesDefaultPort() throws Exception {
+    assertThat(parse("http://example.com")
+        .newBuilder()
+        .scheme("https")
+        .build().port()).isEqualTo(443);
+
+    assertThat(parse("https://example.com")
+        .newBuilder()
+        .scheme("http")
+        .build().port()).isEqualTo(80);
+
+    assertThat(parse("https://example.com:1234")
+        .newBuilder()
+        .scheme("http")
+        .build().port()).isEqualTo(1234);
+  }
+
+  @Test public void composeEncodesWhitespace() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("a\r\n\f\t b")
+        .password("c\r\n\f\t d")
+        .host("host")
+        .addPathSegment("e\r\n\f\t f")
+        .query("g\r\n\f\t h")
+        .fragment("i\r\n\f\t j")
+        .build();
+    assertThat(url.toString()).isEqualTo(("http://a%0D%0A%0C%09%20b:c%0D%0A%0C%09%20d@host"
+        + "/e%0D%0A%0C%09%20f?g%0D%0A%0C%09%20h#i%0D%0A%0C%09 j"));
+    assertThat(url.username()).isEqualTo("a\r\n\f\t b");
+    assertThat(url.password()).isEqualTo("c\r\n\f\t d");
+    assertThat(url.pathSegments().get(0)).isEqualTo("e\r\n\f\t f");
+    assertThat(url.query()).isEqualTo("g\r\n\f\t h");
+    assertThat(url.fragment()).isEqualTo("i\r\n\f\t j");
+  }
+
+  @Test public void composeFromUnencodedComponents() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("a:\u0001@/\\?#%b")
+        .password("c:\u0001@/\\?#%d")
+        .host("ef")
+        .port(8080)
+        .addPathSegment("g:\u0001@/\\?#%h")
+        .query("i:\u0001@/\\?#%j")
+        .fragment("k:\u0001@/\\?#%l")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo(("http://a%3A%01%40%2F%5C%3F%23%25b:c%3A%01%40%2F%5C%3F%23%25d@ef:8080/"
+        + "g:%01@%2F%5C%3F%23%25h?i:%01@/\\?%23%25j#k:%01@/\\?#%25l"));
+    assertThat(url.scheme()).isEqualTo("http");
+    assertThat(url.username()).isEqualTo("a:\u0001@/\\?#%b");
+    assertThat(url.password()).isEqualTo("c:\u0001@/\\?#%d");
+    assertThat(url.pathSegments()).containsExactly("g:\u0001@/\\?#%h");
+    assertThat(url.query()).isEqualTo("i:\u0001@/\\?#%j");
+    assertThat(url.fragment()).isEqualTo("k:\u0001@/\\?#%l");
+    assertThat(url.encodedUsername()).isEqualTo("a%3A%01%40%2F%5C%3F%23%25b");
+    assertThat(url.encodedPassword()).isEqualTo("c%3A%01%40%2F%5C%3F%23%25d");
+    assertThat(url.encodedPath()).isEqualTo("/g:%01@%2F%5C%3F%23%25h");
+    assertThat(url.encodedQuery()).isEqualTo("i:%01@/\\?%23%25j");
+    assertThat(url.encodedFragment()).isEqualTo("k:%01@/\\?#%25l");
+  }
+
+  @Test public void composeFromEncodedComponents() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .encodedUsername("a:\u0001@/\\?#%25b")
+        .encodedPassword("c:\u0001@/\\?#%25d")
+        .host("ef")
+        .port(8080)
+        .addEncodedPathSegment("g:\u0001@/\\?#%25h")
+        .encodedQuery("i:\u0001@/\\?#%25j")
+        .encodedFragment("k:\u0001@/\\?#%25l")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo(("http://a%3A%01%40%2F%5C%3F%23%25b:c%3A%01%40%2F%5C%3F%23%25d@ef:8080/"
+        + "g:%01@%2F%5C%3F%23%25h?i:%01@/\\?%23%25j#k:%01@/\\?#%25l"));
+    assertThat(url.scheme()).isEqualTo("http");
+    assertThat(url.username()).isEqualTo("a:\u0001@/\\?#%b");
+    assertThat(url.password()).isEqualTo("c:\u0001@/\\?#%d");
+    assertThat(url.pathSegments()).containsExactly("g:\u0001@/\\?#%h");
+    assertThat(url.query()).isEqualTo("i:\u0001@/\\?#%j");
+    assertThat(url.fragment()).isEqualTo("k:\u0001@/\\?#%l");
+    assertThat(url.encodedUsername()).isEqualTo("a%3A%01%40%2F%5C%3F%23%25b");
+    assertThat(url.encodedPassword()).isEqualTo("c%3A%01%40%2F%5C%3F%23%25d");
+    assertThat(url.encodedPath()).isEqualTo("/g:%01@%2F%5C%3F%23%25h");
+    assertThat(url.encodedQuery()).isEqualTo("i:%01@/\\?%23%25j");
+    assertThat(url.encodedFragment()).isEqualTo("k:%01@/\\?#%25l");
+  }
+
+  @Test public void composeWithEncodedPath() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .encodedPath("/a%2Fb/c")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/a%2Fb/c");
+    assertThat(url.encodedPath()).isEqualTo("/a%2Fb/c");
+    assertThat(url.pathSegments()).containsExactly("a/b", "c");
+  }
+
+  @Test public void composeMixingPathSegments() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .encodedPath("/a%2fb/c")
+        .addPathSegment("d%25e")
+        .addEncodedPathSegment("f%25g")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/a%2fb/c/d%2525e/f%25g");
+    assertThat(url.encodedPath()).isEqualTo("/a%2fb/c/d%2525e/f%25g");
+    assertThat(url.encodedPathSegments()).containsExactly("a%2fb", "c", "d%2525e", "f%25g");
+    assertThat(url.pathSegments()).containsExactly("a/b", "c", "d%25e", "f%g");
+  }
+
+  @Test public void composeWithAddSegment() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().addPathSegment("").build().encodedPath())
+        .isEqualTo("/a/b/c/");
+    assertThat(base.newBuilder().addPathSegment("").addPathSegment("d").build().encodedPath())
+        .isEqualTo("/a/b/c/d");
+    assertThat(base.newBuilder().addPathSegment("..").build().encodedPath())
+        .isEqualTo("/a/b/");
+    assertThat(base.newBuilder().addPathSegment("").addPathSegment("..").build().encodedPath())
+        .isEqualTo("/a/b/");
+    assertThat(base.newBuilder().addPathSegment("").addPathSegment("").build().encodedPath())
+        .isEqualTo("/a/b/c/");
+  }
+
+  @Test public void pathSize() throws Exception {
+    assertThat(parse("http://host/").pathSize()).isEqualTo(1);
+    assertThat(parse("http://host/a/b/c").pathSize()).isEqualTo(3);
+  }
+
+  @Test public void addPathSegments() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+
+    // Add a string with zero slashes: resulting URL gains one slash.
+    assertThat(base.newBuilder().addPathSegments("").build().encodedPath())
+        .isEqualTo("/a/b/c/");
+    assertThat(base.newBuilder().addPathSegments("d").build().encodedPath())
+        .isEqualTo("/a/b/c/d");
+
+    // Add a string with one slash: resulting URL gains two slashes.
+    assertThat(base.newBuilder().addPathSegments("/").build().encodedPath())
+        .isEqualTo("/a/b/c//");
+    assertThat(base.newBuilder().addPathSegments("d/").build().encodedPath())
+        .isEqualTo("/a/b/c/d/");
+    assertThat(base.newBuilder().addPathSegments("/d").build().encodedPath())
+        .isEqualTo("/a/b/c//d");
+
+    // Add a string with two slashes: resulting URL gains three slashes.
+    assertThat(base.newBuilder().addPathSegments("//").build().encodedPath())
+        .isEqualTo("/a/b/c///");
+    assertThat(base.newBuilder().addPathSegments("/d/").build().encodedPath())
+        .isEqualTo("/a/b/c//d/");
+    assertThat(base.newBuilder().addPathSegments("d//").build().encodedPath())
+        .isEqualTo("/a/b/c/d//");
+    assertThat(base.newBuilder().addPathSegments("//d").build().encodedPath())
+        .isEqualTo("/a/b/c///d");
+    assertThat(base.newBuilder().addPathSegments("d/e/f").build().encodedPath())
+        .isEqualTo("/a/b/c/d/e/f");
+  }
+
+  @Test public void addPathSegmentsOntoTrailingSlash() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c/");
+
+    // Add a string with zero slashes: resulting URL gains zero slashes.
+    assertThat(base.newBuilder().addPathSegments("").build().encodedPath())
+        .isEqualTo("/a/b/c/");
+    assertThat(base.newBuilder().addPathSegments("d").build().encodedPath())
+        .isEqualTo("/a/b/c/d");
+
+    // Add a string with one slash: resulting URL gains one slash.
+    assertThat(base.newBuilder().addPathSegments("/").build().encodedPath())
+        .isEqualTo("/a/b/c//");
+    assertThat(base.newBuilder().addPathSegments("d/").build().encodedPath())
+        .isEqualTo("/a/b/c/d/");
+    assertThat(base.newBuilder().addPathSegments("/d").build().encodedPath())
+        .isEqualTo("/a/b/c//d");
+
+    // Add a string with two slashes: resulting URL gains two slashes.
+    assertThat(base.newBuilder().addPathSegments("//").build().encodedPath())
+        .isEqualTo("/a/b/c///");
+    assertThat(base.newBuilder().addPathSegments("/d/").build().encodedPath())
+        .isEqualTo("/a/b/c//d/");
+    assertThat(base.newBuilder().addPathSegments("d//").build().encodedPath())
+        .isEqualTo("/a/b/c/d//");
+    assertThat(base.newBuilder().addPathSegments("//d").build().encodedPath())
+        .isEqualTo("/a/b/c///d");
+    assertThat(base.newBuilder().addPathSegments("d/e/f").build().encodedPath())
+        .isEqualTo("/a/b/c/d/e/f");
+  }
+
+  @Test public void addPathSegmentsWithBackslash() throws Exception {
+    HttpUrl base = parse("http://host/");
+    assertThat(base.newBuilder().addPathSegments("d\\e").build().encodedPath())
+        .isEqualTo("/d/e");
+    assertThat(base.newBuilder().addEncodedPathSegments("d\\e").build().encodedPath())
+        .isEqualTo("/d/e");
+  }
+
+  @Test public void addPathSegmentsWithEmptyPaths() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().addPathSegments("/d/e///f").build().encodedPath())
+        .isEqualTo("/a/b/c//d/e///f");
+  }
+
+  @Test public void addEncodedPathSegments() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(
+        (Object) base.newBuilder().addEncodedPathSegments("d/e/%20/\n").build().encodedPath())
+        .isEqualTo("/a/b/c/d/e/%20/");
+  }
+
+  @Test public void addPathSegmentDotDoesNothing() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().addPathSegment(".").build().encodedPath())
+        .isEqualTo("/a/b/c");
+  }
+
+  @Test public void addPathSegmentEncodes() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().addPathSegment("%2e").build().encodedPath())
+        .isEqualTo("/a/b/c/%252e");
+    assertThat(base.newBuilder().addPathSegment("%2e%2e").build().encodedPath())
+        .isEqualTo("/a/b/c/%252e%252e");
+  }
+
+  @Test public void addPathSegmentDotDotPopsDirectory() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().addPathSegment("..").build().encodedPath())
+        .isEqualTo("/a/b/");
+  }
+
+  @Test public void addPathSegmentDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().addPathSegment(".\n").build().encodedPath())
+        .isEqualTo("/a/b/c/.%0A");
+  }
+
+  @Test public void addEncodedPathSegmentDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().addEncodedPathSegment(".\n").build().encodedPath())
+        .isEqualTo("/a/b/c");
+  }
+
+  @Test public void addEncodedPathSegmentDotDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().addEncodedPathSegment("..\n").build().encodedPath())
+        .isEqualTo("/a/b/");
+  }
+
+  @Test public void setPathSegment() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().setPathSegment(0, "d").build().encodedPath())
+        .isEqualTo("/d/b/c");
+    assertThat(base.newBuilder().setPathSegment(1, "d").build().encodedPath())
+        .isEqualTo("/a/d/c");
+    assertThat(base.newBuilder().setPathSegment(2, "d").build().encodedPath())
+        .isEqualTo("/a/b/d");
+  }
+
+  @Test public void setPathSegmentEncodes() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().setPathSegment(0, "%25").build().encodedPath())
+        .isEqualTo("/%2525/b/c");
+    assertThat(base.newBuilder().setPathSegment(0, ".\n").build().encodedPath())
+        .isEqualTo("/.%0A/b/c");
+    assertThat(base.newBuilder().setPathSegment(0, "%2e").build().encodedPath())
+        .isEqualTo("/%252e/b/c");
+  }
+
+  @Test public void setPathSegmentAcceptsEmpty() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().setPathSegment(0, "").build().encodedPath())
+        .isEqualTo("//b/c");
+    assertThat(base.newBuilder().setPathSegment(2, "").build().encodedPath())
+        .isEqualTo("/a/b/");
+  }
+
+  @Test public void setPathSegmentRejectsDot() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setPathSegment(0, ".");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setPathSegmentRejectsDotDot() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setPathSegment(0, "..");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setPathSegmentWithSlash() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder().setPathSegment(1, "/").build();
+    assertThat(url.encodedPath()).isEqualTo("/a/%2F/c");
+  }
+
+  @Test public void setPathSegmentOutOfBounds() throws Exception {
+    try {
+      new HttpUrl.Builder().setPathSegment(1, "a");
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentEncodes() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    assertThat(base.newBuilder().setEncodedPathSegment(0, "%25").build().encodedPath())
+        .isEqualTo("/%25/b/c");
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDot() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, ".");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, ".\n");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDotDot() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, "..");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentRejectsDotDotAndIgnoredCharacter() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    try {
+      base.newBuilder().setEncodedPathSegment(0, "..\n");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setEncodedPathSegmentWithSlash() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder().setEncodedPathSegment(1, "/").build();
+    assertThat(url.encodedPath()).isEqualTo("/a/%2F/c");
+  }
+
+  @Test public void setEncodedPathSegmentOutOfBounds() throws Exception {
+    try {
+      new HttpUrl.Builder().setEncodedPathSegment(1, "a");
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void removePathSegment() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder()
+        .removePathSegment(0)
+        .build();
+    assertThat(url.encodedPath()).isEqualTo("/b/c");
+  }
+
+  @Test public void removePathSegmentDoesntRemovePath() throws Exception {
+    HttpUrl base = parse("http://host/a/b/c");
+    HttpUrl url = base.newBuilder()
+        .removePathSegment(0)
+        .removePathSegment(0)
+        .removePathSegment(0)
+        .build();
+    assertThat(url.pathSegments()).containsExactly("");
+    assertThat(url.encodedPath()).isEqualTo("/");
+  }
+
+  @Test public void removePathSegmentOutOfBounds() throws Exception {
+    try {
+      new HttpUrl.Builder().removePathSegment(1);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void toJavaNetUrl() throws Exception {
+    HttpUrl httpUrl = parse("http://username:password@host/path?query#fragment");
+    URL javaNetUrl = httpUrl.url();
+    assertThat(javaNetUrl.toString())
+        .isEqualTo("http://username:password@host/path?query#fragment");
+  }
+
+  @Test public void toUri() throws Exception {
+    HttpUrl httpUrl = parse("http://username:password@host/path?query#fragment");
+    URI uri = httpUrl.uri();
+    assertThat(uri.toString())
+        .isEqualTo("http://username:password@host/path?query#fragment");
+  }
+
+  @Test public void toUriSpecialQueryCharacters() throws Exception {
+    HttpUrl httpUrl = parse("http://host/?d=abc!@[]^`{}|\\");
+    URI uri = httpUrl.uri();
+    assertThat(uri.toString()).isEqualTo("http://host/?d=abc!@[]%5E%60%7B%7D%7C%5C");
+  }
+
+  @Test public void toUriWithUsernameNoPassword() throws Exception {
+    HttpUrl httpUrl = new HttpUrl.Builder()
+        .scheme("http")
+        .username("user")
+        .host("host")
+        .build();
+    assertThat(httpUrl.toString()).isEqualTo("http://user@host/");
+    assertThat(httpUrl.uri().toString()).isEqualTo("http://user@host/");
+  }
+
+  @Test public void toUriUsernameSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .username("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo("http://%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/");
+    assertThat(url.uri().toString())
+        .isEqualTo("http://%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/");
+  }
+
+  @Test public void toUriPasswordSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .username("user")
+        .password("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo("http://user:%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/");
+    assertThat(url.uri().toString())
+        .isEqualTo("http://user:%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/");
+  }
+
+  @Test public void toUriPathSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addPathSegment("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/=[]:;%22~%7C%3F%23@%5E%2F$%25*");
+    assertThat(url.uri().toString())
+        .isEqualTo("http://host/=%5B%5D:;%22~%7C%3F%23@%5E%2F$%25*");
+  }
+
+  @Test public void toUriQueryParameterNameSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addQueryParameter("=[]:;\"~|?#@^/$%*", "a")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo("http://host/?%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*=a");
+    assertThat(url.uri().toString())
+        .isEqualTo("http://host/?%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*=a");
+    assertThat(url.queryParameter("=[]:;\"~|?#@^/$%*")).isEqualTo("a");
+  }
+
+  @Test public void toUriQueryParameterValueSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addQueryParameter("a", "=[]:;\"~|?#@^/$%*")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo("http://host/?a=%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*");
+    assertThat(url.uri().toString())
+        .isEqualTo("http://host/?a=%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*");
+    assertThat(url.queryParameter("a")).isEqualTo("=[]:;\"~|?#@^/$%*");
+  }
+
+  @Test public void toUriQueryValueSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .query("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/?=[]:;%22~|?%23@^/$%25*");
+    assertThat(url.uri().toString()).isEqualTo("http://host/?=[]:;%22~%7C?%23@%5E/$%25*");
+  }
+
+  @Test public void queryCharactersEncodedWhenComposed() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo("http://host/?a=%21%24%28%29%2C%2F%3A%3B%3F%40%5B%5D%5C%5E%60%7B%7C%7D%7E");
+    assertThat(url.queryParameter("a")).isEqualTo("!$(),/:;?@[]\\^`{|}~");
+  }
+
+  /**
+   * When callers use {@code addEncodedQueryParameter()} we only encode what's strictly required.
+   * We retain the encoded (or non-encoded) state of the input.
+   */
+  @Test public void queryCharactersNotReencodedWhenComposedWithAddEncoded() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addEncodedQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/?a=!$(),/:;?@[]\\^`{|}~");
+    assertThat(url.queryParameter("a")).isEqualTo("!$(),/:;?@[]\\^`{|}~");
+  }
+
+  /**
+   * When callers parse a URL with query components that aren't encoded, we shouldn't convert them
+   * into a canonical form because doing so could be semantically different.
+   */
+  @Test public void queryCharactersNotReencodedWhenParsed() throws Exception {
+    HttpUrl url = parse("http://host/?a=!$(),/:;?@[]\\^`{|}~");
+    assertThat(url.toString()).isEqualTo("http://host/?a=!$(),/:;?@[]\\^`{|}~");
+    assertThat(url.queryParameter("a")).isEqualTo("!$(),/:;?@[]\\^`{|}~");
+  }
+
+  @Test public void toUriFragmentSpecialCharacters() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .fragment("=[]:;\"~|?#@^/$%*")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/#=[]:;\"~|?#@^/$%25*");
+    assertThat(url.uri().toString()).isEqualTo("http://host/#=[]:;%22~%7C?%23@%5E/$%25*");
+  }
+
+  @Test public void toUriWithControlCharacters() throws Exception {
+    // Percent-encoded in the path.
+    assertThat(parse("http://host/a\u0000b").uri()).isEqualTo(new URI("http://host/a%00b"));
+    assertThat(parse("http://host/a\u0080b").uri())
+        .isEqualTo(new URI("http://host/a%C2%80b"));
+    assertThat(parse("http://host/a\u009fb").uri())
+        .isEqualTo(new URI("http://host/a%C2%9Fb"));
+    // Percent-encoded in the query.
+    assertThat(parse("http://host/?a\u0000b").uri())
+        .isEqualTo(new URI("http://host/?a%00b"));
+    assertThat(parse("http://host/?a\u0080b").uri())
+        .isEqualTo(new URI("http://host/?a%C2%80b"));
+    assertThat(parse("http://host/?a\u009fb").uri())
+        .isEqualTo(new URI("http://host/?a%C2%9Fb"));
+    // Stripped from the fragment.
+    assertThat(parse("http://host/#a\u0000b").uri())
+        .isEqualTo(new URI("http://host/#a%00b"));
+    assertThat(parse("http://host/#a\u0080b").uri()).isEqualTo(new URI("http://host/#ab"));
+    assertThat(parse("http://host/#a\u009fb").uri()).isEqualTo(new URI("http://host/#ab"));
+  }
+
+  @Test public void toUriWithSpaceCharacters() throws Exception {
+    // Percent-encoded in the path.
+    assertThat(parse("http://host/a\u000bb").uri()).isEqualTo(new URI("http://host/a%0Bb"));
+    assertThat(parse("http://host/a b").uri()).isEqualTo(new URI("http://host/a%20b"));
+    assertThat(parse("http://host/a\u2009b").uri())
+        .isEqualTo(new URI("http://host/a%E2%80%89b"));
+    assertThat(parse("http://host/a\u3000b").uri())
+        .isEqualTo(new URI("http://host/a%E3%80%80b"));
+    // Percent-encoded in the query.
+    assertThat(parse("http://host/?a\u000bb").uri())
+        .isEqualTo(new URI("http://host/?a%0Bb"));
+    assertThat(parse("http://host/?a b").uri()).isEqualTo(new URI("http://host/?a%20b"));
+    assertThat(parse("http://host/?a\u2009b").uri())
+        .isEqualTo(new URI("http://host/?a%E2%80%89b"));
+    assertThat(parse("http://host/?a\u3000b").uri())
+        .isEqualTo(new URI("http://host/?a%E3%80%80b"));
+    // Stripped from the fragment.
+    assertThat(parse("http://host/#a\u000bb").uri())
+        .isEqualTo(new URI("http://host/#a%0Bb"));
+    assertThat(parse("http://host/#a b").uri()).isEqualTo(new URI("http://host/#a%20b"));
+    assertThat(parse("http://host/#a\u2009b").uri()).isEqualTo(new URI("http://host/#ab"));
+    assertThat(parse("http://host/#a\u3000b").uri()).isEqualTo(new URI("http://host/#ab"));
+  }
+
+  @Test public void toUriWithNonHexPercentEscape() throws Exception {
+    assertThat(parse("http://host/%xx").uri()).isEqualTo(new URI("http://host/%25xx"));
+  }
+
+  @Test public void toUriWithTruncatedPercentEscape() throws Exception {
+    assertThat(parse("http://host/%a").uri()).isEqualTo(new URI("http://host/%25a"));
+    assertThat(parse("http://host/%").uri()).isEqualTo(new URI("http://host/%25"));
+  }
+
+  @Test public void fromJavaNetUrl() throws Exception {
+    URL javaNetUrl = new URL("http://username:password@host/path?query#fragment");
+    HttpUrl httpUrl = HttpUrl.get(javaNetUrl);
+    assertThat(httpUrl.toString())
+        .isEqualTo("http://username:password@host/path?query#fragment");
+  }
+
+  @Test public void fromJavaNetUrlUnsupportedScheme() throws Exception {
+    URL javaNetUrl = new URL("mailto:user@example.com");
+    assertThat(HttpUrl.get(javaNetUrl)).isNull();
+  }
+
+  @Test public void fromUri() throws Exception {
+    URI uri = new URI("http://username:password@host/path?query#fragment");
+    HttpUrl httpUrl = HttpUrl.get(uri);
+    assertThat(httpUrl.toString())
+        .isEqualTo("http://username:password@host/path?query#fragment");
+  }
+
+  @Test public void fromUriUnsupportedScheme() throws Exception {
+    URI uri = new URI("mailto:user@example.com");
+    assertThat(HttpUrl.get(uri)).isNull();
+  }
+
+  @Test public void fromUriPartial() throws Exception {
+    URI uri = new URI("/path");
+    assertThat(HttpUrl.get(uri)).isNull();
+  }
+
+  @Test public void composeQueryWithComponents() throws Exception {
+    HttpUrl base = parse("http://host/");
+    HttpUrl url = base.newBuilder().addQueryParameter("a+=& b", "c+=& d").build();
+    assertThat(url.toString()).isEqualTo("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d");
+    assertThat(url.queryParameterValue(0)).isEqualTo("c+=& d");
+    assertThat(url.queryParameterName(0)).isEqualTo("a+=& b");
+    assertThat(url.queryParameter("a+=& b")).isEqualTo("c+=& d");
+    assertThat(url.queryParameterNames()).isEqualTo(Collections.singleton("a+=& b"));
+    assertThat(url.queryParameterValues("a+=& b")).isEqualTo(singletonList("c+=& d"));
+    assertThat(url.querySize()).isEqualTo(1);
+    // Ambiguous! (Though working as designed.)
+    assertThat(url.query()).isEqualTo("a+=& b=c+=& d");
+    assertThat(url.encodedQuery()).isEqualTo("a%2B%3D%26%20b=c%2B%3D%26%20d");
+  }
+
+  @Test public void composeQueryWithEncodedComponents() throws Exception {
+    HttpUrl base = parse("http://host/");
+    HttpUrl url = base.newBuilder().addEncodedQueryParameter("a+=& b", "c+=& d").build();
+    assertThat(url.toString()).isEqualTo("http://host/?a+%3D%26%20b=c+%3D%26%20d");
+    assertThat(url.queryParameter("a =& b")).isEqualTo("c =& d");
+  }
+
+  @Test public void composeQueryRemoveQueryParameter() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .addQueryParameter("a+=& b", "c+=& d")
+        .removeAllQueryParameters("a+=& b")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/");
+    assertThat(url.queryParameter("a+=& b")).isNull();
+  }
+
+  @Test public void composeQueryRemoveEncodedQueryParameter() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .addEncodedQueryParameter("a+=& b", "c+=& d")
+        .removeAllEncodedQueryParameters("a+=& b")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/");
+    assertThat(url.queryParameter("a =& b")).isNull();
+  }
+
+  @Test public void composeQuerySetQueryParameter() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .addQueryParameter("a+=& b", "c+=& d")
+        .setQueryParameter("a+=& b", "ef")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/?a%2B%3D%26%20b=ef");
+    assertThat(url.queryParameter("a+=& b")).isEqualTo("ef");
+  }
+
+  @Test public void composeQuerySetEncodedQueryParameter() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .addEncodedQueryParameter("a+=& b", "c+=& d")
+        .setEncodedQueryParameter("a+=& b", "ef")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/?a+%3D%26%20b=ef");
+    assertThat(url.queryParameter("a =& b")).isEqualTo("ef");
+  }
+
+  @Test public void composeQueryMultipleEncodedValuesForParameter() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .addQueryParameter("a+=& b", "c+=& d")
+        .addQueryParameter("a+=& b", "e+=& f")
+        .build();
+    assertThat(url.toString())
+        .isEqualTo("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d&a%2B%3D%26%20b=e%2B%3D%26%20f");
+    assertThat(url.querySize()).isEqualTo(2);
+    assertThat(url.queryParameterNames()).isEqualTo(Collections.singleton("a+=& b"));
+    assertThat(url.queryParameterValues("a+=& b")).containsExactly("c+=& d", "e+=& f");
+  }
+
+  @Test public void absentQueryIsZeroNameValuePairs() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .query(null)
+        .build();
+    assertThat(url.querySize()).isEqualTo(0);
+  }
+
+  @Test public void emptyQueryIsSingleNameValuePairWithEmptyKey() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .query("")
+        .build();
+    assertThat(url.querySize()).isEqualTo(1);
+    assertThat(url.queryParameterName(0)).isEqualTo("");
+    assertThat(url.queryParameterValue(0)).isNull();
+  }
+
+  @Test public void ampersandQueryIsTwoNameValuePairsWithEmptyKeys() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .query("&")
+        .build();
+    assertThat(url.querySize()).isEqualTo(2);
+    assertThat(url.queryParameterName(0)).isEqualTo("");
+    assertThat(url.queryParameterValue(0)).isNull();
+    assertThat(url.queryParameterName(1)).isEqualTo("");
+    assertThat(url.queryParameterValue(1)).isNull();
+  }
+
+  @Test public void removeAllDoesNotRemoveQueryIfNoParametersWereRemoved() throws Exception {
+    HttpUrl url = parse("http://host/").newBuilder()
+        .query("")
+        .removeAllQueryParameters("a")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/?");
+  }
+
+  @Test public void queryParametersWithoutValues() throws Exception {
+    HttpUrl url = parse("http://host/?foo&bar&baz");
+    assertThat(url.querySize()).isEqualTo(3);
+    assertThat(url.queryParameterNames()).containsExactly("foo", "bar", "baz");
+    assertThat(url.queryParameterValue(0)).isNull();
+    assertThat(url.queryParameterValue(1)).isNull();
+    assertThat(url.queryParameterValue(2)).isNull();
+    assertThat(url.queryParameterValues("foo")).isEqualTo(singletonList((String) null));
+    assertThat(url.queryParameterValues("bar")).isEqualTo(singletonList((String) null));
+    assertThat(url.queryParameterValues("baz")).isEqualTo(singletonList((String) null));
+  }
+
+  @Test public void queryParametersWithEmptyValues() throws Exception {
+    HttpUrl url = parse("http://host/?foo=&bar=&baz=");
+    assertThat(url.querySize()).isEqualTo(3);
+    assertThat(url.queryParameterNames()).containsExactly("foo", "bar", "baz");
+    assertThat(url.queryParameterValue(0)).isEqualTo("");
+    assertThat(url.queryParameterValue(1)).isEqualTo("");
+    assertThat(url.queryParameterValue(2)).isEqualTo("");
+    assertThat(url.queryParameterValues("foo")).isEqualTo(singletonList(""));
+    assertThat(url.queryParameterValues("bar")).isEqualTo(singletonList(""));
+    assertThat(url.queryParameterValues("baz")).isEqualTo(singletonList(""));
+  }
+
+  @Test public void queryParametersWithRepeatedName() throws Exception {
+    HttpUrl url = parse("http://host/?foo[]=1&foo[]=2&foo[]=3");
+    assertThat(url.querySize()).isEqualTo(3);
+    assertThat(url.queryParameterNames()).isEqualTo(Collections.singleton("foo[]"));
+    assertThat(url.queryParameterValue(0)).isEqualTo("1");
+    assertThat(url.queryParameterValue(1)).isEqualTo("2");
+    assertThat(url.queryParameterValue(2)).isEqualTo("3");
+    assertThat(url.queryParameterValues("foo[]")).containsExactly("1", "2", "3");
+  }
+
+  @Test public void queryParameterLookupWithNonCanonicalEncoding() throws Exception {
+    HttpUrl url = parse("http://host/?%6d=m&+=%20");
+    assertThat(url.queryParameterName(0)).isEqualTo("m");
+    assertThat(url.queryParameterName(1)).isEqualTo(" ");
+    assertThat(url.queryParameter("m")).isEqualTo("m");
+    assertThat(url.queryParameter(" ")).isEqualTo(" ");
+  }
+
+  @Test public void parsedQueryDoesntIncludeFragment() {
+    HttpUrl url = parse("http://host/?#fragment");
+    assertThat(url.fragment()).isEqualTo("fragment");
+    assertThat(url.query()).isEqualTo("");
+    assertThat(url.encodedQuery()).isEqualTo("");
+  }
+
+  @Test public void roundTripBuilder() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .username("%")
+        .password("%")
+        .host("host")
+        .addPathSegment("%")
+        .query("%")
+        .fragment("%")
+        .build();
+    assertThat(url.toString()).isEqualTo("http://%25:%25@host/%25?%25#%25");
+    assertThat(url.newBuilder().build().toString())
+        .isEqualTo("http://%25:%25@host/%25?%25#%25");
+    assertThat(url.resolve("").toString()).isEqualTo("http://%25:%25@host/%25?%25");
+  }
+
+  /**
+   * Although HttpUrl prefers percent-encodings in uppercase, it should preserve the exact structure
+   * of the original encoding.
+   */
+  @Test public void rawEncodingRetained() throws Exception {
+    String urlString = "http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D#%6d%6D";
+    HttpUrl url = parse(urlString);
+    assertThat(url.encodedUsername()).isEqualTo("%6d%6D");
+    assertThat(url.encodedPassword()).isEqualTo("%6d%6D");
+    assertThat(url.encodedPath()).isEqualTo("/%6d%6D");
+    assertThat(url.encodedPathSegments()).containsExactly("%6d%6D");
+    assertThat(url.encodedQuery()).isEqualTo("%6d%6D");
+    assertThat(url.encodedFragment()).isEqualTo("%6d%6D");
+    assertThat(url.toString()).isEqualTo(urlString);
+    assertThat(url.newBuilder().build().toString()).isEqualTo(urlString);
+    assertThat(url.resolve("").toString())
+        .isEqualTo("http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D");
+  }
+
+  @Test public void clearFragment() throws Exception {
+    HttpUrl url = parse("http://host/#fragment")
+        .newBuilder()
+        .fragment(null)
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/");
+    assertThat(url.fragment()).isNull();
+    assertThat(url.encodedFragment()).isNull();
+  }
+
+  @Test public void clearEncodedFragment() throws Exception {
+    HttpUrl url = parse("http://host/#fragment")
+        .newBuilder()
+        .encodedFragment(null)
+        .build();
+    assertThat(url.toString()).isEqualTo("http://host/");
+    assertThat(url.fragment()).isNull();
+    assertThat(url.encodedFragment()).isNull();
+  }
+
+  @Test public void topPrivateDomain() {
+    assertThat(parse("https://google.com").topPrivateDomain()).isEqualTo("google.com");
+    assertThat(parse("https://adwords.google.co.uk").topPrivateDomain())
+        .isEqualTo("google.co.uk");
+    assertThat(parse("https://Ê†É.Ê†ÉÊú®.jp").topPrivateDomain())
+        .isEqualTo("xn--ewv.xn--4pvxs.jp");
+    assertThat(parse("https://xn--ewv.xn--4pvxs.jp").topPrivateDomain())
+        .isEqualTo("xn--ewv.xn--4pvxs.jp");
+
+    assertThat(parse("https://co.uk").topPrivateDomain()).isNull();
+    assertThat(parse("https://square").topPrivateDomain()).isNull();
+    assertThat(parse("https://Ê†ÉÊú®.jp").topPrivateDomain()).isNull();
+    assertThat(parse("https://xn--4pvxs.jp").topPrivateDomain()).isNull();
+    assertThat(parse("https://localhost").topPrivateDomain()).isNull();
+    assertThat(parse("https://127.0.0.1").topPrivateDomain()).isNull();
+  }
+
+  private void assertInvalid(String string, String exceptionMessage) {
+    if (useGet) {
+      try {
+        parse(string);
+        fail("Expected get of \"" + string + "\" to throw with: " + exceptionMessage);
+      } catch (IllegalArgumentException e) {
+        assertThat(e.getMessage()).isEqualTo(exceptionMessage);
+      }
+    } else {
+      assertThat(parse(string)).overridingErrorMessage(string).isNull();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java b/okhttp/src/test/java/okhttp3/InterceptorTest.java
similarity index 55%
rename from okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
rename to okhttp/src/test/java/okhttp3/InterceptorTest.java
index e01a360b9b..8dfe07f7ad 100644
--- a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp/src/test/java/okhttp3/InterceptorTest.java
@@ -16,6 +16,8 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.Socket;
 import java.net.SocketTimeoutException;
 import java.util.Arrays;
 import java.util.Locale;
@@ -40,19 +42,14 @@
 import org.junit.Rule;
 import org.junit.Test;
 
-import static okhttp3.TestUtil.defaultClient;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class InterceptorTest {
   @Rule public MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
-  private OkHttpClient client = defaultClient();
+  private OkHttpClient client = clientTestRule.client;
   private RecordingCallback callback = new RecordingCallback();
 
   @Test public void applicationInterceptorsCanShortCircuitResponses() throws Exception {
@@ -62,39 +59,32 @@
         .url("https://localhost:1/")
         .build();
 
-    final Response interceptorResponse = new Response.Builder()
+    Response interceptorResponse = new Response.Builder()
         .request(request)
         .protocol(Protocol.HTTP_1_1)
         .code(200)
         .message("Intercepted!")
-        .body(ResponseBody.create(MediaType.parse("text/plain; charset=utf-8"), "abc"))
+        .body(ResponseBody.create(MediaType.get("text/plain; charset=utf-8"), "abc"))
         .build();
 
     client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            return interceptorResponse;
-          }
-        }).build();
+        .addInterceptor(chain -> interceptorResponse)
+        .build();
 
     Response response = client.newCall(request).execute();
-    assertSame(interceptorResponse, response);
+    assertThat(response).isSameAs(interceptorResponse);
   }
 
   @Test public void networkInterceptorsCannotShortCircuitResponses() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(500));
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return new Response.Builder()
-            .request(chain.request())
-            .protocol(Protocol.HTTP_1_1)
-            .code(200)
-            .message("Intercepted!")
-            .body(ResponseBody.create(MediaType.parse("text/plain; charset=utf-8"), "abc"))
-            .build();
-      }
-    };
+    Interceptor interceptor = chain -> new Response.Builder()
+        .request(chain.request())
+        .protocol(Protocol.HTTP_1_1)
+        .code(200)
+        .message("Intercepted!")
+        .body(ResponseBody.create(MediaType.get("text/plain; charset=utf-8"), "abc"))
+        .build();
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
         .build();
@@ -107,8 +97,8 @@
       client.newCall(request).execute();
       fail();
     } catch (IllegalStateException expected) {
-      assertEquals("network interceptor " + interceptor + " must call proceed() exactly once",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("network interceptor " + interceptor + " must call proceed() exactly once"));
     }
   }
 
@@ -116,11 +106,9 @@
     server.enqueue(new MockResponse());
     server.enqueue(new MockResponse());
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        chain.proceed(chain.request());
-        return chain.proceed(chain.request());
-      }
+    Interceptor interceptor = chain -> {
+      chain.proceed(chain.request());
+      return chain.proceed(chain.request());
     };
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -134,23 +122,21 @@
       client.newCall(request).execute();
       fail();
     } catch (IllegalStateException expected) {
-      assertEquals("network interceptor " + interceptor + " must call proceed() exactly once",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("network interceptor " + interceptor + " must call proceed() exactly once"));
     }
   }
 
   @Test public void networkInterceptorsCannotChangeServerAddress() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(500));
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Address address = chain.connection().route().address();
-        String sameHost = address.url().host();
-        int differentPort = address.url().port() + 1;
-        return chain.proceed(chain.request().newBuilder()
-            .url(HttpUrl.parse("http://" + sameHost + ":" + differentPort + "/"))
-            .build());
-      }
+    Interceptor interceptor = chain -> {
+      Address address = chain.connection().route().address();
+      String sameHost = address.url().host();
+      int differentPort = address.url().port() + 1;
+      return chain.proceed(chain.request().newBuilder()
+          .url("http://" + sameHost + ":" + differentPort + "/")
+          .build());
     };
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -164,20 +150,18 @@
       client.newCall(request).execute();
       fail();
     } catch (IllegalStateException expected) {
-      assertEquals("network interceptor " + interceptor + " must retain the same host and port",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("network interceptor " + interceptor + " must retain the same host and port"));
     }
   }
 
   @Test public void networkInterceptorsHaveConnectionAccess() throws Exception {
     server.enqueue(new MockResponse());
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Connection connection = chain.connection();
-        assertNotNull(connection);
-        return chain.proceed(chain.request());
-      }
+    Interceptor interceptor = chain -> {
+      Connection connection = chain.connection();
+      assertThat(connection).isNotNull();
+      return chain.proceed(chain.request());
     };
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -194,20 +178,18 @@
         .setBody(gzip("abcabcabc"))
         .addHeader("Content-Encoding: gzip"));
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        // The network request has everything: User-Agent, Host, Accept-Encoding.
-        Request networkRequest = chain.request();
-        assertNotNull(networkRequest.header("User-Agent"));
-        assertEquals(server.getHostName() + ":" + server.getPort(),
-            networkRequest.header("Host"));
-        assertNotNull(networkRequest.header("Accept-Encoding"));
-
-        // The network response also has everything, including the raw gzipped content.
-        Response networkResponse = chain.proceed(networkRequest);
-        assertEquals("gzip", networkResponse.header("Content-Encoding"));
-        return networkResponse;
-      }
+    Interceptor interceptor = chain -> {
+      // The network request has everything: User-Agent, Host, Accept-Encoding.
+      Request networkRequest = chain.request();
+      assertThat(networkRequest.header("User-Agent")).isNotNull();
+      assertThat(networkRequest.header("Host")).isEqualTo(
+          (server.getHostName() + ":" + server.getPort()));
+      assertThat(networkRequest.header("Accept-Encoding")).isNotNull();
+
+      // The network response also has everything, including the raw gzipped content.
+      Response networkResponse = chain.proceed(networkRequest);
+      assertThat(networkResponse.header("Content-Encoding")).isEqualTo("gzip");
+      return networkResponse;
     };
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -218,30 +200,28 @@
         .build();
 
     // No extra headers in the application's request.
-    assertNull(request.header("User-Agent"));
-    assertNull(request.header("Host"));
-    assertNull(request.header("Accept-Encoding"));
+    assertThat(request.header("User-Agent")).isNull();
+    assertThat(request.header("Host")).isNull();
+    assertThat(request.header("Accept-Encoding")).isNull();
 
     // No extra headers in the application's response.
     Response response = client.newCall(request).execute();
-    assertNull(request.header("Content-Encoding"));
-    assertEquals("abcabcabc", response.body().string());
+    assertThat(request.header("Content-Encoding")).isNull();
+    assertThat(response.body().string()).isEqualTo("abcabcabc");
   }
 
   @Test public void networkInterceptorsCanChangeRequestMethodFromGetToPost() throws Exception {
     server.enqueue(new MockResponse());
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Request originalRequest = chain.request();
-        MediaType mediaType = MediaType.parse("text/plain");
-        RequestBody body = RequestBody.create(mediaType, "abc");
-        return chain.proceed(originalRequest.newBuilder()
-            .method("POST", body)
-            .header("Content-Type", mediaType.toString())
-            .header("Content-Length", Long.toString(body.contentLength()))
-            .build());
-      }
+    Interceptor interceptor = chain -> {
+      Request originalRequest = chain.request();
+      MediaType mediaType = MediaType.get("text/plain");
+      RequestBody body = RequestBody.create(mediaType, "abc");
+      return chain.proceed(originalRequest.newBuilder()
+          .method("POST", body)
+          .header("Content-Type", mediaType.toString())
+          .header("Content-Length", Long.toString(body.contentLength()))
+          .build());
     };
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -255,8 +235,8 @@
     client.newCall(request).execute();
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("POST", recordedRequest.getMethod());
-    assertEquals("abc", recordedRequest.getBody().readUtf8());
+    assertThat(recordedRequest.getMethod()).isEqualTo("POST");
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("abc");
   }
 
   @Test public void applicationInterceptorsRewriteRequestToServer() throws Exception {
@@ -270,29 +250,27 @@
   private void rewriteRequestToServer(boolean network) throws Exception {
     server.enqueue(new MockResponse());
 
-    addInterceptor(network, new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Request originalRequest = chain.request();
-        return chain.proceed(originalRequest.newBuilder()
-            .method("POST", uppercase(originalRequest.body()))
-            .addHeader("OkHttp-Intercepted", "yep")
-            .build());
-      }
+    addInterceptor(network, chain -> {
+      Request originalRequest = chain.request();
+      return chain.proceed(originalRequest.newBuilder()
+          .method("POST", uppercase(originalRequest.body()))
+          .addHeader("OkHttp-Intercepted", "yep")
+          .build());
     });
 
     Request request = new Request.Builder()
         .url(server.url("/"))
         .addHeader("Original-Header", "foo")
-        .method("PUT", RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .method("PUT", RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     client.newCall(request).execute();
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("ABC", recordedRequest.getBody().readUtf8());
-    assertEquals("foo", recordedRequest.getHeader("Original-Header"));
-    assertEquals("yep", recordedRequest.getHeader("OkHttp-Intercepted"));
-    assertEquals("POST", recordedRequest.getMethod());
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("ABC");
+    assertThat(recordedRequest.getHeader("Original-Header")).isEqualTo("foo");
+    assertThat(recordedRequest.getHeader("OkHttp-Intercepted")).isEqualTo("yep");
+    assertThat(recordedRequest.getMethod()).isEqualTo("POST");
   }
 
   @Test public void applicationInterceptorsRewriteResponseFromServer() throws Exception {
@@ -308,14 +286,12 @@ private void rewriteResponseFromServer(boolean network) throws Exception {
         .addHeader("Original-Header: foo")
         .setBody("abc"));
 
-    addInterceptor(network, new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Response originalResponse = chain.proceed(chain.request());
-        return originalResponse.newBuilder()
-            .body(uppercase(originalResponse.body()))
-            .addHeader("OkHttp-Intercepted", "yep")
-            .build();
-      }
+    addInterceptor(network, chain -> {
+      Response originalResponse = chain.proceed(chain.request());
+      return originalResponse.newBuilder()
+          .body(uppercase(originalResponse.body()))
+          .addHeader("OkHttp-Intercepted", "yep")
+          .build();
     });
 
     Request request = new Request.Builder()
@@ -323,9 +299,9 @@ private void rewriteResponseFromServer(boolean network) throws Exception {
         .build();
 
     Response response = client.newCall(request).execute();
-    assertEquals("ABC", response.body().string());
-    assertEquals("yep", response.header("OkHttp-Intercepted"));
-    assertEquals("foo", response.header("Original-Header"));
+    assertThat(response.body().string()).isEqualTo("ABC");
+    assertThat(response.header("OkHttp-Intercepted")).isEqualTo("yep");
+    assertThat(response.header("Original-Header")).isEqualTo("foo");
   }
 
   @Test public void multipleApplicationInterceptors() throws Exception {
@@ -339,27 +315,23 @@ private void rewriteResponseFromServer(boolean network) throws Exception {
   private void multipleInterceptors(boolean network) throws Exception {
     server.enqueue(new MockResponse());
 
-    addInterceptor(network, new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Request originalRequest = chain.request();
-        Response originalResponse = chain.proceed(originalRequest.newBuilder()
-            .addHeader("Request-Interceptor", "Android") // 1. Added first.
-            .build());
-        return originalResponse.newBuilder()
-            .addHeader("Response-Interceptor", "Donut") // 4. Added last.
-            .build();
-      }
+    addInterceptor(network, chain -> {
+      Request originalRequest = chain.request();
+      Response originalResponse = chain.proceed(originalRequest.newBuilder()
+          .addHeader("Request-Interceptor", "Android") // 1. Added first.
+          .build());
+      return originalResponse.newBuilder()
+          .addHeader("Response-Interceptor", "Donut") // 4. Added last.
+          .build();
     });
-    addInterceptor(network, new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Request originalRequest = chain.request();
-        Response originalResponse = chain.proceed(originalRequest.newBuilder()
-            .addHeader("Request-Interceptor", "Bob") // 2. Added second.
-            .build());
-        return originalResponse.newBuilder()
-            .addHeader("Response-Interceptor", "Cupcake") // 3. Added third.
-            .build();
-      }
+    addInterceptor(network, chain -> {
+      Request originalRequest = chain.request();
+      Response originalResponse = chain.proceed(originalRequest.newBuilder()
+          .addHeader("Request-Interceptor", "Bob") // 2. Added second.
+          .build());
+      return originalResponse.newBuilder()
+          .addHeader("Response-Interceptor", "Cupcake") // 3. Added third.
+          .build();
     });
 
     Request request = new Request.Builder()
@@ -367,12 +339,11 @@ private void multipleInterceptors(boolean network) throws Exception {
         .build();
 
     Response response = client.newCall(request).execute();
-    assertEquals(Arrays.asList("Cupcake", "Donut"),
-        response.headers("Response-Interceptor"));
+    assertThat(response.headers("Response-Interceptor")).containsExactly("Cupcake", "Donut");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals(Arrays.asList("Android", "Bob"),
-        recordedRequest.getHeaders().values("Request-Interceptor"));
+    assertThat(recordedRequest.getHeaders().values("Request-Interceptor"))
+        .containsExactly("Android", "Bob");
   }
 
   @Test public void asyncApplicationInterceptors() throws Exception {
@@ -386,13 +357,11 @@ private void multipleInterceptors(boolean network) throws Exception {
   private void asyncInterceptors(boolean network) throws Exception {
     server.enqueue(new MockResponse());
 
-    addInterceptor(network, new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Response originalResponse = chain.proceed(chain.request());
-        return originalResponse.newBuilder()
-            .addHeader("OkHttp-Intercepted", "yep")
-            .build();
-      }
+    addInterceptor(network, chain -> {
+      Response originalResponse = chain.proceed(chain.request());
+      return originalResponse.newBuilder()
+          .addHeader("OkHttp-Intercepted", "yep")
+          .build();
     });
 
     Request request = new Request.Builder()
@@ -410,20 +379,19 @@ private void asyncInterceptors(boolean network) throws Exception {
     server.enqueue(new MockResponse().setBody("b"));
 
     client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            Response response1 = chain.proceed(chain.request());
-            response1.body().close();
-            return chain.proceed(chain.request());
-          }
-        }).build();
+        .addInterceptor(chain -> {
+          Response response1 = chain.proceed(chain.request());
+          response1.body().close();
+          return chain.proceed(chain.request());
+        })
+        .build();
 
     Request request = new Request.Builder()
         .url(server.url("/"))
         .build();
 
     Response response = client.newCall(request).execute();
-    assertEquals(response.body().string(), "b");
+    assertThat("b").isEqualTo(response.body().string());
   }
 
   /** Make sure interceptors can interact with the OkHttp client. */
@@ -432,25 +400,24 @@ private void asyncInterceptors(boolean network) throws Exception {
     server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
 
     client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            if (chain.request().url().encodedPath().equals("/b")) {
-              Request requestA = new Request.Builder()
-                  .url(server.url("/a"))
-                  .build();
-              Response responseA = client.newCall(requestA).execute();
-              assertEquals("a", responseA.body().string());
-            }
-
-            return chain.proceed(chain.request());
+        .addInterceptor(chain -> {
+          if (chain.request().url().encodedPath().equals("/b")) {
+            Request requestA = new Request.Builder()
+                .url(server.url("/a"))
+                .build();
+            Response responseA = client.newCall(requestA).execute();
+            assertThat(responseA.body().string()).isEqualTo("a");
           }
-        }).build();
+
+          return chain.proceed(chain.request());
+        })
+        .build();
 
     Request requestB = new Request.Builder()
         .url(server.url("/b"))
         .build();
     Response responseB = client.newCall(requestB).execute();
-    assertEquals("b", responseB.body().string());
+    assertThat(responseB.body().string()).isEqualTo("b");
   }
 
   /** Make sure interceptors can interact with the OkHttp client asynchronously. */
@@ -459,25 +426,24 @@ private void asyncInterceptors(boolean network) throws Exception {
     server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
 
     client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            if (chain.request().url().encodedPath().equals("/b")) {
-              Request requestA = new Request.Builder()
-                  .url(server.url("/a"))
-                  .build();
-
-              try {
-                RecordingCallback callbackA = new RecordingCallback();
-                client.newCall(requestA).enqueue(callbackA);
-                callbackA.await(requestA.url()).assertBody("a");
-              } catch (Exception e) {
-                throw new RuntimeException(e);
-              }
+        .addInterceptor(chain -> {
+          if (chain.request().url().encodedPath().equals("/b")) {
+            Request requestA = new Request.Builder()
+                .url(server.url("/a"))
+                .build();
+
+            try {
+              RecordingCallback callbackA = new RecordingCallback();
+              client.newCall(requestA).enqueue(callbackA);
+              callbackA.await(requestA.url()).assertBody("a");
+            } catch (Exception e) {
+              throw new RuntimeException(e);
             }
-
-            return chain.proceed(chain.request());
           }
-        }).build();
+
+          return chain.proceed(chain.request());
+        })
+        .build();
 
     Request requestB = new Request.Builder()
         .url(server.url("/b"))
@@ -500,11 +466,7 @@ private void asyncInterceptors(boolean network) throws Exception {
    * with it.
    */
   private void interceptorThrowsRuntimeExceptionSynchronous(boolean network) throws Exception {
-    addInterceptor(network, new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        throw new RuntimeException("boom!");
-      }
-    });
+    addInterceptor(network, chain -> { throw new RuntimeException("boom!"); });
 
     Request request = new Request.Builder()
         .url(server.url("/"))
@@ -514,19 +476,19 @@ private void interceptorThrowsRuntimeExceptionSynchronous(boolean network) throw
       client.newCall(request).execute();
       fail();
     } catch (RuntimeException expected) {
-      assertEquals("boom!", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("boom!");
     }
   }
 
   @Test public void networkInterceptorModifiedRequestIsReturned() throws IOException {
     server.enqueue(new MockResponse());
 
-    Interceptor modifyHeaderInterceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return chain.proceed(chain.request().newBuilder()
-            .header("User-Agent", "intercepted request")
-            .build());
-      }
+    Interceptor modifyHeaderInterceptor = chain -> {
+      Request modifiedRequest = chain.request()
+          .newBuilder()
+          .header("User-Agent", "intercepted request")
+          .build();
+      return chain.proceed(modifiedRequest);
     };
 
     client = client.newBuilder()
@@ -539,9 +501,10 @@ private void interceptorThrowsRuntimeExceptionSynchronous(boolean network) throw
         .build();
 
     Response response = client.newCall(request).execute();
-    assertNotNull(response.request().header("User-Agent"));
-    assertEquals("user request", response.request().header("User-Agent"));
-    assertEquals("intercepted request", response.networkResponse().request().header("User-Agent"));
+    assertThat(response.request().header("User-Agent")).isNotNull();
+    assertThat(response.request().header("User-Agent")).isEqualTo("user request");
+    assertThat(response.networkResponse().request().header("User-Agent")).isEqualTo(
+        "intercepted request");
   }
 
   @Test public void applicationInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
@@ -557,11 +520,7 @@ private void interceptorThrowsRuntimeExceptionSynchronous(boolean network) throw
    * exception goes to the uncaught exception handler.
    */
   private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) throws Exception {
-    addInterceptor(network, new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        throw new RuntimeException("boom!");
-      }
-    });
+    addInterceptor(network, chain -> { throw new RuntimeException("boom!"); });
 
     ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
     client = client.newBuilder()
@@ -573,17 +532,15 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
         .build();
     client.newCall(request).enqueue(callback);
 
-    assertEquals("boom!", executor.takeException().getMessage());
+    assertThat(executor.takeException().getMessage()).isEqualTo("boom!");
   }
 
   @Test public void applicationInterceptorReturnsNull() throws Exception {
     server.enqueue(new MockResponse());
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        chain.proceed(chain.request());
-        return null;
-      }
+    Interceptor interceptor = chain -> {
+      chain.proceed(chain.request());
+      return null;
     };
     client = client.newBuilder()
         .addInterceptor(interceptor)
@@ -601,18 +558,17 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       client.newCall(request).execute();
       fail();
     } catch (NullPointerException expected) {
-      assertEquals("interceptor " + interceptor + " returned null", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("interceptor " + interceptor + " returned null"));
     }
   }
 
   @Test public void networkInterceptorReturnsNull() throws Exception {
     server.enqueue(new MockResponse());
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        chain.proceed(chain.request());
-        return null;
-      }
+    Interceptor interceptor = chain -> {
+      chain.proceed(chain.request());
+      return null;
     };
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -630,7 +586,8 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       client.newCall(request).execute();
       fail();
     } catch (NullPointerException expected) {
-      assertEquals("interceptor " + interceptor + " returned null", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("interceptor " + interceptor + " returned null"));
     }
   }
 
@@ -639,12 +596,10 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
         .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
         .addHeader("Connection", "Close"));
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Response response = chain.proceed(chain.request());
-        assertNotNull(chain.connection());
-        return response;
-      }
+    Interceptor interceptor = chain -> {
+      Response response = chain.proceed(chain.request());
+      assertThat(chain.connection()).isNotNull();
+      return response;
     };
 
     client = client.newBuilder()
@@ -662,10 +617,11 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
   @Test public void applicationInterceptorResponseMustHaveBody() throws Exception {
     server.enqueue(new MockResponse());
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return chain.proceed(chain.request()).newBuilder().body(null).build();
-      }
+    Interceptor interceptor = chain -> {
+      Response response = chain.proceed(chain.request());
+      return response.newBuilder()
+          .body(null)
+          .build();
     };
     client = client.newBuilder()
         .addInterceptor(interceptor)
@@ -678,18 +634,19 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       client.newCall(request).execute();
       fail();
     } catch (IllegalStateException expected) {
-      assertEquals("interceptor " + interceptor + " returned a response with no body",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("interceptor " + interceptor + " returned a response with no body"));
     }
   }
 
   @Test public void networkInterceptorResponseMustHaveBody() throws Exception {
     server.enqueue(new MockResponse());
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return chain.proceed(chain.request()).newBuilder().body(null).build();
-      }
+    Interceptor interceptor = chain -> {
+      Response response = chain.proceed(chain.request());
+      return response.newBuilder()
+          .body(null)
+          .build();
     };
     client = client.newBuilder()
         .addNetworkInterceptor(interceptor)
@@ -702,39 +659,44 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       client.newCall(request).execute();
       fail();
     } catch (IllegalStateException expected) {
-      assertEquals("interceptor " + interceptor + " returned a response with no body",
-          expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("interceptor " + interceptor + " returned a response with no body"));
     }
   }
 
   @Test public void connectTimeout() throws Exception {
-    Interceptor interceptor1 = new Interceptor() {
-      @Override public Response intercept(Chain chainA) throws IOException {
-        assertEquals(5000, chainA.connectTimeoutMillis());
+    Interceptor interceptor1 = chainA -> {
+      assertThat(chainA.connectTimeoutMillis()).isEqualTo(5000);
 
-        Chain chainB = chainA.withConnectTimeout(100, TimeUnit.MILLISECONDS);
-        assertEquals(100, chainB.connectTimeoutMillis());
+      Interceptor.Chain chainB = chainA.withConnectTimeout(100, TimeUnit.MILLISECONDS);
+      assertThat(chainB.connectTimeoutMillis()).isEqualTo(100);
 
-        return chainB.proceed(chainA.request());
-      }
+      return chainB.proceed(chainA.request());
     };
 
-    Interceptor interceptor2 = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        assertEquals(100, chain.connectTimeoutMillis());
-        return chain.proceed(chain.request());
-      }
+    Interceptor interceptor2 = chain -> {
+      assertThat(chain.connectTimeoutMillis()).isEqualTo(100);
+      return chain.proceed(chain.request());
     };
 
+    ServerSocket serverSocket = new ServerSocket(0, 1);
+    // Fill backlog queue with this request so subsequent requests will be blocked.
+    new Socket().connect(serverSocket.getLocalSocketAddress());
+
     client = client.newBuilder()
         .connectTimeout(5, TimeUnit.SECONDS)
         .addInterceptor(interceptor1)
         .addInterceptor(interceptor2)
         .build();
 
-    Request request1 = new Request.Builder()
-        .url("http://" + TestUtil.UNREACHABLE_ADDRESS)
-        .build();
+    Request request1 =
+        new Request.Builder()
+            .url(
+                "http://"
+                    + serverSocket.getInetAddress().getCanonicalHostName()
+                    + ":"
+                    + serverSocket.getLocalPort())
+            .build();
     Call call = client.newCall(request1);
 
     try {
@@ -742,25 +704,23 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
       fail();
     } catch (SocketTimeoutException expected) {
     }
+
+    serverSocket.close();
   }
 
   @Test public void chainWithReadTimeout() throws Exception {
-    Interceptor interceptor1 = new Interceptor() {
-      @Override public Response intercept(Chain chainA) throws IOException {
-        assertEquals(5000, chainA.readTimeoutMillis());
+    Interceptor interceptor1 = chainA -> {
+      assertThat(chainA.readTimeoutMillis()).isEqualTo(5000);
 
-        Chain chainB = chainA.withReadTimeout(100, TimeUnit.MILLISECONDS);
-        assertEquals(100, chainB.readTimeoutMillis());
+      Interceptor.Chain chainB = chainA.withReadTimeout(100, TimeUnit.MILLISECONDS);
+      assertThat(chainB.readTimeoutMillis()).isEqualTo(100);
 
-        return chainB.proceed(chainA.request());
-      }
+      return chainB.proceed(chainA.request());
     };
 
-    Interceptor interceptor2 = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        assertEquals(100, chain.readTimeoutMillis());
-        return chain.proceed(chain.request());
-      }
+    Interceptor interceptor2 = chain -> {
+      assertThat(chain.readTimeoutMillis()).isEqualTo(100);
+      return chain.proceed(chain.request());
     };
 
     client = client.newBuilder()
@@ -787,22 +747,18 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
   }
 
   @Test public void chainWithWriteTimeout() throws Exception {
-    Interceptor interceptor1 = new Interceptor() {
-      @Override public Response intercept(Chain chainA) throws IOException {
-        assertEquals(5000, chainA.writeTimeoutMillis());
+    Interceptor interceptor1 = chainA -> {
+      assertThat(chainA.writeTimeoutMillis()).isEqualTo(5000);
 
-        Chain chainB = chainA.withWriteTimeout(100, TimeUnit.MILLISECONDS);
-        assertEquals(100, chainB.writeTimeoutMillis());
+      Interceptor.Chain chainB = chainA.withWriteTimeout(100, TimeUnit.MILLISECONDS);
+      assertThat(chainB.writeTimeoutMillis()).isEqualTo(100);
 
-        return chainB.proceed(chainA.request());
-      }
+      return chainB.proceed(chainA.request());
     };
 
-    Interceptor interceptor2 = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        assertEquals(100, chain.writeTimeoutMillis());
-        return chain.proceed(chain.request());
-      }
+    Interceptor interceptor2 = chain -> {
+      assertThat(chain.writeTimeoutMillis()).isEqualTo(100);
+      return chain.proceed(chain.request());
     };
 
     client = client.newBuilder()
@@ -818,7 +774,7 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
     byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
     Request request1 = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), data))
+        .post(RequestBody.create(MediaType.get("text/plain"), data))
         .build();
     Call call = client.newCall(request1);
 
@@ -830,19 +786,17 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
   }
 
   @Test public void chainCanCancelCall() throws Exception {
-    final AtomicReference<Call> callRef = new AtomicReference<>();
+    AtomicReference<Call> callRef = new AtomicReference<>();
 
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        Call call = chain.call();
-        callRef.set(call);
+    Interceptor interceptor = chain -> {
+      Call call = chain.call();
+      callRef.set(call);
 
-        assertFalse(call.isCanceled());
-        call.cancel();
-        assertTrue(call.isCanceled());
+      assertThat(call.isCanceled()).isFalse();
+      call.cancel();
+      assertThat(call.isCanceled()).isTrue();
 
-        return chain.proceed(chain.request());
-      }
+      return chain.proceed(chain.request());
     };
 
     client = client.newBuilder()
@@ -860,10 +814,10 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
     } catch (IOException expected) {
     }
 
-    assertSame(call, callRef.get());
+    assertThat(callRef.get()).isSameAs(call);
   }
 
-  private RequestBody uppercase(final RequestBody original) {
+  private RequestBody uppercase(RequestBody original) {
     return new RequestBody() {
       @Override public MediaType contentType() {
         return original.contentType();
@@ -882,7 +836,7 @@ private RequestBody uppercase(final RequestBody original) {
     };
   }
 
-  private Sink uppercase(final BufferedSink original) {
+  private Sink uppercase(BufferedSink original) {
     return new ForwardingSink(original) {
       @Override public void write(Buffer source, long byteCount) throws IOException {
         original.writeUtf8(source.readUtf8(byteCount).toUpperCase(Locale.US));
@@ -895,7 +849,7 @@ static ResponseBody uppercase(ResponseBody original) throws IOException {
         Okio.buffer(uppercase(original.source())));
   }
 
-  private static Source uppercase(final Source original) {
+  private static Source uppercase(Source original) {
     return new ForwardingSource(original) {
       @Override public long read(Buffer sink, long byteCount) throws IOException {
         Buffer mixedCase = new Buffer();
@@ -929,22 +883,20 @@ private void addInterceptor(boolean network, Interceptor interceptor) {
     private final BlockingQueue<Exception> exceptions = new LinkedBlockingQueue<>();
 
     public ExceptionCatchingExecutor() {
-      super(1, 1, 0, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
+      super(1, 1, 0, TimeUnit.SECONDS, new SynchronousQueue<>());
     }
 
-    @Override public void execute(final Runnable runnable) {
-      super.execute(new Runnable() {
-        @Override public void run() {
-          try {
-            runnable.run();
-          } catch (Exception e) {
-            exceptions.add(e);
-          }
+    @Override public void execute(Runnable runnable) {
+      super.execute(() -> {
+        try {
+          runnable.run();
+        } catch (Exception e) {
+          exceptions.add(e);
         }
       });
     }
 
-    public Exception takeException() throws InterruptedException {
+    public Exception takeException() throws Exception {
       return exceptions.take();
     }
   }
diff --git a/okhttp/src/test/java/okhttp3/KotlinSourceCompatibilityTest.kt b/okhttp/src/test/java/okhttp3/KotlinSourceCompatibilityTest.kt
new file mode 100644
index 0000000000..b2cb509d9f
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/KotlinSourceCompatibilityTest.kt
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.proxy.NullProxySelector
+import okhttp3.internal.tls.OkHostnameVerifier
+import okhttp3.tls.internal.TlsUtil.localhost
+import org.junit.Ignore
+import org.junit.Test
+import java.io.File
+import java.net.Proxy
+import java.net.ProxySelector
+import java.time.Duration
+import java.util.concurrent.TimeUnit
+import javax.net.SocketFactory
+import javax.net.ssl.HostnameVerifier
+import javax.net.ssl.SSLSocketFactory
+
+/**
+ * Access every type, function, and property from Kotlin to defend against unexpected regressions in
+ * source-compatibility.
+ *
+ * Unlike most tests we're only really interested in whether this test compiles: it's output is not
+ * interesting. Do not simplify this code by removing unused declarations or unnecessary types;
+ * doing so limits the utility of the test.
+ */
+@Suppress("UNUSED_VARIABLE")
+class KotlinSourceCompatibilityTest {
+  @Test @Ignore
+  fun address() {
+    val address: Address = Address(
+        "",
+        0,
+        Dns.SYSTEM,
+        SocketFactory.getDefault(),
+        localhost().sslSocketFactory(),
+        OkHostnameVerifier.INSTANCE,
+        CertificatePinner.DEFAULT,
+        Authenticator.NONE,
+        Proxy.NO_PROXY,
+        listOf(Protocol.HTTP_1_1),
+        listOf(ConnectionSpec.MODERN_TLS),
+        NullProxySelector()
+    )
+    val url: HttpUrl = address.url()
+    val dns: Dns = address.dns()
+    val socketFactory: SocketFactory = address.socketFactory()
+    val proxyAuthenticator: Authenticator = address.proxyAuthenticator()
+    val protocols: List<Protocol> = address.protocols()
+    val connectionSpecs: List<ConnectionSpec> = address.connectionSpecs()
+    val proxySelector: ProxySelector = address.proxySelector()
+    val sslSocketFactory: SSLSocketFactory? = address.sslSocketFactory()
+    val hostnameVerifier: HostnameVerifier? = address.hostnameVerifier()
+    val certificatePinner: CertificatePinner? = address.certificatePinner()
+  }
+
+  @Test @Ignore
+  fun cache() {
+    val cache = Cache(File("/cache/"), Integer.MAX_VALUE.toLong())
+    cache.initialize()
+    cache.delete()
+    cache.evictAll()
+    val urls: MutableIterator<String> = cache.urls()
+    val writeAbortCount: Int = cache.writeAbortCount()
+    val writeSuccessCount: Int = cache.writeSuccessCount()
+    val size: Long = cache.size()
+    val maxSize: Long = cache.maxSize()
+    cache.flush()
+    cache.close()
+    val directory: File = cache.directory()
+    val networkCount: Int = cache.networkCount()
+    val hitCount: Int = cache.hitCount()
+    val requestCount: Int = cache.requestCount()
+  }
+
+  @Test @Ignore
+  fun cacheControl() {
+    val cacheControl: CacheControl = CacheControl.Builder().build()
+    val noCache: Boolean = cacheControl.noCache()
+    val noStore: Boolean = cacheControl.noStore()
+    val maxAgeSeconds: Int = cacheControl.maxAgeSeconds()
+    val sMaxAgeSeconds: Int = cacheControl.sMaxAgeSeconds()
+    val mustRevalidate: Boolean = cacheControl.mustRevalidate()
+    val maxStaleSeconds: Int = cacheControl.maxStaleSeconds()
+    val minFreshSeconds: Int = cacheControl.minFreshSeconds()
+    val onlyIfCached: Boolean = cacheControl.onlyIfCached()
+    val noTransform: Boolean = cacheControl.noTransform()
+    val immutable: Boolean = cacheControl.immutable()
+    val forceCache: CacheControl = CacheControl.FORCE_CACHE
+    val forceNetwork: CacheControl = CacheControl.FORCE_NETWORK
+    val parse: CacheControl = CacheControl.parse(Headers.of())
+  }
+
+  @Test @Ignore
+  fun cacheControlBuilder() {
+    var builder: CacheControl.Builder = CacheControl.Builder()
+    builder = builder.noCache()
+    builder = builder.noStore()
+    builder = builder.maxAge(0, TimeUnit.MILLISECONDS)
+    builder = builder.maxStale(0, TimeUnit.MILLISECONDS)
+    builder = builder.minFresh(0, TimeUnit.MILLISECONDS)
+    builder = builder.onlyIfCached()
+    builder = builder.noTransform()
+    builder = builder.immutable()
+    val cacheControl: CacheControl = builder.build()
+  }
+
+  @Test @Ignore
+  fun okHttpClient() {
+    val client: OkHttpClient = OkHttpClient()
+    val dispatcher: Dispatcher = client.dispatcher()
+    val proxy: Proxy? = client.proxy()
+    val protocols: List<Protocol> = client.protocols()
+    val connectionSpecs: List<ConnectionSpec> = client.connectionSpecs()
+    val interceptors: List<Interceptor> = client.interceptors()
+    val networkInterceptors: List<Interceptor> = client.networkInterceptors()
+    val eventListenerFactory: EventListener.Factory = client.eventListenerFactory()
+    val proxySelector: ProxySelector = client.proxySelector()
+    val cookieJar: CookieJar = client.cookieJar()
+    val cache: Cache? = client.cache()
+    val socketFactory: SocketFactory = client.socketFactory()
+    val sslSocketFactory: SSLSocketFactory = client.sslSocketFactory()
+    val hostnameVerifier: HostnameVerifier = client.hostnameVerifier()
+    val certificatePinner: CertificatePinner = client.certificatePinner()
+    val proxyAuthenticator: Authenticator = client.proxyAuthenticator()
+    val authenticator: Authenticator = client.authenticator()
+    val connectionPool: ConnectionPool = client.connectionPool()
+    val dns: Dns = client.dns()
+    val followSslRedirects: Boolean = client.followSslRedirects()
+    val followRedirects: Boolean = client.followRedirects()
+    val retryOnConnectionFailure: Boolean = client.retryOnConnectionFailure()
+    val callTimeoutMillis: Int = client.callTimeoutMillis()
+    val connectTimeoutMillis: Int = client.connectTimeoutMillis()
+    val readTimeoutMillis: Int = client.readTimeoutMillis()
+    val writeTimeoutMillis: Int = client.writeTimeoutMillis()
+    val pingIntervalMillis: Int = client.pingIntervalMillis()
+    val call: Call = client.newCall(Request.Builder().build())
+    val webSocket: WebSocket = client.newWebSocket(
+        Request.Builder().build(),
+        object : WebSocketListener() {
+        })
+    val newBuilder: OkHttpClient.Builder = client.newBuilder()
+  }
+
+  @Test @Ignore
+  fun okHttpClientBuilder() {
+    var builder: OkHttpClient.Builder = OkHttpClient.Builder()
+    builder = builder.callTimeout(0L, TimeUnit.SECONDS)
+    builder = builder.callTimeout(Duration.ofSeconds(0L))
+    builder = builder.connectTimeout(0L, TimeUnit.SECONDS)
+    builder = builder.connectTimeout(Duration.ofSeconds(0L))
+    builder = builder.readTimeout(0L, TimeUnit.SECONDS)
+    builder = builder.readTimeout(Duration.ofSeconds(0L))
+    builder = builder.writeTimeout(0L, TimeUnit.SECONDS)
+    builder = builder.writeTimeout(Duration.ofSeconds(0L))
+    builder = builder.pingInterval(0L, TimeUnit.SECONDS)
+    builder = builder.pingInterval(Duration.ofSeconds(0L))
+    builder = builder.proxy(Proxy.NO_PROXY)
+    builder = builder.proxySelector(NullProxySelector())
+    builder = builder.cookieJar(CookieJar.NO_COOKIES)
+    builder = builder.cache(Cache(File("/cache/"), Integer.MAX_VALUE.toLong()))
+    builder = builder.dns(Dns.SYSTEM)
+    builder = builder.socketFactory(SocketFactory.getDefault())
+    builder = builder.sslSocketFactory(localhost().sslSocketFactory(), localhost().trustManager())
+    builder = builder.hostnameVerifier(OkHostnameVerifier.INSTANCE)
+    builder = builder.certificatePinner(CertificatePinner.DEFAULT)
+    builder = builder.authenticator(Authenticator.NONE)
+    builder = builder.proxyAuthenticator(Authenticator.NONE)
+    builder = builder.connectionPool(ConnectionPool(0, 0, TimeUnit.SECONDS))
+    builder = builder.followSslRedirects(false)
+    builder = builder.followRedirects(false)
+    builder = builder.retryOnConnectionFailure(false)
+    builder = builder.dispatcher(Dispatcher())
+    builder = builder.protocols(listOf(Protocol.HTTP_1_1))
+    builder = builder.connectionSpecs(listOf(ConnectionSpec.MODERN_TLS))
+    val interceptors: List<Interceptor> = builder.interceptors()
+    builder = builder.addInterceptor(object : Interceptor {
+      override fun intercept(chain: Interceptor.Chain): Response = TODO()
+    })
+    val networkInterceptors: List<Interceptor> = builder.networkInterceptors()
+    builder = builder.addNetworkInterceptor(object : Interceptor {
+      override fun intercept(chain: Interceptor.Chain): Response = TODO()
+    })
+    builder = builder.eventListener(EventListener.NONE)
+    builder = builder.eventListenerFactory(object : EventListener.Factory {
+      override fun create(call: Call): EventListener = TODO()
+    })
+    val client: OkHttpClient = builder.build()
+  }
+}
\ No newline at end of file
diff --git a/okhttp/src/test/java/okhttp3/MediaTypeTest.java b/okhttp/src/test/java/okhttp3/MediaTypeTest.java
new file mode 100644
index 0000000000..4978669299
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/MediaTypeTest.java
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2011 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.nio.charset.Charset;
+import java.util.Arrays;
+import java.util.Collection;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Test MediaType API and parsing.
+ *
+ * <p>This test includes tests from <a href="https://code.google.com/p/guava-libraries/">Guava's</a>
+ * MediaTypeTest.
+ */
+@RunWith(Parameterized.class)
+public class MediaTypeTest {
+  @Parameterized.Parameters(name = "Use get = {0}")
+  public static Collection<Object[]> parameters() {
+    return asList(
+        new Object[] { true },
+        new Object[] { false }
+    );
+  }
+
+  @Parameterized.Parameter
+  public boolean useGet;
+
+  private MediaType parse(String string) {
+    return useGet
+        ? MediaType.get(string)
+        : MediaType.parse(string);
+  }
+
+  @Test public void testParse() throws Exception {
+    MediaType mediaType = parse("text/plain;boundary=foo;charset=utf-8");
+    assertThat(mediaType.type()).isEqualTo("text");
+    assertThat(mediaType.subtype()).isEqualTo("plain");
+    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
+    assertThat(mediaType.toString()).isEqualTo("text/plain;boundary=foo;charset=utf-8");
+    assertThat(parse("text/plain;boundary=foo;charset=utf-8")).isEqualTo(mediaType);
+    assertThat(parse("text/plain;boundary=foo;charset=utf-8").hashCode()).isEqualTo(
+        (long) mediaType.hashCode());
+  }
+
+  @Test public void testValidParse() throws Exception {
+    assertMediaType("text/plain");
+    assertMediaType("application/atom+xml; charset=utf-8");
+    assertMediaType("application/atom+xml; a=1; a=2; b=3");
+    assertMediaType("image/gif; foo=bar");
+    assertMediaType("text/plain; a=1");
+    assertMediaType("text/plain; a=1; a=2; b=3");
+    assertMediaType("text/plain; charset=utf-16");
+    assertMediaType("text/plain; \t \n \r a=b");
+    assertMediaType("text/plain;");
+    assertMediaType("text/plain; ");
+    assertMediaType("text/plain; a=1;");
+    assertMediaType("text/plain; a=1; ");
+    assertMediaType("text/plain; a=1;; b=2");
+    assertMediaType("text/plain;;");
+    assertMediaType("text/plain; ;");
+  }
+
+  @Test public void testInvalidParse() throws Exception {
+    assertInvalid("", "No subtype found for: \"\"");
+    assertInvalid("/", "No subtype found for: \"/\"");
+    assertInvalid("text", "No subtype found for: \"text\"");
+    assertInvalid("text/", "No subtype found for: \"text/\"");
+    assertInvalid("te<t/plain", "No subtype found for: \"te<t/plain\"");
+    assertInvalid(" text/plain", "No subtype found for: \" text/plain\"");
+    assertInvalid("te xt/plain", "No subtype found for: \"te xt/plain\"");
+    assertInvalid("text /plain", "No subtype found for: \"text /plain\"");
+    assertInvalid("text/ plain", "No subtype found for: \"text/ plain\"");
+
+    assertInvalid("text/pl@in",
+        "Parameter is not formatted correctly: \"@in\" for: \"text/pl@in\"");
+    assertInvalid("text/plain; a",
+        "Parameter is not formatted correctly: \"a\" for: \"text/plain; a\"");
+    assertInvalid("text/plain; a=",
+        "Parameter is not formatted correctly: \"a=\" for: \"text/plain; a=\"");
+    assertInvalid("text/plain; a=@",
+        "Parameter is not formatted correctly: \"a=@\" for: \"text/plain; a=@\"");
+    assertInvalid("text/plain; a=\"@",
+        "Parameter is not formatted correctly: \"a=\"@\" for: \"text/plain; a=\"@\"");
+    assertInvalid("text/plain; a=1; b",
+        "Parameter is not formatted correctly: \"b\" for: \"text/plain; a=1; b\"");
+    assertInvalid("text/plain; a=1; b=",
+        "Parameter is not formatted correctly: \"b=\" for: \"text/plain; a=1; b=\"");
+    assertInvalid("text/plain; a=\u2025",
+        "Parameter is not formatted correctly: \"a=‚Ä•\" for: \"text/plain; a=‚Ä•\"");
+    assertInvalid("text/pl ain",
+        "Parameter is not formatted correctly: \" ain\" for: \"text/pl ain\"");
+    assertInvalid("text/plain ",
+        "Parameter is not formatted correctly: \" \" for: \"text/plain \"");
+    assertInvalid("text/plain ; a=1",
+        "Parameter is not formatted correctly: \" ; a=1\" for: \"text/plain ; a=1\"");
+  }
+
+  @Test public void testDoubleQuotesAreSpecial() throws Exception {
+    MediaType mediaType = parse("text/plain;a=\";charset=utf-8;b=\"");
+    assertThat(mediaType.charset()).isNull();
+  }
+
+  @Test public void testSingleQuotesAreNotSpecial() throws Exception {
+    MediaType mediaType = parse("text/plain;a=';charset=utf-8;b='");
+    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
+  }
+
+  @Test public void testParseWithSpecialCharacters() throws Exception {
+    MediaType mediaType = parse("!#$%&'*+-.{|}~/!#$%&'*+-.{|}~; !#$%&'*+-.{|}~=!#$%&'*+-.{|}~");
+    assertThat(mediaType.type()).isEqualTo("!#$%&'*+-.{|}~");
+    assertThat(mediaType.subtype()).isEqualTo("!#$%&'*+-.{|}~");
+  }
+
+  @Test public void testCharsetIsOneOfManyParameters() throws Exception {
+    MediaType mediaType = parse("text/plain;a=1;b=2;charset=utf-8;c=3");
+    assertThat(mediaType.type()).isEqualTo("text");
+    assertThat(mediaType.subtype()).isEqualTo("plain");
+    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
+  }
+
+  @Test public void testCharsetAndQuoting() throws Exception {
+    MediaType mediaType = parse(
+        "text/plain;a=\";charset=us-ascii\";charset=\"utf-8\";b=\"iso-8859-1\"");
+    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
+  }
+
+  @Test public void testDuplicatedCharsets() {
+    MediaType mediaType = parse("text/plain; charset=utf-8; charset=UTF-8");
+    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
+  }
+
+  @Test public void testMultipleCharsets() {
+    assertInvalid("text/plain; charset=utf-8; charset=utf-16",
+        "Multiple charsets defined: \"utf-8\" and: \"utf-16\" for: \"text/plain; charset=utf-8; charset=utf-16\"");
+  }
+
+  @Test public void testIllegalCharsetName() {
+    MediaType mediaType = parse("text/plain; charset=\"!@#$%^&*()\"");
+    assertThat(mediaType.charset()).isNull();
+  }
+
+  @Test public void testUnsupportedCharset() {
+    MediaType mediaType = parse("text/plain; charset=utf-wtf");
+    assertThat(mediaType.charset()).isNull();
+  }
+
+  /**
+   * This is invalid according to RFC 822. But it's what Chrome does and it avoids a potentially
+   * unpleasant IllegalCharsetNameException.
+   */
+  @Test public void testCharsetNameIsSingleQuoted() throws Exception {
+    MediaType mediaType = parse("text/plain;charset='utf-8'");
+    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
+  }
+
+  @Test public void testCharsetNameIsDoubleQuotedAndSingleQuoted() throws Exception {
+    MediaType mediaType = parse("text/plain;charset=\"'utf-8'\"");
+    assertThat(mediaType.charset()).isNull();
+  }
+
+  @Test public void testCharsetNameIsDoubleQuotedSingleQuote() throws Exception {
+    MediaType mediaType = parse("text/plain;charset=\"'\"");
+    assertThat(mediaType.charset()).isNull();
+  }
+
+  @Test public void testDefaultCharset() throws Exception {
+    MediaType noCharset = parse("text/plain");
+    assertThat(noCharset.charset(UTF_8).name()).isEqualTo("UTF-8");
+    assertThat(noCharset.charset(Charset.forName("US-ASCII")).name()).isEqualTo("US-ASCII");
+
+    MediaType charset = parse("text/plain; charset=iso-8859-1");
+    assertThat(charset.charset(UTF_8).name()).isEqualTo("ISO-8859-1");
+    assertThat(charset.charset(Charset.forName("US-ASCII")).name()).isEqualTo("ISO-8859-1");
+  }
+
+  @Test public void testParseDanglingSemicolon() throws Exception {
+    MediaType mediaType = parse("text/plain;");
+    assertThat(mediaType.type()).isEqualTo("text");
+    assertThat(mediaType.subtype()).isEqualTo("plain");
+    assertThat(mediaType.charset()).isNull();
+    assertThat(mediaType.toString()).isEqualTo("text/plain;");
+  }
+
+  private void assertMediaType(String string) {
+    assertThat(parse(string).toString()).isEqualTo(string);
+  }
+
+  private void assertInvalid(String string, String exceptionMessage) {
+    if (useGet) {
+      try {
+        parse(string);
+        fail("Expected get of \"" + string + "\" to throw with: " + exceptionMessage);
+      } catch (IllegalArgumentException e) {
+        assertThat(e.getMessage()).isEqualTo(exceptionMessage);
+      }
+    } else {
+      assertThat(parse(string)).overridingErrorMessage(string).isNull();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java b/okhttp/src/test/java/okhttp3/MultipartBodyTest.java
similarity index 69%
rename from okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
rename to okhttp/src/test/java/okhttp3/MultipartBodyTest.java
index 35d2f67906..00ae7bbdf5 100644
--- a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
+++ b/okhttp/src/test/java/okhttp3/MultipartBodyTest.java
@@ -20,8 +20,8 @@
 import okio.BufferedSink;
 import org.junit.Test;
 
-import static okhttp3.internal.Util.UTF_8;
-import static org.junit.Assert.assertEquals;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class MultipartBodyTest {
@@ -30,7 +30,7 @@
       new MultipartBody.Builder().build();
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Multipart body must have at least one part.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Multipart body must have at least one part.");
     }
   }
 
@@ -46,16 +46,16 @@
         .addPart(RequestBody.create(null, "Hello, World!"))
         .build();
 
-    assertEquals("123", body.boundary());
-    assertEquals(MultipartBody.MIXED, body.type());
-    assertEquals("multipart/mixed; boundary=123", body.contentType().toString());
-    assertEquals(1, body.parts().size());
-    assertEquals(53, body.contentLength());
+    assertThat(body.boundary()).isEqualTo("123");
+    assertThat(body.type()).isEqualTo(MultipartBody.MIXED);
+    assertThat(body.contentType().toString()).isEqualTo("multipart/mixed; boundary=123");
+    assertThat(body.parts().size()).isEqualTo(1);
+    assertThat(body.contentLength()).isEqualTo(53);
 
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
-    assertEquals(buffer.size(), body.contentLength());
-    assertEquals(expected, buffer.readUtf8());
+    assertThat(body.contentLength()).isEqualTo(buffer.size());
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
   }
 
   @Test public void threeParts() throws Exception {
@@ -80,16 +80,16 @@
         .addPart(RequestBody.create(null, "Fox"))
         .build();
 
-    assertEquals("123", body.boundary());
-    assertEquals(MultipartBody.MIXED, body.type());
-    assertEquals("multipart/mixed; boundary=123", body.contentType().toString());
-    assertEquals(3, body.parts().size());
-    assertEquals(112, body.contentLength());
+    assertThat(body.boundary()).isEqualTo("123");
+    assertThat(body.type()).isEqualTo(MultipartBody.MIXED);
+    assertThat(body.contentType().toString()).isEqualTo("multipart/mixed; boundary=123");
+    assertThat(body.parts().size()).isEqualTo(3);
+    assertThat(body.contentLength()).isEqualTo(112);
 
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
-    assertEquals(buffer.size(), body.contentLength());
-    assertEquals(expected, buffer.readUtf8());
+    assertThat(body.contentLength()).isEqualTo(buffer.size());
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
   }
 
   @Test public void fieldAndTwoFiles() throws Exception {
@@ -129,27 +129,28 @@
                 .addPart(
                     Headers.of("Content-Disposition", "file; filename=\"file1.txt\""),
                     RequestBody.create(
-                        MediaType.parse("text/plain"), "... contents of file1.txt ..."))
+                        MediaType.get("text/plain"), "... contents of file1.txt ..."))
                 .addPart(
                     Headers.of(
                         "Content-Disposition", "file; filename=\"file2.gif\"",
                         "Content-Transfer-Encoding", "binary"),
                     RequestBody.create(
-                        MediaType.parse("image/gif"),
+                        MediaType.get("image/gif"),
                         "... contents of file2.gif ...".getBytes(UTF_8)))
                 .build())
         .build();
 
-    assertEquals("AaB03x", body.boundary());
-    assertEquals(MultipartBody.FORM, body.type());
-    assertEquals("multipart/form-data; boundary=AaB03x", body.contentType().toString());
-    assertEquals(2, body.parts().size());
-    assertEquals(568, body.contentLength());
+    assertThat(body.boundary()).isEqualTo("AaB03x");
+    assertThat(body.type()).isEqualTo(MultipartBody.FORM);
+    assertThat(body.contentType().toString()).isEqualTo(
+        "multipart/form-data; boundary=AaB03x");
+    assertThat(body.parts().size()).isEqualTo(2);
+    assertThat(body.contentLength()).isEqualTo(568);
 
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
-    assertEquals(buffer.size(), body.contentLength());
-    assertEquals(expected, buffer.readUtf8());
+    assertThat(body.contentLength()).isEqualTo(buffer.size());
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
   }
 
   @Test public void stringEscapingIsWeird() throws Exception {
@@ -171,7 +172,7 @@
         + "\r\n"
         + "%22\r\n"
         + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"field with \u0391\"\r\n"
+        + "Content-Disposition: form-data; name=\"field with \u007e\"\r\n"
         + "Content-Length: 5\r\n"
         + "\r\n"
         + "Alpha\r\n"
@@ -180,15 +181,15 @@
     MultipartBody body = new MultipartBody.Builder("AaB03x")
         .setType(MultipartBody.FORM)
         .addFormDataPart("field with spaces", "filename with spaces.txt",
-            RequestBody.create(MediaType.parse("text/plain; charset=utf-8"), "okay"))
+            RequestBody.create(MediaType.get("text/plain; charset=utf-8"), "okay"))
         .addFormDataPart("field with \"", "\"")
         .addFormDataPart("field with %22", "%22")
-        .addFormDataPart("field with \u0391", "Alpha")
+        .addFormDataPart("field with \u007e", "Alpha")
         .build();
 
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
-    assertEquals(expected, buffer.readUtf8());
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
   }
 
   @Test public void streamingPartHasNoLength() throws Exception {
@@ -228,15 +229,15 @@
         .addPart(RequestBody.create(null, "Fox"))
         .build();
 
-    assertEquals("123", body.boundary());
-    assertEquals(MultipartBody.MIXED, body.type());
-    assertEquals("multipart/mixed; boundary=123", body.contentType().toString());
-    assertEquals(3, body.parts().size());
-    assertEquals(-1, body.contentLength());
+    assertThat(body.boundary()).isEqualTo("123");
+    assertThat(body.type()).isEqualTo(MultipartBody.MIXED);
+    assertThat(body.contentType().toString()).isEqualTo("multipart/mixed; boundary=123");
+    assertThat(body.parts().size()).isEqualTo(3);
+    assertThat(body.contentLength()).isEqualTo(-1);
 
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
-    assertEquals(expected, buffer.readUtf8());
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
   }
 
   @Test public void contentTypeHeaderIsForbidden() throws Exception {
@@ -263,12 +264,33 @@
     MultipartBody body = new MultipartBody.Builder()
         .addPart(Headers.of("Foo", "Bar"), RequestBody.create(null, "Baz"))
         .build();
-    assertEquals(1, body.parts().size());
+    assertThat(body.parts().size()).isEqualTo(1);
 
     Buffer part1Buffer = new Buffer();
     MultipartBody.Part part1 = body.part(0);
     part1.body().writeTo(part1Buffer);
-    assertEquals(Headers.of("Foo", "Bar"), part1.headers());
-    assertEquals("Baz", part1Buffer.readUtf8());
+    assertThat(part1.headers()).isEqualTo(Headers.of("Foo", "Bar"));
+    assertThat(part1Buffer.readUtf8()).isEqualTo("Baz");
+  }
+
+  @Test public void nonAsciiFilename() throws Exception {
+    String expected = ""
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"attachment\"; filename=\"resum√©.pdf\"\r\n"
+        + "Content-Type: application/pdf; charset=utf-8\r\n"
+        + "Content-Length: 17\r\n"
+        + "\r\n"
+        + "Jesse‚Äôs Resum√©\r\n"
+        + "--AaB03x--\r\n";
+
+    MultipartBody body = new MultipartBody.Builder("AaB03x")
+        .setType(MultipartBody.FORM)
+        .addFormDataPart("attachment", "resum√©.pdf",
+            RequestBody.create(MediaType.parse("application/pdf"), "Jesse‚Äôs Resum√©"))
+        .build();
+
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    assertThat(buffer.readUtf8()).isEqualTo(expected);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp/src/test/java/okhttp3/OkHttpClientTest.java
similarity index 57%
rename from okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
rename to okhttp/src/test/java/okhttp3/OkHttpClientTest.java
index f38c9daaa1..7c8b1ffee7 100644
--- a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
+++ b/okhttp/src/test/java/okhttp3/OkHttpClientTest.java
@@ -15,23 +15,26 @@
  */
 package okhttp3;
 
-import java.io.IOException;
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.ProxySelector;
 import java.net.ResponseCache;
-import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLSocketFactory;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
 import org.junit.After;
+import org.junit.Rule;
 import org.junit.Test;
 
+import static java.util.Arrays.asList;
 import static okhttp3.TestUtil.defaultClient;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class OkHttpClientTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
   private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
   private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
   private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();
@@ -44,14 +47,19 @@
 
   @Test public void durationDefaults() {
     OkHttpClient client = defaultClient();
-    assertEquals(10_000, client.connectTimeoutMillis());
-    assertEquals(10_000, client.readTimeoutMillis());
-    assertEquals(10_000, client.writeTimeoutMillis());
-    assertEquals(0, client.pingIntervalMillis());
+    assertThat(client.callTimeoutMillis()).isEqualTo(0);
+    assertThat(client.connectTimeoutMillis()).isEqualTo(10_000);
+    assertThat(client.readTimeoutMillis()).isEqualTo(10_000);
+    assertThat(client.writeTimeoutMillis()).isEqualTo(10_000);
+    assertThat(client.pingIntervalMillis()).isEqualTo(0);
   }
 
   @Test public void timeoutValidRange() {
     OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.callTimeout(1, TimeUnit.NANOSECONDS);
+    } catch (IllegalArgumentException ignored) {
+    }
     try {
       builder.connectTimeout(1, TimeUnit.NANOSECONDS);
     } catch (IllegalArgumentException ignored) {
@@ -64,6 +72,10 @@
       builder.readTimeout(1, TimeUnit.NANOSECONDS);
     } catch (IllegalArgumentException ignored) {
     }
+    try {
+      builder.callTimeout(365, TimeUnit.DAYS);
+    } catch (IllegalArgumentException ignored) {
+    }
     try {
       builder.connectTimeout(365, TimeUnit.DAYS);
     } catch (IllegalArgumentException ignored) {
@@ -79,18 +91,14 @@
   }
 
   @Test public void clonedInterceptorsListsAreIndependent() throws Exception {
-    Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
-        return chain.proceed(chain.request());
-      }
-    };
+    Interceptor interceptor = chain -> chain.proceed(chain.request());
     OkHttpClient original = defaultClient();
     original.newBuilder()
         .addInterceptor(interceptor)
         .addNetworkInterceptor(interceptor)
         .build();
-    assertEquals(0, original.interceptors().size());
-    assertEquals(0, original.networkInterceptors().size());
+    assertThat(original.interceptors().size()).isEqualTo(0);
+    assertThat(original.networkInterceptors().size()).isEqualTo(0);
   }
 
   /**
@@ -102,21 +110,21 @@
 
     // Values should be non-null.
     OkHttpClient a = client.newBuilder().build();
-    assertNotNull(a.dispatcher());
-    assertNotNull(a.connectionPool());
-    assertNotNull(a.sslSocketFactory());
+    assertThat(a.dispatcher()).isNotNull();
+    assertThat(a.connectionPool()).isNotNull();
+    assertThat(a.sslSocketFactory()).isNotNull();
 
     // Multiple clients share the instances.
     OkHttpClient b = client.newBuilder().build();
-    assertSame(a.dispatcher(), b.dispatcher());
-    assertSame(a.connectionPool(), b.connectionPool());
-    assertSame(a.sslSocketFactory(), b.sslSocketFactory());
+    assertThat(b.dispatcher()).isSameAs(a.dispatcher());
+    assertThat(b.connectionPool()).isSameAs(a.connectionPool());
+    assertThat(b.sslSocketFactory()).isSameAs(a.sslSocketFactory());
   }
 
   @Test public void setProtocolsRejectsHttp10() throws Exception {
     OkHttpClient.Builder builder = new OkHttpClient.Builder();
     try {
-      builder.protocols(Arrays.asList(Protocol.HTTP_1_0, Protocol.HTTP_1_1));
+      builder.protocols(asList(Protocol.HTTP_1_0, Protocol.HTTP_1_1));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -125,7 +133,7 @@
   @Test public void certificatePinnerEquality() {
     OkHttpClient clientA = TestUtil.defaultClient();
     OkHttpClient clientB = TestUtil.defaultClient();
-    assertEquals(clientA.certificatePinner(), clientB.certificatePinner());
+    assertThat(clientB.certificatePinner()).isEqualTo(clientA.certificatePinner());
   }
 
   @Test public void nullInterceptor() {
@@ -134,7 +142,6 @@
       builder.addInterceptor(null);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("interceptor == null", expected.getMessage());
     }
   }
 
@@ -144,7 +151,6 @@
       builder.addNetworkInterceptor(null);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("interceptor == null", expected.getMessage());
     }
   }
 
@@ -155,7 +161,7 @@
       builder.build();
       fail();
     } catch (IllegalStateException expected) {
-      assertEquals("Null interceptor: [null]", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("Null interceptor: [null]");
     }
   }
 
@@ -166,38 +172,61 @@
       builder.build();
       fail();
     } catch (IllegalStateException expected) {
-      assertEquals("Null network interceptor: [null]", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("Null network interceptor: [null]");
     }
   }
 
-  @Test public void testH2COkHttpClientConstructionFallback() {
-    // fallbacks are not allowed when using h2c prior knowledge
+  @Test public void testH2PriorKnowledgeOkHttpClientConstructionFallback() {
     try {
       new OkHttpClient.Builder()
-              .protocols(Arrays.asList(Protocol.H2C, Protocol.HTTP_1_1));
-      fail("When H2C is specified, no other protocol can be specified");
+          .protocols(asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
+      fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("protocols containing h2c cannot use other protocols: [h2c, http/1.1]", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("protocols containing h2_prior_knowledge cannot use other protocols: "
+            + "[h2_prior_knowledge, http/1.1]"));
     }
   }
 
-  @Test public void testH2COkHttpClientConstructionDuplicates() {
-    // Treating this use case as user error
+  @Test public void testH2PriorKnowledgeOkHttpClientConstructionDuplicates() {
     try {
       new OkHttpClient.Builder()
-              .protocols(Arrays.asList(Protocol.H2C, Protocol.H2C));
-      fail("When H2C is specified, no other protocol can be specified");
+          .protocols(asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
+      fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("protocols containing h2c cannot use other protocols: [h2c, h2c]", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          ("protocols containing h2_prior_knowledge cannot use other protocols: "
+            + "[h2_prior_knowledge, h2_prior_knowledge]"));
     }
   }
 
-  @Test public void testH2COkHttpClientConstructionSuccess() {
+  @Test public void testH2PriorKnowledgeOkHttpClientConstructionSuccess() {
     OkHttpClient okHttpClient = new OkHttpClient.Builder()
-            .protocols(Arrays.asList(Protocol.H2C))
-            .build();
+        .protocols(asList(Protocol.H2_PRIOR_KNOWLEDGE))
+        .build();
+    assertThat(okHttpClient.protocols().size()).isEqualTo(1);
+    assertThat(okHttpClient.protocols().get(0)).isEqualTo(Protocol.H2_PRIOR_KNOWLEDGE);
+  }
 
-    assertEquals(1, okHttpClient.protocols().size());
-    assertEquals(Protocol.H2C, okHttpClient.protocols().get(0));
+  @Test public void nullDefaultProxySelector() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    ProxySelector.setDefault(null);
+
+    OkHttpClient client = defaultClient().newBuilder()
+        .build();
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+    Response response = client.newCall(request).execute();
+    assertThat(response.body().string()).isEqualTo("abc");
+  }
+
+  @Test public void sslSocketFactorySetAsSocketFactory() throws Exception {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.socketFactory(SSLSocketFactory.getDefault());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
   }
 }
diff --git a/okhttp/src/test/java/okhttp3/ProtocolTest.java b/okhttp/src/test/java/okhttp3/ProtocolTest.java
new file mode 100644
index 0000000000..ffced6eacf
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/ProtocolTest.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class ProtocolTest {
+  @Test
+  public void testGetKnown() throws IOException {
+    assertThat(Protocol.get("http/1.0")).isEqualTo(Protocol.HTTP_1_0);
+    assertThat(Protocol.get("http/1.1")).isEqualTo(Protocol.HTTP_1_1);
+    assertThat(Protocol.get("spdy/3.1")).isEqualTo(Protocol.SPDY_3);
+    assertThat(Protocol.get("h2")).isEqualTo(Protocol.HTTP_2);
+    assertThat(Protocol.get("h2_prior_knowledge")).isEqualTo(Protocol.H2_PRIOR_KNOWLEDGE);
+    assertThat(Protocol.get("quic")).isEqualTo(Protocol.QUIC);
+  }
+
+  @Test(expected = IOException.class)
+  public void testGetUnknown() throws IOException {
+    Protocol.get("tcp");
+  }
+
+  @Test
+  public void testToString() throws IOException {
+    assertThat(Protocol.HTTP_1_0.toString()).isEqualTo("http/1.0");
+    assertThat(Protocol.HTTP_1_1.toString()).isEqualTo("http/1.1");
+    assertThat(Protocol.SPDY_3.toString()).isEqualTo("spdy/3.1");
+    assertThat(Protocol.HTTP_2.toString()).isEqualTo("h2");
+    assertThat(Protocol.H2_PRIOR_KNOWLEDGE.toString()).isEqualTo("h2_prior_knowledge");
+    assertThat(Protocol.QUIC.toString()).isEqualTo("quic");
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java b/okhttp/src/test/java/okhttp3/RecordedResponse.java
similarity index 66%
rename from okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
rename to okhttp/src/test/java/okhttp3/RecordedResponse.java
index d34380cc4f..482d78179b 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
+++ b/okhttp/src/test/java/okhttp3/RecordedResponse.java
@@ -19,25 +19,22 @@
 import java.text.SimpleDateFormat;
 import java.util.Arrays;
 import java.util.Date;
+import javax.annotation.Nullable;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /**
  * A received response or failure recorded by the response recorder.
  */
 public final class RecordedResponse {
   public final Request request;
-  public final Response response;
-  public final WebSocket webSocket;
-  public final String body;
-  public final IOException failure;
+  public final @Nullable Response response;
+  public final @Nullable WebSocket webSocket;
+  public final @Nullable String body;
+  public final @Nullable IOException failure;
 
-  public RecordedResponse(Request request, Response response, WebSocket webSocket, String body,
-      IOException failure) {
+  public RecordedResponse(Request request, @Nullable Response response,
+      @Nullable WebSocket webSocket, @Nullable String body, @Nullable IOException failure) {
     this.request = request;
     this.response = response;
     this.webSocket = webSocket;
@@ -46,58 +43,58 @@ public RecordedResponse(Request request, Response response, WebSocket webSocket,
   }
 
   public RecordedResponse assertRequestUrl(HttpUrl url) {
-    assertEquals(url, request.url());
+    assertThat(request.url()).isEqualTo(url);
     return this;
   }
 
   public RecordedResponse assertRequestMethod(String method) {
-    assertEquals(method, request.method());
+    assertThat(request.method()).isEqualTo(method);
     return this;
   }
 
   public RecordedResponse assertRequestHeader(String name, String... values) {
-    assertEquals(Arrays.asList(values), request.headers(name));
+    assertThat(request.headers(name)).containsExactly(values);
     return this;
   }
 
   public RecordedResponse assertCode(int expectedCode) {
-    assertEquals(expectedCode, response.code());
+    assertThat(response.code()).isEqualTo(expectedCode);
     return this;
   }
 
   public RecordedResponse assertSuccessful() {
-    assertTrue(response.isSuccessful());
+    assertThat(response.isSuccessful()).isTrue();
     return this;
   }
 
   public RecordedResponse assertNotSuccessful() {
-    assertFalse(response.isSuccessful());
+    assertThat(response.isSuccessful()).isFalse();
     return this;
   }
 
   public RecordedResponse assertHeader(String name, String... values) {
-    assertEquals(Arrays.asList(values), response.headers(name));
+    assertThat(response.headers(name)).containsExactly(values);
     return this;
   }
 
   public RecordedResponse assertHeaders(Headers headers) {
-    assertEquals(headers, response.headers());
+    assertThat(response.headers()).isEqualTo(headers);
     return this;
   }
 
   public RecordedResponse assertBody(String expectedBody) {
-    assertEquals(expectedBody, body);
+    assertThat(body).isEqualTo(expectedBody);
     return this;
   }
 
   public RecordedResponse assertHandshake() {
     Handshake handshake = response.handshake();
-    assertNotNull(handshake.tlsVersion());
-    assertNotNull(handshake.cipherSuite());
-    assertNotNull(handshake.peerPrincipal());
-    assertEquals(1, handshake.peerCertificates().size());
-    assertNull(handshake.localPrincipal());
-    assertEquals(0, handshake.localCertificates().size());
+    assertThat(handshake.tlsVersion()).isNotNull();
+    assertThat(handshake.cipherSuite()).isNotNull();
+    assertThat(handshake.peerPrincipal()).isNotNull();
+    assertThat(handshake.peerCertificates().size()).isEqualTo(1);
+    assertThat(handshake.localPrincipal()).isNull();
+    assertThat(handshake.localCertificates().size()).isEqualTo(0);
     return this;
   }
 
@@ -106,8 +103,8 @@ public RecordedResponse assertHandshake() {
    */
   public RecordedResponse priorResponse() {
     Response priorResponse = response.priorResponse();
-    assertNotNull(priorResponse);
-    assertNull(priorResponse.body());
+    assertThat(priorResponse).isNotNull();
+    assertThat(priorResponse.body()).isNull();
     return new RecordedResponse(priorResponse.request(), priorResponse, null, null, null);
   }
 
@@ -116,20 +113,20 @@ public RecordedResponse priorResponse() {
    */
   public RecordedResponse networkResponse() {
     Response networkResponse = response.networkResponse();
-    assertNotNull(networkResponse);
-    assertNull(networkResponse.body());
+    assertThat(networkResponse).isNotNull();
+    assertThat(networkResponse.body()).isNull();
     return new RecordedResponse(networkResponse.request(), networkResponse, null, null, null);
   }
 
   /** Asserts that the current response didn't use the network. */
   public RecordedResponse assertNoNetworkResponse() {
-    assertNull(response.networkResponse());
+    assertThat(response.networkResponse()).isNull();
     return this;
   }
 
   /** Asserts that the current response didn't use the cache. */
   public RecordedResponse assertNoCacheResponse() {
-    assertNull(response.cacheResponse());
+    assertThat(response.cacheResponse()).isNull();
     return this;
   }
 
@@ -138,8 +135,8 @@ public RecordedResponse assertNoCacheResponse() {
    */
   public RecordedResponse cacheResponse() {
     Response cacheResponse = response.cacheResponse();
-    assertNotNull(cacheResponse);
-    assertNull(cacheResponse.body());
+    assertThat(cacheResponse).isNotNull();
+    assertThat(cacheResponse.body()).isNull();
     return new RecordedResponse(cacheResponse.request(), cacheResponse, null, null, null);
   }
 
@@ -151,19 +148,21 @@ public RecordedResponse assertFailure(Class<?>... allowedExceptionTypes) {
         break;
       }
     }
-    assertTrue("Expected exception type among " + Arrays.toString(allowedExceptionTypes)
-            + ", got " + failure, found);
+    assertThat(found)
+        .overridingErrorMessage("Expected exception type among "
+            + Arrays.toString(allowedExceptionTypes) + ", got " + failure)
+        .isTrue();
     return this;
   }
 
   public RecordedResponse assertFailure(String... messages) {
-    assertNotNull("No failure found", failure);
-    assertTrue(failure.getMessage(), Arrays.asList(messages).contains(failure.getMessage()));
+    assertThat(failure).overridingErrorMessage("No failure found").isNotNull();
+    assertThat(messages).contains(failure.getMessage());
     return this;
   }
 
   public RecordedResponse assertFailureMatches(String... patterns) {
-    assertNotNull(failure);
+    assertThat(failure).isNotNull();
     for (String pattern : patterns) {
       if (failure.getMessage().matches(pattern)) return this;
     }
@@ -181,8 +180,10 @@ public RecordedResponse assertReceivedResponseAtMillis(long minimum, long maximu
   }
 
   private void assertDateInRange(long minimum, long actual, long maximum) {
-    assertTrue("actual " + format(actual) + " < minimum " + format(maximum), actual >= minimum);
-    assertTrue("actual " + format(actual) + " > maximum " + format(minimum), actual <= maximum);
+    assertThat(actual)
+        .overridingErrorMessage("%s <= %s <= %s", format(minimum), format(actual), format(maximum))
+        .isBetween(minimum, maximum);
+
   }
 
   private String format(long time) {
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingCallback.java b/okhttp/src/test/java/okhttp3/RecordingCallback.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/RecordingCallback.java
rename to okhttp/src/test/java/okhttp3/RecordingCallback.java
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java b/okhttp/src/test/java/okhttp3/RecordingEventListener.java
similarity index 84%
rename from okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
rename to okhttp/src/test/java/okhttp3/RecordingEventListener.java
index 6799300cdf..47d3be7a14 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
+++ b/okhttp/src/test/java/okhttp3/RecordingEventListener.java
@@ -19,18 +19,17 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
-import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Deque;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import javax.annotation.Nullable;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
 
-public final class RecordingEventListener extends EventListener {
-  final Deque<CallEvent> eventSequence = new ArrayDeque<>();
+public class RecordingEventListener extends EventListener {
+  final Deque<CallEvent> eventSequence = new ConcurrentLinkedDeque<>();
 
   final List<Object> forbiddenLocks = new ArrayList<>();
 
@@ -44,11 +43,15 @@ public void forbidLock(Object lock) {
    * {@code eventClass} and returns it.
    */
   public <T> T removeUpToEvent(Class<T> eventClass) {
+    List<CallEvent> fullEventSequence = new ArrayList<>(eventSequence);
     Object event = eventSequence.poll();
     while (event != null && !eventClass.isInstance(event)) {
       event = eventSequence.poll();
     }
-    if (event == null) throw new AssertionError();
+    if (event == null) {
+      throw new AssertionError(
+          eventClass.getSimpleName() + " not found. Found " + fullEventSequence + ".");
+    }
     return eventClass.cast(event);
   }
 
@@ -66,14 +69,13 @@ public void clearAllEvents() {
 
   private void logEvent(CallEvent e) {
     for (Object lock : forbiddenLocks) {
-      assertFalse(lock.toString(), Thread.holdsLock(lock));
+      assertThat(Thread.holdsLock(lock)).overridingErrorMessage(lock.toString()).isFalse();
     }
 
     CallEvent startEvent = e.closes();
 
     if (startEvent != null) {
-      assertTrue(e.getName() + " without matching " + startEvent.getName(),
-          eventSequence.contains(startEvent));
+      assertThat(eventSequence).contains(startEvent);
     }
 
     eventSequence.offer(e);
@@ -127,7 +129,7 @@ private void logEvent(CallEvent e) {
   }
 
   @Override public void requestHeadersEnd(Call call, Request request) {
-    logEvent(new RequestHeadersEnd(call, request.headers.byteCount()));
+    logEvent(new RequestHeadersEnd(call, request.headers().byteCount()));
   }
 
   @Override public void requestBodyStart(Call call) {
@@ -138,12 +140,16 @@ private void logEvent(CallEvent e) {
     logEvent(new RequestBodyEnd(call, byteCount));
   }
 
+  @Override public void requestFailed(Call call, IOException ioe) {
+    logEvent(new RequestFailed(call, ioe));
+  }
+
   @Override public void responseHeadersStart(Call call) {
     logEvent(new ResponseHeadersStart(call));
   }
 
   @Override public void responseHeadersEnd(Call call, Response response) {
-    logEvent(new ResponseHeadersEnd(call, response.headers.byteCount()));
+    logEvent(new ResponseHeadersEnd(call, response.headers().byteCount()));
   }
 
   @Override public void responseBodyStart(Call call) {
@@ -154,6 +160,10 @@ private void logEvent(CallEvent e) {
     logEvent(new ResponseBodyEnd(call, byteCount));
   }
 
+  @Override public void responseFailed(Call call, IOException ioe) {
+    logEvent(new ResponseFailed(call, ioe));
+  }
+
   @Override public void callEnd(Call call) {
     logEvent(new CallEnd(call));
   }
@@ -168,7 +178,7 @@ private void logEvent(CallEvent e) {
 
     CallEvent(Call call, Object... params) {
       this.call = call;
-      this.params = Arrays.asList(params);
+      this.params = asList(params);
     }
 
     public String getName() {
@@ -217,7 +227,7 @@ public String getName() {
       this.inetAddressList = inetAddressList;
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new DnsStart(call, domainName);
     }
   }
@@ -265,7 +275,7 @@ public String getName() {
       this.ioe = ioe;
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new ConnectStart(call, inetSocketAddress, proxy);
     }
   }
@@ -284,7 +294,7 @@ public String getName() {
       this.handshake = handshake;
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new SecureConnectStart(call);
     }
   }
@@ -306,7 +316,7 @@ public String getName() {
       this.connection = connection;
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new ConnectionAcquired(call, connection);
     }
   }
@@ -322,7 +332,7 @@ public String getName() {
       super(call);
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new CallStart(call);
     }
   }
@@ -350,7 +360,7 @@ public String getName() {
       this.headerLength = headerLength;
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new RequestHeadersStart(call);
     }
   }
@@ -369,11 +379,20 @@ public String getName() {
       this.bytesWritten = bytesWritten;
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new RequestBodyStart(call);
     }
   }
 
+  static final class RequestFailed extends CallEvent {
+    final IOException ioe;
+
+    RequestFailed(Call call, IOException ioe) {
+      super(call, ioe);
+      this.ioe = ioe;
+    }
+  }
+
   static final class ResponseHeadersStart extends CallEvent {
     ResponseHeadersStart(Call call) {
       super(call);
@@ -388,7 +407,7 @@ public String getName() {
       this.headerLength = headerLength;
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new RequestHeadersStart(call);
     }
   }
@@ -407,8 +426,17 @@ public String getName() {
       this.bytesRead = bytesRead;
     }
 
-    @Nullable @Override public CallEvent closes() {
+    @Override public @Nullable CallEvent closes() {
       return new ResponseBodyStart(call);
     }
   }
+
+  static final class ResponseFailed extends CallEvent {
+    final IOException ioe;
+
+    ResponseFailed(Call call, IOException ioe) {
+      super(call, ioe);
+      this.ioe = ioe;
+    }
+  }
 }
diff --git a/okhttp/src/test/java/okhttp3/RecordingExecutor.kt b/okhttp/src/test/java/okhttp3/RecordingExecutor.kt
new file mode 100644
index 0000000000..c9ea6c8901
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/RecordingExecutor.kt
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2019 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import org.assertj.core.api.Assertions.assertThat
+import java.util.ArrayList
+import java.util.concurrent.AbstractExecutorService
+import java.util.concurrent.RejectedExecutionException
+import java.util.concurrent.TimeUnit
+
+internal class RecordingExecutor(
+  private val dispatcherTest: DispatcherTest
+) : AbstractExecutorService() {
+  private var shutdown: Boolean = false
+  private val calls = ArrayList<RealCall.AsyncCall>()
+
+  override fun execute(command: Runnable) {
+    if (shutdown) throw RejectedExecutionException()
+    calls.add(command as RealCall.AsyncCall)
+  }
+
+  fun assertJobs(vararg expectedUrls: String) {
+    val actualUrls = calls.map { it.request().url().toString() }
+    assertThat(actualUrls).containsExactly(*expectedUrls)
+  }
+
+  fun finishJob(url: String) {
+    val i = calls.iterator()
+    while (i.hasNext()) {
+      val call = i.next()
+      if (call.request().url().toString() == url) {
+        i.remove()
+        dispatcherTest.dispatcher.finished(call)
+        return
+      }
+    }
+    throw AssertionError("No such job: $url")
+  }
+
+  override fun shutdown() {
+    shutdown = true
+  }
+
+  override fun shutdownNow(): List<Runnable> {
+    throw UnsupportedOperationException()
+  }
+
+  override fun isShutdown(): Boolean {
+    throw UnsupportedOperationException()
+  }
+
+  override fun isTerminated(): Boolean {
+    throw UnsupportedOperationException()
+  }
+
+  override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean {
+    throw UnsupportedOperationException()
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingWebSocketListener.java b/okhttp/src/test/java/okhttp3/RecordingWebSocketListener.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/RecordingWebSocketListener.java
rename to okhttp/src/test/java/okhttp3/RecordingWebSocketListener.java
diff --git a/okhttp/src/test/java/okhttp3/RequestTest.java b/okhttp/src/test/java/okhttp3/RequestTest.java
new file mode 100644
index 0000000000..11bfe6a81f
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/RequestTest.java
@@ -0,0 +1,359 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.net.URI;
+import java.util.UUID;
+import okio.Buffer;
+import org.junit.Test;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class RequestTest {
+  @Test public void string() throws Exception {
+    MediaType contentType = MediaType.get("text/plain; charset=utf-8");
+    RequestBody body = RequestBody.create(contentType, "abc".getBytes(UTF_8));
+    assertThat(body.contentType()).isEqualTo(contentType);
+    assertThat(body.contentLength()).isEqualTo(3);
+    assertThat(bodyToHex(body)).isEqualTo("616263");
+    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
+        "616263");
+  }
+
+  @Test public void stringWithDefaultCharsetAdded() throws Exception {
+    MediaType contentType = MediaType.get("text/plain");
+    RequestBody body = RequestBody.create(contentType, "\u0800");
+    assertThat(body.contentType()).isEqualTo(MediaType.get("text/plain; charset=utf-8"));
+    assertThat(body.contentLength()).isEqualTo(3);
+    assertThat(bodyToHex(body)).isEqualTo("e0a080");
+  }
+
+  @Test public void stringWithNonDefaultCharsetSpecified() throws Exception {
+    MediaType contentType = MediaType.get("text/plain; charset=utf-16be");
+    RequestBody body = RequestBody.create(contentType, "\u0800");
+    assertThat(body.contentType()).isEqualTo(contentType);
+    assertThat(body.contentLength()).isEqualTo(2);
+    assertThat(bodyToHex(body)).isEqualTo("0800");
+  }
+
+  @Test public void byteArray() throws Exception {
+    MediaType contentType = MediaType.get("text/plain");
+    RequestBody body = RequestBody.create(contentType, "abc".getBytes(UTF_8));
+    assertThat(body.contentType()).isEqualTo(contentType);
+    assertThat(body.contentLength()).isEqualTo(3);
+    assertThat(bodyToHex(body)).isEqualTo("616263");
+    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
+        "616263");
+  }
+
+  @Test public void byteArrayRange() throws Exception {
+    MediaType contentType = MediaType.get("text/plain");
+    RequestBody body = RequestBody.create(contentType, ".abcd".getBytes(UTF_8), 1, 3);
+    assertThat(body.contentType()).isEqualTo(contentType);
+    assertThat(body.contentLength()).isEqualTo(3);
+    assertThat(bodyToHex(body)).isEqualTo("616263");
+    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
+        "616263");
+  }
+
+  @Test public void file() throws Exception {
+    File file = File.createTempFile("RequestTest", "tmp");
+    FileWriter writer = new FileWriter(file);
+    writer.write("abc");
+    writer.close();
+
+    MediaType contentType = MediaType.get("text/plain");
+    RequestBody body = RequestBody.create(contentType, file);
+    assertThat(body.contentType()).isEqualTo(contentType);
+    assertThat(body.contentLength()).isEqualTo(3);
+    assertThat(bodyToHex(body)).isEqualTo("616263");
+    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
+        "616263");
+  }
+
+  /** Common verbs used for apis such as GitHub, AWS, and Google Cloud. */
+  @Test public void crudVerbs() throws IOException {
+    MediaType contentType = MediaType.get("application/json");
+    RequestBody body = RequestBody.create(contentType, "{}");
+
+    Request get = new Request.Builder().url("http://localhost/api").get().build();
+    assertThat(get.method()).isEqualTo("GET");
+    assertThat(get.body()).isNull();
+
+    Request head = new Request.Builder().url("http://localhost/api").head().build();
+    assertThat(head.method()).isEqualTo("HEAD");
+    assertThat(head.body()).isNull();
+
+    Request delete = new Request.Builder().url("http://localhost/api").delete().build();
+    assertThat(delete.method()).isEqualTo("DELETE");
+    assertThat(delete.body().contentLength()).isEqualTo(0L);
+
+    Request post = new Request.Builder().url("http://localhost/api").post(body).build();
+    assertThat(post.method()).isEqualTo("POST");
+    assertThat(post.body()).isEqualTo(body);
+
+    Request put = new Request.Builder().url("http://localhost/api").put(body).build();
+    assertThat(put.method()).isEqualTo("PUT");
+    assertThat(put.body()).isEqualTo(body);
+
+    Request patch = new Request.Builder().url("http://localhost/api").patch(body).build();
+    assertThat(patch.method()).isEqualTo("PATCH");
+    assertThat(patch.body()).isEqualTo(body);
+  }
+
+  @Test public void uninitializedURI() throws Exception {
+    Request request = new Request.Builder().url("http://localhost/api").build();
+    assertThat(request.url().uri()).isEqualTo(new URI("http://localhost/api"));
+    assertThat(request.url()).isEqualTo(HttpUrl.get("http://localhost/api"));
+  }
+
+  @Test public void newBuilderUrlResetsUrl() {
+    Request requestWithoutCache = new Request.Builder().url("http://localhost/api").build();
+    Request builtRequestWithoutCache =
+        requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
+    assertThat(builtRequestWithoutCache.url()).isEqualTo(
+        HttpUrl.get("http://localhost/api/foo"));
+
+    Request requestWithCache = new Request.Builder().url("http://localhost/api").build();
+    // cache url object
+    requestWithCache.url();
+    Request builtRequestWithCache = requestWithCache.newBuilder().url(
+        "http://localhost/api/foo").build();
+    assertThat(builtRequestWithCache.url()).isEqualTo(
+        HttpUrl.get("http://localhost/api/foo"));
+  }
+
+  @Test public void cacheControl() {
+    Request request = new Request.Builder()
+        .cacheControl(new CacheControl.Builder().noCache().build())
+        .url("https://square.com")
+        .build();
+    assertThat(request.headers("Cache-Control")).containsExactly("no-cache");
+  }
+
+  @Test public void emptyCacheControlClearsAllCacheControlHeaders() {
+    Request request = new Request.Builder()
+        .header("Cache-Control", "foo")
+        .cacheControl(new CacheControl.Builder().build())
+        .url("https://square.com")
+        .build();
+    assertThat(request.headers("Cache-Control")).isEmpty();
+  }
+
+  @Test public void headerAcceptsPermittedCharacters() {
+    Request.Builder builder = new Request.Builder();
+    builder.header("AZab09~", "AZab09 ~");
+    builder.addHeader("AZab09~", "AZab09 ~");
+  }
+
+  @Test public void emptyNameForbidden() {
+    Request.Builder builder = new Request.Builder();
+    try {
+      builder.header("", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.addHeader("", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void headerForbidsNullArguments() {
+    Request.Builder builder = new Request.Builder();
+    try {
+      builder.header(null, "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.addHeader(null, "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.header("Name", null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.addHeader("Name", null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void headerAllowsTabOnlyInValues() {
+    Request.Builder builder = new Request.Builder();
+    builder.header("key", "sample\tvalue");
+    try {
+      builder.header("sample\tkey", "value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void headerForbidsControlCharacters() {
+    assertForbiddenHeader("\u0000");
+    assertForbiddenHeader("\r");
+    assertForbiddenHeader("\n");
+    assertForbiddenHeader("\u001f");
+    assertForbiddenHeader("\u007f");
+    assertForbiddenHeader("\u0080");
+    assertForbiddenHeader("\ud83c\udf69");
+  }
+
+  private void assertForbiddenHeader(String s) {
+    Request.Builder builder = new Request.Builder();
+    try {
+      builder.header(s, "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.addHeader(s, "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.header("Name", s);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      builder.addHeader("Name", s);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void noTag() {
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .build();
+    assertThat(request.tag()).isNull();
+    assertThat(request.tag(Object.class)).isNull();
+    assertThat(request.tag(UUID.class)).isNull();
+    assertThat(request.tag(String.class)).isNull();
+  }
+
+  @Test public void defaultTag() {
+    UUID tag = UUID.randomUUID();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(tag)
+        .build();
+    assertThat(request.tag()).isSameAs(tag);
+    assertThat(request.tag(Object.class)).isSameAs(tag);
+    assertThat(request.tag(UUID.class)).isNull();
+    assertThat(request.tag(String.class)).isNull();
+  }
+
+  @Test public void nullRemovesTag() {
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag("a")
+        .tag(null)
+        .build();
+    assertThat(request.tag()).isNull();
+  }
+
+  @Test public void removeAbsentTag() {
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(null)
+        .build();
+    assertThat(request.tag()).isNull();
+  }
+
+  @Test public void objectTag() {
+    UUID tag = UUID.randomUUID();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(Object.class, tag)
+        .build();
+    assertThat(request.tag()).isSameAs(tag);
+    assertThat(request.tag(Object.class)).isSameAs(tag);
+    assertThat(request.tag(UUID.class)).isNull();
+    assertThat(request.tag(String.class)).isNull();
+  }
+
+  @Test public void typedTag() {
+    UUID uuidTag = UUID.randomUUID();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(UUID.class, uuidTag)
+        .build();
+    assertThat(request.tag()).isNull();
+    assertThat(request.tag(Object.class)).isNull();
+    assertThat(request.tag(UUID.class)).isSameAs(uuidTag);
+    assertThat(request.tag(String.class)).isNull();
+  }
+
+  @Test public void replaceOnlyTag() {
+    UUID uuidTag1 = UUID.randomUUID();
+    UUID uuidTag2 = UUID.randomUUID();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(UUID.class, uuidTag1)
+        .tag(UUID.class, uuidTag2)
+        .build();
+    assertThat(request.tag(UUID.class)).isSameAs(uuidTag2);
+  }
+
+  @Test public void multipleTags() {
+    UUID uuidTag = UUID.randomUUID();
+    String stringTag = "dilophosaurus";
+    Long longTag = 20170815L;
+    Object objectTag = new Object();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(Object.class, objectTag)
+        .tag(UUID.class, uuidTag)
+        .tag(String.class, stringTag)
+        .tag(Long.class, longTag)
+        .build();
+    assertThat(request.tag()).isSameAs(objectTag);
+    assertThat(request.tag(Object.class)).isSameAs(objectTag);
+    assertThat(request.tag(UUID.class)).isSameAs(uuidTag);
+    assertThat(request.tag(String.class)).isSameAs(stringTag);
+    assertThat(request.tag(Long.class)).isSameAs(longTag);
+  }
+
+  /** Confirm that we don't accidentally share the backing map between objects. */
+  @Test public void tagsAreImmutable() {
+    Request.Builder builder = new Request.Builder()
+        .url("https://square.com");
+    Request requestA = builder.tag(String.class, "a").build();
+    Request requestB = builder.tag(String.class, "b").build();
+    Request requestC = requestA.newBuilder().tag(String.class, "c").build();
+    assertThat(requestA.tag(String.class)).isSameAs("a");
+    assertThat(requestB.tag(String.class)).isSameAs("b");
+    assertThat(requestC.tag(String.class)).isSameAs("c");
+  }
+
+  private String bodyToHex(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return buffer.readByteString().hex();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java b/okhttp/src/test/java/okhttp3/ResponseBodyTest.java
similarity index 78%
rename from okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
rename to okhttp/src/test/java/okhttp3/ResponseBodyTest.java
index 47feecacb6..cced85f93a 100644
--- a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
+++ b/okhttp/src/test/java/okhttp3/ResponseBodyTest.java
@@ -27,59 +27,59 @@
 import okio.Okio;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ResponseBodyTest {
   @Test public void stringEmpty() throws IOException {
     ResponseBody body = body("");
-    assertEquals("", body.string());
+    assertThat(body.string()).isEqualTo("");
   }
 
   @Test public void stringLooksLikeBomButTooShort() throws IOException {
     ResponseBody body = body("000048");
-    assertEquals("\0\0H", body.string());
+    assertThat(body.string()).isEqualTo("\0\0H");
   }
 
   @Test public void stringDefaultsToUtf8() throws IOException {
     ResponseBody body = body("68656c6c6f");
-    assertEquals("hello", body.string());
+    assertThat(body.string()).isEqualTo("hello");
   }
 
   @Test public void stringExplicitCharset() throws IOException {
     ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
-    assertEquals("hello", body.string());
+    assertThat(body.string()).isEqualTo("hello");
   }
 
   @Test public void stringBomOverridesExplicitCharset() throws IOException {
     ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f", "utf-8");
-    assertEquals("hello", body.string());
+    assertThat(body.string()).isEqualTo("hello");
   }
 
   @Test public void stringBomUtf8() throws IOException {
     ResponseBody body = body("efbbbf68656c6c6f");
-    assertEquals("hello", body.string());
+    assertThat(body.string()).isEqualTo("hello");
   }
 
   @Test public void stringBomUtf16Be() throws IOException {
     ResponseBody body = body("feff00680065006c006c006f");
-    assertEquals("hello", body.string());
+    assertThat(body.string()).isEqualTo("hello");
   }
 
   @Test public void stringBomUtf16Le() throws IOException {
     ResponseBody body = body("fffe680065006c006c006f00");
-    assertEquals("hello", body.string());
+    assertThat(body.string()).isEqualTo("hello");
   }
 
   @Test public void stringBomUtf32Be() throws IOException {
     ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f");
-    assertEquals("hello", body.string());
+    assertThat(body.string()).isEqualTo("hello");
   }
 
   @Test public void stringBomUtf32Le() throws IOException {
     ResponseBody body = body("ffff000068000000650000006c0000006c0000006f000000");
-    assertEquals("hello", body.string());
+    assertThat(body.string()).isEqualTo("hello");
   }
 
   @Test public void stringClosesUnderlyingSource() throws IOException {
@@ -103,53 +103,53 @@
         });
       }
     };
-    assertEquals("hello", body.string());
-    assertTrue(closed.get());
+    assertThat(body.string()).isEqualTo("hello");
+    assertThat(closed.get()).isTrue();
   }
 
   @Test public void readerEmpty() throws IOException {
     ResponseBody body = body("");
-    assertEquals("", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("");
   }
 
   @Test public void readerLooksLikeBomButTooShort() throws IOException {
     ResponseBody body = body("000048");
-    assertEquals("\0\0H", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("\0\0H");
   }
 
   @Test public void readerDefaultsToUtf8() throws IOException {
     ResponseBody body = body("68656c6c6f");
-    assertEquals("hello", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("hello");
   }
 
   @Test public void readerExplicitCharset() throws IOException {
     ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
-    assertEquals("hello", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("hello");
   }
 
   @Test public void readerBomUtf8() throws IOException {
     ResponseBody body = body("efbbbf68656c6c6f");
-    assertEquals("hello", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("hello");
   }
 
   @Test public void readerBomUtf16Be() throws IOException {
     ResponseBody body = body("feff00680065006c006c006f");
-    assertEquals("hello", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("hello");
   }
 
   @Test public void readerBomUtf16Le() throws IOException {
     ResponseBody body = body("fffe680065006c006c006f00");
-    assertEquals("hello", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("hello");
   }
 
   @Test public void readerBomUtf32Be() throws IOException {
     ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f");
-    assertEquals("hello", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("hello");
   }
 
   @Test public void readerBomUtf32Le() throws IOException {
     ResponseBody body = body("ffff000068000000650000006c0000006c0000006f000000");
-    assertEquals("hello", exhaust(body.charStream()));
+    assertThat(exhaust(body.charStream())).isEqualTo("hello");
   }
 
   @Test public void readerClosedBeforeBomClosesUnderlyingSource() throws IOException {
@@ -174,7 +174,7 @@
       }
     };
     body.charStream().close();
-    assertTrue(closed.get());
+    assertThat(closed.get()).isTrue();
   }
 
   @Test public void readerClosedAfterBomClosesUnderlyingSource() throws IOException {
@@ -199,25 +199,25 @@
       }
     };
     Reader reader = body.charStream();
-    assertEquals('h', reader.read());
+    assertThat(reader.read()).isEqualTo('h');
     reader.close();
-    assertTrue(closed.get());
+    assertThat(closed.get()).isTrue();
   }
 
   @Test public void sourceEmpty() throws IOException {
     ResponseBody body = body("");
     BufferedSource source = body.source();
-    assertTrue(source.exhausted());
-    assertEquals("", source.readUtf8());
+    assertThat(source.exhausted()).isTrue();
+    assertThat(source.readUtf8()).isEqualTo("");
   }
 
   @Test public void sourceSeesBom() throws IOException {
     ResponseBody body = body("efbbbf68656c6c6f");
     BufferedSource source = body.source();
-    assertEquals(0xef, source.readByte() & 0xff);
-    assertEquals(0xbb, source.readByte() & 0xff);
-    assertEquals(0xbf, source.readByte() & 0xff);
-    assertEquals("hello", source.readUtf8());
+    assertThat((source.readByte() & 0xff)).isEqualTo(0xef);
+    assertThat((source.readByte() & 0xff)).isEqualTo(0xbb);
+    assertThat((source.readByte() & 0xff)).isEqualTo(0xbf);
+    assertThat(source.readUtf8()).isEqualTo("hello");
   }
 
   @Test public void sourceClosesUnderlyingSource() throws IOException {
@@ -242,21 +242,21 @@
       }
     };
     body.source().close();
-    assertTrue(closed.get());
+    assertThat(closed.get()).isTrue();
   }
 
   @Test public void bytesEmpty() throws IOException {
     ResponseBody body = body("");
-    assertEquals(0, body.bytes().length);
+    assertThat(body.bytes().length).isEqualTo(0);
   }
 
   @Test public void bytesSeesBom() throws IOException {
     ResponseBody body = body("efbbbf68656c6c6f");
     byte[] bytes = body.bytes();
-    assertEquals(0xef, bytes[0] & 0xff);
-    assertEquals(0xbb, bytes[1] & 0xff);
-    assertEquals(0xbf, bytes[2] & 0xff);
-    assertEquals("hello", new String(bytes, 3, 5, "UTF-8"));
+    assertThat((bytes[0] & 0xff)).isEqualTo(0xef);
+    assertThat((bytes[1] & 0xff)).isEqualTo(0xbb);
+    assertThat((bytes[2] & 0xff)).isEqualTo(0xbf);
+    assertThat(new String(bytes, 3, 5, UTF_8)).isEqualTo("hello");
   }
 
   @Test public void bytesClosesUnderlyingSource() throws IOException {
@@ -280,8 +280,8 @@
         });
       }
     };
-    assertEquals(5, body.bytes().length);
-    assertTrue(closed.get());
+    assertThat(body.bytes().length).isEqualTo(5);
+    assertThat(closed.get()).isTrue();
   }
 
   @Test public void bytesThrowsWhenLengthsDisagree() {
@@ -302,7 +302,8 @@
       body.bytes();
       fail();
     } catch (IOException e) {
-      assertEquals("Content-Length (10) and stream length (5) disagree", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "Content-Length (10) and stream length (5) disagree");
     }
   }
 
@@ -324,23 +325,24 @@
       body.bytes();
       fail();
     } catch (IOException e) {
-      assertEquals("Cannot buffer entire body for content length: 2147483648", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "Cannot buffer entire body for content length: 2147483648");
     }
   }
 
   @Test public void byteStreamEmpty() throws IOException {
     ResponseBody body = body("");
     InputStream bytes = body.byteStream();
-    assertEquals(-1, bytes.read());
+    assertThat(bytes.read()).isEqualTo(-1);
   }
 
   @Test public void byteStreamSeesBom() throws IOException {
     ResponseBody body = body("efbbbf68656c6c6f");
     InputStream bytes = body.byteStream();
-    assertEquals(0xef, bytes.read());
-    assertEquals(0xbb, bytes.read());
-    assertEquals(0xbf, bytes.read());
-    assertEquals("hello", exhaust(new InputStreamReader(bytes, "utf-8")));
+    assertThat(bytes.read()).isEqualTo(0xef);
+    assertThat(bytes.read()).isEqualTo(0xbb);
+    assertThat(bytes.read()).isEqualTo(0xbf);
+    assertThat(exhaust(new InputStreamReader(bytes, UTF_8))).isEqualTo("hello");
   }
 
   @Test public void byteStreamClosesUnderlyingSource() throws IOException {
@@ -365,7 +367,7 @@
       }
     };
     body.byteStream().close();
-    assertTrue(closed.get());
+    assertThat(closed.get()).isTrue();
   }
 
   @Test public void throwingUnderlyingSourceClosesQuietly() throws IOException {
@@ -387,7 +389,7 @@
         });
       }
     };
-    assertEquals("hello", body.source().readUtf8());
+    assertThat(body.source().readUtf8()).isEqualTo("hello");
     body.close();
   }
 
@@ -396,8 +398,8 @@ static ResponseBody body(String hex) {
   }
 
   static ResponseBody body(String hex, String charset) {
-    MediaType mediaType = charset == null ? null : MediaType.parse("any/thing; charset=" + charset);
-    return ResponseBody.create(mediaType, ByteString.decodeHex(hex).toByteArray());
+    MediaType mediaType = charset == null ? null : MediaType.get("any/thing; charset=" + charset);
+    return ResponseBody.create(mediaType, ByteString.decodeHex(hex));
   }
 
   static String exhaust(Reader reader) throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseTest.java b/okhttp/src/test/java/okhttp3/ResponseTest.java
similarity index 84%
rename from okhttp-tests/src/test/java/okhttp3/ResponseTest.java
rename to okhttp/src/test/java/okhttp3/ResponseTest.java
index 5d77a02a26..162d2d9a39 100644
--- a/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
+++ b/okhttp/src/test/java/okhttp3/ResponseTest.java
@@ -23,27 +23,27 @@
 import okio.Timeout;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class ResponseTest {
   @Test public void peekShorterThanResponse() throws Exception {
     Response response = newResponse(responseBody("abcdef"));
     ResponseBody peekedBody = response.peekBody(3);
-    assertEquals("abc", peekedBody.string());
-    assertEquals("abcdef", response.body().string());
+    assertThat(peekedBody.string()).isEqualTo("abc");
+    assertThat(response.body().string()).isEqualTo("abcdef");
   }
 
   @Test public void peekLongerThanResponse() throws Exception {
     Response response = newResponse(responseBody("abc"));
     ResponseBody peekedBody = response.peekBody(6);
-    assertEquals("abc", peekedBody.string());
-    assertEquals("abc", response.body().string());
+    assertThat(peekedBody.string()).isEqualTo("abc");
+    assertThat(response.body().string()).isEqualTo("abc");
   }
 
   @Test public void peekAfterReadingResponse() throws Exception {
     Response response = newResponse(responseBody("abc"));
-    assertEquals("abc", response.body().string());
+    assertThat(response.body().string()).isEqualTo("abc");
 
     try {
       response.peekBody(3);
@@ -56,9 +56,9 @@
     Response response = newResponse(responseBody("abcdef"));
     ResponseBody p1 = response.peekBody(4);
     ResponseBody p2 = response.peekBody(2);
-    assertEquals("abcdef", response.body().string());
-    assertEquals("abcd", p1.string());
-    assertEquals("ab", p2.string());
+    assertThat(response.body().string()).isEqualTo("abcdef");
+    assertThat(p1.string()).isEqualTo("abcd");
+    assertThat(p2.string()).isEqualTo("ab");
   }
 
   /**
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java b/okhttp/src/test/java/okhttp3/SocksProxy.java
similarity index 98%
rename from okhttp-tests/src/test/java/okhttp3/SocksProxy.java
rename to okhttp/src/test/java/okhttp3/SocksProxy.java
index d56241ac91..4675171798 100644
--- a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
+++ b/okhttp/src/test/java/okhttp3/SocksProxy.java
@@ -61,8 +61,7 @@
 
   private ServerSocket serverSocket;
   private AtomicInteger connectionCount = new AtomicInteger();
-  private final Set<Socket> openSockets =
-      Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
+  private final Set<Socket> openSockets = Collections.newSetFromMap(new ConcurrentHashMap<>());
 
   public void play() throws IOException {
     serverSocket = new ServerSocket(0);
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java b/okhttp/src/test/java/okhttp3/SocksProxyTest.java
similarity index 84%
rename from okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
rename to okhttp/src/test/java/okhttp3/SocksProxyTest.java
index 83a6617b90..6768632b6f 100644
--- a/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
+++ b/okhttp/src/test/java/okhttp3/SocksProxyTest.java
@@ -26,22 +26,22 @@
 import okhttp3.mockwebserver.MockWebServer;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class SocksProxyTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
   private final SocksProxy socksProxy = new SocksProxy();
-  private final MockWebServer server = new MockWebServer();
 
   @Before public void setUp() throws Exception {
-    server.start();
     socksProxy.play();
   }
 
   @After public void tearDown() throws Exception {
-    server.shutdown();
     socksProxy.shutdown();
   }
 
@@ -55,14 +55,14 @@
 
     Request request1 = new Request.Builder().url(server.url("/")).build();
     Response response1 = client.newCall(request1).execute();
-    assertEquals("abc", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("abc");
 
     Request request2 = new Request.Builder().url(server.url("/")).build();
     Response response2 = client.newCall(request2).execute();
-    assertEquals("def", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("def");
 
     // The HTTP calls should share a single connection.
-    assertEquals(1, socksProxy.connectionCount());
+    assertThat(socksProxy.connectionCount()).isEqualTo(1);
   }
 
   @Test public void proxySelector() throws Exception {
@@ -84,9 +84,9 @@
 
     Request request = new Request.Builder().url(server.url("/")).build();
     Response response = client.newCall(request).execute();
-    assertEquals("abc", response.body().string());
+    assertThat(response.body().string()).isEqualTo("abc");
 
-    assertEquals(1, socksProxy.connectionCount());
+    assertThat(socksProxy.connectionCount()).isEqualTo(1);
   }
 
   @Test public void checkRemoteDNSResolve() throws Exception {
@@ -104,8 +104,8 @@
 
     Request request = new Request.Builder().url(url).build();
     Response response1 = client.newCall(request).execute();
-    assertEquals("abc", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("abc");
 
-    assertEquals(1, socksProxy.connectionCount());
+    assertThat(socksProxy.connectionCount()).isEqualTo(1);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java b/okhttp/src/test/java/okhttp3/TestLogHandler.java
similarity index 97%
rename from okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
rename to okhttp/src/test/java/okhttp3/TestLogHandler.java
index 52f5d2da7f..055b25e226 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
+++ b/okhttp/src/test/java/okhttp3/TestLogHandler.java
@@ -50,7 +50,7 @@
     return list;
   }
 
-  public String take() throws InterruptedException {
+  public String take() throws Exception {
     String message = logs.poll(10, TimeUnit.SECONDS);
     if (message == null) {
       throw new AssertionError("Timed out waiting for log message.");
diff --git a/okhttp/src/test/java/okhttp3/TestTls13Request.java b/okhttp/src/test/java/okhttp3/TestTls13Request.java
new file mode 100644
index 0000000000..797dcde7a9
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/TestTls13Request.java
@@ -0,0 +1,106 @@
+package okhttp3;
+
+import java.io.IOException;
+import java.security.Security;
+import java.util.List;
+import okhttp3.internal.platform.Platform;
+import org.conscrypt.Conscrypt;
+
+import static java.util.Arrays.asList;
+
+public class TestTls13Request {
+
+  // TLS 1.3
+  private static final CipherSuite[] TLS13_CIPHER_SUITES = new CipherSuite[] {
+      CipherSuite.TLS_AES_128_GCM_SHA256,
+      CipherSuite.TLS_AES_256_GCM_SHA384,
+      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_AES_128_CCM_SHA256,
+      CipherSuite.TLS_AES_128_CCM_8_SHA256
+  };
+
+  /**
+   * A TLS 1.3 only Connection Spec. This will be eventually be exposed
+   * as part of MODERN_TLS or folded into the default OkHttp client once published and
+   * available in JDK11 or Conscrypt.
+   */
+  private static final ConnectionSpec TLS_13 = new ConnectionSpec.Builder(true)
+      .cipherSuites(TLS13_CIPHER_SUITES)
+      .tlsVersions(TlsVersion.TLS_1_3)
+      .build();
+
+
+  private static final ConnectionSpec TLS_12 =
+      new ConnectionSpec.Builder(ConnectionSpec.RESTRICTED_TLS).tlsVersions(TlsVersion.TLS_1_2)
+          .build();
+
+  private TestTls13Request() {
+  }
+
+  public static void main(String[] args) {
+    //System.setProperty("javax.net.debug", "ssl:handshake:verbose");
+    Security.insertProviderAt(Conscrypt.newProviderBuilder().provideTrustManager().build(), 1);
+
+    System.out.println(
+        "Running tests using " + Platform.get() + " " + System.getProperty("java.vm.version"));
+
+    // https://github.com/tlswg/tls13-spec/wiki/Implementations
+    List<String> urls =
+        asList("https://enabled.tls13.com", "https://www.howsmyssl.com/a/check",
+            "https://tls13.cloudflare.com", "https://www.allizom.org/robots.txt",
+            "https://tls13.crypto.mozilla.org/", "https://tls.ctf.network/robots.txt",
+            "https://rustls.jbp.io/", "https://h2o.examp1e.net", "https://mew.org/",
+            "https://tls13.baishancloud.com/", "https://tls13.akamai.io/", "https://swifttls.org/",
+            "https://www.googleapis.com/robots.txt", "https://graph.facebook.com/robots.txt",
+            "https://api.twitter.com/robots.txt", "https://connect.squareup.com/robots.txt");
+
+    System.out.println("TLS1.3+TLS1.2");
+    testClient(urls, buildClient(ConnectionSpec.RESTRICTED_TLS));
+
+    System.out.println("\nTLS1.3 only");
+    testClient(urls, buildClient(TLS_13));
+
+    System.out.println("\nTLS1.3 then fallback");
+    testClient(urls, buildClient(TLS_13, TLS_12));
+  }
+
+  private static void testClient(List<String> urls, OkHttpClient client) {
+    try {
+      for (String url : urls) {
+        sendRequest(client, url);
+      }
+    } finally {
+      client.dispatcher().executorService().shutdownNow();
+      client.connectionPool().evictAll();
+    }
+  }
+
+  private static OkHttpClient buildClient(ConnectionSpec... specs) {
+    return new OkHttpClient.Builder().connectionSpecs(asList(specs)).build();
+  }
+
+  private static void sendRequest(OkHttpClient client, String url) {
+    System.out.printf("%-40s ", url);
+    System.out.flush();
+
+    System.out.println(Platform.get());
+
+    Request request = new Request.Builder().url(url).build();
+
+    try (Response response = client.newCall(request).execute()) {
+      Handshake handshake = response.handshake();
+      System.out.println(handshake.tlsVersion()
+          + " "
+          + handshake.cipherSuite()
+          + " "
+          + response.protocol()
+          + " "
+          + response.code()
+          + " "
+          + response.body().bytes().length
+          + "b");
+    } catch (IOException ioe) {
+      System.out.println(ioe.toString());
+    }
+  }
+}
diff --git a/okhttp/src/test/java/okhttp3/URLConnectionTest.java b/okhttp/src/test/java/okhttp3/URLConnectionTest.java
new file mode 100644
index 0000000000..813853d1ac
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/URLConnectionTest.java
@@ -0,0 +1,3859 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.Authenticator;
+import java.net.ConnectException;
+import java.net.CookieManager;
+import java.net.HttpURLConnection;
+import java.net.InetAddress;
+import java.net.PasswordAuthentication;
+import java.net.ProtocolException;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketAddress;
+import java.net.SocketException;
+import java.net.SocketTimeoutException;
+import java.net.URI;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.UnknownHostException;
+import java.security.KeyStore;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.zip.GZIPInputStream;
+import javax.annotation.Nullable;
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLProtocolException;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.internal.InternalKtKt;
+import okhttp3.internal.RecordingAuthenticator;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.Util;
+import okhttp3.internal.Version;
+import okhttp3.internal.platform.Platform;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.GzipSink;
+import okio.Okio;
+import okio.Utf8;
+import org.junit.After;
+import org.junit.AssumptionViolatedException;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Arrays.asList;
+import static java.util.Locale.US;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static okhttp3.internal.InternalKtKt.addHeaderLenient;
+import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
+import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
+import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
+
+/** Android's URLConnectionTest, ported to exercise OkHttp's Call API. */
+public final class URLConnectionTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final MockWebServer server2 = new MockWebServer();
+  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+
+  private HandshakeCertificates handshakeCertificates = localhost();
+  private OkHttpClient client = clientTestRule.client;
+  private @Nullable Cache cache;
+
+  @Before public void setUp() {
+    server.setProtocolNegotiationEnabled(false);
+  }
+
+  @After public void tearDown() throws Exception {
+    Authenticator.setDefault(null);
+    System.clearProperty("proxyHost");
+    System.clearProperty("proxyPort");
+    System.clearProperty("http.proxyHost");
+    System.clearProperty("http.proxyPort");
+    System.clearProperty("https.proxyHost");
+    System.clearProperty("https.proxyPort");
+    if (cache != null) {
+      cache.delete();
+    }
+  }
+
+  @Test public void requestHeaders() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .addHeader("D", "e")
+        .addHeader("D", "f")
+        .build();
+    assertThat(request.header("D")).isEqualTo("f");
+    assertThat(request.header("d")).isEqualTo("f");
+    Headers requestHeaders = request.headers();
+    assertThat(new LinkedHashSet<>(requestHeaders.values("D"))).isEqualTo(
+        newSet("e", "f"));
+    assertThat(new LinkedHashSet<>(requestHeaders.values("d"))).isEqualTo(
+        newSet("e", "f"));
+    try {
+      new Request.Builder()
+          .header(null, "j");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Request.Builder()
+          .addHeader(null, "k");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Request.Builder()
+          .addHeader("NullValue", null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Request.Builder()
+          .addHeader("AnotherNullValue", null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+
+    Response response = getResponse(request);
+    response.close();
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertThat(recordedRequest.getHeaders().values("D")).isEqualTo(
+        asList("e", "f"));
+    assertThat(recordedRequest.getHeader("G")).isNull();
+    assertThat(recordedRequest.getHeader("null")).isNull();
+  }
+
+  @Test public void getRequestPropertyReturnsLastValue() {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .addHeader("A", "value1")
+        .addHeader("A", "value2")
+        .build();
+    assertThat(request.header("A")).isEqualTo("value2");
+  }
+
+  @Test public void responseHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.0 200 Fantastic")
+        .addHeader("A: c")
+        .addHeader("B: d")
+        .addHeader("A: e")
+        .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
+
+    Request request = newRequest("/");
+    Response response = getResponse(request);
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("Fantastic");
+    try {
+      response.header(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    Headers responseHeaders = response.headers();
+    assertThat(new LinkedHashSet<>(responseHeaders.values("A"))).isEqualTo(
+        newSet("c", "e"));
+    assertThat(new LinkedHashSet<>(responseHeaders.values("a"))).isEqualTo(
+        newSet("c", "e"));
+    assertThat(responseHeaders.name(0)).isEqualTo("A");
+    assertThat(responseHeaders.value(0)).isEqualTo("c");
+    assertThat(responseHeaders.name(1)).isEqualTo("B");
+    assertThat(responseHeaders.value(1)).isEqualTo("d");
+    assertThat(responseHeaders.name(2)).isEqualTo("A");
+    assertThat(responseHeaders.value(2)).isEqualTo("e");
+    response.body().close();
+  }
+
+  @Test public void serverSendsInvalidStatusLine() {
+    server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
+
+    Request request = newRequest("/");
+
+    try {
+      getResponse(request);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void serverSendsInvalidCodeTooLarge() {
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
+
+    Request request = newRequest("/");
+
+    try {
+      getResponse(request);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void serverSendsInvalidCodeNotANumber() {
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
+
+    Request request = newRequest("/");
+    try {
+      getResponse(request);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void serverSendsUnnecessaryWhitespace() {
+    server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
+
+    Request request = newRequest("/");
+    try {
+      getResponse(request);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void connectRetriesUntilConnectedOrFailed() throws Exception {
+    Request request = newRequest("/foo");
+    server.shutdown();
+
+    try {
+      getResponse(request);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void requestBodySurvivesRetriesWithFixedLength() throws Exception {
+    testRequestBodySurvivesRetries(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void requestBodySurvivesRetriesWithChunkedStreaming() throws Exception {
+    testRequestBodySurvivesRetries(TransferKind.CHUNKED);
+  }
+
+  private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    // Use a misconfigured proxy to guarantee that the request is retried.
+    client = client.newBuilder()
+        .proxySelector(new FakeProxySelector()
+            .addProxy(server2.toProxyAddress())
+            .addProxy(Proxy.NO_PROXY))
+        .build();
+    server2.shutdown();
+
+    Request request = new Request.Builder()
+        .url(server.url("/def"))
+        .post(transferKind.newRequestBody("body"))
+        .build();
+    Response response = getResponse(request);
+    assertContent("abc", response);
+
+    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("body");
+  }
+
+  // Check that if we don't read to the end of a response, the next request on the
+  // recycled connection doesn't get the unread tail of the first request's response.
+  // http://code.google.com/p/android/issues/detail?id=2939
+  @Test public void bug2939() throws Exception {
+    MockResponse response = new MockResponse()
+        .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8);
+
+    server.enqueue(response);
+    server.enqueue(response);
+
+    Request request = newRequest("/");
+    Response c1 = getResponse(request);
+    assertContent("ABCDE", c1, 5);
+    Response c2 = getResponse(request);
+    assertContent("ABCDE", c2, 5);
+
+    c1.close();
+    c2.close();
+  }
+
+  @Test public void connectionsArePooled() throws Exception {
+    MockResponse response = new MockResponse()
+        .setBody("ABCDEFGHIJKLMNOPQR");
+
+    server.enqueue(response);
+    server.enqueue(response);
+    server.enqueue(response);
+
+    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/foo")));
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/bar?baz=quux")));
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/z")));
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
+  }
+
+  @Test public void chunkedConnectionsArePooled() throws Exception {
+    MockResponse response = new MockResponse()
+        .setChunkedBody("ABCDEFGHIJKLMNOPQR", 5);
+
+    server.enqueue(response);
+    server.enqueue(response);
+    server.enqueue(response);
+
+    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/foo")));
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/bar?baz=quux")));
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/z")));
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
+  }
+
+  @Test public void serverClosesSocket() throws Exception {
+    testServerClosesOutput(DISCONNECT_AT_END);
+  }
+
+  @Test public void serverShutdownInput() throws Exception {
+    testServerClosesOutput(SHUTDOWN_INPUT_AT_END);
+  }
+
+  @Test public void serverShutdownOutput() throws Exception {
+    testServerClosesOutput(SHUTDOWN_OUTPUT_AT_END);
+  }
+
+  @Test public void invalidHost() throws Exception {
+    // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
+    client = client.newBuilder()
+        .dns(new FakeDns())
+        .build();
+    try {
+      getResponse(new Request.Builder()
+          .url(HttpUrl.get("http://1234.1.1.1/index.html"))
+          .build());
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("This connection won't pool properly")
+        .setSocketPolicy(socketPolicy));
+    MockResponse responseAfter = new MockResponse()
+        .setBody("This comes after a busted connection");
+    server.enqueue(responseAfter);
+    server.enqueue(responseAfter); // Enqueue 2x because the broken connection may be reused.
+
+    Response response1 = getResponse(newRequest("/a"));
+    response1.body().source().timeout().timeout(100, MILLISECONDS);
+    assertContent("This connection won't pool properly", response1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+
+    // Give the server time to enact the socket policy if it's one that could happen after the
+    // client has received the response.
+    Thread.sleep(500);
+
+    Response response2 = getResponse(newRequest("/b"));
+    response1.body().source().timeout().timeout(100, MILLISECONDS);
+    assertContent("This comes after a busted connection", response2);
+
+    // Check that a fresh connection was created, either immediately or after attempting reuse.
+    // We know that a fresh connection was created if the server recorded a request with sequence
+    // number 0. Since the client may have attempted to reuse the broken connection just before
+    // creating a fresh connection, the server may have recorded 2 requests at this point. The order
+    // of recording is non-deterministic.
+    RecordedRequest requestAfter = server.takeRequest();
+    assertThat(requestAfter.getSequenceNumber() == 0
+        || server.getRequestCount() == 3 && server.takeRequest().getSequenceNumber() == 0).isTrue();
+  }
+
+  enum WriteKind {BYTE_BY_BYTE, SMALL_BUFFERS, LARGE_BUFFERS}
+
+  @Test public void chunkedUpload_byteByByte() throws Exception {
+    doUpload(TransferKind.CHUNKED, WriteKind.BYTE_BY_BYTE);
+  }
+
+  @Test public void chunkedUpload_smallBuffers() throws Exception {
+    doUpload(TransferKind.CHUNKED, WriteKind.SMALL_BUFFERS);
+  }
+
+  @Test public void chunkedUpload_largeBuffers() throws Exception {
+    doUpload(TransferKind.CHUNKED, WriteKind.LARGE_BUFFERS);
+  }
+
+  @Test public void fixedLengthUpload_byteByByte() throws Exception {
+    doUpload(TransferKind.FIXED_LENGTH, WriteKind.BYTE_BY_BYTE);
+  }
+
+  @Test public void fixedLengthUpload_smallBuffers() throws Exception {
+    doUpload(TransferKind.FIXED_LENGTH, WriteKind.SMALL_BUFFERS);
+  }
+
+  @Test public void fixedLengthUpload_largeBuffers() throws Exception {
+    doUpload(TransferKind.FIXED_LENGTH, WriteKind.LARGE_BUFFERS);
+  }
+
+  private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Exception {
+    int n = 512 * 1024;
+    server.setBodyLimit(0);
+    server.enqueue(new MockResponse());
+
+    RequestBody requestBody = new RequestBody() {
+      @Override public @Nullable MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return uploadKind == TransferKind.CHUNKED ? -1L : n;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        if (writeKind == WriteKind.BYTE_BY_BYTE) {
+          for (int i = 0; i < n; ++i) {
+            sink.writeByte('x');
+          }
+        } else {
+          byte[] buf = new byte[writeKind == WriteKind.SMALL_BUFFERS ? 256 : 64 * 1024];
+          Arrays.fill(buf, (byte) 'x');
+          for (int i = 0; i < n; i += buf.length) {
+            sink.write(buf, 0, Math.min(buf.length, n - i));
+          }
+        }
+      }
+    };
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(requestBody)
+        .build());
+    assertThat(response.code()).isEqualTo(200);
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBodySize()).isEqualTo(n);
+    if (uploadKind == TransferKind.CHUNKED) {
+      assertThat(request.getChunkSizes()).isNotEmpty();
+    } else {
+      assertThat(request.getChunkSizes()).isEmpty();
+    }
+  }
+
+  @Test public void connectViaHttps() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("this response comes via HTTPS"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Response response = getResponse(newRequest("/foo"));
+    assertContent("this response comes via HTTPS", response);
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+  }
+
+  @Test public void connectViaHttpsReusingConnections() throws Exception {
+    connectViaHttpsReusingConnections(false);
+  }
+
+  @Test public void connectViaHttpsReusingConnectionsAfterRebuildingClient() throws Exception {
+    connectViaHttpsReusingConnections(true);
+  }
+
+  private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("this response comes via HTTPS"));
+    server.enqueue(new MockResponse()
+        .setBody("another response via HTTPS"));
+
+    // The pool will only reuse sockets if the SSL socket factories are the same.
+    SSLSocketFactory clientSocketFactory = handshakeCertificates.sslSocketFactory();
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+
+    CookieJar cookieJar = new JavaNetCookieJar(new CookieManager());
+    ConnectionPool connectionPool = new ConnectionPool();
+
+    client = new OkHttpClient.Builder()
+        .cache(cache)
+        .connectionPool(connectionPool)
+        .cookieJar(cookieJar)
+        .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+    Response response1 = getResponse(newRequest("/"));
+    assertContent("this response comes via HTTPS", response1);
+
+    if (rebuildClient) {
+      client = new OkHttpClient.Builder()
+          .cache(cache)
+          .connectionPool(connectionPool)
+          .cookieJar(cookieJar)
+          .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
+          .hostnameVerifier(hostnameVerifier)
+          .build();
+    }
+
+    Response response2 = getResponse(newRequest("/"));
+    assertContent("another response via HTTPS", response2);
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+  }
+
+  @Test public void connectViaHttpsReusingConnectionsDifferentFactories() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("this response comes via HTTPS"));
+    server.enqueue(new MockResponse()
+        .setBody("another response via HTTPS"));
+
+    // install a custom SSL socket factory so the server can be authorized
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    Response response1 = getResponse(newRequest("/"));
+    assertContent("this response comes via HTTPS", response1);
+
+    SSLContext sslContext2 = Platform.get().getSSLContext();
+    sslContext2.init(null, null, null);
+    SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
+
+    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    trustManagerFactory.init((KeyStore) null);
+    X509TrustManager trustManager = (X509TrustManager) trustManagerFactory.getTrustManagers()[0];
+
+    client = client.newBuilder()
+        .sslSocketFactory(sslSocketFactory2, trustManager)
+        .build();
+    try {
+      getResponse(newRequest("/"));
+      fail("without an SSL socket factory, the connection should fail");
+    } catch (SSLException expected) {
+    }
+  }
+
+  // TODO(jwilson): tests below this marker need to be migrated to OkHttp's request/response API.
+
+  @Test public void connectViaHttpsWithSSLFallback() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse()
+        .setBody("this response comes via SSL"));
+
+    client = client.newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
+        .build();
+    Response response = getResponse(newRequest("/foo"));
+
+    assertContent("this response comes via SSL", response);
+
+    RecordedRequest failHandshakeRequest = server.takeRequest();
+    assertThat(failHandshakeRequest.getRequestLine()).isNull();
+
+    RecordedRequest fallbackRequest = server.takeRequest();
+    assertThat(fallbackRequest.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(fallbackRequest.getTlsVersion()).isIn(TlsVersion.TLS_1_2, TlsVersion.TLS_1_3);
+  }
+
+  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(FAIL_HANDSHAKE));
+
+    client = client.newBuilder()
+        .connectionSpecs(asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
+        .build();
+
+    try {
+      getResponse(newRequest("/foo"));
+      fail();
+    } catch (IOException expected) {
+      assertThat(expected.getSuppressed().length).isEqualTo(1);
+    }
+  }
+
+  /**
+   * When a pooled connection fails, don't blame the route. Otherwise pooled connection failures can
+   * cause unnecessary SSL fallbacks.
+   *
+   * https://github.com/square/okhttp/issues/515
+   */
+  @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setSocketPolicy(DISCONNECT_AT_END));
+    server.enqueue(new MockResponse()
+        .setBody("def"));
+
+    client = client.newBuilder()
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
+        .build();
+
+    assertContent("abc", getResponse(newRequest("/")));
+
+    // Give the server time to disconnect.
+    Thread.sleep(500);
+
+    assertContent("def", getResponse(newRequest("/")));
+
+    Set<TlsVersion> tlsVersions =
+        EnumSet.of(TlsVersion.TLS_1_0, TlsVersion.TLS_1_2,
+            TlsVersion.TLS_1_3); // v1.2 on OpenJDK 8.
+
+    RecordedRequest request1 = server.takeRequest();
+    assertThat(tlsVersions).contains(request1.getTlsVersion());
+
+    RecordedRequest request2 = server.takeRequest();
+    assertThat(tlsVersions).contains(request2.getTlsVersion());
+  }
+
+  /**
+   * Verify that we don't retry connections on certificate verification errors.
+   *
+   * http://code.google.com/p/android/issues/detail?id=13178
+   */
+  @Test public void connectViaHttpsToUntrustedServer() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()); // unused
+
+    try {
+      getResponse(newRequest("/foo"));
+      fail();
+    } catch (SSLHandshakeException expected) {
+      assertThat(expected.getCause()).isInstanceOf(CertificateException.class);
+    }
+    assertThat(server.getRequestCount()).isEqualTo(0);
+  }
+
+  @Test public void connectViaProxyUsingProxyArg() throws Exception {
+    testConnectViaProxy(ProxyConfig.CREATE_ARG);
+  }
+
+  @Test public void connectViaProxyUsingProxySystemProperty() throws Exception {
+    testConnectViaProxy(ProxyConfig.PROXY_SYSTEM_PROPERTY);
+  }
+
+  @Test public void connectViaProxyUsingHttpProxySystemProperty() throws Exception {
+    testConnectViaProxy(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
+  }
+
+  private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
+    MockResponse mockResponse = new MockResponse()
+        .setBody("this response comes via a proxy");
+    server.enqueue(mockResponse);
+
+    HttpUrl url = HttpUrl.parse("http://android.com/foo");
+    Response response = proxyConfig.connect(server, client, url).execute();
+    assertContent("this response comes via a proxy", response);
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getRequestLine()).isEqualTo(
+        "GET http://android.com/foo HTTP/1.1");
+    assertThat(request.getHeader("Host")).isEqualTo("android.com");
+  }
+
+  @Test public void contentDisagreesWithContentLengthHeaderBodyTooLong() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("abc\r\nYOU SHOULD NOT SEE THIS")
+        .clearHeaders()
+        .addHeader("Content-Length: 3"));
+    assertContent("abc", getResponse(newRequest("/")));
+  }
+
+  @Test public void contentDisagreesWithContentLengthHeaderBodyTooShort() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setHeader("Content-Length", "5")
+        .setSocketPolicy(DISCONNECT_AT_END));
+    try {
+      Response response = getResponse(newRequest("/"));
+      response.body().source().readUtf8(5);
+      fail();
+    } catch (ProtocolException expected) {
+    }
+  }
+
+  private void testConnectViaSocketFactory(boolean useHttps) throws IOException {
+    SocketFactory uselessSocketFactory = new SocketFactory() {
+      @Override public Socket createSocket() {
+        throw new IllegalArgumentException("useless");
+      }
+
+      @Override public Socket createSocket(InetAddress host, int port) {
+        return null;
+      }
+
+      @Override public Socket createSocket(InetAddress address, int port, InetAddress localAddress,
+          int localPort) {
+        return null;
+      }
+
+      @Override public Socket createSocket(String host, int port) {
+        return null;
+      }
+
+      @Override public Socket createSocket(String host, int port, InetAddress localHost, int localPort) {
+        return null;
+      }
+    };
+
+    if (useHttps) {
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+      client = client.newBuilder()
+          .sslSocketFactory(
+              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+          .hostnameVerifier(new RecordingHostnameVerifier())
+          .build();
+    }
+
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 200 OK"));
+
+    client = client.newBuilder()
+        .socketFactory(uselessSocketFactory)
+        .build();
+    try {
+      getResponse(newRequest("/"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+
+    client = client.newBuilder()
+        .socketFactory(SocketFactory.getDefault())
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.code()).isEqualTo(200);
+  }
+
+  @Test public void connectHttpViaSocketFactory() throws Exception {
+    testConnectViaSocketFactory(false);
+  }
+
+  @Test public void connectHttpsViaSocketFactory() throws Exception {
+    testConnectViaSocketFactory(true);
+  }
+
+  @Test public void contentDisagreesWithChunkedHeaderBodyTooLong() throws IOException {
+    MockResponse mockResponse = new MockResponse()
+        .setChunkedBody("abc", 3);
+    Buffer buffer = mockResponse.getBody();
+    buffer.writeUtf8("\r\nYOU SHOULD NOT SEE THIS");
+    mockResponse.setBody(buffer);
+    mockResponse.clearHeaders();
+    mockResponse.addHeader("Transfer-encoding: chunked");
+
+    server.enqueue(mockResponse);
+
+    assertContent("abc", getResponse(newRequest("/")));
+  }
+
+  @Test public void contentDisagreesWithChunkedHeaderBodyTooShort() {
+    MockResponse mockResponse = new MockResponse()
+        .setChunkedBody("abcdefg", 5);
+
+    Buffer truncatedBody = new Buffer();
+    Buffer fullBody = mockResponse.getBody();
+    truncatedBody.write(fullBody, 4);
+    mockResponse.setBody(truncatedBody);
+
+    mockResponse.clearHeaders();
+    mockResponse.addHeader("Transfer-encoding: chunked");
+    mockResponse.setSocketPolicy(DISCONNECT_AT_END);
+
+    server.enqueue(mockResponse);
+
+    try {
+      Response response = getResponse(newRequest("/"));
+      response.body().source().readUtf8(7);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void connectViaHttpProxyToHttpsUsingProxyArgWithNoProxy() throws Exception {
+    testConnectViaDirectProxyToHttps(ProxyConfig.NO_PROXY);
+  }
+
+  @Test public void connectViaHttpProxyToHttpsUsingHttpProxySystemProperty() throws Exception {
+    // https should not use http proxy
+    testConnectViaDirectProxyToHttps(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
+  }
+
+  private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("this response comes via HTTPS"));
+
+    HttpUrl url = server.url("/foo");
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    Call call = proxyConfig.connect(server, client, url);
+
+    assertContent("this response comes via HTTPS", call.execute());
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+  }
+
+  @Test public void connectViaHttpProxyToHttpsUsingProxyArg() throws Exception {
+    testConnectViaHttpProxyToHttps(ProxyConfig.CREATE_ARG);
+  }
+
+  /**
+   * We weren't honoring all of the appropriate proxy system properties when connecting via HTTPS.
+   * http://b/3097518
+   */
+  @Test public void connectViaHttpProxyToHttpsUsingProxySystemProperty() throws Exception {
+    testConnectViaHttpProxyToHttps(ProxyConfig.PROXY_SYSTEM_PROPERTY);
+  }
+
+  @Test public void connectViaHttpProxyToHttpsUsingHttpsProxySystemProperty() throws Exception {
+    testConnectViaHttpProxyToHttps(ProxyConfig.HTTPS_PROXY_SYSTEM_PROPERTY);
+  }
+
+  /**
+   * We were verifying the wrong hostname when connecting to an HTTPS site through a proxy.
+   * http://b/3097277
+   */
+  private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("this response comes via a secure proxy"));
+
+    HttpUrl url = HttpUrl.parse("https://android.com/foo");
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+    Call call = proxyConfig.connect(server, client, url);
+
+    assertContent("this response comes via a secure proxy", call.execute());
+
+    RecordedRequest connect = server.takeRequest();
+    assertThat(connect.getRequestLine()).overridingErrorMessage(
+        "Connect line failure on proxy").isEqualTo("CONNECT android.com:443 HTTP/1.1");
+    assertThat(connect.getHeader("Host")).isEqualTo("android.com:443");
+
+    RecordedRequest get = server.takeRequest();
+    assertThat(get.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(get.getHeader("Host")).isEqualTo("android.com");
+    assertThat(hostnameVerifier.calls).isEqualTo(
+        asList("verify android.com"));
+  }
+
+  /** Tolerate bad https proxy response when using HttpResponseCache. Android bug 6754912. */
+  @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
+    initResponseCache();
+
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
+    MockResponse badProxyResponse = new MockResponse()
+        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
+        .setBody("bogus proxy connect response content");
+    server.enqueue(badProxyResponse);
+    server.enqueue(new MockResponse()
+        .setBody("response"));
+
+    // Configure a single IP address for the host and a single configuration, so we only need one
+    // failure to fail permanently.
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS))
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Response response = getResponse(new Request.Builder()
+        .url(HttpUrl.get("https://android.com/foo"))
+        .build());
+    assertContent("response", response);
+
+    RecordedRequest connect = server.takeRequest();
+    assertThat(connect.getRequestLine()).isEqualTo(
+        "CONNECT android.com:443 HTTP/1.1");
+    assertThat(connect.getHeader("Host")).isEqualTo("android.com:443");
+  }
+
+  private void initResponseCache() {
+    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
+    client = client.newBuilder()
+        .cache(cache)
+        .build();
+  }
+
+  /** Test which headers are sent unencrypted to the HTTP proxy. */
+  @Test public void proxyConnectIncludesProxyHeadersOnly() throws Exception {
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("encrypted response from the origin server"));
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+
+    Response response = getResponse(new Request.Builder()
+        .url(HttpUrl.get("https://android.com/foo"))
+        .header("Private", "Secret")
+        .header("Proxy-Authorization", "bar")
+        .header("User-Agent", "baz")
+        .build());
+    assertContent("encrypted response from the origin server", response);
+
+    RecordedRequest connect = server.takeRequest();
+    assertThat(connect.getHeader("Private")).isNull();
+    assertThat(connect.getHeader("Proxy-Authorization")).isNull();
+    assertThat(connect.getHeader("User-Agent")).isEqualTo(Version.userAgent());
+    assertThat(connect.getHeader("Host")).isEqualTo("android.com:443");
+    assertThat(connect.getHeader("Proxy-Connection")).isEqualTo("Keep-Alive");
+
+    RecordedRequest get = server.takeRequest();
+    assertThat(get.getHeader("Private")).isEqualTo("Secret");
+    assertThat(hostnameVerifier.calls).isEqualTo(
+        asList("verify android.com"));
+  }
+
+  @Test public void proxyAuthenticateOnConnect() throws Exception {
+    Authenticator.setDefault(new RecordingAuthenticator());
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    client = client.newBuilder()
+        .proxyAuthenticator(new JavaNetAuthenticator())
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Response response = getResponse(new Request.Builder()
+        .url(HttpUrl.parse("https://android.com/foo"))
+        .build());
+    assertContent("A", response);
+
+    RecordedRequest connect1 = server.takeRequest();
+    assertThat(connect1.getRequestLine()).isEqualTo(
+        "CONNECT android.com:443 HTTP/1.1");
+    assertThat(connect1.getHeader("Proxy-Authorization")).isNull();
+
+    RecordedRequest connect2 = server.takeRequest();
+    assertThat(connect2.getRequestLine()).isEqualTo(
+        "CONNECT android.com:443 HTTP/1.1");
+    assertThat(connect2.getHeader("Proxy-Authorization")).isEqualTo(
+        ("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS));
+
+    RecordedRequest get = server.takeRequest();
+    assertThat(get.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(get.getHeader("Proxy-Authorization")).isNull();
+  }
+
+  // Don't disconnect after building a tunnel with CONNECT
+  // http://code.google.com/p/android/issues/detail?id=37221
+  @Test public void proxyWithConnectionClose() throws IOException {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("this response comes via a proxy"));
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    Response response = getResponse(new Request.Builder()
+        .url("https://android.com/foo")
+        .header("Connection", "close")
+        .build());
+
+    assertContent("this response comes via a proxy", response);
+  }
+
+  @Test public void proxyWithConnectionReuse() throws IOException {
+    SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+
+    server.useHttps(socketFactory, true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
+        .clearHeaders());
+    server.enqueue(new MockResponse()
+        .setBody("response 1"));
+    server.enqueue(new MockResponse()
+        .setBody("response 2"));
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
+        .hostnameVerifier(hostnameVerifier)
+        .build();
+
+    assertContent("response 1", getResponse(newRequest(HttpUrl.get("https://android.com/foo"))));
+    assertContent("response 2", getResponse(newRequest(HttpUrl.get("https://android.com/foo"))));
+  }
+
+  @Test public void proxySelectorHttpWithConnectionReuse() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("response 1"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(407));
+
+    client = client.newBuilder()
+        .proxySelector(new ProxySelector() {
+          @Override public List<Proxy> select(URI uri) {
+            return Collections.singletonList(server.toProxyAddress());
+          }
+
+          @Override public void connectFailed(
+              URI uri, SocketAddress socketAddress, IOException e) {
+          }
+        }).build();
+    HttpUrl url = HttpUrl.get("http://android.com/foo");
+    assertContent("response 1", getResponse(newRequest(url)));
+    assertThat(getResponse(newRequest(url)).code()).isEqualTo(407);
+  }
+
+  @Test public void disconnectedConnection() throws IOException {
+    server.enqueue(new MockResponse()
+        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
+        .setBody("ABCD"));
+
+    Call call = client.newCall(newRequest("/"));
+    Response response = call.execute();
+    InputStream in = response.body().byteStream();
+    assertThat((char) in.read()).isEqualTo('A');
+    call.cancel();
+    try {
+      // Reading 'B' may succeed if it's buffered.
+      in.read();
+
+      // But 'C' shouldn't be buffered (the response is throttled) and this should fail.
+      in.read();
+      fail("Expected a connection closed exception");
+    } catch (IOException expected) {
+    }
+    in.close();
+  }
+
+  @Test public void disconnectDuringConnect_cookieJar() {
+    AtomicReference<Call> callReference = new AtomicReference<>();
+
+    class DisconnectingCookieJar implements CookieJar {
+      @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
+      }
+
+      @Override public List<Cookie> loadForRequest(HttpUrl url) {
+        callReference.get().cancel();
+        return Collections.emptyList();
+      }
+    }
+    client = client.newBuilder()
+        .cookieJar(new DisconnectingCookieJar())
+        .build();
+
+    Call call = client.newCall(newRequest("/"));
+    callReference.set(call);
+    try {
+      call.execute();
+      fail("Connection should not be established");
+    } catch (IOException expected) {
+      assertThat(expected.getMessage()).isEqualTo("Canceled");
+    }
+  }
+
+  @Test public void disconnectBeforeConnect() {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    Call call = client.newCall(newRequest("/"));
+    call.cancel();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @SuppressWarnings("deprecation") @Test public void defaultRequestProperty() {
+    URLConnection.setDefaultRequestProperty("X-testSetDefaultRequestProperty", "A");
+    assertThat(
+        (Object) URLConnection.getDefaultRequestProperty("X-setDefaultRequestProperty")).isNull();
+  }
+
+  /**
+   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
+   * characters can be read, the remaining characters are returned and the stream is closed.
+   */
+  private String readAscii(InputStream in, int count) throws IOException {
+    StringBuilder result = new StringBuilder();
+    for (int i = 0; i < count; i++) {
+      int value = in.read();
+      if (value == -1) {
+        in.close();
+        break;
+      }
+      result.append((char) value);
+    }
+    return result.toString();
+  }
+
+  @Test public void markAndResetWithContentLengthHeader() throws IOException {
+    testMarkAndReset(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void markAndResetWithChunkedEncoding() throws IOException {
+    testMarkAndReset(TransferKind.CHUNKED);
+  }
+
+  @Test public void markAndResetWithNoLengthHeaders() throws IOException {
+    testMarkAndReset(TransferKind.END_OF_STREAM);
+  }
+
+  private void testMarkAndReset(TransferKind transferKind) throws IOException {
+    MockResponse response = new MockResponse();
+    transferKind.setBody(response, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1024);
+    server.enqueue(response);
+    server.enqueue(response);
+
+    InputStream in = getResponse(newRequest("/")).body().byteStream();
+    assertThat(in.markSupported())
+        .overridingErrorMessage("This implementation claims to support mark().")
+        .isFalse();
+    in.mark(5);
+    assertThat(readAscii(in, 5)).isEqualTo("ABCDE");
+    try {
+      in.reset();
+      fail();
+    } catch (IOException expected) {
+    }
+    assertThat(readAscii(in, Integer.MAX_VALUE)).isEqualTo(
+        "FGHIJKLMNOPQRSTUVWXYZ");
+    in.close();
+    assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", getResponse(newRequest("/")));
+  }
+
+  /**
+   * We've had a bug where we forget the HTTP response when we see response code 401. This causes a
+   * new HTTP request to be issued for every call into the URLConnection.
+   */
+  @Test public void unauthorizedResponseHandling() throws IOException {
+    MockResponse mockResponse = new MockResponse()
+        .addHeader("WWW-Authenticate: challenge")
+        .setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
+        .setBody("Unauthorized");
+    server.enqueue(mockResponse);
+    server.enqueue(mockResponse);
+    server.enqueue(mockResponse);
+
+    Response response = getResponse(newRequest("/"));
+
+    assertThat(response.code()).isEqualTo(401);
+    assertThat(response.code()).isEqualTo(401);
+    assertThat(response.code()).isEqualTo(401);
+    assertThat(server.getRequestCount()).isEqualTo(1);
+    response.body().close();
+  }
+
+  @Test public void nonHexChunkSize() {
+    server.enqueue(new MockResponse()
+        .setBody("5\r\nABCDE\r\nG\r\nFGHIJKLMNOPQRSTU\r\n0\r\n\r\n")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked"));
+
+    try (Response response = getResponse(newRequest("/"))) {
+      response.body().string();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void malformedChunkSize() {
+    server.enqueue(new MockResponse()
+        .setBody("5:x\r\nABCDE\r\n0\r\n\r\n")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked"));
+
+    try (Response response = getResponse(newRequest("/"))) {
+      readAscii(response.body().byteStream(), Integer.MAX_VALUE);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void extensionAfterChunkSize() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("5;x\r\nABCDE\r\n0\r\n\r\n")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked"));
+
+    try (Response response = getResponse(newRequest("/"))) {
+      assertContent("ABCDE", response);
+    }
+  }
+
+  @Test public void missingChunkBody() {
+    server.enqueue(new MockResponse()
+        .setBody("5")
+        .clearHeaders()
+        .addHeader("Transfer-encoding: chunked")
+        .setSocketPolicy(DISCONNECT_AT_END));
+
+    try (Response response = getResponse(newRequest("/"))) {
+      readAscii(response.body().byteStream(), Integer.MAX_VALUE);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  /**
+   * This test checks whether connections are gzipped by default. This behavior in not required by
+   * the API, so a failure of this test does not imply a bug in the implementation.
+   */
+  @Test public void gzipEncodingEnabledByDefault() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip"));
+
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "ABCABCABC");
+    assertThat(response.header("Content-Encoding")).isNull();
+    assertThat(response.body().contentLength()).isEqualTo(-1L);
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Accept-Encoding")).isEqualTo("gzip");
+  }
+
+  @Test public void clientConfiguredGzipContentEncoding() throws Exception {
+    Buffer bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
+    server.enqueue(new MockResponse()
+        .setBody(bodyBytes)
+        .addHeader("Content-Encoding: gzip"));
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .header("Accept-Encoding", "gzip")
+        .build());
+    InputStream gunzippedIn = new GZIPInputStream(response.body().byteStream());
+    assertThat(readAscii(gunzippedIn, Integer.MAX_VALUE)).isEqualTo(
+        "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
+    assertThat(response.body().contentLength()).isEqualTo(bodyBytes.size());
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Accept-Encoding")).isEqualTo("gzip");
+  }
+
+  @Test public void gzipAndConnectionReuseWithFixedLength() throws Exception {
+    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, false);
+  }
+
+  @Test public void gzipAndConnectionReuseWithChunkedEncoding() throws Exception {
+    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, false);
+  }
+
+  @Test public void gzipAndConnectionReuseWithFixedLengthAndTls() throws Exception {
+    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, true);
+  }
+
+  @Test public void gzipAndConnectionReuseWithChunkedEncodingAndTls() throws Exception {
+    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, true);
+  }
+
+  @Test public void clientConfiguredCustomContentEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABCDE")
+        .addHeader("Content-Encoding: custom"));
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .header("Accept-Encoding", "custom")
+        .build());
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "ABCDE");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Accept-Encoding")).isEqualTo("custom");
+  }
+
+  /**
+   * Test a bug where gzip input streams weren't exhausting the input stream, which corrupted the
+   * request that followed or prevented connection reuse. http://code.google.com/p/android/issues/detail?id=7059
+   * http://code.google.com/p/android/issues/detail?id=38817
+   */
+  private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind transferKind,
+      boolean tls) throws Exception {
+    if (tls) {
+      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
+      RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+      server.useHttps(socketFactory, false);
+      client = client.newBuilder()
+          .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
+          .hostnameVerifier(hostnameVerifier)
+          .build();
+    }
+
+    MockResponse responseOne = new MockResponse()
+        .addHeader("Content-Encoding: gzip");
+    transferKind.setBody(responseOne, gzip("one (gzipped)"), 5);
+    server.enqueue(responseOne);
+    MockResponse responseTwo = new MockResponse();
+    transferKind.setBody(responseTwo, "two (identity)", 5);
+    server.enqueue(responseTwo);
+
+    Response response1 = getResponse(new Request.Builder()
+        .header("Accept-Encoding", "gzip")
+        .url(server.url("/"))
+        .build());
+    InputStream gunzippedIn = new GZIPInputStream(response1.body().byteStream());
+    assertThat(readAscii(gunzippedIn, Integer.MAX_VALUE)).isEqualTo(
+        "one (gzipped)");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+
+    Response response2 = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    assertThat(readAscii(response2.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "two (identity)");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+  }
+
+  @Test public void transparentGzipWorksAfterExceptionRecovery() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("a")
+        .setSocketPolicy(SHUTDOWN_INPUT_AT_END));
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("b")));
+
+    // Seed the pool with a bad connection.
+    assertContent("a", getResponse(newRequest("/")));
+
+    // Give the server time to disconnect.
+    Thread.sleep(500);
+
+    // This connection will need to be recovered. When it is, transparent gzip should still work!
+    assertContent("b", getResponse(newRequest("/")));
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Connection is not pooled.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+  }
+
+  @Test public void endOfStreamResponseIsNotPooled() throws Exception {
+    client.connectionPool().evictAll();
+    server.enqueue(new MockResponse()
+        .setBody("{}")
+        .clearHeaders()
+        .setSocketPolicy(DISCONNECT_AT_END));
+
+    Response response = getResponse(newRequest("/"));
+    assertContent("{}", response);
+    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(0);
+  }
+
+  @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
+    testEarlyDisconnectDoesntHarmPooling(TransferKind.CHUNKED);
+  }
+
+  @Test public void earlyDisconnectDoesntHarmPoolingWithFixedLengthEncoding() throws Exception {
+    testEarlyDisconnectDoesntHarmPooling(TransferKind.FIXED_LENGTH);
+  }
+
+  private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) throws Exception {
+    MockResponse mockResponse1 = new MockResponse();
+    transferKind.setBody(mockResponse1, "ABCDEFGHIJK", 1024);
+    server.enqueue(mockResponse1);
+
+    MockResponse mockResponse2 = new MockResponse();
+    transferKind.setBody(mockResponse2, "LMNOPQRSTUV", 1024);
+    server.enqueue(mockResponse2);
+
+    Call call1 = client.newCall(newRequest("/"));
+    Response response1 = call1.execute();
+    InputStream in1 = response1.body().byteStream();
+    assertThat(readAscii(in1, 5)).isEqualTo("ABCDE");
+    in1.close();
+    call1.cancel();
+
+    Call call2 = client.newCall(newRequest("/"));
+    Response response2 = call2.execute();
+    InputStream in2 = response2.body().byteStream();
+    assertThat(readAscii(in2, 5)).isEqualTo("LMNOP");
+    in2.close();
+    call2.cancel();
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Connection is pooled!
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+  }
+
+  @Test public void streamDiscardingIsTimely() throws Exception {
+    // This response takes at least a full second to serve: 10,000 bytes served 100 bytes at a time.
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[10000]))
+        .throttleBody(100, 10, MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    long startNanos = System.nanoTime();
+    Response connection1 = getResponse(newRequest("/"));
+    InputStream in = connection1.body().byteStream();
+    in.close();
+    long elapsedNanos = System.nanoTime() - startNanos;
+    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
+
+    // If we're working correctly, this should be greater than 100ms, but less than double that.
+    // Previously we had a bug where we would download the entire response body as long as no
+    // individual read took longer than 100ms.
+    assertThat(elapsedMillis).isLessThan(500L);
+
+    // Do another request to confirm that the discarded connection was not pooled.
+    assertContent("A", getResponse(newRequest("/")));
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Connection is not pooled.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+  }
+
+  @Test public void setChunkedStreamingMode() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(TransferKind.CHUNKED.newRequestBody("ABCDEFGHIJKLMNOPQ"))
+        .build());
+    assertThat(response.code()).isEqualTo(200);
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("ABCDEFGHIJKLMNOPQ");
+    assertThat(request.getChunkSizes()).isEqualTo(
+        asList("ABCDEFGHIJKLMNOPQ".length()));
+  }
+
+  @Test public void authenticateWithFixedLengthStreaming() throws Exception {
+    testAuthenticateWithStreamingPost(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void authenticateWithChunkedStreaming() throws Exception {
+    testAuthenticateWithStreamingPost(TransferKind.CHUNKED);
+  }
+
+  private void testAuthenticateWithStreamingPost(TransferKind streamingMode) throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate."));
+    server.enqueue(new MockResponse()
+        .setBody("Authenticated!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    client = client.newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build();
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(streamingMode.newRequestBody("ABCD"))
+        .build();
+    Response response = getResponse(request);
+    assertThat(response.code()).isEqualTo(200);
+    assertContent("Authenticated!", response);
+
+    // No authorization header for the request...
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertThat(recordedRequest.getHeader("Authorization")).isNull();
+    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("ABCD");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("abc");
+  }
+
+  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    postBodyRetransmittedAfterAuthorizationFail("");
+  }
+
+  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse());
+
+    String credential = Credentials.basic("jesse", "secret");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential, null))
+        .build();
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(null, body))
+        .build());
+    assertThat(response.code()).isEqualTo(200);
+    response.body().byteStream().close();
+
+    RecordedRequest recordedRequest1 = server.takeRequest();
+    assertThat(recordedRequest1.getMethod()).isEqualTo("POST");
+    assertThat(recordedRequest1.getBody().readUtf8()).isEqualTo(body);
+    assertThat(recordedRequest1.getHeader("Authorization")).isNull();
+
+    RecordedRequest recordedRequest2 = server.takeRequest();
+    assertThat(recordedRequest2.getMethod()).isEqualTo("POST");
+    assertThat(recordedRequest2.getBody().readUtf8()).isEqualTo(body);
+    assertThat(recordedRequest2.getHeader("Authorization")).isEqualTo(
+        credential);
+  }
+
+  @Test public void nonStandardAuthenticationScheme() throws Exception {
+    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo");
+    assertThat(calls).isEqualTo(Collections.<String>emptyList());
+  }
+
+  @Test public void nonStandardAuthenticationSchemeWithRealm() throws Exception {
+    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo realm=\"Bar\"");
+    assertThat(calls.size()).isEqualTo(0);
+  }
+
+  // Digest auth is currently unsupported. Test that digest requests should fail reasonably.
+  // http://code.google.com/p/android/issues/detail?id=11140
+  @Test public void digestAuthentication() throws Exception {
+    List<String> calls = authCallsForHeader("WWW-Authenticate: Digest "
+        + "realm=\"testrealm@host.com\", qop=\"auth,auth-int\", "
+        + "nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", "
+        + "opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"");
+    assertThat(calls.size()).isEqualTo(0);
+  }
+
+  @Test public void allAttributesSetInServerAuthenticationCallbacks() throws Exception {
+    List<String> calls = authCallsForHeader("WWW-Authenticate: Basic realm=\"Bar\"");
+    assertThat(calls.size()).isEqualTo(1);
+    URL url = server.url("/").url();
+    String call = calls.get(0);
+    assertThat(call).contains("host=" + url.getHost());
+    assertThat(call).contains("port=" + url.getPort());
+    assertThat(call).contains("site=" + url.getHost());
+    assertThat(call).contains("url=" + url);
+    assertThat(call).contains("type=" + Authenticator.RequestorType.SERVER);
+    assertThat(call).contains("prompt=Bar");
+    assertThat(call).contains("protocol=http");
+    assertThat(call.toLowerCase(US)).contains("scheme=basic"); // lowercase for the RI.
+  }
+
+  @Test public void allAttributesSetInProxyAuthenticationCallbacks() throws Exception {
+    List<String> calls = authCallsForHeader("Proxy-Authenticate: Basic realm=\"Bar\"");
+    assertThat(calls.size()).isEqualTo(1);
+    URL url = server.url("/").url();
+    String call = calls.get(0);
+    assertThat(call).contains("host=" + url.getHost());
+    assertThat(call).contains("port=" + url.getPort());
+    assertThat(call).contains("site=" + url.getHost());
+    assertThat(call).contains("url=http://android.com");
+    assertThat(call).contains("type=" + Authenticator.RequestorType.PROXY);
+    assertThat(call).contains("prompt=Bar");
+    assertThat(call).contains("protocol=http");
+    assertThat(call.toLowerCase(US)).contains("scheme=basic");
+  }
+
+  private List<String> authCallsForHeader(String authHeader) throws IOException {
+    boolean proxy = authHeader.startsWith("Proxy-");
+    int responseCode = proxy ? 407 : 401;
+    RecordingAuthenticator authenticator = new RecordingAuthenticator(null);
+    Authenticator.setDefault(authenticator);
+    server.enqueue(new MockResponse()
+        .setResponseCode(responseCode)
+        .addHeader(authHeader)
+        .setBody("Please authenticate."));
+
+    Response response;
+    if (proxy) {
+      client = client.newBuilder()
+          .proxy(server.toProxyAddress())
+          .proxyAuthenticator(new JavaNetAuthenticator())
+          .build();
+      response = getResponse(newRequest(HttpUrl.get("http://android.com/")));
+    } else {
+      client = client.newBuilder()
+          .authenticator(new JavaNetAuthenticator())
+          .build();
+      response = getResponse(newRequest("/"));
+    }
+    assertThat(response.code()).isEqualTo(responseCode);
+    response.body().byteStream().close();
+    return authenticator.calls;
+  }
+
+  @Test public void setValidRequestMethod() {
+    assertMethodForbidsRequestBody("GET");
+    assertMethodPermitsRequestBody("DELETE");
+    assertMethodForbidsRequestBody("HEAD");
+    assertMethodPermitsRequestBody("OPTIONS");
+    assertMethodPermitsRequestBody("POST");
+    assertMethodPermitsRequestBody("PUT");
+    assertMethodPermitsRequestBody("TRACE");
+    assertMethodPermitsRequestBody("PATCH");
+
+    assertMethodPermitsNoRequestBody("GET");
+    assertMethodPermitsNoRequestBody("DELETE");
+    assertMethodPermitsNoRequestBody("HEAD");
+    assertMethodPermitsNoRequestBody("OPTIONS");
+    assertMethodForbidsNoRequestBody("POST");
+    assertMethodForbidsNoRequestBody("PUT");
+    assertMethodPermitsNoRequestBody("TRACE");
+    assertMethodForbidsNoRequestBody("PATCH");
+  }
+
+  private void assertMethodPermitsRequestBody(String requestMethod) {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method(requestMethod, RequestBody.create(null, "abc"))
+        .build();
+    assertThat(request.method()).isEqualTo(requestMethod);
+  }
+
+  private void assertMethodForbidsRequestBody(String requestMethod) {
+    try {
+      new Request.Builder()
+          .url(server.url("/"))
+          .method(requestMethod, RequestBody.create(null, "abc"))
+          .build();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  private void assertMethodPermitsNoRequestBody(String requestMethod) {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method(requestMethod, null)
+        .build();
+    assertThat(request.method()).isEqualTo(requestMethod);
+  }
+
+  private void assertMethodForbidsNoRequestBody(String requestMethod) {
+    try {
+      new Request.Builder()
+          .url(server.url("/"))
+          .method(requestMethod, null)
+          .build();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setInvalidRequestMethodLowercase() throws Exception {
+    assertValidRequestMethod("get");
+  }
+
+  @Test public void setInvalidRequestMethodConnect() throws Exception {
+    assertValidRequestMethod("CONNECT");
+  }
+
+  private void assertValidRequestMethod(String requestMethod) throws Exception {
+    server.enqueue(new MockResponse());
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .method(requestMethod, null)
+        .build());
+    assertThat(response.code()).isEqualTo(200);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertThat(recordedRequest.getMethod()).isEqualTo(requestMethod);
+  }
+
+  @Test public void shoutcast() throws Exception {
+    server.enqueue(new MockResponse()
+        .setStatus("ICY 200 OK")
+        .addHeader("Accept-Ranges: none")
+        .addHeader("Content-Type: audio/mpeg")
+        .addHeader("icy-br:128")
+        .addHeader("ice-audio-info: bitrate=128;samplerate=44100;channels=2")
+        .addHeader("icy-br:128")
+        .addHeader("icy-description:Rock")
+        .addHeader("icy-genre:riders")
+        .addHeader("icy-name:A2RRock")
+        .addHeader("icy-pub:1")
+        .addHeader("icy-url:http://www.A2Rradio.com")
+        .addHeader("Server: Icecast 2.3.3-kh8")
+        .addHeader("Cache-Control: no-cache")
+        .addHeader("Pragma: no-cache")
+        .addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT")
+        .addHeader("icy-metaint:16000")
+        .setBody("mp3 data"));
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("OK");
+    assertContent("mp3 data", response);
+  }
+
+  @Test public void secureFixedLengthStreaming() throws Exception {
+    testSecureStreamingPost(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void secureChunkedStreaming() throws Exception {
+    testSecureStreamingPost(TransferKind.CHUNKED);
+  }
+
+  /**
+   * Users have reported problems using HTTPS with streaming request bodies.
+   * http://code.google.com/p/android/issues/detail?id=12860
+   */
+  private void testSecureStreamingPost(TransferKind streamingMode) throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("Success!"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(streamingMode.newRequestBody("ABCD"))
+        .build());
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Success!");
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getRequestLine()).isEqualTo("POST / HTTP/1.1");
+    if (streamingMode == TransferKind.FIXED_LENGTH) {
+      assertThat(request.getChunkSizes()).isEqualTo(
+          Collections.<Integer>emptyList());
+    } else if (streamingMode == TransferKind.CHUNKED) {
+      assertThat(request.getChunkSizes()).containsExactly(4);
+    }
+    assertThat(request.getBody().readUtf8()).isEqualTo("ABCD");
+  }
+
+  @Test public void authenticateWithPost() throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate.");
+    // Fail auth three times...
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    // ...then succeed the fourth time.
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    client = client.newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build();
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(null, "ABCD"))
+        .build());
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Successful auth!");
+
+    // No authorization header for the first request...
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Authorization")).isNull();
+
+    // ...but the three requests that follow include an authorization header.
+    for (int i = 0; i < 3; i++) {
+      request = server.takeRequest();
+      assertThat(request.getRequestLine()).isEqualTo("POST / HTTP/1.1");
+      assertThat(request.getHeader("Authorization")).isEqualTo(
+          ("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS));
+      assertThat(request.getBody().readUtf8()).isEqualTo("ABCD");
+    }
+  }
+
+  @Test public void authenticateWithGet() throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate.");
+    // Fail auth three times...
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    // ...then succeed the fourth time.
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    client = client.newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Successful auth!");
+
+    // No authorization header for the first request...
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Authorization")).isNull();
+
+    // ...but the three requests that follow requests include an authorization header.
+    for (int i = 0; i < 3; i++) {
+      request = server.takeRequest();
+      assertThat(request.getRequestLine()).isEqualTo("GET / HTTP/1.1");
+      assertThat(request.getHeader("Authorization")).isEqualTo(
+          ("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS));
+    }
+  }
+
+  @Test public void authenticateWithCharset() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
+        .setBody("Please authenticate with UTF-8."));
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate with ISO-8859-1."));
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator(
+        new PasswordAuthentication("username", "m√∂torhead".toCharArray())));
+    client = client.newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Successful auth!");
+
+    // No authorization header for the first request...
+    RecordedRequest request1 = server.takeRequest();
+    assertThat(request1.getHeader("Authorization")).isNull();
+
+    // UTF-8 encoding for the first credential.
+    RecordedRequest request2 = server.takeRequest();
+    assertThat(request2.getHeader("Authorization")).isEqualTo(
+        "Basic dXNlcm5hbWU6bcO2dG9yaGVhZA==");
+
+    // ISO-8859-1 encoding for the second credential.
+    RecordedRequest request3 = server.takeRequest();
+    assertThat(request3.getHeader("Authorization")).isEqualTo(
+        "Basic dXNlcm5hbWU6bfZ0b3JoZWFk");
+  }
+
+  /** https://code.google.com/p/android/issues/detail?id=74026 */
+  @Test public void authenticateWithGetAndTransparentGzip() throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate.");
+    // Fail auth three times...
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    // ...then succeed the fourth time.
+    MockResponse successfulResponse = new MockResponse()
+        .addHeader("Content-Encoding", "gzip")
+        .setBody(gzip("Successful auth!"));
+    server.enqueue(successfulResponse);
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    client = client.newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Successful auth!");
+
+    // no authorization header for the first request...
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Authorization")).isNull();
+
+    // ...but the three requests that follow requests include an authorization header
+    for (int i = 0; i < 3; i++) {
+      request = server.takeRequest();
+      assertThat(request.getRequestLine()).isEqualTo("GET / HTTP/1.1");
+      assertThat(request.getHeader("Authorization")).isEqualTo(
+          ("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS));
+    }
+  }
+
+  /** https://github.com/square/okhttp/issues/342 */
+  @Test public void authenticateRealmUppercase() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("wWw-aUtHeNtIcAtE: bAsIc rEaLm=\"pRoTeCtEd aReA\"")
+        .setBody("Please authenticate."));
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    client = client.newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Successful auth!");
+  }
+
+  @Test public void redirectedWithChunkedEncoding() throws Exception {
+    testRedirected(TransferKind.CHUNKED, true);
+  }
+
+  @Test public void redirectedWithContentLengthHeader() throws Exception {
+    testRedirected(TransferKind.FIXED_LENGTH, true);
+  }
+
+  @Test public void redirectedWithNoLengthHeaders() throws Exception {
+    testRedirected(TransferKind.END_OF_STREAM, false);
+  }
+
+  private void testRedirected(TransferKind transferKind, boolean reuse) throws Exception {
+    MockResponse mockResponse = new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo");
+    transferKind.setBody(mockResponse, "This page has moved!", 10);
+    server.enqueue(mockResponse);
+    server.enqueue(new MockResponse()
+        .setBody("This is the new location!"));
+
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "This is the new location!");
+
+    RecordedRequest first = server.takeRequest();
+    assertThat(first.getRequestLine()).isEqualTo("GET / HTTP/1.1");
+    RecordedRequest retry = server.takeRequest();
+    assertThat(retry.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    if (reuse) {
+      assertThat(retry.getSequenceNumber()).overridingErrorMessage(
+          "Expected connection reuse").isEqualTo(1);
+    }
+  }
+
+  @Test public void redirectedOnHttps() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse()
+        .setBody("This is the new location!"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "This is the new location!");
+
+    RecordedRequest first = server.takeRequest();
+    assertThat(first.getRequestLine()).isEqualTo("GET / HTTP/1.1");
+    RecordedRequest retry = server.takeRequest();
+    assertThat(retry.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(retry.getSequenceNumber()).overridingErrorMessage(
+        "Expected connection reuse").isEqualTo(1);
+  }
+
+  @Test public void notRedirectedFromHttpsToHttp() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: http://anyhost/foo")
+        .setBody("This page has moved!"));
+
+    client = client.newBuilder()
+        .followSslRedirects(false)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "This page has moved!");
+  }
+
+  @Test public void notRedirectedFromHttpToHttps() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: https://anyhost/foo")
+        .setBody("This page has moved!"));
+
+    client = client.newBuilder()
+        .followSslRedirects(false)
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "This page has moved!");
+  }
+
+  @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
+    server2.enqueue(new MockResponse()
+        .setBody("This is insecure HTTP!"));
+
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.url("/").url())
+        .setBody("This page has moved!"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .followSslRedirects(true)
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertContent("This is insecure HTTP!", response);
+    assertThat(response.handshake()).isNull();
+  }
+
+  @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
+    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server2.enqueue(new MockResponse()
+        .setBody("This is secure HTTPS!"));
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.url("/").url())
+        .setBody("This page has moved!"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .followSslRedirects(true)
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertContent("This is secure HTTPS!", response);
+  }
+
+  @Test public void redirectToAnotherOriginServer() throws Exception {
+    redirectToAnotherOriginServer(false);
+  }
+
+  @Test public void redirectToAnotherOriginServerWithHttps() throws Exception {
+    redirectToAnotherOriginServer(true);
+  }
+
+  private void redirectToAnotherOriginServer(boolean https) throws Exception {
+    if (https) {
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+      server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
+      server2.setProtocolNegotiationEnabled(false);
+      client = client.newBuilder()
+          .sslSocketFactory(
+              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+          .hostnameVerifier(new RecordingHostnameVerifier())
+          .build();
+    }
+
+    server2.enqueue(new MockResponse()
+        .setBody("This is the 2nd server!"));
+    server2.enqueue(new MockResponse()
+        .setBody("This is the 2nd server, again!"));
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.url("/").url().toString())
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse()
+        .setBody("This is the first server again!"));
+
+    Response response = getResponse(newRequest("/"));
+    assertContent("This is the 2nd server!", response);
+    assertThat(response.request().url()).isEqualTo(server2.url("/"));
+
+    // make sure the first server was careful to recycle the connection
+    assertContent("This is the first server again!", getResponse(newRequest(server.url("/"))));
+    assertContent("This is the 2nd server, again!", getResponse(newRequest(server2.url("/"))));
+
+    String server1Host = server.getHostName() + ":" + server.getPort();
+    String server2Host = server2.getHostName() + ":" + server2.getPort();
+    assertThat(server.takeRequest().getHeader("Host")).isEqualTo(server1Host);
+    assertThat(server2.takeRequest().getHeader("Host")).isEqualTo(server2Host);
+    assertThat(server.takeRequest().getSequenceNumber()).overridingErrorMessage(
+        "Expected connection reuse").isEqualTo(1);
+    assertThat(server2.takeRequest().getSequenceNumber()).overridingErrorMessage(
+        "Expected connection reuse").isEqualTo(1);
+  }
+
+  @Test public void redirectWithProxySelector() throws Exception {
+    final List<URI> proxySelectionRequests = new ArrayList<>();
+    client = client.newBuilder()
+        .proxySelector(new ProxySelector() {
+          @Override public List<Proxy> select(URI uri) {
+            proxySelectionRequests.add(uri);
+            MockWebServer proxyServer = (uri.getPort() == server.getPort())
+                ? server
+                : server2;
+            return asList(proxyServer.toProxyAddress());
+          }
+
+          @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
+            throw new AssertionError();
+          }
+        })
+        .build();
+
+    server2.enqueue(new MockResponse()
+        .setBody("This is the 2nd server!"));
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + server2.url("/b").toString())
+        .setBody("This page has moved!"));
+
+    assertContent("This is the 2nd server!", getResponse(newRequest("/a")));
+
+    assertThat(proxySelectionRequests).isEqualTo(
+        asList(server.url("/").url().toURI(), server2.url("/").url().toURI()));
+  }
+
+  @Test public void redirectWithAuthentication() throws Exception {
+    server2.enqueue(new MockResponse()
+        .setBody("Page 2"));
+
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: " + server2.url("/b")));
+
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret"), null))
+        .build();
+    assertContent("Page 2", getResponse(newRequest("/a")));
+
+    RecordedRequest redirectRequest = server2.takeRequest();
+    assertThat(redirectRequest.getHeader("Authorization")).isNull();
+    assertThat(redirectRequest.getPath()).isEqualTo("/b");
+  }
+
+  @Test public void response300MultipleChoiceWithPost() throws Exception {
+    // Chrome doesn't follow the redirect, but Firefox and the RI both do
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MULT_CHOICE, TransferKind.END_OF_STREAM);
+  }
+
+  @Test public void response301MovedPermanentlyWithPost() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_PERM, TransferKind.END_OF_STREAM);
+  }
+
+  @Test public void response302MovedTemporarilyWithPost() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.END_OF_STREAM);
+  }
+
+  @Test public void response303SeeOtherWithPost() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_SEE_OTHER, TransferKind.END_OF_STREAM);
+  }
+
+  @Test public void postRedirectToGetWithChunkedRequest() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.CHUNKED);
+  }
+
+  @Test public void postRedirectToGetWithStreamedRequest() throws Exception {
+    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.FIXED_LENGTH);
+  }
+
+  private void testResponseRedirectedWithPost(int redirectCode, TransferKind transferKind)
+      throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(redirectCode)
+        .addHeader("Location: /page2")
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse()
+        .setBody("Page 2"));
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/page1"))
+        .post(transferKind.newRequestBody("ABCD"))
+        .build());
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Page 2");
+
+    RecordedRequest page1 = server.takeRequest();
+    assertThat(page1.getRequestLine()).isEqualTo("POST /page1 HTTP/1.1");
+    assertThat(page1.getBody().readUtf8()).isEqualTo("ABCD");
+
+    RecordedRequest page2 = server.takeRequest();
+    assertThat(page2.getRequestLine()).isEqualTo("GET /page2 HTTP/1.1");
+  }
+
+  @Test public void redirectedPostStripsRequestBodyHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /page2"));
+    server.enqueue(new MockResponse()
+        .setBody("Page 2"));
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/page1"))
+        .post(RequestBody.create(MediaType.get("text/plain; charset=utf-8"), "ABCD"))
+        .header("Transfer-Encoding", "identity")
+        .build());
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Page 2");
+
+    assertThat(server.takeRequest().getRequestLine()).isEqualTo(
+        "POST /page1 HTTP/1.1");
+
+    RecordedRequest page2 = server.takeRequest();
+    assertThat(page2.getRequestLine()).isEqualTo("GET /page2 HTTP/1.1");
+    assertThat(page2.getHeader("Content-Length")).isNull();
+    assertThat(page2.getHeader("Content-Type")).isNull();
+    assertThat(page2.getHeader("Transfer-Encoding")).isNull();
+  }
+
+  @Test public void response305UseProxy() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_USE_PROXY)
+        .addHeader("Location: " + server.url("/").url())
+        .setBody("This page has moved!"));
+    server.enqueue(new MockResponse()
+        .setBody("Proxy Response"));
+
+    Response response = getResponse(newRequest("/foo"));
+    // Fails on the RI, which gets "Proxy Response".
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "This page has moved!");
+
+    RecordedRequest page1 = server.takeRequest();
+    assertThat(page1.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(server.getRequestCount()).isEqualTo(1);
+  }
+
+  @Test public void response307WithGet() throws Exception {
+    testRedirect(true, "GET");
+  }
+
+  @Test public void response307WithHead() throws Exception {
+    testRedirect(true, "HEAD");
+  }
+
+  @Test public void response307WithOptions() throws Exception {
+    testRedirect(true, "OPTIONS");
+  }
+
+  @Test public void response307WithPost() throws Exception {
+    testRedirect(true, "POST");
+  }
+
+  @Test public void response308WithGet() throws Exception {
+    testRedirect(false, "GET");
+  }
+
+  @Test public void response308WithHead() throws Exception {
+    testRedirect(false, "HEAD");
+  }
+
+  @Test public void response308WithOptions() throws Exception {
+    testRedirect(false, "OPTIONS");
+  }
+
+  @Test public void response308WithPost() throws Exception {
+    testRedirect(false, "POST");
+  }
+
+  private void testRedirect(boolean temporary, String method) throws Exception {
+    MockResponse response1 = new MockResponse()
+        .setResponseCode(temporary ? HTTP_TEMP_REDIRECT : HTTP_PERM_REDIRECT)
+        .addHeader("Location: /page2");
+    if (!method.equals("HEAD")) {
+      response1.setBody("This page has moved!");
+    }
+    server.enqueue(response1);
+    server.enqueue(new MockResponse()
+        .setBody("Page 2"));
+
+    Request.Builder requestBuilder = new Request.Builder()
+        .url(server.url("/page1"));
+    if (method.equals("POST")) {
+      requestBuilder.post(RequestBody.create(null, "ABCD"));
+    } else {
+      requestBuilder.method(method, null);
+    }
+
+    Response response = getResponse(requestBuilder.build());
+    String responseString = readAscii(response.body().byteStream(), Integer.MAX_VALUE);
+
+    RecordedRequest page1 = server.takeRequest();
+    assertThat(page1.getRequestLine()).isEqualTo((method + " /page1 HTTP/1.1"));
+
+    if (method.equals("GET")) {
+      assertThat(responseString).isEqualTo("Page 2");
+    } else if (method.equals("HEAD")) {
+      assertThat(responseString).isEqualTo("");
+    } else {
+      // Methods other than GET/HEAD shouldn't follow the redirect.
+      if (method.equals("POST")) {
+        assertThat(page1.getBody().readUtf8()).isEqualTo("ABCD");
+      }
+      assertThat(server.getRequestCount()).isEqualTo(1);
+      assertThat(responseString).isEqualTo("This page has moved!");
+      return;
+    }
+
+    // GET/HEAD requests should have followed the redirect with the same method.
+    assertThat(server.getRequestCount()).isEqualTo(2);
+    RecordedRequest page2 = server.takeRequest();
+    assertThat(page2.getRequestLine()).isEqualTo((method + " /page2 HTTP/1.1"));
+  }
+
+  @Test public void follow20Redirects() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.enqueue(new MockResponse()
+        .setBody("Success!"));
+
+    Response response = getResponse(newRequest("/0"));
+    assertContent("Success!", response);
+    assertThat(response.request().url()).isEqualTo(server.url("/20"));
+  }
+
+  @Test public void doesNotFollow21Redirects() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+
+    try {
+      getResponse(newRequest("/0"));
+      fail();
+    } catch (ProtocolException expected) {
+      assertThat(expected.getMessage()).isEqualTo(
+          "Too many follow-up requests: 21");
+    }
+  }
+
+  @Test public void httpsWithCustomTrustManager() throws Exception {
+    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
+    RecordingTrustManager trustManager =
+        new RecordingTrustManager(handshakeCertificates.trustManager());
+    SSLContext sslContext = Platform.get().getSSLContext();
+    sslContext.init(null, new TrustManager[] {trustManager}, null);
+
+    client = client.newBuilder()
+        .hostnameVerifier(hostnameVerifier)
+        .sslSocketFactory(sslContext.getSocketFactory(), trustManager)
+        .build();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setBody("GHI"));
+
+    assertContent("ABC", getResponse(newRequest("/")));
+    assertContent("DEF", getResponse(newRequest("/")));
+    assertContent("GHI", getResponse(newRequest("/")));
+
+    assertThat(hostnameVerifier.calls).isEqualTo(
+        asList("verify " + server.getHostName()));
+    assertThat(trustManager.calls).isEqualTo(
+        asList("checkServerTrusted [CN=localhost 1]"));
+  }
+
+  @Test public void getClientRequestTimeout() throws Exception {
+    enqueueClientRequestTimeoutResponses();
+
+    Response response = getResponse(newRequest("/"));
+
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Body");
+  }
+
+  private void enqueueClientRequestTimeoutResponses() {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(HttpURLConnection.HTTP_CLIENT_TIMEOUT)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse()
+        .setBody("Body"));
+  }
+
+  @Test public void bufferedBodyWithClientRequestTimeout() throws Exception {
+    enqueueClientRequestTimeoutResponses();
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(null, "Hello"))
+        .build());
+
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "Body");
+
+    RecordedRequest request1 = server.takeRequest();
+    assertThat(request1.getBody().readUtf8()).isEqualTo("Hello");
+
+    RecordedRequest request2 = server.takeRequest();
+    assertThat(request2.getBody().readUtf8()).isEqualTo("Hello");
+  }
+
+  @Test public void streamedBodyWithClientRequestTimeout() throws Exception {
+    enqueueClientRequestTimeoutResponses();
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(TransferKind.CHUNKED.newRequestBody("Hello"))
+        .build());
+
+    assertThat(response.code()).isEqualTo(200);
+    assertContent("Body", response);
+    response.close();
+    assertThat(server.getRequestCount()).isEqualTo(2);
+  }
+
+  @Test public void readTimeouts() throws IOException {
+    // This relies on the fact that MockWebServer doesn't close the
+    // connection after a response has been sent. This causes the client to
+    // try to read more bytes than are sent, which results in a timeout.
+    server.enqueue(new MockResponse()
+        .setBody("ABC")
+        .clearHeaders()
+        .addHeader("Content-Length: 4"));
+    server.enqueue(new MockResponse()
+        .setBody("unused")); // to keep the server alive
+
+    Response response = getResponse(newRequest("/"));
+    BufferedSource in = response.body().source();
+    in.timeout().timeout(1000, MILLISECONDS);
+    assertThat(in.readByte()).isEqualTo((byte) 'A');
+    assertThat(in.readByte()).isEqualTo((byte) 'B');
+    assertThat(in.readByte()).isEqualTo((byte) 'C');
+    try {
+      in.readByte(); // If Content-Length was accurate, this would return -1 immediately.
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+    in.close();
+  }
+
+  /** Confirm that an unacknowledged write times out. */
+  @Test public void writeTimeouts() throws IOException {
+    MockWebServer server = new MockWebServer();
+    // Sockets on some platforms can have large buffers that mean writes do not block when
+    // required. These socket factories explicitly set the buffer sizes on sockets created.
+    final int SOCKET_BUFFER_SIZE = 4 * 1024;
+    server.setServerSocketFactory(
+        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
+          @Override
+          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
+              throws IOException {
+            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            return serverSocket;
+          }
+        });
+    client = client.newBuilder()
+        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
+          @Override protected Socket configureSocket(Socket socket) throws IOException {
+            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
+            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
+            return socket;
+          }
+        })
+        .writeTimeout(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    server.start();
+    server.enqueue(new MockResponse()
+        .throttleBody(1, 1, TimeUnit.SECONDS)); // Prevent the server from reading!
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(new RequestBody() {
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
+            sink.write(data);
+          }
+        })
+        .build();
+    try {
+      getResponse(request);
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+  }
+
+  @Test public void setChunkedEncodingAsRequestProperty() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .header("Transfer-encoding", "chunked")
+        .post(TransferKind.CHUNKED.newRequestBody("ABC"))
+        .build());
+    assertThat(response.code()).isEqualTo(200);
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getBody().readUtf8()).isEqualTo("ABC");
+  }
+
+  @Test public void connectionCloseInRequest() throws Exception {
+    server.enqueue(new MockResponse()); // Server doesn't honor the connection: close header!
+    server.enqueue(new MockResponse());
+
+    Response a = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .header("Connection", "close")
+        .build());
+    assertThat(a.code()).isEqualTo(200);
+
+    Response b = getResponse(newRequest("/"));
+    assertThat(b.code()).isEqualTo(200);
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).overridingErrorMessage(
+        "When connection: close is used, each request should get its own connection").isEqualTo(
+        (long) 0);
+  }
+
+  @Test public void connectionCloseInResponse() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Connection: close"));
+    server.enqueue(new MockResponse());
+
+    Response a = getResponse(newRequest("/"));
+    assertThat(a.code()).isEqualTo(200);
+
+    Response b = getResponse(newRequest("/"));
+    assertThat(b.code()).isEqualTo(200);
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).overridingErrorMessage(
+        "When connection: close is used, each request should get its own connection").isEqualTo(
+        (long) 0);
+  }
+
+  @Test public void connectionCloseWithRedirect() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .addHeader("Connection: close"));
+    server.enqueue(new MockResponse()
+        .setBody("This is the new location!"));
+
+    Response response = getResponse(newRequest("/"));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "This is the new location!");
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).overridingErrorMessage(
+        "When connection: close is used, each request should get its own connection").isEqualTo(
+        (long) 0);
+  }
+
+  /**
+   * Retry redirects if the socket is closed.
+   * https://code.google.com/p/android/issues/detail?id=41576
+   */
+  @Test public void sameConnectionRedirectAndReuse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse()
+        .setBody("This is the new page!"));
+
+    assertContent("This is the new page!", getResponse(newRequest("/")));
+
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+  }
+
+  @Test public void responseCodeDisagreesWithHeaders() {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
+        .setBody("This body is not allowed!"));
+
+    try {
+      getResponse(newRequest("/"));
+      fail();
+    } catch (IOException expected) {
+      assertThat(expected.getMessage()).isEqualTo(
+          "HTTP 204 had non-zero Content-Length: 25");
+    }
+  }
+
+  @Test public void singleByteReadIsSigned() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer()
+            .writeByte(-2)
+            .writeByte(-1)));
+
+    Response response = getResponse(newRequest("/"));
+    InputStream in = response.body().byteStream();
+    assertThat(in.read()).isEqualTo(254);
+    assertThat(in.read()).isEqualTo(255);
+    assertThat(in.read()).isEqualTo(-1);
+  }
+
+  @Test public void flushAfterStreamTransmittedWithChunkedEncoding() throws IOException {
+    testFlushAfterStreamTransmitted(TransferKind.CHUNKED);
+  }
+
+  @Test public void flushAfterStreamTransmittedWithFixedLength() throws IOException {
+    testFlushAfterStreamTransmitted(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void flushAfterStreamTransmittedWithNoLengthHeaders() throws IOException {
+    testFlushAfterStreamTransmitted(TransferKind.END_OF_STREAM);
+  }
+
+  /**
+   * We explicitly permit apps to close the upload stream even after it has been transmitted.  We
+   * also permit flush so that buffered streams can do a no-op flush when they are closed.
+   * http://b/3038470
+   */
+  private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    AtomicReference<BufferedSink> sinkReference = new AtomicReference<>();
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(new ForwardingRequestBody(transferKind.newRequestBody("def")) {
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sinkReference.set(sink);
+            super.writeTo(sink);
+          }
+        })
+        .build());
+
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "abc");
+
+    try {
+      sinkReference.get().flush();
+    } catch (IllegalStateException expected) {
+    }
+    try {
+      sinkReference.get().write("ghi".getBytes(UTF_8));
+      sinkReference.get().emit();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void getHeadersThrows() {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(DISCONNECT_AT_START));
+
+    try {
+      getResponse(newRequest("/"));
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void dnsFailureThrowsIOException() {
+    client = client.newBuilder()
+        .dns(new FakeDns())
+        .build();
+    try {
+      getResponse(newRequest(HttpUrl.get("http://host.unlikelytld")));
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
+    try {
+      getResponse(newRequest(HttpUrl.get("http://./foo.html")));
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
+  @Test public void getKeepAlive() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    // The request should work once and then fail.
+    Response connection1 = getResponse(newRequest("/"));
+    BufferedSource source1 = connection1.body().source();
+    source1.timeout().timeout(100, TimeUnit.MILLISECONDS);
+    assertThat(readAscii(source1.inputStream(), Integer.MAX_VALUE)).isEqualTo(
+        "ABC");
+    server.shutdown();
+    try {
+      getResponse(newRequest("/"));
+      fail();
+    } catch (ConnectException expected) {
+    }
+  }
+
+  /** http://code.google.com/p/android/issues/detail?id=14562 */
+  @Test public void readAfterLastByte() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABC")
+        .clearHeaders()
+        .addHeader("Connection: close")
+        .setSocketPolicy(DISCONNECT_AT_END));
+
+    Response response = getResponse(newRequest("/"));
+    InputStream in = response.body().byteStream();
+    assertThat(readAscii(in, 3)).isEqualTo("ABC");
+    assertThat(in.read()).isEqualTo(-1);
+    // throws IOException in Gingerbread.
+    assertThat(in.read()).isEqualTo(-1);
+  }
+
+  @Test public void getOutputStreamOnGetFails() {
+    try {
+      new Request.Builder()
+          .url(server.url("/"))
+          .method("GET", RequestBody.create(null, "abc"))
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void clientSendsContentLength() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(null, "ABC"))
+        .build());
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "A");
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Content-Length")).isEqualTo("3");
+    response.body().close();
+  }
+
+  @Test public void getContentLengthConnects() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.body().contentLength()).isEqualTo(3L);
+    response.body().close();
+  }
+
+  @Test public void getContentTypeConnects() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Type: text/plain")
+        .setBody("ABC"));
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.body().contentType()).isEqualTo(
+        MediaType.get("text/plain"));
+    response.body().close();
+  }
+
+  @Test public void getContentEncodingConnects() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Encoding: identity")
+        .setBody("ABC"));
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.header("Content-Encoding")).isEqualTo("identity");
+    response.body().close();
+  }
+
+  @Test public void urlContainsQueryButNoPath() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    HttpUrl url = server.url("?query");
+    Response response = getResponse(newRequest(url));
+    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
+        "A");
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getRequestLine()).isEqualTo("GET /?query HTTP/1.1");
+  }
+
+  @Test public void doOutputForMethodThatDoesntSupportOutput() {
+    try {
+      new Request.Builder()
+          .url(server.url("/"))
+          .method("HEAD", RequestBody.create(null, ""))
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  // http://code.google.com/p/android/issues/detail?id=20442
+  @Test public void inputStreamAvailableWithChunkedEncoding() throws Exception {
+    testInputStreamAvailable(TransferKind.CHUNKED);
+  }
+
+  @Test public void inputStreamAvailableWithContentLengthHeader() throws Exception {
+    testInputStreamAvailable(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void inputStreamAvailableWithNoLengthHeaders() throws Exception {
+    testInputStreamAvailable(TransferKind.END_OF_STREAM);
+  }
+
+  private void testInputStreamAvailable(TransferKind transferKind) throws IOException {
+    String body = "ABCDEFGH";
+    MockResponse mockResponse = new MockResponse();
+    transferKind.setBody(mockResponse, body, 4);
+    server.enqueue(mockResponse);
+    Response response = getResponse(newRequest("/"));
+    InputStream in = response.body().byteStream();
+    for (int i = 0; i < body.length(); i++) {
+      assertThat(in.available()).isGreaterThanOrEqualTo(0);
+      assertThat(in.read()).isEqualTo(body.charAt(i));
+    }
+    assertThat(in.available()).isEqualTo(0);
+    assertThat(in.read()).isEqualTo(-1);
+  }
+
+  @Test public void postFailsWithBufferedRequestForSmallRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 1024);
+  }
+
+  @Test public void postFailsWithBufferedRequestForLargeRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 16384);
+  }
+
+  @Test public void postFailsWithChunkedRequestForSmallRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 1024);
+  }
+
+  @Test public void postFailsWithChunkedRequestForLargeRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 16384);
+  }
+
+  @Test public void postFailsWithFixedLengthRequestForSmallRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 1024);
+  }
+
+  @Test public void postFailsWithFixedLengthRequestForLargeRequest() throws Exception {
+    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 16384);
+  }
+
+  private void reusedConnectionFailsWithPost(TransferKind transferKind, int requestSize)
+      throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .setSocketPolicy(DISCONNECT_AT_END));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    assertContent("A", getResponse(newRequest("/a")));
+
+    // Give the server time to disconnect.
+    Thread.sleep(500);
+
+    // If the request body is larger than OkHttp's replay buffer, the failure may still occur.
+    char[] requestBodyChars = new char[requestSize];
+    Arrays.fill(requestBodyChars, 'x');
+    String requestBody = new String(requestBodyChars);
+
+    for (int j = 0; j < 2; j++) {
+      try {
+        Response response = getResponse(new Request.Builder()
+            .url(server.url("/b"))
+            .post(transferKind.newRequestBody(requestBody))
+            .build());
+        assertContent("B", response);
+        break;
+      } catch (IOException socketException) {
+        // If there's a socket exception, this must have a streamed request body.
+        assertThat(j).isEqualTo(0);
+        assertThat(transferKind).isIn(TransferKind.CHUNKED, TransferKind.FIXED_LENGTH);
+      }
+    }
+
+    RecordedRequest requestA = server.takeRequest();
+    assertThat(requestA.getPath()).isEqualTo("/a");
+    RecordedRequest requestB = server.takeRequest();
+    assertThat(requestB.getPath()).isEqualTo("/b");
+    assertThat(requestB.getBody().readUtf8()).isEqualTo(requestBody);
+  }
+
+  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(DISCONNECT_AFTER_REQUEST));
+    server.enqueue(new MockResponse()
+        .setBody("def"));
+
+    // Seed the connection pool so we have something that can fail.
+    assertContent("abc", getResponse(newRequest("/")));
+
+    Response post = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(null, "body!"))
+        .build());
+    assertContent("def", post);
+
+    RecordedRequest get = server.takeRequest();
+    assertThat(get.getSequenceNumber()).isEqualTo(0);
+
+    RecordedRequest post1 = server.takeRequest();
+    assertThat(post1.getBody().readUtf8()).isEqualTo("body!");
+    assertThat(post1.getSequenceNumber()).isEqualTo(1);
+
+    RecordedRequest post2 = server.takeRequest();
+    assertThat(post2.getBody().readUtf8()).isEqualTo("body!");
+    assertThat(post2.getSequenceNumber()).isEqualTo(0);
+  }
+
+  @Test public void fullyBufferedPostIsTooShort() {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    RequestBody requestBody = new RequestBody() {
+      @Override public @Nullable MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 4L;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("abc");
+      }
+    };
+    try {
+      getResponse(new Request.Builder()
+          .url(server.url("/b"))
+          .post(requestBody)
+          .build());
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test public void fullyBufferedPostIsTooLong() {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    RequestBody requestBody = new RequestBody() {
+      @Override public @Nullable MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 3L;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("abcd");
+      }
+    };
+    try {
+      getResponse(new Request.Builder()
+          .url(server.url("/b"))
+          .post(requestBody)
+          .build());
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  @Test @Ignore public void testPooledConnectionsDetectHttp10() {
+    // TODO: write a test that shows pooled connections detect HTTP/1.0 (vs. HTTP/1.1)
+    fail("TODO");
+  }
+
+  @Test @Ignore public void postBodiesRetransmittedOnAuthProblems() {
+    fail("TODO");
+  }
+
+  @Test @Ignore public void cookiesAndTrailers() {
+    // Do cookie headers get processed too many times?
+    fail("TODO");
+  }
+
+  @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("body"));
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .header("B", "")
+        .build());
+    assertContent("body", response);
+    assertThat(response.request().header("B")).isEqualTo("");
+  }
+
+  @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("A:")
+        .setBody("body"));
+    Response response = getResponse(newRequest("/"));
+    assertContent("body", response);
+    assertThat(response.header("A")).isEqualTo("");
+  }
+
+  @Test public void emptyRequestHeaderNameIsStrict() {
+    try {
+      new Request.Builder()
+          .url(server.url("/"))
+          .header("", "A")
+          .build();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void emptyResponseHeaderNameIsLenient() throws Exception {
+    Headers.Builder headers = new Headers.Builder();
+    InternalKtKt.addHeaderLenient(headers, ":A");
+    server.enqueue(new MockResponse()
+        .setHeaders(headers.build())
+        .setBody("body"));
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.header("")).isEqualTo("A");
+    response.body().close();
+  }
+
+  @Test public void requestHeaderValidationIsStrict() {
+    try {
+      new Request.Builder()
+          .addHeader("a\tb", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Request.Builder()
+          .addHeader("Name", "c\u007fd");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Request.Builder()
+          .addHeader("", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Request.Builder()
+          .addHeader("\ud83c\udf69", "Value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+    try {
+      new Request.Builder()
+          .addHeader("Name", "\u2615\ufe0f");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void responseHeaderParsingIsLenient() throws Exception {
+    Headers.Builder headersBuilder = new Headers.Builder();
+    headersBuilder.add("Content-Length", "0");
+    addHeaderLenient(headersBuilder, "a\tb: c\u007fd");
+    addHeaderLenient(headersBuilder, ": ef");
+    addHeaderLenient(headersBuilder, "\ud83c\udf69: \u2615\ufe0f");
+    Headers headers = headersBuilder.build();
+    server.enqueue(new MockResponse()
+        .setHeaders(headers));
+
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.header("a\tb")).isEqualTo("c\u007fd");
+    assertThat(response.header("\ud83c\udf69")).isEqualTo("\u2615\ufe0f");
+    assertThat(response.header("")).isEqualTo("ef");
+  }
+
+  @Test @Ignore public void deflateCompression() {
+    fail("TODO");
+  }
+
+  @Test @Ignore public void postBodiesRetransmittedOnIpAddressProblems() {
+    fail("TODO");
+  }
+
+  @Test @Ignore public void pooledConnectionProblemsNotReportedToProxySelector() {
+    fail("TODO");
+  }
+
+  @Test public void customBasicAuthenticator() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate."));
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    String credential = Credentials.basic("jesse", "peanutbutter");
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential, null);
+    client = client.newBuilder()
+        .authenticator(authenticator)
+        .build();
+    assertContent("A", getResponse(newRequest("/private")));
+
+    assertThat(server.takeRequest().getHeader("Authorization")).isNull();
+    assertThat(server.takeRequest().getHeader("Authorization")).isEqualTo(
+        credential);
+
+    assertThat(authenticator.onlyRoute().proxy()).isEqualTo(Proxy.NO_PROXY);
+    Response response = authenticator.onlyResponse();
+    assertThat(response.request().url().url().getPath()).isEqualTo("/private");
+    assertThat(response.challenges()).isEqualTo(
+        asList(new Challenge("Basic", "protected area")));
+  }
+
+  @Test public void customTokenAuthenticator() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
+        .setBody("Please authenticate."));
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+
+    RecordingOkAuthenticator authenticator
+        = new RecordingOkAuthenticator("oauthed abc123", "Bearer");
+    client = client.newBuilder()
+        .authenticator(authenticator)
+        .build();
+    assertContent("A", getResponse(newRequest("/private")));
+
+    assertThat(server.takeRequest().getHeader("Authorization")).isNull();
+    assertThat(server.takeRequest().getHeader("Authorization")).isEqualTo(
+        "oauthed abc123");
+
+    Response response = authenticator.onlyResponse();
+    assertThat(response.request().url().url().getPath()).isEqualTo("/private");
+    assertThat(response.challenges()).isEqualTo(
+        asList(new Challenge("Bearer", "oauthed")));
+  }
+
+  @Test public void authenticateCallsTrackedAsRedirects() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\""));
+    server.enqueue(new MockResponse()
+        .setBody("c"));
+
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
+        Credentials.basic("jesse", "peanutbutter"), "Basic");
+    client = client.newBuilder()
+        .authenticator(authenticator)
+        .build();
+    assertContent("c", getResponse(newRequest("/a")));
+
+    Response challengeResponse = authenticator.responses.get(0);
+    assertThat(challengeResponse.request().url().url().getPath()).isEqualTo(
+        "/b");
+
+    Response redirectedBy = challengeResponse.priorResponse();
+    assertThat(redirectedBy.request().url().url().getPath()).isEqualTo("/a");
+  }
+
+  @Test public void attemptAuthorization20Times() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(401));
+    }
+    server.enqueue(new MockResponse()
+        .setBody("Success!"));
+
+    String credential = Credentials.basic("jesse", "peanutbutter");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential, null))
+        .build();
+
+    Response response = getResponse(newRequest("/0"));
+    assertContent("Success!", response);
+  }
+
+  @Test public void doesNotAttemptAuthorization21Times() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(401));
+    }
+
+    String credential = Credentials.basic("jesse", "peanutbutter");
+    client = client.newBuilder()
+        .authenticator(new RecordingOkAuthenticator(credential, null))
+        .build();
+
+    try {
+      getResponse(newRequest("/"));
+      fail();
+    } catch (ProtocolException expected) {
+      assertThat(expected.getMessage()).isEqualTo(
+          "Too many follow-up requests: 21");
+    }
+  }
+
+  @Test public void setsNegotiatedProtocolHeader_HTTP_2() throws Exception {
+    setsNegotiatedProtocolHeader(Protocol.HTTP_2);
+  }
+
+  private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException {
+    enableProtocol(protocol);
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+    client = client.newBuilder()
+        .protocols(asList(protocol, Protocol.HTTP_1_1))
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.protocol()).isEqualTo(protocol);
+    assertContent("A", response);
+  }
+
+  @Test public void http10SelectedProtocol() throws IOException {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.0 200 OK"));
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_1_0);
+  }
+
+  @Test public void http11SelectedProtocol() throws IOException {
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 200 OK"));
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_1_1);
+  }
+
+  /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
+  @Test public void zeroLengthPost() throws Exception {
+    zeroLengthPayload("POST");
+  }
+
+  @Test public void zeroLengthPost_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    zeroLengthPost();
+  }
+
+  /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
+  @Test public void zeroLengthPut() throws Exception {
+    zeroLengthPayload("PUT");
+  }
+
+  @Test public void zeroLengthPut_HTTP_2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    zeroLengthPut();
+  }
+
+  private void zeroLengthPayload(String method) throws Exception {
+    server.enqueue(new MockResponse());
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .method(method, RequestBody.create(null, ""))
+        .build());
+    assertContent("", response);
+    RecordedRequest zeroLengthPayload = server.takeRequest();
+    assertThat(zeroLengthPayload.getMethod()).isEqualTo(method);
+    assertThat(zeroLengthPayload.getHeader("content-length")).isEqualTo("0");
+    assertThat(zeroLengthPayload.getBodySize()).isEqualTo(0L);
+  }
+
+  @Test public void setProtocols() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+    client = client.newBuilder()
+        .protocols(asList(Protocol.HTTP_1_1))
+        .build();
+    assertContent("A", getResponse(newRequest("/")));
+  }
+
+  @Test public void setProtocolsWithoutHttp11() {
+    try {
+      new OkHttpClient.Builder()
+          .protocols(asList(Protocol.HTTP_2));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setProtocolsWithNull() {
+    try {
+      new OkHttpClient.Builder()
+          .protocols(asList(Protocol.HTTP_1_1, null));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void veryLargeFixedLengthRequest() throws Exception {
+    server.setBodyLimit(0);
+    server.enqueue(new MockResponse());
+
+    long contentLength = Integer.MAX_VALUE + 1L;
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(new RequestBody() {
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
+
+          @Override public long contentLength() {
+            return contentLength;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            byte[] buffer = new byte[1024 * 1024];
+            for (long bytesWritten = 0; bytesWritten < contentLength; ) {
+              int byteCount = (int) Math.min(buffer.length, contentLength - bytesWritten);
+              bytesWritten += byteCount;
+              sink.write(buffer, 0, byteCount);
+            }
+          }
+        })
+        .build());
+
+    assertContent("", response);
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("Content-Length")).isEqualTo(
+        Long.toString(contentLength));
+  }
+
+  @Test public void testNoSslFallback() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false /* tunnelProxy */);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse()
+        .setBody("Response that would have needed fallbacks"));
+
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .build();
+    try {
+      getResponse(newRequest("/"));
+      fail();
+    } catch (SSLProtocolException expected) {
+      // RI response to the FAIL_HANDSHAKE
+    } catch (SSLHandshakeException expected) {
+      // Android's response to the FAIL_HANDSHAKE
+    } catch (SSLException expected) {
+      // JDK 1.9 response to the FAIL_HANDSHAKE
+      // javax.net.ssl.SSLException: Unexpected handshake message: client_hello
+    } catch (SocketException expected) {
+      // Conscrypt's response to the FAIL_HANDSHAKE
+    }
+  }
+
+  /**
+   * We had a bug where we attempted to gunzip responses that didn't have a body. This only came up
+   * with 304s since that response code can include headers (like "Content-Encoding") without any
+   * content to go along with it. https://github.com/square/okhttp/issues/358
+   */
+  @Test public void noTransparentGzipFor304NotModified() throws Exception {
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+        .setBody("b"));
+
+    Response response1 = getResponse(newRequest("/"));
+    assertThat(response1.code()).isEqualTo(
+        (long) HttpURLConnection.HTTP_NOT_MODIFIED);
+    assertContent("", response1);
+
+    Response response2 = getResponse(newRequest("/"));
+    assertThat(response2.code()).isEqualTo(HttpURLConnection.HTTP_OK);
+    assertContent("b", response2);
+
+    RecordedRequest requestA = server.takeRequest();
+    assertThat(requestA.getSequenceNumber()).isEqualTo(0);
+
+    RecordedRequest requestB = server.takeRequest();
+    assertThat(requestB.getSequenceNumber()).isEqualTo(1);
+  }
+
+  @Test public void nullSSLSocketFactory_throws() {
+    try {
+      client.newBuilder().sslSocketFactory(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  /**
+   * We had a bug where we weren't closing Gzip streams on redirects.
+   * https://github.com/square/okhttp/issues/441
+   */
+  @Test public void gzipWithRedirectAndConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("Moved! Moved! Moved!")));
+    server.enqueue(new MockResponse()
+        .setBody("This is the new page!"));
+
+    Response response = getResponse(newRequest("/"));
+    assertContent("This is the new page!", response);
+
+    RecordedRequest requestA = server.takeRequest();
+    assertThat(requestA.getSequenceNumber()).isEqualTo(0);
+
+    RecordedRequest requestB = server.takeRequest();
+    assertThat(requestB.getSequenceNumber()).isEqualTo(1);
+  }
+
+  /**
+   * The RFC is unclear in this regard as it only specifies that this should invalidate the cache
+   * entry (if any).
+   */
+  @Test public void bodyPermittedOnDelete() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Response response = getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .delete(RequestBody.create(null, "BODY"))
+        .build());
+    assertThat(response.code()).isEqualTo(200);
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getMethod()).isEqualTo("DELETE");
+    assertThat(request.getBody().readUtf8()).isEqualTo("BODY");
+  }
+
+  @Test public void userAgentDefaultsToOkHttpVersion() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    assertContent("abc", getResponse(newRequest("/")));
+
+    RecordedRequest request = server.takeRequest();
+    assertThat(request.getHeader("User-Agent")).isEqualTo(Version.userAgent());
+  }
+
+  @Test public void urlWithSpaceInHost() {
+    try {
+      HttpUrl.get("http://and roid.com/");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void urlWithSpaceInHostViaHttpProxy() {
+    try {
+      HttpUrl.get("http://and roid.com/");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void urlHostWithNul() {
+    try {
+      HttpUrl.get("http://host\u0000/");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void urlRedirectToHostWithNul() throws Exception {
+    String redirectUrl = "http://host\u0000/";
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeaderLenient("Location", redirectUrl));
+
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.code()).isEqualTo(302);
+    assertThat(response.header("Location")).isEqualTo(redirectUrl);
+  }
+
+  @Test public void urlWithBadAsciiHost() {
+    try {
+      HttpUrl.get("http://host\u0001/");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void setSslSocketFactoryFailsOnJdk9() {
+    assumeTrue(getPlatform().equals("jdk9"));
+
+    try {
+      client.newBuilder()
+          .sslSocketFactory(handshakeCertificates.sslSocketFactory());
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+
+  /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
+  @Test public void unexpectedExceptionSync() throws Exception {
+    client = client.newBuilder()
+        .dns(hostname -> {
+          throw new RuntimeException("boom!");
+        })
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    try {
+      getResponse(newRequest("/"));
+      fail();
+    } catch (RuntimeException expected) {
+      assertThat(expected.getMessage()).isEqualTo("boom!");
+    }
+  }
+
+  @Test public void streamedBodyIsRetriedOnHttp2Shutdown() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setBody("abc"));
+    server.enqueue(new MockResponse()
+        .setBody("def"));
+
+    // Send a separate request which will trigger a GOAWAY frame on the healthy connection.
+    Response response = getResponse(newRequest("/"));
+    assertContent("abc", response);
+
+    // Ensure the GOAWAY frame has time to be read and processed.
+    Thread.sleep(500);
+
+    assertContent("def", getResponse(new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(null, "123"))
+        .build()));
+
+    RecordedRequest request1 = server.takeRequest();
+    assertThat(request1.getSequenceNumber()).isEqualTo(0);
+
+    RecordedRequest request2 = server.takeRequest();
+    assertThat(request2.getBody().readUtf8()).isEqualTo("123");
+    assertThat(request2.getSequenceNumber()).isEqualTo(0);
+  }
+
+  @Test public void authenticateNoConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Connection: close")
+        .setResponseCode(401)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+
+    Authenticator.setDefault(new RecordingAuthenticator(null));
+    client = client.newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build();
+    Response response = getResponse(newRequest("/"));
+    assertThat(response.code()).isEqualTo(401);
+  }
+
+  private Request newRequest(String s) {
+    return newRequest(server.url(s));
+  }
+
+  private Request newRequest(HttpUrl url) {
+    return new Request.Builder()
+        .url(url)
+        .build();
+  }
+
+  private Response getResponse(Request request) throws IOException {
+    return client.newCall(request).execute();
+  }
+
+  /** Returns a gzipped copy of {@code bytes}. */
+  public Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink gzipSink = Okio.buffer(new GzipSink(result));
+    gzipSink.writeUtf8(data);
+    gzipSink.close();
+    return result;
+  }
+
+  private void assertContent(String expected, Response response, int limit)
+      throws IOException {
+    assertThat(readAscii(response.body().byteStream(), limit)).isEqualTo(
+        expected);
+  }
+
+  private void assertContent(String expected, Response response) throws IOException {
+    assertContent(expected, response, Integer.MAX_VALUE);
+  }
+
+  private Set<String> newSet(String... elements) {
+    return new LinkedHashSet<>(asList(elements));
+  }
+
+  enum TransferKind {
+    CHUNKED {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setChunkedBody(content, chunkSize);
+      }
+
+      @Override RequestBody newRequestBody(String body) {
+        return new RequestBody() {
+          @Override public long contentLength() {
+            return -1L;
+          }
+
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.writeUtf8(body);
+          }
+        };
+      }
+    },
+    FIXED_LENGTH {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+      }
+
+      @Override RequestBody newRequestBody(String body) {
+        return new RequestBody() {
+          @Override public long contentLength() {
+            return Utf8.size(body);
+          }
+
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.writeUtf8(body);
+          }
+        };
+      }
+    },
+    END_OF_STREAM {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
+        response.setBody(content);
+        response.setSocketPolicy(DISCONNECT_AT_END);
+        response.removeHeader("Content-Length");
+      }
+
+      @Override RequestBody newRequestBody(String body) {
+        throw new AssumptionViolatedException("END_OF_STREAM not implemented for requests");
+      }
+    };
+
+    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
+
+    abstract RequestBody newRequestBody(String body);
+
+    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
+      setBody(response, new Buffer().writeUtf8(content), chunkSize);
+    }
+  }
+
+  enum ProxyConfig {
+    NO_PROXY() {
+      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
+        return client.newBuilder()
+            .proxy(Proxy.NO_PROXY)
+            .build();
+      }
+    },
+
+    CREATE_ARG() {
+      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
+        return client.newBuilder()
+            .proxy(server.toProxyAddress())
+            .build();
+      }
+    },
+
+    PROXY_SYSTEM_PROPERTY() {
+      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
+        System.setProperty("proxyHost", server.getHostName());
+        System.setProperty("proxyPort", Integer.toString(server.getPort()));
+        return client;
+      }
+    },
+
+    HTTP_PROXY_SYSTEM_PROPERTY() {
+      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
+        System.setProperty("http.proxyHost", server.getHostName());
+        System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
+        return client;
+      }
+    },
+
+    HTTPS_PROXY_SYSTEM_PROPERTY() {
+      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
+        System.setProperty("https.proxyHost", server.getHostName());
+        System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
+        return client;
+      }
+    };
+
+    public abstract Call.Factory connect(MockWebServer server, OkHttpClient client)
+        throws IOException;
+
+    public Call connect(
+        MockWebServer server, OkHttpClient client, HttpUrl url) throws IOException {
+      Request request = new Request.Builder()
+          .url(url)
+          .build();
+      return connect(server, client).newCall(request);
+    }
+  }
+
+  private static class RecordingTrustManager implements X509TrustManager {
+    private final List<String> calls = new ArrayList<>();
+    private final X509TrustManager delegate;
+
+    RecordingTrustManager(X509TrustManager delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public X509Certificate[] getAcceptedIssuers() {
+      return delegate.getAcceptedIssuers();
+    }
+
+    @Override public void checkClientTrusted(X509Certificate[] chain, String authType) {
+      calls.add("checkClientTrusted " + certificatesToString(chain));
+    }
+
+    @Override public void checkServerTrusted(X509Certificate[] chain, String authType) {
+      calls.add("checkServerTrusted " + certificatesToString(chain));
+    }
+
+    private String certificatesToString(X509Certificate[] certificates) {
+      List<String> result = new ArrayList<>();
+      for (X509Certificate certificate : certificates) {
+        result.add(certificate.getSubjectDN() + " " + certificate.getSerialNumber());
+      }
+      return result.toString();
+    }
+  }
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
+   */
+  private void enableProtocol(Protocol protocol) {
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .protocols(asList(protocol, Protocol.HTTP_1_1))
+        .build();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.setProtocolNegotiationEnabled(true);
+    server.setProtocols(client.protocols());
+  }
+
+  /**
+   * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
+   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
+   * for details.
+   */
+  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
+    return new FallbackTestClientSocketFactory(handshakeCertificates.sslSocketFactory());
+  }
+
+  private String getPlatform() {
+    return System.getProperty("okhttp.platform", "platform");
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java b/okhttp/src/test/java/okhttp3/UrlComponentEncodingTester.java
similarity index 97%
rename from okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
rename to okhttp/src/test/java/okhttp3/UrlComponentEncodingTester.java
index 2ca0256881..bc2f054fc9 100644
--- a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
+++ b/okhttp/src/test/java/okhttp3/UrlComponentEncodingTester.java
@@ -230,7 +230,7 @@ public UrlComponentEncodingTester test(Component component) {
   private void testParseAlreadyEncoded(int codePoint, Encoding encoding, Component component) {
     String encoded = encoding.encode(codePoint);
     String urlString = component.urlString(encoded);
-    HttpUrl url = HttpUrl.parse(urlString);
+    HttpUrl url = HttpUrl.get(urlString);
     if (!component.encodedValue(url).equals(encoded)) {
       fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
     }
@@ -238,7 +238,7 @@ private void testParseAlreadyEncoded(int codePoint, Encoding encoding, Component
 
   private void testEncodeAndDecode(int codePoint, Component component) {
     String expected = Encoding.IDENTITY.encode(codePoint);
-    HttpUrl.Builder builder = HttpUrl.parse("http://host/").newBuilder();
+    HttpUrl.Builder builder = HttpUrl.get("http://host/").newBuilder();
     component.set(builder, expected);
     HttpUrl url = builder.build();
     String actual = component.get(url);
@@ -252,7 +252,7 @@ private void testParseOriginal(int codePoint, Encoding encoding, Component compo
     if (encoding != Encoding.PERCENT) return;
     String identity = Encoding.IDENTITY.encode(codePoint);
     String urlString = component.urlString(identity);
-    HttpUrl url = HttpUrl.parse(urlString);
+    HttpUrl url = HttpUrl.get(urlString);
 
     String s = component.encodedValue(url);
     if (!s.equals(encoded)) {
@@ -262,7 +262,7 @@ private void testParseOriginal(int codePoint, Encoding encoding, Component compo
 
   private void testToUrl(int codePoint, Encoding encoding, Component component) {
     String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
     URL javaNetUrl = httpUrl.url();
     if (!javaNetUrl.toString().equals(javaNetUrl.toString())) {
       fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
@@ -271,7 +271,7 @@ private void testToUrl(int codePoint, Encoding encoding, Component component) {
 
   private void testFromUrl(int codePoint, Encoding encoding, Component component) {
     String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
     HttpUrl toAndFromJavaNetUrl = HttpUrl.get(httpUrl.url());
     if (!toAndFromJavaNetUrl.equals(httpUrl)) {
       fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
@@ -282,7 +282,7 @@ private void testUri(
       int codePoint, Encoding encoding, Component component, boolean uriEscaped) {
     String string = new String(new int[] {codePoint}, 0, 1);
     String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
     URI uri = httpUrl.uri();
     HttpUrl toAndFromUri = HttpUrl.get(uri);
     if (uriEscaped) {
@@ -306,13 +306,13 @@ private void testUri(
 
   public enum Encoding {
     IDENTITY {
-      public String encode(int codePoint) {
+      @Override public String encode(int codePoint) {
         return new String(new int[] {codePoint}, 0, 1);
       }
     },
 
     PERCENT {
-      public String encode(int codePoint) {
+      @Override public String encode(int codePoint) {
         ByteString utf8 = ByteString.encodeUtf8(IDENTITY.encode(codePoint));
         Buffer percentEncoded = new Buffer();
         for (int i = 0; i < utf8.size(); i++) {
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java b/okhttp/src/test/java/okhttp3/WebPlatformUrlTest.java
similarity index 82%
rename from okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
rename to okhttp/src/test/java/okhttp3/WebPlatformUrlTest.java
index a15c57ea35..c12c6a417a 100644
--- a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
+++ b/okhttp/src/test/java/okhttp3/WebPlatformUrlTest.java
@@ -26,9 +26,7 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameter;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /** Runs the web platform URL tests against Java URL models. */
 @RunWith(Parameterized.class)
@@ -46,7 +44,7 @@
     }
   }
 
-  @Parameter(0)
+  @Parameter
   public WebPlatformUrlTestData testData;
 
   private static final List<String> HTTP_URL_SCHEMES
@@ -58,8 +56,6 @@
       "Parsing: <http://f:\n/c> against <http://example.org/foo/bar>",
       "Parsing: <http://f:999999/c> against <http://example.org/foo/bar>",
       "Parsing: <http://192.0x00A80001> against <about:blank>",
-      // This test fails on Java 7 but passes on Java 8. See HttpUrlTest.hostWithTrailingDot().
-      "Parsing: <http://%30%78%63%30%2e%30%32%35%30.01%2e> against <http://other.com/>",
       "Parsing: <http://%30%78%63%30%2e%30%32%35%30.01> against <http://other.com/>",
       "Parsing: <http://192.168.0.257> against <http://other.com/>",
       "Parsing: <http://ÔºêÔº∏ÔΩÉÔºêÔºéÔºêÔºíÔºïÔºêÔºéÔºêÔºë> against <http://other.com/>"
@@ -98,14 +94,15 @@ private void testHttpUrl() {
     if (testData.base.equals("about:blank")) {
       url = HttpUrl.parse(testData.input);
     } else {
-      HttpUrl baseUrl = HttpUrl.parse(testData.base);
+      HttpUrl baseUrl = HttpUrl.get(testData.base);
       url = baseUrl.resolve(testData.input);
     }
 
     if (testData.expectParseFailure()) {
-      assertNull("Expected URL to fail parsing", url);
+      assertThat(url).overridingErrorMessage("Expected URL to fail parsing").isNull();
     } else {
-      assertNotNull("Expected URL to parse successfully, but was null", url);
+      assertThat(url).overridingErrorMessage(
+          "Expected URL to parse successfully, but was null").isNotNull();
       String effectivePort = url.port() != HttpUrl.defaultPort(url.scheme())
           ? Integer.toString(url.port())
           : "";
@@ -114,12 +111,13 @@ private void testHttpUrl() {
       String effectiveHost = url.host().contains(":")
           ? ("[" + url.host() + "]")
           : url.host();
-      assertEquals("scheme", testData.scheme, url.scheme());
-      assertEquals("host", testData.host, effectiveHost);
-      assertEquals("port", testData.port, effectivePort);
-      assertEquals("path", testData.path, url.encodedPath());
-      assertEquals("query", testData.query, effectiveQuery);
-      assertEquals("fragment", testData.fragment, effectiveFragment);
+      assertThat(url.scheme()).overridingErrorMessage("scheme").isEqualTo(testData.scheme);
+      assertThat(effectiveHost).overridingErrorMessage("host").isEqualTo(testData.host);
+      assertThat(effectivePort).overridingErrorMessage("port").isEqualTo(testData.port);
+      assertThat(url.encodedPath()).overridingErrorMessage("path").isEqualTo(testData.path);
+      assertThat(effectiveQuery).overridingErrorMessage("query").isEqualTo(testData.query);
+      assertThat(effectiveFragment).overridingErrorMessage("fragment").isEqualTo(
+          testData.fragment);
     }
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java b/okhttp/src/test/java/okhttp3/WebPlatformUrlTestData.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTestData.java
rename to okhttp/src/test/java/okhttp3/WebPlatformUrlTestData.java
diff --git a/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java b/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
new file mode 100644
index 0000000000..6d9dcef39f
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
@@ -0,0 +1,321 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.HttpURLConnection;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.BufferedSink;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class WholeOperationTimeoutTest {
+  /** A large response body. Smaller bodies might successfully read after the socket is closed! */
+  private static final String BIG_ENOUGH_BODY = TestUtil.repeat('a', 64 * 1024);
+
+  @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+
+  private OkHttpClient client = clientTestRule.client;
+
+  @Test public void defaultConfigIsNoTimeout() throws Exception {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+    assertThat(call.timeout().timeoutNanos()).isEqualTo(0);
+  }
+
+  @Test public void configureClientDefault() throws Exception {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    OkHttpClient timeoutClient = client.newBuilder()
+        .callTimeout(456, TimeUnit.MILLISECONDS)
+        .build();
+
+    Call call = timeoutClient.newCall(request);
+    assertThat(call.timeout().timeoutNanos()).isEqualTo(TimeUnit.MILLISECONDS.toNanos(456));
+  }
+
+  @Test public void timeoutWritingRequest() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(sleepingRequestBody(500))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e.getMessage()).isEqualTo("timeout");
+      assertThat(call.isCanceled()).isTrue();
+    }
+  }
+
+  @Test public void timeoutWritingRequestWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(sleepingRequestBody(500))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        exceptionRef.set(e);
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        response.close();
+        latch.countDown();
+      }
+    });
+
+    latch.await();
+    assertThat(call.isCanceled()).isTrue();
+    assertThat(exceptionRef.get()).isNotNull();
+  }
+
+  @Test public void timeoutProcessing() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e.getMessage()).isEqualTo("timeout");
+      assertThat(call.isCanceled()).isTrue();
+    }
+  }
+
+  @Test public void timeoutProcessingWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        exceptionRef.set(e);
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        response.close();
+        latch.countDown();
+      }
+    });
+
+    latch.await();
+    assertThat(call.isCanceled()).isTrue();
+    assertThat(exceptionRef.get()).isNotNull();
+  }
+
+  @Test public void timeoutReadingResponse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    Response response = call.execute();
+    Thread.sleep(500);
+    try {
+      response.body().source().readUtf8();
+      fail();
+    } catch (IOException e) {
+      assertThat(e.getMessage()).isEqualTo("timeout");
+      assertThat(call.isCanceled()).isTrue();
+    }
+  }
+
+  @Test public void timeoutReadingResponseWithEnqueue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try {
+          Thread.sleep(500);
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+        try {
+          response.body().source().readUtf8();
+          fail();
+        } catch (IOException e) {
+          exceptionRef.set(e);
+        } finally {
+          latch.countDown();
+        }
+      }
+    });
+
+    latch.await();
+    assertThat(call.isCanceled()).isTrue();
+    assertThat(exceptionRef.get()).isNotNull();
+  }
+
+  @Test public void singleTimeoutForAllFollowUpRequests() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/b")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/c")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/d")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/e")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .setHeader("Location", "/f")
+        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
+    server.enqueue(new MockResponse());
+
+    Request request = new Request.Builder()
+        .url(server.url("/a"))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e.getMessage()).isEqualTo("timeout");
+      assertThat(call.isCanceled()).isTrue();
+    }
+  }
+
+  @Test
+  public void timeoutFollowingRedirectOnNewConnection() throws Exception {
+    MockWebServer otherServer = new MockWebServer();
+
+    server.enqueue(
+        new MockResponse()
+            .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+            .setHeader("Location", otherServer.url("/")));
+
+    otherServer.enqueue(new MockResponse().setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    Request request = new Request.Builder().url(server.url("/")).build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
+    try {
+      call.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e.getMessage()).isEqualTo("timeout");
+      assertThat(call.isCanceled()).isTrue();
+    }
+  }
+
+  @Test public void noTimeout() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(250, TimeUnit.MILLISECONDS)
+        .setBody(BIG_ENOUGH_BODY));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(sleepingRequestBody(250))
+        .build();
+
+    Call call = client.newCall(request);
+    call.timeout().timeout(1000, TimeUnit.MILLISECONDS);
+    Response response = call.execute();
+    Thread.sleep(250);
+    response.body().source().readUtf8();
+    response.close();
+    assertThat(call.isCanceled()).isFalse();
+  }
+
+  private RequestBody sleepingRequestBody(final int sleepMillis) {
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.parse("text/plain");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        try {
+          sink.writeUtf8("abc");
+          sink.flush();
+          Thread.sleep(sleepMillis);
+          sink.writeUtf8("def");
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+      }
+    };
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java b/okhttp/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
similarity index 92%
rename from okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
rename to okhttp/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
index 7811ff5d75..84b4b0f613 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
+++ b/okhttp/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
@@ -21,6 +21,8 @@
 import java.util.List;
 import okhttp3.Dns;
 
+import static java.util.Arrays.asList;
+
 /**
  * A network that always resolves two IP addresses per host. Use this when testing route selection
  * fallbacks to guarantee that a fallback address is available.
@@ -28,6 +30,6 @@
 public class DoubleInetAddressDns implements Dns {
   @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
     List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
-    return Arrays.asList(addresses.get(0), addresses.get(0));
+    return asList(addresses.get(0), addresses.get(0));
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java b/okhttp/src/test/java/okhttp3/internal/RecordingAuthenticator.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/internal/RecordingAuthenticator.java
rename to okhttp/src/test/java/okhttp3/internal/RecordingAuthenticator.java
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java b/okhttp/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
similarity index 76%
rename from okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
rename to okhttp/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
index 2464a910b4..126fce4d7e 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
+++ b/okhttp/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
@@ -18,7 +18,9 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nullable;
 import okhttp3.Authenticator;
+import okhttp3.Challenge;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.Route;
@@ -26,10 +28,12 @@
 public final class RecordingOkAuthenticator implements Authenticator {
   public final List<Response> responses = new ArrayList<>();
   public final List<Route> routes = new ArrayList<>();
-  public final String credential;
+  public @Nullable String credential;
+  public @Nullable String scheme;
 
-  public RecordingOkAuthenticator(String credential) {
+  public RecordingOkAuthenticator(@Nullable String credential, @Nullable String scheme) {
     this.credential = credential;
+    this.scheme = scheme;
   }
 
   public Response onlyResponse() {
@@ -49,10 +53,21 @@ public Route onlyRoute() {
     responses.add(response);
     routes.add(route);
 
-    if (credential == null) return null;
+    if (!schemeMatches(response) || credential == null) return null;
+
     String header = response.code() == 407 ? "Proxy-Authorization" : "Authorization";
     return response.request().newBuilder()
         .addHeader(header, credential)
         .build();
   }
+
+  private boolean schemeMatches(Response response) {
+    if (scheme == null) return true;
+
+    for (Challenge challenge : response.challenges()) {
+      if (challenge.scheme().equalsIgnoreCase(scheme)) return true;
+    }
+
+    return false;
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java b/okhttp/src/test/java/okhttp3/internal/SocketRecorder.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/internal/SocketRecorder.java
rename to okhttp/src/test/java/okhttp3/internal/SocketRecorder.java
diff --git a/okhttp/src/test/java/okhttp3/internal/UtilTest.java b/okhttp/src/test/java/okhttp3/internal/UtilTest.java
new file mode 100644
index 0000000000..cac32a9922
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/internal/UtilTest.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public final class UtilTest {
+  @Test public void immutableMap() {
+    Map<String, String> map = new LinkedHashMap<>();
+    map.put("a", "A");
+    Map<String, String> immutableCopy = Util.immutableMap(map);
+    assertThat(Collections.singletonMap("a", "A")).isEqualTo(immutableCopy);
+    map.clear();
+    assertThat(Collections.singletonMap("a", "A")).isEqualTo(immutableCopy);
+    try {
+      immutableCopy.clear();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java b/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
similarity index 85%
rename from okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
rename to okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
index 04ba57126b..98e8f76af3 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
@@ -19,7 +19,6 @@
 import java.io.IOException;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Deque;
 import java.util.Iterator;
 import java.util.List;
@@ -33,21 +32,17 @@
 import okio.Source;
 import org.junit.After;
 import org.junit.Before;
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 import org.junit.rules.Timeout;
 
+import static java.util.Arrays.asList;
 import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE;
 import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE_BACKUP;
 import static okhttp3.internal.cache.DiskLruCache.MAGIC;
 import static okhttp3.internal.cache.DiskLruCache.VERSION_1;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class DiskLruCacheTest {
@@ -121,7 +116,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     fileSystem.setFaultyDelete(cacheDir, false);
 
     DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertNull(snapshot);
+    assertThat(snapshot).isNull();
   }
 
   @Test public void validateKey() throws Exception {
@@ -129,45 +124,51 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     try {
       key = "has_space ";
       cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+      fail("Expecting an IllegalArgumentException as the key was invalid.");
     } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+      assertThat(iae.getMessage()).isEqualTo(
+          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
     }
     try {
       key = "has_CR\r";
       cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+      fail("Expecting an IllegalArgumentException as the key was invalid.");
     } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+      assertThat(iae.getMessage()).isEqualTo(
+          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
     }
     try {
       key = "has_LF\n";
       cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+      fail("Expecting an IllegalArgumentException as the key was invalid.");
     } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+      assertThat(iae.getMessage()).isEqualTo(
+          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
     }
     try {
       key = "has_invalid/";
       cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+      fail("Expecting an IllegalArgumentException as the key was invalid.");
     } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+      assertThat(iae.getMessage()).isEqualTo(
+          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
     }
     try {
       key = "has_invalid\u2603";
       cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was invalid.");
+      fail("Expecting an IllegalArgumentException as the key was invalid.");
     } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+      assertThat(iae.getMessage()).isEqualTo(
+          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
     }
     try {
       key = "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long_"
           + "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long";
       cache.edit(key);
-      fail("Exepcting an IllegalArgumentException as the key was too long.");
+      fail("Expecting an IllegalArgumentException as the key was too long.");
     } catch (IllegalArgumentException iae) {
-      assertEquals("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\"", iae.getMessage());
+      assertThat(iae.getMessage()).isEqualTo(
+          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
     }
 
     // Test valid cases.
@@ -188,8 +189,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor creator = cache.edit("k1");
     setString(creator, 0, "ABC");
     setString(creator, 1, "DE");
-    assertNull(creator.newSource(0));
-    assertNull(creator.newSource(1));
+    assertThat(creator.newSource(0)).isNull();
+    assertThat(creator.newSource(1)).isNull();
     creator.commit();
 
     DiskLruCache.Snapshot snapshot = cache.get("k1");
@@ -253,7 +254,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
   @Test public void journalDoesNotIncludeReadOfYetUnpublishedValue() throws Exception {
     DiskLruCache.Editor creator = cache.edit("k1");
-    assertNull(cache.get("k1"));
+    assertThat(cache.get("k1")).isNull();
     setString(creator, 0, "A");
     setString(creator, 1, "BC");
     creator.commit();
@@ -298,16 +299,16 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     setString(editor, 1, "B");
     editor.commit();
     File k1 = getCleanFile("k1", 0);
-    assertEquals("ABC", readFile(k1));
+    assertThat(readFile(k1)).isEqualTo("ABC");
     cache.remove("k1");
-    assertFalse(fileSystem.exists(k1));
+    assertThat(fileSystem.exists(k1)).isFalse();
   }
 
   @Test public void removePreventsActiveEditFromStoringAValue() throws Exception {
     set("a", "a", "a");
     DiskLruCache.Editor a = cache.edit("a");
     setString(a, 0, "a1");
-    assertTrue(cache.remove("a"));
+    assertThat(cache.remove("a")).isTrue();
     setString(a, 1, "a2");
     a.commit();
     assertAbsent("a");
@@ -325,8 +326,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     DiskLruCache.Snapshot snapshot1 = cache.get("k1");
     BufferedSource inV1 = Okio.buffer(snapshot1.getSource(0));
-    assertEquals('A', inV1.readByte());
-    assertEquals('A', inV1.readByte());
+    assertThat(inV1.readByte()).isEqualTo((byte) 'A');
+    assertThat(inV1.readByte()).isEqualTo((byte) 'A');
 
     DiskLruCache.Editor v1Updater = cache.edit("k1");
     setString(v1Updater, 0, "CCcc");
@@ -338,8 +339,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertSnapshotValue(snapshot2, 1, "DDdd");
     snapshot2.close();
 
-    assertEquals('a', inV1.readByte());
-    assertEquals('a', inV1.readByte());
+    assertThat(inV1.readByte()).isEqualTo((byte) 'a');
+    assertThat(inV1.readByte()).isEqualTo((byte) 'a');
     assertSnapshotValue(snapshot1, 1, "BBbb");
     snapshot1.close();
   }
@@ -356,11 +357,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     writeFile(dirtyFile1, "D");
     createJournal("CLEAN k1 1 1", "DIRTY   k1");
     createNewCache();
-    assertFalse(fileSystem.exists(cleanFile0));
-    assertFalse(fileSystem.exists(cleanFile1));
-    assertFalse(fileSystem.exists(dirtyFile0));
-    assertFalse(fileSystem.exists(dirtyFile1));
-    assertNull(cache.get("k1"));
+    assertThat(fileSystem.exists(cleanFile0)).isFalse();
+    assertThat(fileSystem.exists(cleanFile1)).isFalse();
+    assertThat(fileSystem.exists(dirtyFile0)).isFalse();
+    assertThat(fileSystem.exists(dirtyFile1)).isFalse();
+    assertThat(cache.get("k1")).isNull();
   }
 
   @Test public void openWithInvalidVersionClearsDirectory() throws Exception {
@@ -401,7 +402,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     createJournal("CLEAN k1 1 1", "BOGUS");
     createNewCache();
     assertGarbageFilesAllDeleted();
-    assertNull(cache.get("k1"));
+    assertThat(cache.get("k1")).isNull();
   }
 
   @Test public void openWithInvalidFileSizeClearsDirectory() throws Exception {
@@ -410,7 +411,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     createJournal("CLEAN k1 0000x001 1");
     createNewCache();
     assertGarbageFilesAllDeleted();
-    assertNull(cache.get("k1"));
+    assertThat(cache.get("k1")).isNull();
   }
 
   @Test public void openWithTruncatedLineDiscardsThatLine() throws Exception {
@@ -422,7 +423,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     sink.writeUtf8(MAGIC + "\n" + VERSION_1 + "\n100\n2\n\nCLEAN k1 1 1"); // no trailing newline
     sink.close();
     createNewCache();
-    assertNull(cache.get("k1"));
+    assertThat(cache.get("k1")).isNull();
 
     // The journal is not corrupt when editing after a truncated line.
     set("k1", "C", "D");
@@ -438,7 +439,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     createJournal("CLEAN k1 1 1 1");
     createNewCache();
     assertGarbageFilesAllDeleted();
-    assertNull(cache.get("k1"));
+    assertThat(cache.get("k1")).isNull();
   }
 
   @Test public void keyWithSpaceNotPermitted() throws Exception {
@@ -482,11 +483,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     } catch (IllegalStateException expected) {
     }
 
-    assertFalse(fileSystem.exists(getCleanFile("k1", 0)));
-    assertFalse(fileSystem.exists(getCleanFile("k1", 1)));
-    assertFalse(fileSystem.exists(getDirtyFile("k1", 0)));
-    assertFalse(fileSystem.exists(getDirtyFile("k1", 1)));
-    assertNull(cache.get("k1"));
+    assertThat(fileSystem.exists(getCleanFile("k1", 0))).isFalse();
+    assertThat(fileSystem.exists(getCleanFile("k1", 1))).isFalse();
+    assertThat(fileSystem.exists(getDirtyFile("k1", 0))).isFalse();
+    assertThat(fileSystem.exists(getDirtyFile("k1", 1))).isFalse();
+    assertThat(cache.get("k1")).isNull();
 
     DiskLruCache.Editor creator2 = cache.edit("k1");
     setString(creator2, 0, "B");
@@ -498,11 +499,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor creator = cache.edit("k1");
     setString(creator, 1, "A");
     creator.abort();
-    assertFalse(fileSystem.exists(getCleanFile("k1", 0)));
-    assertFalse(fileSystem.exists(getCleanFile("k1", 1)));
-    assertFalse(fileSystem.exists(getDirtyFile("k1", 0)));
-    assertFalse(fileSystem.exists(getDirtyFile("k1", 1)));
-    assertNull(cache.get("k1"));
+    assertThat(fileSystem.exists(getCleanFile("k1", 0))).isFalse();
+    assertThat(fileSystem.exists(getCleanFile("k1", 1))).isFalse();
+    assertThat(fileSystem.exists(getDirtyFile("k1", 0))).isFalse();
+    assertThat(fileSystem.exists(getDirtyFile("k1", 1))).isFalse();
+    assertThat(cache.get("k1")).isNull();
   }
 
   @Test public void updateExistingEntryWithTooFewValuesReusesPreviousValues() throws Exception {
@@ -528,7 +529,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "bb", "bbbb"); // size 6
     cache.setMaxSize(20);
     set("c", "c", "c"); // size 12
-    assertEquals(12, cache.size());
+    assertThat(cache.size()).isEqualTo(12);
   }
 
   @Test public void shrinkMaxSizeEvicts() throws Exception {
@@ -538,7 +539,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "bb", "bbbb"); // size 6
     set("c", "c", "c"); // size 12
     cache.setMaxSize(10);
-    assertEquals(1, executor.jobs.size());
+    assertThat(executor.jobs.size()).isEqualTo(1);
   }
 
   @Test public void evictOnInsert() throws Exception {
@@ -547,12 +548,12 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     set("a", "a", "aaa"); // size 4
     set("b", "bb", "bbbb"); // size 6
-    assertEquals(10, cache.size());
+    assertThat(cache.size()).isEqualTo(10);
 
     // Cause the size to grow to 12 should evict 'A'.
     set("c", "c", "c");
     cache.flush();
-    assertEquals(8, cache.size());
+    assertThat(cache.size()).isEqualTo(8);
     assertAbsent("a");
     assertValue("b", "bb", "bbbb");
     assertValue("c", "c", "c");
@@ -560,7 +561,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     // Causing the size to grow to 10 should evict nothing.
     set("d", "d", "d");
     cache.flush();
-    assertEquals(10, cache.size());
+    assertThat(cache.size()).isEqualTo(10);
     assertAbsent("a");
     assertValue("b", "bb", "bbbb");
     assertValue("c", "c", "c");
@@ -569,7 +570,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     // Causing the size to grow to 18 should evict 'B' and 'C'.
     set("e", "eeee", "eeee");
     cache.flush();
-    assertEquals(10, cache.size());
+    assertThat(cache.size()).isEqualTo(10);
     assertAbsent("a");
     assertAbsent("b");
     assertAbsent("c");
@@ -584,12 +585,12 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("a", "a", "aa"); // size 3
     set("b", "b", "bb"); // size 3
     set("c", "c", "cc"); // size 3
-    assertEquals(9, cache.size());
+    assertThat(cache.size()).isEqualTo(9);
 
     // Causing the size to grow to 11 should evict 'A'.
     set("b", "b", "bbbb");
     cache.flush();
-    assertEquals(8, cache.size());
+    assertThat(cache.size()).isEqualTo(8);
     assertAbsent("a");
     assertValue("b", "b", "bbbb");
     assertValue("c", "c", "cc");
@@ -610,7 +611,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     // Causing the size to grow to 12 should evict 'C'.
     set("g", "g", "g");
     cache.flush();
-    assertEquals(10, cache.size());
+    assertThat(cache.size()).isEqualTo(10);
     assertAbsent("a");
     assertValue("b", "b", "b");
     assertAbsent("c");
@@ -627,13 +628,13 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("e", "e", "e");
     set("f", "f", "f");
     cache.get("b").close(); // 'B' is now least recently used.
-    assertEquals(12, cache.size());
+    assertThat(cache.size()).isEqualTo(12);
     cache.close();
     createNewCacheWithSize(10);
 
     set("g", "g", "g");
     cache.flush();
-    assertEquals(10, cache.size());
+    assertThat(cache.size()).isEqualTo(10);
     assertAbsent("a");
     assertValue("b", "b", "b");
     assertAbsent("c");
@@ -682,7 +683,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
   @Test public void readingTheSameStreamMultipleTimes() throws Exception {
     set("a", "a", "b");
     DiskLruCache.Snapshot snapshot = cache.get("a");
-    assertSame(snapshot.getSource(0), snapshot.getSource(0));
+    assertThat(snapshot.getSource(0)).isSameAs(snapshot.getSource(0));
     snapshot.close();
   }
 
@@ -740,10 +741,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     executor.jobs.removeFirst().run();
 
     // Don't allow edits under any circumstances.
-    assertNull(cache.edit("a"));
-    assertNull(cache.edit("c"));
+    assertThat(cache.edit("a")).isNull();
+    assertThat(cache.edit("c")).isNull();
     DiskLruCache.Snapshot snapshot = cache.get("a");
-    assertNull(snapshot.edit());
+    assertThat(snapshot.edit()).isNull();
     snapshot.close();
   }
 
@@ -760,12 +761,12 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     // The rebuild is retried on cache hits and on cache edits.
     DiskLruCache.Snapshot snapshot = cache.get("b");
     snapshot.close();
-    assertNull(cache.edit("d"));
-    assertEquals(2, executor.jobs.size());
+    assertThat(cache.edit("d")).isNull();
+    assertThat(executor.jobs.size()).isEqualTo(2);
 
     // On cache misses, no retry job is queued.
-    assertNull(cache.get("c"));
-    assertEquals(2, executor.jobs.size());
+    assertThat(cache.get("c")).isNull();
+    assertThat(executor.jobs.size()).isEqualTo(2);
 
     // Let the rebuild complete successfully.
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
@@ -826,7 +827,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     // Although 'c' successfully committed above, the journal wasn't available to issue a CLEAN op.
     // Because the last state of 'c' was DIRTY before the journal failed, it should be removed
     // entirely on a subsequent open.
-    assertEquals(4, cache.size());
+    assertThat(cache.size()).isEqualTo(4);
     assertAbsent("c");
     assertAbsent("d");
     assertAbsent("e");
@@ -842,7 +843,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
     executor.jobs.removeFirst().run();
 
-    assertTrue(cache.remove("a"));
+    assertThat(cache.remove("a")).isTrue();
     assertAbsent("a");
 
     // Let the rebuild complete successfully.
@@ -862,7 +863,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
     executor.jobs.removeFirst().run();
 
-    assertTrue(cache.remove("a"));
+    assertThat(cache.remove("a")).isTrue();
     assertAbsent("a");
 
     cache.close();
@@ -871,9 +872,9 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     // The journal will have no record that 'a' was removed. It will have an entry for 'a', but when
     // it tries to read the cache files, it will find they were deleted. Once it encounters an entry
     // with missing cache files, it should remove it from the cache entirely.
-    assertEquals(4, cache.size());
-    assertNull(cache.get("a"));
-    assertEquals(2, cache.size());
+    assertThat(cache.size()).isEqualTo(4);
+    assertThat(cache.get("a")).isNull();
+    assertThat(cache.size()).isEqualTo(2);
   }
 
   @Test public void rebuildJournalFailureAllowsEvictAll() throws Exception {
@@ -888,7 +889,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     cache.evictAll();
 
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
     assertAbsent("a");
     assertAbsent("b");
 
@@ -898,10 +899,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     // The journal has no record that 'a' and 'b' were removed. It will have an entry for both, but
     // when it tries to read the cache files for either entry, it will discover the cache files are
     // missing and remove the entries from the cache.
-    assertEquals(4, cache.size());
-    assertNull(cache.get("a"));
-    assertNull(cache.get("b"));
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(4);
+    assertThat(cache.get("a")).isNull();
+    assertThat(cache.get("b")).isNull();
+    assertThat(cache.size()).isEqualTo(0);
   }
 
   @Test public void rebuildJournalFailureWithCacheTrim() throws Exception {
@@ -930,7 +931,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     cache.close();
 
     fileSystem.rename(journalFile, journalBkpFile);
-    assertFalse(fileSystem.exists(journalFile));
+    assertThat(fileSystem.exists(journalFile)).isFalse();
 
     createNewCache();
 
@@ -938,8 +939,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertSnapshotValue(snapshot, 0, "ABC");
     assertSnapshotValue(snapshot, 1, "DE");
 
-    assertFalse(fileSystem.exists(journalBkpFile));
-    assertTrue(fileSystem.exists(journalFile));
+    assertThat(fileSystem.exists(journalBkpFile)).isFalse();
+    assertThat(fileSystem.exists(journalFile)).isTrue();
   }
 
   @Test public void journalFileIsPreferredOverBackupFile() throws Exception {
@@ -957,8 +958,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     creator.commit();
     cache.close();
 
-    assertTrue(fileSystem.exists(journalFile));
-    assertTrue(fileSystem.exists(journalBkpFile));
+    assertThat(fileSystem.exists(journalFile)).isTrue();
+    assertThat(fileSystem.exists(journalBkpFile)).isTrue();
 
     createNewCache();
 
@@ -970,8 +971,8 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertSnapshotValue(snapshotB, 0, "F");
     assertSnapshotValue(snapshotB, 1, "GH");
 
-    assertFalse(fileSystem.exists(journalBkpFile));
-    assertTrue(fileSystem.exists(journalFile));
+    assertThat(fileSystem.exists(journalBkpFile)).isFalse();
+    assertThat(fileSystem.exists(journalFile)).isTrue();
   }
 
   @Test public void openCreatesDirectoryIfNecessary() throws Exception {
@@ -979,16 +980,16 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     File dir = tempDir.newFolder("testOpenCreatesDirectoryIfNecessary");
     cache = DiskLruCache.create(fileSystem, dir, appVersion, 2, Integer.MAX_VALUE);
     set("a", "a", "a");
-    assertTrue(fileSystem.exists(new File(dir, "a.0")));
-    assertTrue(fileSystem.exists(new File(dir, "a.1")));
-    assertTrue(fileSystem.exists(new File(dir, "journal")));
+    assertThat(fileSystem.exists(new File(dir, "a.0"))).isTrue();
+    assertThat(fileSystem.exists(new File(dir, "a.1"))).isTrue();
+    assertThat(fileSystem.exists(new File(dir, "journal"))).isTrue();
   }
 
   @Test public void fileDeletedExternally() throws Exception {
     set("a", "a", "a");
     fileSystem.delete(getCleanFile("a", 1));
-    assertNull(cache.get("a"));
-    assertEquals(0, cache.size());
+    assertThat(cache.get("a")).isNull();
+    assertThat(cache.size()).isEqualTo(0);
   }
 
   @Test public void editSameVersion() throws Exception {
@@ -1018,7 +1019,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor toAbort = snapshot.edit();
     setString(toAbort, 0, "b");
     toAbort.commit();
-    assertNull(snapshot.edit());
+    assertThat(snapshot.edit()).isNull();
   }
 
   @Test public void editSinceEvicted() throws Exception {
@@ -1029,7 +1030,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("b", "bb", "bbb"); // size 5
     set("c", "cc", "ccc"); // size 5; will evict 'A'
     cache.flush();
-    assertNull(snapshot.edit());
+    assertThat(snapshot.edit()).isNull();
   }
 
   @Test public void editSinceEvictedAndRecreated() throws Exception {
@@ -1041,7 +1042,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("c", "cc", "ccc"); // size 5; will evict 'A'
     set("a", "a", "aaaa"); // size 5; will evict 'B'
     cache.flush();
-    assertNull(snapshot.edit());
+    assertThat(snapshot.edit()).isNull();
   }
 
   /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
@@ -1075,13 +1076,13 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     fileSystem.deleteContents(tempDir.getRoot());
     setString(a, 1, "a2");
     a.commit();
-    assertNull(cache.get("a"));
+    assertThat(cache.get("a")).isNull();
   }
 
   /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
   @Test public void aggressiveClearingHandlesRead() throws Exception {
     fileSystem.deleteContents(tempDir.getRoot());
-    assertNull(cache.get("a"));
+    assertThat(cache.get("a")).isNull();
   }
 
   /**
@@ -1095,21 +1096,21 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     cache.setMaxSize(8); // Smaller than the sum of active edits!
     cache.flush(); // Force trimToSize().
-    assertEquals(0, cache.size());
-    assertNull(cache.get("a"));
+    assertThat(cache.size()).isEqualTo(0);
+    assertThat(cache.get("a")).isNull();
 
     // After the edit is completed, its entry is still gone.
     setString(a, 1, "a1");
     a.commit();
     assertAbsent("a");
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
   }
 
   @Test public void evictAll() throws Exception {
     set("a", "a", "a");
     set("b", "b", "b");
     cache.evictAll();
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
     assertAbsent("a");
     assertAbsent("b");
   }
@@ -1119,7 +1120,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     setString(a, 0, "a1");
     setString(a, 1, "a2");
     cache.evictAll();
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
     a.commit();
     assertAbsent("a");
   }
@@ -1130,7 +1131,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     setString(a, 0, "a1");
     setString(a, 1, "a2");
     cache.evictAll();
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
     a.commit();
     assertAbsent("a");
   }
@@ -1140,7 +1141,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Snapshot a = cache.get("a");
     assertSnapshotValue(a, 0, "a");
     cache.evictAll();
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
     assertAbsent("a");
     assertSnapshotValue(a, 1, "a");
     a.close();
@@ -1150,9 +1151,9 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("a", "a", "a");
     DiskLruCache.Snapshot a = cache.get("a");
     cache.evictAll();
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
     assertAbsent("a");
-    assertNull(a.edit());
+    assertThat(a.edit()).isNull();
     a.close();
   }
 
@@ -1162,28 +1163,28 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("c", "c1", "c2");
     Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
 
-    assertTrue(iterator.hasNext());
+    assertThat(iterator.hasNext()).isTrue();
     DiskLruCache.Snapshot a = iterator.next();
-    assertEquals("a", a.key());
+    assertThat(a.key()).isEqualTo("a");
     assertSnapshotValue(a, 0, "a1");
     assertSnapshotValue(a, 1, "a2");
     a.close();
 
-    assertTrue(iterator.hasNext());
+    assertThat(iterator.hasNext()).isTrue();
     DiskLruCache.Snapshot b = iterator.next();
-    assertEquals("b", b.key());
+    assertThat(b.key()).isEqualTo("b");
     assertSnapshotValue(b, 0, "b1");
     assertSnapshotValue(b, 1, "b2");
     b.close();
 
-    assertTrue(iterator.hasNext());
+    assertThat(iterator.hasNext()).isTrue();
     DiskLruCache.Snapshot c = iterator.next();
-    assertEquals("c", c.key());
+    assertThat(c.key()).isEqualTo("c");
     assertSnapshotValue(c, 0, "c1");
     assertSnapshotValue(c, 1, "c2");
     c.close();
 
-    assertFalse(iterator.hasNext());
+    assertThat(iterator.hasNext()).isFalse();
     try {
       iterator.next();
       fail();
@@ -1197,16 +1198,16 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
 
     DiskLruCache.Snapshot a = iterator.next();
-    assertEquals("a", a.key());
+    assertThat(a.key()).isEqualTo("a");
     a.close();
 
     set("c", "c1", "c2");
 
     DiskLruCache.Snapshot b = iterator.next();
-    assertEquals("b", b.key());
+    assertThat(b.key()).isEqualTo("b");
     b.close();
 
-    assertFalse(iterator.hasNext());
+    assertThat(iterator.hasNext()).isFalse();
   }
 
   @Test public void iteratorElementsUpdatedDuringIterationAreUpdated() throws Exception {
@@ -1215,13 +1216,13 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
 
     DiskLruCache.Snapshot a = iterator.next();
-    assertEquals("a", a.key());
+    assertThat(a.key()).isEqualTo("a");
     a.close();
 
     set("b", "b3", "b4");
 
     DiskLruCache.Snapshot b = iterator.next();
-    assertEquals("b", b.key());
+    assertThat(b.key()).isEqualTo("b");
     assertSnapshotValue(b, 0, "b3");
     assertSnapshotValue(b, 1, "b4");
     b.close();
@@ -1235,10 +1236,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     cache.remove("b");
 
     DiskLruCache.Snapshot a = iterator.next();
-    assertEquals("a", a.key());
+    assertThat(a.key()).isEqualTo("a");
     a.close();
 
-    assertFalse(iterator.hasNext());
+    assertThat(iterator.hasNext()).isFalse();
   }
 
   @Test public void iteratorRemove() throws Exception {
@@ -1249,7 +1250,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     a.close();
     iterator.remove();
 
-    assertEquals(null, cache.get("a"));
+    assertThat(cache.get("a")).isNull();
   }
 
   @Test public void iteratorRemoveBeforeNext() throws Exception {
@@ -1281,7 +1282,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     set("a", "a1", "a2");
     Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
     cache.close();
-    assertFalse(iterator.hasNext());
+    assertThat(iterator.hasNext()).isFalse();
   }
 
   @Test public void isClosed_uninitializedCache() throws Exception {
@@ -1289,9 +1290,9 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
     toClose.add(cache);
 
-    assertFalse(cache.isClosed());
+    assertThat(cache.isClosed()).isFalse();
     cache.close();
-    assertTrue(cache.isClosed());
+    assertThat(cache.isClosed()).isTrue();
   }
 
   @Test public void journalWriteFailsDuringEdit() throws Exception {
@@ -1300,11 +1301,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // We can't begin the edit if writing 'DIRTY' fails.
     fileSystem.setFaultyWrite(journalFile, true);
-    assertNull(cache.edit("c"));
+    assertThat(cache.edit("c")).isNull();
 
     // Once the journal has a failure, subsequent writes aren't permitted.
     fileSystem.setFaultyWrite(journalFile, false);
-    assertNull(cache.edit("d"));
+    assertThat(cache.edit("d")).isNull();
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
     cache.close();
@@ -1332,7 +1333,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Once the journal has a failure, subsequent writes aren't permitted.
     fileSystem.setFaultyWrite(journalFile, false);
-    assertNull(cache.edit("d"));
+    assertThat(cache.edit("d")).isNull();
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
     cache.close();
@@ -1356,7 +1357,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Once the journal has a failure, subsequent writes aren't permitted.
     fileSystem.setFaultyWrite(journalFile, false);
-    assertNull(cache.edit("d"));
+    assertThat(cache.edit("d")).isNull();
 
     // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
     cache.close();
@@ -1373,7 +1374,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Remove, but the journal write will fail.
     fileSystem.setFaultyWrite(journalFile, true);
-    assertTrue(cache.remove("a"));
+    assertThat(cache.remove("a")).isTrue();
 
     // Confirm that the entry was still removed.
     fileSystem.setFaultyWrite(journalFile, false);
@@ -1394,9 +1395,9 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     executor.jobs.pop().run();
 
     // Confirm that edits are prevented after a cache trim failure.
-    assertNull(cache.edit("a"));
-    assertNull(cache.edit("b"));
-    assertNull(cache.edit("c"));
+    assertThat(cache.edit("a")).isNull();
+    assertThat(cache.edit("b")).isNull();
+    assertThat(cache.edit("c")).isNull();
 
     // Allow the test to clean up.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
@@ -1413,12 +1414,12 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     executor.jobs.pop().run();
 
     // An edit should now add a job to clean up if the most recent trim failed.
-    assertNull(cache.edit("b"));
+    assertThat(cache.edit("b")).isNull();
     executor.jobs.pop().run();
 
     // Confirm a successful cache trim now allows edits.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    assertNull(cache.edit("c"));
+    assertThat(cache.edit("c")).isNull();
     executor.jobs.pop().run();
     set("c", "cc", "cc");
     assertValue("c", "cc", "cc");
@@ -1476,10 +1477,10 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Confirm snapshot writes are prevented after a trim failure.
     DiskLruCache.Snapshot snapshot1 = cache.get("a");
-    assertNull(snapshot1.edit());
+    assertThat(snapshot1.edit()).isNull();
     snapshot1.close();
     DiskLruCache.Snapshot snapshot2 = cache.get("b");
-    assertNull(snapshot2.edit());
+    assertThat(snapshot2.edit()).isNull();
     snapshot2.close();
 
     // Allow the test to clean up.
@@ -1497,7 +1498,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     executor.jobs.pop().run();
 
     // Confirm we prevent edits after a trim failure.
-    assertNull(cache.edit("c"));
+    assertThat(cache.edit("c")).isNull();
 
     // A successful eviction should allow new writes.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
@@ -1517,7 +1518,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     executor.jobs.pop().run();
 
     // Confirm we prevent edits after a trim failure.
-    assertNull(cache.edit("c"));
+    assertThat(cache.edit("c")).isNull();
 
     // A successful removal which trims the cache should allow new writes.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
@@ -1537,7 +1538,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     executor.jobs.pop().run();
 
     // Confirm we prevent edits after a trim failure.
-    assertNull(cache.edit("c"));
+    assertThat(cache.edit("c")).isNull();
 
     // A successful flush trims the cache and should allow new writes.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
@@ -1557,15 +1558,15 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     executor.jobs.pop().run();
 
     // Confirm the partial snapshot is not returned.
-    assertNull(cache.get("a"));
+    assertThat(cache.get("a")).isNull();
 
     // Confirm we prevent edits after a trim failure.
-    assertNull(cache.edit("a"));
+    assertThat(cache.edit("a")).isNull();
 
     // Confirm the partial snapshot is not returned after a successful trim.
     fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), false);
     executor.jobs.pop().run();
-    assertNull(cache.get("a"));
+    assertThat(cache.get("a")).isNull();
   }
 
   @Test public void noSizeCorruptionAfterCreatorDetached() throws Exception {
@@ -1577,11 +1578,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Create a new value in its place.
     set("k1", "bb", "bb");
-    assertEquals(4, cache.size());
+    assertThat(cache.size()).isEqualTo(4);
 
     // Committing the detached editor should not change the cache's size.
     editor.commit();
-    assertEquals(4, cache.size());
+    assertThat(cache.size()).isEqualTo(4);
     assertValue("k1", "bb", "bb");
   }
 
@@ -1596,11 +1597,11 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
 
     // Create a new value in its place.
     set("k1", "ccc", "ccc");
-    assertEquals(6, cache.size());
+    assertThat(cache.size()).isEqualTo(6);
 
     // Committing the detached editor should not change the cache's size.
     editor.commit();
-    assertEquals(6, cache.size());
+    assertThat(cache.size()).isEqualTo(6);
     assertValue("k1", "ccc", "ccc");
   }
 
@@ -1610,7 +1611,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     DiskLruCache.Editor editor = cache.edit("k1");
     cache.evictAll();
 
-    assertNull(editor.newSource(0));
+    assertThat(editor.newSource(0)).isNull();
   }
 
   @Test public void editsDiscardedAfterEditorDetached() throws Exception {
@@ -1638,7 +1639,7 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     cache.evictAll();
 
     editor.abort();
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
     assertAbsent("k1");
   }
 
@@ -1649,8 +1650,8 @@ private void assertJournalEquals(String... expectedBodyLines) throws Exception {
     expectedLines.add("100");
     expectedLines.add("2");
     expectedLines.add("");
-    expectedLines.addAll(Arrays.asList(expectedBodyLines));
-    assertEquals(expectedLines, readJournalLines());
+    expectedLines.addAll(asList(expectedBodyLines));
+    assertThat(readJournalLines()).isEqualTo(expectedLines);
   }
 
   private void createJournal(String... bodyLines) throws Exception {
@@ -1744,12 +1745,12 @@ private void generateSomeGarbageFiles() throws Exception {
   }
 
   private void assertGarbageFilesAllDeleted() {
-    assertFalse(fileSystem.exists(getCleanFile("g1", 0)));
-    assertFalse(fileSystem.exists(getCleanFile("g1", 1)));
-    assertFalse(fileSystem.exists(getCleanFile("g2", 0)));
-    assertFalse(fileSystem.exists(getCleanFile("g2", 1)));
-    assertFalse(fileSystem.exists(new File(cacheDir, "otherFile0")));
-    assertFalse(fileSystem.exists(new File(cacheDir, "dir1")));
+    assertThat(fileSystem.exists(getCleanFile("g1", 0))).isFalse();
+    assertThat(fileSystem.exists(getCleanFile("g1", 1))).isFalse();
+    assertThat(fileSystem.exists(getCleanFile("g2", 0))).isFalse();
+    assertThat(fileSystem.exists(getCleanFile("g2", 1))).isFalse();
+    assertThat(fileSystem.exists(new File(cacheDir, "otherFile0"))).isFalse();
+    assertThat(fileSystem.exists(new File(cacheDir, "dir1"))).isFalse();
   }
 
   private void set(String key, String value0, String value1) throws Exception {
@@ -1772,25 +1773,25 @@ private void assertAbsent(String key) throws Exception {
       snapshot.close();
       fail();
     }
-    assertFalse(fileSystem.exists(getCleanFile(key, 0)));
-    assertFalse(fileSystem.exists(getCleanFile(key, 1)));
-    assertFalse(fileSystem.exists(getDirtyFile(key, 0)));
-    assertFalse(fileSystem.exists(getDirtyFile(key, 1)));
+    assertThat(fileSystem.exists(getCleanFile(key, 0))).isFalse();
+    assertThat(fileSystem.exists(getCleanFile(key, 1))).isFalse();
+    assertThat(fileSystem.exists(getDirtyFile(key, 0))).isFalse();
+    assertThat(fileSystem.exists(getDirtyFile(key, 1))).isFalse();
   }
 
   private void assertValue(String key, String value0, String value1) throws Exception {
     DiskLruCache.Snapshot snapshot = cache.get(key);
     assertSnapshotValue(snapshot, 0, value0);
     assertSnapshotValue(snapshot, 1, value1);
-    assertTrue(fileSystem.exists(getCleanFile(key, 0)));
-    assertTrue(fileSystem.exists(getCleanFile(key, 1)));
+    assertThat(fileSystem.exists(getCleanFile(key, 0))).isTrue();
+    assertThat(fileSystem.exists(getCleanFile(key, 1))).isTrue();
     snapshot.close();
   }
 
   private void assertSnapshotValue(DiskLruCache.Snapshot snapshot, int index, String value)
       throws IOException {
-    assertEquals(value, sourceAsString(snapshot.getSource(index)));
-    assertEquals(value.length(), snapshot.getLength(index));
+    assertThat(sourceAsString(snapshot.getSource(index))).isEqualTo(value);
+    assertThat(snapshot.getLength(index)).isEqualTo(value.length());
   }
 
   private String sourceAsString(Source source) throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java b/okhttp/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
similarity index 87%
rename from okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
rename to okhttp/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
index 21bbd49358..cca27974fc 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
@@ -30,7 +30,7 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class FileOperatorTest {
@@ -55,10 +55,10 @@
 
     Buffer buffer = new Buffer();
     operator.read(0, buffer, 5);
-    assertEquals("Hello", buffer.readUtf8());
+    assertThat(buffer.readUtf8()).isEqualTo("Hello");
 
     operator.read(4, buffer, 5);
-    assertEquals("o, Wo", buffer.readUtf8());
+    assertThat(buffer.readUtf8()).isEqualTo("o, Wo");
   }
 
   @Test public void write() throws Exception {
@@ -66,13 +66,13 @@
 
     Buffer buffer1 = new Buffer().writeUtf8("Hello, World");
     operator.write(0, buffer1, 5);
-    assertEquals(", World", buffer1.readUtf8());
+    assertThat(buffer1.readUtf8()).isEqualTo(", World");
 
     Buffer buffer2 = new Buffer().writeUtf8("icopter!");
     operator.write(3, buffer2, 7);
-    assertEquals("!", buffer2.readUtf8());
+    assertThat(buffer2.readUtf8()).isEqualTo("!");
 
-    assertEquals(ByteString.encodeUtf8("Helicopter"), snapshot());
+    assertThat(snapshot()).isEqualTo(ByteString.encodeUtf8("Helicopter"));
   }
 
   @Test public void readAndWrite() throws Exception {
@@ -99,12 +99,12 @@
     operator.read(4, buffer, 19);
     operator.write(80, buffer, buffer.size());
 
-    assertEquals(snapshot(), ByteString.encodeUtf8(""
+    assertThat(ByteString.encodeUtf8(""
         + "god creates dinosaurs. "
         + "god destroys dinosaurs. "
         + "god creates man. "
         + "man destroys god. "
-        + "man creates dinosaurs. "));
+        + "man creates dinosaurs. ")).isEqualTo(snapshot());
   }
 
   @Test public void multipleOperatorsShareOneFile() throws Exception {
@@ -124,13 +124,13 @@
     operatorA.write(36, bufferA, 33);
 
     operatorB.read(0, bufferB, 9);
-    assertEquals("Dodgson!\n", bufferB.readUtf8());
+    assertThat(bufferB.readUtf8()).isEqualTo("Dodgson!\n");
 
     operatorA.read(9, bufferA, 27);
-    assertEquals("You shouldn't use my name.\n", bufferA.readUtf8());
+    assertThat(bufferA.readUtf8()).isEqualTo("You shouldn't use my name.\n");
 
     operatorB.read(36, bufferB, 33);
-    assertEquals("Dodgson, we've got Dodgson here!\n", bufferB.readUtf8());
+    assertThat(bufferB.readUtf8()).isEqualTo("Dodgson, we've got Dodgson here!\n");
   }
 
   @Test public void largeRead() throws Exception {
@@ -141,7 +141,7 @@
 
     Buffer buffer = new Buffer();
     operator.read(0, buffer, data.size());
-    assertEquals(data, buffer.readByteString());
+    assertThat(buffer.readByteString()).isEqualTo(data);
   }
 
   @Test public void largeWrite() throws Exception {
@@ -152,7 +152,7 @@
     Buffer buffer = new Buffer().write(data);
     operator.write(0, buffer, data.size());
 
-    assertEquals(data, snapshot());
+    assertThat(snapshot()).isEqualTo(data);
   }
 
   @Test public void readBounds() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java b/okhttp/src/test/java/okhttp3/internal/cache2/RelayTest.java
similarity index 68%
rename from okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
rename to okhttp/src/test/java/okhttp3/internal/cache2/RelayTest.java
index cbffa87d09..5e3911899f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache2/RelayTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/cache2/RelayTest.java
@@ -34,10 +34,7 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class RelayTest {
@@ -63,17 +60,17 @@
     Source source = relay.newSource();
     Buffer sourceBuffer = new Buffer();
 
-    assertEquals(5, source.read(sourceBuffer, 5));
-    assertEquals("abcde", sourceBuffer.readUtf8());
+    assertThat(source.read(sourceBuffer, 5)).isEqualTo(5);
+    assertThat(sourceBuffer.readUtf8()).isEqualTo("abcde");
 
-    assertEquals(8, source.read(sourceBuffer, 1024));
-    assertEquals("fghijklm", sourceBuffer.readUtf8());
+    assertThat(source.read(sourceBuffer, 1024)).isEqualTo(8);
+    assertThat(sourceBuffer.readUtf8()).isEqualTo("fghijklm");
 
-    assertEquals(-1, source.read(sourceBuffer, 1024));
-    assertEquals(0, sourceBuffer.size());
+    assertThat(source.read(sourceBuffer, 1024)).isEqualTo(-1);
+    assertThat(sourceBuffer.size()).isEqualTo(0);
 
     source.close();
-    assertTrue(relay.isClosed());
+    assertThat(relay.isClosed()).isTrue();
     assertFile(Relay.PREFIX_CLEAN, 13L, metadata.size(), "abcdefghijklm", metadata);
   }
 
@@ -85,11 +82,11 @@
     BufferedSource source1 = Okio.buffer(relay.newSource());
     BufferedSource source2 = Okio.buffer(relay.newSource());
 
-    assertEquals("abcdefghijklm", source1.readUtf8());
-    assertEquals("abcdefghijklm", source2.readUtf8());
+    assertThat(source1.readUtf8()).isEqualTo("abcdefghijklm");
+    assertThat(source2.readUtf8()).isEqualTo("abcdefghijklm");
     source1.close();
     source2.close();
-    assertTrue(relay.isClosed());
+    assertThat(relay.isClosed()).isTrue();
 
     assertFile(Relay.PREFIX_CLEAN, 13L, metadata.size(), "abcdefghijklm", metadata);
   }
@@ -102,15 +99,15 @@
     BufferedSource source1 = Okio.buffer(relay.newSource());
     BufferedSource source2 = Okio.buffer(relay.newSource());
 
-    assertEquals("abcde", source1.readUtf8(5));
-    assertEquals("abcde", source2.readUtf8(5));
-    assertEquals("fghij", source2.readUtf8(5));
-    assertEquals("fghij", source1.readUtf8(5));
-    assertTrue(source1.exhausted());
-    assertTrue(source2.exhausted());
+    assertThat(source1.readUtf8(5)).isEqualTo("abcde");
+    assertThat(source2.readUtf8(5)).isEqualTo("abcde");
+    assertThat(source2.readUtf8(5)).isEqualTo("fghij");
+    assertThat(source1.readUtf8(5)).isEqualTo("fghij");
+    assertThat(source1.exhausted()).isTrue();
+    assertThat(source2.exhausted()).isTrue();
     source1.close();
     source2.close();
-    assertTrue(relay.isClosed());
+    assertThat(relay.isClosed()).isTrue();
 
     assertFile(Relay.PREFIX_CLEAN, 10L, metadata.size(), "abcdefghij", metadata);
   }
@@ -123,15 +120,15 @@
     BufferedSource source1 = Okio.buffer(relay.newSource());
     BufferedSource source2 = Okio.buffer(relay.newSource());
 
-    assertEquals("abcdefghij", source1.readUtf8(10));
-    assertEquals("abcdefghij", source2.readUtf8(10));
-    assertEquals("klmnopqrst", source2.readUtf8(10));
-    assertEquals("klmnopqrst", source1.readUtf8(10));
-    assertTrue(source1.exhausted());
-    assertTrue(source2.exhausted());
+    assertThat(source1.readUtf8(10)).isEqualTo("abcdefghij");
+    assertThat(source2.readUtf8(10)).isEqualTo("abcdefghij");
+    assertThat(source2.readUtf8(10)).isEqualTo("klmnopqrst");
+    assertThat(source1.readUtf8(10)).isEqualTo("klmnopqrst");
+    assertThat(source1.exhausted()).isTrue();
+    assertThat(source2.exhausted()).isTrue();
     source1.close();
     source2.close();
-    assertTrue(relay.isClosed());
+    assertThat(relay.isClosed()).isTrue();
 
     assertFile(Relay.PREFIX_CLEAN, 20L, metadata.size(), "abcdefghijklmnopqrst", metadata);
   }
@@ -142,24 +139,24 @@
 
     Relay relay1 = Relay.edit(file, upstream, metadata, 5);
     BufferedSource source1 = Okio.buffer(relay1.newSource());
-    assertEquals("abcdefghij", source1.readUtf8(10));
-    assertTrue(source1.exhausted());
+    assertThat(source1.readUtf8(10)).isEqualTo("abcdefghij");
+    assertThat(source1.exhausted()).isTrue();
     source1.close();
-    assertTrue(relay1.isClosed());
+    assertThat(relay1.isClosed()).isTrue();
 
     // Since relay1 is closed, new sources cannot be created.
-    assertNull(relay1.newSource());
+    assertThat(relay1.newSource()).isNull();
 
     Relay relay2 = Relay.read(file);
-    assertEquals(metadata, relay2.metadata());
+    assertThat(relay2.metadata()).isEqualTo(metadata);
     BufferedSource source2 = Okio.buffer(relay2.newSource());
-    assertEquals("abcdefghij", source2.readUtf8(10));
-    assertTrue(source2.exhausted());
+    assertThat(source2.readUtf8(10)).isEqualTo("abcdefghij");
+    assertThat(source2.exhausted()).isTrue();
     source2.close();
-    assertTrue(relay2.isClosed());
+    assertThat(relay2.isClosed()).isTrue();
 
     // Since relay2 is closed, new sources cannot be created.
-    assertNull(relay2.newSource());
+    assertThat(relay2.newSource()).isNull();
 
     assertFile(Relay.PREFIX_CLEAN, 10L, metadata.size(), "abcdefghij", metadata);
   }
@@ -170,15 +167,15 @@
 
     Relay relay1 = Relay.edit(file, upstream, metadata, 5);
     BufferedSource source1 = Okio.buffer(relay1.newSource());
-    assertEquals("abcdefghij", source1.readUtf8(10));
+    assertThat(source1.readUtf8(10)).isEqualTo("abcdefghij");
     source1.close(); // Not exhausted!
-    assertTrue(relay1.isClosed());
+    assertThat(relay1.isClosed()).isTrue();
 
     try {
       Relay.read(file);
       fail();
     } catch (IOException expected) {
-      assertEquals("unreadable cache file", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("unreadable cache file");
     }
 
     assertFile(Relay.PREFIX_DIRTY, -1L, -1, null, null);
@@ -194,10 +191,10 @@
 
     source1.close();
     source1.close(); // Unnecessary. Shouldn't decrement the reference count.
-    assertFalse(relay.isClosed());
+    assertThat(relay.isClosed()).isFalse();
 
     source2.close();
-    assertTrue(relay.isClosed());
+    assertThat(relay.isClosed()).isTrue();
     assertFile(Relay.PREFIX_DIRTY, -1L, -1, null, null);
   }
 
@@ -217,38 +214,36 @@
     sink.writeUtf8("klmnopqrst");
     sink.close();
 
-    assertEquals(ByteString.encodeUtf8("abcdefghijklmnopqrst"), future1.get());
-    assertEquals(ByteString.encodeUtf8("abcdefghijklmnopqrst"), future2.get());
+    assertThat(future1.get()).isEqualTo(ByteString.encodeUtf8("abcdefghijklmnopqrst"));
+    assertThat(future2.get()).isEqualTo(ByteString.encodeUtf8("abcdefghijklmnopqrst"));
 
-    assertTrue(relay.isClosed());
+    assertThat(relay.isClosed()).isTrue();
 
     assertFile(Relay.PREFIX_CLEAN, 20L, metadata.size(), "abcdefghijklmnopqrst", metadata);
   }
 
   /** Returns a callable that reads all of source, closes it, and returns the bytes. */
   private Callable<ByteString> sourceReader(final Source source) {
-    return new Callable<ByteString>() {
-      @Override public ByteString call() throws Exception {
-        Buffer buffer = new Buffer();
-        while (source.read(buffer, 16384) != -1) {
-        }
-        source.close();
-        return buffer.readByteString();
+    return () -> {
+      Buffer buffer = new Buffer();
+      while (source.read(buffer, 16384) != -1) {
       }
+      source.close();
+      return buffer.readByteString();
     };
   }
 
   private void assertFile(ByteString prefix, long upstreamSize, int metadataSize, String upstream,
       ByteString metadata) throws IOException {
     BufferedSource source = Okio.buffer(Okio.source(file));
-    assertEquals(prefix, source.readByteString(prefix.size()));
-    assertEquals(upstreamSize, source.readLong());
-    assertEquals(metadataSize, source.readLong());
+    assertThat(source.readByteString(prefix.size())).isEqualTo(prefix);
+    assertThat(source.readLong()).isEqualTo(upstreamSize);
+    assertThat(source.readLong()).isEqualTo(metadataSize);
     if (upstream != null) {
-      assertEquals(upstream, source.readUtf8(upstreamSize));
+      assertThat(source.readUtf8(upstreamSize)).isEqualTo(upstream);
     }
     if (metadata != null) {
-      assertEquals(metadata, source.readByteString(metadataSize));
+      assertThat(source.readByteString(metadataSize)).isEqualTo(metadata);
     }
     source.close();
   }
diff --git a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
new file mode 100644
index 0000000000..3224f9fa22
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.Socket;
+import java.util.Collections;
+import java.util.concurrent.TimeUnit;
+import javax.net.SocketFactory;
+import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.ConnectionPool;
+import okhttp3.Dns;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Route;
+import okhttp3.internal.Internal;
+import okhttp3.internal.RecordingOkAuthenticator;
+import org.junit.Test;
+
+import static okhttp3.TestUtil.awaitGarbageCollection;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class ConnectionPoolTest {
+  private final Address addressA = newAddress("a");
+  private final Route routeA1 = newRoute(addressA);
+  private final Address addressB = newAddress("b");
+  private final Route routeB1 = newRoute(addressB);
+  private final Address addressC = newAddress("c");
+  private final Route routeC1 = newRoute(addressC);
+
+  static {
+    Internal.initializeInstanceForTests();
+  }
+
+  @Test public void connectionsEvictedWhenIdleLongEnough() throws Exception {
+    RealConnectionPool pool = new RealConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 50L);
+
+    // Running at time 50, the pool returns that nothing can be evicted until time 150.
+    assertThat(pool.cleanup(50L)).isEqualTo(100L);
+    assertThat(pool.connectionCount()).isEqualTo(1);
+    assertThat(c1.socket().isClosed()).isFalse();
+
+    // Running at time 60, the pool returns that nothing can be evicted until time 150.
+    assertThat(pool.cleanup(60L)).isEqualTo(90L);
+    assertThat(pool.connectionCount()).isEqualTo(1);
+    assertThat(c1.socket().isClosed()).isFalse();
+
+    // Running at time 149, the pool returns that nothing can be evicted until time 150.
+    assertThat(pool.cleanup(149L)).isEqualTo(1L);
+    assertThat(pool.connectionCount()).isEqualTo(1);
+    assertThat(c1.socket().isClosed()).isFalse();
+
+    // Running at time 150, the pool evicts.
+    assertThat(pool.cleanup(150L)).isEqualTo(0);
+    assertThat(pool.connectionCount()).isEqualTo(0);
+    assertThat(c1.socket().isClosed()).isTrue();
+
+    // Running again, the pool reports that no further runs are necessary.
+    assertThat(pool.cleanup(150L)).isEqualTo(-1);
+    assertThat(pool.connectionCount()).isEqualTo(0);
+    assertThat(c1.socket().isClosed()).isTrue();
+  }
+
+  @Test public void inUseConnectionsNotEvicted() throws Exception {
+    ConnectionPool poolApi = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    RealConnectionPool pool = Internal.instance.realConnectionPool(poolApi);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 50L);
+    synchronized (pool) {
+      OkHttpClient client = new OkHttpClient.Builder()
+          .connectionPool(poolApi)
+          .build();
+      Call call = client.newCall(newRequest(addressA));
+      Transmitter transmitter = new Transmitter(client, call);
+      transmitter.prepareToConnect(call.request());
+      transmitter.acquireConnectionNoEvents(c1);
+    }
+
+    // Running at time 50, the pool returns that nothing can be evicted until time 150.
+    assertThat(pool.cleanup(50L)).isEqualTo(100L);
+    assertThat(pool.connectionCount()).isEqualTo(1);
+    assertThat(c1.socket().isClosed()).isFalse();
+
+    // Running at time 60, the pool returns that nothing can be evicted until time 160.
+    assertThat(pool.cleanup(60L)).isEqualTo(100L);
+    assertThat(pool.connectionCount()).isEqualTo(1);
+    assertThat(c1.socket().isClosed()).isFalse();
+
+    // Running at time 160, the pool returns that nothing can be evicted until time 260.
+    assertThat(pool.cleanup(160L)).isEqualTo(100L);
+    assertThat(pool.connectionCount()).isEqualTo(1);
+    assertThat(c1.socket().isClosed()).isFalse();
+  }
+
+  @Test public void cleanupPrioritizesEarliestEviction() throws Exception {
+    RealConnectionPool pool = new RealConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 75L);
+    RealConnection c2 = newConnection(pool, routeB1, 50L);
+
+    // Running at time 75, the pool returns that nothing can be evicted until time 150.
+    assertThat(pool.cleanup(75L)).isEqualTo(75L);
+    assertThat(pool.connectionCount()).isEqualTo(2);
+
+    // Running at time 149, the pool returns that nothing can be evicted until time 150.
+    assertThat(pool.cleanup(149L)).isEqualTo(1L);
+    assertThat(pool.connectionCount()).isEqualTo(2);
+
+    // Running at time 150, the pool evicts c2.
+    assertThat(pool.cleanup(150L)).isEqualTo(0L);
+    assertThat(pool.connectionCount()).isEqualTo(1);
+    assertThat(c1.socket().isClosed()).isFalse();
+    assertThat(c2.socket().isClosed()).isTrue();
+
+    // Running at time 150, the pool returns that nothing can be evicted until time 175.
+    assertThat(pool.cleanup(150L)).isEqualTo(25L);
+    assertThat(pool.connectionCount()).isEqualTo(1);
+
+    // Running at time 175, the pool evicts c1.
+    assertThat(pool.cleanup(175L)).isEqualTo(0L);
+    assertThat(pool.connectionCount()).isEqualTo(0);
+    assertThat(c1.socket().isClosed()).isTrue();
+    assertThat(c2.socket().isClosed()).isTrue();
+  }
+
+  @Test public void oldestConnectionsEvictedIfIdleLimitExceeded() throws Exception {
+    RealConnectionPool pool = new RealConnectionPool(2, 100L, TimeUnit.NANOSECONDS);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 50L);
+    RealConnection c2 = newConnection(pool, routeB1, 75L);
+
+    // With 2 connections, there's no need to evict until the connections time out.
+    assertThat(pool.cleanup(100L)).isEqualTo(50L);
+    assertThat(pool.connectionCount()).isEqualTo(2);
+    assertThat(c1.socket().isClosed()).isFalse();
+    assertThat(c2.socket().isClosed()).isFalse();
+
+    // Add a third connection
+    RealConnection c3 = newConnection(pool, routeC1, 75L);
+
+    // The third connection bounces the first.
+    assertThat(pool.cleanup(100L)).isEqualTo(0L);
+    assertThat(pool.connectionCount()).isEqualTo(2);
+    assertThat(c1.socket().isClosed()).isTrue();
+    assertThat(c2.socket().isClosed()).isFalse();
+    assertThat(c3.socket().isClosed()).isFalse();
+  }
+
+  @Test public void leakedAllocation() throws Exception {
+    ConnectionPool poolApi = new ConnectionPool(Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
+    RealConnectionPool pool = Internal.instance.realConnectionPool(poolApi);
+    pool.cleanupRunning = true; // Prevent the cleanup runnable from being started.
+
+    RealConnection c1 = newConnection(pool, routeA1, 0L);
+    allocateAndLeakAllocation(poolApi, c1);
+
+    awaitGarbageCollection();
+    assertThat(pool.cleanup(100L)).isEqualTo(0L);
+    assertThat(c1.transmitters).isEmpty();
+
+    // Can't allocate once a leak has been detected.
+    assertThat(c1.noNewExchanges).isTrue();
+  }
+
+  /** Use a helper method so there's no hidden reference remaining on the stack. */
+  private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
+    synchronized (Internal.instance.realConnectionPool(pool)) {
+      OkHttpClient client = new OkHttpClient.Builder()
+          .connectionPool(pool)
+          .build();
+      Call call = client.newCall(newRequest(connection.route().address()));
+      Transmitter transmitter = new Transmitter(client, call);
+      transmitter.prepareToConnect(call.request());
+      transmitter.acquireConnectionNoEvents(connection);
+    }
+  }
+
+  private RealConnection newConnection(RealConnectionPool pool, Route route, long idleAtNanos) {
+    RealConnection result = RealConnection.testConnection(pool, route, new Socket(), idleAtNanos);
+    synchronized (pool) {
+      pool.put(result);
+    }
+    return result;
+  }
+
+  private Address newAddress(String name) {
+    return new Address(name, 1, Dns.SYSTEM, SocketFactory.getDefault(), null, null, null,
+        new RecordingOkAuthenticator("password", null), null, Collections.emptyList(),
+        Collections.emptyList(), ProxySelector.getDefault());
+  }
+
+  private Route newRoute(Address address) {
+    return new Route(address, Proxy.NO_PROXY,
+        InetSocketAddress.createUnresolved(address.url().host(), address.url().port()));
+  }
+
+  private Request newRequest(Address address) {
+    return new Request.Builder()
+        .url(address.url())
+        .build();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
similarity index 77%
rename from okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
rename to okhttp/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
index 7dcbb7467e..625e882b1c 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
@@ -18,19 +18,17 @@
 import java.io.IOException;
 import java.security.cert.CertificateException;
 import java.util.Arrays;
-import java.util.LinkedHashSet;
-import java.util.Set;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocket;
 import okhttp3.ConnectionSpec;
 import okhttp3.TlsVersion;
 import okhttp3.internal.Internal;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static java.util.Arrays.asList;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class ConnectionSpecSelectorTest {
   static {
@@ -40,7 +38,7 @@
   public static final SSLHandshakeException RETRYABLE_EXCEPTION = new SSLHandshakeException(
       "Simulated handshake exception");
 
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
 
   @Test
   public void nonRetryableIOException() throws Exception {
@@ -51,7 +49,7 @@ public void nonRetryableIOException() throws Exception {
 
     boolean retry = connectionSpecSelector.connectionFailed(
         new IOException("Non-handshake exception"));
-    assertFalse(retry);
+    assertThat(retry).isFalse();
     socket.close();
   }
 
@@ -66,7 +64,7 @@ public void nonRetryableSSLHandshakeException() throws Exception {
         new SSLHandshakeException("Certificate handshake exception");
     trustIssueException.initCause(new CertificateException());
     boolean retry = connectionSpecSelector.connectionFailed(trustIssueException);
-    assertFalse(retry);
+    assertThat(retry).isFalse();
     socket.close();
   }
 
@@ -74,42 +72,44 @@ public void nonRetryableSSLHandshakeException() throws Exception {
   public void retryableSSLHandshakeException() throws Exception {
     ConnectionSpecSelector connectionSpecSelector =
         createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
-    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    SSLSocket socket = createSocketWithEnabledProtocols(
+        TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
     connectionSpecSelector.configureSecureSocket(socket);
 
     boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
-    assertTrue(retry);
+    assertThat(retry).isTrue();
     socket.close();
   }
 
   @Test
   public void someFallbacksSupported() throws Exception {
-    ConnectionSpec sslV3 =
-        new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-            .tlsVersions(TlsVersion.SSL_3_0)
-            .build();
+    ConnectionSpec sslV3 = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .tlsVersions(TlsVersion.SSL_3_0)
+        .build();
 
     ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(
         ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3);
 
-    TlsVersion[] enabledSocketTlsVersions = {TlsVersion.TLS_1_1, TlsVersion.TLS_1_0};
+    TlsVersion[] enabledSocketTlsVersions = {
+        TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0
+    };
     SSLSocket socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
 
     // MODERN_TLS is used here.
     connectionSpecSelector.configureSecureSocket(socket);
-    assertEnabledProtocols(socket, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_2);
 
     boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
-    assertTrue(retry);
+    assertThat(retry).isTrue();
     socket.close();
 
     // COMPATIBLE_TLS is used here.
     socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
     connectionSpecSelector.configureSecureSocket(socket);
-    assertEnabledProtocols(socket, TlsVersion.TLS_1_0);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
 
     retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
-    assertFalse(retry);
+    assertThat(retry).isFalse();
     socket.close();
 
     // sslV3 is not used because SSLv3 is not enabled on the socket.
@@ -117,19 +117,17 @@ public void someFallbacksSupported() throws Exception {
 
   private static ConnectionSpecSelector createConnectionSpecSelector(
       ConnectionSpec... connectionSpecs) {
-    return new ConnectionSpecSelector(Arrays.asList(connectionSpecs));
+    return new ConnectionSpecSelector(asList(connectionSpecs));
   }
 
   private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) throws IOException {
-    SSLSocket socket = (SSLSocket) sslClient.socketFactory.createSocket();
+    SSLSocket socket = (SSLSocket) handshakeCertificates.sslSocketFactory().createSocket();
     socket.setEnabledProtocols(javaNames(tlsVersions));
     return socket;
   }
 
   private static void assertEnabledProtocols(SSLSocket socket, TlsVersion... required) {
-    Set<String> actual = new LinkedHashSet<>(Arrays.asList(socket.getEnabledProtocols()));
-    Set<String> expected = new LinkedHashSet<>(Arrays.asList(javaNames(required)));
-    assertEquals(expected, actual);
+    assertThat(socket.getEnabledProtocols()).containsExactlyInAnyOrder(javaNames(required));
   }
 
   private static String[] javaNames(TlsVersion... tlsVersions) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java b/okhttp/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
similarity index 65%
rename from okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
rename to okhttp/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
index 209d79d5c5..bce264a618 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
@@ -18,14 +18,15 @@
 import java.io.IOException;
 import org.junit.Test;
 
-import static org.junit.Assert.assertSame;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class RouteExceptionTest {
 
   @Test public void getConnectionIOException_single() {
     IOException firstException = new IOException();
     RouteException re = new RouteException(firstException);
-    assertSame(firstException, re.getLastConnectException());
+    assertThat(re.getFirstConnectException()).isSameAs(firstException);
+    assertThat(re.getLastConnectException()).isSameAs(firstException);
   }
 
   @Test public void getConnectionIOException_multiple() {
@@ -36,12 +37,13 @@
     re.addConnectException(secondException);
     re.addConnectException(thirdException);
 
-    IOException connectionIOException = re.getLastConnectException();
-    assertSame(thirdException, connectionIOException);
-    Throwable[] thirdSuppressedExceptions = thirdException.getSuppressed();
-    assertSame(secondException, thirdSuppressedExceptions[0]);
+    IOException connectionIOException = re.getFirstConnectException();
+    assertThat(connectionIOException).isSameAs(firstException);
+    Throwable[] suppressedExceptions = connectionIOException.getSuppressed();
+    assertThat(suppressedExceptions.length).isEqualTo(2);
+    assertThat(suppressedExceptions[0]).isSameAs(secondException);
+    assertThat(suppressedExceptions[1]).isSameAs(thirdException);
 
-    Throwable[] secondSuppressedException = secondException.getSuppressed();
-    assertSame(firstException, secondSuppressedException[0]);
+    assertThat(re.getLastConnectException()).isSameAs(thirdException);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java b/okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
similarity index 78%
rename from okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
rename to okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
index 26fbe3f031..ead073c6f6 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
@@ -32,22 +32,23 @@
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Address;
 import okhttp3.Authenticator;
+import okhttp3.Call;
 import okhttp3.ConnectionSpec;
 import okhttp3.EventListener;
 import okhttp3.FakeDns;
 import okhttp3.Protocol;
+import okhttp3.Request;
 import okhttp3.Route;
+import okhttp3.TestUtil;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.RecordingProxySelector;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Before;
 import org.junit.Test;
 
 import static java.net.Proxy.NO_PROXY;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class RouteSelectorTest {
@@ -67,9 +68,10 @@
   private String uriHost = "hosta";
   private int uriPort = 1003;
 
+  private Call call;
   private SocketFactory socketFactory;
-  private final SslClient sslClient = SslClient.localhost();
-  private final SSLSocketFactory sslSocketFactory = sslClient.socketFactory;
+  private final HandshakeCertificates handshakeCertificates = localhost();
+  private final SSLSocketFactory sslSocketFactory = handshakeCertificates.sslSocketFactory();
   private HostnameVerifier hostnameVerifier;
 
   private final Authenticator authenticator = Authenticator.NONE;
@@ -79,28 +81,31 @@
   private RouteDatabase routeDatabase = new RouteDatabase();
 
   @Before public void setUp() throws Exception {
+    call = TestUtil.defaultClient().newCall(new Request.Builder()
+        .url("https://" + uriHost + ":" + uriPort + "/")
+        .build());
     socketFactory = SocketFactory.getDefault();
     hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
   }
 
   @Test public void singleRoute() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(uriHost, dns.allocate(1));
     RouteSelector.Selection selection = routeSelector.next();
     assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
-    assertFalse(selection.hasNext());
+    assertThat(selection.hasNext()).isFalse();
     try {
       selection.next();
       fail();
     } catch (NoSuchElementException expected) {
     }
 
-    assertFalse(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isFalse();
     try {
       routeSelector.next();
       fail();
@@ -110,18 +115,18 @@
 
   @Test public void singleRouteReturnsFailedRoute() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(uriHost, dns.allocate(1));
     RouteSelector.Selection selection = routeSelector.next();
     Route route = selection.next();
     routeDatabase.failed(route);
-    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
+    routeSelector = new RouteSelector(address, routeDatabase, call, EventListener.NONE);
     selection = routeSelector.next();
     assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    assertFalse(selection.hasNext());
+    assertThat(selection.hasNext()).isFalse();
 
     try {
       selection.next();
@@ -129,7 +134,7 @@
     } catch (NoSuchElementException expected) {
     }
 
-    assertFalse(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isFalse();
     try {
       routeSelector.next();
       fail();
@@ -140,17 +145,17 @@
   @Test public void explicitProxyTriesThatProxysAddressesOnly() throws Exception {
     Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
         authenticator, proxyA, protocols, connectionSpecs, proxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(proxyAHost, dns.allocate(2));
     RouteSelector.Selection selection = routeSelector.next();
     assertRoute(selection.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     assertRoute(selection.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
 
-    assertFalse(selection.hasNext());
-    assertFalse(routeSelector.hasNext());
+    assertThat(selection.hasNext()).isFalse();
+    assertThat(routeSelector.hasNext()).isFalse();
     dns.assertRequests(proxyAHost);
     proxySelector.assertRequests(); // No proxy selector requests!
   }
@@ -158,17 +163,17 @@
   @Test public void explicitDirectProxy() throws Exception {
     Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
         authenticator, NO_PROXY, protocols, connectionSpecs, proxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(uriHost, dns.allocate(2));
     RouteSelector.Selection selection = routeSelector.next();
     assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
 
-    assertFalse(selection.hasNext());
-    assertFalse(routeSelector.hasNext());
+    assertThat(selection.hasNext()).isFalse();
+    assertThat(routeSelector.hasNext()).isFalse();
     dns.assertRequests(uriHost);
     proxySelector.assertRequests(); // No proxy selector requests!
   }
@@ -176,7 +181,7 @@
   @Test public void proxySelectorReturnsNull() throws Exception {
     ProxySelector nullProxySelector = new ProxySelector() {
       @Override public List<Proxy> select(URI uri) {
-        assertEquals(uriHost, uri.getHost());
+        assertThat(uri.getHost()).isEqualTo(uriHost);
         return null;
       }
 
@@ -188,31 +193,31 @@
 
     Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, nullProxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(uriHost, dns.allocate(1));
     RouteSelector.Selection selection = routeSelector.next();
     assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
 
-    assertFalse(selection.hasNext());
-    assertFalse(routeSelector.hasNext());
+    assertThat(selection.hasNext()).isFalse();
+    assertThat(routeSelector.hasNext()).isFalse();
   }
 
   @Test public void proxySelectorReturnsNoProxies() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(uriHost, dns.allocate(2));
     RouteSelector.Selection selection = routeSelector.next();
     assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
 
-    assertFalse(selection.hasNext());
-    assertFalse(routeSelector.hasNext());
+    assertThat(selection.hasNext()).isFalse();
+    assertThat(routeSelector.hasNext()).isFalse();
     dns.assertRequests(uriHost);
     proxySelector.assertRequests(address.url().uri());
   }
@@ -222,48 +227,48 @@
 
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
     proxySelector.assertRequests(address.url().uri());
 
     // First try the IP addresses of the first proxy, in sequence.
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(proxyAHost, dns.allocate(2));
     RouteSelector.Selection selection1 = routeSelector.next();
     assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
     dns.assertRequests(proxyAHost);
-    assertFalse(selection1.hasNext());
+    assertThat(selection1.hasNext()).isFalse();
 
     // Next try the IP address of the second proxy.
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(proxyBHost, dns.allocate(1));
     RouteSelector.Selection selection2 = routeSelector.next();
     assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
     dns.assertRequests(proxyBHost);
-    assertFalse(selection2.hasNext());
+    assertThat(selection2.hasNext()).isFalse();
 
     // No more proxies to try.
-    assertFalse(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isFalse();
   }
 
   @Test public void proxySelectorDirectConnectionsAreSkipped() throws Exception {
     Address address = httpAddress();
 
     proxySelector.proxies.add(NO_PROXY);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
     proxySelector.assertRequests(address.url().uri());
 
     // Only the origin server will be attempted.
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(uriHost, dns.allocate(1));
     RouteSelector.Selection selection = routeSelector.next();
     assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
 
-    assertFalse(selection.hasNext());
-    assertFalse(routeSelector.hasNext());
+    assertThat(selection.hasNext()).isFalse();
+    assertThat(routeSelector.hasNext()).isFalse();
   }
 
   @Test public void proxyDnsFailureContinuesToNextProxy() throws Exception {
@@ -272,18 +277,18 @@
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
     proxySelector.proxies.add(proxyA);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
     proxySelector.assertRequests(address.url().uri());
 
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(proxyAHost, dns.allocate(1));
     RouteSelector.Selection selection1 = routeSelector.next();
     assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
-    assertFalse(selection1.hasNext());
+    assertThat(selection1.hasNext()).isFalse();
 
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.clear(proxyBHost);
     try {
       routeSelector.next();
@@ -292,21 +297,21 @@
     }
     dns.assertRequests(proxyBHost);
 
-    assertTrue(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isTrue();
     dns.set(proxyAHost, dns.allocate(1));
     RouteSelector.Selection selection2 = routeSelector.next();
     assertRoute(selection2.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
 
-    assertFalse(selection2.hasNext());
-    assertFalse(routeSelector.hasNext());
+    assertThat(selection2.hasNext()).isFalse();
+    assertThat(routeSelector.hasNext()).isFalse();
   }
 
   @Test public void multipleProxiesMultipleInetAddressesMultipleConfigurations() throws Exception {
     Address address = httpsAddress();
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
     // Proxy A
@@ -315,7 +320,7 @@
     assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
     assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
-    assertFalse(selection1.hasNext());
+    assertThat(selection1.hasNext()).isFalse();
 
     // Proxy B
     dns.set(proxyBHost, dns.allocate(2));
@@ -323,15 +328,15 @@
     assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
     dns.assertRequests(proxyBHost);
     assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 1), proxyBPort);
-    assertFalse(selection2.hasNext());
+    assertThat(selection2.hasNext()).isFalse();
 
     // No more proxies to attempt.
-    assertFalse(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isFalse();
   }
 
   @Test public void failedRouteWithSingleProxy() throws Exception {
     Address address = httpsAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
     final int numberOfAddresses = 2;
@@ -342,30 +347,30 @@
     List<Route> regularRoutes = selection1.getAll();
 
     // Check that we do indeed have more than one route.
-    assertEquals(numberOfAddresses, regularRoutes.size());
+    assertThat(regularRoutes.size()).isEqualTo(numberOfAddresses);
     // Add first regular route as failed.
     routeDatabase.failed(regularRoutes.get(0));
     // Reset selector
-    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
+    routeSelector = new RouteSelector(address, routeDatabase, call, EventListener.NONE);
 
     // The first selection prioritizes the non-failed routes.
     RouteSelector.Selection selection2 = routeSelector.next();
-    assertEquals(regularRoutes.get(1), selection2.next());
-    assertFalse(selection2.hasNext());
+    assertThat(selection2.next()).isEqualTo(regularRoutes.get(1));
+    assertThat(selection2.hasNext()).isFalse();
 
     // The second selection will contain all failed routes.
     RouteSelector.Selection selection3 = routeSelector.next();
-    assertEquals(regularRoutes.get(0), selection3.next());
-    assertFalse(selection3.hasNext());
+    assertThat(selection3.next()).isEqualTo(regularRoutes.get(0));
+    assertThat(selection3.hasNext()).isFalse();
 
-    assertFalse(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isFalse();
   }
 
   @Test public void failedRouteWithMultipleProxies() throws IOException {
     Address address = httpsAddress();
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
     dns.set(proxyAHost, dns.allocate(1));
@@ -378,26 +383,26 @@
     assertRoute(route, address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     routeDatabase.failed(route);
 
-    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
+    routeSelector = new RouteSelector(address, routeDatabase, call, EventListener.NONE);
 
     // Confirm we enumerate both proxies, giving preference to the route from ProxyB.
     RouteSelector.Selection selection2 = routeSelector.next();
     dns.assertRequests(proxyAHost, proxyBHost);
     assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
-    assertFalse(selection2.hasNext());
+    assertThat(selection2.hasNext()).isFalse();
 
     // Confirm the last selection contains the postponed route from ProxyA.
     RouteSelector.Selection selection3 = routeSelector.next();
     dns.assertRequests();
     assertRoute(selection3.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    assertFalse(selection3.hasNext());
+    assertThat(selection3.hasNext()).isFalse();
 
-    assertFalse(routeSelector.hasNext());
+    assertThat(routeSelector.hasNext()).isFalse();
   }
 
   @Test public void queryForAllSelectedRoutes() throws IOException {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
         EventListener.NONE);
 
     dns.set(uriHost, dns.allocate(2));
@@ -408,42 +413,42 @@
     assertRoute(routes.get(0), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     assertRoute(routes.get(1), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
 
-    assertSame(routes.get(0), selection.next());
-    assertSame(routes.get(1), selection.next());
-    assertFalse(selection.hasNext());
-    assertFalse(routeSelector.hasNext());
+    assertThat(selection.next()).isSameAs(routes.get(0));
+    assertThat(selection.next()).isSameAs(routes.get(1));
+    assertThat(selection.hasNext()).isFalse();
+    assertThat(routeSelector.hasNext()).isFalse();
   }
 
   @Test public void getHostString() throws Exception {
     // Name proxy specification.
     InetSocketAddress socketAddress = InetSocketAddress.createUnresolved("host", 1234);
-    assertEquals("host", RouteSelector.getHostString(socketAddress));
+    assertThat(RouteSelector.getHostString(socketAddress)).isEqualTo("host");
     socketAddress = InetSocketAddress.createUnresolved("127.0.0.1", 1234);
-    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+    assertThat(RouteSelector.getHostString(socketAddress)).isEqualTo("127.0.0.1");
 
     // InetAddress proxy specification.
     socketAddress = new InetSocketAddress(InetAddress.getByName("localhost"), 1234);
-    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+    assertThat(RouteSelector.getHostString(socketAddress)).isEqualTo("127.0.0.1");
     socketAddress = new InetSocketAddress(
         InetAddress.getByAddress(new byte[] {127, 0, 0, 1}), 1234);
-    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+    assertThat(RouteSelector.getHostString(socketAddress)).isEqualTo("127.0.0.1");
     socketAddress = new InetSocketAddress(
         InetAddress.getByAddress("foobar", new byte[] {127, 0, 0, 1}), 1234);
-    assertEquals("127.0.0.1", RouteSelector.getHostString(socketAddress));
+    assertThat(RouteSelector.getHostString(socketAddress)).isEqualTo("127.0.0.1");
   }
 
   @Test public void routeToString() throws Exception {
     Route route = new Route(httpAddress(), Proxy.NO_PROXY,
         InetSocketAddress.createUnresolved("host", 1234));
-    assertEquals("Route{host:1234}", route.toString());
+    assertThat(route.toString()).isEqualTo("Route{host:1234}");
   }
 
   private void assertRoute(Route route, Address address, Proxy proxy, InetAddress socketAddress,
       int socketPort) {
-    assertEquals(address, route.address());
-    assertEquals(proxy, route.proxy());
-    assertEquals(socketAddress, route.socketAddress().getAddress());
-    assertEquals(socketPort, route.socketAddress().getPort());
+    assertThat(route.address()).isEqualTo(address);
+    assertThat(route.proxy()).isEqualTo(proxy);
+    assertThat(route.socketAddress().getAddress()).isEqualTo(socketAddress);
+    assertThat(route.socketAddress().getPort()).isEqualTo(socketPort);
   }
 
   /** Returns an address that's without an SSL socket factory or hostname verifier. */
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java b/okhttp/src/test/java/okhttp3/internal/http/CancelTest.java
similarity index 61%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
rename to okhttp/src/test/java/okhttp3/internal/http/CancelTest.java
index aad2bfc8dd..6f11d320b7 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/DisconnectTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http/CancelTest.java
@@ -17,27 +17,33 @@
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.HttpURLConnection;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import javax.net.ServerSocketFactory;
 import javax.net.SocketFactory;
+import okhttp3.Call;
 import okhttp3.DelegatingServerSocketFactory;
 import okhttp3.DelegatingSocketFactory;
+import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
+import okhttp3.OkHttpClientTestRule;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okio.Buffer;
+import okio.BufferedSink;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 
-import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.fail;
 
-public final class DisconnectTest {
+public final class CancelTest {
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   // The size of the socket buffers in bytes.
   private static final int SOCKET_BUFFER_SIZE = 256 * 1024;
@@ -57,7 +63,7 @@
             return serverSocket;
           }
         });
-    client = defaultClient().newBuilder()
+    client = clientTestRule.client.newBuilder()
         .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
           @Override protected Socket configureSocket(Socket socket) throws IOException {
             socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
@@ -68,44 +74,51 @@
         .build();
   }
 
-  @Test public void interruptWritingRequestBody() throws Exception {
-    int requestBodySize = 2 * 1024 * 1024; // 2 MiB
-
-    server.enqueue(new MockResponse()
-        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
+  @Test public void cancelWritingRequestBody() throws Exception {
+    server.enqueue(new MockResponse());
     server.start();
 
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
-    disconnectLater(connection, 500);
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new RequestBody() {
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
+
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            for (int i = 0; i < 10; i++) {
+              sink.writeByte(0);
+              sink.flush();
+              sleep(100);
+            }
+            fail("Expected connection to be closed");
+          }
+        })
+        .build());
 
-    connection.setDoOutput(true);
-    connection.setFixedLengthStreamingMode(requestBodySize);
-    OutputStream requestBody = connection.getOutputStream();
-    byte[] buffer = new byte[1024];
+    cancelLater(call, 500);
     try {
-      for (int i = 0; i < requestBodySize; i += buffer.length) {
-        requestBody.write(buffer);
-        requestBody.flush();
-      }
-      fail("Expected connection to be closed");
+      call.execute();
+      fail();
     } catch (IOException expected) {
     }
-
-    connection.disconnect();
   }
 
-  @Test public void interruptReadingResponseBody() throws Exception {
-    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
+  @Test public void cancelReadingResponseBody() throws Exception {
+    int responseBodySize = 8 * 1024 * 1024; // 8 MiB.
 
     server.enqueue(new MockResponse()
         .setBody(new Buffer().write(new byte[responseBodySize]))
         .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
     server.start();
 
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
-    disconnectLater(connection, 500);
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
 
-    InputStream responseBody = connection.getInputStream();
+    Response response = call.execute();
+    cancelLater(call, 500);
+    InputStream responseBody = response.body().byteStream();
     byte[] buffer = new byte[1024];
     try {
       while (responseBody.read(buffer) != -1) {
@@ -117,17 +130,19 @@
     responseBody.close();
   }
 
-  private void disconnectLater(final HttpURLConnection connection, final int delayMillis) {
-    Thread interruptingCow = new Thread() {
-      @Override public void run() {
-        try {
-          sleep(delayMillis);
-          connection.disconnect();
-        } catch (InterruptedException e) {
-          throw new RuntimeException(e);
-        }
-      }
-    };
+  private void sleep(int delayMillis) {
+    try {
+      Thread.sleep(delayMillis);
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+    }
+  }
+
+  private void cancelLater(Call call, int delayMillis) {
+    Thread interruptingCow = new Thread(() -> {
+      sleep(delayMillis);
+      call.cancel();
+    });
     interruptingCow.start();
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java b/okhttp/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
rename to okhttp/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java b/okhttp/src/test/java/okhttp3/internal/http/HttpDateTest.java
similarity index 51%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
rename to okhttp/src/test/java/okhttp3/internal/http/HttpDateTest.java
index 0a22eb0f8a..3d9860da64 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/HttpDateTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http/HttpDateTest.java
@@ -21,8 +21,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class HttpDateTest {
 
@@ -43,48 +42,51 @@ public void tearDown() throws Exception {
 
   @Test public void parseStandardFormats() throws Exception {
     // RFC 822, updated by RFC 1123 with GMT.
-    assertEquals(0L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT").getTime());
-    assertEquals(1402057830000L, HttpDate.parse("Fri, 06 Jun 2014 12:30:30 GMT").getTime());
+    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT").getTime()).isEqualTo(0L);
+    assertThat(HttpDate.parse("Fri, 06 Jun 2014 12:30:30 GMT").getTime()).isEqualTo(1402057830000L);
 
     // RFC 850, obsoleted by RFC 1036 with GMT.
-    assertEquals(0L, HttpDate.parse("Thursday, 01-Jan-70 00:00:00 GMT").getTime());
-    assertEquals(1402057830000L, HttpDate.parse("Friday, 06-Jun-14 12:30:30 GMT").getTime());
+    assertThat(HttpDate.parse("Thursday, 01-Jan-70 00:00:00 GMT").getTime()).isEqualTo(0L);
+    assertThat(HttpDate.parse("Friday, 06-Jun-14 12:30:30 GMT").getTime()).isEqualTo(1402057830000L);
 
     // ANSI C's asctime(): should use GMT, not platform default.
-    assertEquals(0L, HttpDate.parse("Thu Jan 1 00:00:00 1970").getTime());
-    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014").getTime());
+    assertThat(HttpDate.parse("Thu Jan 1 00:00:00 1970").getTime()).isEqualTo(0L);
+    assertThat(HttpDate.parse("Fri Jun 6 12:30:30 2014").getTime()).isEqualTo(1402057830000L);
   }
 
   @Test public void format() throws Exception {
-    assertEquals("Thu, 01 Jan 1970 00:00:00 GMT", HttpDate.format(new Date(0)));
-    assertEquals("Fri, 06 Jun 2014 12:30:30 GMT", HttpDate.format(new Date(1402057830000L)));
+    assertThat(HttpDate.format(new Date(0))).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT");
+    assertThat(HttpDate.format(new Date(1402057830000L))).isEqualTo(
+        "Fri, 06 Jun 2014 12:30:30 GMT");
   }
 
   @Test public void parseNonStandardStrings() throws Exception {
     // RFC 822, updated by RFC 1123 with any TZ
-    assertEquals(3600000L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT-01:00").getTime());
-    assertEquals(28800000L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 PST").getTime());
+    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT-01:00").getTime()).isEqualTo(3600000L);
+    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00 PST").getTime()).isEqualTo(28800000L);
     // Ignore trailing junk
-    assertEquals(0L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT JUNK").getTime());
+    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT JUNK").getTime()).isEqualTo(0L);
     // Missing timezones treated as bad.
-    assertNull(HttpDate.parse("Thu, 01 Jan 1970 00:00:00"));
+    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00:00")).isNull();
     // Missing seconds treated as bad.
-    assertNull(HttpDate.parse("Thu, 01 Jan 1970 00:00 GMT"));
+    assertThat(HttpDate.parse("Thu, 01 Jan 1970 00:00 GMT")).isNull();
     // Extra spaces treated as bad.
-    assertNull(HttpDate.parse("Thu,  01 Jan 1970 00:00 GMT"));
+    assertThat(HttpDate.parse("Thu,  01 Jan 1970 00:00 GMT")).isNull();
     // Missing leading zero treated as bad.
-    assertNull(HttpDate.parse("Thu, 1 Jan 1970 00:00 GMT"));
+    assertThat(HttpDate.parse("Thu, 1 Jan 1970 00:00 GMT")).isNull();
 
     // RFC 850, obsoleted by RFC 1036 with any TZ.
-    assertEquals(3600000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 GMT-01:00").getTime());
-    assertEquals(28800000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST").getTime());
+    assertThat(HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 GMT-01:00").getTime()).isEqualTo(
+        3600000L);
+    assertThat(HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST").getTime()).isEqualTo(28800000L);
     // Ignore trailing junk
-    assertEquals(28800000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST JUNK").getTime());
+    assertThat(HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST JUNK").getTime()).isEqualTo(
+        28800000L);
 
     // ANSI C's asctime() format
     // This format ignores the timezone entirely even if it is present and uses GMT.
-    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014 PST").getTime());
+    assertThat(HttpDate.parse("Fri Jun 6 12:30:30 2014 PST").getTime()).isEqualTo(1402057830000L);
     // Ignore trailing junk.
-    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014 JUNK").getTime());
+    assertThat(HttpDate.parse("Fri Jun 6 12:30:30 2014 JUNK").getTime()).isEqualTo(1402057830000L);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java b/okhttp/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
similarity index 93%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
rename to okhttp/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
index fb37e7e491..f7b2d58918 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
+++ b/okhttp/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
@@ -26,7 +26,7 @@
 import java.util.List;
 import okhttp3.internal.Util;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class RecordingProxySelector extends ProxySelector {
   public final List<Proxy> proxies = new ArrayList<>();
@@ -39,7 +39,7 @@
   }
 
   public void assertRequests(URI... expectedUris) {
-    assertEquals(Arrays.asList(expectedUris), requestedUris);
+    assertThat(requestedUris).containsExactly(expectedUris);
     requestedUris.clear();
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java b/okhttp/src/test/java/okhttp3/internal/http/StatusLineTest.java
similarity index 81%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
rename to okhttp/src/test/java/okhttp3/internal/http/StatusLineTest.java
index 6eb1aa8b12..08e002de7e 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/StatusLineTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http/StatusLineTest.java
@@ -20,7 +20,7 @@
 import okhttp3.Protocol;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class StatusLineTest {
@@ -29,18 +29,18 @@
     int version = 1;
     int code = 200;
     StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code + " " + message);
-    assertEquals(message, statusLine.message);
-    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
-    assertEquals(code, statusLine.code);
+    assertThat(statusLine.message).isEqualTo(message);
+    assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_1);
+    assertThat(statusLine.code).isEqualTo(code);
   }
 
   @Test public void emptyMessage() throws IOException {
     int version = 1;
     int code = 503;
     StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code + " ");
-    assertEquals("", statusLine.message);
-    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
-    assertEquals(code, statusLine.code);
+    assertThat(statusLine.message).isEqualTo("");
+    assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_1);
+    assertThat(statusLine.code).isEqualTo(code);
   }
 
   /**
@@ -51,17 +51,17 @@
     int version = 1;
     int code = 503;
     StatusLine statusLine = StatusLine.parse("HTTP/1." + version + " " + code);
-    assertEquals("", statusLine.message);
-    assertEquals(Protocol.HTTP_1_1, statusLine.protocol);
-    assertEquals(code, statusLine.code);
+    assertThat(statusLine.message).isEqualTo("");
+    assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_1);
+    assertThat(statusLine.code).isEqualTo(code);
   }
 
   // https://github.com/square/okhttp/issues/386
   @Test public void shoutcast() throws IOException {
     StatusLine statusLine = StatusLine.parse("ICY 200 OK");
-    assertEquals("OK", statusLine.message);
-    assertEquals(Protocol.HTTP_1_0, statusLine.protocol);
-    assertEquals(200, statusLine.code);
+    assertThat(statusLine.message).isEqualTo("OK");
+    assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_0);
+    assertThat(statusLine.code).isEqualTo(200);
   }
 
   @Test public void missingProtocol() throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java b/okhttp/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
similarity index 60%
rename from okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
rename to okhttp/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
index 9ac3b93ecc..86364052f6 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
@@ -17,34 +17,40 @@
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.InterruptedIOException;
-import java.io.OutputStream;
-import java.net.HttpURLConnection;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import javax.net.ServerSocketFactory;
 import javax.net.SocketFactory;
+import okhttp3.Call;
 import okhttp3.DelegatingServerSocketFactory;
 import okhttp3.DelegatingSocketFactory;
+import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
-import okhttp3.OkUrlFactory;
+import okhttp3.OkHttpClientTestRule;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okio.Buffer;
+import okio.BufferedSink;
+import org.junit.After;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 
-import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.fail;
 
 public final class ThreadInterruptTest {
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
 
   // The size of the socket buffers in bytes.
   private static final int SOCKET_BUFFER_SIZE = 256 * 1024;
 
   private MockWebServer server;
-  private OkHttpClient client;
+  private OkHttpClient client = clientTestRule.client;
 
   @Before public void setUp() throws Exception {
     // Sockets on some platforms can have large buffers that mean writes do not block when
@@ -59,7 +65,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
             return serverSocket;
           }
         });
-    client = defaultClient().newBuilder()
+    client = clientTestRule.client.newBuilder()
         .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
           @Override
           protected Socket configureSocket(Socket socket) throws IOException {
@@ -71,67 +77,80 @@ protected Socket configureSocket(Socket socket) throws IOException {
         .build();
   }
 
-  @Test public void interruptWritingRequestBody() throws Exception {
-    int requestBodySize = 2 * 1024 * 1024; // 2 MiB
+  @After public void tearDown() throws Exception {
+    Thread.interrupted(); // Clear interrupted state.
+  }
 
-    server.enqueue(new MockResponse()
-        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
+  @Test public void interruptWritingRequestBody() throws Exception {
+    server.enqueue(new MockResponse());
     server.start();
 
-    interruptLater(500);
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(new RequestBody() {
+          @Override public @Nullable MediaType contentType() {
+            return null;
+          }
 
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
-    connection.setDoOutput(true);
-    connection.setFixedLengthStreamingMode(requestBodySize);
-    OutputStream requestBody = connection.getOutputStream();
-    byte[] buffer = new byte[1024];
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            for (int i = 0; i < 10; i++) {
+              sink.writeByte(0);
+              sink.flush();
+              sleep(100);
+            }
+            fail("Expected connection to be closed");
+          }
+        })
+        .build());
+
+    interruptLater(500);
     try {
-      for (int i = 0; i < requestBodySize; i += buffer.length) {
-        requestBody.write(buffer);
-        requestBody.flush();
-      }
-      fail("Expected thread to be interrupted");
-    } catch (InterruptedIOException expected) {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
     }
-
-    connection.disconnect();
   }
 
   @Test public void interruptReadingResponseBody() throws Exception {
-    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
+    int responseBodySize = 8 * 1024 * 1024; // 8 MiB.
 
     server.enqueue(new MockResponse()
         .setBody(new Buffer().write(new byte[responseBodySize]))
         .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
     server.start();
 
-    interruptLater(500);
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
 
-    HttpURLConnection connection = new OkUrlFactory(client).open(server.url("/").url());
-    InputStream responseBody = connection.getInputStream();
+    Response response = call.execute();
+    interruptLater(500);
+    InputStream responseBody = response.body().byteStream();
     byte[] buffer = new byte[1024];
     try {
       while (responseBody.read(buffer) != -1) {
       }
-      fail("Expected thread to be interrupted");
-    } catch (InterruptedIOException expected) {
+      fail("Expected connection to be interrupted");
+    } catch (IOException expected) {
     }
 
     responseBody.close();
   }
 
-  private void interruptLater(final int delayMillis) {
-    final Thread toInterrupt = Thread.currentThread();
-    Thread interruptingCow = new Thread() {
-      @Override public void run() {
-        try {
-          sleep(delayMillis);
-          toInterrupt.interrupt();
-        } catch (InterruptedException e) {
-          throw new RuntimeException(e);
-        }
-      }
-    };
+  private void sleep(int delayMillis) {
+    try {
+      Thread.sleep(delayMillis);
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+    }
+  }
+
+  private void interruptLater(int delayMillis) {
+    Thread toInterrupt = Thread.currentThread();
+    Thread interruptingCow = new Thread(() -> {
+      sleep(delayMillis);
+      toInterrupt.interrupt();
+    });
     interruptingCow.start();
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java b/okhttp/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
rename to okhttp/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java b/okhttp/src/test/java/okhttp3/internal/http2/FrameLogTest.java
similarity index 58%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java
rename to okhttp/src/test/java/okhttp3/internal/http2/FrameLogTest.java
index 94e5e83581..d3bc42b198 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/FrameLogTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/FrameLogTest.java
@@ -32,56 +32,56 @@
 import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
 import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
 import static okhttp3.internal.http2.Http2.frameLog;
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class FrameLogTest {
   /** Real stream traffic applied to the log format. */
   @Test public void exampleStream() {
-    assertEquals(">> 0x00000000     5 SETTINGS      ",
-        frameLog(false, 0, 5, TYPE_SETTINGS, FLAG_NONE));
-    assertEquals(">> 0x00000003   100 HEADERS       END_HEADERS",
-        frameLog(false, 3, 100, TYPE_HEADERS, FLAG_END_HEADERS));
-    assertEquals(">> 0x00000003     0 DATA          END_STREAM",
-        frameLog(false, 3, 0, TYPE_DATA, FLAG_END_STREAM));
-    assertEquals("<< 0x00000000    15 SETTINGS      ",
-        frameLog(true, 0, 15, TYPE_SETTINGS, FLAG_NONE));
-    assertEquals(">> 0x00000000     0 SETTINGS      ACK",
-        frameLog(false, 0, 0, TYPE_SETTINGS, FLAG_ACK));
-    assertEquals("<< 0x00000000     0 SETTINGS      ACK",
-        frameLog(true, 0, 0, TYPE_SETTINGS, FLAG_ACK));
-    assertEquals("<< 0x00000003    22 HEADERS       END_HEADERS",
-        frameLog(true, 3, 22, TYPE_HEADERS, FLAG_END_HEADERS));
-    assertEquals("<< 0x00000003   226 DATA          END_STREAM",
-        frameLog(true, 3, 226, TYPE_DATA, FLAG_END_STREAM));
-    assertEquals(">> 0x00000000     8 GOAWAY        ",
-        frameLog(false, 0, 8, TYPE_GOAWAY, FLAG_NONE));
+    assertThat(frameLog(false, 0, 5, TYPE_SETTINGS, FLAG_NONE)).isEqualTo(
+        ">> 0x00000000     5 SETTINGS      ");
+    assertThat(frameLog(false, 3, 100, TYPE_HEADERS, FLAG_END_HEADERS)).isEqualTo(
+        ">> 0x00000003   100 HEADERS       END_HEADERS");
+    assertThat(frameLog(false, 3, 0, TYPE_DATA, FLAG_END_STREAM)).isEqualTo(
+        ">> 0x00000003     0 DATA          END_STREAM");
+    assertThat(frameLog(true, 0, 15, TYPE_SETTINGS, FLAG_NONE)).isEqualTo(
+        "<< 0x00000000    15 SETTINGS      ");
+    assertThat(frameLog(false, 0, 0, TYPE_SETTINGS, FLAG_ACK)).isEqualTo(
+        ">> 0x00000000     0 SETTINGS      ACK");
+    assertThat(frameLog(true, 0, 0, TYPE_SETTINGS, FLAG_ACK)).isEqualTo(
+        "<< 0x00000000     0 SETTINGS      ACK");
+    assertThat(frameLog(true, 3, 22, TYPE_HEADERS, FLAG_END_HEADERS)).isEqualTo(
+        "<< 0x00000003    22 HEADERS       END_HEADERS");
+    assertThat(frameLog(true, 3, 226, TYPE_DATA, FLAG_END_STREAM)).isEqualTo(
+        "<< 0x00000003   226 DATA          END_STREAM");
+    assertThat(frameLog(false, 0, 8, TYPE_GOAWAY, FLAG_NONE)).isEqualTo(
+        ">> 0x00000000     8 GOAWAY        ");
   }
 
   @Test public void flagOverlapOn0x1() {
-    assertEquals("<< 0x00000000     0 SETTINGS      ACK",
-        frameLog(true, 0, 0, TYPE_SETTINGS, (byte) 0x1));
-    assertEquals("<< 0x00000000     8 PING          ACK",
-        frameLog(true, 0, 8, TYPE_PING, (byte) 0x1));
-    assertEquals("<< 0x00000003     0 HEADERS       END_STREAM",
-        frameLog(true, 3, 0, TYPE_HEADERS, (byte) 0x1));
-    assertEquals("<< 0x00000003     0 DATA          END_STREAM",
-        frameLog(true, 3, 0, TYPE_DATA, (byte) 0x1));
+    assertThat(frameLog(true, 0, 0, TYPE_SETTINGS, (byte) 0x1)).isEqualTo(
+        "<< 0x00000000     0 SETTINGS      ACK");
+    assertThat(frameLog(true, 0, 8, TYPE_PING, (byte) 0x1)).isEqualTo(
+        "<< 0x00000000     8 PING          ACK");
+    assertThat(frameLog(true, 3, 0, TYPE_HEADERS, (byte) 0x1)).isEqualTo(
+        "<< 0x00000003     0 HEADERS       END_STREAM");
+    assertThat(frameLog(true, 3, 0, TYPE_DATA, (byte) 0x1)).isEqualTo(
+        "<< 0x00000003     0 DATA          END_STREAM");
   }
 
   @Test public void flagOverlapOn0x4() {
-    assertEquals("<< 0x00000003 10000 HEADERS       END_HEADERS",
-        frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x4));
-    assertEquals("<< 0x00000003 10000 CONTINUATION  END_HEADERS",
-        frameLog(true, 3, 10000, TYPE_CONTINUATION, (byte) 0x4));
-    assertEquals("<< 0x00000004 10000 PUSH_PROMISE  END_PUSH_PROMISE",
-        frameLog(true, 4, 10000, TYPE_PUSH_PROMISE, (byte) 0x4));
+    assertThat(frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x4)).isEqualTo(
+        "<< 0x00000003 10000 HEADERS       END_HEADERS");
+    assertThat(frameLog(true, 3, 10000, TYPE_CONTINUATION, (byte) 0x4)).isEqualTo(
+        "<< 0x00000003 10000 CONTINUATION  END_HEADERS");
+    assertThat(frameLog(true, 4, 10000, TYPE_PUSH_PROMISE, (byte) 0x4)).isEqualTo(
+        "<< 0x00000004 10000 PUSH_PROMISE  END_PUSH_PROMISE");
   }
 
   @Test public void flagOverlapOn0x20() {
-    assertEquals("<< 0x00000003 10000 HEADERS       PRIORITY",
-        frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x20));
-    assertEquals("<< 0x00000003 10000 DATA          COMPRESSED",
-        frameLog(true, 3, 10000, TYPE_DATA, (byte) 0x20));
+    assertThat(frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x20)).isEqualTo(
+        "<< 0x00000003 10000 HEADERS       PRIORITY");
+    assertThat(frameLog(true, 3, 10000, TYPE_DATA, (byte) 0x20)).isEqualTo(
+        "<< 0x00000003 10000 DATA          COMPRESSED");
   }
 
   /**
@@ -92,7 +92,7 @@
     List<String> formattedFlags = new ArrayList<>(0x40); // Highest valid flag is 0x20.
     for (byte i = 0; i < 0x40; i++) formattedFlags.add(Http2.formatFlags(TYPE_HEADERS, i));
 
-    assertEquals(Arrays.asList(
+    assertThat(formattedFlags).containsExactly(
         "",
         "END_STREAM",
         "00000010",
@@ -157,6 +157,6 @@
         "00111101",
         "00111110",
         "00111111"
-    ), formattedFlags);
+    );
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java b/okhttp/src/test/java/okhttp3/internal/http2/HpackTest.java
similarity index 80%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
rename to okhttp/src/test/java/okhttp3/internal/http2/HpackTest.java
index 454f5eec99..90a7d7290f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/HpackTest.java
@@ -23,9 +23,10 @@
 import org.junit.Before;
 import org.junit.Test;
 
+import static java.util.Arrays.asList;
 import static okhttp3.TestUtil.headerEntries;
 import static okio.ByteString.decodeHex;
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class HpackTest {
@@ -54,9 +55,9 @@
     bytesIn.writeAll(bytesOut);
     hpackReader.readHeaders();
 
-    assertEquals(0, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(0);
 
-    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
   }
 
   /**
@@ -74,9 +75,10 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(0, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(0);
 
-    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
+        headerEntries("custom-key", "custom-header"));
   }
 
   /** Oldest entries are evicted to support newer ones. */
@@ -114,8 +116,8 @@
     Hpack.Writer writer = new Hpack.Writer(110, false, bytesOut);
     writer.writeHeaders(headerBlock);
 
-    assertEquals(bytesIn, bytesOut);
-    assertEquals(2, writer.headerCount);
+    assertThat(bytesOut).isEqualTo(bytesIn);
+    assertThat(writer.headerCount).isEqualTo(2);
 
     int tableLength = writer.dynamicTable.length;
     Header entry = writer.dynamicTable[tableLength - 1];
@@ -159,7 +161,7 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(2, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(2);
 
     Header entry1 = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry1, "custom-bar", "custom-header", 55);
@@ -169,13 +171,13 @@
 
     // Once a header field is decoded and added to the reconstructed header
     // list, it cannot be removed from it. Hence, foo is here.
-    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
 
     // Simulate receiving a small dynamic table size update, that implies eviction.
     bytesIn.writeByte(0x3F); // Dynamic table size update (size = 55).
     bytesIn.writeByte(0x18);
     hpackReader.readHeaders();
-    assertEquals(1, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(1);
   }
 
   /** Header table backing array is initially 8 long, let's ensure it grows. */
@@ -197,7 +199,7 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(256, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(256);
   }
 
   @Test public void huffmanDecodingSupported() throws IOException {
@@ -209,8 +211,8 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(1, hpackReader.headerCount);
-    assertEquals(52, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.headerCount).isEqualTo(1);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(52);
 
     Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":path", "www.example.com", 52);
@@ -229,13 +231,14 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(1, hpackReader.headerCount);
-    assertEquals(55, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.headerCount).isEqualTo(1);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(55);
 
     Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, "custom-key", "custom-header", 55);
 
-    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
+        headerEntries("custom-key", "custom-header"));
   }
 
   /**
@@ -250,13 +253,13 @@
     bytesIn.writeUtf8("/sample/path");
 
     hpackWriter.writeHeaders(headerBlock);
-    assertEquals(bytesIn, bytesOut);
+    assertThat(bytesOut).isEqualTo(bytesIn);
 
     hpackReader.readHeaders();
 
-    assertEquals(0, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(0);
 
-    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
   }
 
   @Test public void literalHeaderFieldWithoutIndexingNewName() throws IOException {
@@ -271,9 +274,9 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(0, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(0);
 
-    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
   }
 
   @Test public void literalHeaderFieldNeverIndexedIndexedName() throws IOException {
@@ -284,9 +287,10 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(0, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(0);
 
-    assertEquals(headerEntries(":path", "/sample/path"), hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
+        headerEntries(":path", "/sample/path"));
   }
 
   @Test public void literalHeaderFieldNeverIndexedNewName() throws IOException {
@@ -301,9 +305,9 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(0, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(0);
 
-    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
   }
 
   @Test public void literalHeaderFieldWithIncrementalIndexingIndexedName() throws IOException {
@@ -315,9 +319,9 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(1, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(1);
 
-    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
   }
 
   @Test public void literalHeaderFieldWithIncrementalIndexingNewName() throws IOException {
@@ -331,18 +335,18 @@
     bytesIn.writeUtf8("custom-header");
 
     hpackWriter.writeHeaders(headerBlock);
-    assertEquals(bytesIn, bytesOut);
+    assertThat(bytesOut).isEqualTo(bytesIn);
 
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
 
     Header entry = hpackWriter.dynamicTable[hpackWriter.dynamicTable.length - 1];
     checkEntry(entry, "custom-key", "custom-header", 55);
 
     hpackReader.readHeaders();
 
-    assertEquals(1, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(1);
 
-    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
   }
 
   @Test public void theSameHeaderAfterOneIncrementalIndexed() throws IOException {
@@ -361,18 +365,18 @@
     bytesIn.writeByte(0xbe); // Indexed name and value (idx = 63)
 
     hpackWriter.writeHeaders(headerBlock);
-    assertEquals(bytesIn, bytesOut);
+    assertThat(bytesOut).isEqualTo(bytesIn);
 
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
 
     Header entry = hpackWriter.dynamicTable[hpackWriter.dynamicTable.length - 1];
     checkEntry(entry, "custom-key", "custom-header", 55);
 
     hpackReader.readHeaders();
 
-    assertEquals(1, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(1);
 
-    assertEquals(headerBlock, hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
   }
 
   @Test public void staticHeaderIsNotCopiedIntoTheIndexedTable() throws IOException {
@@ -381,12 +385,13 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(0, hpackReader.headerCount);
-    assertEquals(0, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.headerCount).isEqualTo(0);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(0);
 
-    assertEquals(null, hpackReader.dynamicTable[readerHeaderTableLength() - 1]);
+    assertThat(hpackReader.dynamicTable[readerHeaderTableLength() - 1]).isNull();
 
-    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
+        headerEntries(":method", "GET"));
   }
 
   // Example taken from twitter/hpack DecoderTest.testUnusedIndex
@@ -397,7 +402,7 @@
       hpackReader.readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("index == 0", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("index == 0");
     }
   }
 
@@ -409,7 +414,7 @@
       hpackReader.readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("Header index too large 127", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Header index too large 127");
     }
   }
 
@@ -422,7 +427,7 @@
       hpackReader.readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("Header index too large -2147483521", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Header index too large -2147483521");
     }
   }
 
@@ -431,14 +436,14 @@
     bytesIn.writeByte(0x20);
     hpackReader.readHeaders();
 
-    assertEquals(0, hpackReader.maxDynamicTableByteCount());
+    assertThat(hpackReader.maxDynamicTableByteCount()).isEqualTo(0);
 
     bytesIn.writeByte(0x3f); // encode size 4096
     bytesIn.writeByte(0xe1);
     bytesIn.writeByte(0x1f);
     hpackReader.readHeaders();
 
-    assertEquals(4096, hpackReader.maxDynamicTableByteCount());
+    assertThat(hpackReader.maxDynamicTableByteCount()).isEqualTo(4096);
   }
 
   // Example taken from twitter/hpack DecoderTest.testIllegalHeaderTableSizeUpdate
@@ -451,7 +456,7 @@
       hpackReader.readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("Invalid dynamic table size update 4097", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Invalid dynamic table size update 4097");
     }
   }
 
@@ -464,7 +469,7 @@
       hpackReader.readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("Invalid dynamic table size update -2147483648", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Invalid dynamic table size update -2147483648");
     }
   }
 
@@ -479,9 +484,10 @@
     hpackReader.readHeaders();
 
     // Not buffered in header table.
-    assertEquals(0, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(0);
 
-    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
+        headerEntries(":method", "GET"));
   }
 
   @Test public void readLiteralHeaderWithIncrementalIndexingStaticName() throws IOException {
@@ -492,7 +498,8 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(Arrays.asList(new Header("www-authenticate", "Basic")), hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList())
+        .containsExactly(new Header("www-authenticate", "Basic"));
   }
 
   @Test public void readLiteralHeaderWithIncrementalIndexingDynamicName() throws IOException {
@@ -508,9 +515,8 @@
 
     hpackReader.readHeaders();
 
-    assertEquals(
-        Arrays.asList(new Header("custom-foo", "Basic"), new Header("custom-foo", "Basic2")),
-        hpackReader.getAndResetHeaderList());
+    assertThat(hpackReader.getAndResetHeaderList()).containsExactly(
+        new Header("custom-foo", "Basic"), new Header("custom-foo", "Basic2"));
   }
 
   /**
@@ -547,7 +553,7 @@
       hpackReader.readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("Header index too large 78", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Header index too large 78");
     }
   }
 
@@ -565,21 +571,21 @@ private void firstRequestWithoutHuffman() {
   }
 
   private void checkReadFirstRequestWithoutHuffman() {
-    assertEquals(1, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(1);
 
     // [  1] (s =  57) :authority: www.example.com
     Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 57
-    assertEquals(57, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(57);
 
     // Decoded header list:
-    assertEquals(headerEntries(
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
         ":method", "GET",
         ":scheme", "http",
         ":path", "/",
-        ":authority", "www.example.com"), hpackReader.getAndResetHeaderList());
+        ":authority", "www.example.com"));
   }
 
   private void secondRequestWithoutHuffman() {
@@ -598,7 +604,7 @@ private void secondRequestWithoutHuffman() {
   }
 
   private void checkReadSecondRequestWithoutHuffman() {
-    assertEquals(2, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(2);
 
     // [  1] (s =  53) cache-control: no-cache
     Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
@@ -609,15 +615,15 @@ private void checkReadSecondRequestWithoutHuffman() {
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 110
-    assertEquals(110, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(110);
 
     // Decoded header list:
-    assertEquals(headerEntries(
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
         ":method", "GET",
         ":scheme", "http",
         ":path", "/",
         ":authority", "www.example.com",
-        "cache-control", "no-cache"), hpackReader.getAndResetHeaderList());
+        "cache-control", "no-cache"));
   }
 
   private void thirdRequestWithoutHuffman() {
@@ -637,7 +643,7 @@ private void thirdRequestWithoutHuffman() {
   }
 
   private void checkReadThirdRequestWithoutHuffman() {
-    assertEquals(3, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(3);
 
     // [  1] (s =  54) custom-key: custom-value
     Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 3];
@@ -652,15 +658,15 @@ private void checkReadThirdRequestWithoutHuffman() {
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 164
-    assertEquals(164, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(164);
 
     // Decoded header list:
-    assertEquals(headerEntries(
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
         ":method", "GET",
         ":scheme", "https",
         ":path", "/index.html",
         ":authority", "www.example.com",
-        "custom-key", "custom-value"), hpackReader.getAndResetHeaderList());
+        "custom-key", "custom-value"));
   }
 
   /**
@@ -695,21 +701,21 @@ private void firstRequestWithHuffman() {
   }
 
   private void checkReadFirstRequestWithHuffman() {
-    assertEquals(1, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(1);
 
     // [  1] (s =  57) :authority: www.example.com
     Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 57
-    assertEquals(57, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(57);
 
     // Decoded header list:
-    assertEquals(headerEntries(
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
         ":method", "GET",
         ":scheme", "http",
         ":path", "/",
-        ":authority", "www.example.com"), hpackReader.getAndResetHeaderList());
+        ":authority", "www.example.com"));
   }
 
   private void secondRequestWithHuffman() {
@@ -729,7 +735,7 @@ private void secondRequestWithHuffman() {
   }
 
   private void checkReadSecondRequestWithHuffman() {
-    assertEquals(2, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(2);
 
     // [  1] (s =  53) cache-control: no-cache
     Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
@@ -740,15 +746,15 @@ private void checkReadSecondRequestWithHuffman() {
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 110
-    assertEquals(110, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(110);
 
     // Decoded header list:
-    assertEquals(headerEntries(
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
         ":method", "GET",
         ":scheme", "http",
         ":path", "/",
         ":authority", "www.example.com",
-        "cache-control", "no-cache"), hpackReader.getAndResetHeaderList());
+        "cache-control", "no-cache"));
   }
 
   private void thirdRequestWithHuffman() {
@@ -770,7 +776,7 @@ private void thirdRequestWithHuffman() {
   }
 
   private void checkReadThirdRequestWithHuffman() {
-    assertEquals(3, hpackReader.headerCount);
+    assertThat(hpackReader.headerCount).isEqualTo(3);
 
     // [  1] (s =  54) custom-key: custom-value
     Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 3];
@@ -785,24 +791,24 @@ private void checkReadThirdRequestWithHuffman() {
     checkEntry(entry, ":authority", "www.example.com", 57);
 
     // Table size: 164
-    assertEquals(164, hpackReader.dynamicTableByteCount);
+    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(164);
 
     // Decoded header list:
-    assertEquals(headerEntries(
+    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
         ":method", "GET",
         ":scheme", "https",
         ":path", "/index.html",
         ":authority", "www.example.com",
-        "custom-key", "custom-value"), hpackReader.getAndResetHeaderList());
+        "custom-key", "custom-value"));
   }
 
   @Test public void readSingleByteInt() throws IOException {
-    assertEquals(10, newReader(byteStream()).readInt(10, 31));
-    assertEquals(10, newReader(byteStream()).readInt(0xe0 | 10, 31));
+    assertThat(newReader(byteStream()).readInt(10, 31)).isEqualTo(10);
+    assertThat(newReader(byteStream()).readInt(0xe0 | 10, 31)).isEqualTo(10);
   }
 
   @Test public void readMultibyteInt() throws IOException {
-    assertEquals(1337, newReader(byteStream(154, 10)).readInt(31, 31));
+    assertThat(newReader(byteStream(154, 10)).readInt(31, 31)).isEqualTo(1337);
   }
 
   @Test public void writeSingleByteInt() throws IOException {
@@ -822,30 +828,30 @@ private void checkReadThirdRequestWithHuffman() {
   @Test public void max31BitValue() throws IOException {
     hpackWriter.writeInt(0x7fffffff, 31, 0);
     assertBytes(31, 224, 255, 255, 255, 7);
-    assertEquals(0x7fffffff,
-        newReader(byteStream(224, 255, 255, 255, 7)).readInt(31, 31));
+    assertThat(newReader(byteStream(224, 255, 255, 255, 7)).readInt(31, 31)).isEqualTo(
+        (long) 0x7fffffff);
   }
 
   @Test public void prefixMask() throws IOException {
     hpackWriter.writeInt(31, 31, 0);
     assertBytes(31, 0);
-    assertEquals(31, newReader(byteStream(0)).readInt(31, 31));
+    assertThat(newReader(byteStream(0)).readInt(31, 31)).isEqualTo(31);
   }
 
   @Test public void prefixMaskMinusOne() throws IOException {
     hpackWriter.writeInt(30, 31, 0);
     assertBytes(30);
-    assertEquals(31, newReader(byteStream(0)).readInt(31, 31));
+    assertThat(newReader(byteStream(0)).readInt(31, 31)).isEqualTo(31);
   }
 
   @Test public void zero() throws IOException {
     hpackWriter.writeInt(0, 31, 0);
     assertBytes(0);
-    assertEquals(0, newReader(byteStream()).readInt(0, 31));
+    assertThat(newReader(byteStream()).readInt(0, 31)).isEqualTo(0);
   }
 
   @Test public void lowercaseHeaderNameBeforeEmit() throws IOException {
-    hpackWriter.writeHeaders(Arrays.asList(new Header("FoO", "BaR")));
+    hpackWriter.writeHeaders(asList(new Header("FoO", "BaR")));
     assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'B', 'a', 'R');
   }
 
@@ -854,38 +860,39 @@ private void checkReadThirdRequestWithHuffman() {
       newReader(byteStream(0, 3, 'F', 'o', 'o', 3, 'B', 'a', 'R')).readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR response malformed: mixed case name: Foo", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "PROTOCOL_ERROR response malformed: mixed case name: Foo");
     }
   }
 
   @Test public void emptyHeaderName() throws IOException {
     hpackWriter.writeByteString(ByteString.encodeUtf8(""));
     assertBytes(0);
-    assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString());
+    assertThat(newReader(byteStream(0)).readByteString()).isEqualTo(ByteString.EMPTY);
   }
 
   @Test public void emitsDynamicTableSizeUpdate() throws IOException {
     hpackWriter.setHeaderTableSizeSetting(2048);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+    hpackWriter.writeHeaders(asList(new Header("foo", "bar")));
     assertBytes(
         0x3F, 0xE1, 0xF, // Dynamic table size update (size = 2048).
         0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
 
     hpackWriter.setHeaderTableSizeSetting(8192);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("bar", "foo")));
+    hpackWriter.writeHeaders(asList(new Header("bar", "foo")));
     assertBytes(
         0x3F, 0xE1, 0x3F, // Dynamic table size update (size = 8192).
         0x40, 3, 'b', 'a', 'r', 3, 'f', 'o', 'o');
 
     // No more dynamic table updates should be emitted.
-    hpackWriter.writeHeaders(Arrays.asList(new Header("far", "boo")));
+    hpackWriter.writeHeaders(asList(new Header("far", "boo")));
     assertBytes(0x40, 3, 'f', 'a', 'r', 3, 'b', 'o', 'o');
   }
 
   @Test public void noDynamicTableSizeUpdateWhenSizeIsEqual() throws IOException {
     int currentSize = hpackWriter.headerTableSizeSetting;
     hpackWriter.setHeaderTableSizeSetting(currentSize);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+    hpackWriter.writeHeaders(asList(new Header("foo", "bar")));
 
     assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
   }
@@ -893,7 +900,7 @@ private void checkReadThirdRequestWithHuffman() {
   @Test public void growDynamicTableSize() throws IOException {
     hpackWriter.setHeaderTableSizeSetting(8192);
     hpackWriter.setHeaderTableSizeSetting(16384);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+    hpackWriter.writeHeaders(asList(new Header("foo", "bar")));
 
     assertBytes(
         0x3F, 0xE1, 0x7F, // Dynamic table size update (size = 16384).
@@ -903,7 +910,7 @@ private void checkReadThirdRequestWithHuffman() {
   @Test public void shrinkDynamicTableSize() throws IOException {
     hpackWriter.setHeaderTableSizeSetting(2048);
     hpackWriter.setHeaderTableSizeSetting(0);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+    hpackWriter.writeHeaders(asList(new Header("foo", "bar")));
 
     assertBytes(
         0x20, // Dynamic size update (size = 0).
@@ -916,7 +923,7 @@ private void checkReadThirdRequestWithHuffman() {
     hpackWriter.setHeaderTableSizeSetting(0);
     hpackWriter.setHeaderTableSizeSetting(4096);
     hpackWriter.setHeaderTableSizeSetting(2048);
-    hpackWriter.writeHeaders(Arrays.asList(new Header("foo", "bar")));
+    hpackWriter.writeHeaders(asList(new Header("foo", "bar")));
 
     assertBytes(
         0x20, // Dynamic size update (size = 0).
@@ -930,13 +937,13 @@ private void checkReadThirdRequestWithHuffman() {
             "custom-key1", "custom-header",
             "custom-key2", "custom-header");
     hpackWriter.writeHeaders(headerBlock);
-    assertEquals(2, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(2);
 
     hpackWriter.setHeaderTableSizeSetting(56);
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
 
     hpackWriter.setHeaderTableSizeSetting(0);
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
   }
 
   @Test public void noEvictionOnDynamicTableSizeIncrease() throws IOException {
@@ -945,15 +952,15 @@ private void checkReadThirdRequestWithHuffman() {
             "custom-key1", "custom-header",
             "custom-key2", "custom-header");
     hpackWriter.writeHeaders(headerBlock);
-    assertEquals(2, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(2);
 
     hpackWriter.setHeaderTableSizeSetting(8192);
-    assertEquals(2, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(2);
   }
 
   @Test public void dynamicTableSizeHasAnUpperBound() {
     hpackWriter.setHeaderTableSizeSetting(1048576);
-    assertEquals(16384, hpackWriter.maxDynamicTableByteCount);
+    assertThat(hpackWriter.maxDynamicTableByteCount).isEqualTo(16384);
   }
 
   @Test public void huffmanEncode() throws IOException {
@@ -972,33 +979,33 @@ private void checkReadThirdRequestWithHuffman() {
         .readByteString();
 
     ByteString actual = bytesOut.readByteString();
-    assertEquals(expected, actual);
+    assertThat(actual).isEqualTo(expected);
   }
 
   @Test public void staticTableIndexedHeaders() throws IOException {
     hpackWriter.writeHeaders(headerEntries(":method", "GET"));
     assertBytes(0x82);
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
 
     hpackWriter.writeHeaders(headerEntries(":method", "POST"));
     assertBytes(0x83);
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
 
     hpackWriter.writeHeaders(headerEntries(":path", "/"));
     assertBytes(0x84);
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
 
     hpackWriter.writeHeaders(headerEntries(":path", "/index.html"));
     assertBytes(0x85);
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
 
     hpackWriter.writeHeaders(headerEntries(":scheme", "http"));
     assertBytes(0x86);
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
 
     hpackWriter.writeHeaders(headerEntries(":scheme", "https"));
     assertBytes(0x87);
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
   }
 
   @Test public void dynamicTableIndexedHeader() throws IOException {
@@ -1006,64 +1013,64 @@ private void checkReadThirdRequestWithHuffman() {
     assertBytes(0x40,
         10, 'c', 'u', 's', 't', 'o', 'm', '-', 'k', 'e', 'y',
         13, 'c', 'u', 's', 't', 'o', 'm', '-', 'h', 'e', 'a', 'd', 'e', 'r');
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
 
     hpackWriter.writeHeaders(headerEntries("custom-key", "custom-header"));
     assertBytes(0xbe);
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
   }
 
   @Test public void doNotIndexPseudoHeaders() throws IOException {
     hpackWriter.writeHeaders(headerEntries(":method", "PUT"));
     assertBytes(0x02, 3, 'P', 'U', 'T');
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
 
     hpackWriter.writeHeaders(headerEntries(":path", "/okhttp"));
     assertBytes(0x04, 7, '/', 'o', 'k', 'h', 't', 't', 'p');
-    assertEquals(0, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(0);
   }
 
   @Test public void incrementalIndexingWithAuthorityPseudoHeader() throws IOException {
     hpackWriter.writeHeaders(headerEntries(":authority", "foo.com"));
     assertBytes(0x41, 7, 'f', 'o', 'o', '.', 'c', 'o', 'm');
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
 
     hpackWriter.writeHeaders(headerEntries(":authority", "foo.com"));
     assertBytes(0xbe);
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
 
     // If the :authority header somehow changes, it should be re-added to the dynamic table.
     hpackWriter.writeHeaders(headerEntries(":authority", "bar.com"));
     assertBytes(0x41, 7, 'b', 'a', 'r', '.', 'c', 'o', 'm');
-    assertEquals(2, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(2);
 
     hpackWriter.writeHeaders(headerEntries(":authority", "bar.com"));
     assertBytes(0xbe);
-    assertEquals(2, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(2);
   }
 
   @Test public void incrementalIndexingWithStaticTableIndexedName() throws IOException {
     hpackWriter.writeHeaders(headerEntries("accept-encoding", "gzip"));
     assertBytes(0x50, 4, 'g', 'z', 'i', 'p');
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
 
     hpackWriter.writeHeaders(headerEntries("accept-encoding", "gzip"));
     assertBytes(0xbe);
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
   }
 
   @Test public void incrementalIndexingWithDynamcTableIndexedName() throws IOException {
     hpackWriter.writeHeaders(headerEntries("foo", "bar"));
     assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
-    assertEquals(1, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(1);
 
     hpackWriter.writeHeaders(headerEntries("foo", "bar1"));
     assertBytes(0x7e, 4, 'b', 'a', 'r', '1');
-    assertEquals(2, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(2);
 
     hpackWriter.writeHeaders(headerEntries("foo", "bar1"));
     assertBytes(0xbe);
-    assertEquals(2, hpackWriter.headerCount);
+    assertThat(hpackWriter.headerCount).isEqualTo(2);
   }
 
   private Hpack.Reader newReader(Buffer source) {
@@ -1075,15 +1082,15 @@ private Buffer byteStream(int... bytes) {
   }
 
   private void checkEntry(Header entry, String name, String value, int size) {
-    assertEquals(name, entry.name.utf8());
-    assertEquals(value, entry.value.utf8());
-    assertEquals(size, entry.hpackSize);
+    assertThat(entry.name.utf8()).isEqualTo(name);
+    assertThat(entry.value.utf8()).isEqualTo(value);
+    assertThat(entry.hpackSize).isEqualTo(size);
   }
 
   private void assertBytes(int... bytes) throws IOException {
     ByteString expected = intArrayToByteArray(bytes);
     ByteString actual = bytesOut.readByteString();
-    assertEquals(expected, actual);
+    assertThat(actual).isEqualTo(expected);
   }
 
   private ByteString intArrayToByteArray(int[] bytes) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
similarity index 61%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
rename to okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index 2ab31a35de..03b1e1eb4d 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -15,6 +15,7 @@
  */
 package okhttp3.internal.http2;
 
+import java.io.EOFException;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.Socket;
@@ -24,6 +25,7 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import okhttp3.Headers;
 import okhttp3.internal.Util;
 import okhttp3.internal.http2.MockHttp2Peer.InFrame;
 import okio.AsyncTimeout;
@@ -33,15 +35,21 @@
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
+import okio.Utf8;
 import org.junit.After;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
 import org.junit.rules.Timeout;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Arrays.asList;
 import static okhttp3.TestUtil.headerEntries;
 import static okhttp3.TestUtil.repeat;
+import static okhttp3.internal.Internal.initializeInstanceForTests;
 import static okhttp3.internal.Util.EMPTY_BYTE_ARRAY;
+import static okhttp3.internal.Util.EMPTY_HEADERS;
 import static okhttp3.internal.http2.Http2Connection.Listener.REFUSE_INCOMING_STREAMS;
 import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.http2.Settings.ENABLE_PUSH;
@@ -49,15 +57,19 @@
 import static okhttp3.internal.http2.Settings.INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
 import static okhttp3.internal.http2.Settings.MAX_FRAME_SIZE;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.fail;
 
 public final class Http2ConnectionTest {
   private final MockHttp2Peer peer = new MockHttp2Peer();
 
-  @Rule public final TestRule timeout = new Timeout(5_000);
+  @Rule public final TestRule timeout = new Timeout(5_000, TimeUnit.MILLISECONDS);
+
+  @Before public void setup() {
+    initializeInstanceForTests();
+  }
 
   @After public void tearDown() throws Exception {
     peer.close();
@@ -76,11 +88,11 @@
 
     // verify the peer received what was expected
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
-    assertEquals(0, ping.streamId);
-    assertEquals(2, ping.payload1);
-    assertEquals(3, ping.payload2);
-    assertTrue(ping.ack);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
+    assertThat(ping.streamId).isEqualTo(0);
+    assertThat(ping.payload1).isEqualTo(2);
+    assertThat(ping.payload2).isEqualTo(3);
+    assertThat(ping.ack).isTrue();
   }
 
   @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
@@ -100,16 +112,16 @@
 
     // Verify the peer received the second ACK.
     InFrame ackFrame = peer.takeFrame();
-    assertEquals(Http2.TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
+    assertThat(ackFrame.type).isEqualTo(Http2.TYPE_SETTINGS);
+    assertThat(ackFrame.streamId).isEqualTo(0);
+    assertThat(ackFrame.ack).isTrue();
 
     // This stream was created *after* the connection settings were adjusted.
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
 
-    assertEquals(3368, connection.peerSettings.getInitialWindowSize());
+    assertThat(connection.peerSettings.getInitialWindowSize()).isEqualTo(3368);
     // New Stream is has the most recent initial window size.
-    assertEquals(3368, stream.bytesLeftInWriteWindow);
+    assertThat(stream.bytesLeftInWriteWindow).isEqualTo(3368);
   }
 
   @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
@@ -120,10 +132,10 @@
     Http2Connection connection = connectWithSettings(client, settings);
 
     // Verify the peer's settings were read and applied.
-    assertEquals(0, connection.peerSettings.getHeaderTableSize());
+    assertThat(connection.peerSettings.getHeaderTableSize()).isEqualTo(0);
     Http2Writer writer = connection.writer;
-    assertEquals(0, writer.hpackWriter.dynamicTableByteCount);
-    assertEquals(0, writer.hpackWriter.headerTableSizeSetting);
+    assertThat(writer.hpackWriter.dynamicTableByteCount).isEqualTo(0);
+    assertThat(writer.hpackWriter.headerTableSizeSetting).isEqualTo(0);
   }
 
   @Test public void peerHttp2ClientDisablesPush() throws Exception {
@@ -134,7 +146,7 @@
     Http2Connection connection = connectWithSettings(client, settings);
 
     // verify the peer's settings were read and applied.
-    assertFalse(connection.peerSettings.getEnablePush(true));
+    assertThat(connection.peerSettings.getEnablePush(true)).isFalse();
   }
 
   @Test public void peerIncreasesMaxFrameSize() throws Exception {
@@ -145,8 +157,8 @@
     Http2Connection connection = connectWithSettings(true, settings);
 
     // verify the peer's settings were read and applied.
-    assertEquals(newMaxFrameSize, connection.peerSettings.getMaxFrameSize(-1));
-    assertEquals(newMaxFrameSize, connection.writer.maxDataLength());
+    assertThat(connection.peerSettings.getMaxFrameSize(-1)).isEqualTo(newMaxFrameSize);
+    assertThat(connection.writer.maxDataLength()).isEqualTo(newMaxFrameSize);
   }
 
   /**
@@ -181,15 +193,48 @@
     // Verify the peer received what was expected.
     peer.takeFrame(); // PING
     InFrame headers = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, headers.type);
+    assertThat(headers.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame data1 = peer.takeFrame();
-    assertEquals(Http2.TYPE_DATA, data1.type);
-    assertEquals(3, data1.streamId);
-    assertTrue(Arrays.equals("abcde".getBytes("UTF-8"), data1.data));
+    assertThat(data1.type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(data1.streamId).isEqualTo(3);
+    assertArrayEquals("abcde".getBytes(UTF_8), data1.data);
     InFrame data2 = peer.takeFrame();
-    assertEquals(Http2.TYPE_DATA, data2.type);
-    assertEquals(3, data2.streamId);
-    assertTrue(Arrays.equals("fghi".getBytes("UTF-8"), data2.data));
+    assertThat(data2.type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(data2.streamId).isEqualTo(3);
+    assertArrayEquals("fghi".getBytes(UTF_8), data2.data);
+  }
+
+  /**
+   * Confirm that we account for discarded data frames. It's possible that data frames are in-flight
+   * just prior to us canceling a stream.
+   */
+  @Test public void discardedDataFramesAreCounted() throws Exception {
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM 3
+    peer.sendFrame().headers(false, 3, headerEntries("a", "apple"));
+    peer.sendFrame().data(false, 3, data(1024), 1024);
+    peer.acceptFrame(); // RST_STREAM
+    peer.sendFrame().data(true, 3, data(1024), 1024);
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    Http2Connection connection = connect(peer);
+    Http2Stream stream1 = connection.newStream(headerEntries("b", "bark"), false);
+    Source source = stream1.getSource();
+    Buffer buffer = new Buffer();
+    while (buffer.size() != 1024) source.read(buffer, 1024);
+    stream1.close(ErrorCode.CANCEL, null);
+
+    InFrame frame1 = peer.takeFrame();
+    assertThat(frame1.type).isEqualTo(Http2.TYPE_HEADERS);
+    InFrame frame2 = peer.takeFrame();
+    assertThat(frame2.type).isEqualTo(Http2.TYPE_RST_STREAM);
+    InFrame frame3 = peer.takeFrame();
+    assertThat(frame3.type).isEqualTo(Http2.TYPE_RST_STREAM);
+
+    assertThat(connection.unacknowledgedBytesRead).isEqualTo(2048);
   }
 
   @Test public void receiveGoAwayHttp2() throws Exception {
@@ -217,7 +262,7 @@
       sink2.flush();
       fail();
     } catch (IOException expected) {
-      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream was reset: REFUSED_STREAM");
     }
     sink1.writeUtf8("def");
     sink1.close();
@@ -226,21 +271,21 @@
       fail();
     } catch (ConnectionShutdownException expected) {
     }
-    assertTrue(stream1.isOpen());
-    assertFalse(stream2.isOpen());
-    assertEquals(1, connection.openStreamCount());
+    assertThat(stream1.isOpen()).isTrue();
+    assertThat(stream2.isOpen()).isFalse();
+    assertThat(connection.openStreamCount()).isEqualTo(1);
 
     // verify the peer received what was expected
     InFrame synStream1 = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream1.type);
+    assertThat(synStream1.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame synStream2 = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream2.type);
+    assertThat(synStream2.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
     InFrame data1 = peer.takeFrame();
-    assertEquals(Http2.TYPE_DATA, data1.type);
-    assertEquals(3, data1.streamId);
-    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
+    assertThat(data1.type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(data1.streamId).isEqualTo(3);
+    assertArrayEquals("abcdef".getBytes(UTF_8), data1.data);
   }
 
   @Test public void readSendsWindowUpdateHttp2() throws Exception {
@@ -251,7 +296,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     for (int i = 0; i < 3; i++) {
       // Send frames of summing to size 50, which is windowUpdateThreshold.
       peer.sendFrame().data(false, 3, data(24), 24);
@@ -267,26 +312,28 @@
     Http2Connection connection = connect(peer);
     connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertThat(stream.unacknowledgedBytesRead).isEqualTo(0);
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
     buffer.writeAll(in);
-    assertEquals(-1, in.read(buffer, 1));
-    assertEquals(150, buffer.size());
+    assertThat(in.read(buffer, 1)).isEqualTo(-1);
+    assertThat(buffer.size()).isEqualTo(150);
 
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     for (int i = 0; i < 3; i++) {
       List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
       for (int j = 0; j < 2; j++) {
         InFrame windowUpdate = peer.takeFrame();
-        assertEquals(Http2.TYPE_WINDOW_UPDATE, windowUpdate.type);
+        assertThat(windowUpdate.type).isEqualTo(Http2.TYPE_WINDOW_UPDATE);
         windowUpdateStreamIds.add(windowUpdate.streamId);
-        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+        assertThat(windowUpdate.windowSizeIncrement).isEqualTo(windowUpdateThreshold);
       }
-      assertTrue(windowUpdateStreamIds.contains(0)); // connection
-      assertTrue(windowUpdateStreamIds.contains(3)); // stream
+      // connection
+      assertThat(windowUpdateStreamIds).contains(0);
+      // stream
+      assertThat(windowUpdateStreamIds).contains(3);
     }
   }
 
@@ -295,19 +342,19 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(true, 3, data(0), 0);
     peer.play();
 
     // Play it back.
     Http2Connection connection = connect(peer);
     Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+    assertThat(client.getSource().read(new Buffer(), 1)).isEqualTo(-1);
 
     // Verify the peer received what was expected.
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertEquals(5, peer.frameCount());
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.frameCount()).isEqualTo(5);
   }
 
   @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
@@ -316,7 +363,7 @@
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // DATA
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.play();
 
     // Play it back.
@@ -328,9 +375,9 @@
     out.close();
 
     // Verify the peer received what was expected.
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
-    assertEquals(5, peer.frameCount());
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(peer.frameCount()).isEqualTo(5);
   }
 
   @Test public void maxFrameSizeHonored() throws Exception {
@@ -341,7 +388,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // DATA
     peer.acceptFrame(); // DATA
     peer.play();
@@ -355,11 +402,11 @@
     out.close();
 
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame data = peer.takeFrame();
-    assertEquals(peer.maxOutboundDataLength(), data.data.length);
+    assertThat(data.data.length).isEqualTo(peer.maxOutboundDataLength());
     data = peer.takeFrame();
-    assertEquals(1, data.data.length);
+    assertThat(data.data.length).isEqualTo(1);
   }
 
   @Test public void pushPromiseStream() throws Exception {
@@ -367,18 +414,18 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    final List<Header> expectedRequestHeaders = Arrays.asList(
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
+    final List<Header> expectedRequestHeaders = asList(
         new Header(Header.TARGET_METHOD, "GET"),
         new Header(Header.TARGET_SCHEME, "https"),
         new Header(Header.TARGET_AUTHORITY, "squareup.com"),
         new Header(Header.TARGET_PATH, "/cached")
     );
     peer.sendFrame().pushPromise(3, 2, expectedRequestHeaders);
-    final List<Header> expectedResponseHeaders = Arrays.asList(
+    final List<Header> expectedResponseHeaders = asList(
         new Header(Header.RESPONSE_STATUS, "200")
     );
-    peer.sendFrame().synReply(true, 2, expectedResponseHeaders);
+    peer.sendFrame().headers(true, 2, expectedResponseHeaders);
     peer.sendFrame().data(true, 3, data(0), 0);
     peer.play();
 
@@ -387,13 +434,13 @@
     // play it back
     Http2Connection connection = connect(peer, observer, REFUSE_INCOMING_STREAMS);
     Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+    assertThat(client.getSource().read(new Buffer(), 1)).isEqualTo(-1);
 
     // verify the peer received what was expected
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
 
-    assertEquals(expectedRequestHeaders, observer.takeEvent());
-    assertEquals(expectedResponseHeaders, observer.takeEvent());
+    assertThat(observer.takeEvent()).isEqualTo(expectedRequestHeaders);
+    assertThat(observer.takeEvent()).isEqualTo(expectedResponseHeaders);
   }
 
   @Test public void doublePushPromise() throws Exception {
@@ -411,21 +458,21 @@
     connection.newStream(headerEntries("b", "banana"), false);
 
     // verify the peer received what was expected
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(ErrorCode.PROTOCOL_ERROR, peer.takeFrame().errorCode);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.takeFrame().errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
   }
 
   @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
     // write the mocking script
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
-    peer.sendFrame().pushPromise(3, 2, Arrays.asList(
+    peer.sendFrame().pushPromise(3, 2, asList(
         new Header(Header.TARGET_METHOD, "GET"),
         new Header(Header.TARGET_SCHEME, "https"),
         new Header(Header.TARGET_AUTHORITY, "squareup.com"),
         new Header(Header.TARGET_PATH, "/cached")
     ));
-    peer.sendFrame().synReply(true, 2, Arrays.asList(
+    peer.sendFrame().headers(true, 2, asList(
         new Header(Header.RESPONSE_STATUS, "200")
     ));
     peer.acceptFrame(); // RST_STREAM
@@ -436,9 +483,9 @@
 
     // verify the peer received what was expected
     InFrame rstStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
-    assertEquals(2, rstStream.streamId);
-    assertEquals(ErrorCode.CANCEL, rstStream.errorCode);
+    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
+    assertThat(rstStream.streamId).isEqualTo(2);
+    assertThat(rstStream.errorCode).isEqualTo(ErrorCode.CANCEL);
   }
 
   /**
@@ -478,7 +525,7 @@
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // DATA
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0); // PING
@@ -490,20 +537,242 @@
     BufferedSink out = Okio.buffer(stream.getSink());
     out.writeUtf8("c3po");
     out.close();
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     assertStreamData("robot", stream.getSource());
     connection.writePingAndAwaitPong();
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertFalse(synStream.outFinished);
-    assertEquals(3, synStream.streamId);
-    assertEquals(-1, synStream.associatedStreamId);
-    assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.outFinished).isFalse();
+    assertThat(synStream.streamId).isEqualTo(3);
+    assertThat(synStream.associatedStreamId).isEqualTo(-1);
+    assertThat(synStream.headerBlock).isEqualTo(headerEntries("b", "banana"));
     InFrame requestData = peer.takeFrame();
-    assertTrue(Arrays.equals("c3po".getBytes("UTF-8"), requestData.data));
+    assertArrayEquals("c3po".getBytes(UTF_8), requestData.data);
+  }
+
+  @Test public void serverFinishesStreamWithHeaders() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // PING
+    peer.sendFrame().headers(true, 3, headerEntries("headers", "bam"));
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), false);
+    connection.writePingAndAwaitPong();
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("headers", "bam"));
+    assertThat(stream.trailers()).isEqualTo(EMPTY_HEADERS);
+    assertThat(connection.openStreamCount()).isEqualTo(0);
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.outFinished).isFalse();
+    assertThat(synStream.streamId).isEqualTo(3);
+    assertThat(synStream.associatedStreamId).isEqualTo(-1);
+    assertThat(synStream.headerBlock).isEqualTo(headerEntries("a", "artichaut"));
+  }
+
+  @Test public void serverWritesTrailersAndClientReadsTrailers() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().headers(false, 3, headerEntries("headers", "bam"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().headers(true, 3, headerEntries("trailers", "boom"));
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), false);
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("headers", "bam"));
+    connection.writePingAndAwaitPong();
+    assertThat(stream.trailers()).isEqualTo(Headers.of("trailers", "boom"));
+    assertThat(connection.openStreamCount()).isEqualTo(0);
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.outFinished).isFalse();
+    assertThat(synStream.streamId).isEqualTo(3);
+    assertThat(synStream.associatedStreamId).isEqualTo(-1);
+    assertThat(synStream.headerBlock).isEqualTo(headerEntries("a", "artichaut"));
+  }
+
+  @Test public void serverWritesTrailersWithData() throws Exception {
+    // We buffer some outbound data and headers and confirm that the END_STREAM flag comes with the
+    // headers (and not with the data).
+
+    // write the mocking script for the client
+    peer.setClient(true);
+
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.sendFrame().headers(true, 3, headerEntries("client", "abc"));
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // HEADERS STREAM 3
+    peer.acceptFrame(); // DATA STREAM 3 "abcde"
+    peer.acceptFrame(); // HEADERS STREAM 3
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
+    stream.enqueueTrailers(Headers.of("foo", "bar"));
+    BufferedSink sink = Okio.buffer(stream.getSink());
+    sink.writeUtf8("abcdefghi");
+    sink.close();
+
+    // Verify the peer received what was expected.
+    InFrame headers1 = peer.takeFrame();
+    assertThat(headers1.type).isEqualTo(Http2.TYPE_HEADERS);
+    InFrame data1 = peer.takeFrame();
+    assertThat(data1.type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(data1.streamId).isEqualTo(3);
+    assertArrayEquals("abcdefghi".getBytes(UTF_8), data1.data);
+    assertThat(data1.inFinished).isFalse();
+    InFrame headers2 = peer.takeFrame();
+    assertThat(headers2.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(headers2.inFinished).isTrue();
+  }
+
+  @Test public void clientCannotReadTrailersWithoutExhaustingStream() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().data(false, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.sendFrame().headers(true, 3, headerEntries("trailers", "boom"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), true);
+    connection.writePingAndAwaitPong();
+    try {
+      stream.trailers();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void clientCannotReadTrailersIfTheStreamFailed() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().rstStream(3, ErrorCode.PROTOCOL_ERROR);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), true);
+    connection.writePingAndAwaitPong();
+    try {
+      stream.trailers();
+      fail();
+    } catch (StreamResetException expected) {
+    }
+  }
+
+  @Test public void serverCannotEnqueueTrailersAfterFinishingTheStream() throws Exception {
+    peer.setClient(true);
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // Play it back.
+    Http2Connection connection = connect(peer);
+    connection.writePingAndAwaitPong();
+    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
+    // finish the stream
+    stream.writeHeaders(headerEntries("b", "berserk"), true, false);
+    try {
+      stream.enqueueTrailers(Headers.of("trailers", "boom"));
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test public void noTrailersFrameYieldsEmptyTrailers() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().headers(false, 3, headerEntries("headers", "bam"));
+    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PONG
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), false);
+    BufferedSource source = Okio.buffer(stream.getSource());
+    connection.writePingAndAwaitPong();
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("headers", "bam"));
+    assertThat(source.readUtf8(5)).isEqualTo("robot");
+    assertThat(stream.trailers()).isEqualTo(EMPTY_HEADERS);
+    assertThat(connection.openStreamCount()).isEqualTo(0);
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.outFinished).isFalse();
+    assertThat(synStream.streamId).isEqualTo(3);
+    assertThat(synStream.associatedStreamId).isEqualTo(-1);
+    assertThat(synStream.headerBlock).isEqualTo(headerEntries("a", "artichaut"));
+  }
+
+  @Test public void serverReadsHeadersDataHeaders() throws Exception {
+    // write the mocking script
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // HEADERS
+    peer.sendFrame().headers(true, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0); // PING
+    peer.play();
+
+    // play it back
+    Http2Connection connection = connect(peer);
+    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.writeUtf8("c3po");
+    out.close();
+    stream.writeHeaders(headerEntries("e", "elephant"), false, false);
+    connection.writePingAndAwaitPong();
+    assertThat(connection.openStreamCount()).isEqualTo(0);
+
+    // verify the peer received what was expected
+    InFrame synStream = peer.takeFrame();
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.outFinished).isFalse();
+    assertThat(synStream.streamId).isEqualTo(3);
+    assertThat(synStream.associatedStreamId).isEqualTo(-1);
+    assertThat(synStream.headerBlock).isEqualTo(headerEntries("b", "banana"));
+    InFrame requestData = peer.takeFrame();
+    assertArrayEquals("c3po".getBytes(UTF_8), requestData.data);
+
+    InFrame nextFrame = peer.takeFrame();
+    assertThat(nextFrame.headerBlock).isEqualTo(headerEntries("e", "elephant"));
   }
 
   @Test public void clientCreatesStreamAndServerRepliesWithFin() throws Exception {
@@ -512,22 +781,22 @@
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(true, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(true, 3, headerEntries("a", "android"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     Http2Connection connection = connect(peer);
     connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(1, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(1);
     connection.writePingAndAwaitPong(); // Ensure that the SYN_REPLY has been received.
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
   }
 
   @Test public void serverPingsClient() throws Exception {
@@ -543,10 +812,10 @@
 
     // verify the peer received what was expected
     InFrame ping = peer.takeFrame();
-    assertEquals(0, ping.streamId);
-    assertEquals(2, ping.payload1);
-    assertEquals(0, ping.payload2);
-    assertTrue(ping.ack);
+    assertThat(ping.streamId).isEqualTo(0);
+    assertThat(ping.payload1).isEqualTo(2);
+    assertThat(ping.payload2).isEqualTo(0);
+    assertThat(ping.ack).isTrue();
   }
 
   @Test public void clientPingsServer() throws Exception {
@@ -562,16 +831,18 @@
     long pingAtNanos = System.nanoTime();
     connection.writePingAndAwaitPong();
     long elapsedNanos = System.nanoTime() - pingAtNanos;
-    assertTrue(elapsedNanos > 0);
-    assertTrue(elapsedNanos < TimeUnit.SECONDS.toNanos(1));
+    assertThat(elapsedNanos).isGreaterThan(0L);
+    assertThat(elapsedNanos).isLessThan(TimeUnit.SECONDS.toNanos(1));
 
     // verify the peer received what was expected
     InFrame pingFrame = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, pingFrame.type);
-    assertEquals(0, pingFrame.streamId);
-    assertEquals(0x4f4b6f6b, pingFrame.payload1); // OkOk
-    assertEquals(0xf09f8da9, pingFrame.payload2); // donut
-    assertFalse(pingFrame.ack);
+    assertThat(pingFrame.type).isEqualTo(Http2.TYPE_PING);
+    assertThat(pingFrame.streamId).isEqualTo(0);
+    // OkOk
+    assertThat(pingFrame.payload1).isEqualTo(0x4f4b6f6b);
+    // donut
+    assertThat(pingFrame.payload2).isEqualTo(0xf09f8da9);
+    assertThat(pingFrame.ack).isFalse();
   }
 
   @Test public void unexpectedPingIsNotReturned() throws Exception {
@@ -590,9 +861,9 @@
 
     // verify the peer received what was expected
     InFrame ping2 = peer.takeFrame();
-    assertEquals(2, ping2.payload1);
+    assertThat(ping2.payload1).isEqualTo(2);
     InFrame ping4 = peer.takeFrame();
-    assertEquals(4, ping4.payload1);
+    assertThat(ping4.payload1).isEqualTo(4);
   }
 
   @Test public void serverSendsSettingsToClient() throws Exception {
@@ -621,10 +892,10 @@
     Http2Connection connection = connect(peer, IGNORE, listener);
 
     synchronized (connection) {
-      assertEquals(10, connection.peerSettings.getMaxConcurrentStreams(-1));
+      assertThat(connection.peerSettings.getMaxConcurrentStreams(-1)).isEqualTo(10);
     }
     maxConcurrentStreamsUpdated.await();
-    assertEquals(10, maxConcurrentStreams.get());
+    assertThat(maxConcurrentStreams.get()).isEqualTo(10);
   }
 
   @Test public void multipleSettingsFramesAreMerged() throws Exception {
@@ -648,13 +919,13 @@
     // play it back
     Http2Connection connection = connect(peer);
 
-    assertEquals(Http2.TYPE_SETTINGS, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_SETTINGS);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
     synchronized (connection) {
-      assertEquals(10000, connection.peerSettings.getHeaderTableSize());
-      assertEquals(40000, connection.peerSettings.getInitialWindowSize());
-      assertEquals(50000, connection.peerSettings.getMaxFrameSize(-1));
-      assertEquals(60000, connection.peerSettings.getMaxConcurrentStreams(-1));
+      assertThat(connection.peerSettings.getHeaderTableSize()).isEqualTo(10000);
+      assertThat(connection.peerSettings.getInitialWindowSize()).isEqualTo(40000);
+      assertThat(connection.peerSettings.getMaxFrameSize(-1)).isEqualTo(50000);
+      assertThat(connection.peerSettings.getMaxConcurrentStreams(-1)).isEqualTo(60000);
     }
   }
 
@@ -679,10 +950,11 @@
     connection.readerRunnable.settings(true, settings2);
 
     synchronized (connection) {
-      assertEquals(-1, connection.peerSettings.getHeaderTableSize());
-      assertEquals(DEFAULT_INITIAL_WINDOW_SIZE, connection.peerSettings.getInitialWindowSize());
-      assertEquals(-1, connection.peerSettings.getMaxFrameSize(-1));
-      assertEquals(60000, connection.peerSettings.getMaxConcurrentStreams(-1));
+      assertThat(connection.peerSettings.getHeaderTableSize()).isEqualTo(-1);
+      assertThat(connection.peerSettings.getInitialWindowSize()).isEqualTo(
+          (long) DEFAULT_INITIAL_WINDOW_SIZE);
+      assertThat(connection.peerSettings.getMaxFrameSize(-1)).isEqualTo(-1);
+      assertThat(connection.peerSettings.getMaxConcurrentStreams(-1)).isEqualTo(60000);
     }
   }
 
@@ -701,18 +973,18 @@
 
     // verify the peer received what was expected
     InFrame rstStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
-    assertEquals(41, rstStream.streamId);
-    assertEquals(ErrorCode.PROTOCOL_ERROR, rstStream.errorCode);
+    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
+    assertThat(rstStream.streamId).isEqualTo(41);
+    assertThat(rstStream.errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
     InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.payload1);
+    assertThat(ping.payload1).isEqualTo(2);
   }
 
   @Test public void bogusReplySilentlyIgnored() throws Exception {
     // write the mocking script
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
-    peer.sendFrame().synReply(false, 41, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 41, headerEntries("a", "android"));
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
     peer.play();
@@ -722,7 +994,7 @@
 
     // verify the peer received what was expected
     InFrame ping = peer.takeFrame();
-    assertEquals(2, ping.payload1);
+    assertThat(ping.payload1).isEqualTo(2);
   }
 
   @Test public void serverClosesClientOutputStream() throws Exception {
@@ -745,7 +1017,7 @@
       out.flush();
       fail();
     } catch (IOException expected) {
-      assertEquals("stream was reset: CANCEL", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream was reset: CANCEL");
     }
     try {
       out.close();
@@ -753,15 +1025,15 @@
     } catch (IOException expected) {
       // Close throws because buffered data wasn't flushed.
     }
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertFalse(synStream.inFinished);
-    assertFalse(synStream.outFinished);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.inFinished).isFalse();
+    assertThat(synStream.outFinished).isFalse();
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
   }
 
   /**
@@ -785,25 +1057,25 @@
       in.read(new Buffer(), 1);
       fail();
     } catch (IOException expected) {
-      assertEquals("stream closed", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream closed");
     }
     try {
       out.writeUtf8("a");
       out.flush();
       fail();
     } catch (IOException expected) {
-      assertEquals("stream finished", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream finished");
     }
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertTrue(synStream.inFinished);
-    assertFalse(synStream.outFinished);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.inFinished).isTrue();
+    assertThat(synStream.outFinished).isFalse();
     InFrame rstStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
-    assertEquals(ErrorCode.CANCEL, rstStream.errorCode);
+    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
+    assertThat(rstStream.errorCode).isEqualTo(ErrorCode.CANCEL);
   }
 
   /**
@@ -829,28 +1101,28 @@
       source.read(new Buffer(), 1);
       fail();
     } catch (IOException expected) {
-      assertEquals("stream closed", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream closed");
     }
     out.writeUtf8("square");
     out.flush();
     out.close();
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertFalse(synStream.inFinished);
-    assertFalse(synStream.outFinished);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.inFinished).isFalse();
+    assertThat(synStream.outFinished).isFalse();
     InFrame data = peer.takeFrame();
-    assertEquals(Http2.TYPE_DATA, data.type);
-    assertTrue(Arrays.equals("square".getBytes("UTF-8"), data.data));
+    assertThat(data.type).isEqualTo(Http2.TYPE_DATA);
+    assertArrayEquals("square".getBytes(UTF_8), data.data);
     InFrame fin = peer.takeFrame();
-    assertEquals(Http2.TYPE_DATA, fin.type);
-    assertTrue(fin.inFinished);
-    assertFalse(fin.outFinished);
+    assertThat(fin.type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(fin.inFinished).isTrue();
+    assertThat(fin.outFinished).isFalse();
     InFrame rstStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
-    assertEquals(ErrorCode.CANCEL, rstStream.errorCode);
+    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
+    assertThat(rstStream.errorCode).isEqualTo(ErrorCode.CANCEL);
   }
 
   @Test public void serverClosesClientInputStream() throws Exception {
@@ -858,7 +1130,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().headers(false, 3, headerEntries("b", "banana"));
     peer.sendFrame().data(true, 3, new Buffer().writeUtf8("square"), 6);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
@@ -870,13 +1142,13 @@
     Source source = stream.getSource();
     assertStreamData("square", source);
     connection.writePingAndAwaitPong(); // Ensure that inFinished has been received.
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertTrue(synStream.inFinished);
-    assertFalse(synStream.outFinished);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(synStream.inFinished).isTrue();
+    assertThat(synStream.outFinished).isFalse();
   }
 
   @Test public void remoteDoubleSynReply() throws Exception {
@@ -884,23 +1156,23 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().headers(false, 3, headerEntries("b", "banana"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("c", "cola"), false);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     connection.writePingAndAwaitPong(); // Ensure that the 2nd SYN REPLY has been received.
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
   }
 
   @Test public void remoteSendsDataAfterInFinished() throws Exception {
@@ -908,7 +1180,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
     peer.sendFrame().data(true, 3, new Buffer().writeUtf8("c3po"), 4);
     peer.acceptFrame(); // RST_STREAM
@@ -919,18 +1191,18 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     assertStreamData("robot", stream.getSource());
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame rstStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
-    assertEquals(3, rstStream.streamId);
+    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
+    assertThat(rstStream.streamId).isEqualTo(3);
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
-    assertEquals(2, ping.payload1);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
+    assertThat(ping.payload1).isEqualTo(2);
   }
 
   @Test public void clientDoesNotLimitFlowControl() throws Exception {
@@ -939,7 +1211,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().headers(false, 3, headerEntries("b", "banana"));
     peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
     peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
     peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
@@ -952,14 +1224,14 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    assertEquals(headerEntries("b", "banana"), stream.takeResponseHeaders());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("b", "banana"));
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
-    assertEquals(2, ping.payload1);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
+    assertThat(ping.payload1).isEqualTo(2);
   }
 
   @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
@@ -976,19 +1248,19 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     try {
-      stream.takeResponseHeaders();
+      stream.takeHeaders();
       fail();
     } catch (IOException expected) {
-      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream was reset: REFUSED_STREAM");
     }
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
-    assertEquals(2, ping.payload1);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
+    assertThat(ping.payload1).isEqualTo(2);
   }
 
   @Test public void receiveGoAway() throws Exception {
@@ -1016,7 +1288,7 @@
       sink2.flush();
       fail();
     } catch (IOException expected) {
-      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream was reset: REFUSED_STREAM");
     }
     sink1.writeUtf8("def");
     sink1.close();
@@ -1025,21 +1297,21 @@
       fail();
     } catch (ConnectionShutdownException expected) {
     }
-    assertTrue(stream1.isOpen());
-    assertFalse(stream2.isOpen());
-    assertEquals(1, connection.openStreamCount());
+    assertThat(stream1.isOpen()).isTrue();
+    assertThat(stream2.isOpen()).isFalse();
+    assertThat(connection.openStreamCount()).isEqualTo(1);
 
     // verify the peer received what was expected
     InFrame synStream1 = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream1.type);
+    assertThat(synStream1.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame synStream2 = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream2.type);
+    assertThat(synStream2.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
     InFrame data1 = peer.takeFrame();
-    assertEquals(Http2.TYPE_DATA, data1.type);
-    assertEquals(3, data1.streamId);
-    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
+    assertThat(data1.type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(data1.streamId).isEqualTo(3);
+    assertArrayEquals("abcdef".getBytes(UTF_8), data1.data);
   }
 
   @Test public void sendGoAway() throws Exception {
@@ -1049,7 +1321,7 @@
     peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // GOAWAY
     peer.acceptFrame(); // PING
-    peer.sendFrame().synStream(false, 2, 0, headerEntries("b", "b")); // Should be ignored!
+    peer.sendFrame().headers(false, 2, headerEntries("b", "b")); // Should be ignored!
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
@@ -1063,18 +1335,18 @@
     }
     connection.writePing(false, 0x01, 0x02);
     connection.shutdown(ErrorCode.PROTOCOL_ERROR);
-    assertEquals(1, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(1);
     connection.awaitPong(); // Prevent the peer from exiting prematurely.
 
     // verify the peer received what was expected
     InFrame synStream1 = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream1.type);
+    assertThat(synStream1.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame pingFrame = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, pingFrame.type);
+    assertThat(pingFrame.type).isEqualTo(Http2.TYPE_PING);
     InFrame goaway = peer.takeFrame();
-    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
-    assertEquals(0, goaway.streamId);
-    assertEquals(ErrorCode.PROTOCOL_ERROR, goaway.errorCode);
+    assertThat(goaway.type).isEqualTo(Http2.TYPE_GOAWAY);
+    assertThat(goaway.streamId).isEqualTo(0);
+    assertThat(goaway.errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
   }
 
   @Test public void close() throws Exception {
@@ -1089,9 +1361,9 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    assertEquals(1, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(1);
     connection.close();
-    assertEquals(0, connection.openStreamCount());
+    assertThat(connection.openStreamCount()).isEqualTo(0);
     try {
       connection.newStream(headerEntries("b", "banana"), false);
       fail();
@@ -1103,23 +1375,23 @@
       sink.flush();
       fail();
     } catch (IOException expected) {
-      assertEquals("stream finished", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream finished");
     }
     try {
       stream.getSource().read(new Buffer(), 1);
       fail();
     } catch (IOException expected) {
-      assertEquals("stream was reset: CANCEL", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("stream was reset: CANCEL");
     }
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame goaway = peer.takeFrame();
-    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
+    assertThat(goaway.type).isEqualTo(Http2.TYPE_GOAWAY);
     InFrame rstStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_RST_STREAM, rstStream.type);
-    assertEquals(3, rstStream.streamId);
+    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
+    assertThat(rstStream.streamId).isEqualTo(3);
   }
 
   @Test public void getResponseHeadersTimesOut() throws Exception {
@@ -1136,18 +1408,19 @@
     stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
     long startNanos = System.nanoTime();
     try {
-      stream.takeResponseHeaders();
+      stream.takeHeaders();
       fail();
     } catch (InterruptedIOException expected) {
     }
     long elapsedNanos = System.nanoTime() - startNanos;
     awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
+    /* 200ms delta */
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(500d, offset(200d));
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_RST_STREAM);
   }
 
   @Test public void readTimesOut() throws Exception {
@@ -1155,7 +1428,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
@@ -1172,12 +1445,13 @@
     }
     long elapsedNanos = System.nanoTime() - startNanos;
     awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
+    /* 200ms delta */
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(500d, offset(200d));
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_RST_STREAM);
   }
 
   @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
@@ -1190,7 +1464,7 @@
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // DATA
     peer.acceptFrame(); // RST_STREAM
     peer.play();
@@ -1211,14 +1485,15 @@
     }
     long elapsedNanos = System.nanoTime() - startNanos;
     awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
+    /* 200ms delta */
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(500d, offset(200d));
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
-    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_RST_STREAM);
   }
 
   @Test public void writeTimesOutAwaitingConnectionWindow() throws Exception {
@@ -1232,7 +1507,7 @@
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 3, 0);
     peer.acceptFrame(); // DATA
@@ -1255,15 +1530,16 @@
     }
     long elapsedNanos = System.nanoTime() - startNanos;
     awaitWatchdogIdle();
-    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(0, connection.openStreamCount());
+    /* 200ms delta */
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(500d, offset(200d));
+    assertThat(connection.openStreamCount()).isEqualTo(0);
 
     // verify the peer received what was expected
-    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_RST_STREAM, peer.takeFrame().type);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_RST_STREAM);
   }
 
   @Test public void outgoingWritesAreBatched() throws Exception {
@@ -1271,7 +1547,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // DATA
     peer.play();
 
@@ -1286,11 +1562,11 @@
     sink.close();
 
     // verify the peer received one incoming frame
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame data = peer.takeFrame();
-    assertEquals(Http2.TYPE_DATA, data.type);
-    assertTrue(Arrays.equals("abcdefghij".getBytes("UTF-8"), data.data));
-    assertTrue(data.inFinished);
+    assertThat(data.type).isEqualTo(Http2.TYPE_DATA);
+    assertArrayEquals("abcdefghij".getBytes(UTF_8), data.data);
+    assertThat(data.inFinished).isTrue();
   }
 
   @Test public void headers() throws Exception {
@@ -1299,8 +1575,8 @@
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().headers(3, headerEntries("c", "c3po"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("c", "c3po"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
@@ -1308,14 +1584,14 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     connection.writePingAndAwaitPong(); // Ensure that the HEADERS has been received.
-    assertEquals(Arrays.asList(new Header("a", "android"), null, new Header("c", "c3po")),
-        stream.takeResponseHeaders());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("c", "c3po"));
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame ping = peer.takeFrame();
-    assertEquals(Http2.TYPE_PING, ping.type);
+    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
   }
 
   @Test public void readMultipleSetsOfResponseHeaders() throws Exception {
@@ -1323,23 +1599,23 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0); // PING
-    peer.sendFrame().synReply(true, 3, headerEntries("c", "cola"));
+    peer.sendFrame().headers(true, 3, headerEntries("c", "cola"));
+    peer.sendFrame().ping(true, 1, 0); // PONG
     peer.play();
 
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     stream.getConnection().flush();
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     connection.writePingAndAwaitPong();
-    assertEquals(headerEntries("c", "cola"), stream.takeResponseHeaders());
+    assertThat(stream.trailers()).isEqualTo(Headers.of("c", "cola"));
 
     // verify the peer received what was expected
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_PING, peer.takeFrame().type);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
   }
 
   @Test public void readSendsWindowUpdate() throws Exception {
@@ -1350,7 +1626,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     for (int i = 0; i < 3; i++) {
       // Send frames of summing to size 50, which is windowUpdateThreshold.
       peer.sendFrame().data(false, 3, data(24), 24);
@@ -1366,26 +1642,28 @@
     Http2Connection connection = connect(peer);
     connection.okHttpSettings.set(INITIAL_WINDOW_SIZE, windowSize);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(0, stream.unacknowledgedBytesRead);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertThat(stream.unacknowledgedBytesRead).isEqualTo(0);
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
     buffer.writeAll(in);
-    assertEquals(-1, in.read(buffer, 1));
-    assertEquals(150, buffer.size());
+    assertThat(in.read(buffer, 1)).isEqualTo(-1);
+    assertThat(buffer.size()).isEqualTo(150);
 
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     for (int i = 0; i < 3; i++) {
       List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
       for (int j = 0; j < 2; j++) {
         InFrame windowUpdate = peer.takeFrame();
-        assertEquals(Http2.TYPE_WINDOW_UPDATE, windowUpdate.type);
+        assertThat(windowUpdate.type).isEqualTo(Http2.TYPE_WINDOW_UPDATE);
         windowUpdateStreamIds.add(windowUpdate.streamId);
-        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+        assertThat(windowUpdate.windowSizeIncrement).isEqualTo(windowUpdateThreshold);
       }
-      assertTrue(windowUpdateStreamIds.contains(0)); // connection
-      assertTrue(windowUpdateStreamIds.contains(3)); // stream
+      // connection
+      assertThat(windowUpdateStreamIds).contains(0);
+      // stream
+      assertThat(windowUpdateStreamIds).contains(3);
     }
   }
 
@@ -1394,19 +1672,19 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(true, 3, data(0), 0);
     peer.play();
 
     // Play it back.
     Http2Connection connection = connect(peer);
     Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+    assertThat(client.getSource().read(new Buffer(), 1)).isEqualTo(-1);
 
     // Verify the peer received what was expected.
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
-    assertEquals(5, peer.frameCount());
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.frameCount()).isEqualTo(5);
   }
 
   @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
@@ -1415,7 +1693,7 @@
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // DATA
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.play();
 
     // Play it back.
@@ -1427,9 +1705,9 @@
     out.close();
 
     // Verify the peer received what was expected.
-    assertEquals(Http2.TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(Http2.TYPE_DATA, peer.takeFrame().type);
-    assertEquals(5, peer.frameCount());
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
+    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_DATA);
+    assertThat(peer.frameCount()).isEqualTo(5);
   }
 
   @Test public void testTruncatedDataFrame() throws Exception {
@@ -1437,7 +1715,7 @@
     peer.sendFrame().settings(new Settings());
     peer.acceptFrame(); // ACK
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.sendFrame().data(false, 3, data(1024), 1024);
     peer.truncateLastFrame(8 + 100);
     peer.play();
@@ -1445,13 +1723,12 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
+    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
     Source in = stream.getSource();
     try {
       Okio.buffer(in).readByteString(101);
       fail();
-    } catch (IOException expected) {
-      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
+    } catch (EOFException expected) {
     }
   }
 
@@ -1477,14 +1754,14 @@
     out1.flush();
 
     // Check that we've filled the window for both the stream and also the connection.
-    assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+    assertThat(connection.bytesLeftInWriteWindow).isEqualTo(0);
+    assertThat(connection.getStream(3).bytesLeftInWriteWindow).isEqualTo(0);
 
     // receiving a window update on the connection will unblock new streams.
     connection.readerRunnable.windowUpdate(0, 3);
 
-    assertEquals(3, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+    assertThat(connection.bytesLeftInWriteWindow).isEqualTo(3);
+    assertThat(connection.getStream(3).bytesLeftInWriteWindow).isEqualTo(0);
 
     // Another stream should be able to send data even though 1 is blocked.
     Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
@@ -1492,15 +1769,16 @@
     out2.writeUtf8("foo");
     out2.flush();
 
-    assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
-    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE - 3, connection.getStream(5).bytesLeftInWriteWindow);
+    assertThat(connection.bytesLeftInWriteWindow).isEqualTo(0);
+    assertThat(connection.getStream(3).bytesLeftInWriteWindow).isEqualTo(0);
+    assertThat(connection.getStream(5).bytesLeftInWriteWindow).isEqualTo(
+        (long) (DEFAULT_INITIAL_WINDOW_SIZE - 3));
   }
 
   @Test public void remoteOmitsInitialSettings() throws Exception {
     // Write the mocking script. Note no SETTINGS frame is sent or acknowledged.
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
     peer.acceptFrame(); // GOAWAY
     peer.play();
 
@@ -1511,18 +1789,18 @@
 
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
     try {
-      stream.takeResponseHeaders();
+      stream.takeHeaders();
       fail();
     } catch (IOException expected) {
-      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("Expected a SETTINGS frame but was 1");
     }
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
-    assertEquals(Http2.TYPE_HEADERS, synStream.type);
+    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
     InFrame goaway = peer.takeFrame();
-    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
-    assertEquals(ErrorCode.PROTOCOL_ERROR, goaway.errorCode);
+    assertThat(goaway.type).isEqualTo(Http2.TYPE_GOAWAY);
+    assertThat(goaway.errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
   }
 
   private Buffer data(int byteCount) {
@@ -1531,7 +1809,12 @@ private Buffer data(int byteCount) {
 
   private void assertStreamData(String expected, Source source) throws IOException {
     String actual = Okio.buffer(source).readUtf8();
-    assertEquals(expected, actual);
+    assertThat(actual).isEqualTo(expected);
+  }
+
+  /** Reads {@code prefix} from {@code source}. */
+  private void assertStreamPrefix(String prefix, BufferedSource source) throws IOException {
+    assertThat(source.readUtf8(Utf8.size(prefix))).isEqualTo(prefix);
   }
 
   /**
@@ -1539,7 +1822,7 @@ private void assertStreamData(String expected, Source source) throws IOException
    * creates more work for the watchdog and waits for that work to be executed. When it is, we know
    * work that preceded this call is complete.
    */
-  private void awaitWatchdogIdle() throws InterruptedException {
+  private void awaitWatchdogIdle() throws Exception {
     final CountDownLatch latch = new CountDownLatch(1);
     AsyncTimeout watchdogJob = new AsyncTimeout() {
       @Override protected void timedOut() {
@@ -1579,9 +1862,9 @@ private Http2Connection connect(MockHttp2Peer peer, PushObserver pushObserver,
 
     // verify the peer received the ACK
     InFrame ackFrame = peer.takeFrame();
-    assertEquals(Http2.TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
+    assertThat(ackFrame.type).isEqualTo(Http2.TYPE_SETTINGS);
+    assertThat(ackFrame.streamId).isEqualTo(0);
+    assertThat(ackFrame.ack).isTrue();
 
     return connection;
   }
@@ -1609,7 +1892,7 @@ private Http2Connection connect(MockHttp2Peer peer, PushObserver pushObserver,
   private static class RecordingPushObserver implements PushObserver {
     final List<Object> events = new ArrayList<>();
 
-    public synchronized Object takeEvent() throws InterruptedException {
+    public synchronized Object takeEvent() throws Exception {
       while (events.isEmpty()) {
         wait();
       }
@@ -1617,7 +1900,7 @@ public synchronized Object takeEvent() throws InterruptedException {
     }
 
     @Override public synchronized boolean onRequest(int streamId, List<Header> requestHeaders) {
-      assertEquals(2, streamId);
+      assertThat(streamId).isEqualTo(2);
       events.add(requestHeaders);
       notifyAll();
       return false;
@@ -1625,8 +1908,8 @@ public synchronized Object takeEvent() throws InterruptedException {
 
     @Override public synchronized boolean onHeaders(
         int streamId, List<Header> responseHeaders, boolean last) {
-      assertEquals(2, streamId);
-      assertTrue(last);
+      assertThat(streamId).isEqualTo(2);
+      assertThat(last).isTrue();
       events.add(responseHeaders);
       notifyAll();
       return false;
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java b/okhttp/src/test/java/okhttp3/internal/http2/Http2Test.java
similarity index 81%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
rename to okhttp/src/test/java/okhttp3/internal/http2/Http2Test.java
index 24ec759c2d..bce4c34858 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/Http2Test.java
@@ -28,6 +28,7 @@
 import okio.Okio;
 import org.junit.Test;
 
+import static java.util.Arrays.asList;
 import static okhttp3.TestUtil.headerEntries;
 import static okhttp3.internal.http2.Http2.FLAG_COMPRESSED;
 import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
@@ -35,9 +36,7 @@
 import static okhttp3.internal.http2.Http2.FLAG_NONE;
 import static okhttp3.internal.http2.Http2.FLAG_PADDED;
 import static okhttp3.internal.http2.Http2.FLAG_PRIORITY;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class Http2Test {
@@ -65,15 +64,16 @@
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBytes);
 
-    assertEquals(frame, sendHeaderFrames(true, sentHeaders)); // Check writer sends the same bytes.
+    // Check writer sends the same bytes.
+    assertThat(sendHeaderFrames(true, sentHeaders)).isEqualTo(frame);
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void headers(boolean inFinished, int streamId,
           int associatedStreamId, List<Header> headerBlock) {
-        assertTrue(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(sentHeaders, headerBlock);
+        assertThat(inFinished).isTrue();
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(associatedStreamId).isEqualTo(-1);
+        assertThat(headerBlock).isEqualTo(sentHeaders);
       }
     });
   }
@@ -93,17 +93,17 @@
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void priority(int streamId, int streamDependency, int weight,
           boolean exclusive) {
-        assertEquals(0, streamDependency);
-        assertEquals(256, weight);
-        assertFalse(exclusive);
+        assertThat(streamDependency).isEqualTo(0);
+        assertThat(weight).isEqualTo(256);
+        assertThat(exclusive).isFalse();
       }
 
       @Override public void headers(boolean inFinished, int streamId,
           int associatedStreamId, List<Header> nameValueBlock) {
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(sentHeaders, nameValueBlock);
+        assertThat(inFinished).isFalse();
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(associatedStreamId).isEqualTo(-1);
+        assertThat(nameValueBlock).isEqualTo(sentHeaders);
       }
     });
   }
@@ -128,16 +128,17 @@
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBlock);
 
-    assertEquals(frame, sendHeaderFrames(false, sentHeaders)); // Check writer sends the same bytes.
+    // Check writer sends the same bytes.
+    assertThat(sendHeaderFrames(false, sentHeaders)).isEqualTo(frame);
 
     // Reading the above frames should result in a concatenated headerBlock.
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void headers(boolean inFinished, int streamId,
           int associatedStreamId, List<Header> headerBlock) {
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(sentHeaders, headerBlock);
+        assertThat(inFinished).isFalse();
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(associatedStreamId).isEqualTo(-1);
+        assertThat(headerBlock).isEqualTo(sentHeaders);
       }
     });
   }
@@ -145,7 +146,7 @@
   @Test public void pushPromise() throws IOException {
     final int expectedPromisedStreamId = 11;
 
-    final List<Header> pushPromise = Arrays.asList(
+    final List<Header> pushPromise = asList(
         new Header(Header.TARGET_METHOD, "GET"),
         new Header(Header.TARGET_SCHEME, "https"),
         new Header(Header.TARGET_AUTHORITY, "squareup.com"),
@@ -161,14 +162,15 @@
     frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
     frame.writeAll(headerBytes);
 
-    assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
+    assertThat(sendPushPromiseFrames(expectedPromisedStreamId, pushPromise)).isEqualTo(
+        frame);
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override
       public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(expectedPromisedStreamId, promisedStreamId);
-        assertEquals(pushPromise, headerBlock);
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(promisedStreamId).isEqualTo(expectedPromisedStreamId);
+        assertThat(headerBlock).isEqualTo(pushPromise);
       }
     });
   }
@@ -196,15 +198,16 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(expectedStreamId & 0x7fffffff);
     frame.writeAll(headerBlock);
 
-    assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
+    assertThat(sendPushPromiseFrames(expectedPromisedStreamId, pushPromise)).isEqualTo(
+        frame);
 
     // Reading the above frames should result in a concatenated headerBlock.
     reader.nextFrame(false, new BaseTestHandler() {
       @Override
       public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(expectedPromisedStreamId, promisedStreamId);
-        assertEquals(pushPromise, headerBlock);
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(promisedStreamId).isEqualTo(expectedPromisedStreamId);
+        assertThat(headerBlock).isEqualTo(pushPromise);
       }
     });
   }
@@ -218,8 +221,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void rstStream(int streamId, ErrorCode errorCode) {
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(ErrorCode.PROTOCOL_ERROR, errorCode);
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
       }
     });
   }
@@ -238,9 +241,10 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void settings(boolean clearPrevious, Settings settings) {
-        assertFalse(clearPrevious); // No clearPrevious in HTTP/2.
-        assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
-        assertEquals(false, settings.getEnablePush(true));
+        // No clearPrevious in HTTP/2.
+        assertThat(clearPrevious).isFalse();
+        assertThat(settings.getHeaderTableSize()).isEqualTo(reducedTableSizeBytes);
+        assertThat(settings.getEnablePush(true)).isFalse();
       }
     });
   }
@@ -257,7 +261,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
     }
   }
 
@@ -275,7 +279,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
         settingValue.set(settings.get(7));
       }
     });
-    assertEquals(settingValue.intValue(), 1);
+    assertThat(1).isEqualTo(settingValue.intValue());
   }
 
   @Test public void readSettingsFrameExperimentalId() throws IOException {
@@ -305,7 +309,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
     }
   }
 
@@ -321,7 +326,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: -2147483648", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: -2147483648");
     }
   }
 
@@ -337,7 +343,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16383", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16383");
     }
   }
 
@@ -353,7 +359,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16777216", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16777216");
     }
   }
 
@@ -369,13 +376,13 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(expectedPayload2);
 
     // Check writer sends the same bytes.
-    assertEquals(frame, sendPingFrame(true, expectedPayload1, expectedPayload2));
+    assertThat(sendPingFrame(true, expectedPayload1, expectedPayload2)).isEqualTo(frame);
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void ping(boolean ack, int payload1, int payload2) {
-        assertTrue(ack);
-        assertEquals(expectedPayload1, payload1);
-        assertEquals(expectedPayload2, payload2);
+        assertThat(ack).isTrue();
+        assertThat(payload1).isEqualTo(expectedPayload1);
+        assertThat(payload2).isEqualTo(expectedPayload2);
       }
     });
   }
@@ -391,17 +398,17 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.write(expectedData);
 
     // Check writer sends the same bytes.
-    assertEquals(frame, sendDataFrame(new Buffer().write(expectedData)));
+    assertThat(sendDataFrame(new Buffer().write(expectedData))).isEqualTo(frame);
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void data(boolean inFinished, int streamId, BufferedSource source,
           int length) throws IOException {
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(Http2.INITIAL_MAX_FRAME_SIZE, length);
+        assertThat(inFinished).isFalse();
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(length).isEqualTo(Http2.INITIAL_MAX_FRAME_SIZE);
         ByteString data = source.readByteString(length);
         for (byte b : data.toByteArray()) {
-          assertEquals(2, b);
+          assertThat(b).isEqualTo((byte) 2);
         }
       }
     });
@@ -420,7 +427,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR: TYPE_DATA streamId == 0", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("PROTOCOL_ERROR: TYPE_DATA streamId == 0");
     }
   }
 
@@ -441,8 +448,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       reader.nextFrame(false, new BaseTestHandler());
       fail();
     } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA",
-          e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
     }
   }
 
@@ -464,7 +471,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.write(padding);
 
     reader.nextFrame(false, assertData());
-    assertTrue(frame.exhausted()); // Padding was skipped.
+    // Padding was skipped.
+    assertThat(frame.exhausted()).isTrue();
   }
 
   @Test public void readPaddedDataFrameZeroPadding() throws IOException {
@@ -497,7 +505,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.write(padding);
 
     reader.nextFrame(false, assertHeaderBlock());
-    assertTrue(frame.exhausted()); // Padding was skipped.
+    // Padding was skipped.
+    assertThat(frame.exhausted()).isTrue();
   }
 
   @Test public void readPaddedHeadersFrameZeroPadding() throws IOException {
@@ -538,7 +547,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeAll(headerBlock);
 
     reader.nextFrame(false, assertHeaderBlock());
-    assertTrue(frame.exhausted());
+    assertThat(frame.exhausted()).isTrue();
   }
 
   @Test public void tooLargeDataFrame() throws IOException {
@@ -546,7 +555,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       sendDataFrame(new Buffer().write(new byte[0x1000000]));
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("FRAME_SIZE_ERROR length > 16384: 16777216", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("FRAME_SIZE_ERROR length > 16384: 16777216");
     }
   }
 
@@ -560,12 +569,12 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt((int) expectedWindowSizeIncrement);
 
     // Check writer sends the same bytes.
-    assertEquals(frame, windowUpdate(expectedWindowSizeIncrement));
+    assertThat(windowUpdate(expectedWindowSizeIncrement)).isEqualTo(frame);
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(windowSizeIncrement).isEqualTo(expectedWindowSizeIncrement);
       }
     });
   }
@@ -575,15 +584,15 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       windowUpdate(0);
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 0",
-          e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 0");
     }
     try {
       windowUpdate(0x80000000L);
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 2147483648",
-          e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 2147483648");
     }
   }
 
@@ -598,14 +607,15 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.writeInt(expectedError.httpCode);
 
     // Check writer sends the same bytes.
-    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
+    assertThat(sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY)).isEqualTo(
+        frame);
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void goAway(
           int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-        assertEquals(expectedStreamId, lastGoodStreamId);
-        assertEquals(expectedError, errorCode);
-        assertEquals(0, debugData.size());
+        assertThat(lastGoodStreamId).isEqualTo(expectedStreamId);
+        assertThat(errorCode).isEqualTo(expectedError);
+        assertThat(debugData.size()).isEqualTo(0);
       }
     });
   }
@@ -624,14 +634,14 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     frame.write(expectedData.toByteArray());
 
     // Check writer sends the same bytes.
-    assertEquals(frame, sendGoAway(0, expectedError, expectedData.toByteArray()));
+    assertThat(sendGoAway(0, expectedError, expectedData.toByteArray())).isEqualTo(frame);
 
     reader.nextFrame(false, new BaseTestHandler() {
       @Override public void goAway(
           int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-        assertEquals(0, lastGoodStreamId);
-        assertEquals(expectedError, errorCode);
-        assertEquals(expectedData, debugData);
+        assertThat(lastGoodStreamId).isEqualTo(0);
+        assertThat(errorCode).isEqualTo(expectedError);
+        assertThat(debugData).isEqualTo(expectedData);
       }
     });
   }
@@ -644,7 +654,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       fail();
     } catch (IllegalArgumentException e) {
       // TODO: real max is based on settings between 16384 and 16777215
-      assertEquals("FRAME_SIZE_ERROR length > 16384: 16777216", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("FRAME_SIZE_ERROR length > 16384: 16777216");
     }
   }
 
@@ -655,7 +665,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
     writer.applyAndAckSettings(new Settings().set(Settings.MAX_FRAME_SIZE, newMaxFrameSize));
 
-    assertEquals(newMaxFrameSize, writer.maxDataLength());
+    assertThat(writer.maxDataLength()).isEqualTo(newMaxFrameSize);
     writer.frameHeader(0, newMaxFrameSize, Http2.TYPE_DATA, FLAG_NONE);
   }
 
@@ -668,7 +678,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
       writer.frameHeader(streamId, Http2.INITIAL_MAX_FRAME_SIZE, Http2.TYPE_DATA, FLAG_NONE);
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("reserved bit set: -2147483645", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("reserved bit set: -2147483645");
     }
   }
 
@@ -720,10 +730,10 @@ private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
     return new BaseTestHandler() {
       @Override public void headers(boolean inFinished, int streamId,
           int associatedStreamId, List<Header> headerBlock) {
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
+        assertThat(inFinished).isFalse();
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(associatedStreamId).isEqualTo(-1);
+        assertThat(headerBlock).isEqualTo(headerEntries("foo", "barrr", "baz", "qux"));
       }
     };
   }
@@ -732,12 +742,12 @@ private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
     return new BaseTestHandler() {
       @Override public void data(boolean inFinished, int streamId, BufferedSource source,
           int length) throws IOException {
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(1123, length);
+        assertThat(inFinished).isFalse();
+        assertThat(streamId).isEqualTo(expectedStreamId);
+        assertThat(length).isEqualTo(1123);
         ByteString data = source.readByteString(length);
         for (byte b : data.toByteArray()) {
-          assertEquals(2, b);
+          assertThat(b).isEqualTo((byte) 2);
         }
       }
     };
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
similarity index 59%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
rename to okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 631632b58d..9d9aa59ff7 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -20,7 +20,6 @@
 import java.net.Authenticator;
 import java.net.HttpURLConnection;
 import java.net.SocketTimeoutException;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
@@ -41,18 +40,17 @@
 import okhttp3.Interceptor;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
+import okhttp3.OkHttpClientTestRule;
 import okhttp3.Protocol;
 import okhttp3.RecordingCookieJar;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
-import okhttp3.Route;
 import okhttp3.TestLogHandler;
 import okhttp3.TestUtil;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.mockwebserver.Dispatcher;
@@ -62,46 +60,50 @@
 import okhttp3.mockwebserver.QueueDispatcher;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
-import okio.BufferedSource;
 import okio.GzipSink;
 import okio.Okio;
 import org.junit.After;
+import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
+import org.junit.rules.Timeout;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Arrays.asList;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
-import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertThat;
 import static org.junit.Assert.fail;
 import static org.junit.Assume.assumeTrue;
 
-/** Test how SPDY interacts with HTTP/2 features. */
+/** Test how HTTP/2 interacts with HTTP features. */
 @RunWith(Parameterized.class)
 public final class HttpOverHttp2Test {
   private static final Logger http2Logger = Logger.getLogger(Http2.class.getName());
-  private static final SslClient sslClient = SslClient.localhost();
+  private static final HandshakeCertificates handshakeCertificates = localhost();
 
   @Parameters(name = "{0}")
   public static Collection<Protocol> data() {
-    return Arrays.asList(Protocol.H2C, Protocol.HTTP_2);
+    return asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_2);
   }
 
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
   @Rule public final MockWebServer server = new MockWebServer();
+  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
+  @Rule public final Timeout timeout = new Timeout(5, SECONDS);
 
   private OkHttpClient client;
   private Cache cache;
@@ -111,31 +113,31 @@
   private Protocol protocol;
 
   public HttpOverHttp2Test(Protocol protocol) {
-    this.client = protocol == Protocol.HTTP_2 ? buildHttp2Client() : buildH2cClient();
+    this.client = protocol == Protocol.HTTP_2 ? buildHttp2Client() : buildH2PriorKnowledgeClient();
     this.scheme = protocol == Protocol.HTTP_2 ? "https" : "http";
     this.protocol = protocol;
   }
 
-  private static OkHttpClient buildH2cClient() {
-    return defaultClient().newBuilder()
-        .protocols(Arrays.asList(Protocol.H2C))
+  private OkHttpClient buildH2PriorKnowledgeClient() {
+    return clientTestRule.client.newBuilder()
+        .protocols(asList(Protocol.H2_PRIOR_KNOWLEDGE))
         .build();
   }
 
-  private static OkHttpClient buildHttp2Client() {
-    return defaultClient().newBuilder()
-        .protocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
-        .dns(new SingleInetAddressDns())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+  private OkHttpClient buildHttp2Client() {
+    return clientTestRule.client.newBuilder()
+        .protocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
   }
 
-  @Before public void setUp() throws Exception {
-    if (protocol == Protocol.H2C) {
-      server.setProtocols(Arrays.asList(Protocol.H2C));
+  @Before public void setUp() {
+    if (protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
+      server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE));
     } else {
-      server.useHttps(sslClient.socketFactory, false);
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     }
 
     cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
@@ -145,12 +147,10 @@ private static OkHttpClient buildHttp2Client() {
     http2Logger.setLevel(Level.FINE);
   }
 
-  @After public void tearDown() throws Exception {
+  @After public void tearDown() {
     Authenticator.setDefault(null);
     http2Logger.removeHandler(http2Handler);
     http2Logger.setLevel(previousLevel);
-
-    client.connectionPool().evictAll();
   }
 
   @Test public void get() throws Exception {
@@ -163,14 +163,16 @@ private static OkHttpClient buildHttp2Client() {
         .build());
     Response response = call.execute();
 
-    assertEquals("ABCDE", response.body().string());
-    assertEquals(200, response.code());
-    assertEquals("", response.message());
+    assertThat(response.body().string()).isEqualTo("ABCDE");
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("");
+    assertThat(response.protocol()).isEqualTo(protocol);
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals(scheme, request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
+    assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(request.getHeader(":scheme")).isEqualTo(scheme);
+    assertThat(request.getHeader(":authority")).isEqualTo(
+        (server.getHostName() + ":" + server.getPort()));
   }
 
   @Test public void emptyResponse() throws IOException {
@@ -181,12 +183,12 @@ private static OkHttpClient buildHttp2Client() {
         .build());
     Response response = call.execute();
 
-    assertEquals(-1, response.body().byteStream().read());
+    assertThat(response.body().byteStream().read()).isEqualTo(-1);
     response.body().close();
   }
 
   @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
-    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+    byte[] postBytes = "FGHIJ".getBytes(UTF_8);
 
     server.enqueue(new MockResponse().setBody("ABCDE"));
 
@@ -194,7 +196,7 @@ private static OkHttpClient buildHttp2Client() {
         .url(server.url("/foo"))
         .post(new RequestBody() {
           @Override public MediaType contentType() {
-            return MediaType.parse("text/plain; charset=utf-8");
+            return MediaType.get("text/plain; charset=utf-8");
           }
 
           @Override public void writeTo(BufferedSink sink) throws IOException {
@@ -204,16 +206,16 @@ private static OkHttpClient buildHttp2Client() {
         .build());
 
     Response response = call.execute();
-    assertEquals("ABCDE", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABCDE");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertThat(request.getRequestLine()).isEqualTo("POST /foo HTTP/1.1");
     assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertNull(request.getHeader("Content-Length"));
+    assertThat(request.getHeader("Content-Length")).isNull();
   }
 
   @Test public void userSuppliedContentLengthHeader() throws Exception {
-    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+    byte[] postBytes = "FGHIJ".getBytes(UTF_8);
 
     server.enqueue(new MockResponse().setBody("ABCDE"));
 
@@ -221,10 +223,10 @@ private static OkHttpClient buildHttp2Client() {
         .url(server.url("/foo"))
         .post(new RequestBody() {
           @Override public MediaType contentType() {
-            return MediaType.parse("text/plain; charset=utf-8");
+            return MediaType.get("text/plain; charset=utf-8");
           }
 
-          @Override public long contentLength() throws IOException {
+          @Override public long contentLength() {
             return postBytes.length;
           }
 
@@ -235,16 +237,17 @@ private static OkHttpClient buildHttp2Client() {
         .build());
 
     Response response = call.execute();
-    assertEquals("ABCDE", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABCDE");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertThat(request.getRequestLine()).isEqualTo("POST /foo HTTP/1.1");
     assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+    assertThat(Integer.parseInt(request.getHeader("Content-Length"))).isEqualTo(
+        (long) postBytes.length);
   }
 
   @Test public void closeAfterFlush() throws Exception {
-    final byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
+    byte[] postBytes = "FGHIJ".getBytes(UTF_8);
 
     server.enqueue(new MockResponse().setBody("ABCDE"));
 
@@ -252,10 +255,10 @@ private static OkHttpClient buildHttp2Client() {
         .url(server.url("/foo"))
         .post(new RequestBody() {
           @Override public MediaType contentType() {
-            return MediaType.parse("text/plain; charset=utf-8");
+            return MediaType.get("text/plain; charset=utf-8");
           }
 
-          @Override public long contentLength() throws IOException {
+          @Override public long contentLength() {
             return postBytes.length;
           }
 
@@ -268,12 +271,13 @@ private static OkHttpClient buildHttp2Client() {
         .build());
 
     Response response = call.execute();
-    assertEquals("ABCDE", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABCDE");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertThat(request.getRequestLine()).isEqualTo("POST /foo HTTP/1.1");
     assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+    assertThat(Integer.parseInt(request.getHeader("Content-Length"))).isEqualTo(
+        (long) postBytes.length);
   }
 
   @Test public void connectionReuse() throws Exception {
@@ -289,17 +293,114 @@ private static OkHttpClient buildHttp2Client() {
     Response response1 = call1.execute();
     Response response2 = call2.execute();
 
-    assertEquals("ABC", response1.body().source().readUtf8(3));
-    assertEquals("GHI", response2.body().source().readUtf8(3));
-    assertEquals("DEF", response1.body().source().readUtf8(3));
-    assertEquals("JKL", response2.body().source().readUtf8(3));
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(response1.body().source().readUtf8(3)).isEqualTo("ABC");
+    assertThat(response2.body().source().readUtf8(3)).isEqualTo("GHI");
+    assertThat(response1.body().source().readUtf8(3)).isEqualTo("DEF");
+    assertThat(response2.body().source().readUtf8(3)).isEqualTo("JKL");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
 
     response1.close();
     response2.close();
   }
 
+  @Test public void connectionWindowUpdateAfterCanceling() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1])));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
+
+    // Cancel the call and discard what we've buffered for the response body. This should free up
+    // the connection flow-control window so new requests can proceed.
+    call1.cancel();
+    assertThat(Util.discard(response1.body().source(), 1, TimeUnit.SECONDS))
+        .overridingErrorMessage("Call should not have completed successfully.")
+        .isFalse();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertThat(response2.body().string()).isEqualTo("abc");
+  }
+
+  /** Wait for the client to receive {@code dataLength} DATA frames. */
+  private void waitForDataFrames(int dataLength) throws Exception {
+    int expectedFrameCount = dataLength / 16384;
+    int dataFrameCount = 0;
+    while (dataFrameCount < expectedFrameCount) {
+      String log = http2Handler.take();
+      if (log.equals("FINE: << 0x00000003 16384 DATA          ")) {
+        dataFrameCount++;
+      }
+    }
+  }
+
+  @Test public void connectionWindowUpdateOnClose() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1])));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
+
+    // Cancel the call and close the response body. This should discard the buffered data and update
+    // the connection flow-control window.
+    call1.cancel();
+    response1.close();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertThat(response2.body().string()).isEqualTo("abc");
+  }
+
+  @Test public void concurrentRequestWithEmptyFlowControlWindow() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE])));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
+
+    assertThat(response1.body().contentLength()).isEqualTo(
+        (long) Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
+    int read = response1.body().source().read(new byte[8192]);
+    assertThat(read).isEqualTo(8192);
+
+    // Make a second call that should transmit the response headers. The response body won't be
+    // transmitted until the flow-control window is updated from the first request.
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertThat(response2.code()).isEqualTo(200);
+
+    // Close the response body. This should discard the buffered data and update the connection
+    // flow-control window.
+    response1.close();
+
+    assertThat(response2.body().string()).isEqualTo("abc");
+  }
+
   /** https://github.com/square/okhttp/issues/373 */
   @Test @Ignore public void synchronousRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
@@ -310,8 +411,8 @@ private static OkHttpClient buildHttp2Client() {
     executor.execute(new AsyncRequest("/r1", countDownLatch));
     executor.execute(new AsyncRequest("/r2", countDownLatch));
     countDownLatch.await();
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void gzippedResponseBody() throws Exception {
@@ -324,7 +425,7 @@ private static OkHttpClient buildHttp2Client() {
         .build());
 
     Response response = call.execute();
-    assertEquals("ABCABCABC", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABCABCABC");
   }
 
   @Test public void authenticate() throws Exception {
@@ -337,20 +438,20 @@ private static OkHttpClient buildHttp2Client() {
 
     String credential = Credentials.basic("username", "password");
     client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential))
+        .authenticator(new RecordingOkAuthenticator(credential, "Basic"))
         .build();
 
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("Successful auth!", response.body().string());
+    assertThat(response.body().string()).isEqualTo("Successful auth!");
 
     RecordedRequest denied = server.takeRequest();
-    assertNull(denied.getHeader("Authorization"));
+    assertThat(denied.getHeader("Authorization")).isNull();
     RecordedRequest accepted = server.takeRequest();
-    assertEquals("GET / HTTP/1.1", accepted.getRequestLine());
-    assertEquals(credential, accepted.getHeader("Authorization"));
+    assertThat(accepted.getRequestLine()).isEqualTo("GET / HTTP/1.1");
+    assertThat(accepted.getHeader("Authorization")).isEqualTo(credential);
   }
 
   @Test public void redirect() throws Exception {
@@ -364,12 +465,12 @@ private static OkHttpClient buildHttp2Client() {
         .build());
 
     Response response = call.execute();
-    assertEquals("This is the new location!", response.body().string());
+    assertThat(response.body().string()).isEqualTo("This is the new location!");
 
     RecordedRequest request1 = server.takeRequest();
-    assertEquals("/", request1.getPath());
+    assertThat(request1.getPath()).isEqualTo("/");
     RecordedRequest request2 = server.takeRequest();
-    assertEquals("/foo", request2.getPath());
+    assertThat(request2.getPath()).isEqualTo("/foo");
   }
 
   @Test public void readAfterLastByte() throws Exception {
@@ -381,11 +482,11 @@ private static OkHttpClient buildHttp2Client() {
     Response response = call.execute();
 
     InputStream in = response.body().byteStream();
-    assertEquals('A', in.read());
-    assertEquals('B', in.read());
-    assertEquals('C', in.read());
-    assertEquals(-1, in.read());
-    assertEquals(-1, in.read());
+    assertThat(in.read()).isEqualTo('A');
+    assertThat(in.read()).isEqualTo('B');
+    assertThat(in.read()).isEqualTo('C');
+    assertThat(in.read()).isEqualTo(-1);
+    assertThat(in.read()).isEqualTo(-1);
 
     in.close();
   }
@@ -406,7 +507,7 @@ private static OkHttpClient buildHttp2Client() {
       call1.execute();
       fail("Should have timed out!");
     } catch (SocketTimeoutException expected) {
-      assertEquals("timeout", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("timeout");
     }
 
     // Confirm that a subsequent request on the same connection is not impacted.
@@ -414,11 +515,11 @@ private static OkHttpClient buildHttp2Client() {
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("A", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("A");
 
     // Confirm that the connection was reused.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   /**
@@ -441,7 +542,7 @@ private static OkHttpClient buildHttp2Client() {
         .build());
 
     Response response = call.execute();
-    assertEquals(new String(body), response.body().string());
+    assertThat(response.body().string()).isEqualTo(new String(body));
   }
 
   /**
@@ -471,7 +572,7 @@ private static OkHttpClient buildHttp2Client() {
       response1.body().string();
       fail("Should have timed out!");
     } catch (SocketTimeoutException expected) {
-      assertEquals("timeout", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo("timeout");
     }
 
     // Confirm that a subsequent request on the same connection is not impacted.
@@ -479,11 +580,11 @@ private static OkHttpClient buildHttp2Client() {
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals(body, response2.body().string());
+    assertThat(response2.body().string()).isEqualTo(body);
 
     // Confirm that the connection was reused.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void connectionTimeout() throws Exception {
@@ -508,7 +609,7 @@ private static OkHttpClient buildHttp2Client() {
         .build());
 
     Response response1 = call1.execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
 
     try {
       call2.execute();
@@ -517,8 +618,8 @@ private static OkHttpClient buildHttp2Client() {
     }
 
     // Confirm that the connection was reused.
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void responsesAreCached() throws IOException {
@@ -535,26 +636,26 @@ private static OkHttpClient buildHttp2Client() {
         .build());
     Response response1 = call1.execute();
 
-    assertEquals("A", response1.body().string());
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
+    assertThat(response1.body().string()).isEqualTo("A");
+    assertThat(cache.requestCount()).isEqualTo(1);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(0);
 
     Call call2 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("A", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("A");
 
     Call call3 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response3 = call3.execute();
-    assertEquals("A", response3.body().string());
+    assertThat(response3.body().string()).isEqualTo("A");
 
-    assertEquals(3, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(2, cache.hitCount());
+    assertThat(cache.requestCount()).isEqualTo(3);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(2);
   }
 
   @Test public void conditionalCache() throws IOException {
@@ -572,21 +673,21 @@ private static OkHttpClient buildHttp2Client() {
         .url(server.url("/"))
         .build());
     Response response1 = call1.execute();
-    assertEquals("A", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("A");
 
-    assertEquals(1, cache.requestCount());
-    assertEquals(1, cache.networkCount());
-    assertEquals(0, cache.hitCount());
+    assertThat(cache.requestCount()).isEqualTo(1);
+    assertThat(cache.networkCount()).isEqualTo(1);
+    assertThat(cache.hitCount()).isEqualTo(0);
 
     Call call2 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("A", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("A");
 
-    assertEquals(2, cache.requestCount());
-    assertEquals(2, cache.networkCount());
-    assertEquals(1, cache.hitCount());
+    assertThat(cache.requestCount()).isEqualTo(2);
+    assertThat(cache.networkCount()).isEqualTo(2);
+    assertThat(cache.hitCount()).isEqualTo(1);
   }
 
   @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
@@ -605,14 +706,14 @@ private static OkHttpClient buildHttp2Client() {
         .url(server.url("/"))
         .build());
     Response response1 = call1.execute();
-    assertEquals("AB", response1.body().source().readUtf8(2));
+    assertThat(response1.body().source().readUtf8(2)).isEqualTo("AB");
     response1.body().close();
 
     Call call2 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("ABCD", response2.body().source().readUtf8());
+    assertThat(response2.body().source().readUtf8()).isEqualTo("ABCD");
     response2.body().close();
   }
 
@@ -633,10 +734,10 @@ private static OkHttpClient buildHttp2Client() {
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("", response.body().string());
+    assertThat(response.body().string()).isEqualTo("");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("a=b", request.getHeader("Cookie"));
+    assertThat(request.getHeader("Cookie")).isEqualTo("a=b");
   }
 
   @Test public void receiveResponseCookies() throws Exception {
@@ -652,18 +753,12 @@ private static OkHttpClient buildHttp2Client() {
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("", response.body().string());
+    assertThat(response.body().string()).isEqualTo("");
 
     cookieJar.assertResponseCookies("a=b; path=/");
   }
 
-  /** https://github.com/square/okhttp/issues/1191 */
-  @Ignore // TODO: recover gracefully when a connection is shutdown.
   @Test public void cancelWithStreamNotCompleted() throws Exception {
-    // Ensure that the (shared) connection pool is in a consistent state.
-    client.connectionPool().evictAll();
-    assertEquals(0, client.connectionPool().connectionCount());
-
     server.enqueue(new MockResponse()
         .setBody("abc"));
     server.enqueue(new MockResponse()
@@ -677,13 +772,13 @@ private static OkHttpClient buildHttp2Client() {
     call1.cancel();
 
     // That connection is pooled, and it works.
-    assertEquals(1, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
     Call call2 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("def", response2.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(response2.body().string()).isEqualTo("def");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
 
     // Clean up the connection.
     response.close();
@@ -700,10 +795,12 @@ private static OkHttpClient buildHttp2Client() {
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("abc", response.body().string());
+    assertThat(response.body().string()).isEqualTo("abc");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reused connection.
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Reused connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   @Test public void recoverFromOneInternalErrorRequiresNewConnection() throws Exception {
@@ -721,10 +818,12 @@ private static OkHttpClient buildHttp2Client() {
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("abc", response.body().string());
+    assertThat(response.body().string()).isEqualTo("abc");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void recoverFromMultipleRefusedStreamsRequiresNewConnection() throws Exception {
@@ -745,11 +844,139 @@ private static OkHttpClient buildHttp2Client() {
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("abc", response.body().string());
+    assertThat(response.body().string()).isEqualTo("abc");
+
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Reused connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    // New connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+  }
+
+  @Test public void recoverFromCancelReusesConnection() throws Exception {
+    List<CountDownLatch> responseDequeuedLatches = Arrays.asList(
+        new CountDownLatch(1),
+        // No synchronization is needed for the last request, which is not canceled.
+        new CountDownLatch(0));
+    List<CountDownLatch> requestCanceledLatches = Arrays.asList(
+        new CountDownLatch(1),
+        new CountDownLatch(0));
+
+    QueueDispatcher dispatcher =
+        new RespondAfterCancelDispatcher(responseDequeuedLatches, requestCanceledLatches);
+    dispatcher.enqueueResponse(new MockResponse()
+        .setBodyDelay(10, TimeUnit.SECONDS)
+        .setBody("abc"));
+    dispatcher.enqueueResponse(new MockResponse()
+        .setBody("def"));
+    server.setDispatcher(dispatcher);
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    callAndCancel(0, responseDequeuedLatches.get(0), requestCanceledLatches.get(0));
+
+    // Make a second request to ensure the connection is reused.
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertThat(response.body().string()).isEqualTo("def");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+  }
+
+  @Test public void recoverFromMultipleCancelReusesConnection() throws Exception {
+    List<CountDownLatch> responseDequeuedLatches = Arrays.asList(
+        new CountDownLatch(1),
+        new CountDownLatch(1),
+        // No synchronization is needed for the last request, which is not canceled.
+        new CountDownLatch(0));
+    List<CountDownLatch> requestCanceledLatches = Arrays.asList(
+        new CountDownLatch(1),
+        new CountDownLatch(1),
+        new CountDownLatch(0));
+
+    QueueDispatcher dispatcher =
+        new RespondAfterCancelDispatcher(responseDequeuedLatches, requestCanceledLatches);
+    dispatcher.enqueueResponse(new MockResponse()
+            .setBodyDelay(10, TimeUnit.SECONDS)
+            .setBody("abc"));
+    dispatcher.enqueueResponse(new MockResponse()
+            .setBodyDelay(10, TimeUnit.SECONDS)
+            .setBody("def"));
+    dispatcher.enqueueResponse(new MockResponse()
+            .setBody("ghi"));
+    server.setDispatcher(dispatcher);
+
+    client = client.newBuilder()
+            .dns(new DoubleInetAddressDns())
+            .build();
+
+    callAndCancel(0, responseDequeuedLatches.get(0), requestCanceledLatches.get(0));
+    callAndCancel(1, responseDequeuedLatches.get(1), requestCanceledLatches.get(1));
 
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reused connection.
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    // Make a third request to ensure the connection is reused.
+    Call call = client.newCall(new Request.Builder()
+            .url(server.url("/"))
+            .build());
+    Response response = call.execute();
+    assertThat(response.body().string()).isEqualTo("ghi");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
+  }
+
+  private class RespondAfterCancelDispatcher extends QueueDispatcher {
+    final private List<CountDownLatch> responseDequeuedLatches;
+    final private List<CountDownLatch> requestCanceledLatches;
+    private int responseIndex = 0;
+
+    RespondAfterCancelDispatcher(
+        List<CountDownLatch> responseDequeuedLatches,
+        List<CountDownLatch> requestCanceledLatches) {
+      this.responseDequeuedLatches = responseDequeuedLatches;
+      this.requestCanceledLatches = requestCanceledLatches;
+    }
+
+    @Override
+    synchronized public MockResponse dispatch(RecordedRequest request)
+        throws InterruptedException {
+      // This guarantees a deterministic sequence when handling the canceled request:
+      // 1. Server reads request and dequeues first response
+      // 2. Client cancels request
+      // 3. Server tries to send response on the canceled stream
+      // Otherwise, there is no guarantee for the sequence. For example, the server may use the
+      // first mocked response to respond to the second request.
+      MockResponse response = super.dispatch(request);
+      responseDequeuedLatches.get(responseIndex).countDown();
+      requestCanceledLatches.get(responseIndex).await();
+      responseIndex++;
+      return response;
+    }
+  }
+
+  /** Make a call and canceling it as soon as it's accepted by the server. */
+  private void callAndCancel(int expectedSequenceNumber, CountDownLatch responseDequeuedLatch,
+      CountDownLatch requestCanceledLatch) throws Exception {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    CountDownLatch latch = new CountDownLatch(1);
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call1, IOException e) {
+        latch.countDown();
+      }
+
+      @Override public void onResponse(Call call1, Response response) {
+        fail();
+      }
+    });
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(
+        (long) expectedSequenceNumber);
+    responseDequeuedLatch.await();
+    call.cancel();
+    requestCanceledLatch.countDown();
+    latch.await();
   }
 
   @Test public void noRecoveryFromRefusedStreamWithRetryDisabled() throws Exception {
@@ -778,16 +1005,16 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
       call.execute();
       fail();
     } catch (StreamResetException expected) {
-      assertEquals(errorCode, expected.errorCode);
+      assertThat(expected.errorCode).isEqualTo(errorCode);
     }
   }
 
-  @Test public void recoverFromConnectionNoNewStreamsOnFollowUp() throws InterruptedException {
+  @Test public void recoverFromConnectionNoNewStreamsOnFollowUp() throws Exception {
     server.enqueue(new MockResponse()
         .setResponseCode(401));
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(ErrorCode.CANCEL.httpCode));
+        .setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.httpCode));
     server.enqueue(new MockResponse()
         .setBody("DEF"));
     server.enqueue(new MockResponse()
@@ -796,18 +1023,16 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     server.enqueue(new MockResponse()
         .setBody("ABC"));
 
-    final CountDownLatch latch = new CountDownLatch(1);
-    final BlockingQueue<String> responses = new SynchronousQueue<>();
-    okhttp3.Authenticator authenticator = new okhttp3.Authenticator() {
-      @Override public Request authenticate(Route route, Response response) throws IOException {
-        responses.offer(response.body().string());
-        try {
-          latch.await();
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
-        return response.request();
+    CountDownLatch latch = new CountDownLatch(1);
+    BlockingQueue<String> responses = new SynchronousQueue<>();
+    okhttp3.Authenticator authenticator = (route, response) -> {
+      responses.offer(response.body().string());
+      try {
+        latch.await();
+      } catch (InterruptedException e) {
+        throw new AssertionError();
       }
+      return response.request();
     };
 
     OkHttpClient blockingAuthClient = client.newBuilder()
@@ -830,24 +1055,24 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
         .build();
     blockingAuthClient.newCall(request).enqueue(callback);
     String response1 = responses.take();
-    assertEquals("", response1);
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(response1).isEqualTo("");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
 
     // Now make the second request which will restrict the first HTTP/2 connection from creating new
     // streams.
     client.newCall(request).enqueue(callback);
     String response2 = responses.take();
-    assertEquals("DEF", response2);
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(response2).isEqualTo("DEF");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
 
     // Let the first request proceed. It should discard the the held HTTP/2 connection and get a new
     // one.
     latch.countDown();
     String response3 = responses.take();
-    assertEquals("ABC", response3);
-    assertEquals(1, server.takeRequest().getSequenceNumber());
-    assertEquals(2, server.takeRequest().getSequenceNumber());
+    assertThat(response3).isEqualTo("ABC");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
   }
 
   @Test public void nonAsciiResponseHeader() throws Exception {
@@ -861,8 +1086,8 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     Response response = call.execute();
     response.close();
 
-    assertEquals("Œ±", response.header("Alpha"));
-    assertEquals("Beta", response.header("Œ≤"));
+    assertThat(response.header("Alpha")).isEqualTo("Œ±");
+    assertThat(response.header("Œ≤")).isEqualTo("Beta");
   }
 
   @Test public void serverSendsPushPromise_GET() throws Exception {
@@ -878,18 +1103,20 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
         .build());
     Response response = call.execute();
 
-    assertEquals("ABCDE", response.body().string());
-    assertEquals(200, response.code());
-    assertEquals("", response.message());
+    assertThat(response.body().string()).isEqualTo("ABCDE");
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals(scheme, request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
+    assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(request.getHeader(":scheme")).isEqualTo(scheme);
+    assertThat(request.getHeader(":authority")).isEqualTo(
+        (server.getHostName() + ":" + server.getPort()));
 
     RecordedRequest pushedRequest = server.takeRequest();
-    assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
-    assertEquals("bar", pushedRequest.getHeader("foo"));
+    assertThat(pushedRequest.getRequestLine()).isEqualTo(
+        "GET /foo/bar HTTP/1.1");
+    assertThat(pushedRequest.getHeader("foo")).isEqualTo("bar");
   }
 
   @Test public void serverSendsPushPromise_HEAD() throws Exception {
@@ -904,18 +1131,20 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
         .url(server.url("/foo"))
         .build());
     Response response = call.execute();
-    assertEquals("ABCDE", response.body().string());
-    assertEquals(200, response.code());
-    assertEquals("", response.message());
+    assertThat(response.body().string()).isEqualTo("ABCDE");
+    assertThat(response.code()).isEqualTo(200);
+    assertThat(response.message()).isEqualTo("");
 
     RecordedRequest request = server.takeRequest();
-    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals(scheme, request.getHeader(":scheme"));
-    assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
+    assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
+    assertThat(request.getHeader(":scheme")).isEqualTo(scheme);
+    assertThat(request.getHeader(":authority")).isEqualTo(
+        (server.getHostName() + ":" + server.getPort()));
 
     RecordedRequest pushedRequest = server.takeRequest();
-    assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
-    assertEquals("bar", pushedRequest.getHeader("foo"));
+    assertThat(pushedRequest.getRequestLine()).isEqualTo(
+        "HEAD /foo/bar HTTP/1.1");
+    assertThat(pushedRequest.getHeader("foo")).isEqualTo("bar");
   }
 
   @Test public void noDataFramesSentWithNullRequestBody() throws Exception {
@@ -927,13 +1156,15 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
         .method("DELETE", null)
         .build());
     Response response = call.execute();
-    assertEquals("ABC", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABC");
 
-    assertEquals(protocol, response.protocol());
+    assertThat(response.protocol()).isEqualTo(protocol);
 
     List<String> logs = http2Handler.takeAll();
 
-    assertThat("header logged", firstFrame(logs, "HEADERS"), containsString("HEADERS       END_STREAM|END_HEADERS"));
+    assertThat(firstFrame(logs, "HEADERS"))
+        .overridingErrorMessage("header logged")
+        .contains("HEADERS       END_STREAM|END_HEADERS");
   }
 
   @Test public void emptyDataFrameSentWithEmptyBody() throws Exception {
@@ -945,14 +1176,22 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
         .method("DELETE", Util.EMPTY_REQUEST)
         .build());
     Response response = call.execute();
-    assertEquals("ABC", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABC");
 
-    assertEquals(protocol, response.protocol());
+    assertThat(response.protocol()).isEqualTo(protocol);
 
     List<String> logs = http2Handler.takeAll();
 
-    assertThat("header logged", firstFrame(logs, "HEADERS"), containsString("HEADERS       END_HEADERS"));
-    assertThat("data logged", firstFrame(logs, "DATA"), containsString("0 DATA          END_STREAM"));
+    assertThat(firstFrame(logs, "HEADERS"))
+        .overridingErrorMessage("header logged")
+        .contains("HEADERS       END_HEADERS");
+    // While MockWebServer waits to read the client's HEADERS frame before sending the response, it
+    // doesn't wait to read the client's DATA frame and may send a DATA frame before the client
+    // does. So we can't assume the client's empty DATA will be logged first.
+    assertThat(countFrames(logs, "FINE: >> 0x00000003     0 DATA          END_STREAM"))
+        .isEqualTo((long) 2);
+    assertThat(countFrames(logs, "FINE: >> 0x00000003     3 DATA          "))
+        .isEqualTo((long) 1);
   }
 
   @Test public void pingsTransmitted() throws Exception {
@@ -970,16 +1209,20 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("ABC", response.body().string());
+    assertThat(response.body().string()).isEqualTo("ABC");
 
-    assertEquals(protocol, response.protocol());
+    assertThat(response.protocol()).isEqualTo(protocol);
 
     // Confirm a single ping was sent and received, and its reply was sent and received.
     List<String> logs = http2Handler.takeAll();
-    assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          "));
-    assertEquals(1, countFrames(logs, "FINE: << 0x00000000     8 PING          "));
-    assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          ACK"));
-    assertEquals(1, countFrames(logs, "FINE: << 0x00000000     8 PING          ACK"));
+    assertThat(countFrames(logs, "FINE: >> 0x00000000     8 PING          ")).isEqualTo(
+        (long) 1);
+    assertThat(countFrames(logs, "FINE: << 0x00000000     8 PING          ")).isEqualTo(
+        (long) 1);
+    assertThat(countFrames(logs, "FINE: >> 0x00000000     8 PING          ACK")).isEqualTo(
+        (long) 1);
+    assertThat(countFrames(logs, "FINE: << 0x00000000     8 PING          ACK")).isEqualTo(
+        (long) 1);
   }
 
   @Test public void missingPongsFailsConnection() throws Exception {
@@ -1002,16 +1245,20 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
       call.execute();
       fail();
     } catch (StreamResetException expected) {
-      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(
+          "stream was reset: PROTOCOL_ERROR");
     }
 
     long elapsedUntilFailure = System.nanoTime() - executeAtNanos;
-    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo(
+        (double) 1000, offset(250d));
 
     // Confirm a single ping was sent but not acknowledged.
     List<String> logs = http2Handler.takeAll();
-    assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          "));
-    assertEquals(0, countFrames(logs, "FINE: << 0x00000000     8 PING          ACK"));
+    assertThat(countFrames(logs, "FINE: >> 0x00000000     8 PING          ")).isEqualTo(
+        (long) 1);
+    assertThat(countFrames(logs, "FINE: << 0x00000000     8 PING          ACK")).isEqualTo(
+        (long) 0);
   }
 
   private String firstFrame(List<String> logs, String type) {
@@ -1048,7 +1295,7 @@ private int countFrames(List<String> logs, String message) {
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("", response.body().string());
+    assertThat(response.body().string()).isEqualTo("");
 
     server.enqueue(new MockResponse()
         .setBody("ABC"));
@@ -1072,13 +1319,17 @@ private int countFrames(List<String> logs, String message) {
         .build());
     Response response3 = call3.execute();
 
-    assertEquals("ABC", response1.body().string());
-    assertEquals("DEF", response2.body().string());
-    assertEquals("GHI", response3.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // Settings connection.
-    assertEquals(1, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
-    assertEquals(2, server.takeRequest().getSequenceNumber()); // Reuse settings connection.
-    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection!
+    assertThat(response1.body().string()).isEqualTo("ABC");
+    assertThat(response2.body().string()).isEqualTo("DEF");
+    assertThat(response3.body().string()).isEqualTo("GHI");
+    // Settings connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    // Reuse settings connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
+    // Reuse settings connection.
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
+    // New connection!
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void connectionNotReusedAfterShutdown() throws Exception {
@@ -1092,15 +1343,15 @@ private int countFrames(List<String> logs, String message) {
         .url(server.url("/"))
         .build());
     Response response1 = call1.execute();
-    assertEquals("ABC", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("ABC");
 
     Call call2 = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("DEF", response2.body().string());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(response2.body().string()).isEqualTo("DEF");
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   /**
@@ -1127,7 +1378,7 @@ private int countFrames(List<String> logs, String message) {
                   .url(server.url("/"))
                   .build());
               Response response = call.execute();
-              assertEquals("ABC", response.body().string());
+              assertThat(response.body().string()).isEqualTo("ABC");
               // Wait until the GOAWAY has been processed.
               RealConnection connection = (RealConnection) chain.connection();
               while (connection.isHealthy(false)) ;
@@ -1141,10 +1392,10 @@ private int countFrames(List<String> logs, String message) {
         .url(server.url("/"))
         .build());
     Response response = call.execute();
-    assertEquals("DEF", response.body().string());
+    assertThat(response.body().string()).isEqualTo("DEF");
 
-    assertEquals(0, server.takeRequest().getSequenceNumber());
-    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
   }
 
   @Test public void responseHeadersAfterGoaway() throws Exception {
@@ -1155,7 +1406,7 @@ private int countFrames(List<String> logs, String message) {
         .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
         .setBody("DEF"));
 
-    final BlockingQueue<String> bodies = new SynchronousQueue<>();
+    BlockingQueue<String> bodies = new SynchronousQueue<>();
     Callback callback = new Callback() {
       @Override public void onResponse(Call call, Response response) throws IOException {
         bodies.add(response.body().string());
@@ -1167,9 +1418,9 @@ private int countFrames(List<String> logs, String message) {
     client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
     client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
 
-    assertEquals("DEF", bodies.poll(2, SECONDS));
-    assertEquals("ABC", bodies.poll(2, SECONDS));
-    assertEquals(2, server.getRequestCount());
+    assertThat(bodies.poll(2, SECONDS)).isEqualTo("DEF");
+    assertThat(bodies.poll(2, SECONDS)).isEqualTo("ABC");
+    assertThat(server.getRequestCount()).isEqualTo(2);
   }
 
   /**
@@ -1182,12 +1433,9 @@ private int countFrames(List<String> logs, String message) {
   @Test public void concurrentHttp2ConnectionsDeduplicated() throws Exception {
     assumeTrue(protocol == Protocol.HTTP_2);
 
-    server.useHttps(sslClient.socketFactory, true);
-
-    // Force a fresh connection pool for the test.
-    client.connectionPool().evictAll();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
 
-    final QueueDispatcher queueDispatcher = new QueueDispatcher();
+    QueueDispatcher queueDispatcher = new QueueDispatcher();
     queueDispatcher.enqueueResponse(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
         .clearHeaders());
@@ -1214,7 +1462,7 @@ private int countFrames(List<String> logs, String message) {
                 .url("https://android.com/call2")
                 .build());
             Response response2 = call2.execute();
-            assertEquals("call2 response", response2.body().string());
+            assertThat(response2.body().string()).isEqualTo("call2 response");
           } catch (IOException e) {
             throw new RuntimeException(e);
           }
@@ -1240,27 +1488,27 @@ private int countFrames(List<String> logs, String message) {
         .url("https://android.com/call1")
         .build());
     Response response2 = call1.execute();
-    assertEquals("call1 response", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("call1 response");
 
     RecordedRequest call1Connect = server.takeRequest();
-    assertEquals("CONNECT", call1Connect.getMethod());
-    assertEquals(0, call1Connect.getSequenceNumber());
+    assertThat(call1Connect.getMethod()).isEqualTo("CONNECT");
+    assertThat(call1Connect.getSequenceNumber()).isEqualTo(0);
 
     RecordedRequest call2Connect = server.takeRequest();
-    assertEquals("CONNECT", call2Connect.getMethod());
-    assertEquals(0, call2Connect.getSequenceNumber());
+    assertThat(call2Connect.getMethod()).isEqualTo("CONNECT");
+    assertThat(call2Connect.getSequenceNumber()).isEqualTo(0);
 
     RecordedRequest call2Get = server.takeRequest();
-    assertEquals("GET", call2Get.getMethod());
-    assertEquals("/call2", call2Get.getPath());
-    assertEquals(0, call2Get.getSequenceNumber());
+    assertThat(call2Get.getMethod()).isEqualTo("GET");
+    assertThat(call2Get.getPath()).isEqualTo("/call2");
+    assertThat(call2Get.getSequenceNumber()).isEqualTo(0);
 
     RecordedRequest call1Get = server.takeRequest();
-    assertEquals("GET", call1Get.getMethod());
-    assertEquals("/call1", call1Get.getPath());
-    assertEquals(1, call1Get.getSequenceNumber());
+    assertThat(call1Get.getMethod()).isEqualTo("GET");
+    assertThat(call1Get.getPath()).isEqualTo("/call1");
+    assertThat(call1Get.getSequenceNumber()).isEqualTo(1);
 
-    assertEquals(1, client.connectionPool().connectionCount());
+    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
   }
 
   /** https://github.com/square/okhttp/issues/3103 */
@@ -1283,13 +1531,14 @@ private int countFrames(List<String> logs, String message) {
         .build());
 
     Response response = call.execute();
-    assertEquals("", response.body().string());
+    assertThat(response.body().string()).isEqualTo("");
 
     RecordedRequest recordedRequest = server.takeRequest();
-    assertEquals("privateobject.com", recordedRequest.getHeader(":authority"));
+    assertThat(recordedRequest.getHeader(":authority")).isEqualTo(
+        "privateobject.com");
   }
 
-  public Buffer gzip(String bytes) throws IOException {
+  private Buffer gzip(String bytes) throws IOException {
     Buffer bytesOut = new Buffer();
     BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
     sink.writeUtf8(bytes);
@@ -1301,7 +1550,7 @@ public Buffer gzip(String bytes) throws IOException {
     String path;
     CountDownLatch countDownLatch;
 
-    public AsyncRequest(String path, CountDownLatch countDownLatch) {
+    AsyncRequest(String path, CountDownLatch countDownLatch) {
       this.path = path;
       this.countDownLatch = countDownLatch;
     }
@@ -1312,35 +1561,11 @@ public AsyncRequest(String path, CountDownLatch countDownLatch) {
             .url(server.url(path))
             .build());
         Response response = call.execute();
-        assertEquals("A", response.body().string());
+        assertThat(response.body().string()).isEqualTo("A");
         countDownLatch.countDown();
       } catch (Exception e) {
         throw new RuntimeException(e);
       }
     }
   }
-
-  static final class RecordingHandler extends BaseTestHandler {
-    int headerFrameCount;
-    final List<Integer> dataFrames = new ArrayList<>();
-
-    @Override public void settings(boolean clearPrevious, Settings settings) {
-    }
-
-    @Override public void ackSettings() {
-    }
-
-    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-    }
-
-    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
-        throws IOException {
-      dataFrames.add(length);
-    }
-
-    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock) {
-      headerFrameCount++;
-    }
-  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java b/okhttp/src/test/java/okhttp3/internal/http2/HuffmanTest.java
similarity index 86%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
rename to okhttp/src/test/java/okhttp3/internal/http2/HuffmanTest.java
index 53642c0ea0..b84d2de09f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HuffmanTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/HuffmanTest.java
@@ -16,14 +16,13 @@
 package okhttp3.internal.http2;
 
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.Random;
 import okio.Buffer;
 import okio.ByteString;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertArrayEquals;
 
 /** Original version of this class was lifted from {@code com.twitter.hpack.HuffmanTest}. */
 public final class HuffmanTest {
@@ -42,9 +41,9 @@
   private void assertRoundTrip(ByteString data) throws IOException {
     Buffer buffer = new Buffer();
     Huffman.get().encode(data, buffer);
-    assertEquals(buffer.size(), Huffman.get().encodedLength(data));
+    assertThat(Huffman.get().encodedLength(data)).isEqualTo(buffer.size());
 
     byte[] decodedBytes = Huffman.get().decode(buffer.readByteArray());
-    assertTrue(Arrays.equals(data.toByteArray(), decodedBytes));
+    assertArrayEquals(data.toByteArray(), decodedBytes);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java b/okhttp/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
similarity index 96%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
rename to okhttp/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
index fe5f82fd4a..1ade5b1dde 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
@@ -100,7 +100,7 @@ public Http2Writer truncateLastFrame(int length) {
     return writer;
   }
 
-  public InFrame takeFrame() throws InterruptedException {
+  public InFrame takeFrame() throws Exception {
     return inFrames.take();
   }
 
@@ -110,14 +110,12 @@ public void play() throws IOException {
     serverSocket.setReuseAddress(false);
     serverSocket.bind(new InetSocketAddress("localhost", 0), 1);
     port = serverSocket.getLocalPort();
-    executor.execute(new Runnable() {
-      @Override public void run() {
-        try {
-          readAndWriteFrames();
-        } catch (IOException e) {
-          Util.closeQuietly(MockHttp2Peer.this);
-          logger.info(MockHttp2Peer.this + " done: " + e.getMessage());
-        }
+    executor.execute(() -> {
+      try {
+        readAndWriteFrames();
+      } catch (IOException e) {
+        Util.closeQuietly(MockHttp2Peer.this);
+        logger.info(MockHttp2Peer.this + " done: " + e.getMessage());
       }
     });
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java b/okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java
similarity index 61%
rename from okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java
rename to okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java
index a26506ca27..8e2aa424b2 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/SettingsTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java
@@ -19,42 +19,41 @@
 
 import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class SettingsTest {
   @Test public void unsetField() {
     Settings settings = new Settings();
-    assertEquals(-3, settings.getMaxConcurrentStreams(-3));
+    assertThat(settings.getMaxConcurrentStreams(-3)).isEqualTo(-3);
   }
 
   @Test public void setFields() {
     Settings settings = new Settings();
 
     settings.set(Settings.HEADER_TABLE_SIZE, 8096);
-    assertEquals(8096, settings.getHeaderTableSize());
+    assertThat(settings.getHeaderTableSize()).isEqualTo(8096);
 
-    assertEquals(true, settings.getEnablePush(true));
+    assertThat(settings.getEnablePush(true)).isTrue();
     settings.set(Settings.ENABLE_PUSH, 1);
-    assertEquals(true, settings.getEnablePush(false));
+    assertThat(settings.getEnablePush(false)).isTrue();
     settings.clear();
 
-    assertEquals(-3, settings.getMaxConcurrentStreams(-3));
+    assertThat(settings.getMaxConcurrentStreams(-3)).isEqualTo(-3);
     settings.set(MAX_CONCURRENT_STREAMS, 75);
-    assertEquals(75, settings.getMaxConcurrentStreams(-3));
+    assertThat(settings.getMaxConcurrentStreams(-3)).isEqualTo(75);
 
     settings.clear();
-    assertEquals(16384, settings.getMaxFrameSize(16384));
+    assertThat(settings.getMaxFrameSize(16384)).isEqualTo(16384);
     settings.set(Settings.MAX_FRAME_SIZE, 16777215);
-    assertEquals(16777215, settings.getMaxFrameSize(16384));
+    assertThat(settings.getMaxFrameSize(16384)).isEqualTo(16777215);
 
-    assertEquals(-1, settings.getMaxHeaderListSize(-1));
+    assertThat(settings.getMaxHeaderListSize(-1)).isEqualTo(-1);
     settings.set(Settings.MAX_HEADER_LIST_SIZE, 16777215);
-    assertEquals(16777215, settings.getMaxHeaderListSize(-1));
+    assertThat(settings.getMaxHeaderListSize(-1)).isEqualTo(16777215);
 
-    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE,
-        settings.getInitialWindowSize());
+    assertThat(settings.getInitialWindowSize()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
     settings.set(Settings.INITIAL_WINDOW_SIZE, 108);
-    assertEquals(108, settings.getInitialWindowSize());
+    assertThat(settings.getInitialWindowSize()).isEqualTo(108);
   }
 
   @Test public void merge() {
@@ -69,9 +68,9 @@
     b.set(Settings.MAX_CONCURRENT_STREAMS, 60000);
 
     a.merge(b);
-    assertEquals(10000, a.getHeaderTableSize());
-    assertEquals(40000, a.getMaxHeaderListSize(-1));
-    assertEquals(50000, a.getInitialWindowSize());
-    assertEquals(60000, a.getMaxConcurrentStreams(-1));
+    assertThat(a.getHeaderTableSize()).isEqualTo(10000);
+    assertThat(a.getMaxHeaderListSize(-1)).isEqualTo(40000);
+    assertThat(a.getInitialWindowSize()).isEqualTo(50000);
+    assertThat(a.getMaxConcurrentStreams(-1)).isEqualTo(60000);
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java b/okhttp/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
similarity index 100%
rename from okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
rename to okhttp/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/JdkWithJettyBootPlatformTest.java b/okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
similarity index 83%
rename from okhttp-tests/src/test/java/okhttp3/internal/platform/JdkWithJettyBootPlatformTest.java
rename to okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
index afe7145a01..3d9cd3ceaa 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/JdkWithJettyBootPlatformTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
@@ -18,14 +18,14 @@
 import org.junit.Test;
 
 import static okhttp3.internal.platform.PlatformTest.getPlatform;
-import static org.junit.Assert.assertNotNull;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assume.assumeTrue;
 
-public class JdkWithJettyBootPlatformTest {
+public class Jdk8WithJettyBootPlatformTest {
   @Test
   public void testBuildsWithJettyBoot() {
     assumeTrue(getPlatform().equals("jdk-with-jetty-boot"));
 
-    assertNotNull(JdkWithJettyBootPlatform.buildIfSupported());
+    assertThat(Jdk8WithJettyBootPlatform.buildIfSupported()).isNotNull();
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java b/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
similarity index 63%
rename from okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
rename to okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
index ada8f78969..0ff13bc9d0 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
@@ -15,11 +15,11 @@
  */
 package okhttp3.internal.platform;
 
+import java.lang.reflect.Method;
 import org.junit.Test;
 
 import static okhttp3.internal.platform.PlatformTest.getPlatform;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assume.assumeTrue;
 
 public class Jdk9PlatformTest {
@@ -27,7 +27,7 @@
   public void buildsWhenJdk9() {
     assumeTrue(getPlatform().equals("jdk9"));
 
-    assertNotNull(Jdk9Platform.buildIfSupported());
+    assertThat(Jdk9Platform.buildIfSupported()).isNotNull();
   }
 
   @Test
@@ -36,7 +36,15 @@ public void findsAlpnMethods() {
 
     Jdk9Platform platform = Jdk9Platform.buildIfSupported();
 
-    assertEquals("getApplicationProtocol", platform.getProtocolMethod.getName());
-    assertEquals("setApplicationProtocols", platform.setProtocolMethod.getName());
+    assertThat(platform.getProtocolMethod.getName()).isEqualTo("getApplicationProtocol");
+    assertThat(platform.setProtocolMethod.getName()).isEqualTo("setApplicationProtocols");
+  }
+
+  @Test
+  public void testToStringIsClassname() throws NoSuchMethodException {
+    assumeTrue(getPlatform().equals("jdk9"));
+
+    Method method = this.getClass().getMethod("toString");
+    assertThat(new Jdk9Platform(method, method).toString()).isEqualTo("Jdk9Platform");
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java b/okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java
similarity index 72%
rename from okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
rename to okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java
index ffd5842e83..a192b8c5e4 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/PlatformTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java
@@ -17,7 +17,7 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class PlatformTest {
   @Test public void alwaysBuilds() {
@@ -26,10 +26,19 @@
 
   /** Guard against the default value changing by accident. */
   @Test public void defaultPrefix() {
-    assertEquals("OkHttp", new Platform().getPrefix());
+    assertThat(new Platform().getPrefix()).isEqualTo("OkHttp");
   }
 
   public static String getPlatform() {
     return System.getProperty("okhttp.platform", "platform");
   }
+
+  public static String getJvmSpecVersion() {
+    return System.getProperty("java.specification.version", "unknown");
+  }
+
+  @Test
+  public void testToStringIsClassname() {
+    assertThat(new Platform().toString()).isEqualTo("Platform");
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
similarity index 80%
rename from okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
rename to okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
index e999890991..70d44bbe28 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
@@ -25,9 +25,7 @@
 import org.junit.Test;
 
 import static okhttp3.internal.publicsuffix.PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class PublicSuffixDatabaseTest {
@@ -40,12 +38,14 @@
         .writeUtf8("square.com\n");
     publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
 
-    assertEquals("example.com", publicSuffixDatabase.getEffectiveTldPlusOne("example.com"));
-    assertEquals("example.com", publicSuffixDatabase.getEffectiveTldPlusOne("foo.example.com"));
-    assertEquals("bar.square.com",
-        publicSuffixDatabase.getEffectiveTldPlusOne("foo.bar.square.com"));
-    assertEquals("foo.my.square.com",
-        publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com"));
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("example.com")).isEqualTo(
+        "example.com");
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.example.com")).isEqualTo(
+        "example.com");
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.bar.square.com")).isEqualTo(
+        "bar.square.com");
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com")).isEqualTo(
+        "foo.my.square.com");
   }
 
   @Test public void wildcardMatch() {
@@ -55,11 +55,11 @@
         .writeUtf8("example.com\n");
     publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
 
-    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("my.square.com"));
-    assertEquals("foo.my.square.com",
-        publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com"));
-    assertEquals("foo.my.square.com",
-        publicSuffixDatabase.getEffectiveTldPlusOne("bar.foo.my.square.com"));
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("my.square.com")).isNull();
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com")).isEqualTo(
+        "foo.my.square.com");
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("bar.foo.my.square.com")).isEqualTo(
+        "foo.my.square.com");
   }
 
   @Test public void boundarySearches() {
@@ -69,10 +69,10 @@
         .writeUtf8("fff\n");
     publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
 
-    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("aaa"));
-    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("ggg"));
-    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("ccc"));
-    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("eee"));
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("aaa")).isNull();
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("ggg")).isNull();
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("ccc")).isNull();
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("eee")).isNull();
   }
 
   @Test public void exceptionRule() {
@@ -85,9 +85,11 @@
         .writeUtf8("square.com\n");
     publicSuffixDatabase.setListBytes(buffer.readByteArray(), exception.readByteArray());
 
-    assertEquals("my.square.jp", publicSuffixDatabase.getEffectiveTldPlusOne("my.square.jp"));
-    assertEquals("my.square.jp", publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.jp"));
-    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("my1.square.jp"));
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("my.square.jp")).isEqualTo(
+        "my.square.jp");
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.jp")).isEqualTo(
+        "my.square.jp");
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("my1.square.jp")).isNull();
   }
 
   @Test public void noEffectiveTldPlusOne() {
@@ -100,8 +102,8 @@
         .writeUtf8("square.com\n");
     publicSuffixDatabase.setListBytes(buffer.readByteArray(), exception.readByteArray());
 
-    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("example.com"));
-    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("foo.square.jp"));
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("example.com")).isNull();
+    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.square.jp")).isNull();
   }
 
   @Test public void allPublicSuffixes() throws IOException {
@@ -119,10 +121,10 @@
         // A wildcard rule, let's replace the wildcard with a value.
         publicSuffix = publicSuffix.replaceAll("\\*", "square");
       }
-      assertNull(publicSuffixDatabase.getEffectiveTldPlusOne(publicSuffix));
+      assertThat(publicSuffixDatabase.getEffectiveTldPlusOne(publicSuffix)).isNull();
 
       String test = "foobar." + publicSuffix;
-      assertEquals(test, publicSuffixDatabase.getEffectiveTldPlusOne(test));
+      assertThat(publicSuffixDatabase.getEffectiveTldPlusOne(test)).isEqualTo(test);
     }
   }
 
@@ -140,10 +142,11 @@
 
     while (!buffer.exhausted()) {
       String exception = buffer.readUtf8LineStrict();
-      assertEquals(exception, publicSuffixDatabase.getEffectiveTldPlusOne(exception));
+      assertThat(publicSuffixDatabase.getEffectiveTldPlusOne(exception)).isEqualTo(
+          exception);
 
       String test = "foobar." + exception;
-      assertEquals(exception, publicSuffixDatabase.getEffectiveTldPlusOne(test));
+      assertThat(publicSuffixDatabase.getEffectiveTldPlusOne(test)).isEqualTo(exception);
     }
   }
 
@@ -151,9 +154,9 @@
     Thread.currentThread().interrupt();
     try {
       String result = publicSuffixDatabase.getEffectiveTldPlusOne("squareup.com");
-      assertEquals("squareup.com", result);
+      assertThat(result).isEqualTo("squareup.com");
     } finally {
-      assertTrue(Thread.interrupted());
+      assertThat(Thread.interrupted()).isTrue();
     }
   }
 
@@ -276,9 +279,9 @@ private void checkPublicSuffix(String domain, String registrablePart) {
 
     String result = publicSuffixDatabase.getEffectiveTldPlusOne(canonicalDomain);
     if (registrablePart == null) {
-      assertNull(result);
+      assertThat(result).isNull();
     } else {
-      assertEquals(Util.canonicalizeHost(registrablePart), result);
+      assertThat(result).isEqualTo(Util.canonicalizeHost(registrablePart));
     }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
similarity index 63%
rename from okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
rename to okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
index dad2e0e950..3df548f3ba 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
@@ -15,65 +15,83 @@
  */
 package okhttp3.internal.tls;
 
+import java.security.GeneralSecurityException;
+import java.security.SecureRandom;
+import java.security.cert.X509Certificate;
+import java.util.Collections;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
 import okhttp3.Call;
 import okhttp3.CertificatePinner;
 import okhttp3.OkHttpClient;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.platform.Platform;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.mockwebserver.internal.tls.HeldCertificate;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import org.junit.Rule;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.internal.platform.PlatformTest.getJvmSpecVersion;
 import static okhttp3.internal.platform.PlatformTest.getPlatform;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static okhttp3.tls.internal.TlsUtil.newKeyManager;
+import static okhttp3.tls.internal.TlsUtil.newTrustManager;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeFalse;
 
 public final class CertificatePinnerChainValidationTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
   /** The pinner should pull the root certificate from the trust manager. */
   @Test public void pinRootNotPresentInChain() throws Exception {
+    // TODO https://github.com/square/okhttp/issues/4703
+    assumeFalse(getJvmSpecVersion().equals("11"));
+
     HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("2")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("intermediate_ca")
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
-        .serialNumber("3")
+        .signedBy(intermediateCa)
+        .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(rootCa.certificate))
+        .add(server.getHostName(), CertificatePinner.pin(rootCa.certificate()))
         .build();
-    SslClient sslClient = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
         .build();
     OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
 
-    SslClient serverSslClient = new SslClient.Builder()
-        .certificateChain(certificate, intermediateCa)
+    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(certificate, intermediateCa.certificate())
         .build();
-    server.useHttps(serverSslClient.socketFactory, false);
+    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
 
     // The request should complete successfully.
     server.enqueue(new MockResponse()
@@ -83,7 +101,7 @@
         .url(server.url("/"))
         .build());
     Response response1 = call1.execute();
-    assertEquals("abc", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("abc");
 
     // Confirm that a second request also succeeds. This should detect caching problems.
     server.enqueue(new MockResponse()
@@ -93,43 +111,47 @@
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("def", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("def");
   }
 
   /** The pinner should accept an intermediate from the server's chain. */
   @Test public void pinIntermediatePresentInChain() throws Exception {
+    // TODO https://github.com/square/okhttp/issues/4703
+    assumeFalse(getJvmSpecVersion().equals("11"));
+
     HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("2")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("intermediate_ca")
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
-        .serialNumber("3")
+        .signedBy(intermediateCa)
+        .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(intermediateCa.certificate))
+        .add(server.getHostName(), CertificatePinner.pin(intermediateCa.certificate()))
         .build();
-    SslClient contextBuilder = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
         .build();
     OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(contextBuilder.socketFactory, contextBuilder.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
 
-    SslClient serverSslContext = new SslClient.Builder()
-        .certificateChain(certificate.keyPair, certificate.certificate, intermediateCa.certificate)
+    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(certificate, intermediateCa.certificate())
         .build();
-    server.useHttps(serverSslContext.socketFactory, false);
+    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
 
     // The request should complete successfully.
     server.enqueue(new MockResponse()
@@ -139,7 +161,7 @@
         .url(server.url("/"))
         .build());
     Response response1 = call1.execute();
-    assertEquals("abc", response1.body().string());
+    assertThat(response1.body().string()).isEqualTo("abc");
     response1.close();
 
     // Force a fresh connection for the next request.
@@ -153,15 +175,18 @@
         .url(server.url("/"))
         .build());
     Response response2 = call2.execute();
-    assertEquals("def", response2.body().string());
+    assertThat(response2.body().string()).isEqualTo("def");
     response2.close();
   }
 
   @Test public void unrelatedPinnedLeafCertificateInChain() throws Exception {
+    // https://github.com/square/okhttp/issues/4729
+    assumeFalse(getJvmSpecVersion().equals("11"));
+
     // Start with a trusted root CA certificate.
     HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
         .build();
 
@@ -169,24 +194,25 @@
     // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
     // certificate.
     HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("2")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("good_intermediate_ca")
         .build();
     HeldCertificate goodCertificate = new HeldCertificate.Builder()
-        .issuedBy(goodIntermediateCa)
-        .serialNumber("3")
+        .signedBy(goodIntermediateCa)
+        .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(goodCertificate.certificate))
+        .add(server.getHostName(), CertificatePinner.pin(goodCertificate.certificate()))
         .build();
-    SslClient clientContextBuilder = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
         .build();
     OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(clientContextBuilder.socketFactory, clientContextBuilder.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
@@ -196,32 +222,21 @@
     // trusted good certificate above. The attack is that by including the good certificate in the
     // chain, we may trick the certificate pinner into accepting the rouge certificate.
     HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("4")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(4L)
         .commonName("bad_intermediate_ca")
         .build();
     HeldCertificate rogueCertificate = new HeldCertificate.Builder()
-        .serialNumber("5")
-        .issuedBy(compromisedIntermediateCa)
+        .serialNumber(5L)
+        .signedBy(compromisedIntermediateCa)
         .commonName(server.getHostName())
         .build();
 
-    SslClient.Builder sslBuilder = new SslClient.Builder();
-
-    // Test setup fails on JDK9
-    // java.security.KeyStoreException: Certificate chain is not valid
-    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
-    // http://openjdk.java.net/jeps/229
-    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
-    if (getPlatform().equals("jdk9")) {
-      sslBuilder.keyStoreType("JKS");
-    }
+    SSLSocketFactory socketFactory = newServerSocketFactory(rogueCertificate,
+        compromisedIntermediateCa.certificate(), goodCertificate.certificate());
 
-    SslClient serverSslContext = sslBuilder.certificateChain(
-        rogueCertificate.keyPair, rogueCertificate.certificate, compromisedIntermediateCa.certificate, goodCertificate.certificate, rootCa.certificate)
-        .build();
-    server.useHttps(serverSslContext.socketFactory, false);
+    server.useHttps(socketFactory, false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .addHeader("Content-Type: text/plain"));
@@ -238,20 +253,23 @@
     } catch (SSLPeerUnverifiedException expected) {
       // Certificate pinning fails!
       String message = expected.getMessage();
-      assertTrue(message, message.startsWith("Certificate pinning failure!"));
+      assertThat(message).startsWith("Certificate pinning failure!");
     }
   }
 
   @Test public void unrelatedPinnedIntermediateCertificateInChain() throws Exception {
+    // https://github.com/square/okhttp/issues/4729
+    assumeFalse(getJvmSpecVersion().equals("11"));
+
     // Start with two root CA certificates, one is good and the other is compromised.
     HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
         .build();
     HeldCertificate compromisedRootCa = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .ca(3)
+        .serialNumber(2L)
+        .certificateAuthority(1)
         .commonName("compromised_root")
         .build();
 
@@ -259,20 +277,21 @@
     // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
     // certificate.
     HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("3")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(3L)
         .commonName("intermediate_ca")
         .build();
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(goodIntermediateCa.certificate))
+        .add(server.getHostName(), CertificatePinner.pin(goodIntermediateCa.certificate()))
         .build();
-    SslClient clientContextBuilder = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
-        .addTrustedCertificate(compromisedRootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
+        .addTrustedCertificate(compromisedRootCa.certificate())
         .build();
     OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(clientContextBuilder.socketFactory, clientContextBuilder.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
@@ -282,32 +301,20 @@
     // serves the good CAs certificate in the chain, which means the certificate pinner sees a
     // different set of certificates than the SSL verifier.
     HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(compromisedRootCa)
-        .ca(2)
-        .serialNumber("4")
+        .signedBy(compromisedRootCa)
+        .certificateAuthority(0)
+        .serialNumber(4L)
         .commonName("intermediate_ca")
         .build();
     HeldCertificate rogueCertificate = new HeldCertificate.Builder()
-        .serialNumber("5")
-        .issuedBy(compromisedIntermediateCa)
+        .serialNumber(5L)
+        .signedBy(compromisedIntermediateCa)
         .commonName(server.getHostName())
         .build();
 
-    SslClient.Builder sslBuilder = new SslClient.Builder();
-
-    // Test setup fails on JDK9
-    // java.security.KeyStoreException: Certificate chain is not valid
-    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
-    // http://openjdk.java.net/jeps/229
-    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
-    if (getPlatform().equals("jdk9")) {
-      sslBuilder.keyStoreType("JKS");
-    }
-
-    SslClient serverSslContext = sslBuilder.certificateChain(
-            rogueCertificate.keyPair, rogueCertificate.certificate, goodIntermediateCa.certificate, compromisedIntermediateCa.certificate, compromisedRootCa.certificate)
-        .build();
-    server.useHttps(serverSslContext.socketFactory, false);
+    SSLSocketFactory socketFactory = newServerSocketFactory(rogueCertificate,
+        goodIntermediateCa.certificate(), compromisedIntermediateCa.certificate());
+    server.useHttps(socketFactory, false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .addHeader("Content-Type: text/plain"));
@@ -324,11 +331,27 @@
     } catch (SSLHandshakeException expected) {
       // On Android, the handshake fails before the certificate pinner runs.
       String message = expected.getMessage();
-      assertTrue(message, message.contains("Could not validate certificate"));
+      assertThat(message).contains("Could not validate certificate");
     } catch (SSLPeerUnverifiedException expected) {
       // On OpenJDK, the handshake succeeds but the certificate pinner fails.
       String message = expected.getMessage();
-      assertTrue(message, message.startsWith("Certificate pinning failure!"));
+      assertThat(message).startsWith("Certificate pinning failure!");
     }
   }
+
+  private SSLSocketFactory newServerSocketFactory(HeldCertificate heldCertificate,
+      X509Certificate... intermediates) throws GeneralSecurityException {
+    // Test setup fails on JDK9
+    // java.security.KeyStoreException: Certificate chain is not valid
+    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
+    // http://openjdk.java.net/jeps/229
+    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
+    String keystoreType = getPlatform().equals("jdk9") ? "JKS" : null;
+    X509KeyManager x509KeyManager = newKeyManager(keystoreType, heldCertificate, intermediates);
+    X509TrustManager trustManager = newTrustManager(keystoreType, Collections.emptyList());
+    SSLContext sslContext = Platform.get().getSSLContext();
+    sslContext.init(new KeyManager[] { x509KeyManager }, new TrustManager[] { trustManager },
+        new SecureRandom());
+    return sslContext.getSocketFactory();
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
similarity index 54%
rename from okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
rename to okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
index 3f753de0d1..c65c4b56da 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
@@ -15,42 +15,46 @@
  */
 package okhttp3.internal.tls;
 
-import java.io.IOException;
 import java.net.SocketException;
 import java.security.GeneralSecurityException;
-import java.security.NoSuchAlgorithmException;
+import java.security.SecureRandom;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import javax.net.ssl.KeyManager;
 import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
 import javax.security.auth.x500.X500Principal;
 import okhttp3.Call;
-import okhttp3.DelegatingSSLSocketFactory;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.internal.tls.HeldCertificate;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
+import static java.util.Arrays.asList;
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.internal.platform.PlatformTest.getJvmSpecVersion;
 import static okhttp3.internal.platform.PlatformTest.getPlatform;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static okhttp3.tls.internal.TlsUtil.newKeyManager;
+import static okhttp3.tls.internal.TlsUtil.newTrustManager;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeFalse;
 
 public final class ClientAuthTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
-  public enum ClientAuth {
-    NONE, WANTS, NEEDS
-  }
-
   private HeldCertificate serverRootCa;
   private HeldCertificate serverIntermediateCa;
   private HeldCertificate serverCert;
@@ -59,116 +63,131 @@
   private HeldCertificate clientCert;
 
   @Before
-  public void setUp() throws GeneralSecurityException {
+  public void setUp() {
     serverRootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
-        .subjectAlternativeName("root_ca.com")
+        .addSubjectAlternativeName("root_ca.com")
         .build();
     serverIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(serverRootCa)
-        .ca(2)
-        .serialNumber("2")
+        .signedBy(serverRootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("intermediate_ca")
-        .subjectAlternativeName("intermediate_ca.com")
+        .addSubjectAlternativeName("intermediate_ca.com")
         .build();
 
     serverCert = new HeldCertificate.Builder()
-        .issuedBy(serverIntermediateCa)
-        .serialNumber("3")
+        .signedBy(serverIntermediateCa)
+        .serialNumber(3L)
         .commonName("Local Host")
-        .subjectAlternativeName(server.getHostName())
+        .addSubjectAlternativeName(server.getHostName())
         .build();
 
     clientRootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(13)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
-        .subjectAlternativeName("root_ca.com")
+        .addSubjectAlternativeName("root_ca.com")
         .build();
     clientIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(serverRootCa)
-        .ca(12)
-        .serialNumber("2")
+        .signedBy(serverRootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("intermediate_ca")
-        .subjectAlternativeName("intermediate_ca.com")
+        .addSubjectAlternativeName("intermediate_ca.com")
         .build();
 
     clientCert = new HeldCertificate.Builder()
-        .issuedBy(clientIntermediateCa)
-        .serialNumber("4")
+        .signedBy(clientIntermediateCa)
+        .serialNumber(4L)
         .commonName("Jethro Willis")
-        .subjectAlternativeName("jethrowillis.com")
+        .addSubjectAlternativeName("jethrowillis.com")
         .build();
   }
 
   @Test public void clientAuthForWants() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.WANTS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requestClientAuth();
     server.enqueue(new MockResponse().setBody("abc"));
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
-    assertEquals(new X500Principal("CN=Jethro Willis"), response.handshake().localPrincipal());
-    assertEquals("abc", response.body().string());
+    assertThat(response.handshake().peerPrincipal()).isEqualTo(
+        new X500Principal("CN=Local Host"));
+    assertThat(response.handshake().localPrincipal()).isEqualTo(
+        new X500Principal("CN=Jethro Willis"));
+    assertThat(response.body().string()).isEqualTo("abc");
   }
 
   @Test public void clientAuthForNeeds() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requireClientAuth();
     server.enqueue(new MockResponse().setBody("abc"));
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
-    assertEquals(new X500Principal("CN=Jethro Willis"), response.handshake().localPrincipal());
-    assertEquals("abc", response.body().string());
+    assertThat(response.handshake().peerPrincipal()).isEqualTo(
+        new X500Principal("CN=Local Host"));
+    assertThat(response.handshake().localPrincipal()).isEqualTo(
+        new X500Principal("CN=Jethro Willis"));
+    assertThat(response.body().string()).isEqualTo("abc");
   }
 
   @Test public void clientAuthSkippedForNone() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NONE);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.noClientAuth();
     server.enqueue(new MockResponse().setBody("abc"));
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
-    assertEquals(null, response.handshake().localPrincipal());
-    assertEquals("abc", response.body().string());
+    assertThat(response.handshake().peerPrincipal()).isEqualTo(
+        new X500Principal("CN=Local Host"));
+    assertThat(response.handshake().localPrincipal()).isNull();
+    assertThat(response.body().string()).isEqualTo("abc");
   }
 
   @Test public void missingClientAuthSkippedForWantsOnly() throws Exception {
-    OkHttpClient client = buildClient(null, clientIntermediateCa);
+    OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.WANTS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requestClientAuth();
     server.enqueue(new MockResponse().setBody("abc"));
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
-    assertEquals(null, response.handshake().localPrincipal());
-    assertEquals("abc", response.body().string());
+    assertThat(response.handshake().peerPrincipal()).isEqualTo(
+        new X500Principal("CN=Local Host"));
+    assertThat(response.handshake().localPrincipal()).isNull();
+    assertThat(response.body().string()).isEqualTo("abc");
   }
 
   @Test public void missingClientAuthFailsForNeeds() throws Exception {
-    OkHttpClient client = buildClient(null, clientIntermediateCa);
+    // TODO https://github.com/square/okhttp/issues/4598
+    // StreamReset stream was reset: PROT...
+    assumeFalse(getJvmSpecVersion().equals("11"));
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+    OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requireClientAuth();
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
 
@@ -176,25 +195,28 @@ public void setUp() throws GeneralSecurityException {
       call.execute();
       fail();
     } catch (SSLHandshakeException expected) {
+    } catch (SSLException expected) {
+      String jvmVersion = System.getProperty("java.specification.version");
+      assertThat(jvmVersion).isEqualTo("11");
     } catch (SocketException expected) {
-      // JDK 9
-      assertTrue(getPlatform().equals("jdk9"));
+      assertThat(getPlatform()).isEqualTo("jdk9");
     }
   }
 
   @Test public void commonNameIsNotTrusted() throws Exception {
     serverCert = new HeldCertificate.Builder()
-        .issuedBy(serverIntermediateCa)
-        .serialNumber("3")
+        .signedBy(serverIntermediateCa)
+        .serialNumber(3L)
         .commonName(server.getHostName())
-        .subjectAlternativeName("different-host.com")
+        .addSubjectAlternativeName("different-host.com")
         .build();
 
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requireClientAuth();
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
 
@@ -206,16 +228,21 @@ public void setUp() throws GeneralSecurityException {
   }
 
   @Test public void invalidClientAuthFails() throws Throwable {
+    // TODO https://github.com/square/okhttp/issues/4598
+    // StreamReset stream was reset: PROT...
+    assumeFalse(getJvmSpecVersion().equals("11"));
+
     HeldCertificate clientCert2 = new HeldCertificate.Builder()
-        .serialNumber("4")
+        .serialNumber(4L)
         .commonName("Jethro Willis")
         .build();
 
     OkHttpClient client = buildClient(clientCert2);
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requireClientAuth();
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
 
@@ -223,54 +250,45 @@ public void setUp() throws GeneralSecurityException {
       call.execute();
       fail();
     } catch (SSLHandshakeException expected) {
+    } catch (SSLException expected) {
+      // javax.net.ssl.SSLException: readRecord
+      String jvmVersion = System.getProperty("java.specification.version");
+      assertThat(jvmVersion).isEqualTo("11");
     } catch (SocketException expected) {
-      // JDK 9
-      assertTrue(getPlatform().equals("jdk9"));
+      assertThat(getPlatform()).isEqualTo("jdk9");
     }
   }
 
-  public OkHttpClient buildClient(HeldCertificate cert, HeldCertificate... chain) {
-    SslClient.Builder sslClientBuilder = new SslClient.Builder()
-        .addTrustedCertificate(serverRootCa.certificate);
+  private OkHttpClient buildClient(
+      HeldCertificate heldCertificate, X509Certificate... intermediates) {
+    HandshakeCertificates.Builder builder = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(serverRootCa.certificate());
 
-    if (cert != null) {
-      sslClientBuilder.certificateChain(cert, chain);
+    if (heldCertificate != null) {
+      builder.heldCertificate(heldCertificate, intermediates);
     }
 
-    SslClient sslClient = sslClientBuilder.build();
+    HandshakeCertificates handshakeCertificates = builder.build();
     return defaultClient().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .build();
   }
 
-  public SSLSocketFactory buildServerSslSocketFactory(final ClientAuth clientAuth) {
+  private SSLSocketFactory buildServerSslSocketFactory() {
     // The test uses JDK default SSL Context instead of the Platform provided one
     // as Conscrypt seems to have some differences, we only want to test client side here.
-    SslClient serverSslClient = new SslClient.Builder()
-        .addTrustedCertificate(serverRootCa.certificate)
-        .addTrustedCertificate(clientRootCa.certificate)
-        .certificateChain(serverCert, serverIntermediateCa)
-        .sslContext(getSslContext())
-        .build();
-
-    return new DelegatingSSLSocketFactory(serverSslClient.socketFactory) {
-      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
-        if (clientAuth == ClientAuth.NEEDS) {
-          sslSocket.setNeedClientAuth(true);
-        } else if (clientAuth == ClientAuth.WANTS) {
-          sslSocket.setWantClientAuth(true);
-        }
-
-        return super.configureSocket(sslSocket);
-      }
-    };
-  }
-
-  private SSLContext getSslContext() {
     try {
-      return SSLContext.getInstance("TLS");
-    } catch (NoSuchAlgorithmException e) {
-      throw new IllegalStateException("unable to build JDK default SSLContext");
+      X509KeyManager keyManager = newKeyManager(
+          null, serverCert, serverIntermediateCa.certificate());
+      X509TrustManager trustManager = newTrustManager(
+          null, asList(serverRootCa.certificate(), clientRootCa.certificate()));
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(new KeyManager[] {keyManager}, new TrustManager[] {trustManager},
+          new SecureRandom());
+      return sslContext.getSocketFactory();
+    } catch (GeneralSecurityException e) {
+      throw new AssertionError(e);
     }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java b/okhttp/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
similarity index 96%
rename from okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
rename to okhttp/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
index 09c22b8594..099b8982b0 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
@@ -20,7 +20,7 @@
 
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class DistinguishedNameParserTest {
@@ -120,7 +120,8 @@
   private void assertCn(String expected, String dn) {
     X500Principal principal = new X500Principal(dn);
     DistinguishedNameParser parser = new DistinguishedNameParser(principal);
-    assertEquals(dn, expected, parser.findMostSpecific("cn"));
+    assertThat(parser.findMostSpecific("cn")).overridingErrorMessage(dn).isEqualTo(
+        expected);
   }
 
   private void expectExceptionInPrincipal(String dn) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java b/okhttp/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
similarity index 85%
rename from okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
rename to okhttp/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
index 6dd5bbbd7c..9a878f1c41 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
@@ -28,9 +28,8 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.assertj.core.api.Assertions.assertThat;
 
 /**
  * Tests for our hostname verifier. Most of these tests are from AOSP, which itself includes tests
@@ -41,7 +40,7 @@
 
   @Test public void verify() throws Exception {
     FakeSSLSession session = new FakeSSLSession();
-    assertFalse(verifier.verify("localhost", session));
+    assertThat(verifier.verify("localhost", session)).isFalse();
   }
 
   @Test public void verifyCn() throws Exception {
@@ -72,9 +71,9 @@
         + "HwlNrAu8jlZ2UqSgskSWlhYdMTAP9CPHiUv9N7FcT58Itv/I4fKREINQYjDpvQcx\n"
         + "SaTYb9dr5sB4WLNglk7zxDtM80H518VvihTcP7FHL+Gn6g4j5fkI98+S\n"
         + "-----END CERTIFICATE-----\n");
-    assertFalse(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertFalse(verifier.verify("bar.com", session));
+    assertThat(verifier.verify("foo.com", session)).isFalse();
+    assertThat(verifier.verify("a.foo.com", session)).isFalse();
+    assertThat(verifier.verify("bar.com", session)).isFalse();
   }
 
   @Test public void verifyNonAsciiCn() throws Exception {
@@ -105,8 +104,8 @@
         + "9BsO7qe46hidgn39hKh1WjKK2VcL/3YRsC4wUi0PBtFW6ScMCuMhgIRXSPU55Rae\n"
         + "UIlOdPjjr1SUNWGId1rD7W16Scpwnknn310FNxFMHVI0GTGFkNdkilNCFJcIoRA=\n"
         + "-----END CERTIFICATE-----\n");
-    assertFalse(verifier.verify("\u82b1\u5b50.co.jp", session));
-    assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
+    assertThat(verifier.verify("\u82b1\u5b50.co.jp", session)).isFalse();
+    assertThat(verifier.verify("a.\u82b1\u5b50.co.jp", session)).isFalse();
   }
 
   @Test public void verifySubjectAlt() throws Exception {
@@ -138,10 +137,10 @@
         + "2xq+8bc6HojdtbCyug/fvBZvZqQXSmU8m8IVcMmWMz0ZQO8ee3QkBHMZfCy7P/kr\n"
         + "VbWx/uETImUu+NZg22ewEw==\n"
         + "-----END CERTIFICATE-----\n");
-    assertFalse(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertTrue(verifier.verify("bar.com", session));
-    assertFalse(verifier.verify("a.bar.com", session));
+    assertThat(verifier.verify("foo.com", session)).isFalse();
+    assertThat(verifier.verify("a.foo.com", session)).isFalse();
+    assertThat(verifier.verify("bar.com", session)).isTrue();
+    assertThat(verifier.verify("a.bar.com", session)).isFalse();
   }
 
   /**
@@ -179,8 +178,8 @@
         + "sWIKHYrmhCIRshUNohGXv50m2o+1w9oWmQ6Dkq7lCjfXfUB4wIbggJjpyEtbNqBt\n"
         + "j4MC2x5rfsLKKqToKmNE7pFEgqwe8//Aar1b+Qj+\n"
         + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
+    assertThat(verifier.verify("foo.com", session)).isTrue();
+    assertThat(verifier.verify("a.foo.com", session)).isFalse();
     // these checks test alternative subjects. The test data contains an
     // alternative subject starting with a japanese kanji character. This is
     // not supported by Android because the underlying implementation from
@@ -219,10 +218,10 @@
         + "qAVqixM+J0qJmQStgAc53i2aTMvAQu3A3snvH/PHTBo+5UL72n9S1kZyNCsVf1Qo\n"
         + "n8jKTiRriEM+fMFlcgQP284EBFzYHyCXFb9O/hMjK2+6mY9euMB1U1aFFzM/Bg==\n"
         + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertTrue(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
+    assertThat(verifier.verify("foo.com", session)).isTrue();
+    assertThat(verifier.verify("a.foo.com", session)).isFalse();
+    assertThat(verifier.verify("foo.com", session)).isTrue();
+    assertThat(verifier.verify("a.foo.com", session)).isFalse();
   }
 
   @Test public void verifyMultipleCn() throws Exception {
@@ -254,12 +253,12 @@
         + "SpQFCfo02NO0uNRDPUdJx2huycdNb+AXHaO7eXevDLJ+QnqImIzxWiY6zLOdzjjI\n"
         + "VBMkLHmnP7SjGSQ3XA4ByrQOxfOUTyLyE7NuemhHppuQPxE=\n"
         + "-----END CERTIFICATE-----\n");
-    assertFalse(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertFalse(verifier.verify("bar.com", session));
-    assertFalse(verifier.verify("a.bar.com", session));
-    assertFalse(verifier.verify("\u82b1\u5b50.co.jp", session));
-    assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
+    assertThat(verifier.verify("foo.com", session)).isFalse();
+    assertThat(verifier.verify("a.foo.com", session)).isFalse();
+    assertThat(verifier.verify("bar.com", session)).isFalse();
+    assertThat(verifier.verify("a.bar.com", session)).isFalse();
+    assertThat(verifier.verify("\u82b1\u5b50.co.jp", session)).isFalse();
+    assertThat(verifier.verify("a.\u82b1\u5b50.co.jp", session)).isFalse();
   }
 
   @Test public void verifyWilcardCn() throws Exception {
@@ -290,10 +289,10 @@
         + "G9Z6tyMbmfRY+dLSh3a9JwoEcBUso6EWYBakLbq4nG/nvYdYvG9ehrnLVwZFL82e\n"
         + "l3Q/RK95bnA6cuRClGusLad0e6bjkBzx/VQ3VarDEpAkTLUGVAa0CLXtnyc=\n"
         + "-----END CERTIFICATE-----\n");
-    assertFalse(verifier.verify("foo.com", session));
-    assertFalse(verifier.verify("www.foo.com", session));
-    assertFalse(verifier.verify("\u82b1\u5b50.foo.com", session));
-    assertFalse(verifier.verify("a.b.foo.com", session));
+    assertThat(verifier.verify("foo.com", session)).isFalse();
+    assertThat(verifier.verify("www.foo.com", session)).isFalse();
+    assertThat(verifier.verify("\u82b1\u5b50.foo.com", session)).isFalse();
+    assertThat(verifier.verify("a.b.foo.com", session)).isFalse();
   }
 
   @Test public void verifyWilcardCnOnTld() throws Exception {
@@ -325,8 +324,8 @@
         + "UGPLEUDzRHMPHLnSqT1n5UU5UDRytbjJPXzF+l/+WZIsanefWLsxnkgAuZe/oMMF\n"
         + "EJMryEzOjg4Tfuc5qM0EXoPcQ/JlheaxZ40p2IyHqbsWV4MRYuFH4bkM\n"
         + "-----END CERTIFICATE-----\n");
-    assertFalse(verifier.verify("foo.co.jp", session));
-    assertFalse(verifier.verify("\u82b1\u5b50.co.jp", session));
+    assertThat(verifier.verify("foo.co.jp", session)).isFalse();
+    assertThat(verifier.verify("\u82b1\u5b50.co.jp", session)).isFalse();
   }
 
   /**
@@ -365,10 +364,10 @@
         + "pgJsDbJtZfHnV1nd3M6zOtQPm1TIQpNmMMMd/DPrGcUQerD3\n"
         + "-----END CERTIFICATE-----\n");
     // try the foo.com variations
-    assertTrue(verifier.verify("foo.com", session));
-    assertTrue(verifier.verify("www.foo.com", session));
-    assertTrue(verifier.verify("\u82b1\u5b50.foo.com", session));
-    assertFalse(verifier.verify("a.b.foo.com", session));
+    assertThat(verifier.verify("foo.com", session)).isTrue();
+    assertThat(verifier.verify("www.foo.com", session)).isTrue();
+    assertThat(verifier.verify("\u82b1\u5b50.foo.com", session)).isTrue();
+    assertThat(verifier.verify("a.b.foo.com", session)).isFalse();
     // these checks test alternative subjects. The test data contains an
     // alternative subject starting with a japanese kanji character. This is
     // not supported by Android because the underlying implementation from
@@ -404,15 +403,16 @@
         + "DCzOCv9Ma6Lv5o5jcYWVxvBSTsnt22hsJpWD1K7iY9lbkLwl0ivn73pG2evsAn9G\n"
         + "X8YKH52fnHsCrhSD\n"
         + "-----END CERTIFICATE-----");
-    assertEquals(new X500Principal("CN=localhost"), certificate.getSubjectX500Principal());
+    assertThat(certificate.getSubjectX500Principal()).isEqualTo(
+        new X500Principal("CN=localhost"));
 
     FakeSSLSession session = new FakeSSLSession(certificate);
-    assertTrue(verifier.verify("localhost", session));
-    assertTrue(verifier.verify("localhost.localdomain", session));
-    assertFalse(verifier.verify("local.host", session));
+    assertThat(verifier.verify("localhost", session)).isTrue();
+    assertThat(verifier.verify("localhost.localdomain", session)).isTrue();
+    assertThat(verifier.verify("local.host", session)).isFalse();
 
-    assertTrue(verifier.verify("127.0.0.1", session));
-    assertFalse(verifier.verify("127.0.0.2", session));
+    assertThat(verifier.verify("127.0.0.1", session)).isTrue();
+    assertThat(verifier.verify("127.0.0.2", session)).isFalse();
   }
 
   @Test public void wildcardsCannotMatchIpAddresses() throws Exception {
@@ -429,7 +429,7 @@
         + "BQUAA0EAk9i88xdjWoewqvE+iMC9tD2obMchgFDaHH0ogxxiRaIKeEly3g0uGxIt\n"
         + "fl2WRY8hb4x+zRrwsFaLEpdEvqcjOQ==\n"
         + "-----END CERTIFICATE-----");
-    assertFalse(verifier.verify("127.0.0.1", session));
+    assertThat(verifier.verify("127.0.0.1", session)).isFalse();
   }
 
   /**
@@ -451,7 +451,7 @@
         + "U6LFxmZr31lFyis2/T68PpjAppc0DpNQuA2m/Y7oTHBDi55Fw6HVHCw3lucuWZ5d\n"
         + "qUYo4ES548JdpQtcLrW2sA==\n"
         + "-----END CERTIFICATE-----");
-    assertFalse(verifier.verify("google.com", session));
+    assertThat(verifier.verify("google.com", session)).isFalse();
   }
 
   @Test public void subjectAltName() throws Exception {
@@ -477,11 +477,11 @@
         + "DQYJKoZIhvcNAQEFBQADQQBXpZZPOY2Dy1lGG81JTr8L4or9jpKacD7n51eS8iqI\n"
         + "oTznPNuXHU5bFN0AAGX2ij47f/EahqTpo5RdS95P4sVm\n"
         + "-----END CERTIFICATE-----");
-    assertFalse(verifier.verify("foo.com", session));
-    assertTrue(verifier.verify("bar.com", session));
-    assertTrue(verifier.verify("baz.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertFalse(verifier.verify("quux.com", session));
+    assertThat(verifier.verify("foo.com", session)).isFalse();
+    assertThat(verifier.verify("bar.com", session)).isTrue();
+    assertThat(verifier.verify("baz.com", session)).isTrue();
+    assertThat(verifier.verify("a.foo.com", session)).isFalse();
+    assertThat(verifier.verify("quux.com", session)).isFalse();
   }
 
   @Test public void subjectAltNameWithWildcard() throws Exception {
@@ -507,44 +507,44 @@
         + "bTANBgkqhkiG9w0BAQUFAANBAB8yrSl8zqy07i0SNYx2B/FnvQY734pxioaqFWfO\n"
         + "Bqo1ZZl/9aPHEWIwBrxYNVB0SGu/kkbt/vxqOjzzrkXukmI=\n"
         + "-----END CERTIFICATE-----");
-    assertFalse(verifier.verify("foo.com", session));
-    assertTrue(verifier.verify("bar.com", session));
-    assertTrue(verifier.verify("a.baz.com", session));
-    assertFalse(verifier.verify("baz.com", session));
-    assertFalse(verifier.verify("a.foo.com", session));
-    assertFalse(verifier.verify("a.bar.com", session));
-    assertFalse(verifier.verify("quux.com", session));
+    assertThat(verifier.verify("foo.com", session)).isFalse();
+    assertThat(verifier.verify("bar.com", session)).isTrue();
+    assertThat(verifier.verify("a.baz.com", session)).isTrue();
+    assertThat(verifier.verify("baz.com", session)).isFalse();
+    assertThat(verifier.verify("a.foo.com", session)).isFalse();
+    assertThat(verifier.verify("a.bar.com", session)).isFalse();
+    assertThat(verifier.verify("quux.com", session)).isFalse();
   }
 
   @Test public void verifyAsIpAddress() {
     // IPv4
-    assertTrue(Util.verifyAsIpAddress("127.0.0.1"));
-    assertTrue(Util.verifyAsIpAddress("1.2.3.4"));
+    assertThat(Util.verifyAsIpAddress("127.0.0.1")).isTrue();
+    assertThat(Util.verifyAsIpAddress("1.2.3.4")).isTrue();
 
     // IPv6
-    assertTrue(Util.verifyAsIpAddress("::1"));
-    assertTrue(Util.verifyAsIpAddress("2001:db8::1"));
-    assertTrue(Util.verifyAsIpAddress("::192.168.0.1"));
-    assertTrue(Util.verifyAsIpAddress("::ffff:192.168.0.1"));
-    assertTrue(Util.verifyAsIpAddress("FEDC:BA98:7654:3210:FEDC:BA98:7654:3210"));
-    assertTrue(Util.verifyAsIpAddress("1080:0:0:0:8:800:200C:417A"));
-    assertTrue(Util.verifyAsIpAddress("1080::8:800:200C:417A"));
-    assertTrue(Util.verifyAsIpAddress("FF01::101"));
-    assertTrue(Util.verifyAsIpAddress("0:0:0:0:0:0:13.1.68.3"));
-    assertTrue(Util.verifyAsIpAddress("0:0:0:0:0:FFFF:129.144.52.38"));
-    assertTrue(Util.verifyAsIpAddress("::13.1.68.3"));
-    assertTrue(Util.verifyAsIpAddress("::FFFF:129.144.52.38"));
+    assertThat(Util.verifyAsIpAddress("::1")).isTrue();
+    assertThat(Util.verifyAsIpAddress("2001:db8::1")).isTrue();
+    assertThat(Util.verifyAsIpAddress("::192.168.0.1")).isTrue();
+    assertThat(Util.verifyAsIpAddress("::ffff:192.168.0.1")).isTrue();
+    assertThat(Util.verifyAsIpAddress("FEDC:BA98:7654:3210:FEDC:BA98:7654:3210")).isTrue();
+    assertThat(Util.verifyAsIpAddress("1080:0:0:0:8:800:200C:417A")).isTrue();
+    assertThat(Util.verifyAsIpAddress("1080::8:800:200C:417A")).isTrue();
+    assertThat(Util.verifyAsIpAddress("FF01::101")).isTrue();
+    assertThat(Util.verifyAsIpAddress("0:0:0:0:0:0:13.1.68.3")).isTrue();
+    assertThat(Util.verifyAsIpAddress("0:0:0:0:0:FFFF:129.144.52.38")).isTrue();
+    assertThat(Util.verifyAsIpAddress("::13.1.68.3")).isTrue();
+    assertThat(Util.verifyAsIpAddress("::FFFF:129.144.52.38")).isTrue();
 
     // Hostnames
-    assertFalse(Util.verifyAsIpAddress("go"));
-    assertFalse(Util.verifyAsIpAddress("localhost"));
-    assertFalse(Util.verifyAsIpAddress("squareup.com"));
-    assertFalse(Util.verifyAsIpAddress("www.nintendo.co.jp"));
+    assertThat(Util.verifyAsIpAddress("go")).isFalse();
+    assertThat(Util.verifyAsIpAddress("localhost")).isFalse();
+    assertThat(Util.verifyAsIpAddress("squareup.com")).isFalse();
+    assertThat(Util.verifyAsIpAddress("www.nintendo.co.jp")).isFalse();
   }
 
   private X509Certificate certificate(String certificate) throws Exception {
     return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(
-        new ByteArrayInputStream(certificate.getBytes(Util.UTF_8)));
+        new ByteArrayInputStream(certificate.getBytes(UTF_8)));
   }
 
   private SSLSession session(String certificate) throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
similarity index 84%
rename from okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
rename to okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index 38b2762e6a..044643cd4b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -32,9 +32,8 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 import static org.junit.Assert.fail;
 
 public final class RealWebSocketTest {
@@ -65,10 +64,11 @@
 
   @Test public void close() throws IOException {
     client.webSocket.close(1000, "Hello!");
-    assertFalse(server.processNextFrame()); // This will trigger a close response.
+    // This will trigger a close response.
+    assertThat(server.processNextFrame()).isFalse();
     server.listener.assertClosing(1000, "Hello!");
     server.webSocket.close(1000, "Goodbye!");
-    assertFalse(client.processNextFrame());
+    assertThat(client.processNextFrame()).isFalse();
     client.listener.assertClosing(1000, "Goodbye!");
     server.listener.assertClosed(1000, "Hello!");
     client.listener.assertClosed(1000, "Goodbye!");
@@ -77,8 +77,8 @@
   @Test public void clientCloseThenMethodsReturnFalse() throws IOException {
     client.webSocket.close(1000, "Hello!");
 
-    assertFalse(client.webSocket.close(1000, "Hello!"));
-    assertFalse(client.webSocket.send("Hello!"));
+    assertThat(client.webSocket.close(1000, "Hello!")).isFalse();
+    assertThat(client.webSocket.send("Hello!")).isFalse();
   }
 
   @Test public void clientCloseWith0Fails() throws IOException {
@@ -86,7 +86,7 @@
       client.webSocket.close(0, null);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals(expected.getMessage(), "Code must be in range [1000,5000): 0");
+      assertThat("Code must be in range [1000,5000): 0").isEqualTo(expected.getMessage());
     }
   }
 
@@ -95,18 +95,18 @@
     client.webSocket.pong(ByteString.encodeUtf8("Ping!"));
     client.listener.assertFailure(IOException.class, "source is closed");
 
-    assertFalse(client.webSocket.send("Hello!"));
+    assertThat(client.webSocket.send("Hello!")).isFalse();
   }
 
   @Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {
     client2Server.source().close();
 
-    assertTrue(client.webSocket.send("Hello!"));
+    assertThat(client.webSocket.send("Hello!")).isTrue();
     client.listener.assertFailure(IOException.class, "source is closed");
 
     // A failed write prevents further use of the WebSocket instance.
-    assertFalse(client.webSocket.send("Hello!"));
-    assertFalse(client.webSocket.pong(ByteString.encodeUtf8("Ping!")));
+    assertThat(client.webSocket.send("Hello!")).isFalse();
+    assertThat(client.webSocket.pong(ByteString.encodeUtf8("Ping!"))).isFalse();
   }
 
   @Test public void serverCloseThenWritingPingSucceeds() throws IOException {
@@ -114,7 +114,7 @@
     client.processNextFrame();
     client.listener.assertClosing(1000, "Hello!");
 
-    assertTrue(client.webSocket.pong(ByteString.encodeUtf8("Pong?")));
+    assertThat(client.webSocket.pong(ByteString.encodeUtf8("Pong?"))).isTrue();
   }
 
   @Test public void clientCanWriteMessagesAfterServerClose() throws IOException {
@@ -122,7 +122,7 @@
     client.processNextFrame();
     client.listener.assertClosing(1000, "Hello!");
 
-    assertTrue(client.webSocket.send("Hi!"));
+    assertThat(client.webSocket.send("Hi!")).isTrue();
     server.processNextFrame();
     server.listener.assertTextMessage("Hi!");
   }
@@ -131,7 +131,7 @@
     server.webSocket.close(1000, "Hello!");
     client.processNextFrame();
     client.listener.assertClosing(1000, "Hello!");
-    assertTrue(client.webSocket.close(1000, "Bye!"));
+    assertThat(client.webSocket.close(1000, "Bye!")).isTrue();
   }
 
   @Test public void emptyCloseInitiatesShutdown() throws IOException {
@@ -139,7 +139,7 @@
     client.processNextFrame();
     client.listener.assertClosing(1005, "");
 
-    assertTrue(client.webSocket.close(1000, "Bye!"));
+    assertThat(client.webSocket.close(1000, "Bye!")).isTrue();
     server.processNextFrame();
     server.listener.assertClosing(1000, "Bye!");
 
@@ -148,13 +148,13 @@
 
   @Test public void clientCloseClosesConnection() throws IOException {
     client.webSocket.close(1000, "Hello!");
-    assertFalse(client.closed);
+    assertThat(client.closed).isFalse();
     server.processNextFrame(); // Read client closing, send server close.
     server.listener.assertClosing(1000, "Hello!");
 
     server.webSocket.close(1000, "Goodbye!");
     client.processNextFrame(); // Read server closing, close connection.
-    assertTrue(client.closed);
+    assertThat(client.closed).isTrue();
     client.listener.assertClosing(1000, "Goodbye!");
 
     // Server and client both finished closing, connection is closed.
@@ -166,7 +166,7 @@
     server.webSocket.close(1000, "Hello!");
 
     client.processNextFrame(); // Read server close, send client close, close connection.
-    assertFalse(client.closed);
+    assertThat(client.closed).isFalse();
     client.listener.assertClosing(1000, "Hello!");
 
     client.webSocket.close(1000, "Hello!");
@@ -182,7 +182,7 @@
     server.webSocket.close(1000, "Hello!");
     client.processNextFrame(); // Read close, close connection close.
 
-    assertFalse(client.closed);
+    assertThat(client.closed).isFalse();
     client.webSocket.close(1000, "Hi!");
     server.processNextFrame();
 
@@ -191,7 +191,7 @@
     client.listener.assertClosed(1000, "Hello!");
     server.listener.assertClosed(1000, "Hi!");
     client.webSocket.awaitTermination(5, TimeUnit.SECONDS);
-    assertTrue(client.closed);
+    assertThat(client.closed).isTrue();
 
     server.listener.assertExhausted(); // Client should not have sent second close.
     client.listener.assertExhausted(); // Server should not have sent second close.
@@ -200,9 +200,9 @@
   @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
     server.webSocket.send("Hello!");
     server.webSocket.close(1000, "Bye!");
-    assertTrue(client.processNextFrame());
+    assertThat(client.processNextFrame()).isTrue();
     client.listener.assertTextMessage("Hello!");
-    assertFalse(client.processNextFrame());
+    assertThat(client.processNextFrame()).isFalse();
     client.listener.assertClosing(1000, "Bye!");
   }
 
@@ -210,7 +210,7 @@
     server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
 
     client.processNextFrame(); // Detects error, send close, close connection.
-    assertTrue(client.closed);
+    assertThat(client.closed).isTrue();
     client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
     server.processNextFrame();
@@ -220,13 +220,14 @@
   @Test public void protocolErrorInCloseResponseClosesConnection() throws IOException {
     client.webSocket.close(1000, "Hello");
     server.processNextFrame();
-    assertFalse(client.closed); // Not closed until close reply is received.
+    // Not closed until close reply is received.
+    assertThat(client.closed).isFalse();
 
     // Manually write an invalid masked close frame.
     server.sink.write(ByteString.decodeHex("888760b420bb635c68de0cd84f")).emit();
 
     client.processNextFrame();// Detects error, disconnects immediately since close already sent.
-    assertTrue(client.closed);
+    assertThat(client.closed).isTrue();
     client.listener.assertFailure(
         ProtocolException.class, "Server-sent frames must not be masked.");
 
@@ -238,11 +239,12 @@
     client.webSocket.close(1000, "Hello!");
     server.processNextFrame();
 
-    assertFalse(client.closed); // Not closed until close reply is received.
+    // Not closed until close reply is received.
+    assertThat(client.closed).isFalse();
     server.sink.write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
 
     client.processNextFrame(); // Detects error, disconnects immediately since close already sent.
-    assertTrue(client.closed);
+    assertThat(client.closed).isTrue();
     client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
     server.listener.assertClosing(1000, "Hello!");
@@ -269,7 +271,7 @@
 
     client.webSocket.close(1000, "Bye!");
     client.listener.assertFailure(IOException.class, "failure");
-    assertTrue(client.closed);
+    assertThat(client.closed).isTrue();
   }
 
   @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
@@ -292,17 +294,20 @@
     server.processNextFrame(); // Ping.
     client.processNextFrame(); // Pong.
     long elapsedUntilPing1 = System.nanoTime() - startNanos;
-    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing1), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing1)).isCloseTo((double) 500, offset(
+        250d));
 
     server.processNextFrame(); // Ping.
     client.processNextFrame(); // Pong.
     long elapsedUntilPing2 = System.nanoTime() - startNanos;
-    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing2), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing2)).isCloseTo((double) 1000, offset(
+        250d));
 
     server.processNextFrame(); // Ping.
     client.processNextFrame(); // Pong.
     long elapsedUntilPing3 = System.nanoTime() - startNanos;
-    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing3), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing3)).isCloseTo((double) 1500, offset(
+        250d));
   }
 
   @Test public void unacknowledgedPingFailsConnection() throws IOException {
@@ -313,7 +318,8 @@
     client.listener.assertFailure(SocketTimeoutException.class,
         "sent ping but didn't receive pong within 500ms (after 0 successful ping/pongs)");
     long elapsedUntilFailure = System.nanoTime() - startNanos;
-    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 1000, offset(
+        250d));
   }
 
   @Test public void unexpectedPongsDoNotInterfereWithFailureDetection() throws IOException {
@@ -332,14 +338,16 @@
     server.processNextFrame(); // Ping.
     client.processNextFrame(); // Pong.
     long elapsedUntilPing = System.nanoTime() - startNanos;
-    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing)).isCloseTo((double) 500, offset(
+        250d));
 
     // After 1000ms the client will attempt a ping 2, but we don't process it. That'll cause the
     // client to fail at 1500ms when it's time to send ping 3 because pong 2 hasn't been received.
     client.listener.assertFailure(SocketTimeoutException.class,
         "sent ping but didn't receive pong within 500ms (after 1 successful ping/pongs)");
     long elapsedUntilFailure = System.nanoTime() - startNanos;
-    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 1500, offset(
+        250d));
   }
 
   /** One peer's streams, listener, and web socket in the test. */
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
similarity index 73%
rename from okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
rename to okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
index d926d23f7f..c1d110858c 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
@@ -17,16 +17,17 @@
 
 import java.io.EOFException;
 import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.net.HttpURLConnection;
 import java.net.ProtocolException;
 import java.net.SocketTimeoutException;
-import java.util.Collections;
 import java.util.Random;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Logger;
-import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
 import okhttp3.RecordingEventListener;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
@@ -39,7 +40,7 @@
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.mockwebserver.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.ByteString;
 import org.junit.After;
@@ -47,95 +48,108 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static java.util.Arrays.asList;
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.TestUtil.ensureAllConnectionsReleased;
 import static okhttp3.TestUtil.repeat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Offset.offset;
 import static org.junit.Assert.fail;
 
 public final class WebSocketHttpTest {
   @Rule public final MockWebServer webServer = new MockWebServer();
 
-  private final SslClient sslClient = SslClient.localhost();
+  private final HandshakeCertificates handshakeCertificates = localhost();
   private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
   private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
   private final Random random = new Random(0);
   private OkHttpClient client = defaultClient().newBuilder()
       .writeTimeout(500, TimeUnit.MILLISECONDS)
       .readTimeout(500, TimeUnit.MILLISECONDS)
-      .addInterceptor(new Interceptor() {
-        @Override public Response intercept(Chain chain) throws IOException {
-          Response response = chain.proceed(chain.request());
-          assertNotNull(response.body()); // Ensure application interceptors never see a null body.
-          return response;
-        }
+      .addInterceptor(chain -> {
+        Response response = chain.proceed(chain.request());
+        // Ensure application interceptors never see a null body.
+        assertThat(response.body()).isNotNull();
+        return response;
       })
       .build();
 
   @After public void tearDown() {
     clientListener.assertExhausted();
+
+    // TODO: assert all connections are released once leaks are fixed
   }
 
-  @Test public void textMessage() throws IOException {
+  @Test public void textMessage() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
 
     clientListener.assertOpen();
-    serverListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
 
     webSocket.send("Hello, WebSockets!");
     serverListener.assertTextMessage("Hello, WebSockets!");
+
+    closeWebSockets(webSocket, server);
   }
 
-  @Test public void binaryMessage() throws IOException {
+  @Test public void binaryMessage() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
 
     clientListener.assertOpen();
-    serverListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
 
     webSocket.send(ByteString.encodeUtf8("Hello!"));
     serverListener.assertBinaryMessage(ByteString.of(new byte[] {'H', 'e', 'l', 'l', 'o', '!'}));
+
+    closeWebSockets(webSocket, server);
   }
 
-  @Test public void nullStringThrows() throws IOException {
+  @Test public void nullStringThrows() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
 
     clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
     try {
       webSocket.send((String) null);
       fail();
     } catch (NullPointerException e) {
-      assertEquals("text == null", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("text == null");
     }
+
+    closeWebSockets(webSocket, server);
   }
 
-  @Test public void nullByteStringThrows() throws IOException {
+  @Test public void nullByteStringThrows() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
 
     clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
     try {
       webSocket.send((ByteString) null);
       fail();
     } catch (NullPointerException e) {
-      assertEquals("bytes == null", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("bytes == null");
     }
+
+    closeWebSockets(webSocket, server);
   }
 
-  @Test public void serverMessage() throws IOException {
+  @Test public void serverMessage() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    newWebSocket();
+    WebSocket webSocket = newWebSocket();
 
     clientListener.assertOpen();
     WebSocket server = serverListener.assertOpen();
 
     server.send("Hello, WebSockets!");
     clientListener.assertTextMessage("Hello, WebSockets!");
+
+    closeWebSockets(webSocket, server);
   }
 
   @Test public void throwingOnOpenFailsImmediately() {
@@ -150,12 +164,13 @@
     newWebSocket();
 
     serverListener.assertOpen();
+    serverListener.assertFailure(EOFException.class);
     serverListener.assertExhausted();
     clientListener.assertFailure(e);
   }
 
   @Ignore("AsyncCall currently lets runtime exceptions propagate.")
-  @Test public void throwingOnFailLogs() throws InterruptedException {
+  @Test public void throwingOnFailLogs() throws Exception {
     TestLogHandler logs = new TestLogHandler();
     Logger logger = Logger.getLogger(OkHttpClient.class.getName());
     logger.addHandler(logs);
@@ -171,11 +186,11 @@
 
     newWebSocket();
 
-    assertEquals("", logs.take());
+    assertThat(logs.take()).isEqualTo("");
     logger.removeHandler(logs);
   }
 
-  @Test public void throwingOnMessageClosesImmediatelyAndFails() throws IOException {
+  @Test public void throwingOnMessageClosesImmediatelyAndFails() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     newWebSocket();
 
@@ -195,7 +210,7 @@
     serverListener.assertExhausted();
   }
 
-  @Test public void throwingOnClosingClosesImmediatelyAndFails() throws IOException {
+  @Test public void throwingOnClosingClosesImmediatelyAndFails() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     newWebSocket();
 
@@ -239,13 +254,10 @@
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     newWebSocket();
 
-    clientListener.assertOpen();
+    WebSocket webSocket = clientListener.assertOpen();
     WebSocket server = serverListener.assertOpen();
 
-    server.close(1001, "bye");
-    clientListener.assertClosing(1001, "bye");
-    clientListener.assertExhausted();
-    serverListener.assertExhausted();
+    closeWebSockets(webSocket, server);
   }
 
   @Test public void non101RetainsBody() throws IOException {
@@ -277,6 +289,8 @@
 
     server.send("def");
     clientListener.assertTextMessage("def");
+
+    closeWebSockets(webSocket, server);
   }
 
   @Test public void missingConnectionHeader() throws IOException {
@@ -288,6 +302,8 @@
 
     clientListener.assertFailure(101, null, ProtocolException.class,
         "Expected 'Connection' header value 'Upgrade' but was 'null'");
+
+    ensureAllConnectionsReleased(client);
   }
 
   @Test public void wrongConnectionHeader() throws IOException {
@@ -348,51 +364,46 @@
         "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
   }
 
-  @Test public void webSocketAndApplicationInterceptors() throws IOException {
+  @Test public void webSocketAndApplicationInterceptors() {
     final AtomicInteger interceptedCount = new AtomicInteger();
 
     client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            assertNull(chain.request().body());
-            Response response = chain.proceed(chain.request());
-            assertEquals("Upgrade", response.header("Connection"));
-            assertTrue(response.body().source().exhausted());
-            interceptedCount.incrementAndGet();
-            return response;
-          }
-        }).build();
+        .addInterceptor(chain -> {
+          assertThat(chain.request().body()).isNull();
+          Response response = chain.proceed(chain.request());
+          assertThat(response.header("Connection")).isEqualTo("Upgrade");
+          assertThat(response.body().source().exhausted()).isTrue();
+          interceptedCount.incrementAndGet();
+          return response;
+        })
+        .build();
 
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     WebSocket webSocket = newWebSocket();
     clientListener.assertOpen();
-    assertEquals(1, interceptedCount.get());
-    webSocket.close(1000, null);
+    assertThat(interceptedCount.get()).isEqualTo(1);
 
-    WebSocket server = serverListener.assertOpen();
-    server.close(1000, null);
+    closeWebSockets(webSocket, serverListener.assertOpen());
   }
 
-  @Test public void webSocketAndNetworkInterceptors() throws IOException {
+  @Test public void webSocketAndNetworkInterceptors() {
     client = client.newBuilder()
-        .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            throw new AssertionError(); // Network interceptors don't execute.
-          }
-        }).build();
+        .addNetworkInterceptor(chain -> {
+          throw new AssertionError(); // Network interceptors don't execute.
+        })
+        .build();
 
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     WebSocket webSocket = newWebSocket();
     clientListener.assertOpen();
-    webSocket.close(1000, null);
-
     WebSocket server = serverListener.assertOpen();
-    server.close(1000, null);
+
+    closeWebSockets(webSocket, server);
   }
 
-  @Test public void overflowOutgoingQueue() throws IOException {
+  @Test public void overflowOutgoingQueue() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     WebSocket webSocket = newWebSocket();
@@ -400,15 +411,16 @@
 
     // Send messages until the client's outgoing buffer overflows!
     ByteString message = ByteString.of(new byte[1024 * 1024]);
-    int messageCount = 0;
+    long messageCount = 0;
     while (true) {
       boolean success = webSocket.send(message);
       if (!success) break;
 
       messageCount++;
       long queueSize = webSocket.queueSize();
-      assertTrue(queueSize >= 0 && queueSize <= messageCount * message.size());
-      assertTrue(messageCount < 32); // Expect to fail before enqueueing 32 MiB.
+      assertThat(queueSize).isBetween(0L, messageCount * message.size());
+      // Expect to fail before enqueueing 32 MiB.
+      assertThat(messageCount).isLessThan(32L);
     }
 
     // Confirm all sent messages were received, followed by a client-initiated close.
@@ -425,7 +437,7 @@
     serverListener.assertClosed(1001, "");
   }
 
-  @Test public void closeReasonMaximumLength() throws IOException {
+  @Test public void closeReasonMaximumLength() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     String clientReason = repeat('C', 123);
@@ -445,7 +457,7 @@
     serverListener.assertClosed(1000, clientReason);
   }
 
-  @Test public void closeReasonTooLong() throws IOException {
+  @Test public void closeReasonTooLong() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     WebSocket webSocket = newWebSocket();
@@ -457,7 +469,7 @@
       webSocket.close(1000, reason);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("reason.size() > 123: " + reason, expected.getMessage());
+      assertThat(expected.getMessage()).isEqualTo(("reason.size() > 123: " + reason));
     }
 
     webSocket.close(1000, null);
@@ -470,42 +482,44 @@
     serverListener.assertClosed(1000, "");
   }
 
-  @Test public void wsScheme() throws IOException {
+  @Test public void wsScheme() {
     websocketScheme("ws");
   }
 
-  @Test public void wsUppercaseScheme() throws IOException {
+  @Test public void wsUppercaseScheme() {
     websocketScheme("WS");
   }
 
-  @Test public void wssScheme() throws IOException {
-    webServer.useHttps(sslClient.socketFactory, false);
+  @Test public void wssScheme() {
+    webServer.useHttps(handshakeCertificates.sslSocketFactory(), false);
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
     websocketScheme("wss");
   }
 
-  @Test public void httpsScheme() throws IOException {
-    webServer.useHttps(sslClient.socketFactory, false);
+  @Test public void httpsScheme() {
+    webServer.useHttps(handshakeCertificates.sslSocketFactory(), false);
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
     websocketScheme("https");
   }
 
-  @Test public void readTimeoutAppliesToHttpRequest() throws IOException {
+  @Test public void readTimeoutAppliesToHttpRequest() {
     webServer.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.NO_RESPONSE));
 
     WebSocket webSocket = newWebSocket();
 
     clientListener.assertFailure(SocketTimeoutException.class, "timeout", "Read timed out");
-    assertFalse(webSocket.close(1000, null));
+    assertThat(webSocket.close(1000, null)).isFalse();
   }
 
   /**
@@ -513,9 +527,9 @@
    * reading a frame we enable the read timeout. In this test we have the server returning the first
    * byte of a frame but no more frames.
    */
-  @Test public void readTimeoutAppliesWithinFrames() throws IOException {
+  @Test public void readTimeoutAppliesWithinFrames() {
     webServer.setDispatcher(new Dispatcher() {
-      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+      @Override public MockResponse dispatch(RecordedRequest request) {
         return upgradeResponse(request)
             .setBody(new Buffer().write(ByteString.decodeHex("81"))) // Truncated frame.
             .removeHeader("Content-Length")
@@ -527,12 +541,12 @@
     clientListener.assertOpen();
 
     clientListener.assertFailure(SocketTimeoutException.class, "timeout", "Read timed out");
-    assertFalse(webSocket.close(1000, null));
+    assertThat(webSocket.close(1000, null)).isFalse();
   }
 
   @Test public void readTimeoutDoesNotApplyAcrossFrames() throws Exception {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    newWebSocket();
+    WebSocket webSocket = newWebSocket();
 
     clientListener.assertOpen();
     WebSocket server = serverListener.assertOpen();
@@ -542,6 +556,8 @@
 
     server.send("abc");
     clientListener.assertTextMessage("abc");
+
+    closeWebSockets(webSocket, server);
   }
 
   @Test public void clientPingsServerOnInterval() throws Exception {
@@ -561,16 +577,19 @@
     }
 
     long elapsedUntilPong3 = System.nanoTime() - startNanos;
-    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3)).isCloseTo((double) 1500, offset(
+        250d));
 
     // The client pinged the server 3 times, and it has ponged back 3 times.
-    assertEquals(3, webSocket.sentPingCount());
-    assertEquals(3, server.receivedPingCount());
-    assertEquals(3, webSocket.receivedPongCount());
+    assertThat(webSocket.sentPingCount()).isEqualTo(3);
+    assertThat(server.receivedPingCount()).isEqualTo(3);
+    assertThat(webSocket.receivedPongCount()).isEqualTo(3);
 
     // The server has never pinged the client.
-    assertEquals(0, server.receivedPongCount());
-    assertEquals(0, webSocket.receivedPingCount());
+    assertThat(server.receivedPongCount()).isEqualTo(0);
+    assertThat(webSocket.receivedPingCount()).isEqualTo(0);
+
+    closeWebSockets(webSocket, server);
   }
 
   @Test public void clientDoesNotPingServerByDefault() throws Exception {
@@ -583,12 +602,14 @@
     Thread.sleep(1000);
 
     // No pings and no pongs.
-    assertEquals(0, webSocket.sentPingCount());
-    assertEquals(0, webSocket.receivedPingCount());
-    assertEquals(0, webSocket.receivedPongCount());
-    assertEquals(0, server.sentPingCount());
-    assertEquals(0, server.receivedPingCount());
-    assertEquals(0, server.receivedPongCount());
+    assertThat(webSocket.sentPingCount()).isEqualTo(0);
+    assertThat(webSocket.receivedPingCount()).isEqualTo(0);
+    assertThat(webSocket.receivedPongCount()).isEqualTo(0);
+    assertThat(server.sentPingCount()).isEqualTo(0);
+    assertThat(server.receivedPingCount()).isEqualTo(0);
+    assertThat(server.receivedPongCount()).isEqualTo(0);
+
+    closeWebSockets(webSocket, server);
   }
 
   /**
@@ -596,7 +617,7 @@
    * responding to pings. The client should give up when attempting to send its 2nd ping, at about
    * 1000 ms.
    */
-  @Test public void unacknowledgedPingFailsConnection() throws Exception {
+  @Test public void unacknowledgedPingFailsConnection() {
     client = client.newBuilder()
         .pingInterval(500, TimeUnit.MILLISECONDS)
         .build();
@@ -621,11 +642,12 @@
     latch.countDown();
 
     long elapsedUntilFailure = System.nanoTime() - openAtNanos;
-    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 1000, offset(
+        250d));
   }
 
   /** https://github.com/square/okhttp/issues/2788 */
-  @Test public void clientCancelsIfCloseIsNotAcknowledged() throws Exception {
+  @Test public void clientCancelsIfCloseIsNotAcknowledged() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     RealWebSocket webSocket = newWebSocket();
 
@@ -640,14 +662,15 @@
     // Confirm that the hard cancel occurred after 500 ms.
     clientListener.assertFailure();
     long elapsedUntilFailure = System.nanoTime() - closeAtNanos;
-    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 500, offset(
+        250d));
 
     // Close the server and confirm it saw what we expected.
     server.close(1000, null);
     serverListener.assertClosed(1000, "goodbye");
   }
 
-  @Test public void webSocketsDontTriggerEventListener() throws IOException {
+  @Test public void webSocketsDontTriggerEventListener() {
     RecordingEventListener listener = new RecordingEventListener();
 
     client = client.newBuilder()
@@ -671,7 +694,70 @@
     clientListener.assertClosed(1000, "");
     serverListener.assertClosed(1000, "");
 
-    assertEquals(Collections.emptyList(), listener.recordedEventTypes());
+    assertThat(listener.recordedEventTypes()).isEmpty();
+  }
+
+  @Test public void callTimeoutAppliesToSetup() throws Exception {
+    webServer.enqueue(new MockResponse()
+        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
+
+    client = client.newBuilder()
+        .readTimeout(0, TimeUnit.MILLISECONDS)
+        .writeTimeout(0, TimeUnit.MILLISECONDS)
+        .callTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    newWebSocket();
+    clientListener.assertFailure(InterruptedIOException.class, "timeout");
+  }
+
+  @Test public void callTimeoutDoesNotApplyOnceConnected() throws Exception {
+    client = client.newBuilder()
+        .callTimeout(100, TimeUnit.MILLISECONDS)
+        .build();
+
+    webServer.enqueue(new MockResponse()
+        .withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    Thread.sleep(500);
+
+    server.send("Hello, WebSockets!");
+    clientListener.assertTextMessage("Hello, WebSockets!");
+
+    closeWebSockets(webSocket, server);
+  }
+
+  /**
+   * We had a bug where web socket connections were leaked if the HTTP connection upgrade was not
+   * successful. This test confirms that connections are released back to the connection pool!
+   * https://github.com/square/okhttp/issues/4258
+   */
+  @Test public void webSocketConnectionIsReleased() throws Exception {
+    // This test assumes HTTP/1.1 pooling semantics.
+    client = client.newBuilder()
+        .protocols(asList(Protocol.HTTP_1_1))
+        .build();
+
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_FOUND)
+        .setBody("not found!"));
+    webServer.enqueue(new MockResponse());
+
+    newWebSocket();
+    clientListener.assertFailure();
+
+    Request regularRequest = new Request.Builder()
+        .url(webServer.url("/"))
+        .build();
+    Response response = client.newCall(regularRequest).execute();
+    response.close();
+
+    assertThat(webServer.takeRequest().getSequenceNumber()).isEqualTo(0);
+    assertThat(webServer.takeRequest().getSequenceNumber()).isEqualTo(1);
   }
 
   private MockResponse upgradeResponse(RecordedRequest request) {
@@ -683,7 +769,7 @@ private MockResponse upgradeResponse(RecordedRequest request) {
         .setHeader("Sec-WebSocket-Accept", WebSocketProtocol.acceptHeader(key));
   }
 
-  private void websocketScheme(String scheme) throws IOException {
+  private void websocketScheme(String scheme) {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     Request request = new Request.Builder()
@@ -692,10 +778,12 @@ private void websocketScheme(String scheme) throws IOException {
 
     RealWebSocket webSocket = newWebSocket(request);
     clientListener.assertOpen();
-    serverListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
 
     webSocket.send("abc");
     serverListener.assertTextMessage("abc");
+
+    closeWebSockets(webSocket, server);
   }
 
   private RealWebSocket newWebSocket() {
@@ -708,4 +796,15 @@ private RealWebSocket newWebSocket(Request request) {
     webSocket.connect(client);
     return webSocket;
   }
+
+  private void closeWebSockets(WebSocket webSocket, WebSocket server) {
+    server.close(1001, "");
+    clientListener.assertClosing(1001, "");
+    webSocket.close(1000, "");
+    serverListener.assertClosing(1000, "");
+    clientListener.assertClosed(1001, "");
+    serverListener.assertClosed(1000, "");
+    clientListener.assertExhausted();
+    serverListener.assertExhausted();
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
similarity index 89%
rename from okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
rename to okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index 9fa5d1d9dc..07dac19ebb 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -19,15 +19,13 @@
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.Random;
-import java.util.regex.Pattern;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.ByteString;
 import org.junit.After;
 import org.junit.Test;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class WebSocketReaderTest {
@@ -49,7 +47,7 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Control frames must be final.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Control frames must be final.");
     }
   }
 
@@ -59,7 +57,7 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Reserved flags are unsupported.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Reserved flags are unsupported.");
     }
     data.clear();
     data.write(ByteString.decodeHex("aa00")); // Empty ping, flag 2 set.
@@ -67,7 +65,7 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Reserved flags are unsupported.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Reserved flags are unsupported.");
     }
     data.clear();
     data.write(ByteString.decodeHex("ca00")); // Empty ping, flag 3 set.
@@ -75,7 +73,7 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Reserved flags are unsupported.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Reserved flags are unsupported.");
     }
   }
 
@@ -85,7 +83,7 @@
       serverReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Client-sent frames must be masked.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Client-sent frames must be masked.");
     }
   }
 
@@ -95,7 +93,7 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Server-sent frames must not be masked.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Server-sent frames must not be masked.");
     }
   }
 
@@ -105,7 +103,7 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Control frame must be less than 125B.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Control frame must be less than 125B.");
     }
   }
 
@@ -139,7 +137,8 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Frame length 0x8000000000000000 > 0x7FFFFFFFFFFFFFFF", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "Frame length 0x8000000000000000 > 0x7FFFFFFFFFFFFFFF");
     }
   }
 
@@ -233,7 +232,7 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Expected continuation opcode. Got: 2", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Expected continuation opcode. Got: 2");
     }
   }
 
@@ -261,7 +260,7 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Malformed close payload length of 1.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Malformed close payload length of 1.");
     }
   }
 
@@ -284,14 +283,14 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Code must be in range [1000,5000): 1", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Code must be in range [1000,5000): 1");
     }
     data.write(ByteString.decodeHex("88021388")); // Close with code 5000
     try {
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Code must be in range [1000,5000): 5000", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Code must be in range [1000,5000): 5000");
     }
   }
 
@@ -309,11 +308,10 @@
         clientReader.processNextFrame();
         fail();
       } catch (ProtocolException e) {
-        String message = e.getMessage();
-        assertTrue(message, Pattern.matches("Code \\d+ is reserved and may not be used.", message));
+        assertThat(e.getMessage()).matches("Code \\d+ is reserved and may not be used.");
       }
     }
-    assertEquals(1991, count);
+    assertThat(count).isEqualTo(1991);
   }
 
   private byte[] binaryData(int length) {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
similarity index 89%
rename from okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
rename to okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
index f6256ac42f..0ab1d1857b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
@@ -16,7 +16,7 @@
 package okhttp3.internal.ws;
 
 import java.io.IOException;
-import java.util.Arrays;
+import java.util.Objects;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
@@ -24,14 +24,10 @@
 import okhttp3.Response;
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
-import okhttp3.internal.Util;
 import okhttp3.internal.platform.Platform;
 import okio.ByteString;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public final class WebSocketRecorder extends WebSocketListener {
   private final String name;
@@ -86,7 +82,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
   }
 
   @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onClose " + code, null);
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onClosing " + code, null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
@@ -98,7 +94,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
   }
 
   @Override public void onClosed(WebSocket webSocket, int code, String reason) {
-    Platform.get().log(Platform.INFO, "[WS " + name + "] onClose " + code, null);
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onClosed " + code, null);
 
     WebSocketListener delegate = this.delegate;
     if (delegate != null) {
@@ -135,36 +131,36 @@ private Object nextEvent() {
 
   public void assertTextMessage(String payload) {
     Object actual = nextEvent();
-    assertEquals(new Message(payload), actual);
+    assertThat(actual).isEqualTo(new Message(payload));
   }
 
   public void assertBinaryMessage(ByteString payload) {
     Object actual = nextEvent();
-    assertEquals(new Message(payload), actual);
+    assertThat(actual).isEqualTo(new Message(payload));
   }
 
   public void assertPing(ByteString payload) {
     Object actual = nextEvent();
-    assertEquals(new Ping(payload), actual);
+    assertThat(actual).isEqualTo(new Ping(payload));
   }
 
   public void assertPong(ByteString payload) {
     Object actual = nextEvent();
-    assertEquals(new Pong(payload), actual);
+    assertThat(actual).isEqualTo(new Pong(payload));
   }
 
   public void assertClosing(int code, String reason) {
     Object actual = nextEvent();
-    assertEquals(new Closing(code, reason), actual);
+    assertThat(actual).isEqualTo(new Closing(code, reason));
   }
 
   public void assertClosed(int code, String reason) {
     Object actual = nextEvent();
-    assertEquals(new Closed(code, reason), actual);
+    assertThat(actual).isEqualTo(new Closed(code, reason));
   }
 
   public void assertExhausted() {
-    assertTrue("Remaining events: " + events, events.isEmpty());
+    assertThat(events).isEmpty();
   }
 
   public WebSocket assertOpen() {
@@ -181,8 +177,8 @@ public void assertFailure(Throwable t) {
       throw new AssertionError("Expected Failure but was " + event);
     }
     Failure failure = (Failure) event;
-    assertNull(failure.response);
-    assertSame(t, failure.t);
+    assertThat(failure.response).isNull();
+    assertThat(failure.t).isSameAs(t);
   }
 
   public void assertFailure(Class<? extends IOException> cls, String... messages) {
@@ -191,10 +187,10 @@ public void assertFailure(Class<? extends IOException> cls, String... messages)
       throw new AssertionError("Expected Failure but was " + event);
     }
     Failure failure = (Failure) event;
-    assertNull(failure.response);
-    assertEquals(cls, failure.t.getClass());
+    assertThat(failure.response).isNull();
+    assertThat(failure.t.getClass()).isEqualTo(cls);
     if (messages.length > 0) {
-      assertTrue(failure.t.getMessage(), Arrays.asList(messages).contains(failure.t.getMessage()));
+      assertThat(messages).contains(failure.t.getMessage());
     }
   }
 
@@ -212,12 +208,12 @@ public void assertFailure(int code, String body, Class<? extends IOException> cl
       throw new AssertionError("Expected Failure but was " + event);
     }
     Failure failure = (Failure) event;
-    assertEquals(code, failure.response.code());
+    assertThat(failure.response.code()).isEqualTo(code);
     if (body != null) {
-      assertEquals(body, failure.responseBody);
+      assertThat(failure.responseBody).isEqualTo(body);
     }
-    assertEquals(cls, failure.t.getClass());
-    assertEquals(message, failure.t.getMessage());
+    assertThat(failure.t.getClass()).isEqualTo(cls);
+    assertThat(failure.t.getMessage()).isEqualTo(message);
   }
 
   /** Expose this recorder as a frame callback and shim in "ping" events. */
@@ -309,8 +305,8 @@ public Message(String string) {
 
     @Override public boolean equals(Object other) {
       return other instanceof Message
-          && Util.equal(((Message) other).bytes, bytes)
-          && Util.equal(((Message) other).string, string);
+          && Objects.equals(((Message) other).bytes, bytes)
+          && Objects.equals(((Message) other).string, string);
     }
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
similarity index 90%
rename from okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
rename to okhttp/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
index e183d0e2a8..175df0ea7a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
+++ b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -28,7 +28,6 @@
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
-import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
 
 import static okhttp3.TestUtil.repeat;
@@ -36,9 +35,7 @@
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
 import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
-import static okhttp3.internal.ws.WebSocketProtocol.toggleMask;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class WebSocketWriterTest {
@@ -49,14 +46,11 @@
    * Check all data as verified inside of the test. We do this in a rule instead of @After so that
    * exceptions thrown from the test do not cause this check to fail.
    */
-  @Rule public final TestRule noDataLeftBehind = new TestRule() {
-    @Override public Statement apply(final Statement base, Description description) {
-      return new Statement() {
-        @Override public void evaluate() throws Throwable {
-          base.evaluate();
-          assertEquals("Data not empty", "", data.readByteString().hex());
-        }
-      };
+  @Rule public final TestRule noDataLeftBehind = (base, description) -> new Statement() {
+    @Override public void evaluate() throws Throwable {
+      base.evaluate();
+      assertThat(data.readByteString().hex()).overridingErrorMessage("Data not empty").isEqualTo(
+          "");
     }
   };
 
@@ -88,7 +82,7 @@
 
     assertData("8105");
     assertData(bytes);
-    assertTrue(data.exhausted());
+    assertThat(data.exhausted()).isTrue();
   }
 
   @Test public void serverLargeBufferedPayloadWrittenAsOneFrame() throws IOException {
@@ -103,7 +97,7 @@
     assertData("817e");
     assertData(Util.format("%04x", length));
     assertData(bytes);
-    assertTrue(data.exhausted());
+    assertThat(data.exhausted()).isTrue();
   }
 
   @Test public void serverLargeNonBufferedPayloadWrittenAsMultipleFrames() throws IOException {
@@ -131,7 +125,7 @@
     assertData(bytes.readByteArray(24_576));
     assertData("807e06a0");
     assertData(bytes.readByteArray(1_696));
-    assertTrue(data.exhausted());
+    assertThat(data.exhausted()).isTrue();
   }
 
   @Test public void closeFlushes() throws IOException {
@@ -156,7 +150,7 @@
       sink.write(payload, payload.size());
       fail();
     } catch (IOException e) {
-      assertEquals("closed", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("closed");
     }
   }
 
@@ -294,7 +288,7 @@
       clientWriter.writeClose(98724976, ByteString.encodeUtf8("Hello"));
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("Code must be in range [1000,5000): 98724976", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Code must be in range [1000,5000): 98724976");
     }
   }
 
@@ -303,7 +297,7 @@
       clientWriter.writeClose(1005, ByteString.encodeUtf8("Hello"));
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("Code 1005 is reserved and may not be used.", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo("Code 1005 is reserved and may not be used.");
     }
   }
 
@@ -352,7 +346,8 @@
       serverWriter.writePing(ByteString.of(binaryData(1000)));
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "Payload size must be less than or equal to 125");
     }
   }
 
@@ -361,7 +356,8 @@
       serverWriter.writePong(ByteString.of(binaryData(1000)));
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "Payload size must be less than or equal to 125");
     }
   }
 
@@ -371,7 +367,8 @@
       serverWriter.writeClose(1000, longReason);
       fail();
     } catch (IllegalArgumentException e) {
-      assertEquals("Payload size must be less than or equal to 125", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "Payload size must be less than or equal to 125");
     }
   }
 
@@ -381,7 +378,8 @@
       clientWriter.newMessageSink(OPCODE_TEXT, -1);
       fail();
     } catch (IllegalStateException e) {
-      assertEquals("Another message writer is active. Did you call close()?", e.getMessage());
+      assertThat(e.getMessage()).isEqualTo(
+          "Another message writer is active. Did you call close()?");
     }
   }
 
@@ -391,7 +389,7 @@ private void assertData(String hex) throws EOFException {
 
   private void assertData(ByteString expected) throws EOFException {
     ByteString actual = data.readByteString(expected.size());
-    assertEquals(expected, actual);
+    assertThat(actual).isEqualTo(expected);
   }
 
   private void assertData(byte[] data) throws IOException {
@@ -400,7 +398,8 @@ private void assertData(byte[] data) throws IOException {
       int count = Math.min(byteCount, data.length - i);
       Buffer expectedChunk = new Buffer();
       expectedChunk.write(data, i, count);
-      assertEquals("At " + i, expectedChunk.readByteString(), this.data.readByteString(count));
+      assertThat(this.data.readByteString(count)).overridingErrorMessage("At " + i).isEqualTo(
+          expectedChunk.readByteString());
     }
   }
 
diff --git a/okhttp-tests/src/test/resources/web-platform-test-urltestdata.txt b/okhttp/src/test/resources/web-platform-test-urltestdata.txt
similarity index 100%
rename from okhttp-tests/src/test/resources/web-platform-test-urltestdata.txt
rename to okhttp/src/test/resources/web-platform-test-urltestdata.txt
diff --git a/pom.xml b/pom.xml
deleted file mode 100644
index dc7580d228..0000000000
--- a/pom.xml
+++ /dev/null
@@ -1,624 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>7</version>
-  </parent>
-
-  <groupId>com.squareup.okhttp3</groupId>
-  <artifactId>parent</artifactId>
-  <version>3.11.0-SNAPSHOT</version>
-  <packaging>pom</packaging>
-
-  <name>OkHttp (Parent)</name>
-  <description>An HTTP+HTTP/2 client for Android and Java applications</description>
-  <url>https://github.com/square/okhttp</url>
-
-  <modules>
-    <module>okhttp</module>
-    <module>okhttp-tests</module>
-
-    <module>okhttp-android-support</module>
-
-    <module>okhttp-apache</module>
-    <module>okhttp-testing-support</module>
-    <module>okhttp-urlconnection</module>
-
-    <module>okhttp-logging-interceptor</module>
-
-    <module>okcurl</module>
-    <module>mockwebserver</module>
-    <module>samples</module>
-    <module>benchmarks</module>
-  </modules>
-
-  <properties>
-    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-
-    <!-- Compilation -->
-    <airlift.version>0.7</airlift.version>
-    <!-- ALPN library targeted to Java 7 -->
-    <alpn.jdk7.version>7.1.2.v20141202</alpn.jdk7.version>
-    <android.version>4.1.1.4</android.version>
-    <animal.sniffer.version>1.15</animal.sniffer.version>
-    <apache.http.version>4.2.2</apache.http.version>
-    <bouncycastle.version>1.50</bouncycastle.version>
-    <guava.version>16.0</guava.version>
-    <java.version>1.7</java.version>
-    <moshi.version>1.1.0</moshi.version>
-    <okio.version>1.14.0</okio.version>
-
-    <!-- Test Dependencies -->
-    <junit.version>4.12</junit.version>
-
-    <!-- platform test mode -->
-    <okhttp.platform>platform</okhttp.platform>
-  </properties>
-
-  <scm>
-    <url>https://github.com/square/okhttp/</url>
-    <connection>scm:git:https://github.com/square/okhttp.git</connection>
-    <developerConnection>scm:git:git@github.com:square/okhttp.git</developerConnection>
-    <tag>HEAD</tag>
-  </scm>
-
-  <issueManagement>
-    <system>GitHub Issues</system>
-    <url>https://github.com/square/okhttp/issues</url>
-  </issueManagement>
-
-  <licenses>
-    <license>
-      <name>Apache 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-    </license>
-  </licenses>
-
-  <dependencyManagement>
-    <dependencies>
-      <dependency>
-        <groupId>com.squareup.okio</groupId>
-        <artifactId>okio</artifactId>
-        <version>${okio.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.code.findbugs</groupId>
-        <artifactId>jsr305</artifactId>
-        <version>3.0.2</version>
-        <scope>provided</scope>
-      </dependency>
-      <dependency>
-        <groupId>junit</groupId>
-        <artifactId>junit</artifactId>
-        <version>${junit.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.bouncycastle</groupId>
-        <artifactId>bcprov-jdk15on</artifactId>
-        <version>${bouncycastle.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.apache.httpcomponents</groupId>
-        <artifactId>httpclient</artifactId>
-        <version>${apache.http.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>io.airlift</groupId>
-        <artifactId>airline</artifactId>
-        <version>${airlift.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.guava</groupId>
-        <artifactId>guava</artifactId>
-        <version>${guava.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.android</groupId>
-        <artifactId>android</artifactId>
-        <version>${android.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.squareup.moshi</groupId>
-        <artifactId>moshi</artifactId>
-        <version>${moshi.version}</version>
-      </dependency>
-    </dependencies>
-  </dependencyManagement>
-
-  <build>
-    <pluginManagement>
-      <plugins>
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.6.1</version>
-          <configuration>
-            <compilerId>javac-with-errorprone</compilerId>
-            <forceJavacCompilerUse>true</forceJavacCompilerUse>
-            <source>${java.version}</source>
-            <target>${java.version}</target>
-          </configuration>
-          <dependencies>
-            <dependency>
-              <groupId>org.codehaus.plexus</groupId>
-              <artifactId>plexus-compiler-javac-errorprone</artifactId>
-              <version>2.8.1</version>
-            </dependency>
-            <dependency>
-              <groupId>com.google.errorprone</groupId>
-              <artifactId>error_prone_core</artifactId>
-              <version>2.0.16</version>
-            </dependency>
-          </dependencies>
-        </plugin>
-
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-surefire-plugin</artifactId>
-          <version>2.17</version>
-          <configuration>
-            <systemPropertyVariables>
-              <okhttp.platform>${okhttp.platform}</okhttp.platform>
-            </systemPropertyVariables>
-            <redirectTestOutputToFile>true</redirectTestOutputToFile>
-            <properties>
-              <!--
-                Configure a listener for enforcing that no uncaught exceptions issue from OkHttp
-                tests. Every test must have a <scope>test</scope> dependency on
-                okhttp-testing-support.
-                -->
-              <property>
-                <name>listener</name>
-                <value>okhttp3.testing.InstallUncaughtExceptionHandlerListener</value>
-              </property>
-            </properties>
-          </configuration>
-          <dependencies>
-            <dependency>
-              <groupId>org.apache.maven.surefire</groupId>
-              <artifactId>surefire-junit47</artifactId>
-              <version>2.17</version>
-            </dependency>
-          </dependencies>
-        </plugin>
-
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-javadoc-plugin</artifactId>
-          <version>2.10.4</version>
-        </plugin>
-      </plugins>
-    </pluginManagement>
-
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <version>2.4.2</version>
-        <dependencies>
-          <dependency>
-            <groupId>org.apache.maven.scm</groupId>
-            <artifactId>maven-scm-provider-gitexe</artifactId>
-            <version>1.9</version>
-          </dependency>
-        </dependencies>
-        <configuration>
-          <autoVersionSubmodules>true</autoVersionSubmodules>
-        </configuration>
-      </plugin>
-
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.17</version>
-        <dependencies>
-          <dependency>
-            <groupId>com.puppycrawl.tools</groupId>
-            <artifactId>checkstyle</artifactId>
-            <version>7.7</version>
-          </dependency>
-        </dependencies>
-        <configuration>
-          <failsOnError>true</failsOnError>
-          <configLocation>checkstyle.xml</configLocation>
-          <consoleOutput>true</consoleOutput>
-          <excludes>**/CipherSuite.java</excludes>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>verify</phase>
-            <goals>
-              <goal>checkstyle</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <version>${animal.sniffer.version}</version>
-        <executions>
-          <execution>
-            <phase>test</phase>
-            <goals>
-              <goal>check</goal>
-            </goals>
-          </execution>
-        </executions>
-        <configuration>
-          <signature>
-            <groupId>org.codehaus.mojo.signature</groupId>
-            <artifactId>java16</artifactId>
-            <version>1.1</version>
-          </signature>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-
-  <profiles>
-    <profile>
-      <id>alpn-when-jdk7</id>
-      <activation>
-        <jdk>1.7</jdk>
-      </activation>
-      <properties>
-        <bootclasspathPrefix>
-          ${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk7.version}/alpn-boot-${alpn.jdk7.version}.jar
-        </bootclasspathPrefix>
-        <okhttp.platform>jdk-with-jetty-boot</okhttp.platform>
-      </properties>
-      <build>
-        <pluginManagement>
-          <plugins>
-            <plugin>
-              <groupId>org.apache.maven.plugins</groupId>
-              <artifactId>maven-surefire-plugin</artifactId>
-              <configuration>
-                <argLine>-Xbootclasspath/p:${bootclasspathPrefix} -Xms512m -Xmx512m</argLine>
-              </configuration>
-              <dependencies>
-                <dependency>
-                  <groupId>org.mortbay.jetty.alpn</groupId>
-                  <artifactId>alpn-boot</artifactId>
-                  <version>${alpn.jdk7.version}</version>
-                </dependency>
-              </dependencies>
-            </plugin>
-          </plugins>
-        </pluginManagement>
-      </build>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8</id>
-      <activation>
-        <jdk>1.8</jdk>
-      </activation>
-      <properties>
-        <bootclasspathPrefix>
-          ${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.jdk8.version}/alpn-boot-${alpn.jdk8.version}.jar
-        </bootclasspathPrefix>
-        <okhttp.platform>jdk-with-jetty-boot</okhttp.platform>
-      </properties>
-      <build>
-        <pluginManagement>
-          <plugins>
-            <plugin>
-              <groupId>org.apache.maven.plugins</groupId>
-              <artifactId>maven-surefire-plugin</artifactId>
-              <configuration>
-                <argLine>-Xbootclasspath/p:${bootclasspathPrefix} -Xms512m -Xmx512m</argLine>
-              </configuration>
-              <dependencies>
-                <dependency>
-                  <groupId>org.mortbay.jetty.alpn</groupId>
-                  <artifactId>alpn-boot</artifactId>
-                  <version>${alpn.jdk8.version}</version>
-                </dependency>
-              </dependencies>
-            </plugin>
-          </plugins>
-        </pluginManagement>
-      </build>
-    </profile>
-    <profile>
-      <id>jdk9</id>
-      <activation>
-        <jdk>9</jdk>
-      </activation>
-      <properties>
-        <okhttp.platform>jdk9</okhttp.platform>
-      </properties>
-    </profile>
-    <profile>
-      <id>conscrypt</id>
-      <properties>
-        <okhttp.platform>conscrypt</okhttp.platform>
-      </properties>
-      <dependencies>
-        <dependency>
-          <groupId>org.conscrypt</groupId>
-          <artifactId>conscrypt-openjdk-uber</artifactId>
-          <version>1.0.1</version>
-        </dependency>
-      </dependencies>
-    </profile>
-    <!-- ALPN Versions targeted for each Java 8 minor release -->
-    <!-- Check versions with this page: -->
-    <!-- http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html#alpn-chapterchapterversions -->
-    <profile>
-      <id>alpn-when-jdk8_05</id>
-      <activation>
-        <jdk>1.8.0_05</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_11</id>
-      <activation>
-        <jdk>1.8.0_11</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_20</id>
-      <activation>
-        <jdk>1.8.0_20</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.0.v20141016</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_25</id>
-      <activation>
-        <jdk>1.8.0_25</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.2.v20141202</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_31</id>
-      <activation>
-        <jdk>1.8.0_31</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_40</id>
-      <activation>
-        <jdk>1.8.0_40</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_45</id>
-      <activation>
-        <jdk>1.8.0_45</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.3.v20150130</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_51</id>
-      <activation>
-        <jdk>1.8.0_51</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.4.v20150727</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_60</id>
-      <activation>
-        <jdk>1.8.0_60</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.5.v20150921</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_65</id>
-      <activation>
-        <jdk>1.8.0_65</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.6.v20151105</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_66</id>
-      <activation>
-        <jdk>1.8.0_66</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.6.v20151105</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_71</id>
-      <activation>
-        <jdk>1.8.0_71</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_72</id>
-      <activation>
-        <jdk>1.8.0_72</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_73</id>
-      <activation>
-        <jdk>1.8.0_73</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_74</id>
-      <activation>
-        <jdk>1.8.0_74</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_77</id>
-      <activation>
-        <jdk>1.8.0_77</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_91</id>
-      <activation>
-        <jdk>1.8.0_91</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.7.v20160121</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_92</id>
-      <activation>
-        <jdk>1.8.0_92</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.8.v20160420</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_101</id>
-      <activation>
-        <jdk>1.8.0_101</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.8.v20160420</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_102</id>
-      <activation>
-        <jdk>1.8.0_102</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_111</id>
-      <activation>
-        <jdk>1.8.0_111</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_112</id>
-      <activation>
-        <jdk>1.8.0_112</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_121</id>
-      <activation>
-        <jdk>1.8.0_121</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_131</id>
-      <activation>
-        <jdk>1.8.0_131</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_141</id>
-      <activation>
-        <jdk>1.8.0_141</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_144</id>
-      <activation>
-        <jdk>1.8.0_144</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_151</id>
-      <activation>
-        <jdk>1.8.0_151</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_152</id>
-      <activation>
-        <jdk>1.8.0_152</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_161</id>
-      <activation>
-        <jdk>1.8.0_161</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
-      </properties>
-    </profile>
-    <profile>
-      <id>alpn-when-jdk8_162</id>
-      <activation>
-        <jdk>1.8.0_162</jdk>
-      </activation>
-      <properties>
-        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
-      </properties>
-    </profile>
-  </profiles>
-</project>
diff --git a/samples/crawler/build.gradle b/samples/crawler/build.gradle
new file mode 100644
index 0000000000..d9f72bd9c2
--- /dev/null
+++ b/samples/crawler/build.gradle
@@ -0,0 +1,4 @@
+dependencies {
+  implementation project(':okhttp')
+  implementation deps.jsoup
+}
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
deleted file mode 100644
index 81a9d1ae76..0000000000
--- a/samples/crawler/pom.xml
+++ /dev/null
@@ -1,27 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.11.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>crawler</artifactId>
-  <name>Sample: Crawler</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>org.jsoup</groupId>
-      <artifactId>jsoup</artifactId>
-      <version>1.7.3</version>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
index 72f59d32c2..95ba357def 100644
--- a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
+++ b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
@@ -41,8 +41,7 @@
  */
 public final class Crawler {
   private final OkHttpClient client;
-  private final Set<HttpUrl> fetchedUrls = Collections.synchronizedSet(
-      new LinkedHashSet<HttpUrl>());
+  private final Set<HttpUrl> fetchedUrls = Collections.synchronizedSet(new LinkedHashSet<>());
   private final LinkedBlockingQueue<HttpUrl> queue = new LinkedBlockingQueue<>();
   private final ConcurrentHashMap<String, AtomicInteger> hostnames = new ConcurrentHashMap<>();
 
@@ -140,7 +139,7 @@ public static void main(String[] args) throws IOException {
         .build();
 
     Crawler crawler = new Crawler(client);
-    crawler.queue.add(HttpUrl.parse(args[1]));
+    crawler.queue.add(HttpUrl.get(args[1]));
     crawler.parallelDrainQueue(threadCount);
   }
 }
diff --git a/samples/guide/build.gradle b/samples/guide/build.gradle
new file mode 100644
index 0000000000..7f2ef89506
--- /dev/null
+++ b/samples/guide/build.gradle
@@ -0,0 +1,6 @@
+dependencies {
+  implementation project(':okhttp')
+  implementation project(':mockwebserver')
+  implementation project(':okhttp-tls')
+  implementation deps.moshi
+}
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
deleted file mode 100644
index 43a4633981..0000000000
--- a/samples/guide/pom.xml
+++ /dev/null
@@ -1,26 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.11.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>guide</artifactId>
-  <name>Sample: Guide</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/samples/guide/src/main/java/okhttp3/guide/PostExample.java b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
index b6e70ccc7d..ddaacb6c5e 100644
--- a/samples/guide/src/main/java/okhttp3/guide/PostExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
@@ -8,8 +8,7 @@
 import okhttp3.Response;
 
 public class PostExample {
-  public static final MediaType JSON
-      = MediaType.parse("application/json; charset=utf-8");
+  public static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
 
   OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java b/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
index 644f638300..58a791adc7 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CancelCall.java
@@ -37,12 +37,10 @@ public void run() throws Exception {
     final Call call = client.newCall(request);
 
     // Schedule a job to cancel the call in 1 second.
-    executor.schedule(new Runnable() {
-      @Override public void run() {
-        System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f);
-        call.cancel();
-        System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f);
-      }
+    executor.schedule(() -> {
+      System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f);
+      call.cancel();
+      System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f);
     }, 1, TimeUnit.SECONDS);
 
     System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f);
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CurrentDateHeader.java b/samples/guide/src/main/java/okhttp3/recipes/CurrentDateHeader.java
new file mode 100644
index 0000000000..6c15d700df
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/CurrentDateHeader.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.util.Date;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class CurrentDateHeader {
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .addInterceptor(new CurrentDateInterceptor())
+      .build();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      System.out.println(response.request().header("Date"));
+    }
+  }
+
+  static class CurrentDateInterceptor implements Interceptor {
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+      Headers newHeaders = request.headers()
+          .newBuilder()
+          .add("Date", new Date())
+          .build();
+      Request newRequest = request.newBuilder()
+          .headers(newHeaders)
+          .build();
+      return chain.proceed(newRequest);
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CurrentDateHeader().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java b/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
index b568bdf01c..228956ec10 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
@@ -37,6 +37,8 @@
 import okhttp3.Request;
 import okhttp3.Response;
 
+import static java.util.Arrays.asList;
+
 public final class CustomCipherSuites {
   private final OkHttpClient client;
 
@@ -45,7 +47,7 @@ public CustomCipherSuites() throws GeneralSecurityException {
     // an OkHttp request. In order to be selected a cipher suite must be included in both OkHttp's
     // connection spec and in the SSLSocket's enabled cipher suites array. Most applications should
     // not customize the cipher suites list.
-    List<CipherSuite> customCipherSuites = Arrays.asList(
+    List<CipherSuite> customCipherSuites = asList(
         CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
         CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
         CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
diff --git a/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java b/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
new file mode 100644
index 0000000000..dd537f52b2
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.net.InetAddress;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
+
+/**
+ * Create an HTTPS server with a self-signed certificate that OkHttp trusts.
+ */
+public class HttpsServer {
+  public void run() throws Exception {
+    String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
+    HeldCertificate localhostCertificate = new HeldCertificate.Builder()
+        .addSubjectAlternativeName(localhost)
+        .build();
+
+    HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(localhostCertificate)
+        .build();
+    MockWebServer server = new MockWebServer();
+    server.useHttps(serverCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse());
+
+    HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(localhostCertificate.certificate())
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    System.out.println(response.handshake().tlsVersion());
+  }
+
+  public static void main(String... args) throws Exception {
+    new HttpsServer().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
index b216b24b3b..0e52cddd26 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
@@ -25,7 +25,7 @@
 
 public final class PostFile {
   public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
+      = MediaType.get("text/x-markdown; charset=utf-8");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
index 3e93a00e82..60534d7de2 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
@@ -30,7 +30,7 @@
    * these examples, please request your own client ID! https://api.imgur.com/oauth2
    */
   private static final String IMGUR_CLIENT_ID = "9199fdef135c122";
-  private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
+  private static final MediaType MEDIA_TYPE_PNG = MediaType.get("image/png");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
index 440c7768ea..90ec01c6b8 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
@@ -25,7 +25,7 @@
 
 public final class PostStreaming {
   public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
+      = MediaType.get("text/x-markdown; charset=utf-8");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
index b313ce0d1a..c73b9154ed 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
@@ -27,7 +27,7 @@
 
 public final class PostStreamingWithPipe {
   public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
+      = MediaType.get("text/x-markdown; charset=utf-8");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostString.java b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
index 8a312bde8a..6c8ea4f9e3 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostString.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
@@ -24,7 +24,7 @@
 
 public final class PostString {
   public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
+      = MediaType.get("text/x-markdown; charset=utf-8");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PreemptiveAuth.java b/samples/guide/src/main/java/okhttp3/recipes/PreemptiveAuth.java
new file mode 100644
index 0000000000..abbf0eb0c0
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PreemptiveAuth.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.Credentials;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+
+public final class PreemptiveAuth {
+  private final OkHttpClient client;
+
+  public PreemptiveAuth() {
+    client = new OkHttpClient.Builder()
+        .addInterceptor(
+            new BasicAuthInterceptor("publicobject.com", "jesse", "password1"))
+        .build();
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/secrets/hellosecret.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PreemptiveAuth().run();
+  }
+
+  static final class BasicAuthInterceptor implements Interceptor {
+    private final String credentials;
+    private final String host;
+
+    BasicAuthInterceptor(String host, String username, String password) {
+      this.credentials = Credentials.basic(username, password);
+      this.host = host;
+    }
+
+    @Override public Response intercept(Chain chain) throws IOException {
+      Request request = chain.request();
+      if (request.url().host().equals(host)) {
+        request = request.newBuilder()
+            .header("Authorization", credentials)
+            .build();
+      }
+      return chain.proceed(request);
+    }
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
index 1366a82f15..6c9f71279f 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
@@ -156,6 +156,10 @@ private void printEvent(String name) {
       printEvent("requestBodyEnd");
     }
 
+    @Override public void requestFailed(Call call, IOException ioe) {
+      printEvent("requestFailed");
+    }
+
     @Override public void responseHeadersStart(Call call) {
       printEvent("responseHeadersStart");
     }
@@ -172,6 +176,10 @@ private void printEvent(String name) {
       printEvent("responseBodyEnd");
     }
 
+    @Override public void responseFailed(Call call, IOException ioe) {
+      printEvent("responseFailed");
+    }
+
     @Override public void callEnd(Call call) {
       printEvent("callEnd");
     }
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
index 6acedb19e7..c88895b794 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
@@ -131,6 +131,10 @@ private void printEvent(String name) {
       printEvent("requestBodyEnd");
     }
 
+    @Override public void requestFailed(Call call, IOException ioe) {
+      printEvent("requestFailed");
+    }
+
     @Override public void responseHeadersStart(Call call) {
       printEvent("responseHeadersStart");
     }
@@ -147,6 +151,10 @@ private void printEvent(String name) {
       printEvent("responseBodyEnd");
     }
 
+    @Override public void responseFailed(Call call, IOException ioe) {
+      printEvent("responseFailed");
+    }
+
     @Override public void callEnd(Call call) {
       printEvent("callEnd");
     }
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Progress.java b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
index e75a3cc949..197401f205 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/Progress.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
@@ -16,7 +16,6 @@
 package okhttp3.recipes;
 
 import java.io.IOException;
-import okhttp3.Interceptor;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
@@ -61,13 +60,11 @@ public void run() throws Exception {
     };
 
     OkHttpClient client = new OkHttpClient.Builder()
-        .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            Response originalResponse = chain.proceed(chain.request());
-            return originalResponse.newBuilder()
-                .body(new ProgressResponseBody(originalResponse.body(), progressListener))
-                .build();
-          }
+        .addNetworkInterceptor(chain -> {
+          Response originalResponse = chain.proceed(chain.request());
+          return originalResponse.newBuilder()
+              .body(new ProgressResponseBody(originalResponse.body(), progressListener))
+              .build();
         })
         .build();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
index b1a62c0fa3..5473f67011 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
@@ -39,7 +39,7 @@
    * https://console.developers.google.com/project
    */
   public static final String GOOGLE_API_KEY = "AIzaSyAx2WZYe0My0i-uGurpvraYJxO7XNbwiGs";
-  public static final MediaType MEDIA_TYPE_JSON = MediaType.parse("application/json");
+  public static final MediaType MEDIA_TYPE_JSON = MediaType.get("application/json");
 
   private final OkHttpClient client = new OkHttpClient.Builder()
       .addInterceptor(new GzipRequestInterceptor())
diff --git a/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java b/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
index 92d65d8169..4d876bb201 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/RewriteResponseCacheControl.java
@@ -25,13 +25,11 @@
 
 public final class RewriteResponseCacheControl {
   /** Dangerous interceptor that rewrites the server's cache-control header. */
-  private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() {
-    @Override public Response intercept(Chain chain) throws IOException {
-      Response originalResponse = chain.proceed(chain.request());
-      return originalResponse.newBuilder()
-          .header("Cache-Control", "max-age=60")
-          .build();
-    }
+  private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = chain -> {
+    Response originalResponse = chain.proceed(chain.request());
+    return originalResponse.newBuilder()
+        .header("Cache-Control", "max-age=60")
+        .build();
   };
 
   private final OkHttpClient client;
diff --git a/samples/pom.xml b/samples/pom.xml
deleted file mode 100644
index 240093f1bb..0000000000
--- a/samples/pom.xml
+++ /dev/null
@@ -1,39 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.11.0-SNAPSHOT</version>
-  </parent>
-
-  <groupId>com.squareup.okhttp3.sample</groupId>
-  <artifactId>sample-parent</artifactId>
-  <packaging>pom</packaging>
-  <name>Samples (Parent)</name>
-
-  <modules>
-    <module>guide</module>
-    <module>crawler</module>
-    <module>simple-client</module>
-    <module>slack</module>
-    <module>static-server</module>
-  </modules>
-
-  <build>
-    <plugins>
-      <plugin>
-        <!-- Fails on Throwable.addSuppressed() in ARM blocks. -->
-        <groupId>org.codehaus.mojo</groupId>
-        <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <executions>
-          <execution>
-            <phase>none</phase>
-          </execution>
-        </executions>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/samples/simple-client/build.gradle b/samples/simple-client/build.gradle
new file mode 100644
index 0000000000..f47e38b46c
--- /dev/null
+++ b/samples/simple-client/build.gradle
@@ -0,0 +1,4 @@
+dependencies {
+  implementation project(':okhttp')
+  implementation deps.moshi
+}
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
deleted file mode 100644
index f278111319..0000000000
--- a/samples/simple-client/pom.xml
+++ /dev/null
@@ -1,27 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.11.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>simple-client</artifactId>
-  <name>Sample: Simple Client</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
index f2ac973db2..cfd8632cb8 100644
--- a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
+++ b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
@@ -4,7 +4,6 @@
 import com.squareup.moshi.Moshi;
 import com.squareup.moshi.Types;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.List;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
@@ -37,11 +36,7 @@ public static void main(String... args) throws Exception {
       List<Contributor> contributors = CONTRIBUTORS_JSON_ADAPTER.fromJson(body.source());
 
       // Sort list by the most contributions.
-      Collections.sort(contributors, new Comparator<Contributor>() {
-        @Override public int compare(Contributor c1, Contributor c2) {
-          return c2.contributions - c1.contributions;
-        }
-      });
+      Collections.sort(contributors, (c1, c2) -> c2.contributions - c1.contributions);
 
       // Output list of contributors.
       for (Contributor contributor : contributors) {
diff --git a/samples/slack/build.gradle b/samples/slack/build.gradle
new file mode 100644
index 0000000000..b47f85b5a4
--- /dev/null
+++ b/samples/slack/build.gradle
@@ -0,0 +1,4 @@
+dependencies {
+  implementation project(':mockwebserver')
+  implementation deps.moshi
+}
diff --git a/samples/slack/pom.xml b/samples/slack/pom.xml
deleted file mode 100644
index 271cdbfc71..0000000000
--- a/samples/slack/pom.xml
+++ /dev/null
@@ -1,26 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.11.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>slack</artifactId>
-  <name>Sample: Slack</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java b/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
index 04ba201c96..c0ad139aed 100644
--- a/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
+++ b/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
@@ -76,7 +76,7 @@ private HttpUrl redirectUrl() {
   }
 
   /** When the browser hits the redirect URL, use the provided code to ask Slack for a session. */
-  @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+  @Override public MockResponse dispatch(RecordedRequest request) {
     HttpUrl requestUrl = mockWebServer.url(request.getPath());
     String code = requestUrl.queryParameter("code");
     String stateString = requestUrl.queryParameter("state");
diff --git a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
index 0ec0ef7a45..4ab8565942 100644
--- a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
+++ b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
@@ -38,7 +38,7 @@
  * http://localhost:53203/oauth/}, passing the same port to this class‚Äô constructor.
  */
 public final class SlackApi {
-  private final HttpUrl baseUrl = HttpUrl.parse("https://slack.com/api/");
+  private final HttpUrl baseUrl = HttpUrl.get("https://slack.com/api/");
   private final OkHttpClient httpClient;
   private final Moshi moshi;
 
@@ -120,7 +120,7 @@ public WebSocket rtm(HttpUrl url, WebSocketListener listener) {
     @FromJson HttpUrl urlFromJson(String urlString) {
       if (urlString.startsWith("wss:")) urlString = "https:" + urlString.substring(4);
       if (urlString.startsWith("ws:")) urlString = "http:" + urlString.substring(3);
-      return HttpUrl.parse(urlString);
+      return HttpUrl.get(urlString);
     }
   }
 }
diff --git a/samples/slack/src/main/java/okhttp3/slack/SlackClient.java b/samples/slack/src/main/java/okhttp3/slack/SlackClient.java
index 2aa2608986..508a5fd467 100644
--- a/samples/slack/src/main/java/okhttp3/slack/SlackClient.java
+++ b/samples/slack/src/main/java/okhttp3/slack/SlackClient.java
@@ -39,13 +39,10 @@ public void requestOauthSession(String scopes, String team) throws Exception {
       sessionFactory.start();
     }
 
-    HttpUrl authorizeUrl = sessionFactory.newAuthorizeUrl(scopes, team,
-        new OAuthSessionFactory.Listener() {
-          @Override public void sessionGranted(OAuthSession session) {
-            initOauthSession(session);
-            System.out.printf("session granted: %s\n", session);
-          }
-        });
+    HttpUrl authorizeUrl = sessionFactory.newAuthorizeUrl(scopes, team, session -> {
+      initOauthSession(session);
+      System.out.printf("session granted: %s\n", session);
+    });
 
     System.out.printf("open this URL in a browser: %s\n", authorizeUrl);
   }
diff --git a/samples/static-server/build.gradle b/samples/static-server/build.gradle
new file mode 100644
index 0000000000..eb5f9e663c
--- /dev/null
+++ b/samples/static-server/build.gradle
@@ -0,0 +1,14 @@
+jar {
+  manifest {
+    attributes 'Main-Class': 'okhttp3.sample.SampleServer'
+  }
+}
+
+dependencies {
+  implementation project(':mockwebserver')
+}
+
+apply plugin: 'com.github.johnrengelman.shadow'
+shadowJar {
+  mergeServiceFiles()
+}
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
deleted file mode 100644
index 4fdd5fa7e4..0000000000
--- a/samples/static-server/pom.xml
+++ /dev/null
@@ -1,62 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3.sample</groupId>
-    <artifactId>sample-parent</artifactId>
-    <version>3.11.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>static-server</artifactId>
-  <name>Sample: Static Server</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-shade-plugin</artifactId>
-        <version>2.1</version>
-        <configuration>
-          <shadedArtifactAttached>true</shadedArtifactAttached>
-          <shadedClassifierName>shaded</shadedClassifierName>
-          <transformers>
-            <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
-              <manifestEntries>
-                <Main-Class>okhttp3.sample.SampleServer</Main-Class>
-              </manifestEntries>
-            </transformer>
-          </transformers>
-          <filters>
-            <filter>
-              <artifact>*:*</artifact>
-              <excludes>
-                <exclude>META-INF/*.SF</exclude>
-                <exclude>META-INF/*.DSA</exclude>
-                <exclude>META-INF/*.RSA</exclude>
-              </excludes>
-            </filter>
-          </filters>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>shade</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java b/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
index e21432ed20..88e0251bdb 100644
--- a/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
+++ b/samples/static-server/src/main/java/okhttp3/sample/SampleServer.java
@@ -11,7 +11,6 @@
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.TrustManagerFactory;
-import okhttp3.internal.Util;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -119,11 +118,8 @@ public static void main(String[] args) throws Exception {
   private static SSLContext sslContext(String keystoreFile, String password)
       throws GeneralSecurityException, IOException {
     KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
-    InputStream in = new FileInputStream(keystoreFile);
-    try {
+    try (InputStream in = new FileInputStream(keystoreFile)) {
       keystore.load(in, password.toCharArray());
-    } finally {
-      Util.closeQuietly(in);
     }
     KeyManagerFactory keyManagerFactory =
         KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
diff --git a/samples/unixdomainsockets/build.gradle b/samples/unixdomainsockets/build.gradle
new file mode 100644
index 0000000000..ea86233a50
--- /dev/null
+++ b/samples/unixdomainsockets/build.gradle
@@ -0,0 +1,5 @@
+dependencies {
+  implementation project(':okhttp')
+  implementation project(':mockwebserver')
+  implementation deps.jnrUnixsocket
+}
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java
new file mode 100644
index 0000000000..f897565f52
--- /dev/null
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.unixdomainsockets;
+
+import java.io.File;
+import java.util.Collections;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+/**
+ * Create UNIX domain sockets for MockWebServer and OkHttp and connect 'em together. Note that we
+ * cannot do TLS over domain sockets.
+ */
+public class ClientAndServer {
+  public void run() throws Exception {
+    File socketFile = new File("/tmp/ClientAndServer.sock");
+    socketFile.delete(); // Clean up from previous runs.
+
+    MockWebServer server = new MockWebServer();
+    server.setServerSocketFactory(new UnixDomainServerSocketFactory(socketFile));
+    server.setProtocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE));
+    server.enqueue(new MockResponse().setBody("hello"));
+    server.start();
+
+    OkHttpClient client = new OkHttpClient.Builder()
+        .socketFactory(new UnixDomainSocketFactory(socketFile))
+        .protocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE))
+        .build();
+
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      System.out.println(response.body().string());
+    }
+
+    server.shutdown();
+    socketFile.delete();
+  }
+
+  public static void main(String... args) throws Exception {
+    new ClientAndServer().run();
+  }
+}
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/TunnelingUnixSocket.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/TunnelingUnixSocket.java
new file mode 100644
index 0000000000..678e04d4f7
--- /dev/null
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/TunnelingUnixSocket.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.unixdomainsockets;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import jnr.unixsocket.UnixSocket;
+import jnr.unixsocket.UnixSocketAddress;
+import jnr.unixsocket.UnixSocketChannel;
+
+/**
+ * Subtype UNIX socket for a higher-fidelity impersonation of TCP sockets. This is named "tunneling"
+ * because it assumes the ultimate destination has a hostname and port.
+ */
+final class TunnelingUnixSocket extends UnixSocket {
+  private final File path;
+  private InetSocketAddress inetSocketAddress;
+
+  TunnelingUnixSocket(File path, UnixSocketChannel channel) {
+    super(channel);
+    this.path = path;
+  }
+
+  TunnelingUnixSocket(File path, UnixSocketChannel channel, InetSocketAddress address) {
+    this(path, channel);
+    this.inetSocketAddress = address;
+  }
+
+  @Override public void connect(SocketAddress endpoint) throws IOException {
+    this.inetSocketAddress = (InetSocketAddress) endpoint;
+    super.connect(new UnixSocketAddress(path), 0);
+  }
+
+  @Override public void connect(SocketAddress endpoint, int timeout) throws IOException {
+    this.inetSocketAddress = (InetSocketAddress) endpoint;
+    super.connect(new UnixSocketAddress(path), timeout);
+  }
+
+  @Override public InetAddress getInetAddress() {
+    return inetSocketAddress.getAddress();
+  }
+}
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java
new file mode 100644
index 0000000000..a96649e425
--- /dev/null
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.unixdomainsockets;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketAddress;
+import java.net.SocketException;
+import java.nio.channels.ClosedChannelException;
+import javax.net.ServerSocketFactory;
+import jnr.unixsocket.UnixServerSocketChannel;
+import jnr.unixsocket.UnixSocketAddress;
+import jnr.unixsocket.UnixSocketChannel;
+
+/** Impersonate TCP-style ServerSocketFactory over UNIX domain sockets. */
+public final class UnixDomainServerSocketFactory extends ServerSocketFactory {
+  private final File path;
+
+  public UnixDomainServerSocketFactory(File path) {
+    this.path = path;
+  }
+
+  @Override public ServerSocket createServerSocket() throws IOException {
+    return new UnixDomainServerSocket();
+  }
+
+  @Override public ServerSocket createServerSocket(int port) throws IOException {
+    return createServerSocket();
+  }
+
+  @Override public ServerSocket createServerSocket(int port, int backlog) throws IOException {
+    return createServerSocket();
+  }
+
+  @Override public ServerSocket createServerSocket(
+      int port, int backlog, InetAddress inetAddress) throws IOException {
+    return createServerSocket();
+  }
+
+  final class UnixDomainServerSocket extends ServerSocket {
+    private UnixServerSocketChannel serverSocketChannel;
+    private InetSocketAddress endpoint;
+
+    UnixDomainServerSocket() throws IOException {
+    }
+
+    @Override public void bind(SocketAddress endpoint, int backlog) throws IOException {
+      this.endpoint = (InetSocketAddress) endpoint;
+
+      UnixSocketAddress address = new UnixSocketAddress(path);
+      serverSocketChannel = UnixServerSocketChannel.open();
+      serverSocketChannel.configureBlocking(true);
+      serverSocketChannel.socket().bind(address);
+    }
+
+    @Override public int getLocalPort() {
+      return 1; // A white lie. There is no local port.
+    }
+
+    @Override public SocketAddress getLocalSocketAddress() {
+      return endpoint;
+    }
+
+    @Override public Socket accept() throws IOException {
+      try {
+        UnixSocketChannel channel = serverSocketChannel.accept();
+        return new TunnelingUnixSocket(path, channel, endpoint);
+      } catch (ClosedChannelException e) {
+        SocketException exception = new SocketException();
+        exception.initCause(e);
+        throw exception;
+      }
+    }
+
+    @Override public void close() throws IOException {
+      serverSocketChannel.close();
+    }
+  }
+}
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java
new file mode 100644
index 0000000000..fc1c8e05a6
--- /dev/null
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.unixdomainsockets;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import javax.net.SocketFactory;
+import jnr.unixsocket.UnixSocketChannel;
+
+/** Impersonate TCP-style SocketFactory over UNIX domain sockets. */
+public final class UnixDomainSocketFactory extends SocketFactory {
+  private final File path;
+
+  public UnixDomainSocketFactory(File path) {
+    this.path = path;
+  }
+
+  @Override public Socket createSocket() throws IOException {
+    UnixSocketChannel channel = UnixSocketChannel.open();
+    return new TunnelingUnixSocket(path, channel);
+  }
+
+  @Override public Socket createSocket(String host, int port) throws IOException {
+    Socket result = createSocket();
+    result.connect(new InetSocketAddress(host, port));
+    return result;
+  }
+
+  @Override public Socket createSocket(
+      String host, int port, InetAddress localHost, int localPort) throws IOException {
+    return createSocket(host, port);
+  }
+
+  @Override public Socket createSocket(InetAddress host, int port) throws IOException {
+    Socket result = createSocket();
+    result.connect(new InetSocketAddress(host, port));
+    return result;
+  }
+
+  @Override public Socket createSocket(
+      InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException {
+    return createSocket(host, port);
+  }
+}
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 0000000000..367bee6364
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1,16 @@
+include ':mockwebserver'
+include ':okcurl'
+include ':okhttp'
+include ':okhttp-dnsoverhttps'
+include ':okhttp-hpacktests'
+include ':okhttp-logging-interceptor'
+include ':okhttp-sse'
+include ':okhttp-testing-support'
+include ':okhttp-tls'
+include ':okhttp-urlconnection'
+include ':samples:crawler'
+include ':samples:guide'
+include ':samples:simple-client'
+include ':samples:slack'
+include ':samples:static-server'
+include ':samples:unixdomainsockets'
diff --git a/website/index.html b/website/index.html
index 184ee69ce0..02c69c6c9c 100644
--- a/website/index.html
+++ b/website/index.html
@@ -27,6 +27,7 @@ <h1>OkHttp</h1>
               </ul>
             </menu>
           </div>
+        </div>
       </div>
     </header>
     <section id="subtitle">
@@ -57,15 +58,15 @@ <h3 id="overview">Overview</h3>
             <p>OkHttp perseveres when the network is troublesome: it will silently recover from
                 common connection problems. If your service has multiple IP addresses OkHttp will
                 attempt alternate addresses if the first connect fails. This is necessary for IPv4+IPv6
-                and for services hosted in redundant data centers. OkHttp initiates new connections
-                with modern TLS features (SNI, ALPN), and falls back to TLS 1.0 if the handshake
-                fails.</p>
+                and for services hosted in redundant data centers. OkHttp supports modern TLS
+                features (TLS 1.3, ALPN, certificate pinning). It can be configured to fall back for
+                broad connectivity.</p>
 
             <p>Using OkHttp is easy. Its request/response API is designed with fluent builders and
                 immutability. It supports both synchronous blocking calls and async calls with
                 callbacks.</p>
 
-            <p>OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.</p>
+            <p>OkHttp supports Android 5.0+ (API level 21+) and Java 8+.</p>
 
             <h3 id="examples">Examples</h3>
             <h4>Get a URL</h4>
@@ -88,7 +89,7 @@ <h4>Post to a Server</h4>
 
 <pre class="prettyprint">
 public static final MediaType JSON
-    = MediaType.parse("application/json; charset=utf-8");
+    = MediaType.get("application/json; charset=utf-8");
 
 OkHttpClient client = new OkHttpClient();
 
@@ -119,11 +120,21 @@ <h4>Maven</h4>
 &lt;/dependency></pre>
 
             <h4>Gradle</h4>
-            <pre class="prettyprint">compile 'com.squareup.okhttp3:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
+            <pre class="prettyprint">implementation 'com.squareup.okhttp3:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
 
             <h3 id="contributing">Contributing</h3>
             <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
-            <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
+            <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>./gradlew check</code>.</p>
+
+            <p>Some general advice</p>
+            <ul>
+                <li>Don‚Äôt change public API lightly, avoid if possible, and include your reasoning in the PR if essential. It causes pain for developers who use OkHttp and sometimes runtime errors.</li>
+                <li>Favour a working external library if appropriate. There are many examples of OkHttp libraries that can sit on top or hook in via existing APIs.</li>
+                <li>Get working code on a personal branch with tests before you submit a PR.</li>
+                <li>OkHttp is a small and light dependency. Don't introduce new dependencies or major new functionality.</li>
+                <li>OkHttp targets the intersection of RFC correct and widely implemented. Incorrect implementations that are very widely implemented e.g. a bug in Apache, Nginx, Google, Firefox should also be handled.</li>
+            </ul>
+
             <p>Before your code can be accepted into the project you must also sign the <a href="https://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
 
             <h3 id="license">License</h3>
